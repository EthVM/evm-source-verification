{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/LPFarm.sol": {
      "content": "// hevm: flattened sources of src/lp-farm.sol\npragma solidity >0.4.13 >=0.4.23 >=0.5.0 >=0.6.0 <0.7.0 >=0.6.2 <0.7.0 >=0.6.7 <0.7.0;\n\n////// lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-token/src/token.sol\n/// token.sol -- ERC20 implementation with minting and burning\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"ds-math/math.sol\"; */\n/* import \"ds-auth/auth.sol\"; */\n\n\ncontract DSToken is DSMath, DSAuth {\n    bool                                              public  stopped;\n    uint256                                           public  totalSupply;\n    mapping (address => uint256)                      public  balanceOf;\n    mapping (address => mapping (address => uint256)) public  allowance;\n    bytes32                                           public  symbol;\n    uint256                                           public  decimals = 18; // standard token precision. override to customize\n    bytes32                                           public  name = \"\";     // Optional token name\n\n    constructor(bytes32 symbol_) public {\n        symbol = symbol_;\n    }\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n    event Mint(address indexed guy, uint wad);\n    event Burn(address indexed guy, uint wad);\n    event Stop();\n    event Start();\n\n    modifier stoppable {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n\n    function approve(address guy) external returns (bool) {\n        return approve(guy, uint(-1));\n    }\n\n    function approve(address guy, uint wad) public stoppable returns (bool) {\n        allowance[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        stoppable\n        returns (bool)\n    {\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        }\n\n        require(balanceOf[src] >= wad, \"ds-token-insufficient-balance\");\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) external {\n        transferFrom(msg.sender, dst, wad);\n    }\n\n    function pull(address src, uint wad) external {\n        transferFrom(src, msg.sender, wad);\n    }\n\n    function move(address src, address dst, uint wad) external {\n        transferFrom(src, dst, wad);\n    }\n\n\n    function mint(uint wad) external {\n        mint(msg.sender, wad);\n    }\n\n    function burn(uint wad) external {\n        burn(msg.sender, wad);\n    }\n\n    function mint(address guy, uint wad) public auth stoppable {\n        balanceOf[guy] = add(balanceOf[guy], wad);\n        totalSupply = add(totalSupply, wad);\n        emit Mint(guy, wad);\n    }\n\n    function burn(address guy, uint wad) public auth stoppable {\n        if (guy != msg.sender && allowance[guy][msg.sender] != uint(-1)) {\n            require(allowance[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\n        }\n\n        require(balanceOf[guy] >= wad, \"ds-token-insufficient-balance\");\n        balanceOf[guy] = sub(balanceOf[guy], wad);\n        totalSupply = sub(totalSupply, wad);\n        emit Burn(guy, wad);\n    }\n\n    function stop() public auth {\n        stopped = true;\n        emit Stop();\n    }\n\n    function start() public auth {\n        stopped = false;\n        emit Start();\n    }\n\n    function setName(bytes32 name_) external auth {\n        name = name_;\n    }\n}\n\n////// src/constants.sol\n/* pragma solidity ^0.6.7; */\n\n\nlibrary Constants {\n    // Tokens\n    address constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant SUSHI = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n    address constant UNIV2_SUSHI_ETH = 0xCE84867c3c02B05dc570d0135103d3fB9CC19433;\n    address constant UNIV2_SNX_ETH = 0x43AE24960e5534731Fc831386c07755A2dc33D47;\n\n    // Uniswap\n    address constant UNIV2_ROUTER2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    // Sushiswap\n    address constant MASTERCHEF = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;\n}\n////// src/interfaces/masterchef.sol\n// SPDX-License-Identifier: MIT\n/* pragma solidity ^0.6.2; */\n\ninterface Masterchef {\n    function deposit(uint256 _pid, uint256 _amount) external;\n\n    function withdraw(uint256 _pid, uint256 _amount) external;\n\n    function pendingSushi(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256);\n\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address lpToken,\n            uint256 allocPoint,\n            uint256 lastRewardBlock,\n            uint256 accSushiPerShare\n        );\n\n    function userInfo(uint256, address)\n        external\n        view\n        returns (uint256 amount, uint256 rewardDebt);\n\n    function updatePool(uint256 _pid) external;\n}\n\n////// src/interfaces/uniswap.sol\n// SPDX-License-Identifier: MIT\n/* pragma solidity ^0.6.2; */\n\ninterface UniswapRouterV2 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n}\n\ninterface UniswapPair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestamp\n        );\n}\n\n////// src/safe-math.sol\n// SPDX-License-Identifier: MIT\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n\n/* pragma solidity ^0.6.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n////// src/lp-farm.sol\n/* pragma solidity ^0.6.7; */\n\n/* import \"ds-token/token.sol\"; */\n\n/* import \"./interfaces/masterchef.sol\"; */\n/* import \"./interfaces/uniswap.sol\"; */\n\n/* import \"./safe-math.sol\"; */\n/* import \"./constants.sol\"; */\n\n// Liquidity Provider Farming for SushiSwap\n// Used to farm LP Tokens.\n\n// Based off https://github.com/iearn-finance/vaults/blob/master/contracts/yVault.sol\n\ncontract LPFarm {\n    using SafeMath for uint256;\n\n    // Tokens\n    DSToken public sushi = DSToken(Constants.SUSHI);\n    DSToken public snx = DSToken(Constants.SNX);\n    DSToken public weth = DSToken(Constants.WETH);\n    DSToken public lpToken = DSToken(Constants.UNIV2_SNX_ETH);\n    DSToken public degenLpToken;\n\n    // Uniswap Router and Pair\n    UniswapRouterV2 public univ2 = UniswapRouterV2(Constants.UNIV2_ROUTER2);\n    UniswapPair public univ2Pair = UniswapPair(address(lpToken));\n\n    // Masterchef Contract\n    Masterchef public masterchef = Masterchef(Constants.MASTERCHEF);\n    uint256 public poolId = 6;\n\n    // 5% harvester rewards\n    // 2.5% to dev\n    // 2.5% to harvester\n    uint256 public maxharvesterRewards = 5 ether;\n    address public dev = 0xAbcCB8f0a3c206Bb0468C52CCc20f3b81077417B;\n\n\n    constructor() public {\n        degenLpToken = new DSToken(\"dUNI-V2\");\n        degenLpToken.setName(\"Degen UNI-V2\");\n    }\n\n    // **** Harvest profits ****\n\n    function harvestAndWithdrawAll() external {\n        harvest();\n        withdrawAll();\n    }\n\n    function harvest() public {\n        // Get rewards\n        masterchef.withdraw(poolId, 0);\n\n        uint256 sushiBal = sushi.balanceOf(address(this));\n        require(sushiBal > 0, \"no-sushi\");\n\n        // Converts 1/2 to ETH, 1/2 to SNX\n        // Add to liquidity pool\n        uint256 _before = getLpTokenBalance();\n        _convertSushiToLp(sushiBal);\n        uint256 _after = getLpTokenBalance();\n\n        uint256 _amount = _after.sub(_before);\n\n        // Caller gets 2.5%, Dev gets 2.5%\n        uint256 _rewards = _amount.mul(maxharvesterRewards).div(100 ether);\n        lpToken.transfer(dev, _rewards.div(2));\n        lpToken.transfer(msg.sender, _rewards.div(2));\n\n        // Deposit to SNX/ETH pool\n        _amount = lpToken.balanceOf(address(this));\n        lpToken.approve(address(masterchef), _amount);\n        masterchef.deposit(poolId, _amount);\n    }\n\n    function _convertSushiToLp(uint256 _amount) internal {\n        // SUSHI -> WETH\n        address[] memory wethPath = new address[](2);\n        wethPath[0] = address(sushi);\n        wethPath[1] = address(weth);\n        sushi.approve(address(univ2), _amount);\n        univ2.swapExactTokensForTokens(\n            _amount,\n            0,\n            wethPath,\n            address(this),\n            now + 60\n        );\n\n        // 1/2 of WETH\n        // WETH -> SNX\n        uint256 wethHalf = weth.balanceOf(address(this)).div(2);\n        address[] memory snxPath = new address[](2);\n        snxPath[0] = address(weth);\n        snxPath[1] = address(snx);\n        weth.approve(address(univ2), wethHalf);\n        univ2.swapExactTokensForTokens(\n            wethHalf,\n            0,\n            snxPath,\n            address(this),\n            now + 60\n        );\n\n        // Add liquidity\n        uint256 snxBal = snx.balanceOf(address(this));\n        uint256 wethBal = weth.balanceOf(address(this));\n        snx.approve(address(univ2), snxBal);\n        weth.approve(address(univ2), wethBal);\n        univ2.addLiquidity(\n            address(snx),\n            address(weth),\n            snxBal,\n            wethBal,\n            0,\n            0,\n            address(this),\n            now + 60\n        );\n    }\n\n    // **** Withdraw / Deposit functions ****\n\n    function withdrawAll() public {\n        withdraw(degenLpToken.balanceOf(msg.sender));\n    }\n\n    function withdraw(uint256 _shares) public {\n        // Calculate amount to withdraw\n        uint256 _amount = getLpTokenBalance()\n            .div(degenLpToken.totalSupply())\n            .mul(_shares);\n\n        degenLpToken.burn(msg.sender, _shares);\n\n        // Withdraw tokens\n        masterchef.withdraw(poolId, _amount);\n\n        // Send back to user\n        lpToken.transfer(msg.sender, _amount);\n    }\n\n    function depositAll() public {\n        deposit(lpToken.balanceOf(msg.sender));\n    }\n\n    function deposit(uint256 _amount) public {\n        uint256 _lpBal = getLpTokenBalance();\n        uint256 _before = lpToken.balanceOf(address(this));\n        lpToken.transferFrom(msg.sender, address(this), _amount);\n        uint256 _after = lpToken.balanceOf(address(this));\n\n        uint256 _obtained = _after.sub(_before);\n        uint256 _shares = 0;\n        uint256 _degenSupply = degenLpToken.totalSupply();\n\n        if (_degenSupply == 0) {\n            _shares = _obtained;\n        } else {\n            _shares = _obtained.mul(_degenSupply).div(_lpBal);\n        }\n\n        // Stake coins\n        lpToken.approve(address(masterchef), _amount);\n        masterchef.deposit(poolId, _obtained);\n\n        degenLpToken.mint(msg.sender, _shares);\n    }\n\n    function getRatioPerShare() public view returns (uint256) {\n        if (degenLpToken.totalSupply() == 0) {\n            return 0;\n        }\n        \n        return getLpTokenBalance().mul(1e18).div(degenLpToken.totalSupply());\n    }\n\n    function getLpTokenBalance() public view returns (uint256) {\n        (uint256 stakedBal, ) = masterchef.userInfo(poolId, address(this));\n\n        uint256 holdingBal = lpToken.balanceOf(address(this));\n\n        return stakedBal.add(holdingBal);\n    }\n}\n"
    }
  }
}