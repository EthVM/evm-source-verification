{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":54088},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ImpermanentGain.sol":{"content":"pragma solidity 0.5.17;\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) \n            return 0;\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        uint256 z = add(x >> 1, 1);\n        uint256 y = x;\n        while (z < y)\n        {\n            y = z;\n            z = ((add((x / z), z)) / 2);\n        }\n        return y;\n    }\n}\n\ncontract ERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowed;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    uint256 internal _totalSupply;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return A uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param owner address The address which owns the funds.\n    * @param spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n    * @dev Transfer token to a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param spender The address which will spend the funds.\n    * @param value The amount of tokens to be spent.\n    */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n    * @dev Transfer tokens from one address to another.\n    * Note that while this function emits an Approval event, this is not required as per the specification,\n    * and other compliant implementations may not emit the event.\n    * @param from address The address which you want to send tokens from\n    * @param to address The address which you want to transfer to\n    * @param value uint256 the amount of tokens to be transferred\n    */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        if (from != msg.sender && _allowed[from][msg.sender] != uint256(-1))\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n}\n\ncontract ERC20Mintable is ERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    function _mint(address to, uint256 amount) internal {\n        _balances[to] = _balances[to].add(amount);\n        _totalSupply = _totalSupply.add(amount);\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        _balances[from] = _balances[from].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(from, address(0), amount);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract Oracle {\n    function latestAnswer() external view returns (int256);\n}\n\ncontract ImpermanentGain is ERC20Mintable {\n    using SafeMath for *;\n    using SafeERC20 for IERC20;\n\n    bool public canBuy;\n\n    address public treasury;\n    address public baseToken;\n    Oracle public oracle;\n\n    uint256 public openTime;\n    uint256 public closeTime;\n\n    uint256 public openPrice;\n    uint256 public closePrice;\n\n    uint256 public constant leverage = 10;\n    uint256 public constant protocolFee = 100;\n\n    // a + b = $1\n    // b = tokenized put of impermanent loss\n    // a = 1 - b\n    uint256 public bPrice;\n\n    uint256 public poolA;\n    uint256 public poolB;\n\n    mapping(address => uint256) public a;\n    mapping(address => uint256) public b;\n\n    event Mint(address indexed minter, uint256 amount);\n    event Burn(address indexed burner, uint256 amount);\n    event Swap(address indexed user, bool indexed a2b, uint256 input, uint256 output);\n    event AddLP(address indexed provider, uint256 a, uint256 b, uint256 lp);\n    event RemoveLP(address indexed provider, uint256 a, uint256 b, uint256 lp);\n\n    function init(address _baseToken, address _oracle, address _treasury, uint256 _duration, uint256 _a, uint256 _b) public {\n        require(openTime == 0, \"Initialized\");\n        require(_a > 0 && _b > 0, \"No initial liquidity\");\n        baseToken = _baseToken;\n        oracle = Oracle(_oracle);\n        treasury = _treasury;\n        openTime = now;\n        closeTime = now.add(_duration);\n        openPrice = uint256(oracle.latestAnswer());\n\n        canBuy = true;\n\n        name = \"iGain LP token\";\n        symbol = \"iGLP\";\n        decimals = 18;\n\n        uint256 _lp = _a.mul(_b).sqrt();\n        poolA = _a;\n        poolB = _b;\n        _mint(msg.sender, _lp);\n        if(_b > _a) {\n            a[msg.sender] = _b.sub(_a);\n            doTransferIn(baseToken, msg.sender, _b);\n        }\n        else {\n            b[msg.sender] = _a.sub(_b);\n            doTransferIn(baseToken, msg.sender, _a);\n        }\n        emit AddLP(msg.sender, _lp, _a, _b);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n\n    /***********************************|\n    |          mint/burn token          |\n    |__________________________________*/\n\n    // pay `amount` baseToken, get the same amount of a and b\n    function mint(uint256 amount) external {\n        require(canBuy, \"cannot buy\");\n        a[msg.sender] = a[msg.sender].add(amount);\n        b[msg.sender] = b[msg.sender].add(amount);\n        doTransferIn(baseToken, msg.sender, amount);\n    }\n\n    // burn `amount` of a and b, get `amount` baseToken \n    function burn(uint256 amount) external {\n        require(canBuy, \"cannot buy\");\n        a[msg.sender] = a[msg.sender].sub(amount);\n        b[msg.sender] = b[msg.sender].sub(amount);\n        doTransferOut(baseToken, msg.sender, amount);\n    }\n\n    // pay `amount` baseToken, get more that `min_a` of a\n    function mintA(uint256 amount, uint256 min_a) external returns (uint256 _a) {\n        require(canBuy, \"cannot buy\");\n        _a = getAmountOut(amount, poolB, poolA);\n        poolB = poolB.add(amount);\n        poolA = poolA.sub(_a);\n        emit Swap(msg.sender, false, amount, _a);\n        _a = _a.add(amount);\n        require(_a >= min_a, \"SLIPPAGE_DETECTED\");\n        a[msg.sender] = a[msg.sender].add(_a);\n        doTransferIn(baseToken, msg.sender, amount);\n    }\n\n    // burn no more than `max_a` of a, receive `amount` baseToken\n    function burnA(uint256 amount, uint256 max_a) external returns (uint256 _a) {\n        require(canBuy, \"cannot buy\");\n        _a = getAmountIn(amount, poolA, poolB);\n        poolB = poolB.sub(amount);\n        poolA = poolA.add(_a);\n        emit Swap(msg.sender, true, _a, amount);\n        _a = _a.add(amount);\n        require(_a <= max_a, \"SLIPPAGE_DETECTED\");\n        a[msg.sender] = a[msg.sender].sub(_a);\n        doTransferOut(baseToken, msg.sender, amount);\n    }\n\n    // pay `amount` baseToken, get more that `min_b` of b\n    function mintB(uint256 amount, uint256 min_b) external returns (uint256 _b) {\n        require(canBuy, \"cannot buy\");\n        _b = getAmountOut(amount, poolA, poolB);\n        poolA = poolA.add(amount);\n        poolB = poolB.sub(_b);\n        emit Swap(msg.sender, true, amount, _b);\n        _b = _b.add(amount);\n        require(_b >= min_b, \"SLIPPAGE_DETECTED\");\n        b[msg.sender] = b[msg.sender].add(_b);\n        doTransferIn(baseToken, msg.sender, amount);\n    }\n\n    // burn no more than `max_b` of b, receive `amount` baseToken\n    function burnB(uint256 amount, uint256 max_b) external returns (uint256 _b) {\n        require(canBuy, \"cannot buy\");\n        _b = getAmountIn(amount, poolB, poolA);\n        poolA = poolA.sub(amount);\n        poolB = poolB.add(_b);\n        emit Swap(msg.sender, false, _b, amount);\n        _b = _b.add(amount);\n        require(_b <= max_b, \"SLIPPAGE_DETECTED\");\n        b[msg.sender] = b[msg.sender].sub(_b);\n        doTransferOut(baseToken, msg.sender, amount);\n    }\n\n    // pay `amount` baseToken, get more than `min_lp` liquidity provider share\n    function mintLP(uint256 amount, uint256 min_lp) external returns (uint256 _lp) {\n        require(canBuy, \"cannot buy\");\n        uint256 k = poolA.mul(poolB);\n        uint256 _k = poolA.add(amount).mul(poolB.add(amount));\n\n        // ( sqrt(_k/k) - 1 ) * LP\n        _lp = _k.mul(1e36).div(k).sqrt().sub(1e18).mul(_totalSupply).div(1e18);\n        _lp = _lp.mul(997).div(1000); //fee\n\n        require(_lp >= min_lp, \"SLIPPAGE_DETECTED\");\n        poolA = poolA.add(amount);\n        poolB = poolB.add(amount);\n        _mint(msg.sender, _lp);\n        doTransferIn(baseToken, msg.sender, amount);\n        emit AddLP(msg.sender, _lp, amount, amount);\n    }\n\n    // burn no more than `min_lp` liquidity provider share, receive `amount` baseToken\n    function burnLP(uint256 amount, uint256 max_lp) external returns (uint256 _lp) {\n        require(canBuy, \"cannot buy\");\n        uint256 k = poolA.mul(poolB);\n        uint256 _k = poolA.sub(amount).mul(poolB.sub(amount));\n\n        // ( 1 - sqrt(_k/k) ) * LP\n        _lp = (1e18).sub(_k.mul(1e36).div(k).sqrt()).mul(_totalSupply).div(1e18);\n        _lp = _lp.mul(1000).div(997); //fee\n\n        require(_lp <= max_lp, \"SLIPPAGE_DETECTED\");\n        poolA = poolA.sub(amount);\n        poolB = poolB.sub(amount);\n        _burn(msg.sender, _lp);\n        doTransferOut(baseToken, msg.sender, amount);\n        emit RemoveLP(msg.sender, _lp, amount, amount);\n    }\n\n\n    /***********************************|\n    |               swap                |\n    |__________________________________*/\n\n    function swapAtoB(uint256 _a, uint256 min_b) external returns (uint256 _b) {\n        require(canBuy, \"cannot buy\");\n        _b = getAmountOut(_a, poolA, poolB);\n        require(_b >= min_b, \"SLIPPAGE_DETECTED\");\n        poolA = poolA.add(_a);\n        poolB = poolB.sub(_b);\n        a[msg.sender] = a[msg.sender].sub(_a);\n        b[msg.sender] = b[msg.sender].add(_b);\n        emit Swap(msg.sender, true, _a, _b);\n    }\n\n    function swapBtoA(uint256 _b, uint256 min_a) external returns (uint256 _a) {\n        require(canBuy, \"cannot buy\");\n        _a = getAmountOut(_b, poolB, poolA);\n        require(_a >= min_a, \"SLIPPAGE_DETECTED\");\n        poolB = poolB.add(_b);\n        poolA = poolA.sub(_a);\n        b[msg.sender] = b[msg.sender].sub(_b);\n        a[msg.sender] = a[msg.sender].add(_a);\n        emit Swap(msg.sender, false, _b, _a);\n    }\n\n\n    /***********************************|\n    |       add/remove liquidity        |\n    |__________________________________*/\n\n    // deposit `_a` of a and `_b` of b, get more than `min_lp` of liquidity provider share\n    function depositLP(uint256 _a, uint256 _b, uint256 min_lp) external returns (uint256 _lp) {\n        require(canBuy, \"cannot buy\");\n        uint256 k = poolA.mul(poolB);\n        uint256 _k = poolA.add(_a).mul(poolB.add(_b));\n\n        // ( sqrt(_k/k) - 1 ) * LP\n        _lp = _k.mul(1e36).div(k).sqrt().sub(1e18).mul(_totalSupply).div(1e18);\n        _lp = _lp.mul(997).div(1000); //fee\n\n        require(_lp >= min_lp, \"SLIPPAGE_DETECTED\");\n        poolA = poolA.add(_a);\n        poolB = poolB.add(_b);\n        a[msg.sender] = a[msg.sender].sub(_a);\n        b[msg.sender] = b[msg.sender].sub(_b);\n        _mint(msg.sender, _lp);\n        emit AddLP(msg.sender, _lp, _a, _b);\n    }\n\n    // burn no more than `max_lp` of liquidity provider share, withdraw `_a` of a and `_b` of b\n    function withdrawLP(uint256 _a, uint256 _b, uint256 max_lp) external returns (uint256 _lp) {\n        require(canBuy, \"cannot buy\");\n        uint256 k = poolA.mul(poolB);\n        uint256 _k = poolA.sub(_a).mul(poolB.sub(_b));\n\n        // ( 1 - sqrt(_k/k) ) * LP\n        _lp = (1e18).sub(_k.mul(1e36).div(k).sqrt()).mul(_totalSupply).div(1e18);\n        _lp = _lp.mul(1000).div(997); //fee\n\n        require(_lp <= max_lp, \"SLIPPAGE_DETECTED\");\n        poolA = poolA.sub(_a);\n        poolB = poolB.sub(_b);\n        a[msg.sender] = a[msg.sender].add(_a);\n        b[msg.sender] = b[msg.sender].add(_b);\n        _burn(msg.sender, _lp);\n        emit RemoveLP(msg.sender, _lp, _a, _b);\n    }\n\n\n    /***********************************|\n    |             settlement            |\n    |__________________________________*/\n\n    // can only call once after closeTime\n    // get price from oracle and calculate IL\n    function close() external {\n        require(now >= closeTime, \"Not yet\");\n        require(canBuy, \"Closed\");\n        canBuy = false;\n        closePrice = uint256(oracle.latestAnswer());\n        uint256 ratio = openPrice.mul(1e18).div(closePrice);\n        uint256 _bPrice = calcIL(ratio).mul(leverage); //leverage\n        bPrice = _bPrice > 1e18 ? 1e18 : _bPrice;\n    }\n\n    function calcIL(uint256 ratio) public pure returns (uint256) {\n        // 1 - sqrt(ratio) * 2 / (1 + ratio)\n        return (1e18).sub(ratio.mul(1e18).sqrt().mul(2e18).div(ratio.add(1e18)));\n    }\n\n    // burn a, b, and lp and receive baseToken\n    function claim() external returns (uint256 amount) {\n        require(!canBuy, \"Not yet\");\n\n        uint256 _lp = _balances[msg.sender];\n        uint256 _a;\n        uint256 _b;\n\n        if(_lp > 0) {\n            _a = poolA.mul(_lp).div(_totalSupply);   \n            _b = poolB.mul(_lp).div(_totalSupply);\n\n            poolA = poolA.sub(_a);\n            poolB = poolB.sub(_b);\n            _burn(msg.sender, _lp);\n            emit RemoveLP(msg.sender, _lp, _a, _b);\n        }\n\n        _a = _a.add(a[msg.sender]);\n        _b = _b.add(b[msg.sender]);\n        a[msg.sender] = 0;\n        b[msg.sender] = 0;\n\n        amount = _a.mul((1e18).sub(bPrice)).add(_b.mul(bPrice)).div(1e18);\n        doTransferOut(baseToken, msg.sender, amount);\n    }\n\n\n    /***********************************|\n    |          helper function          |\n    |__________________________________*/\n\n    function doTransferIn(address tokenAddr, address from, uint amount) internal {\n        IERC20 token = IERC20(tokenAddr);\n        token.safeTransferFrom(from, address(this), amount);\n\n        emit Mint(from, amount);\n    }\n\n    function doTransferOut(address tokenAddr, address to, uint amount) internal {\n        uint256 fee = amount.div(protocolFee);\n\n        IERC20 token = IERC20(tokenAddr);\n        token.safeTransfer(to, amount.sub(fee));\n        token.safeTransfer(treasury, fee);\n\n        emit Burn(to, amount);\n    }\n\n}\n"}}}