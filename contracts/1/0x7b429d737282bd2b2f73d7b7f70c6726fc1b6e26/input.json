{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "IndexedStakingLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\n\ncontract IndexedStakingLens {\n  struct StakingPool {\n    uint256 pid;\n    address stakingToken;\n    bool isPairToken;\n    address token0;\n    address token1;\n    uint256 amountStaked;\n    uint256 ndxPerDay;\n    string symbol;\n  }\n\n  // Assume 13.5 sec per block\n  uint256 internal constant BLOCKS_PER_DAY = 864000 / 135;\n  IMultiTokenStaking public constant stakingContract = IMultiTokenStaking(0xC46E0E7eCb3EfCC417f6F89b940FFAFf72556382);\n\n  function getPool(\n    uint256 i,\n    uint256 totalAllocPoint,\n    uint256 totalNdxPerDay\n  ) internal view returns (StakingPool memory pool) {\n    pool.pid = i;\n    pool.stakingToken = stakingContract.lpToken(i);\n    IUniswapV2Pair poolAsPair = IUniswapV2Pair(pool.stakingToken);\n    try poolAsPair.getReserves() returns (uint112, uint112, uint32) {\n      pool.isPairToken = true;\n      pool.token0 = poolAsPair.token0();\n      pool.token1 = poolAsPair.token1();\n      pool.symbol = string(abi.encodePacked(\n        SymbolHelper.getSymbol(pool.token0),\n        \"/\",\n        SymbolHelper.getSymbol(pool.token1)\n      ));\n    } catch {\n      pool.symbol = SymbolHelper.getSymbol(pool.stakingToken);\n    }\n    pool.amountStaked = IERC20(pool.stakingToken).balanceOf(address(stakingContract));\n    pool.ndxPerDay = (stakingContract.poolInfo(i).allocPoint * totalNdxPerDay) / totalAllocPoint;\n  }\n\n  function getPools() external view returns (StakingPool[] memory arr) {\n    uint256 len = stakingContract.poolLength();\n    arr = new StakingPool[](len);\n    uint256 totalAllocPoint = stakingContract.totalAllocPoint();\n    uint256 totalNdxPerDay = stakingContract.rewardsSchedule().getRewardsForBlockRange(block.number, block.number + BLOCKS_PER_DAY);\n    for (uint256 i; i < len; i++) {\n      arr[i] = getPool(i, totalAllocPoint, totalNdxPerDay);\n    }\n  }\n}\n\n\nlibrary SymbolHelper {\n\n  /**\n   * @dev Returns the index of the lowest bit set in `self`.\n   * Note: Requires that `self != 0`\n   */\n  function lowestBitSet(uint256 self) internal pure returns (uint256 _z) {\n    require (self > 0, \"Bits::lowestBitSet: Value 0 has no bits set\");\n    uint256 _magic = 0x00818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff;\n    uint256 val = (self & -self) * _magic >> 248;\n    uint256 _y = val >> 5;\n    _z = (\n      _y < 4\n        ? _y < 2\n          ? _y == 0\n            ? 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100\n            : 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606\n          : _y == 2\n            ? 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707\n            : 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e\n        : _y < 6\n          ? _y == 4\n            ? 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff\n            : 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616\n          : _y == 6\n            ? 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe\n            : 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd\n    );\n    _z >>= (val & 0x1f) << 3;\n    return _z & 0xff;\n  }\n\n  function getSymbol(address token) internal view returns (string memory) {\n    (bool success, bytes memory data) = token.staticcall(abi.encodeWithSignature(\"symbol()\"));\n    if (!success) return \"UNKNOWN\";\n    if (data.length != 32) return abi.decode(data, (string));\n    uint256 symbol = abi.decode(data, (uint256));\n    if (symbol == 0) return \"UNKNOWN\";\n    uint256 emptyBits = 255 - lowestBitSet(symbol);\n    uint256 size = (emptyBits / 8) + (emptyBits % 8 > 0 ? 1 : 0);\n    assembly { mstore(data, size) }\n    return string(data);\n  }\n}\n\n\ninterface IMultiTokenStaking {\n  struct PoolInfo {\n    uint128 accRewardsPerShare;\n    uint64 lastRewardBlock;\n    uint64 allocPoint;\n  }\n\n  function poolLength() external view returns (uint256);\n\n  function lpToken(uint256) external view returns (address);\n\n  function poolInfo(uint256) external view returns (PoolInfo memory);\n\n  function totalAllocPoint() external view returns (uint256);\n\n  function rewardsSchedule() external view returns (IRewardsSchedule);\n}\n\ninterface IRewardsSchedule {\n  function getRewardsForBlockRange(uint256 from, uint256 to) external view returns (uint256);\n}\n\ninterface IUniswapV2Pair {\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n}\n\ninterface IERC20 {\n  function balanceOf(address) external view returns (uint256);\n}"
    }
  }
}