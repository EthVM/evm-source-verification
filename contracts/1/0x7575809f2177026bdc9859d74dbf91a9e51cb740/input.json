{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/FeeSplitter.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\ncontract FeeSplitter {\n\n    address payable public dev1;\n    address payable public dev2;\n    uint public shares1;\n    uint public shares2;\n\n    bool internal locked;\n\n    /**\n     * @dev Call the constructor with two addresses and two share proportions, adding to 1000.\n     */\n    constructor(address payable _dev1, address payable _dev2, uint _shares1, uint _shares2) {\n        dev1 = _dev1;\n        dev2 = _dev2;\n        shares1 = _shares1;\n        shares2 = _shares2;\n        require(shares1 + shares2 == 1000, \"Shares must add up to 1000\");\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    /**\n     * @dev Withdraw funds. Solidity integer division may leave up to 1 wei in the contract afterwards.\n     */\n    function withdraw() external noReentrant {\n        uint payout1 = address(this).balance * shares1 / 1000;\n        uint payout2 = address(this).balance * shares2 / 1000;\n\n        (bool success1,) = dev1.call{value: payout1}(\"\");\n        (bool success2,) = dev2.call{value: payout2}(\"\");\n\n        require(success1 && success2, \"Sending ether failed\");\n    }\n\n    /**\n     * @dev Don't allow reentrancy attacks in withdraw()\n     */\n    modifier noReentrant() {\n        require(!locked, \"No reentrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n}"}}}