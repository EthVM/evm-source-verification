{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TeleportToken.sol":{"content":"pragma solidity ^0.8.6;\n/*\n * SPDX-License-Identifier: MIT\n */\npragma experimental ABIEncoderV2;\n\n// import \"hardhat/console.sol\";\n\n\ncontract Verify {\n\n  function recoverSigner(bytes32 message, bytes memory sig)\n       public\n       pure\n       returns (address)\n    {\n       uint8 v;\n       bytes32 r;\n       bytes32 s;\n\n       (v, r, s) = splitSignature(sig);\n\n       if (v != 27 && v != 28) {\n           return (address(0));\n       } else {\n           // solium-disable-next-line arg-overflow\n           return ecrecover(message, v, r, s);\n       }\n  }\n\n  function splitSignature(bytes memory sig)\n       public\n       pure\n       returns (uint8, bytes32, bytes32)\n   {\n       require(sig.length == 65);\n\n       bytes32 r;\n       bytes32 s;\n       uint8 v;\n\n       assembly {\n           // first 32 bytes, after the length prefix\n           r := mload(add(sig, 32))\n           // second 32 bytes\n           s := mload(add(sig, 64))\n           // final byte (first byte of the next 32 bytes)\n           v := byte(0, mload(add(sig, 96)))\n       }\n\n       if (v < 27)\n           v += 27;\n\n       return (v, r, s);\n   }\n}\n\n\nlibrary Endian {\n    /* https://ethereum.stackexchange.com/questions/83626/how-to-reverse-byte-order-in-uint256-or-bytes32 */\n    function reverse64(uint64 input) internal pure returns (uint64 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00FF00FF00) >> 8) |\n            ((v & 0x00FF00FF00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = ((v & 0xFFFF0000FFFF0000) >> 16) |\n            ((v & 0x0000FFFF0000FFFF) << 16);\n\n        // swap 4-byte long pairs\n        v = (v >> 32) | (v << 32);\n    }\n    function reverse32(uint32 input) internal pure returns (uint32 v) {\n        v = input;\n\n        // swap bytes\n        v = ((v & 0xFF00FF00) >> 8) |\n            ((v & 0x00FF00FF) << 8);\n\n        // swap 2-byte long pairs\n        v = (v >> 16) | (v << 16);\n    }\n    function reverse16(uint16 input) internal pure returns (uint16 v) {\n        v = input;\n\n        // swap bytes\n        v = (v >> 8) | (v << 8);\n    }\n}\n\n// ----------------------------------------------------------------------------\n// Safe maths\n// ----------------------------------------------------------------------------\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\nabstract contract ERC20Interface {\n    function totalSupply() virtual public view returns (uint);\n    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n    function transfer(address to, uint tokens) virtual public returns (bool success);\n    function approve(address spender, uint tokens) virtual public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\nabstract contract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\ncontract Oracled is Owned {\n    mapping(address => bool) public oracles;\n    address[] public oraclesArr;\n\n    modifier onlyOracle {\n        require(oracles[msg.sender] == true, \"Account is not a registered oracle\");\n\n        _;\n    }\n\n    function regOracle(address _newOracle) public onlyOwner {\n        require(!oracles[_newOracle], \"Oracle is already registered\");\n        oraclesArr.push(_newOracle);\n        oracles[_newOracle] = true;\n    }\n\n    function unregOracle(address _remOracle) public onlyOwner {\n        require(oracles[_remOracle] == true, \"Oracle is not registered\");\n\n        delete oracles[_remOracle];\n    }\n}\n\n// ----------------------------------------------------------------------------\n// ERC20 Token, with the addition of symbol, name and decimals and an\n// initial fixed supply, added teleport method\n// ----------------------------------------------------------------------------\ncontract TeleportToken is ERC20Interface, Owned, Oracled, Verify {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint public _totalSupply;\n    uint8 public threshold;\n    uint8 public thisChainId;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    mapping(uint64 => mapping(address => bool)) signed;\n    mapping(uint64 => bool) public claimed;\n\n    event Teleport(address indexed from, string to, uint tokens, uint chainId);\n    event Claimed(uint64 id, address to, uint tokens);\n\n    struct TeleportData {\n        uint64 id;\n        uint32 ts;\n        uint64 fromAddr;\n        uint64 quantity;\n        uint64 symbolRaw;\n        uint8 chainId;\n        address toAddress;\n    }\n\n    // ------------------------------------------------------------------------\n    // Constructor\n    // ------------------------------------------------------------------------\n    constructor(string memory _symbol, string memory _name, uint8 _decimals, uint __totalSupply, uint8 _threshold, uint8 _thisChainId) {\n        symbol = _symbol;\n        name = _name;\n        decimals = _decimals;\n        _totalSupply = __totalSupply * 10**uint(_decimals);\n        balances[address(0)] = _totalSupply;\n        threshold = _threshold;\n        thisChainId = _thisChainId;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Total supply\n    // ------------------------------------------------------------------------\n    function totalSupply() override public view returns (uint) {\n        return _totalSupply - balances[address(0)];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Get the token balance for account `tokenOwner`\n    // ------------------------------------------------------------------------\n    function balanceOf(address tokenOwner) override public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer the balance from token owner's account to `to` account\n    // - Owner's account must have sufficient balance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transfer(address to, uint tokens) override public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account\n    //\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n    // recommends that there are no checks for the approval double-spend attack\n    // as this should be implemented in user interfaces\n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) override public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Transfer `tokens` from the `from` account to the `to` account\n    //\n    // The calling account must already have sufficient tokens approve(...)-d\n    // for spending from the `from` account and\n    // - From account must have sufficient balance to transfer\n    // - Spender must have sufficient allowance to transfer\n    // - 0 value transfers are allowed\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) override public returns (bool success) {\n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Returns the amount of tokens approved by the owner that can be\n    // transferred to the spender's account\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) override public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n    // from the token owner's account. The `spender` contract function\n    // `receiveApproval(...)` is then executed\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Moves tokens to the inaccessible account and then sends event for the oracles\n    // to monitor and issue on other chain\n    // to : EOS address\n    // tokens : number of tokens in satoshis\n    // chainId : The chain id that they will be sent to\n    // ------------------------------------------------------------------------\n\n    function teleport(string memory to, uint tokens, uint chainid) public returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[address(0)] = balances[address(0)].add(tokens);\n\n        emit Transfer(msg.sender, address(0), tokens);\n        emit Teleport(msg.sender, to, tokens, chainid);\n\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // Claim tokens sent using signatures supplied to the other chain\n    // ------------------------------------------------------------------------\n\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n    function verifySigData(bytes memory sigData) private returns (TeleportData memory) {\n        TeleportData memory td;\n\n        uint64 id;\n        uint32 ts;\n        uint64 fromAddr;\n        uint64 quantity;\n        uint64 symbolRaw;\n        uint8 chainId;\n        address toAddress;\n        uint64 requiredSymbolRaw;\n        \n        assembly {\n            id := mload(add(add(sigData, 0x8), 0))\n            ts := mload(add(add(sigData, 0x4), 8))\n            fromAddr := mload(add(add(sigData, 0x8), 12))\n            quantity := mload(add(add(sigData, 0x8), 20))\n            symbolRaw := mload(add(add(sigData, 0x8), 29))\n            chainId := mload(add(add(sigData, 0x1), 36))\n            toAddress := mload(add(add(sigData, 0x14), 37))            \n        }\n        td.id = Endian.reverse64(id);\n        td.ts = Endian.reverse32(ts);\n        td.fromAddr = Endian.reverse64(fromAddr);\n        td.quantity = Endian.reverse64(quantity);\n        td.symbolRaw = Endian.reverse64(symbolRaw);\n        td.chainId = chainId;\n        td.toAddress = toAddress;\n\n        requiredSymbolRaw = uint64(bytes8(stringToBytes32(TeleportToken.symbol)));\n        require(requiredSymbolRaw == symbolRaw-td.chainId, \"Wrong symbol\");\n        require(thisChainId == td.chainId, \"Invalid Chain ID\");\n        require(block.timestamp < SafeMath.add(td.ts, (60 * 60 * 24 * 30)), \"Teleport has expired\");\n        require(!claimed[td.id], \"Already Claimed\");\n\n        claimed[td.id] = true;\n\n        return td;\n    }\n\n    function claim(bytes memory sigData, bytes[] calldata signatures) public returns (address toAddress) {\n        TeleportData memory td = verifySigData(sigData);\n\n        // verify signatures\n        require(sigData.length == 69, \"Signature data is the wrong size\");\n        require(signatures.length <= 10, \"Maximum of 10 signatures can be provided\");\n\n        bytes32 message = keccak256(sigData);\n\n        uint8 numberSigs = 0;\n\n        for (uint8 i = 0; i < signatures.length; i++){\n            address potential = Verify.recoverSigner(message, signatures[i]);\n\n            // console.log(potential);\n            // console.log(oracles[potential]);\n            // console.log(!signed[td.id][potential]);\n            // Check that they are an oracle and they haven't signed twice\n            if (oracles[potential] && !signed[td.id][potential]){\n                signed[td.id][potential] = true;\n                numberSigs++;\n\n                if (numberSigs >= threshold){\n                    break;\n                }\n            }\n        }\n\n        require(numberSigs >= threshold, \"Not enough valid signatures provided\");\n\n        balances[address(0)] = balances[address(0)].sub(td.quantity);\n        balances[td.toAddress] = balances[td.toAddress].add(td.quantity);\n\n        emit Claimed(td.id, td.toAddress, td.quantity);\n        emit Transfer(address(0), td.toAddress, td.quantity);\n\n        return td.toAddress;\n    }\n\n    function updateThreshold(uint8 newThreshold) public onlyOwner returns (bool success) {\n        if (newThreshold > 0){\n            require(newThreshold <= 10, \"Threshold has maximum of 10\");\n\n            threshold = newThreshold;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    function updateChainId(uint8 newChainId) public onlyOwner returns (bool success) {\n        if (newChainId > 0){\n            require(newChainId <= 100, \"ChainID is too big\");\n            thisChainId = newChainId;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // ------------------------------------------------------------------------\n    // Don't accept ETH\n    // ------------------------------------------------------------------------\n    receive () external payable {\n        revert();\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Owner can transfer out any accidentally sent ERC20 tokens\n    // ------------------------------------------------------------------------\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}\n"},"TeleportTokenFactory.sol":{"content":"pragma solidity ^0.8.6;\n/*\n * SPDX-License-Identifier: MIT\n */\npragma experimental ABIEncoderV2;\n\n// import \"hardhat/console.sol\";\nimport \"./TeleportToken.sol\";\n\ncontract TeleportTokenFactory is Owned, Oracled {\n    TeleportToken[] public teleporttokens;\n    uint256 public creationFee = 0.1 ether;\n\n    // Payable constructor can receive Ether\n    constructor() payable {\n    }\n\n    // Function to deposit Ether into this contract.\n    // Call this function along with some Ether.\n    // The balance of this contract will be automatically updated.\n    function deposit() public payable {}\n\n    // Call this function along with some Ether.\n    // The function will throw an error since this function is not payable.\n    function notPayable() public {}\n\n    // Function to withdraw all Ether from this contract.\n    function withdraw() onlyOwner public {\n        // get the amount of Ether stored in this contract\n        uint amount = address(this).balance;\n\n        // send all Ether to owner\n        // Owner can receive Ether since the address of owner is payable\n        (bool success, ) = owner.call{value: amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    // Function to receive Ether. msg.data must be empty\n    receive() external payable {}\n\n    // Fallback function is called when msg.data is not empty\n    fallback() external payable {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function create(\n        string memory _symbol,\n        string memory _name,\n        uint8 _decimals,\n        uint256 __totalSupply,\n        uint8 _threshold,\n        uint8 _thisChainId\n    ) public payable {\n        // correct fee\n        require(msg.value == creationFee, \"Wrong fee\");\n        TeleportToken tt = new TeleportToken(\n            _symbol,\n            _name,\n            _decimals,\n            __totalSupply,\n            _threshold,\n            _thisChainId\n        );\n\n        uint oraclesLength = oraclesArr.length;\n        for (uint i = 0; i < oraclesLength; i++) {\n            tt.regOracle(oraclesArr[i]);\n        }\n        tt.transferOwnership(msg.sender);\n\n        teleporttokens.push(tt);\n    }\n\n    function getTokenAddress(uint256 _index)\n        public\n        view\n        returns (\n            address ttAddress\n        )\n    {\n        TeleportToken tt = teleporttokens[_index];\n\n        return (\n            address(tt)\n        );\n    }\n\n    function setFee(uint256 _fee) public onlyOwner {\n        creationFee = _fee;\n    }\n\n}\n"}}}