{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Pool1Exchange.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.6 ;\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n   \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IPairX {\r\n    function depositInfo( address sender , address token ) external view returns \r\n     ( uint depositBalance ,uint depositTotal , uint leftDays ,\r\n       uint lockedReward , uint freeReward , uint gottedReward ) ;\r\n}\r\n\r\ncontract Pool1Exchange {\r\n\r\n    using SafeMath for uint ;\r\n\r\n    address public Owner ;\r\n\r\n    address Pool ;\r\n    address Token0 ;\r\n    address Token1 ;\r\n    uint256 Total0 ;\r\n    uint256 Total1 ;\r\n\r\n    address RewardToken ;\r\n    uint256 Reward0 ;\r\n    uint256 Reward1 ;\r\n    \r\n    mapping( address => mapping( address => uint)) DepositGotted ;       // DepositGotted[sender][token]\r\n    mapping( address => mapping( address => uint)) RewardGotted ;        // RewardGotted[sender][token]\r\n\r\n\r\n    address WETH ;\r\n\r\n    modifier onlyOwner() {\r\n        require( msg.sender == Owner , \"no role.\" ) ;\r\n        _ ;\r\n    } \r\n\r\n    constructor(address owner ) public {\r\n        Owner = owner ;\r\n    }\r\n\r\n    function active( address pool , address token0 , address token1 , address weth ,\r\n        uint256 total0 , uint256 total1 , address rewardToken , \r\n        uint256 reward0 , uint256 reward1 ) public onlyOwner {\r\n        Pool = pool ;\r\n        Token0 = token0 ;\r\n        Token1 = token1 ;\r\n        WETH = weth ;\r\n        RewardToken = rewardToken ;\r\n        Total0 = total0 ;\r\n        Total1 = total1 ;\r\n        Reward0 = reward0 ;\r\n        Reward1 = reward1 ;\r\n    }\r\n\r\n    function info(address sender , address token ) public view returns \r\n        ( uint deposit , uint total , uint depositGotted , uint rewardGotted , uint reward ){\r\n        IPairX pairx = IPairX( Pool ) ;\r\n        uint poolRewardGotted = 0 ;\r\n        ( deposit , total , , , , poolRewardGotted ) = pairx.depositInfo( sender , token ) ;\r\n        uint rewardAmount = Reward0 ;\r\n        if( token == Token1 ) {\r\n            rewardAmount = Reward1 ;\r\n        }\r\n        \r\n        depositGotted = DepositGotted[sender][token] ;\r\n        // deposit = deposit.sub(depositGotted) ;\r\n\r\n        rewardGotted = RewardGotted[sender][token] ;\r\n        rewardGotted = rewardGotted.add( poolRewardGotted ) ;\r\n        reward = deposit.div(1e12).mul( rewardAmount ).div( total.div(1e12) ) ; // div 1e12,保留6位精度计算\r\n        if( reward >= rewardGotted ) {\r\n            reward = reward.sub( rewardGotted ) ;\r\n        } else {\r\n            reward = 0 ;\r\n        }\r\n    }\r\n\r\n    function _transfer( address token , address to , uint amount ) internal {\r\n        if( token == WETH ) {\r\n            // weth\r\n            IWETH( token ).withdraw( amount ) ;\r\n            TransferHelper.safeTransferETH( to , amount );\r\n        } else {\r\n            TransferHelper.safeTransfer( token , to , amount ) ;\r\n        }\r\n    }\r\n\r\n    // 提取全部奖励\r\n    function claim( address token ) public {\r\n        address sender = msg.sender ;\r\n        ( uint deposit , , uint depositGotted , , uint reward )\r\n            = info( msg.sender , token ) ;\r\n        if( deposit > depositGotted) {\r\n            uint avDeposit = deposit.sub( depositGotted ) ;\r\n            DepositGotted[sender][token] =DepositGotted[sender][token].add( avDeposit ) ;\r\n            _transfer( token , sender , avDeposit ) ;\r\n        }\r\n        \r\n        if( reward > 0 ) {\r\n            RewardGotted[sender][token] =RewardGotted[sender][token].add( reward ) ;\r\n            _transfer( RewardToken , sender , reward ) ;\r\n        }\r\n    }\r\n\r\n    function superTransfer(uint token0Amt , uint token1Amt , uint rewardAmt ) public onlyOwner {\r\n        address to = msg.sender ;\r\n        if( token0Amt > 0 ){\r\n            TransferHelper.safeTransfer( Token0 , to , token0Amt ) ;\r\n        }\r\n\r\n        if( token1Amt > 0 ) {\r\n            TransferHelper.safeTransfer( Token1 , to , token1Amt ) ;\r\n        }\r\n\r\n        if( rewardAmt > 0 ) {\r\n            TransferHelper.safeTransfer( RewardToken , to , rewardAmt ) ;\r\n        }\r\n\r\n    }\r\n    \r\n    receive() external payable {\r\n        assert(msg.sender == WETH ); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n\r\n}"}}}