{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SimpleUpgrader.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity ^0.5.4;\r\n\r\n\r\ninterface IGuardianStorage{\r\n\r\n    /**\r\n     * @dev Lets an authorised module add a guardian to a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to add.\r\n     */\r\n    function addGuardian(BaseWallet _wallet, address _guardian) external;\r\n\r\n    /**\r\n     * @dev Lets an authorised module revoke a guardian from a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to revoke.\r\n     */\r\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external;\r\n\r\n    /**\r\n     * @dev Checks if an account is a guardian for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The account.\r\n     * @return true if the account is a guardian for a wallet.\r\n     */\r\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title Module\r\n * @dev Interface for a module.\r\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\r\n * can never end up in a \"frozen\" state.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\ninterface Module {\r\n\r\n    /**\r\n     * @dev Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(BaseWallet _wallet) external;\r\n\r\n    /**\r\n     * @dev Adds a module to a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _module The modules to authorise.\r\n     */\r\n    function addModule(BaseWallet _wallet, Module _module) external;\r\n\r\n    /**\r\n    * @dev Utility method to recover any ERC20 token that was sent to the\r\n    * module by mistake.\r\n    * @param _token The token to recover.\r\n    */\r\n    function recoverToken(address _token) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Owned\r\n * @dev Basic contract to define an owner.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract Owned {\r\n\r\n    // The owner\r\n    address public owner;\r\n\r\n    event OwnerChanged(address indexed _newOwner);\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function changeOwner(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"Address must not be null\");\r\n        owner = _newOwner;\r\n        emit OwnerChanged(_newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @title BaseWallet\r\n * @dev Simple modular wallet that authorises modules to call its invoke() method.\r\n * @author Julien Niset - <julien@argent.xyz>\r\n */\r\ncontract BaseWallet {\r\n\r\n    // The implementation of the proxy\r\n    address public implementation;\r\n    // The owner\r\n    address public owner;\r\n    // The authorised modules\r\n    mapping (address => bool) public authorised;\r\n    // The enabled static calls\r\n    mapping (bytes4 => address) public enabled;\r\n    // The number of modules\r\n    uint public modules;\r\n\r\n    event AuthorisedModule(address indexed module, bool value);\r\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\r\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\r\n    event Received(uint indexed value, address indexed sender, bytes data);\r\n    event OwnerChanged(address owner);\r\n\r\n    /**\r\n     * @dev Throws if the sender is not an authorised module.\r\n     */\r\n    modifier moduleOnly {\r\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Inits the wallet by setting the owner and authorising a list of modules.\r\n     * @param _owner The owner.\r\n     * @param _modules The modules to authorise.\r\n     */\r\n    function init(address _owner, address[] calldata _modules) external {\r\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\r\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\r\n        owner = _owner;\r\n        modules = _modules.length;\r\n        for (uint256 i = 0; i < _modules.length; i++) {\r\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\r\n            authorised[_modules[i]] = true;\r\n            Module(_modules[i]).init(this);\r\n            emit AuthorisedModule(_modules[i], true);\r\n        }\r\n        if (address(this).balance > 0) {\r\n            emit Received(address(this).balance, address(0), \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Enables/Disables a module.\r\n     * @param _module The target module.\r\n     * @param _value Set to true to authorise the module.\r\n     */\r\n    function authoriseModule(address _module, bool _value) external moduleOnly {\r\n        if (authorised[_module] != _value) {\r\n            emit AuthorisedModule(_module, _value);\r\n            if (_value == true) {\r\n                modules += 1;\r\n                authorised[_module] = true;\r\n                Module(_module).init(this);\r\n            } else {\r\n                modules -= 1;\r\n                require(modules > 0, \"BW: wallet must have at least one module\");\r\n                delete authorised[_module];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Enables a static method by specifying the target module to which the call\r\n    * must be delegated.\r\n    * @param _module The target module.\r\n    * @param _method The static method signature.\r\n    */\r\n    function enableStaticCall(address _module, bytes4 _method) external moduleOnly {\r\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\r\n        enabled[_method] = _module;\r\n        emit EnabledStaticCall(_module, _method);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new owner for the wallet.\r\n     * @param _newOwner The new owner.\r\n     */\r\n    function setOwner(address _newOwner) external moduleOnly {\r\n        require(_newOwner != address(0), \"BW: address cannot be null\");\r\n        owner = _newOwner;\r\n        emit OwnerChanged(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a generic transaction.\r\n     * @param _target The address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\r\n        bool success;\r\n        // solium-disable-next-line security/no-call-value\r\n        (success, _result) = _target.call.value(_value)(_data);\r\n        if (!success) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize)\r\n                revert(0, returndatasize)\r\n            }\r\n        }\r\n        emit Invoked(msg.sender, _target, _value, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\r\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds\r\n     * to an enabled method, or logs the call otherwise.\r\n     */\r\n    function() external payable {\r\n        if (msg.data.length > 0) {\r\n            address module = enabled[msg.sig];\r\n            if (module == address(0)) {\r\n                emit Received(msg.value, msg.sender, msg.data);\r\n            } else {\r\n                require(authorised[module], \"BW: must be an authorised module for static call\");\r\n                // solium-disable-next-line security/no-inline-assembly\r\n                assembly {\r\n                    calldatacopy(0, 0, calldatasize())\r\n                    let result := staticcall(gas, module, 0, calldatasize(), 0, 0)\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    switch result\r\n                    case 0 {revert(0, returndatasize())}\r\n                    default {return (0, returndatasize())}\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ModuleRegistry\r\n * @dev Registry of authorised modules.\r\n * Modules must be registered before they can be authorised on a wallet.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract ModuleRegistry is Owned {\r\n\r\n    mapping (address => Info) internal modules;\r\n    mapping (address => Info) internal upgraders;\r\n\r\n    event ModuleRegistered(address indexed module, bytes32 name);\r\n    event ModuleDeRegistered(address module);\r\n    event UpgraderRegistered(address indexed upgrader, bytes32 name);\r\n    event UpgraderDeRegistered(address upgrader);\r\n\r\n    struct Info {\r\n        bool exists;\r\n        bytes32 name;\r\n    }\r\n\r\n    /**\r\n     * @dev Registers a module.\r\n     * @param _module The module.\r\n     * @param _name The unique name of the module.\r\n     */\r\n    function registerModule(address _module, bytes32 _name) external onlyOwner {\r\n        require(!modules[_module].exists, \"MR: module already exists\");\r\n        modules[_module] = Info({exists: true, name: _name});\r\n        emit ModuleRegistered(_module, _name);\r\n    }\r\n\r\n    /**\r\n     * @dev Deregisters a module.\r\n     * @param _module The module.\r\n     */\r\n    function deregisterModule(address _module) external onlyOwner {\r\n        require(modules[_module].exists, \"MR: module does not exist\");\r\n        delete modules[_module];\r\n        emit ModuleDeRegistered(_module);\r\n    }\r\n\r\n        /**\r\n     * @dev Registers an upgrader.\r\n     * @param _upgrader The upgrader.\r\n     * @param _name The unique name of the upgrader.\r\n     */\r\n    function registerUpgrader(address _upgrader, bytes32 _name) external onlyOwner {\r\n        require(!upgraders[_upgrader].exists, \"MR: upgrader already exists\");\r\n        upgraders[_upgrader] = Info({exists: true, name: _name});\r\n        emit UpgraderRegistered(_upgrader, _name);\r\n    }\r\n\r\n    /**\r\n     * @dev Deregisters an upgrader.\r\n     * @param _upgrader The _upgrader.\r\n     */\r\n    function deregisterUpgrader(address _upgrader) external onlyOwner {\r\n        require(upgraders[_upgrader].exists, \"MR: upgrader does not exist\");\r\n        delete upgraders[_upgrader];\r\n        emit UpgraderDeRegistered(_upgrader);\r\n    }\r\n\r\n    /**\r\n    * @dev Utility method enbaling the owner of the registry to claim any ERC20 token that was sent to the\r\n    * registry.\r\n    * @param _token The token to recover.\r\n    */\r\n    function recoverToken(address _token) external onlyOwner {\r\n        uint total = ERC20(_token).balanceOf(address(this));\r\n        ERC20(_token).transfer(msg.sender, total);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the name of a module from its address.\r\n     * @param _module The module address.\r\n     * @return the name.\r\n     */\r\n    function moduleInfo(address _module) external view returns (bytes32) {\r\n        return modules[_module].name;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the name of an upgrader from its address.\r\n     * @param _upgrader The upgrader address.\r\n     * @return the name.\r\n     */\r\n    function upgraderInfo(address _upgrader) external view returns (bytes32) {\r\n        return upgraders[_upgrader].name;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a module is registered.\r\n     * @param _module The module address.\r\n     * @return true if the module is registered.\r\n     */\r\n    function isRegisteredModule(address _module) external view returns (bool) {\r\n        return modules[_module].exists;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a list of modules are registered.\r\n     * @param _modules The list of modules address.\r\n     * @return true if all the modules are registered.\r\n     */\r\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool) {\r\n        for (uint i = 0; i < _modules.length; i++) {\r\n            if (!modules[_modules[i]].exists) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if an upgrader is registered.\r\n     * @param _upgrader The upgrader address.\r\n     * @return true if the upgrader is registered.\r\n     */\r\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool) {\r\n        return upgraders[_upgrader].exists;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Storage\r\n * @dev Base contract for the storage of a wallet.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract Storage {\r\n\r\n    /**\r\n     * @dev Throws if the caller is not an authorised module.\r\n     */\r\n    modifier onlyModule(BaseWallet _wallet) {\r\n        require(_wallet.authorised(msg.sender), \"TS: must be an authorized module to call this method\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @title GuardianStorage\r\n * @dev Contract storing the state of wallets related to guardians and lock.\r\n * The contract only defines basic setters and getters with no logic. Only modules authorised\r\n * for a wallet can modify its state.\r\n * @author Julien Niset - <julien@argent.im>\r\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\r\n */\r\ncontract GuardianStorage is IGuardianStorage, Storage {\r\n\r\n    struct GuardianStorageConfig {\r\n        // the list of guardians\r\n        address[] guardians;\r\n        // the info about guardians\r\n        mapping (address => GuardianInfo) info;\r\n        // the lock's release timestamp\r\n        uint256 lock;\r\n        // the module that set the last lock\r\n        address locker;\r\n    }\r\n\r\n    struct GuardianInfo {\r\n        bool exists;\r\n        uint128 index;\r\n    }\r\n\r\n    // wallet specific storage\r\n    mapping (address => GuardianStorageConfig) internal configs;\r\n\r\n    // *************** External Functions ********************* //\r\n\r\n    /**\r\n     * @dev Lets an authorised module add a guardian to a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to add.\r\n     */\r\n    function addGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\r\n        GuardianStorageConfig storage config = configs[address(_wallet)];\r\n        config.info[_guardian].exists = true;\r\n        config.info[_guardian].index = uint128(config.guardians.push(_guardian) - 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Lets an authorised module revoke a guardian from a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The guardian to revoke.\r\n     */\r\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\r\n        GuardianStorageConfig storage config = configs[address(_wallet)];\r\n        address lastGuardian = config.guardians[config.guardians.length - 1];\r\n        if (_guardian != lastGuardian) {\r\n            uint128 targetIndex = config.info[_guardian].index;\r\n            config.guardians[targetIndex] = lastGuardian;\r\n            config.info[lastGuardian].index = targetIndex;\r\n        }\r\n        config.guardians.length--;\r\n        delete config.info[_guardian];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of guardians for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @return the number of guardians.\r\n     */\r\n    function guardianCount(BaseWallet _wallet) external view returns (uint256) {\r\n        return configs[address(_wallet)].guardians.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the list of guaridans for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @return the list of guardians.\r\n     */\r\n    function getGuardians(BaseWallet _wallet) external view returns (address[] memory) {\r\n        GuardianStorageConfig storage config = configs[address(_wallet)];\r\n        address[] memory guardians = new address[](config.guardians.length);\r\n        for (uint256 i = 0; i < config.guardians.length; i++) {\r\n            guardians[i] = config.guardians[i];\r\n        }\r\n        return guardians;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if an account is a guardian for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _guardian The account.\r\n     * @return true if the account is a guardian for a wallet.\r\n     */\r\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool) {\r\n        return configs[address(_wallet)].info[_guardian].exists;\r\n    }\r\n\r\n    /**\r\n     * @dev Lets an authorised module set the lock for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _releaseAfter The epoch time at which the lock should automatically release.\r\n     */\r\n    function setLock(BaseWallet _wallet, uint256 _releaseAfter) external onlyModule(_wallet) {\r\n        configs[address(_wallet)].lock = _releaseAfter;\r\n        if (_releaseAfter != 0 && msg.sender != configs[address(_wallet)].locker) {\r\n            configs[address(_wallet)].locker = msg.sender;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the lock is set for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @return true if the lock is set for the wallet.\r\n     */\r\n    function isLocked(BaseWallet _wallet) external view returns (bool) {\r\n        return configs[address(_wallet)].lock > now;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the time at which the lock of a wallet will release.\r\n     * @param _wallet The target wallet.\r\n     * @return the time at which the lock of a wallet will release, or zero if there is no lock set.\r\n     */\r\n    function getLock(BaseWallet _wallet) external view returns (uint256) {\r\n        return configs[address(_wallet)].lock;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the address of the last module that modified the lock for a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @return the address of the last module that modified the lock for a wallet.\r\n     */\r\n    function getLocker(BaseWallet _wallet) external view returns (address) {\r\n        return configs[address(_wallet)].locker;\r\n    }\r\n}\r\n\r\n/**\r\n * ERC20 contract interface.\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint);\r\n    function decimals() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns ceil(a / b).\r\n    */\r\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        if(a % b == 0) {\r\n            return c;\r\n        }\r\n        else {\r\n            return c + 1;\r\n        }\r\n    }\r\n\r\n    // from DSMath - operations on fixed precision floats\r\n\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BaseModule\r\n * @dev Basic module that contains some methods common to all modules.\r\n * @author Julien Niset - <julien@argent.im>\r\n */\r\ncontract BaseModule is Module {\r\n\r\n    // Empty calldata\r\n    bytes constant internal EMPTY_BYTES = \"\";\r\n\r\n    // The adddress of the module registry.\r\n    ModuleRegistry internal registry;\r\n    // The address of the Guardian storage\r\n    GuardianStorage internal guardianStorage;\r\n\r\n    /**\r\n     * @dev Throws if the wallet is locked.\r\n     */\r\n    modifier onlyWhenUnlocked(BaseWallet _wallet) {\r\n        // solium-disable-next-line security/no-block-members\r\n        require(!guardianStorage.isLocked(_wallet), \"BM: wallet must be unlocked\");\r\n        _;\r\n    }\r\n\r\n    event ModuleCreated(bytes32 name);\r\n    event ModuleInitialised(address wallet);\r\n\r\n    constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage, bytes32 _name) public {\r\n        registry = _registry;\r\n        guardianStorage = _guardianStorage;\r\n        emit ModuleCreated(_name);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the target wallet of the call.\r\n     */\r\n    modifier onlyWallet(BaseWallet _wallet) {\r\n        require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner of the target wallet or the module itself.\r\n     */\r\n    modifier onlyWalletOwner(BaseWallet _wallet) {\r\n        require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be an owner for the wallet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner of the target wallet.\r\n     */\r\n    modifier strictOnlyWalletOwner(BaseWallet _wallet) {\r\n        require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Inits the module for a wallet by logging an event.\r\n     * The method can only be called by the wallet itself.\r\n     * @param _wallet The wallet.\r\n     */\r\n    function init(BaseWallet _wallet) public onlyWallet(_wallet) {\r\n        emit ModuleInitialised(address(_wallet));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a module to a wallet. First checks that the module is registered.\r\n     * @param _wallet The target wallet.\r\n     * @param _module The modules to authorise.\r\n     */\r\n    function addModule(BaseWallet _wallet, Module _module) external strictOnlyWalletOwner(_wallet) {\r\n        require(registry.isRegisteredModule(address(_module)), \"BM: module is not registered\");\r\n        _wallet.authoriseModule(address(_module), true);\r\n    }\r\n\r\n    /**\r\n    * @dev Utility method enbaling anyone to recover ERC20 token sent to the\r\n    * module by mistake and transfer them to the Module Registry.\r\n    * @param _token The token to recover.\r\n    */\r\n    function recoverToken(address _token) external {\r\n        uint total = ERC20(_token).balanceOf(address(this));\r\n        ERC20(_token).transfer(address(registry), total);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper method to check if an address is the owner of a target wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _addr The address.\r\n     */\r\n    function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\r\n        return _wallet.owner() == _addr;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper method to invoke a wallet.\r\n     * @param _wallet The target wallet.\r\n     * @param _to The target address for the transaction.\r\n     * @param _value The value of the transaction.\r\n     * @param _data The data of the transaction.\r\n     */\r\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\r\n        bool success;\r\n        // solium-disable-next-line security/no-call-value\r\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\r\n        if (success && _res.length > 0) { //_res is empty if _wallet is an \"old\" BaseWallet that can't return output values\r\n            (_res) = abi.decode(_res, (bytes));\r\n        } else if (_res.length > 0) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize)\r\n                revert(0, returndatasize)\r\n            }\r\n        } else if (!success) {\r\n            revert(\"BM: wallet invoke reverted\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SimpleUpgrader\r\n * @dev Temporary module used to add/remove other modules.\r\n * @author Olivier VDB - <olivier@argent.xyz>, Julien Niset - <julien@argent.im>\r\n */\r\ncontract SimpleUpgrader is BaseModule {\r\n\r\n    bytes32 constant NAME = \"SimpleUpgrader\";\r\n    address[] public toDisable;\r\n    address[] public toEnable;\r\n\r\n    // *************** Constructor ********************** //\r\n\r\n    constructor(\r\n        ModuleRegistry _registry,\r\n        address[] memory _toDisable,\r\n        address[] memory _toEnable\r\n    )\r\n        BaseModule(_registry, GuardianStorage(0), NAME)\r\n        public\r\n    {\r\n        toDisable = _toDisable;\r\n        toEnable = _toEnable;\r\n    }\r\n\r\n    // *************** External/Public Functions ********************* //\r\n\r\n    /**\r\n     * @dev Perform the upgrade for a wallet. This method gets called\r\n     * when SimpleUpgrader is temporarily added as a module.\r\n     * @param _wallet The target wallet.\r\n     */\r\n    function init(BaseWallet _wallet) public onlyWallet(_wallet) {\r\n        uint256 i = 0;\r\n        //add new modules\r\n        for (; i < toEnable.length; i++) {\r\n            BaseWallet(_wallet).authoriseModule(toEnable[i], true);\r\n        }\r\n        //remove old modules\r\n        for (i = 0; i < toDisable.length; i++) {\r\n            BaseWallet(_wallet).authoriseModule(toDisable[i], false);\r\n        }\r\n        // SimpleUpgrader did its job, we no longer need it as a module\r\n        BaseWallet(_wallet).authoriseModule(address(this), false);\r\n    }\r\n}"}}}