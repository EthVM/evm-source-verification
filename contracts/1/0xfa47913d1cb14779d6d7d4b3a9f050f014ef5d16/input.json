{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/demaxConfig.sol":{"content":"// Dependency file: contracts/modules/Governable.sol\n\n// pragma solidity >=0.5.16;\n\ncontract Governable {\n    address public governor;\n\n    event ChangeGovernor(address indexed _old, address indexed _new);\n\n    modifier onlyGovernor() {\n        require(msg.sender == governor, 'Governable: FORBIDDEN');\n        _;\n    }\n\n    // called after deployment\n    function initGovernorAddress(address _governor) internal {\n        require(governor == address(0), 'Governable: INITIALIZED');\n        require(_governor != address(0), 'Governable: INPUT_ADDRESS_IS_ZERO');\n        governor = _governor;\n    }\n\n    function changeGovernor(address _new) public onlyGovernor {\n        _changeGovernor(_new);\n    }\n\n    function _changeGovernor(address _new) internal {\n        require(_new != address(0), 'Governable: INVALID_ADDRESS');\n        require(_new != governor, 'Governable: NO_CHANGE');\n        address old = governor;\n        governor = _new;\n        emit ChangeGovernor(old, _new);\n    }\n\n}\n\n// Dependency file: contracts/modules/Ownable.sol\n\n// pragma solidity >=0.5.16;\n\ncontract Ownable {\n    address public owner;\n\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\n        _;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\n        emit OwnerChanged(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n}\n\n// Dependency file: contracts/modules/TokenRegistry.sol\n\n// pragma solidity >=0.5.16;\n\n// import './Governable.sol';\n\n/**\n    Business Process\n    step 1. publishToken\n    step 2. addToken or removeToken\n */\n\ncontract TokenRegistry is Governable {\n    mapping (address => uint) public tokenStatus;\n    mapping (address => uint) public publishTime;\n    mapping(address => mapping(address => uint)) public pairStatus;\n    uint public tokenCount;\n    uint public pairCount;\n    address[] public tokenList;\n    uint public constant NONE = 0;\n    uint public constant REGISTERED = 1;\n    uint public constant PENDING = 2;\n    uint public constant OPENED = 3;\n    uint public constant CLOSED = 4;\n\n    event TokenStatusChanged(address indexed _token, uint _status, uint _block);\n    event PairStatusChanged(address indexed _tokenA, address indexed _tokenB, uint _status);\n\n    function registryToken(address _token) external onlyGovernor returns (bool) {\n        return _updateToken(_token, REGISTERED);\n    }\n\n    function publishToken(address _token) external onlyGovernor returns (bool) {\n        publishTime[_token] = block.number;\n        return _updateToken(_token, PENDING);\n    }\n\n    function updateToken(address _token, uint _status) external onlyGovernor returns (bool) {\n        return _updateToken(_token, _status);\n    }\n\n    function validTokens() external view returns (address[] memory) {\n        uint count;\n        for (uint i; i < tokenList.length; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                count++;\n            }\n        }\n        address[] memory res = new address[](count);\n        uint index = 0;\n        for (uint i; i < tokenList.length; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                res[index] = tokenList[i];\n                index++;\n            }\n        }\n        return res;\n    }\n\n    function iterateValidTokens(uint _start, uint _end) external view returns (address[] memory) {\n        require(_end <= tokenList.length, \"TokenRegistry: OVERFLOW\");\n        require(_start <= _end && _start >= 0 && _end >= 0, \"TokenRegistry: INVAID_PARAMTERS\");\n        uint count;\n        for (uint i = _start; i < _end; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                count++;\n            }\n        }\n        address[] memory res = new address[](count);\n        uint index = 0;\n        for (uint i = _start; i < _end; i++) {\n            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n                res[index] = tokenList[i];\n                index++;\n            }\n        }\n        return res;\n    }\n\n    function _updateToken(address _token, uint _status) internal returns (bool) {\n        require(_token != address(0), 'TokenRegistry: INVALID_TOKEN');\n        require(tokenStatus[_token] != _status, 'TokenRegistry: TOKEN_STATUS_NO_CHANGE');\n        if (tokenStatus[_token] == NONE) {\n            tokenCount++;\n            require(tokenCount <= uint(-1), 'TokenRegistry: OVERFLOW');\n            tokenList.push(_token);\n        }\n        tokenStatus[_token] = _status;\n        emit TokenStatusChanged(_token, _status, block.number);\n        return true;\n    }\n\n    function updatePair(address tokenA, address tokenB, uint _status) external onlyGovernor returns (bool) {\n        return _updatePair(tokenA, tokenB, _status);\n    }\n\n    function _updatePair(address tokenA, address tokenB, uint _status) internal returns (bool) {\n        require(pairStatus[tokenA][tokenB] != _status, 'TokenRegistry: PAIR_STATUS_NO_CHANGE');\n        pairStatus[tokenA][tokenB] = _status;\n        pairStatus[tokenB][tokenA] = _status;\n        emit PairStatusChanged(tokenA, tokenB, _status);\n        return true;\n    }\n\n    function _checkPair(address tokenA, address tokenB) internal view returns (bool) {\n        uint status = pairStatus[tokenA][tokenB];\n        if (status == CLOSED) {\n            return false;\n        }\n        return true;\n    }\n\n}\n// Dependency file: contracts/libraries/TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// pragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n// Dependency file: contracts/libraries/ConfigNames.sol\n\n// pragma solidity >=0.5.16;\n\nlibrary ConfigNames {\n    bytes32 public constant PRODUCE_DGAS_RATE = bytes32('PRODUCE_DGAS_RATE');\n    bytes32 public constant SWAP_FEE_PERCENT = bytes32('SWAP_FEE_PERCENT');\n    bytes32 public constant LIST_DGAS_AMOUNT = bytes32('LIST_DGAS_AMOUNT');\n    bytes32 public constant UNSTAKE_DURATION = bytes32('UNSTAKE_DURATION');\n    bytes32 public constant REMOVE_LIQUIDITY_DURATION = bytes32('REMOVE_LIQUIDITY_DURATION');\n    bytes32 public constant TOKEN_TO_DGAS_PAIR_MIN_PERCENT = bytes32('TOKEN_TO_DGAS_PAIR_MIN_PERCENT');\n    bytes32 public constant LIST_TOKEN_FAILURE_BURN_PRECENT = bytes32('LIST_TOKEN_FAILURE_BURN_PRECENT');\n    bytes32 public constant LIST_TOKEN_SUCCESS_BURN_PRECENT = bytes32('LIST_TOKEN_SUCCESS_BURN_PRECENT');\n    bytes32 public constant PROPOSAL_DGAS_AMOUNT = bytes32('PROPOSAL_DGAS_AMOUNT');\n    bytes32 public constant VOTE_DURATION = bytes32('VOTE_DURATION');\n    bytes32 public constant VOTE_REWARD_PERCENT = bytes32('VOTE_REWARD_PERCENT');\n    bytes32 public constant PAIR_SWITCH = bytes32('PAIR_SWITCH');\n    bytes32 public constant TOKEN_PENGDING_SWITCH = bytes32('TOKEN_PENGDING_SWITCH');\n    bytes32 public constant TOKEN_PENGDING_TIME = bytes32('TOKEN_PENGDING_TIME');\n}\npragma solidity >=0.6.6;\n\n// import './libraries/ConfigNames.sol';\n// import './libraries/TransferHelper.sol';\n// import './modules/TokenRegistry.sol';\n// import './modules/Ownable.sol';\n\ncontract DemaxConfig is TokenRegistry, Ownable {\n    uint public version = 1;\n    event ConigValueChanged(bytes32 _name, uint _old, uint _value);\n\n    struct Config {\n        uint minValue;\n        uint maxValue;\n        uint maxSpan;\n        uint value;\n        uint enable;  // 0:disable, 1: enable\n    }\n\n    mapping(bytes32 => Config) public configs;\n\n    address public dgas;                                // DGAS contract address\n    uint public constant PERCENT_DENOMINATOR = 10000;\n    uint public constant DGAS_DECIMAL = 10 ** 18;\n    address[] public defaultListTokens;\n    \n    modifier notZero(uint amount) {\n        require(amount > 0, \"DemaxConfig: ZERO AMOUNT\");\n        _;\n    }\n\n    constructor()  public {\n        _initConfig(ConfigNames.PRODUCE_DGAS_RATE, 1 * DGAS_DECIMAL, 300 * DGAS_DECIMAL, 50 * DGAS_DECIMAL, 100 * DGAS_DECIMAL);\n        _initConfig(ConfigNames.SWAP_FEE_PERCENT, 5,30,5,30);\n        _initConfig(ConfigNames.LIST_DGAS_AMOUNT, 0, 100000 * DGAS_DECIMAL, 1000 * DGAS_DECIMAL, 0  * DGAS_DECIMAL);\n        _initConfig(ConfigNames.UNSTAKE_DURATION, 6500, 6500*7, 6500, 6500);\n        _initConfig(ConfigNames.REMOVE_LIQUIDITY_DURATION, 0, 6500*7, 6500, 0);\n        _initConfig(ConfigNames.TOKEN_TO_DGAS_PAIR_MIN_PERCENT, 200, 500, 10, 200);\n        _initConfig(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT, 100, 5000, 500, 1000);\n        _initConfig(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT, 1000, 5000, 500, 5000);\n        _initConfig(ConfigNames.PROPOSAL_DGAS_AMOUNT, 100 * DGAS_DECIMAL, 10000 * DGAS_DECIMAL, 100 * DGAS_DECIMAL, 0);\n        _initConfig(ConfigNames.VOTE_DURATION, 6500, 6500*7, 6500, 0);\n        _initConfig(ConfigNames.VOTE_REWARD_PERCENT, 0, 1000, 100, 500);\n        _initConfig(ConfigNames.PAIR_SWITCH, 0, 1, 1, 1);  // 0:off, 1:on\n        _initConfig(ConfigNames.TOKEN_PENGDING_SWITCH, 0, 1, 1, 1);  // 0:off, 1:on\n        _initConfig(ConfigNames.TOKEN_PENGDING_TIME, 0, 100*6500, 10*6500, 100*6500);\n    }\n\n    function _initConfig(bytes32 _name, uint _minValue, uint _maxValue, uint _maxSpan, uint _value) internal {\n        Config storage config = configs[_name];\n        config.minValue = _minValue;\n        config.maxValue = _maxValue;\n        config.maxSpan = _maxSpan;\n        config.value = _value;\n        config.enable = 1;\n    }\n\n    function initialize(address _dgas, address _governor, address[] memory _listTokens) public onlyOwner {\n        require(dgas == address(0), \"DemaxConfig: INITIALIZED\");\n        require(_dgas != address(0), \"DemaxConfig: ZERO ADDRESS\");\n        dgas = _dgas;\n        for(uint i = 0 ; i < _listTokens.length; i++){\n            _updateToken(_listTokens[i], OPENED);\n            defaultListTokens.push(_listTokens[i]);\n        }\n        initGovernorAddress(_governor);\n    }\n\n    function modifyGovernor(address _new) public onlyOwner {\n        _changeGovernor(_new);\n    }\n\n    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) {\n        Config memory config = configs[_name];\n        minValue = config.minValue;\n        maxValue = config.maxValue;\n        maxSpan = config.maxSpan;\n        value = config.value;\n        enable = config.enable;\n    }\n    \n    function getConfigValue(bytes32 _name) public view returns (uint) {\n        return configs[_name].value;\n    }\n\n    function changeConfigValue(bytes32 _name, uint _value) external onlyGovernor returns (bool) {\n        Config storage config = configs[_name];\n        require(config.enable == 1, \"DemaxConfig: DISABLE\");\n        require(_value <= config.maxValue && _value >= config.minValue, \"DemaxConfig: OVERFLOW\");\n        uint old = config.value;\n        uint span = _value >= old ? (_value - old) : (old - _value);\n        require(span <= config.maxSpan, \"DemaxConfig: EXCEED MAX ADJUST SPAN\");\n        config.value = _value;\n        emit ConigValueChanged(_name, old, _value);\n        return true;\n    }\n\n    function checkToken(address _token) public view returns(bool) {\n        if (tokenStatus[_token] == OPENED) {\n            return true;\n        } else if (tokenStatus[_token] == PENDING ) {\n            if (getConfigValue(ConfigNames.TOKEN_PENGDING_SWITCH) == 1 && block.number > publishTime[_token] + getConfigValue(ConfigNames.TOKEN_PENGDING_TIME)) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function checkPair(address tokenA, address tokenB) external view returns (bool) {\n        if (checkToken(tokenA) && checkToken(tokenB) && _checkPair(tokenA, tokenB)) {\n            return true;\n        }\n        return false;\n    }\n\n    function getDefaultListTokens() external view returns (address[] memory) {\n        address[] memory res = new address[](defaultListTokens.length);\n        for (uint i; i < defaultListTokens.length; i++) {\n            res[i] = defaultListTokens[i];\n        }\n        return res;\n    }\n\n}\n\n"}}}