{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":10000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Example.sol":{"content":"pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n}\n\n// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\nabstract contract Ownable {\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"O: onlyOwner function!\");\n        _;\n    }\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Initializes owner variable with msg.sender address.\n     */\n    constructor() internal {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Transfers ownership to the desired address.\n     * The function is callable only by the owner.\n     */\n    function transferOwnership(address _owner) external onlyOwner {\n        require(_owner != address(0), \"O: new owner is the zero address!\");\n        emit OwnershipTransferred(owner, _owner);\n        owner = _owner;\n    }\n}\n\n\n\n/**\n * @title Protocol adapter interface.\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ninterface ProtocolAdapter {\n\n    /**\n     * @dev MUST return \"Asset\" or \"Debt\".\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function adapterType() external pure returns (string memory);\n\n    /**\n     * @dev MUST return token type (default is \"ERC20\").\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function tokenType() external pure returns (string memory);\n\n    /**\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n     */\n    function getBalance(address token, address account) external view returns (uint256);\n}\n\n\nstruct Pool {\n    address poolAddress;\n    address stakingToken;\n    address rewardToken;\n}\n\n\n/**\n * @dev StakingRewards contract interface.\n * Only the functions required for YearnStakingV1Adapter contract are added.\n * The StakingRewards contract is available here\n * github.com/Synthetixio/synthetix/blob/master/contracts/StakingRewards.sol.\n */\ninterface StakingRewards {\n    function earned(address) external view returns (uint256);\n}\n\n\n/**\n * @title Adapter for Harvest protocol.\n * @dev Implementation of ProtocolAdapter interface.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ncontract HarvestStakingAdapter is ProtocolAdapter, Ownable {\n\n    string public constant override adapterType = \"Asset\";\n\n    string public constant override tokenType = \"ERC20\";\n\n    // Returns if the pool is enabled\n    mapping(address => bool) internal isEnabledPool_;\n    // Returns the list of pools where the given token is a staking token\n    mapping(address => address[]) internal stakingPools_;\n    // Returns the list of pools where the given token is a reward token\n    mapping(address => address[]) internal rewardPools_;\n\n    event PoolAdded(\n        address indexed poolAddress,\n        address indexed stakingToken,\n        address indexed rewardToken\n    );\n\n    function addPools(Pool[] calldata pools) external onlyOwner {\n        uint256 length = pools.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            addPool(pools[i]);\n        }\n    }\n\n    function setIsEnabledPools(\n        address[] calldata poolAddresses,\n        bool[] calldata isEnabledPools\n    )\n        external\n        onlyOwner\n    {\n        uint256 length = poolAddresses.length;\n        require(isEnabledPools.length == length, \"HSA: inconsistent arrays\");\n\n        for (uint256 i = 0; i < length; i++) {\n            setIsEnabledPool(poolAddresses[i], isEnabledPools[i]);\n        }\n    }\n\n    /**\n     * @return Amount of staked tokens / rewards earned after staking for a given account.\n     * @dev Implementation of ProtocolAdapter interface function.\n     */\n    function getBalance(address token, address account) external view override returns (uint256) {\n        address[] memory stakingPools = stakingPools_[token];\n        address[] memory rewardPools = rewardPools_[token];\n\n        uint256 length;\n        uint256 totalBalance = 0;\n\n        length = stakingPools.length;\n        for (uint256 i = 0; i < length; i++) {\n            totalBalance += getStakingBalance(stakingPools[i], account);\n        }\n\n        length = rewardPools.length;\n        for (uint256 i = 0; i < length; i++) {\n            totalBalance += getRewardBalance(rewardPools[i], account);\n        }\n\n        return totalBalance;\n    }\n\n    function getRewardPools(address token) external view returns (address[] memory) {\n        return rewardPools_[token];\n    }\n\n    function getStakingPools(address token) external view returns (address[] memory) {\n        return stakingPools_[token];\n    }\n\n    function addPool(Pool memory pool) internal {\n        stakingPools_[pool.stakingToken].push(pool.poolAddress);\n        rewardPools_[pool.rewardToken].push(pool.poolAddress);\n        setIsEnabledPool(pool.poolAddress, true);\n\n        emit PoolAdded(pool.poolAddress, pool.stakingToken, pool.rewardToken);\n    }\n\n    function setIsEnabledPool(address poolAddress, bool isEnabledPool) internal {\n        isEnabledPool_[poolAddress] = isEnabledPool;\n    }\n\n    function getRewardBalance(\n        address poolAddress,\n        address account\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return isEnabledPool_[poolAddress] ? StakingRewards(poolAddress).earned(account) : 0;\n    }\n\n    function getStakingBalance(\n        address poolAddress,\n        address account\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return isEnabledPool_[poolAddress] ? ERC20(poolAddress).balanceOf(account) : 0;\n    }\n}"}}}