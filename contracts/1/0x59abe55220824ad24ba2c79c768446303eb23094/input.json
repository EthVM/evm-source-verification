{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "escrow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @notice Bilateral escrow for ETH and ERC-20/721 tokens.\r\n/// @author LexDAO LLC.\r\ncontract LexLocker {\r\n    uint256 lockerCount;\r\n    mapping(uint256 => Locker) public lockers;\r\n    mapping(address => Resolver) public resolvers;\r\n    \r\n    /// @dev Events to assist web3 applications.\r\n    event Deposit(\r\n        bool nft,\r\n        address indexed depositor, \r\n        address indexed receiver, \r\n        address resolver,\r\n        address token, \r\n        uint256 value, \r\n        uint256 indexed registration,\r\n        string details);\r\n    event Release(uint256 indexed registration);\r\n    event Lock(uint256 indexed registration);\r\n    event Resolve(uint256 indexed registration, uint256 indexed depositorAward, uint256 indexed receiverAward, string details);\r\n    event RegisterResolver(address indexed resolver, bool indexed active, uint256 indexed fee);\r\n    \r\n    /// @dev Tracks registered escrow status.\r\n    struct Locker {  \r\n        bool nft; \r\n        bool locked;\r\n        address depositor;\r\n        address receiver;\r\n        address resolver;\r\n        address token;\r\n        uint256 value;\r\n    }\r\n    \r\n    /// @dev Tracks registered resolver status.\r\n    struct Resolver {\r\n        bool active;\r\n        uint8 fee;\r\n    }\r\n    \r\n     // **** ESCROW PROTOCOL ****  //\r\n    // -------------------------- //\r\n    /// @notice Deposits tokens (ERC-20/721) into escrow - locked funds can be released by `msg.sender` `depositor` - both parties can {lock} for `resolver`. \r\n    /// @param receiver The account that receives funds.\r\n    /// @param resolver The account that unlock funds.\r\n    /// @param token The asset used for funds.\r\n    /// @param value The amount of funds - if `nft`, the 'tokenId'.\r\n    /// @param nft If 'false', ERC-20 is assumed, otherwise, non-fungible asset.\r\n    /// @param details Describes context of escrow - stamped into event.\r\n    function deposit(\r\n        address receiver, \r\n        address resolver, \r\n        address token, \r\n        uint256 value, \r\n        bool nft, \r\n        string calldata details\r\n    ) external payable returns (uint256 registration) {\r\n        require(resolvers[resolver].active, \"resolver not active\");\r\n        \r\n        /// @dev Handle ETH/ERC-20/721 deposit.\r\n        if (msg.value != 0) {\r\n            require(msg.value == value, \"wrong msg.value\");\r\n            /// @dev Override to clarify ETH is used.\r\n            if (token != address(0)) token = address(0);\r\n        } else {\r\n            safeTransferFrom(token, msg.sender, address(this), value);\r\n        }\r\n        \r\n        /// @dev Increment registered lockers and assign # to escrow deposit.\r\n        lockerCount++;\r\n        registration = lockerCount;\r\n        lockers[registration] = Locker(nft, false, msg.sender, receiver, resolver, token, value);\r\n        \r\n        emit Deposit(nft, msg.sender, receiver, resolver, token, value, registration, details);\r\n    }\r\n    \r\n    /// @notice Releases escrowed assets to designated `receiver` - can only be called by `depositor` if not `locked`.\r\n    /// @param registration The index of escrow deposit.\r\n    function release(uint256 registration) external {\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(msg.sender == locker.depositor, \"not depositor\");\r\n        require(!locker.locked, \"locked\");\r\n        \r\n        /// @dev Handle asset transfer.\r\n        if (locker.token == address(0)) { /// @dev Release ETH.\r\n            safeTransferETH(locker.receiver, locker.value);\r\n        } else if (!locker.nft) { /// @dev Release ERC-20.\r\n            safeTransfer(locker.token, locker.receiver, locker.value);\r\n        } else { /// @dev Release NFT.\r\n            safeTransferFrom(locker.token, address(this), locker.receiver, locker.value);\r\n        }\r\n        \r\n        delete lockers[registration];\r\n        \r\n        emit Release(registration);\r\n    }\r\n    \r\n     // **** DISPUTE PROTOCOL ****  //\r\n    // --------------------------- //\r\n    /// @notice Locks escrowed assets for resolution - can only be called by locker parties.\r\n    /// @param registration The index of escrow deposit.\r\n    function lock(uint256 registration) external {\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        require(msg.sender == locker.depositor || msg.sender == locker.receiver, \"Not locker party\");\r\n        \r\n        locker.locked = true;\r\n        \r\n        emit Lock(registration);\r\n    }\r\n    \r\n    /// @notice Resolves locked escrow deposit in split between parties - if NFT, must be complete award (so, one party receives '0').\r\n    /// @param registration The registration index of escrow deposit.\r\n    /// @param depositorAward The sum given to `depositor`.\r\n    /// @param receiverAward The sum given to `receiver`.\r\n    function resolve(uint256 registration, uint256 depositorAward, uint256 receiverAward, string calldata details) external {\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(msg.sender == locker.resolver, \"not resolver\");\r\n        require(locker.locked, \"not locked\");\r\n        require(depositorAward + receiverAward == locker.value, \"not remainder\");\r\n        \r\n        /// @dev Calculate resolution fee and apply to awards.\r\n        unchecked {\r\n            uint256 resolverFee = locker.value / resolvers[locker.resolver].fee / 2;\r\n            depositorAward -= resolverFee;\r\n            receiverAward -= resolverFee;\r\n        }\r\n        \r\n        /// @dev Handle asset transfer.\r\n        if (locker.token == address(0)) { /// @dev Split ETH.\r\n            safeTransferETH(locker.depositor, depositorAward);\r\n            safeTransferETH(locker.receiver, receiverAward);\r\n        } else if (!locker.nft) { /// @dev ...ERC20.\r\n            safeTransfer(locker.token, locker.depositor, depositorAward);\r\n            safeTransfer(locker.token, locker.receiver, receiverAward);\r\n        } else { /// @dev Award NFT.\r\n            if (depositorAward != 0) {\r\n                safeTransferFrom(locker.token, address(this), locker.depositor, locker.value);\r\n            } else {\r\n                safeTransferFrom(locker.token, address(this), locker.receiver, locker.value);\r\n            }\r\n        }\r\n        \r\n        delete lockers[registration];\r\n        \r\n        emit Resolve(registration, depositorAward, receiverAward, details);\r\n    }\r\n    \r\n    function registerResolver(bool active, uint8 fee) external {\r\n        resolvers[msg.sender] = Resolver(active, fee);\r\n        emit RegisterResolver(msg.sender, active, fee);\r\n    }\r\n    \r\n     // **** TRANSFER HELPERS **** //\r\n    // -------------------------- //\r\n    /// @notice Provides 'safe' ERC-20/721 {transfer} for tokens that don't consistently return 'true/false'.\r\n    /// @param token Address of ERC-20/721 token.\r\n    /// @param recipient Account to send tokens to.\r\n    /// @param value Token amount to send - if NFT, 'tokenId'.\r\n    function safeTransfer(address token, address recipient, uint256 value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, value)); // @dev transfer(address,uint256).\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides 'safe' ERC-20/721 {transferFrom} for tokens that don't consistently return 'true/false'.\r\n    /// @param token Address of ERC-20/721 token.\r\n    /// @param sender Account to send tokens from.\r\n    /// @param recipient Account to send tokens to.\r\n    /// @param value Token amount to send - if NFT, 'tokenId'.\r\n    function safeTransferFrom(address token, address sender, address recipient, uint256 value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, value)); // @dev transferFrom(address,address,uint256).\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"pull transfer failed\");\r\n    }\r\n    \r\n    /// @notice Provides 'safe' ETH transfer.\r\n    /// @param recipient Account to send ETH to.\r\n    /// @param value ETH amount to send.\r\n    function safeTransferETH(address recipient, uint256 value) private {\r\n        (bool success, ) = recipient.call{value: value}(\"\");\r\n        require(success, \"eth transfer failed\");\r\n    }\r\n}"
    }
  }
}