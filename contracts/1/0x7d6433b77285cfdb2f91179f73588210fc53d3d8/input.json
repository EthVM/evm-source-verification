{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PETARP.sol": {
      "content": "// File: @openzeppelin/contracts@4.4.0/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/token/ERC721/extensions/IERC721Enumerable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/token/ERC721/ERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts@4.4.0/token/ERC721/extensions/ERC721Enumerable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n * account.\r\n */\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\n// File: contract-3ca8ecdeb2.sol\r\n\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n\r\n\r\n\r\n// PETARP contract\r\n// to get the prg for a token:\r\n// call getTokenPRG( uint256 tokenId, bool unmodified )\r\n// the prg will be returned as bytes\r\ncontract PETARP is ERC721, ERC721Enumerable, Ownable {\r\n  using Counters for Counters.Counter;\r\n  using Strings for uint256;\r\n\r\n  string constant tokenName   = \"PETARP\";\r\n  string constant tokenSymbol = \"ARP\";\r\n\r\n  uint256 public mintPrice = .00256e18;\r\n  string private _tokenBaseURI = \"https://nopsta.com/petarp/meta/\";\r\n\r\n  // the number of seconds in a day\r\n  uint constant DAY_SECONDS = 24 * 60 * 60;\r\n\r\n  // can only mint up to 256 tokens\r\n  uint constant MAX_NUMBER_TOKENS = 256;\r\n\r\n  // each token has 8 parameters\r\n  uint constant PARAM_COUNT = 8;\r\n\r\n  // each token has 4 unlocks: color effect, detune effect, root note change, journey mode\r\n  uint constant UNLOCKS_COUNT = 4;\r\n\r\n  // a token owner can set 8 custom bytes\r\n  uint constant CUSTOM_BYTE_COUNT = 8;\r\n\r\n  // the default filter value (filter cutoff high)\r\n  uint8 constant FILTER_DEFAULT_VALUE = 22 * 8;\r\n\r\n  // the length of the prg in bytes\r\n  uint constant PRG_DATA_LENGTH = 2048;\r\n\r\n  // the position in the prg of the user settings\r\n  uint constant SETTINGS_POSITION = 1826;\r\n\r\n  // the position in the prg where the token parameters go\r\n  uint constant PARAM_START_POSITION = 1837;\r\n\r\n  // the base prg data, this is modified to produce the prg for each token\r\n  bytes constant basePRGData = hex\"01080b0800009e3230363100000078a96f8dfaffa90b8dfbffa9008d0edd8d05dd8d04dda9818d0ddda9018d0edda9358501a000a2fda9ff9dff039dfc049df9059dea06ad1f0f9dffd79dfcd89df9d99deada9401cad0de8cff0fa9128d18d08e0010a9048d1910bd00101869289d0110bd191069009d1a10e8e018d0eaa91f851aad12d0cd12d0f0fb30f6c920b002e626a20bbd200f952ecad0f88557ad2f0f291faa29f085febd8d0e8521ad2f0f4a4a4a4a4aaa4a262d8a2902852b8a29048522ad300f48290faa18bdd80e69ea8523a90e69008524684a4a4a4aaabd670e852ebd770e852fe001d0028619b1238d20d08d21d0af310f2903a8b9850e851b8a4a4a482907aabd850e851c684a4a4a2907aabd850e851dc645c64cc653a00a844284498450c643c651af2d0f851529b0851ead2e0f851629018520af2c0f85142910d00284518a2902d00284438a2901851fa9928546a9a28554a9e2854dad330f482907c901d0028551aabd170f8552684a4a4aae2d0f1009a6fef004a62e10024a4a852caf320f2907a8b90e0f85448a4a4a4a482907aabd110f854b0552c911d0028544684a4a4a29030522aabd820e8518a91f8558855520b70ce602ad12d0c9eed0f9a218b5409d00d4ca10f820830ba526f00ac63a1006a905853ad0dea24fb45df03ad6ad1036a52f95adbd32108503bd8210850488945dd01338e9d48504a9ff9103bd82108504ad1f0fb00cc8984aa8b123b0044a4a4a4aa0009103ca10bfc602f0034c540ba52e8502a51a290fc90830051849ff6911186901854aaaa50c2520f0028651a556a631e00410097d770b900ba9ffd007fd770bb002a9008556c6171008a5188517a5308556c61a101aa534f010a429c8c529d002a0008429b9e70e85fda91f851a8550a5350a6510291e8510f002e6321865218525a52ec906f00538e519852ea202d60a1014b51b950ad65a1006f614b537955ab514950d9511b50df0030a90024525950d290718652d7d520da88a051e0517d002a007b9390d850718b9200d652cac360ff00265fda88622bd610eaab9550d9540b9a90d9541a62220550e291fc9143002290f850620550e290fc90c300229078505a52b8508a50829010a8509a5064820fd0d38a927e506850620fd0d38a917e505850520fd0d68850620fd0da622ca30034cad0aad350ff00a18a547a6337d7e0b854718a550651fb00285504cbf0940ecf6fae8f4f8e700180c04180c040018120c06a528f005c6284caa0b8d02dcaf00dc2904f0788a2901f0358a2902f0478a2910f04c8a2908f07ba9ff8d02dca9008d03dca97f8d00dcaf01dcc53ff015853f2908d005a9024cc20c8a2901d005a9014cc20ca9fd8d00dcaf01dcc53bf01b853b2901d005a9044cc20c8a2908d00bc6311004a90685314cc90ca9fb8d00dcaf01dcc53cf037853c2901d01238a530e9089027853038a556e908901eb0178a2908d01a18a5306908c9f8f00e853018a5566908b00585568d16d44cc90ca9f78d00dcaf01dcc53df021853d2901d007ad340ff002e6328a2908d00fad350ff00ac6331004a9048533105da9ef8d00dcad01dcc53ef036853e2901d019ad360ff014a900852918a5346901c903d002a90085344cc90ca53e2908d011ad370ff00ca5354901853585328510101ba527f004c627f00160a227a9ff9dc007ca10f860455785578d17d0a9508527a9088528a202bd640e2557f004a9e9d002a9ee9dc007ca10eda431b9700b8dc307a9ec9dc507e8e01fd0f6a5304a4a4aaaa9ed9dc507a9eaa633f003bdcf0e8de507a5341869ea8de607a5354a69ea8de7076018130c100c101300241c181a181f1f23241c1817131f1a17240004020102010405060700080009090a0607000304090803060008102d4e7196bee8144374a9e11c5a9ce22d7ccf2885e852c137b439c55af79e4f0ad1a3826e68718ab3ee3c9e15a24604dcd0e21467dd793c29448d08b8a1c528cdbaf17853871a107142894f9b74e2f0a60e3320ff0202020202020303030303040404040505050606060707080809090a0a0b0c0d0d0e0f10111213141517181a1b1d1f20222427292b2e3134373a3e4145494e52575c62686e757c838b939ca5afb9c4d0ddeaf8ff18a605bd001065068503bd191069008504a000a5070a0a6508aabdac0e910318a50469d48504a00218b1236532a0009103a24fb55df003cad0f9a904955da52f95ada5039d3210a5049d821018a508690165092903850860b511f0030a9002452595116000070e0102040681080806e50608050706060706080603030705042e050303040703030303070b0f13171b1f20436f190367050f07090a0b5a25852103595bd15f62139a9fa7a9aba1afc3e7e8e7e8e9e9e9e9fbfcfefdebebebebececececededededeeeeeeeeeff0f2f1f3f4f6f5f7f8faf9eaeaeaea001e1b030c000f121518090306210300050700bcf101fcb00bcfa20a82940064e303557706eeee0488a70ea3a3064e3d028a7101e46511411141211141415141512111154121410f0027b00300000000000f0707010203040506070800000000c0e070381c0e070303070e1c3870e0c0003c7e7e7e7e3c00003c7e66667e3c001818181818181818000000ffff000000181818ffff181818c3e77e3c3c7ee7c3ffffc0c0c0c0c0c0ffff030303030303c0c0c0c0c0c0ffff030303030303ffff0000001f1f181818000000f8f81818181818181f1f000000181818f8f8000000000000070f1c1818000000e0f038181818181c0f07000000181838f0e0000000000103070f1f3f7f0080c0e0f0f8fcfeff7f3f1f0f070301fffefcf8f0e0c08000000000000000\";\r\n\r\n  // this event is emitted when a custom byte is set\r\n  event ByteSet( uint indexed tokenId, uint byteIndex, uint16 bytePosition, uint8 byteValue );\r\n\r\n  // TokenData has the values specific to each token\r\n  struct TokenData {\r\n    // 8 x 1 byte parameters stored in a uint64\r\n    uint64 params;\r\n\r\n    // 4 unlocks, 1 if unlocked, 0 otherwise\r\n    uint8[UNLOCKS_COUNT] unlocked;\r\n\r\n    // 8 custom bytes, set by the token owner\r\n    // bytes in the prg data will be replaced with these bytes\r\n    // customBytePosition is 0 if unset\r\n    uint16[CUSTOM_BYTE_COUNT] customBytePosition;\r\n    uint8[CUSTOM_BYTE_COUNT]  customByteValue;\r\n\r\n    // user data is used to store settings\r\n    uint24 userData;\r\n\r\n    // the last time the token was transferred\r\n    uint256 lastTransfer;\r\n  }\r\n\r\n  // mapping of tokenIds to the token's data\r\n  mapping(uint256 => TokenData) tokenData;\r\n\r\n  // the number of tokens minted. if less than 256 then this will also be the value of the next tokenId\r\n  Counters.Counter private _tokenIdCounter;\r\n\r\n  // keep track of which positions have been used per byte index\r\n  // a position can't be used if someone else has used it first (per byte index)\r\n  mapping( uint16 => uint8 )[CUSTOM_BYTE_COUNT] public positionUsed;\r\n\r\n  constructor() ERC721( tokenName, tokenSymbol ) {\r\n  }\r\n\r\n\r\n  // ------------------------- public/external functions with no access restrictions ------------------------- //\r\n\r\n  function mintToken()\r\n    public\r\n    payable\r\n    returns ( uint256 _tokenId )\r\n  {\r\n    require( _tokenIdCounter.current() < MAX_NUMBER_TOKENS, \"All tokens created\" );\r\n    require( msg.value >= mintPrice, \"The value sent must be at least the mint price\" );\r\n\r\n    uint256 tokenId = _tokenIdCounter.current();\r\n    _tokenIdCounter.increment();\r\n\r\n    _safeMint( msg.sender, tokenId );\r\n\r\n    tokenData[tokenId].params = uint64( bytes8( keccak256( abi.encodePacked( block.timestamp, msg.sender, tokenId.toString() ) ) ) );\r\n\r\n    tokenData[tokenId].lastTransfer = block.timestamp;\r\n\r\n    // increase price for tokens 128 - 255\r\n    if( tokenId == 127 ) {\r\n      mintPrice = .00512e18;\r\n    }\r\n\r\n    return tokenId;\r\n  }\r\n\r\n  // convert a 5 bit number (0-31) stored in user data\r\n  // to the 8 bit number (0-240) used as the prg's initial filter value\r\n  function filterValue( uint8 v )\r\n    internal\r\n    pure\r\n    returns ( uint8 )\r\n  {\r\n    if( v == 0 ) {\r\n      // zero means use the filter default value\r\n      return FILTER_DEFAULT_VALUE;\r\n    } else {\r\n      return (v - 1) * 8;\r\n    }\r\n  }\r\n\r\n  // return the prg for a token as bytes\r\n  // if unmodified is true, don't set any owner custom bytes or settings\r\n  function getTokenPRG( uint256 tokenId, bool unmodified )\r\n    public\r\n    view\r\n    returns ( bytes memory )\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n\r\n    bytes memory tokenPRG = basePRGData;\r\n\r\n    // get the token's parameters and insert them into the prg data\r\n    uint8 p0;\r\n    uint8 p1;\r\n    uint8 p2;\r\n    uint8 p3;\r\n    uint8 p4;\r\n    uint8 p5;\r\n    uint8 p6;\r\n    uint8 p7;\r\n\r\n    (p0, p1, p2, p3, p4, p5, p6, p7) = getTokenParams( tokenId );\r\n\r\n    tokenPRG[PARAM_START_POSITION]     = bytes1( p0 );\r\n    tokenPRG[PARAM_START_POSITION + 1] = bytes1( p1 );\r\n    tokenPRG[PARAM_START_POSITION + 2] = bytes1( p2 );\r\n    tokenPRG[PARAM_START_POSITION + 3] = bytes1( p3 );\r\n    tokenPRG[PARAM_START_POSITION + 4] = bytes1( p4 );\r\n    tokenPRG[PARAM_START_POSITION + 5] = bytes1( p5 );\r\n    tokenPRG[PARAM_START_POSITION + 6] = bytes1( p6 );\r\n    tokenPRG[PARAM_START_POSITION + 7] = bytes1( p7 );\r\n\r\n    // modify the prg to set the state of the unlocks\r\n    for( uint i = 0; i < UNLOCKS_COUNT; i++) {\r\n      tokenPRG[PARAM_START_POSITION + 8 + i] = bytes1( tokenData[tokenId].unlocked[i] );\r\n    }\r\n\r\n    // if unmodified is false, set any custom bytes and settings set by the current or a previous owner\r\n    if( !unmodified ) {\r\n\r\n      // read the user settings from the 24 bit user data number\r\n\r\n      // filter routing (inverted) add the resonance value (32)  (3 bits)\r\n      tokenPRG[SETTINGS_POSITION] = bytes1( uint8( ( ( tokenData[tokenId].userData & 7 ) ^ 7 ) + 32 ) );\r\n\r\n      // filter value (0-31). if 0, set to the default value, otherwise subtract 1 and multiply by 8 (5 bits)\r\n      tokenPRG[SETTINGS_POSITION + 1] = bytes1( filterValue ( uint8( ( tokenData[tokenId].userData >> 3 ) & 31 ) ) );\r\n\r\n      // filter mode (0-6). if 0, set to the default value (3) (3 bits)\r\n      tokenPRG[SETTINGS_POSITION + 2] = bytes1( uint8( ( ( ( tokenData[tokenId].userData >> 8 ) & 7 ) + 3 ) % 7 ) );\r\n\r\n      // color offset effect value (0-15) (4 bits)\r\n      if( tokenData[tokenId].unlocked[0] != 0 ) {\r\n        tokenPRG[SETTINGS_POSITION + 3] = bytes1( uint8( ( tokenData[tokenId].userData >> 11 ) & 15) );\r\n      }\r\n\r\n      // detune effect (0-4) (3 bits)\r\n      if( tokenData[tokenId].unlocked[1] != 0 ) {\r\n        tokenPRG[SETTINGS_POSITION + 4] = bytes1( uint8( ( ( tokenData[tokenId].userData >> 15 ) & 7 ) % 5 ) );\r\n      }\r\n\r\n      // root note change effect (0-2) (2 bits)\r\n      if( tokenData[tokenId].unlocked[2] != 0 ) {\r\n        tokenPRG[SETTINGS_POSITION + 5] = bytes1( uint8( ( ( tokenData[tokenId].userData >> 18 ) & 3 ) % 3 ) );\r\n      }\r\n\r\n      // journey mode off/on (0-1) (1 bit)\r\n      if( tokenData[tokenId].unlocked[3] != 0 ) {\r\n        tokenPRG[SETTINGS_POSITION + 6] = bytes1( uint8( ( tokenData[tokenId].userData >> 20 ) & 1 ) );\r\n      }\r\n\r\n      // include user defined custom bytes if bit 21 is zero\r\n      if( ( tokenData[tokenId].userData >> 21 ) & 1 == 0 ) {\r\n\r\n        uint16 customBytePosition = 0;\r\n        for( uint i = 0; i < CUSTOM_BYTE_COUNT; i++ ) {\r\n          customBytePosition = tokenData[tokenId].customBytePosition[i];\r\n\r\n          if( customBytePosition != 0 && customBytePosition < PRG_DATA_LENGTH ) {\r\n            tokenPRG[customBytePosition] = bytes1( tokenData[tokenId].customByteValue[i] );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // insert the token id into the prg\r\n    tokenPRG[SETTINGS_POSITION + 7] = bytes1( uint8( tokenId ) );\r\n\r\n    return tokenPRG;\r\n  }\r\n\r\n  // get the uint64 the prg params are made from\r\n  function getTokenSeed( uint256 tokenId )\r\n    external\r\n    view\r\n    returns ( uint64 p )\r\n  {\r\n    p = tokenData[tokenId].params;\r\n  }\r\n\r\n  // return the 8 parameters for the token as uint8s\r\n  function getTokenParams( uint256 tokenId )\r\n    public\r\n    view\r\n    returns ( uint8 p0, uint8 p1, uint8 p2, uint8 p3, uint8 p4, uint8 p5, uint8 p6, uint8 p7 )\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n\r\n    uint params = tokenData[tokenId].params;\r\n\r\n    p0 =  uint8( params & 255 );\r\n    p1 =  uint8( (params >> 8) & 255 );\r\n    p2 =  uint8( (params >> 16) & 255 );\r\n    p3 =  uint8( (params >> 24) & 255 );\r\n    p4 =  uint8( (params >> 32) & 255 );\r\n    p5 =  uint8( (params >> 40) & 255 );\r\n    p6 =  uint8( (params >> 48) & 255 );\r\n    p7 =  uint8( (params >> 56) & 255 );\r\n\r\n  }\r\n\r\n  // return the state of the 4 unlocks for the token, 1 = unlocked\r\n  function getTokenUnlocks( uint256 tokenId )\r\n    external\r\n    view\r\n    returns ( uint8 u0, uint8 u1, uint8 u2, uint8 u3 )\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n\r\n    u0 = tokenData[tokenId].unlocked[0];\r\n    u1 = tokenData[tokenId].unlocked[1];\r\n    u2 = tokenData[tokenId].unlocked[2];\r\n    u3 = tokenData[tokenId].unlocked[3];\r\n  }\r\n\r\n  // return an owner set custom byte for the token\r\n  // byteIndex is 0 - 7 (8 custom bytes per token)\r\n  // if a byte is not set, its position will be 0\r\n  function getTokenCustomByte( uint256 tokenId, uint256 byteIndex )\r\n    external\r\n    view\r\n    returns ( uint16 position, uint8 value )\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n    require( byteIndex < CUSTOM_BYTE_COUNT, \"Invalid byte index\" );\r\n\r\n    position = tokenData[tokenId].customBytePosition[byteIndex];\r\n    value    = tokenData[tokenId].customByteValue[byteIndex];\r\n  }\r\n\r\n  // return all the custom bytes for a token in an array\r\n  function getTokenCustomBytes( uint256 tokenId )\r\n    external\r\n    view\r\n    returns ( uint16[CUSTOM_BYTE_COUNT] memory position, uint8[CUSTOM_BYTE_COUNT] memory value )\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n\r\n    position = tokenData[tokenId].customBytePosition;\r\n    value    = tokenData[tokenId].customByteValue;\r\n  }\r\n\r\n\r\n  // return the user data containing the settings for a token\r\n  function getTokenUserData( uint256 tokenId )\r\n    external\r\n    view\r\n    returns ( uint24 userData )\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n\r\n    userData = tokenData[tokenId].userData;\r\n  }\r\n\r\n  // return the time in seconds since a token was last transferred\r\n  function getSecondsSinceLastTransfer( uint tokenId )\r\n    external\r\n    view\r\n    returns(uint)\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n\r\n    return block.timestamp - tokenData[tokenId].lastTransfer;\r\n  }\r\n\r\n  function supportsInterface( bytes4 interfaceId )\r\n    public\r\n    view\r\n    override( ERC721, ERC721Enumerable )\r\n    returns ( bool )\r\n  {\r\n      return super.supportsInterface( interfaceId );\r\n  }\r\n\r\n  // ------------------------- internal unrestricted functions ------------------------- //\r\n\r\n  function _baseURI()\r\n    internal\r\n    view\r\n    override\r\n    returns ( string memory )\r\n  {\r\n    return _tokenBaseURI;\r\n  }\r\n\r\n  function _beforeTokenTransfer( address from, address to, uint256 tokenId )\r\n    internal\r\n    override( ERC721, ERC721Enumerable )\r\n  {\r\n    super._beforeTokenTransfer( from, to, tokenId );\r\n\r\n    // set the time the token was last transferred to the current timestamp\r\n    if( tokenId < _tokenIdCounter.current() ) {\r\n      tokenData[tokenId].lastTransfer = block.timestamp;\r\n    }\r\n  }\r\n\r\n  // ------------------------- token owner functions ------------------------- //\r\n\r\n  // check if the sender address can set a byte for the token\r\n  // the token owner can set up to 8 bytes for a token (byteIndex can be 0-7)\r\n  // each byteIndex can be set if the token has been held for byteIndex x 64 days\r\n  function checkCanSetByte( address sender, uint tokenId, uint byteIndex, uint16 bytePosition )\r\n    public\r\n    view\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n    require( ERC721.ownerOf(tokenId) == sender, \"Only owner can set bytes\" );\r\n\r\n    require( byteIndex < CUSTOM_BYTE_COUNT, \"Invalid byte index\" );\r\n    require( bytePosition < basePRGData.length, \"Invalid position\" );\r\n    require( bytePosition < PARAM_START_POSITION || bytePosition >= PARAM_START_POSITION + 12, \"Can't set param bytes\" );\r\n    require( bytePosition < SETTINGS_POSITION || bytePosition >= SETTINGS_POSITION + 8, \"Can't set settings bytes\" );\r\n\r\n    uint timeRequirement = ( byteIndex + 1 ) * 64 * DAY_SECONDS;\r\n    string memory message = string( abi.encodePacked( \"Since last transfer needs to be greater than \", timeRequirement.toString() ) );\r\n\r\n    if ( bytePosition != 0 ) {\r\n      require( ( block.timestamp - tokenData[tokenId].lastTransfer) >= timeRequirement, message );\r\n    }\r\n\r\n    require( bytePosition == 0 || bytePosition == tokenData[tokenId].customBytePosition[byteIndex] || positionUsed[byteIndex][bytePosition] == 0, \"Position already used\" );\r\n\r\n  }\r\n\r\n\r\n  // set a byte\r\n  function setByte( uint tokenId, uint byteIndex, uint16 bytePosition, uint8 byteValue )\r\n    public\r\n  {\r\n    checkCanSetByte( msg.sender, tokenId, byteIndex, bytePosition );\r\n\r\n    // if the new position is different to the previous position for the byte index\r\n    // mark the previous position as unused and the new position as used\r\n    if( tokenData[tokenId].customBytePosition[byteIndex] != bytePosition ) {\r\n      positionUsed[byteIndex][tokenData[tokenId].customBytePosition[byteIndex]] = 0;\r\n      positionUsed[byteIndex][bytePosition] = 1;\r\n    }\r\n\r\n    // save the values\r\n    tokenData[tokenId].customBytePosition[byteIndex]  = bytePosition;\r\n    tokenData[tokenId].customByteValue[byteIndex]     = byteValue;\r\n\r\n    // emit the event\r\n    emit ByteSet( tokenId, byteIndex, bytePosition, byteValue );\r\n\r\n  }\r\n\r\n  // set all the bytes with one call\r\n  function setBytes( uint tokenId, uint16[CUSTOM_BYTE_COUNT] memory bytePositions, uint8[CUSTOM_BYTE_COUNT] memory byteValues )\r\n    public\r\n  {\r\n    // fail if one of the bytes can't be set\r\n    for( uint i = 0; i < CUSTOM_BYTE_COUNT; i++ ) {\r\n      checkCanSetByte( msg.sender, tokenId, i, bytePositions[i] );\r\n    }\r\n\r\n    for( uint i = 0; i < CUSTOM_BYTE_COUNT; i++ ) {\r\n      setByte( tokenId, i, bytePositions[i], byteValues[i] );\r\n    }\r\n  }\r\n\r\n  // can unlock a feature if:\r\n  // tokenId is valid\r\n  // unlock index is valid\r\n  // sender is the owner of the token\r\n  // unlock ownership/time requirements are met\r\n  function checkCanUnlock( address sender, uint tokenId, uint unlockIndex )\r\n    public\r\n    view\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n    require( unlockIndex < UNLOCKS_COUNT, \"Invalid lock\" );\r\n    require( ERC721.ownerOf( tokenId ) == sender, \"Only owner can unlock\" );\r\n\r\n    // time constraint: 32, 64, 128, 256 days\r\n    uint timeRequirement = ( 2 ** unlockIndex ) * 32 * DAY_SECONDS;\r\n    string memory message = string( abi.encodePacked( \"Since Last Transfer needs to be \", timeRequirement.toString() ) );\r\n\r\n    require( ( block.timestamp - tokenData[tokenId].lastTransfer ) >= timeRequirement, message );\r\n\r\n    if( unlockIndex == 0 ) {\r\n      // to unlock 0, need to own at least 2\r\n      require( ERC721.balanceOf( sender ) > 1, \"Need to own 2 or more\" );\r\n    }\r\n\r\n    // to unlock 3, need to satisfy time constraint and own at least 4\r\n    if( unlockIndex == 3 ) {\r\n      require( ERC721.balanceOf( sender ) > 3, \"Need to own 4 or more\" );\r\n    }\r\n  }\r\n\r\n  // set a feature as unlocked\r\n  function unlock( uint256 tokenId, uint256 unlockIndex )\r\n    external\r\n  {\r\n    checkCanUnlock( msg.sender, tokenId, unlockIndex );\r\n\r\n    // set as unlocked\r\n    tokenData[tokenId].unlocked[unlockIndex] = 1;\r\n  }\r\n\r\n  function checkCanSetUserData( address sender, uint tokenId )\r\n    public\r\n    view\r\n  {\r\n    require( tokenId < _tokenIdCounter.current(), \"Invalid token id\" );\r\n    require( ERC721.ownerOf( tokenId ) == sender, \"Only owner can set user data\" );\r\n  }\r\n\r\n  // user settings for the token\r\n  function setTokenUserData ( uint tokenId, uint24 userData )\r\n    external\r\n  {\r\n    checkCanSetUserData( msg.sender, tokenId );\r\n\r\n    tokenData[tokenId].userData = userData;\r\n  }\r\n\r\n  // set byte and user data\r\n  function setByteAndUserData( uint tokenId, uint byteIndex, uint16 bytePosition, uint8 byteValue, uint24 userData )\r\n    external\r\n  {\r\n    setByte( tokenId, byteIndex, bytePosition, byteValue );\r\n\r\n    checkCanSetUserData( msg.sender, tokenId );\r\n    tokenData[tokenId].userData = userData;\r\n  }\r\n\r\n  // ------------------------- contract owner only functions ------------------------- //\r\n\r\n  function setMintPrice( uint256 price )\r\n    external\r\n    Ownable.onlyOwner\r\n  {\r\n    mintPrice = price;\r\n  }\r\n\r\n  function withdraw( uint amount )\r\n    external\r\n    Ownable.onlyOwner\r\n  {\r\n    require( amount <= address( this ).balance, \"Insufficient funds\" );\r\n\r\n    payable( msg.sender ).transfer( amount );\r\n  }\r\n\r\n  function setBaseURI( string memory baseURI )\r\n    external\r\n    Ownable.onlyOwner {\r\n    _tokenBaseURI = baseURI;\r\n  }\r\n}"
    }
  }
}