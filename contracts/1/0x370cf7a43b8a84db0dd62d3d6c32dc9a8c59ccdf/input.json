{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FLIP sourcecode2.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2019-06-25\r\n*/\r\n\r\n/*\r\n * 컨트랙트 개요\r\n * 1. 목적\r\n *  메인넷 운영이 시작되기 전까지 한시적인 운영을 목적으로 하고 있다.\r\n *  메인넷이 운영되면 컨트랙트의 거래는 모두 중단되며, 메인넷 코인트로 전환을 시작하며,\r\n *  전환 절차를 간단하게 수행할 수 있으며, 블록체인 내 기록을 통해 신뢰도를 얻을 수 있도록 설계 되었다.\r\n * 2. 용어 설명\r\n *  Owner : 컨트랙트를 생성한 컨트랙트의 주인\r\n *  Delegator : Owner의 Private Key를 매번 사용하기에는 보안적인 이슈가 발생할 수 있기 때문에 도입된\r\n *              일부 Owner 권한을 실행할 수 있도록 임명한 대행자\r\n *              특히, 컨트랙트의 거래가 중단된 상태에서 Delegator만 실행할 수 있는 전용 함수를 실행하여\r\n *              컨트랙트의 토큰을 회수하고, 메인넷의 코인으로 전환해주는 핵심적인 기능을 수행\r\n *  Holder : 토큰을 보유할 수 있는 Address를 가지고 있는 계정\r\n * 3. 운용\r\n *  3.1. TokenContainer Structure\r\n *   3.1.1 Charge Amount\r\n *    Charge Amount는 Holder가 구매하여 충전한 토큰량입니다.\r\n *    Owner의 경우에는 컨트랙트 전체에 충전된 토큰량. 즉, Total Supply와 같습니다.\r\n *   3.1.2 Unlock Amount\r\n *    기본적으로 모든 토큰은 Lock 상태인 것이 기본 상태이며, Owner 또는 Delegator가 Unlock 해준 만큼 Balance로 전환됩니다.\r\n *    Unlock Amount는 Charge Amount 중 Unlock 된 만큼만 표시합니다.\r\n *    Unlock Amount는 Charge Amount 보다 커질 수 없습니다.\r\n *   3.1.3 Balance\r\n *    ERC20의 Balance와 같으며, 기본적으로는 Charge Amount - Unlock Amount 값에서 부터 시작합니다.\r\n *    자유롭게 거래가 가능하므로 Balance는 더 크거나 작아질 수 있습니다.\r\n * 4. 토큰 -> 코인 전환 절차\r\n *  4.1. Owner 권한으로 컨트랙트의 거래를 완전히 중단 시킴(lock())\r\n *  4.2. 교환을 실행하기 위한 ExchangeContract를 생성\r\n *  4.3. ExchangeContract의 Address를 Owner의 권한으로 Delegator로 지정\r\n *  4.4. Holder가 ExchangeContract의 exchangeSYM()을 실행하여 잔액을 ExchangeHolder에게 모두 전달\r\n *  4.5. ExchangeHolder로의 입금을 확인\r\n *  4.6. 요청에 대응되는 메인넷의 계정으로 해당되는 양만큼 송금\r\n *  4.7. ExchangeContract의 withdraw()를 사용하여 Owner가 최종적으로 회수하는 것으로 전환절차 완료\r\n */\r\n /*\r\n  *  * Contract Overview \r\n * 1. Purpose\r\n *  It is intended to operate for a limited time until mainnet launch.\r\n *  When the mainnet is launched, all transactions of the contract will be suspended from that day on forward and will initiate the token swap to the mainnet.\r\n * 2. Key Definitions\r\n *  Owner : An entity from which smart contract is created\r\n *  Delegator : The appointed agent is created to prevent from using the contract owner's private key for every transaction made, since it can cause a serious security issue.  \r\n *              In particular, it performs core functons at the time of the token swap event, such as executing a dedicated, Delegator-specific function while contract transaction is under suspension and\r\n *              withdraw contract's tokens. \r\n *  Holder : An account in which tokens can be stored (also referrs to all users of the contract: Owner, Delegator, Spender, ICO buyers, ect.)\r\n * 3. Operation\r\n *  3.1. TokenContainer Structure\r\n *   3.1.1 Charge Amount\r\n *    Charge Amount is the charged token amount purcahsed by Holder.\r\n *    In case for the Owner, the total charged amount in the contract equates to the Total Supply.\r\n *   3.1.2 Unlock Amount\r\n *    Generally, all tokens are under a locked state by default and balance appears according to the amount that Owner or Delegator Unlocks.\r\n *    Unlock Amount only displays tokens that are unlocked from the Charge Amount.\r\n *    Unlock Amount cannot be greater than the Charge Amount.\r\n *   3.1.3 Balance\r\n *     Similiar to the ERC20 Balance; It starts from Charged Amount - Unlock Amount value.\r\n *     You can send & receive tokens at will and it will offset the Balance amount accordingly.\r\n * 4. Token Swap Process\r\n *  4.1. Completely suspend trading operations from the contract address with owner privileges (lock ()).\r\n *  4.2. Create an ExchangeContract contract to execute the exchange.\r\n *  4.3. Owner appoints the ExchangeContract address to the Delegator.\r\n *  4.4. The Holder executes an exchangeSYM() embedded in the ExchangeContract to transfer all the Balance to ExchangeHolder\r\n *  4.5. Verify ExchangeHolder's deposit amount. \r\n *  4.6. Remit an appropriate amount into the mainnet account that corresponds to the request.  \r\n *  4.7. By using the ExchangeContract's withdraw(), the token swap process completes as the Owner makes the final withdrawal.\r\n  */\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /*\r\n     * 운용상 Owner 변경은 사용하지 않으므로 권한 변경 함수 제거하였다.\r\n     */\r\n    /*\r\n     * The privilege change function is removed since the Owner change isn't used during the operation.\r\n     */\r\n    /* not used\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    */\r\n}\r\n\r\n/*\r\n * Owner의 권한 중 일부를 대신 행사할 수 있도록 대행자를 지정/해제 할 수 있는 인터페이스를 정의하고 있다.\r\n */\r\n /*\r\n * It defines an interface where the Owner can appoint / dismiss an agent that can partially excercize privileges in lieu of the Owner's \r\n */\r\ncontract Delegable is Ownable {\r\n    address private _delegator;\r\n    \r\n    event DelegateAppointed(address indexed previousDelegator, address indexed newDelegator);\r\n    \r\n    constructor () internal {\r\n        _delegator = address(0);\r\n    }\r\n    \r\n    /*\r\n     * delegator를 가져옴\r\n     */\r\n    /*\r\n     * Call-up Delegator\r\n     */\r\n    function delegator() public view returns (address) {\r\n        return _delegator;\r\n    }\r\n    \r\n    /*\r\n     * delegator만 실행 가능하도록 지정하는 접근 제한\r\n     */\r\n    /*\r\n     * Access restriction in which only appointed delegator is executable\r\n     */\r\n    modifier onlyDelegator() {\r\n        require(isDelegator());\r\n        _;\r\n    }\r\n    \r\n    /*\r\n     * owner 또는 delegator가 실행 가능하도록 지정하는 접근 제한\r\n     */\r\n    /*\r\n     * Access restriction in which only appointed delegator or Owner are executable\r\n     */\r\n    modifier ownerOrDelegator() {\r\n        require(isOwner() || isDelegator());\r\n        _;\r\n    }\r\n    \r\n    function isDelegator() public view returns (bool) {\r\n        return msg.sender == _delegator;\r\n    }\r\n    \r\n    /*\r\n     * delegator를 임명\r\n     */\r\n    /*\r\n     * Appoint the delegator\r\n     */\r\n    function appointDelegator(address delegator) public onlyOwner returns (bool) {\r\n        require(delegator != address(0));\r\n        require(delegator != owner());\r\n        return _appointDelegator(delegator);\r\n    }\r\n    \r\n    /*\r\n     * 지정된 delegator를 해임\r\n     */\r\n    /*\r\n     * Dimiss the appointed delegator\r\n     */\r\n    function dissmissDelegator() public onlyOwner returns (bool) {\r\n        require(_delegator != address(0));\r\n        return _appointDelegator(address(0));\r\n    }\r\n    \r\n    /*\r\n     * delegator를 변경하는 내부 함수\r\n     */\r\n    /*\r\n     * An internal function that allows delegator changes \r\n     */\r\n    function _appointDelegator(address delegator) private returns (bool) {\r\n        require(_delegator != delegator);\r\n        emit DelegateAppointed(_delegator, delegator);\r\n        _delegator = delegator;\r\n        return true;\r\n    }\r\n}\r\n\r\n/*\r\n * ERC20의 기본 인터페이스는 유지하여 일반적인 토큰 전송이 가능하면서,\r\n * 일부 추가 관리 기능을 구현하기 위한 Struct 및 함수가 추가되어 있습니다.\r\n * 특히, 토큰 -> 코인 교환을 위한 Delegator 임명은 Owner가 직접 수행할 컨트랙트의 주소를 임명하기 때문에\r\n * 외부에서 임의로 권한을 획득하기 매우 어려운 구조를 가집니다.\r\n * 또한, exchange() 함수의 실행은 ExchangeContract에서 Holder가 직접 exchangeSYM() 함수를\r\n * 실행한 것이 트리거가 되기 때문에 임의의 사용자가 다른 사람의 토큰을 탈취할 수 없습니다.\r\n */\r\n /*\r\n * The basic interface of ERC20 is remained untouched therefore basic functions like token transactions will be available. \r\n * On top of that, Structs and functions have been added to implement some additional management functions.\r\n * In particular, we created an additional Delegator agent to initiate the token swap so that the swap is performed by the delegator but directly from the Owner's contract address.\r\n * By implementing an additional agent, it has built a difficult structure to acquire rights arbitrarily from the outside.\r\n * In addition, the execution of exchange() cannot be taken by any other Holders' because the exchangeSYM() is triggered directly by the Holder's execution \r\n */\r\ncontract ERC20Like is IERC20, Delegable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal _totalSupply;  // 총 발행량 // Total Supply\r\n    bool isLock = false;  // 계약 잠금 플래그 // Contract Lock Flag\r\n\r\n    /*\r\n     * 토큰 정보(충전량, 해금량, 가용잔액) 및 Spender 정보를 저장하는 구조체\r\n     */\r\n    /*\r\n     * Structure that stores token information (charge, unlock, balance) as well as Spender information\r\n     */\r\n    struct TokenContainer {\r\n        uint256 chargeAmount; // 충전량 // charge amount\r\n        uint256 unlockAmount; // 해금량 // unlock amount\r\n        uint256 balance;  // 가용잔액 // available balance\r\n        mapping (address => uint256) allowed; // Spender\r\n    }\r\n\r\n    mapping (address => TokenContainer) internal _tokenContainers;\r\n    \r\n    event ChangeCirculation(uint256 circulationAmount);\r\n    event Charge(address indexed holder, uint256 chargeAmount, uint256 unlockAmount);\r\n    event IncreaseUnlockAmount(address indexed holder, uint256 unlockAmount);\r\n    event DecreaseUnlockAmount(address indexed holder, uint256 unlockAmount);\r\n    event Exchange(address indexed holder, address indexed exchangeHolder, uint256 amount);\r\n    event Withdraw(address indexed holder, uint256 amount);\r\n\r\n    // 총 발행량 \r\n    // Total token supply \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    // 가용잔액 가져오기\r\n    // Call-up available balance\r\n    function balanceOf(address holder) public view returns (uint256) {\r\n        return _tokenContainers[holder].balance;\r\n    }\r\n\r\n    // Spender의 남은 잔액 가져오기\r\n    // Call-up Spender's remaining balance\r\n    function allowance(address holder, address spender) public view returns (uint256) {\r\n        return _tokenContainers[holder].allowed[spender];\r\n    }\r\n\r\n    // 토큰송금\r\n    // Transfer token\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    // Spender 지정 및 금액 지정\r\n    // Appoint a Spender and set an amount \r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    // Spender 토큰송금\r\n    // Transfer token via Spender \r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _transfer(from, to, value);\r\n        _approve(from, msg.sender, _tokenContainers[from].allowed[msg.sender].sub(value));\r\n        return true;\r\n    }\r\n\r\n    // Spender가 할당 받은 양 증가\r\n    // Increase a Spender amount alloted by the Owner/Delegator\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(!isLock);\r\n        uint256 value = _tokenContainers[msg.sender].allowed[spender].add(addedValue);\r\n        if (msg.sender == owner()) {  // Sender가 계약 소유자인 경우 전체 발행량 조절\r\n            require(_tokenContainers[msg.sender].chargeAmount >= _tokenContainers[msg.sender].unlockAmount.add(addedValue));\r\n            _tokenContainers[msg.sender].unlockAmount = _tokenContainers[msg.sender].unlockAmount.add(addedValue);\r\n            _tokenContainers[msg.sender].balance = _tokenContainers[msg.sender].balance.add(addedValue);\r\n        }\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    // Spender가 할당 받은 양 감소\r\n    // Decrease a Spender amount alloted by the Owner/Delegator\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(!isLock);\r\n        // 기존에 할당된 금액의 잔액보다 더 많은 금액을 줄이려고 하는 경우 할당액이 0이 되도록 처리\r\n        //// If you reduce more than the alloted amount in the balance, we made sure the alloted amount is set to zero instead of minus\r\n        if (_tokenContainers[msg.sender].allowed[spender] < subtractedValue) {\r\n            subtractedValue = _tokenContainers[msg.sender].allowed[spender];\r\n        }\r\n        \r\n        uint256 value = _tokenContainers[msg.sender].allowed[spender].sub(subtractedValue);\r\n        if (msg.sender == owner()) {  // Sender가 계약 소유자인 경우 전체 발행량 조절 // // Adjust the total circulation amount if the Sender equals the contract owner\r\n            _tokenContainers[msg.sender].unlockAmount = _tokenContainers[msg.sender].unlockAmount.sub(subtractedValue);\r\n            _tokenContainers[msg.sender].balance = _tokenContainers[msg.sender].balance.sub(subtractedValue);\r\n        }\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    // 토큰송금 내부 실행 함수 \r\n    // An internal execution function for troken transfer\r\n    function _transfer(address from, address to, uint256 value) private {\r\n        require(!isLock);\r\n        // 3.1. Known vulnerabilities of ERC-20 token\r\n        // 현재 컨트랙트로는 송금할 수 없도록 예외 처리 // Exceptions were added to not allow deposits to be made in the current contract . \r\n        require(to != address(this));\r\n        require(to != address(0));\r\n\r\n        _tokenContainers[from].balance = _tokenContainers[from].balance.sub(value);\r\n        _tokenContainers[to].balance = _tokenContainers[to].balance.add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    // Spender 지정 내부 실행 함수\r\n    // Internal execution function for assigning a Spender\r\n    function _approve(address holder, address spender, uint256 value) private {\r\n        require(!isLock);\r\n        require(spender != address(0));\r\n        require(holder != address(0));\r\n\r\n        _tokenContainers[holder].allowed[spender] = value;\r\n        emit Approval(holder, spender, value);\r\n    }\r\n\r\n    /* extension */\r\n    /**\r\n     * 충전량 \r\n     */\r\n    /**\r\n     * Charge Amount \r\n     */\r\n    function chargeAmountOf(address holder) external view returns (uint256) {\r\n        return _tokenContainers[holder].chargeAmount;\r\n    }\r\n\r\n    /**\r\n     * 해금량\r\n     */\r\n    /**\r\n     * Unlock Amount\r\n     */\r\n    function unlockAmountOf(address holder) external view returns (uint256) {\r\n        return _tokenContainers[holder].unlockAmount;\r\n    }\r\n\r\n    /**\r\n     * 가용잔액\r\n     */\r\n    /**\r\n     * Available amount in the balance\r\n     */\r\n    function availableBalanceOf(address holder) external view returns (uint256) {\r\n        return _tokenContainers[holder].balance;\r\n    }\r\n\r\n    /**\r\n     * Holder의 계정 잔액 요약 출력(JSON 포맷)\r\n     */\r\n    /**\r\n     * An output of Holder's account balance summary (JSON format)\r\n     */\r\n    function receiptAccountOf(address holder) external view returns (string memory) {\r\n        bytes memory blockStart = bytes(\"{\");\r\n        bytes memory chargeLabel = bytes(\"\\\"chargeAmount\\\" : \\\"\");\r\n        bytes memory charge = bytes(uint2str(_tokenContainers[holder].chargeAmount));\r\n        bytes memory unlockLabel = bytes(\"\\\", \\\"unlockAmount\\\" : \\\"\");\r\n        bytes memory unlock = bytes(uint2str(_tokenContainers[holder].unlockAmount));\r\n        bytes memory balanceLabel = bytes(\"\\\", \\\"availableBalance\\\" : \\\"\");\r\n        bytes memory balance = bytes(uint2str(_tokenContainers[holder].balance));\r\n        bytes memory blockEnd = bytes(\"\\\"}\");\r\n\r\n        string memory receipt = new string(blockStart.length + chargeLabel.length + charge.length + unlockLabel.length + unlock.length + balanceLabel.length + balance.length + blockEnd.length);\r\n        bytes memory receiptBytes = bytes(receipt);\r\n\r\n        uint readIndex = 0;\r\n        uint writeIndex = 0;\r\n\r\n        for (readIndex = 0; readIndex < blockStart.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = blockStart[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < chargeLabel.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = chargeLabel[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < charge.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = charge[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < unlockLabel.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = unlockLabel[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < unlock.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = unlock[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < balanceLabel.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = balanceLabel[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < balance.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = balance[readIndex];\r\n        }\r\n        for (readIndex = 0; readIndex < blockEnd.length; readIndex++) {\r\n            receiptBytes[writeIndex++] = blockEnd[readIndex];\r\n        }\r\n\r\n        return string(receiptBytes);\r\n    }\r\n\r\n    // uint 값을 string 으로 변환하는 내부 함수\r\n    // An internal function that converts an uint value to a string\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    // 전체 유통량 - Owner의 unlockAmount\r\n    // Total circulation supply, or the unlockAmount of the Owner's\r\n    function circulationAmount() external view returns (uint256) {\r\n        return _tokenContainers[owner()].unlockAmount;\r\n    }\r\n\r\n    // 전체 유통량 증가\r\n    // Increase the token's total circulation supply \r\n    /*\r\n     * 컨트랙트 상에 유통되는 토큰량을 증가 시킵니다.\r\n     * Owner가 보유한 전체 토큰량에서 Unlock 된 양 만큼이 현재 유통량이므로,\r\n     * Unlock Amount와 Balance 가 증가하며, Charge Amount는 변동되지 않습니다.\r\n     */\r\n    /*\r\n     * This function increases the amount of circulated tokens that are distributed on the contract.\r\n     * The circulated token is referring to the Unlock tokens out of the contract Owner's total supply, so the Charge Amount is not affected (refer back to the Balance definition above).\r\n     * This function increases in the Unlock Amount as well as in the Balance.\r\n     */\r\n    function increaseCirculation(uint256 amount) external onlyOwner returns (uint256) {\r\n        require(!isLock);\r\n        require(_tokenContainers[msg.sender].chargeAmount >= _tokenContainers[msg.sender].unlockAmount.add(amount));\r\n        _tokenContainers[msg.sender].unlockAmount = _tokenContainers[msg.sender].unlockAmount.add(amount);\r\n        _tokenContainers[msg.sender].balance = _tokenContainers[msg.sender].balance.add(amount);\r\n        emit ChangeCirculation(_tokenContainers[msg.sender].unlockAmount);\r\n        return _tokenContainers[msg.sender].unlockAmount;\r\n    }\r\n\r\n    // 전체 유통량 감소\r\n    // Reduction of the token's total supply\r\n    /*\r\n     * 컨트랙트 상에 유통되는 토큰량을 감소 시킵니다.\r\n     * Owner가 보유한 전체 토큰량에서 Unlock 된 양 만큼이 현재 유통량이므로,\r\n     * Unlock Amount와 Balance 가 감소하며, Charge Amount는 변동되지 않습니다.\r\n     * Owner만 실행할 수 있으며, 정책적인 계획에 맞추어 실행되어야하므로 0보다 작아지는 값이 입력되는 경우 실행을 중단합니다.\r\n     */\r\n    /*\r\n     * This function decreases the amount of circulated tokens that are distributed on the contract.\r\n     * The circulated token is referring to the Unlock tokens out of the contract Owner's total supply, so the Charge Amount is not affected (refer back to the Balance definition above).\r\n     * This function decreases in the Unlock Amount as well as in the Balance.\r\n     */\r\n    function decreaseCirculation(uint256 amount) external onlyOwner returns (uint256) {\r\n        require(!isLock);\r\n        _tokenContainers[msg.sender].unlockAmount = _tokenContainers[msg.sender].unlockAmount.sub(amount);\r\n        _tokenContainers[msg.sender].balance = _tokenContainers[msg.sender].balance.sub(amount);\r\n        emit ChangeCirculation(_tokenContainers[msg.sender].unlockAmount);\r\n        return _tokenContainers[msg.sender].unlockAmount;\r\n    }\r\n\r\n    /*\r\n     * 특정 사용자(ICO, PreSale 구매자)가 구매한 금액 만큼의 충전량을 직접 입력할 때 사용합니다.\r\n     * 컨트랙트 내 토큰의 유통량에 맞추어 동작하므로, Owner의 Balance가 부족하면 실행을 중단힙니다.\r\n     * 충전한 토큰은 lock인 상태로 시작되며, charge() 함수는 충전과 동시에 Unlock하는 양을 지정하여\r\n     * increaseUnlockAmount() 함수의 실행 횟수를 줄일 수 있다.\r\n     */\r\n    /*\r\n     * This function is used to directly input the token amount that is purchased by particular Holders (ICO, Pre-sale buyers). It can be performed by the Owner or the Delegator.\r\n     * Since the contract operates in concurrent to the tokens in circulation, the function will fail to execute when Owner's balance is insuffient. \r\n     * All charged tokens are locked amount. \r\n     */\r\n    function charge(address holder, uint256 chargeAmount, uint256 unlockAmount) external ownerOrDelegator {\r\n        require(!isLock);\r\n        require(holder != address(0));\r\n        require(holder != owner());\r\n        require(chargeAmount > 0);\r\n        require(chargeAmount >= unlockAmount);\r\n        require(_tokenContainers[owner()].balance >= chargeAmount);\r\n\r\n        _tokenContainers[owner()].balance = _tokenContainers[owner()].balance.sub(chargeAmount);\r\n\r\n        _tokenContainers[holder].chargeAmount = _tokenContainers[holder].chargeAmount.add(chargeAmount);\r\n        _tokenContainers[holder].unlockAmount = _tokenContainers[holder].unlockAmount.add(unlockAmount);\r\n        _tokenContainers[holder].balance = _tokenContainers[holder].balance.add(unlockAmount);\r\n        \r\n        emit Charge(holder, chargeAmount, unlockAmount);\r\n    }\r\n    \r\n    /*\r\n     * 특정 사용자(ICO, PreSale 구매자)가 구매한 금액 안에서 해금량을 변경할 때 사용합니다.\r\n     * 총 충전량 안에서 변화가 일어나므로 Unlock Amount가 Charge Amount보다 커질 수 없습니다.\r\n     */\r\n    /*\r\n     * This function is used to change the Unlock Amount of tokens that is purchased by particular Holders (ICO, Pre-sale buyers).\r\n     * Unlock Amount cannot be larger than Charge Amount because changes occur within the total charge amount.\r\n     */\r\n    function increaseUnlockAmount(address holder, uint256 unlockAmount) external ownerOrDelegator {\r\n        require(!isLock);\r\n        require(holder != address(0));\r\n        require(holder != owner());\r\n        require(_tokenContainers[holder].chargeAmount >= _tokenContainers[holder].unlockAmount.add(unlockAmount));\r\n\r\n        _tokenContainers[holder].unlockAmount = _tokenContainers[holder].unlockAmount.add(unlockAmount);\r\n        _tokenContainers[holder].balance = _tokenContainers[holder].balance.add(unlockAmount);\r\n        \r\n        emit IncreaseUnlockAmount(holder, unlockAmount);\r\n    }\r\n    \r\n    /*\r\n     * 특정 사용자(ICO, PreSale 구매자)가 구매한 금액 안에서 해금량을 변경할 때 사용합니다.\r\n     * Balance를 Lock 상태로 전환하는 것이므로 Lock Amount의 값은 Balance보다 커질 수 없습니다.\r\n     */\r\n    /*\r\n     * This function is used to change the Unlock Amount of tokens that is purchased by particular Holders (ICO, Pre-sale buyers).\r\n     * Since the Balance starts from a locked state, the number of locked tokens cannot be greater than the Balance.\r\n     */\r\n    function decreaseUnlockAmount(address holder, uint256 lockAmount) external ownerOrDelegator {\r\n        require(!isLock);\r\n        require(holder != address(0));\r\n        require(holder != owner());\r\n        require(_tokenContainers[holder].balance >= lockAmount);\r\n\r\n        _tokenContainers[holder].unlockAmount = _tokenContainers[holder].unlockAmount.sub(lockAmount);\r\n        _tokenContainers[holder].balance = _tokenContainers[holder].balance.sub(lockAmount);\r\n        \r\n        emit DecreaseUnlockAmount(holder, lockAmount);\r\n    }\r\n\r\n    /*\r\n     * 특정 사용자(ICO, PreSale 구매자)가 구매한 금액 안에서 전체를 해금할 때 사용합니다.\r\n     * Charge Amount 중 Unlock Amount 량을 제외한 나머지 만큼을 일괄적으로 해제합니다.\r\n     */\r\n    /*\r\n     * This function is used to change the Unlock Amount of tokens that is purchased by particular Holders (ICO, Pre-sale buyers).\r\n     * It unlocks all locked tokens in the Charge Amount, other than tokens already unlocked. \r\n     */\r\n    function unlockAmountAll(address holder) external ownerOrDelegator {\r\n        require(!isLock);\r\n        require(holder != address(0));\r\n        require(holder != owner());\r\n\r\n        uint256 unlockAmount = _tokenContainers[holder].chargeAmount.sub(_tokenContainers[holder].unlockAmount);\r\n\r\n        require(unlockAmount > 0);\r\n        \r\n        _tokenContainers[holder].unlockAmount = _tokenContainers[holder].unlockAmount.add(unlockAmount);\r\n        _tokenContainers[holder].balance = _tokenContainers[holder].balance.add(unlockAmount);\r\n    }\r\n\r\n    /*\r\n     * 계약 잠금\r\n     * 계약이 잠기면 컨트랙트의 거래가 중단된 상태가 되며,\r\n     * 거래가 중단된 상태에서는 Owner와 Delegator를 포함한 모든 Holder는 거래를 할 수 없게 된다.\r\n     * 모든 거래가 중단된 상태에서 모든 Holder의 상태가 변경되지 않게 만든 후에\r\n     * 토큰 -> 코인 전환 절차를 진행하기 위함이다.\r\n     * 단, 이 상태에서는 Exchange Contract를 Owner가 직접 Delegator로 임명하여\r\n     * Holder의 요청을 처리하도록 하며, 이때는 토큰 -> 코인 교환회수를 위한 exchange(), withdraw() 함수 실행만 허용이 된다.\r\n     */\r\n    /*\r\n     * Contract lock\r\n     * If the contract is locked, all transactions will be suspended.\r\n     * All Holders including Owner and Delegator will not be able to make transaction during suspension.\r\n     * After all transactions have been stopped and all Holders have not changed their status\r\n     * This function is created primarily for the token swap event. \r\n     * In this process, it's important to note that the Owner of the Exchange contract should directly appoint a delegator when handling Holders' requests.\r\n     * Only the exchange () and withdraw () are allowed to be executed for token swap.\r\n     */\r\n    function lock() external onlyOwner returns (bool) {\r\n        isLock = true;\r\n        return isLock;\r\n    }\r\n\r\n    /*\r\n     * 계약 잠금 해제\r\n     * 잠긴 계약을 해제할 때 사용된다.\r\n     */\r\n    /*\r\n     * Release contract lock\r\n     * The function is used to revert a locked contract to a normal state. \r\n     */\r\n    function unlock() external onlyOwner returns (bool) {\r\n        isLock = false;\r\n        return isLock;\r\n    }\r\n    \r\n    /*\r\n     * 토큰 교환 처리용 외부 호출 함수\r\n     * 계약 전체가 잠긴 상태일 때(교환 처리 중 계약 중단),\r\n     * 외부에서만 호출 가능하며, Delegator이면서 Contract인 경우에만 호출 가능하다.\r\n     */\r\n    /*\r\n     * It is an external call function for token exchange processing\r\n     * This function is used when the entire contract is locked (contract lock during the token swap),\r\n     * It can be called only externally. Also, it can be only called when the agent is both Delegator and Contract.\r\n     */\r\n    function exchange(address holder) external onlyDelegator returns (bool) {\r\n        require(isLock);    // lock state only\r\n        require((delegator() == msg.sender) && isContract(msg.sender));    // contract delegator only\r\n        \r\n        uint256 balance = _tokenContainers[holder].balance;\r\n        _tokenContainers[holder].balance = 0;\r\n        _tokenContainers[msg.sender].balance = _tokenContainers[msg.sender].balance.add(balance);\r\n        \r\n        emit Exchange(holder, msg.sender, balance);\r\n        return true;\r\n    }\r\n    \r\n    /*\r\n     * 토큰 교환 처리 후 회수된 토큰을 Owner한테 돌려주는 함수\r\n     * 계약 전체가 잠긴 상태일 때(교환 처리 중 계약 중단),\r\n     * 외부에서만 호출 가능하며, Delegator이면서 Contract인 경우에만 호출 가능하다.\r\n     */\r\n    /*\r\n     * This is a function in which the Delegator returns tokens to the Owner after the token swap process\r\n     * This function is used when the entire contract is locked (contract lock during the token swap),\r\n     * It can be called only externally. Also, it can be only called when the agent is both Delegator and Contract Owner.\r\n     */\r\n    function withdraw() external onlyDelegator returns (bool) {\r\n        require(isLock);    // lock state only\r\n        require((delegator() == msg.sender) && isContract(msg.sender));    // contract delegator only\r\n        \r\n        uint256 balance = _tokenContainers[msg.sender].balance;\r\n        _tokenContainers[msg.sender].balance = 0;\r\n        _tokenContainers[owner()].balance = _tokenContainers[owner()].balance.add(balance);\r\n        \r\n        emit Withdraw(msg.sender, balance);\r\n    }\r\n    \r\n    /*\r\n     * 현재의 주소가 엔진내에 차지하고 있는 코드의 크기를 계산하여 컨트랙트인지 확인하는 도구\r\n     * 컨트랙트인 경우에만 저장된 코드의 크기가 존재하므로 코드의 크기가 존재한다면\r\n     * 컨트랙트로 판단할 수있다.\r\n     */\r\n    /*\r\n     * This is a tool used for confirming a contract. It determines the size of code that the current address occupies within the blockchain network.\r\n     * Since the size of a stored code exists only in the case of a contract, it is can be used as a validation tool.\r\n     */\r\n    function isContract(address addr) private returns (bool) {\r\n      uint size;\r\n      assembly { size := extcodesize(addr) }\r\n      return size > 0;\r\n    }\r\n}\r\n\r\ncontract FLIP is ERC20Like {\r\n    string public name = \"FLIP\";\r\n    string public symbol = \"FLP\";\r\n    uint256 public decimals = 18;\r\n\r\n    constructor () public {\r\n        _totalSupply = 30000 * (10 ** decimals);\r\n        _tokenContainers[msg.sender].chargeAmount = _totalSupply;\r\n        emit Charge(msg.sender, _tokenContainers[msg.sender].chargeAmount, _tokenContainers[msg.sender].unlockAmount);\r\n    }\r\n}"}}}