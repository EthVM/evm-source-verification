{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "UniswapTwap.sol": {
      "content": "// hevm: flattened sources of src/UniswapTwap.sol\r\n// SPDX-License-Identifier: MIT AND GPL-3.0-or-later AND CC-BY-4.0\r\npragma solidity 0.8.9;\r\n\r\n////// node_modules/@openzeppelin/contracts/utils/Context.sol\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/* pragma solidity ^0.8.0; */\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n////// node_modules/@openzeppelin/contracts/access/Ownable.sol\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\n/* pragma solidity ^0.8.0; */\r\n\r\n/* import \"../utils/Context.sol\"; */\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n////// src/interfaces/IUniswapTWAP.sol\r\n\r\n/* pragma solidity 0.8.9; */\r\n\r\ninterface IUniswapTWAP {\r\n    function maxUpdateWindow() external view returns (uint);\r\n\r\n    function getVaderPrice() external returns (uint);\r\n\r\n    function syncVaderPrice() external;\r\n}\r\n\r\n////// src/interfaces/chainlink/IAggregatorV3.sol\r\n\r\n/* pragma solidity 0.8.9; */\r\n\r\ninterface IAggregatorV3 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int answer,\r\n            uint startedAt,\r\n            uint updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\n////// src/interfaces/uniswap/IUniswapV2Pair.sol\r\n/* pragma solidity 0.8.9; */\r\n\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n}\r\n\r\n////// src/libraries/Babylonian.sol\r\n/* pragma solidity 0.8.9; */\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    // credit for this implementation goes to\r\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n    function sqrt(uint x) internal pure returns (uint) {\r\n        if (x == 0) return 0;\r\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\r\n        // however that code costs significantly more gas\r\n        uint xx = x;\r\n        uint r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n            xx >>= 128;\r\n            r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n            xx >>= 64;\r\n            r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n            xx >>= 32;\r\n            r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n            xx >>= 16;\r\n            r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n            xx >>= 8;\r\n            r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n            xx >>= 4;\r\n            r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n            r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint r1 = x / r;\r\n        return (r < r1 ? r : r1);\r\n    }\r\n}\r\n\r\n////// src/libraries/BitMath.sol\r\n/* pragma solidity 0.8.9; */\r\n\r\nlibrary BitMath {\r\n    // returns the 0 indexed position of the most significant bit of the input x\r\n    // s.t. x >= 2**msb and x < 2**(msb+1)\r\n    function mostSignificantBit(uint x) internal pure returns (uint8 r) {\r\n        require(x > 0, \"BitMath::mostSignificantBit: zero\");\r\n\r\n        if (x >= 0x100000000000000000000000000000000) {\r\n            x >>= 128;\r\n            r += 128;\r\n        }\r\n        if (x >= 0x10000000000000000) {\r\n            x >>= 64;\r\n            r += 64;\r\n        }\r\n        if (x >= 0x100000000) {\r\n            x >>= 32;\r\n            r += 32;\r\n        }\r\n        if (x >= 0x10000) {\r\n            x >>= 16;\r\n            r += 16;\r\n        }\r\n        if (x >= 0x100) {\r\n            x >>= 8;\r\n            r += 8;\r\n        }\r\n        if (x >= 0x10) {\r\n            x >>= 4;\r\n            r += 4;\r\n        }\r\n        if (x >= 0x4) {\r\n            x >>= 2;\r\n            r += 2;\r\n        }\r\n        if (x >= 0x2) r += 1;\r\n    }\r\n\r\n    // returns the 0 indexed position of the least significant bit of the input x\r\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\r\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\r\n    function leastSignificantBit(uint x) internal pure returns (uint8 r) {\r\n        require(x > 0, \"BitMath::leastSignificantBit: zero\");\r\n\r\n        r = 255;\r\n        if (x & type(uint128).max > 0) {\r\n            r -= 128;\r\n        } else {\r\n            x >>= 128;\r\n        }\r\n        if (x & type(uint64).max > 0) {\r\n            r -= 64;\r\n        } else {\r\n            x >>= 64;\r\n        }\r\n        if (x & type(uint32).max > 0) {\r\n            r -= 32;\r\n        } else {\r\n            x >>= 32;\r\n        }\r\n        if (x & type(uint16).max > 0) {\r\n            r -= 16;\r\n        } else {\r\n            x >>= 16;\r\n        }\r\n        if (x & type(uint8).max > 0) {\r\n            r -= 8;\r\n        } else {\r\n            x >>= 8;\r\n        }\r\n        if (x & 0xf > 0) {\r\n            r -= 4;\r\n        } else {\r\n            x >>= 4;\r\n        }\r\n        if (x & 0x3 > 0) {\r\n            r -= 2;\r\n        } else {\r\n            x >>= 2;\r\n        }\r\n        if (x & 0x1 > 0) r -= 1;\r\n    }\r\n}\r\n\r\n////// src/libraries/FullMath.sol\r\n/* pragma solidity 0.8.9; */\r\n\r\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\r\n// license is CC-BY-4.0\r\nlibrary FullMath {\r\n    function fullMul(uint x, uint y) internal pure returns (uint l, uint h) {\r\n        uint mm = mulmod(x, y, type(uint).max);\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    function fullDiv(\r\n        uint l,\r\n        uint h,\r\n        uint d\r\n    ) private pure returns (uint) {\r\n        uint pow2 = d & uint(-int(d));\r\n        d /= pow2;\r\n        l /= pow2;\r\n        l += h * (uint(-int(pow2)) / pow2 + 1);\r\n        uint r = 1;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        r *= 2 - d * r;\r\n        return l * r;\r\n    }\r\n\r\n    function mulDiv(\r\n        uint x,\r\n        uint y,\r\n        uint d\r\n    ) internal pure returns (uint) {\r\n        (uint l, uint h) = fullMul(x, y);\r\n\r\n        uint mm = mulmod(x, y, d);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n\r\n        if (h == 0) return l / d;\r\n\r\n        require(h < d, \"FullMath: FULLDIV_OVERFLOW\");\r\n        return fullDiv(l, h, d);\r\n    }\r\n}\r\n\r\n////// src/libraries/FixedPoint.sol\r\n/* pragma solidity 0.8.9; */\r\n\r\n/* import \"./FullMath.sol\"; */\r\n/* import \"./Babylonian.sol\"; */\r\n/* import \"./BitMath.sol\"; */\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint _x;\r\n    }\r\n\r\n    uint8 public constant RESOLUTION = 112;\r\n    uint public constant Q112 = 0x10000000000000000000000000000; // 2**112\r\n    uint private constant Q224 =\r\n        0x100000000000000000000000000000000000000000000000000000000; // 2**224\r\n    uint private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint(x) << RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint y)\r\n        internal\r\n        pure\r\n        returns (uq144x112 memory)\r\n    {\r\n        uint z = 0;\r\n        require(\r\n            y == 0 || (z = self._x * y) / y == self._x,\r\n            \"FixedPoint::mul: overflow\"\r\n        );\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by an int and decode, returning an int\r\n    // reverts on overflow\r\n    function muli(uq112x112 memory self, int y) internal pure returns (int) {\r\n        uint z = FullMath.mulDiv(self._x, uint(y < 0 ? -y : y), Q112);\r\n        require(z < 2**255, \"FixedPoint::muli: overflow\");\r\n        return y < 0 ? -int(z) : int(z);\r\n    }\r\n\r\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    // lossy\r\n    function muluq(uq112x112 memory self, uq112x112 memory other)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        if (self._x == 0 || other._x == 0) {\r\n            return uq112x112(0);\r\n        }\r\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\r\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\r\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\r\n\r\n        // partial products\r\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\r\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\r\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\r\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\r\n\r\n        // so the bit shift does not overflow\r\n        require(\r\n            upper <= type(uint112).max,\r\n            \"FixedPoint::muluq: upper overflow\"\r\n        );\r\n\r\n        // this cannot exceed 256 bits, all values are 224 bits\r\n        uint sum = uint(upper << RESOLUTION) +\r\n            uppers_lowero +\r\n            uppero_lowers +\r\n            (lower >> RESOLUTION);\r\n\r\n        // so the cast does not overflow\r\n        require(sum <= type(uint224).max, \"FixedPoint::muluq: sum overflow\");\r\n\r\n        return uq112x112(uint224(sum));\r\n    }\r\n\r\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\r\n    function divuq(uq112x112 memory self, uq112x112 memory other)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        require(other._x > 0, \"FixedPoint::divuq: division by zero\");\r\n        if (self._x == other._x) {\r\n            return uq112x112(uint224(Q112));\r\n        }\r\n        if (self._x <= type(uint144).max) {\r\n            uint value = (uint(self._x) << RESOLUTION) / other._x;\r\n            require(value <= type(uint224).max, \"FixedPoint::divuq: overflow\");\r\n            return uq112x112(uint224(value));\r\n        }\r\n\r\n        uint result = FullMath.mulDiv(Q112, self._x, other._x);\r\n        require(result <= type(uint224).max, \"FixedPoint::divuq: overflow\");\r\n        return uq112x112(uint224(result));\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // can be lossy\r\n    function fraction(uint numerator, uint denominator)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        require(denominator > 0, \"FixedPoint::fraction: division by zero\");\r\n        if (numerator == 0) return FixedPoint.uq112x112(0);\r\n\r\n        if (numerator <= type(uint144).max) {\r\n            uint result = (numerator << RESOLUTION) / denominator;\r\n            require(\r\n                result <= type(uint224).max,\r\n                \"FixedPoint::fraction: overflow\"\r\n            );\r\n            return uq112x112(uint224(result));\r\n        } else {\r\n            uint result = FullMath.mulDiv(numerator, Q112, denominator);\r\n            require(\r\n                result <= type(uint224).max,\r\n                \"FixedPoint::fraction: overflow\"\r\n            );\r\n            return uq112x112(uint224(result));\r\n        }\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    // reverts on overflow\r\n    // lossy\r\n    function reciprocal(uq112x112 memory self)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        require(self._x != 0, \"FixedPoint::reciprocal: reciprocal of zero\");\r\n        require(self._x != 1, \"FixedPoint::reciprocal: overflow\");\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    // lossy between 0/1 and 40 bits\r\n    function sqrt(uq112x112 memory self)\r\n        internal\r\n        pure\r\n        returns (uq112x112 memory)\r\n    {\r\n        if (self._x <= type(uint144).max) {\r\n            return uq112x112(uint224(Babylonian.sqrt(uint(self._x) << 112)));\r\n        }\r\n\r\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\r\n        safeShiftBits -= safeShiftBits % 2;\r\n        return\r\n            uq112x112(\r\n                uint224(\r\n                    Babylonian.sqrt(uint(self._x) << safeShiftBits) <<\r\n                        ((112 - safeShiftBits) / 2)\r\n                )\r\n            );\r\n    }\r\n}\r\n\r\n////// src/libraries/UniswapV2OracleLibrary.sol\r\n/* pragma solidity 0.8.9; */\r\n\r\n/* import \"../interfaces/uniswap/IUniswapV2Pair.sol\"; */\r\n/* import \"./FixedPoint.sol\"; */\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2**32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(address pair)\r\n        internal\r\n        view\r\n        returns (\r\n            uint price0Cumulative,\r\n            uint price1Cumulative,\r\n            uint32 blockTimestamp\r\n        )\r\n    {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        ) = IUniswapV2Pair(pair).getReserves();\r\n        if (blockTimestampLast != blockTimestamp) {\r\n            // subtraction overflow is desired\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n            // addition overflow is desired\r\n            // counterfactual\r\n            price0Cumulative +=\r\n                uint(FixedPoint.fraction(reserve1, reserve0)._x) *\r\n                timeElapsed;\r\n            // counterfactual\r\n            price1Cumulative +=\r\n                uint(FixedPoint.fraction(reserve0, reserve1)._x) *\r\n                timeElapsed;\r\n        }\r\n    }\r\n}\r\n\r\n////// src/UniswapTwap.sol\r\n\r\n/* pragma solidity 0.8.9; */\r\n\r\n/* import \"@openzeppelin/contracts/access/Ownable.sol\"; */\r\n/* import \"./interfaces/chainlink/IAggregatorV3.sol\"; */\r\n/* import \"./interfaces/uniswap/IUniswapV2Pair.sol\"; */\r\n/* import \"./interfaces/IUniswapTWAP.sol\"; */\r\n/* import \"./libraries/UniswapV2OracleLibrary.sol\"; */\r\n/* import \"./libraries/FixedPoint.sol\"; */\r\n\r\n/**\r\n * @notice Return absolute value of |x - y|\r\n */\r\nfunction abs(uint x, uint y) pure returns (uint) {\r\n    if (x >= y) {\r\n        return x - y;\r\n    }\r\n    return y - x;\r\n}\r\n\r\ncontract UniswapTwap is IUniswapTWAP, Ownable {\r\n    using FixedPoint for FixedPoint.uq112x112;\r\n    using FixedPoint for FixedPoint.uq144x112;\r\n\r\n    struct ExchangePair {\r\n        uint nativeTokenPriceCumulative;\r\n        FixedPoint.uq112x112 nativeTokenPriceAverage;\r\n        uint lastMeasurement;\r\n        uint updatePeriod;\r\n        // true if token0 = vader\r\n        bool isFirst;\r\n    }\r\n\r\n    event SetOracle(address oracle);\r\n\r\n    // 1 Vader = 1e18\r\n    uint private constant ONE_VADER = 1e18;\r\n    // Denominator to calculate difference in Vader / ETH TWAP and spot price.\r\n    uint private constant MAX_PRICE_DIFF_DENOMINATOR = 1e5;\r\n    // max for maxUpdateWindow\r\n    uint private constant MAX_UPDATE_WINDOW = 30 days;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n    address public immutable vader;\r\n    // Vader ETH pair\r\n    IUniswapV2Pair public immutable pair;\r\n    // Set to pairData.updatePeriod.\r\n    // maxUpdateWindow is called by other contracts.\r\n    uint public maxUpdateWindow;\r\n    ExchangePair public pairData;\r\n    IAggregatorV3 public oracle;\r\n    // Numberator to calculate max allowed difference between Vader / ETH TWAP\r\n    // and spot price.\r\n    // maxPriceDiff must be initialized to MAX_PRICE_DIFF_DENOMINATOR and kept\r\n    // until TWAP price is close to spot price for _updateVaderPrice to not fail.\r\n    uint public maxPriceDiff = MAX_PRICE_DIFF_DENOMINATOR;\r\n\r\n    constructor(\r\n        address _vader,\r\n        IUniswapV2Pair _pair,\r\n        IAggregatorV3 _oracle,\r\n        uint _updatePeriod\r\n    ) {\r\n        require(_vader != address(0), \"vader = 0 address\");\r\n        vader = _vader;\r\n        require(_oracle.decimals() == 8, \"oracle decimals != 8\");\r\n        oracle = _oracle;\r\n        pair = _pair;\r\n        _addVaderPair(_vader, _pair, _updatePeriod);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n    /**\r\n     * @notice Get Vader USD price calculated from Vader / ETH price from\r\n     *         last update.\r\n     **/\r\n    function getStaleVaderPrice() external view returns (uint) {\r\n        return _calculateVaderPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Get ETH / USD price from Chainlink. 1 USD = 1e8.\r\n     **/\r\n    function getChainlinkPrice() public view returns (uint) {\r\n        (uint80 roundID, int price, , , uint80 answeredInRound) = oracle\r\n            .latestRoundData();\r\n        require(answeredInRound >= roundID, \"stale Chainlink price\");\r\n        require(price > 0, \"chainlink price = 0\");\r\n        return uint(price);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to decode and return Vader / ETH TWAP price\r\n     **/\r\n    function getVaderEthPriceAverage() public view returns (uint) {\r\n        return pairData.nativeTokenPriceAverage.mul(ONE_VADER).decode144();\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to decode and return Vader / ETH spot price\r\n     **/\r\n    function getVaderEthSpotPrice() public view returns (uint) {\r\n        (uint reserve0, uint reserve1, ) = pair.getReserves();\r\n        (uint vaderReserve, uint ethReserve) = pairData.isFirst\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n        return\r\n            FixedPoint\r\n                .fraction(ethReserve, vaderReserve)\r\n                .mul(ONE_VADER)\r\n                .decode144();\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n    /**\r\n    * @notice Update Vader / ETH price and return Vader / USD price.\r\n              This function will need to be executed at least twice to return\r\n              sensible Vader / USD price.\r\n    **/\r\n    // NOTE: Fails until _updateVaderPrice is called atlease twice for\r\n    // nativeTokenPriceAverage to be > 0\r\n    function getVaderPrice() external returns (uint) {\r\n        _updateVaderPrice();\r\n        return _calculateVaderPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Update Vader / ETH price.\r\n     **/\r\n    function syncVaderPrice() external {\r\n        _updateVaderPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Update Vader / ETH price.\r\n     **/\r\n    function _updateVaderPrice() private {\r\n        uint timeElapsed = block.timestamp - pairData.lastMeasurement;\r\n        // NOTE: save gas and re-entrancy protection.\r\n        if (timeElapsed < pairData.updatePeriod) return;\r\n        bool isFirst = pairData.isFirst;\r\n        (\r\n            uint price0Cumulative,\r\n            uint price1Cumulative,\r\n            uint currentMeasurement\r\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\r\n        uint priceCumulativeEnd = isFirst ? price0Cumulative : price1Cumulative;\r\n        uint priceCumulativeStart = pairData.nativeTokenPriceCumulative;\r\n        require(\r\n            priceCumulativeEnd >= priceCumulativeStart,\r\n            \"price cumulative end < start\"\r\n        );\r\n        unchecked {\r\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\r\n                uint224(\r\n                    (priceCumulativeEnd - priceCumulativeStart) / timeElapsed\r\n                )\r\n            );\r\n        }\r\n        pairData.nativeTokenPriceCumulative = priceCumulativeEnd;\r\n        pairData.lastMeasurement = currentMeasurement;\r\n\r\n        // check TWAP and spot price difference is not too big\r\n        if (maxPriceDiff < MAX_PRICE_DIFF_DENOMINATOR) {\r\n            // p = TWAP price\r\n            // s = spot price\r\n            // d = max price diff\r\n            // D = MAX_PRICE_DIFF_DENOMINATOR\r\n            // |p - s| / p <= d / D\r\n            uint twapPrice = getVaderEthPriceAverage();\r\n            uint spotPrice = getVaderEthSpotPrice();\r\n            require(twapPrice > 0, \"TWAP = 0\");\r\n            require(spotPrice > 0, \"spot price = 0\");\r\n            // NOTE: if maxPriceDiff = 0, then this check will most likely fail\r\n            require(\r\n                (abs(twapPrice, spotPrice) * MAX_PRICE_DIFF_DENOMINATOR) /\r\n                    twapPrice <=\r\n                    maxPriceDiff,\r\n                \"price diff > max\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates Vader price in USD, 1 USD = 1e18.\r\n     **/\r\n    function _calculateVaderPrice() private view returns (uint vaderUsdPrice) {\r\n        // USD / ETH, 8 decimals\r\n        uint usdPerEth = getChainlinkPrice();\r\n        // ETH / Vader, 18 decimals\r\n        uint ethPerVader = pairData\r\n            .nativeTokenPriceAverage\r\n            .mul(ONE_VADER)\r\n            .decode144();\r\n        // divide by 1e8 from Chainlink price\r\n        vaderUsdPrice = (usdPerEth * ethPerVader) / 1e8;\r\n        require(vaderUsdPrice > 0, \"vader usd price = 0\");\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize pairData.\r\n     * @param _vader Address of Vader.\r\n     * @param _pair Address of Vader / ETH Uniswap V2 pair.\r\n     * @param _updatePeriod Amout of time that has to elapse before Vader / ETH\r\n     *       TWAP can be updated.\r\n     **/\r\n    function _addVaderPair(\r\n        address _vader,\r\n        IUniswapV2Pair _pair,\r\n        uint _updatePeriod\r\n    ) private {\r\n        require(_updatePeriod != 0, \"update period = 0\");\r\n        bool isFirst = _pair.token0() == _vader;\r\n        address nativeAsset = isFirst ? _pair.token0() : _pair.token1();\r\n        require(nativeAsset == _vader, \"unsupported pair\");\r\n        pairData.isFirst = isFirst;\r\n        pairData.lastMeasurement = block.timestamp;\r\n        _setUpdatePeriod(_updatePeriod);\r\n        pairData.nativeTokenPriceCumulative = isFirst\r\n            ? _pair.price0CumulativeLast()\r\n            : _pair.price1CumulativeLast();\r\n        // NOTE: pairData.nativeTokenPriceAverage = 0\r\n    }\r\n\r\n    /**\r\n     * @notice Set Chainlink oracle.\r\n     * @param _oracle Address of Chainlink price oracle.\r\n     **/\r\n    function setOracle(IAggregatorV3 _oracle) external onlyOwner {\r\n        require(_oracle.decimals() == 8, \"oracle decimals != 8\");\r\n        oracle = _oracle;\r\n        emit SetOracle(address(_oracle));\r\n    }\r\n\r\n    /**\r\n     * @notice Set updatePeriod.\r\n     * @param _updatePeriod New update period for Vader / ETH TWAP\r\n     **/\r\n    function _setUpdatePeriod(uint _updatePeriod) private {\r\n        require(_updatePeriod <= MAX_UPDATE_WINDOW, \"update period > max\");\r\n        pairData.updatePeriod = _updatePeriod;\r\n        maxUpdateWindow = _updatePeriod;\r\n    }\r\n\r\n    function setUpdatePeriod(uint _updatePeriod) external onlyOwner {\r\n        _setUpdatePeriod(_updatePeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Set maxPriceDiff.\r\n     * @param _maxPriceDiff Numberator to calculate max allowed difference\r\n     *        between Vader / ETH TWAP and spot price.\r\n     **/\r\n    function _setMaxPriceDiff(uint _maxPriceDiff) private {\r\n        require(\r\n            _maxPriceDiff <= MAX_PRICE_DIFF_DENOMINATOR,\r\n            \"price diff > max\"\r\n        );\r\n        maxPriceDiff = _maxPriceDiff;\r\n    }\r\n\r\n    function setMaxPriceDiff(uint _maxPriceDiff) external onlyOwner {\r\n        _setMaxPriceDiff(_maxPriceDiff);\r\n    }\r\n\r\n    /**\r\n     * @notice Force update Vader TWAP price even if has deviated significantly\r\n     *         from Vader / ETH spot price.\r\n     */\r\n    function forceUpdateVaderPrice() external onlyOwner {\r\n        uint _maxPriceDiff = maxPriceDiff;\r\n        _setMaxPriceDiff(MAX_PRICE_DIFF_DENOMINATOR);\r\n        _updateVaderPrice();\r\n        _setMaxPriceDiff(_maxPriceDiff);\r\n    }\r\n}"
    }
  }
}