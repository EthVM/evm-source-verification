{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DragonCore.sol": {
      "content": "// File: contracts/Ownable.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS paused\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS NOT paused\r\n     */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused returns (bool) {\r\n        paused = true;\r\n        emit Pause();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused returns (bool) {\r\n        paused = false;\r\n        emit Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/DragonAccessControl.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\ncontract DragonAccessControl {\r\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address payable public ceoAddress;\r\n    address payable public cioAddress;\r\n    address payable public cmoAddress;\r\n    address payable public cooAddress;\r\n    address payable public cfoAddress;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CIO-only functionality\r\n    modifier onlyCIO() {\r\n        require(msg.sender == cioAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CMO-only functionality\r\n    modifier onlyCMO() {\r\n        require(msg.sender == cmoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cioAddress ||\r\n            msg.sender == cmoAddress ||\r\n            msg.sender == cooAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address payable _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CIO. Only available to the current CEO.\r\n    /// @param _newCIO The address of the new CIO\r\n    function setCIO(address payable _newCIO) external onlyCEO {\r\n        require(_newCIO != address(0));\r\n\r\n        cioAddress = _newCIO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CMO. Only available to the current CEO.\r\n    /// @param _newCMO The address of the new CMO\r\n    function setCMO(address payable _newCMO) external onlyCEO {\r\n        require(_newCMO != address(0));\r\n\r\n        cmoAddress = _newCMO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address payable _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address payable _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CIO or CMO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\n// File: contracts/DragonERC721.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface ERC721Metadata /* is IERC721Base */ {\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external pure returns (string memory _name);\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external pure returns (string memory _symbol);\r\n\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n//contract DragonERC721 is IERC721, ERC721Metadata, ERC721TokenReceiver, ERC721Enumerable {\r\ncontract DragonERC721 is ERC165, ERC721, ERC721Metadata, ERC721TokenReceiver, ERC721Enumerable {\r\n\r\n    mapping (bytes4 => bool) internal supportedInterfaces;\r\n\r\n    string public tokenURIPrefix = \"https://www.drakons.io/server/api/dragon/metadata/\";\r\n    string public tokenURISuffix = \"\";\r\n\r\n    function name() external pure returns (string memory) {\r\n      return \"Drakons\";\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n      return \"DRKNS\";\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[interfaceID];\r\n    }\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4){\r\n        return bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ClockAuctionBase.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract ClockAuctionBase {\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address payable seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    DragonERC721 public nonFungibleContract;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    address payable public ceoAddress;\r\n    address payable public cfoAddress;\r\n\r\n    modifier onlyCEOCFO() {\r\n        require(\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping (uint256 => Auction) tokenIdToAuction;\r\n\r\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address buyer, address seller);\r\n    event AuctionCancelled(uint256 tokenId);\r\n\r\n\r\n    function setCEO(address payable _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address payable _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _owner - Current owner address of token to escrow.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        nonFungibleContract.transferFrom(_owner, address(this), _tokenId);\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        // it will throw if transfer fails\r\n        //nonFungibleContract.transfer(_receiver, _tokenId);\r\n        nonFungibleContract.transferFrom(address(this), _receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Adds an auction to the list of open auctions. Also fires the\r\n    ///  AuctionCreated event.\r\n    /// @param _tokenId The ID of the token to be put on auction.\r\n    /// @param _auction Auction to add.\r\n    function _addAuction(uint256 _tokenId, Auction memory _auction) internal {\r\n        // Require that all auctions have a duration of\r\n        // at least one minute. (Keeps our math from getting hairy!)\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        tokenIdToAuction[_tokenId] = _auction;\r\n\r\n        //cpt added emit\r\n        emit AuctionCreated(\r\n            uint256(_tokenId),\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        emit AuctionCancelled(_tokenId);\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n    internal\r\n    returns (uint256)\r\n    {\r\n        // Get a reference to the auction struct\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(auction));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address payable seller = auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price, so this subtraction can't go negative.)\r\n            uint256 auctioneerCut = _computeCut(price);\r\n            uint256 sellerProceeds = price - auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        emit AuctionSuccessful(_tokenId, price, msg.sender, seller);\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete tokenIdToAuction[_tokenId];\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on auction.\r\n    /// @param _auction - Auction to check.\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction. Broken into two\r\n    ///  functions (this one, that computes the duration from the auction\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _currentPrice(Auction storage _auction)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function public and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addAuction())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n}\r\n\r\n// File: contracts/ClockAuction.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\ncontract ClockAuction is Pausable, ClockAuctionBase {\r\n\r\n    /// @dev The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    //bytes4 constant InterfaceSignature_ERC721 = bytes4(0x5b5e139f);\r\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x80ac58cd);\r\n\r\n    /// @dev Constructor creates a reference to the NFT ownership contract\r\n    ///  and verifies the owner cut is in the valid range.\r\n    /// @param _nftAddress - address of a deployed contract implementing\r\n    ///  the Nonfungible Interface.\r\n    /// @param _cut - percent cut the owner takes on each auction, must be\r\n    ///  between 0-10,000.\r\n    constructor (address _nftAddress, uint256 _cut) public {\r\n        require(_cut <= 10000);\r\n        ownerCut = _cut;\r\n\r\n        ceoAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n\r\n        DragonERC721 candidateContract = DragonERC721(_nftAddress);\r\n        //require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\r\n        nonFungibleContract = candidateContract;\r\n    }\r\n\r\n\r\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\r\n    ///  as well as any Ether sent directly to the contract address.\r\n    ///  Always transfers to the NFT contract, but can be called either by\r\n    ///  the owner or the NFT contract.\r\n    function withdrawBalance() external {\r\n        address payable nftAddress = address(uint160(address(nonFungibleContract)));\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n            msg.sender == nftAddress\r\n        );\r\n        // We are using this boolean method to make sure that even if one fails it will still work\r\n        //bool res = nftAddress.send(address(this).balance);\r\n        nftAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address payable _seller\r\n    )\r\n    external\r\n    whenNotPaused\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(_owns(msg.sender, _tokenId));\r\n        _escrow(msg.sender, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Ether is supplied.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(uint256 _tokenId)\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(uint256 _tokenId)\r\n    external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller || msg.sender == address(nonFungibleContract));\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /// @dev Cancels an auction when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _tokenId - ID of the NFT on auction to cancel.\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n    whenPaused\r\n    onlyOwner\r\n    external\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_tokenId, auction.seller);\r\n    }\r\n\r\n    /// @dev Returns auction info for an NFT on auction.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getAuction(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns\r\n    (\r\n        address payable seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    ) {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return (\r\n        auction.seller,\r\n        auction.startingPrice,\r\n        auction.endingPrice,\r\n        auction.duration,\r\n        auction.startedAt\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of an auction.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getCurrentPrice(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Auction storage auction = tokenIdToAuction[_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n}\r\n\r\n// File: contracts/SaleClockAuction.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract SaleClockAuction is ClockAuction {\r\n\r\n    // @dev Sanity check that allows us to ensure that we are pointing to the\r\n    //  right auction in our setSaleAuctionAddress() call.\r\n    bool public isSaleClockAuction = true;\r\n\r\n    // Delegate constructor\r\n    constructor(address _nftAddr, uint256 _cut) public\r\n    ClockAuction(_nftAddr, _cut) {}\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of auction (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address payable _seller\r\n    )\r\n    external\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Updates lastSalePrice if seller is the nft contract\r\n    /// Otherwise, works the same as default bid method.\r\n    function bid(uint256 _tokenId)\r\n    external\r\n    payable\r\n    {\r\n        // _bid verifies token ID size\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    function setOwnerCut(uint256 val) external onlyCEOCFO {\r\n        ownerCut = val;\r\n    }\r\n}\r\n\r\n// File: contracts/SiringClockAuction.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract SiringClockAuction is ClockAuction {\r\n\r\n    // @dev Sanity check that allows us to ensure that we are pointing to the\r\n    //  right auction in our setSiringAuctionAddress() call.\r\n    bool public isSiringClockAuction = true;\r\n\r\n    // Delegate constructor\r\n    constructor(address _nftAddr, uint256 _cut) public\r\n    ClockAuction(_nftAddr, _cut) {}\r\n\r\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\r\n    /// require sender to be DragonCore contract.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of auction (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address payable _seller\r\n    )\r\n    external\r\n    {\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        require(msg.sender == address(nonFungibleContract));\r\n        _escrow(_seller, _tokenId);\r\n        Auction memory auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_tokenId, auction);\r\n    }\r\n\r\n    /// @dev Places a bid for siring. Requires the sender\r\n    /// is the DragonCore contract because all bid methods\r\n    /// should be wrapped. Also returns the Dragon to the\r\n    /// seller rather than the winner.\r\n    function bid(uint256 _tokenId)\r\n    external\r\n    payable\r\n    {\r\n        require(msg.sender == address(nonFungibleContract));\r\n        address seller = tokenIdToAuction[_tokenId].seller;\r\n        // _bid checks that token ID is valid and will throw if bid fails\r\n        _bid(_tokenId, msg.value);\r\n        // We transfer the dragon back to the seller, the winner will get\r\n        // the offspring\r\n        _transfer(seller, _tokenId);\r\n    }\r\n\r\n    function setOwnerCut(uint256 val) external onlyCEOCFO {\r\n        ownerCut = val;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/DragonBase.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n\r\n\r\n\r\ncontract DragonBase is DragonAccessControl, DragonERC721 {\r\n\r\n    event Birth(address owner, uint256 dragonId, uint256 matronId, uint256 sireId, uint256 dna, uint32 generation, uint64 runeLevel);\r\n    event DragonAssetsUpdated(uint256 _dragonId, uint64 _rune, uint64 _agility, uint64 _strength, uint64 _intelligence);\r\n    event DragonAssetRequest(uint256 _dragonId);\r\n    //event Transfer(address from, address to, uint256 tokenId, uint32 generation);\r\n\r\n    struct Dragon {\r\n        // The Dragon's genetic code is packed into these 256-bits.\r\n        uint256 dna;\r\n        uint64 birthTime;\r\n        uint64 breedTime;\r\n        uint32 matronId;\r\n        uint32 sireId;\r\n        uint32 siringWithId;\r\n        uint32 generation;\r\n    }\r\n\r\n    struct DragonAssets {\r\n        uint64 runeLevel;\r\n        uint64 agility;\r\n        uint64 strength;\r\n        uint64 intelligence;\r\n    }\r\n\r\n    Dragon[] dragons;\r\n    mapping (uint256 => address) public dragonIndexToOwner;\r\n    mapping (address => uint256) ownershipTokenCount;\r\n    mapping (uint256 => address) public dragonIndexToApproved;\r\n    mapping (uint256 => address) public sireAllowedToAddress;\r\n    mapping (uint256 => DragonAssets) public dragonAssets;\r\n\r\n    mapping (address => mapping (address => bool)) internal authorised;\r\n\r\n    uint256 public updateAssetFee = 8 finney;\r\n\r\n    SaleClockAuction public saleAuction;\r\n    SiringClockAuction public siringAuction;\r\n\r\n    modifier isValidToken(uint256 _tokenId) {\r\n        require(dragonIndexToOwner[_tokenId] != address(0));\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns ownership of a specific Dragon to an address.\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        // Since the number of dragons is capped to 2^32 we can't overflow this\r\n        // Declaration: mapping (address => uint256) ownershipTokenCount;\r\n        ownershipTokenCount[_to]++;\r\n        // transfer ownership\r\n        // Declaration: mapping (uint256 => address) public dragonIndexToOwner;\r\n        dragonIndexToOwner[_tokenId] = _to;\r\n        // When creating new dragons _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n            // once the dragon is transferred also clear sire allowances\r\n            delete sireAllowedToAddress[_tokenId];\r\n            // clear any previously approved ownership exchange\r\n            delete dragonIndexToApproved[_tokenId];\r\n        }\r\n\r\n        //Dragon storage dragon = dragons[_tokenId];\r\n\r\n        // Emit the transfer event.\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @dev An internal method that creates a new dragon and stores it. This\r\n    ///  method doesn't do any checking and should only be called when the\r\n    ///  input data is known to be valid. Will generate both a Birth event\r\n    ///  and a Transfer event.\r\n    /// @param _matronId The dragon ID of the matron of this dragon (zero for firstGen)\r\n    /// @param _sireId The dragon ID of the sire of this dragon (zero for firstGen)\r\n    /// @param _generation The generation number of this dragon, must be computed by caller.\r\n    /// @param _dna The dragon's genetic code.\r\n    /// @param _agility The dragon's agility\r\n    /// @param _strength The dragon's strength\r\n    /// @param _intelligence The dragon's intelligence\r\n    /// @param _runelevel The dragon's rune level\r\n    /// @param _owner The inital owner of this dragon, must be non-zero (except for the mythical beast, ID 0)\r\n    function _createDragon(\r\n        uint256 _matronId,\r\n        uint256 _sireId,\r\n        uint256 _generation,\r\n        uint256 _dna,\r\n        uint64 _agility,\r\n        uint64 _strength,\r\n        uint64 _intelligence,\r\n        uint64 _runelevel,\r\n        address _owner\r\n    )\r\n    internal\r\n    returns (uint)\r\n    {\r\n        require(_matronId == uint256(uint32(_matronId)));\r\n        require(_sireId == uint256(uint32(_sireId)));\r\n        require(_generation == uint256(uint32(_generation)));\r\n\r\n        Dragon memory _dragon = Dragon({\r\n            dna: _dna,\r\n            birthTime: uint64(now),\r\n            breedTime: 0,\r\n            matronId: uint32(_matronId),\r\n            sireId: uint32(_sireId),\r\n            siringWithId: 0,\r\n            generation: uint32(_generation)\r\n            });\r\n\r\n        DragonAssets memory _dragonAssets = DragonAssets({\r\n            runeLevel: _runelevel,\r\n            agility: _agility,\r\n            strength: _strength,\r\n            intelligence: _intelligence\r\n            });\r\n\r\n        uint256 newDragonId = dragons.push(_dragon) - 1;\r\n\r\n        dragonAssets[newDragonId] = _dragonAssets;\r\n\r\n        // It's probably never going to happen, 4 billion dragons is A LOT, but\r\n        // let's just be 100% sure we never let this happen.\r\n        require(newDragonId == uint256(uint32(newDragonId)));\r\n\r\n        // emit the birth event\r\n        emit Birth(\r\n            _owner,\r\n            newDragonId,\r\n            uint256(_dragon.matronId),\r\n            uint256(_dragon.sireId),\r\n            _dragon.dna,\r\n            _dragon.generation,\r\n            _runelevel\r\n        );\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(address(0), _owner, newDragonId);\r\n\r\n        return newDragonId;\r\n    }\r\n\r\n    function setUpdateAssetFee(uint256 newFee) external onlyCLevel {\r\n        updateAssetFee = newFee;\r\n    }\r\n\r\n\r\n    function updateDragonAsset(uint256 _dragonId, uint64 _rune, uint64 _agility, uint64 _strength, uint64 _intelligence)\r\n    external\r\n    whenNotPaused\r\n    onlyCOO\r\n    {\r\n\r\n        DragonAssets storage currentDragonAsset = dragonAssets[_dragonId];\r\n\r\n        require(_rune > currentDragonAsset.runeLevel);\r\n        require(_agility >= currentDragonAsset.agility);\r\n        require(_strength >= currentDragonAsset.strength);\r\n        require(_intelligence >= currentDragonAsset.intelligence);\r\n\r\n        DragonAssets memory _dragonAsset = DragonAssets({\r\n            runeLevel: _rune,\r\n            agility: _agility,\r\n            strength: _strength,\r\n            intelligence: _intelligence\r\n            });\r\n\r\n        dragonAssets[_dragonId] = _dragonAsset;\r\n        msg.sender.transfer(updateAssetFee);\r\n        emit DragonAssetsUpdated(_dragonId, _rune, _agility, _strength, _intelligence);\r\n\r\n    }\r\n\r\n    function requestAssetUpdate(uint256 _dragonId, uint256 _rune)\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    {\r\n        require(msg.value >= updateAssetFee);\r\n\r\n        DragonAssets storage currentDragonAsset = dragonAssets[_dragonId];\r\n        require(_rune > currentDragonAsset.runeLevel);\r\n\r\n        emit DragonAssetRequest(_dragonId);\r\n\r\n        //assetManagement.requestAssetUpdate.value(msg.value)(_dragonId);\r\n    }\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool)\r\n    {\r\n        return authorised[_owner][_operator];\r\n    }\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external\r\n    {\r\n        emit ApprovalForAll(msg.sender,_operator, _approved);\r\n        authorised[msg.sender][_operator] = _approved;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view isValidToken(_tokenId) returns (string memory)\r\n    {\r\n        uint maxlength = 78;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        uint _tmpTokenId = _tokenId;\r\n        uint _offset = 48;\r\n\r\n        bytes memory _uriBase;\r\n        _uriBase = bytes(tokenURIPrefix);\r\n\r\n        while (_tmpTokenId != 0) {\r\n            uint remainder = _tmpTokenId % 10;\r\n            _tmpTokenId = _tmpTokenId / 10;\r\n            reversed[i++] = byte(uint8(_offset + remainder));\r\n        }\r\n\r\n        bytes memory s = new bytes(_uriBase.length + i);\r\n        uint j;\r\n\r\n        //add the base to the final array\r\n        for (j = 0; j < _uriBase.length; j++) {\r\n            s[j] = _uriBase[j];\r\n        }\r\n        //add the tokenId to the final array\r\n        for (j = 0; j < i; j++) {\r\n            s[j + _uriBase.length] = reversed[i - 1 - j];\r\n        }\r\n        //turn it into a string and return it\r\n        return string(s);\r\n    }\r\n}\r\n\r\n// File: contracts/DragonOwnership.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title The facet of the BlockDragons core contract that manages ownership, ERC-721 (draft) compliant.\r\n/// @author Zynappse Corporation (https://www.zynapse.com)\r\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\r\n///  @dev Refer to the Dragon contract documentation for details in contract interactions.\r\ncontract DragonOwnership is DragonBase {\r\n\r\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n    string public constant name = \"Drakons\";\r\n    string public constant symbol = \"DRKNS\";\r\n\r\n    //bytes4 constant InterfaceSignature_ERC165 = bytes4(keccak256('supportsInterface(bytes4)'));\r\n\r\n    //bytes4 constant InterfaceSignature_ERC721 =\r\n    //bytes4(keccak256('name()')) ^\r\n    //bytes4(keccak256('symbol()')) ^\r\n    //bytes4(keccak256('totalSupply()')) ^\r\n    //bytes4(keccak256('balanceOf(address)')) ^\r\n    //bytes4(keccak256('ownerOf(uint256)')) ^\r\n    //bytes4(keccak256('approve(address,uint256)')) ^\r\n    //bytes4(keccak256('transfer(address,uint256)')) ^\r\n    //bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    //bytes4(keccak256('tokensOfOwner(address)')) ^\r\n    //bytes4(keccak256('tokenMetadata(uint256,string)'));\r\n\r\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\r\n    ///  ERC-165 (obviously!) and ERC-721.\r\n    //function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    //{\r\n    //    return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\r\n    //}\r\n\r\n    function setTokenURIAffixes(string calldata _prefix, string calldata _suffix) external onlyCEO {\r\n        tokenURIPrefix = _prefix;\r\n        tokenURISuffix = _suffix;\r\n    }\r\n\r\n    /// @dev Checks if a given address is the current owner of a particular Dragon.\r\n    /// @param _claimant the address we are validating against.\r\n    /// @param _tokenId dragon id, only valid when > 0\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return dragonIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /// @dev Checks if a given address currently has transferApproval for a particular Dragon.\r\n    /// @param _claimant the address we are confirming dragon is approved for.\r\n    /// @param _tokenId dragon id, only valid when > 0\r\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return dragonIndexToApproved[_tokenId] == _claimant;\r\n    }\r\n\r\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\r\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\r\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\r\n    ///  _approve() and transferFrom() are used together for putting Dragons on auction, and\r\n    ///  there is no value in spamming the log with Approval events in that case.\r\n    function _approve(uint256 _tokenId, address _approved) internal {\r\n        dragonIndexToApproved[_tokenId] = _approved;\r\n    }\r\n\r\n    /// @notice Returns the number of Dragons owned by a specific address.\r\n    /// @param _owner The owner address to check.\r\n    /// @dev Required for ERC-721 compliance\r\n    function balanceOf(address _owner) public view returns (uint256 count) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public payable\r\n    {\r\n        require(_to != address(0));\r\n        require(_to != address(this));\r\n        require(_to != address(saleAuction));\r\n        require(_to != address(siringAuction));\r\n\r\n        // Check for approval and valid ownership\r\n        //require(_approvedFor(msg.sender, _tokenId));\r\n        //require(_owns(_from, _tokenId));\r\n        address owner = ownerOf(_tokenId);\r\n        require(owner == _from);\r\n        require (owner == msg.sender || dragonIndexToApproved[_tokenId] == msg.sender || authorised[owner][msg.sender]);\r\n\r\n        // Reassign ownership, clearing pending approvals and emitting Transfer event.\r\n        _transfer(_from, _to, _tokenId);\r\n\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n\r\n        if(size > 0) {\r\n            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\r\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")));\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable\r\n    {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /// @notice Transfers a Dragon to another address. If transferring to a smart\r\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\r\n    ///  BlockDragonz specifically) or your Dragon may be lost forever. Seriously.\r\n    /// @param _to The address of the recipient, can be a user or contract.\r\n    /// @param _tokenId The ID of the Dragon to transfer.\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    whenNotPaused\r\n    {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any dragons (except very briefly\r\n        // after a firstGen dragon is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Disallow transfers to the auction contracts to prevent accidental\r\n        // misuse. Auction contracts should only take ownership of dragons\r\n        // through the allow + transferFrom flow.\r\n        require(_to != address(saleAuction));\r\n        require(_to != address(siringAuction));\r\n\r\n        // You can only send your own dragon.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Returns the address currently assigned ownership of a given Dragon.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function ownerOf(uint256 _tokenId) public view isValidToken(_tokenId) returns (address)\r\n    {\r\n        return dragonIndexToOwner[_tokenId];\r\n    }\r\n\r\n    /// @notice Grant another address the right to transfer a specific Dragon via\r\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\r\n    /// @param _approved The address to be granted transfer approval. Pass address(0) to\r\n    ///  clear all approvals.\r\n    /// @param _tokenId The ID of the Dragon that can be transferred if this call succeeds.\r\n    /// @dev Required for ERC-721 compliance.\r\n    //function approve( address _to, uint256 _tokenId) external whenNotPaused {\r\n    function approve(address _approved, uint256 _tokenId) external payable whenNotPaused {\r\n        // Only an owner can grant transfer approval.\r\n        //require(_owns(msg.sender, _tokenId) || authorised[owner][msg.sender]);\r\n        address owner = dragonIndexToOwner[_tokenId];\r\n        require(owner == msg.sender || authorised[owner][msg.sender]);\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _approved);\r\n\r\n        // Emit approval event.\r\n        //emit Approval(msg.sender, _approved, _tokenId);\r\n        emit Approval(owner, _approved, _tokenId);\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address)\r\n    {\r\n        return dragonIndexToApproved[_tokenId];\r\n    }\r\n\r\n\r\n    /// @notice Transfer a Dragon owned by another address, for which the calling address\r\n    ///  has previously been granted transfer approval by the owner.\r\n    /// @param _from The address that owns the Dragon to be transfered.\r\n    /// @param _to The address that should take ownership of the Dragon. Can be any address,\r\n    ///  including the caller.\r\n    /// @param _tokenId The ID of the Dragon to be transferred.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable whenNotPaused\r\n    {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        // The contract should never own any dragons (except very briefly\r\n        // after a firstGen dragon is created and before it goes on auction).\r\n        require(_to != address(this));\r\n        // Check for approval and valid ownership\r\n        //require(_approvedFor(msg.sender, _tokenId));\r\n        //require(_owns(_from, _tokenId));\r\n        address owner = ownerOf(_tokenId);\r\n        require(owner == _from);\r\n        require (owner == msg.sender || dragonIndexToApproved[_tokenId] == msg.sender || authorised[owner][msg.sender]);\r\n\r\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Returns the total number of Dragons currently in existence.\r\n    /// @dev Required for ERC-721 compliance.\r\n    function totalSupply() public view returns (uint) {\r\n        return dragons.length - 1;\r\n    }\r\n\r\n    /// @notice Returns a list of all Dragon IDs assigned to an address.\r\n    /// @param _owner The owner whose Dragons we are interested in.\r\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire Dragon array looking for dragons belonging to owner),\r\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] memory ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalDragons = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all dragons have IDs starting at 1 and increasing\r\n            // sequentially up to the totalDragon count.\r\n            uint256 dragonId;\r\n\r\n            for (dragonId = 1; dragonId <= totalDragons; dragonId++) {\r\n                if (dragonIndexToOwner[dragonId] == _owner) {\r\n                    result[resultIndex] = dragonId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256)\r\n    {\r\n        return _index;\r\n    }\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    //function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 dragonId)\r\n    {\r\n        uint256 count = 0;\r\n        for (uint256 i = 1; i <= totalSupply(); ++i) {\r\n            if (dragonIndexToOwner[i] == _owner) {\r\n                if (count == _index) {\r\n                    return i;\r\n                } else {\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n        revert();\r\n    }\r\n}\r\n\r\n// File: contracts/DragonBreeding.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title DragonCore that manages Dragon siring, gestation, and birth.\r\n/// @author Zynappse Corporation (https://www.zynapse.com)\r\n/// @dev See the DragonCore contract documentation to understand how the various contract facets are arranged.\r\ncontract DragonBreeding is DragonOwnership {\r\n\r\n    /// @dev The Pregnant event is fired when two dragons successfully breed and the pregnancy timer begins for the matron.\r\n    event Pregnant(address owner, uint256 matronId, uint256 sireId);\r\n\r\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\r\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\r\n    ///  the CIO role as the gas price changes.\r\n    uint256 public autoBirthFee = 2 finney;\r\n\r\n    // Keeps track of number of pregnant dragons.\r\n    uint256 public pregnantDragons;\r\n\r\n    uint32 public BREEDING_LIMIT = 3;\r\n    mapping(uint256 => uint64) breeding;\r\n\r\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret genetic combination algorithm.\r\n    //GeneScienceInterface public geneScience;\r\n\r\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\r\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\r\n    //function setGeneScienceAddress(address _address) external onlyCEO {\r\n    //    GeneScienceInterface candidateContract = GeneScienceInterface(_address);\r\n\r\n    // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n    //    require(candidateContract.isGeneScience());\r\n\r\n    // Set the new contract address\r\n    //    geneScience = candidateContract;\r\n    //}\r\n\r\n    /// @dev Checks that a given Dragon is able to breed. Requires that the\r\n    ///  current cooldown is finished (for sires) and also checks that there is\r\n    ///  no pending pregnancy.\r\n    function _isReadyToBreed(Dragon storage _dragon) internal view returns (bool) {\r\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\r\n        // the dragon has a pending birth; there can be some period of time between the end\r\n        // of the pregnacy timer and the birth event.\r\n        return (_dragon.siringWithId == 0);\r\n    }\r\n\r\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\r\n    ///  and matron have the same owner, or if the sire has given siring permission to\r\n    ///  the matron's owner (via approveSiring()).\r\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns (bool) {\r\n        address matronOwner = dragonIndexToOwner[_matronId];\r\n        address sireOwner = dragonIndexToOwner[_sireId];\r\n\r\n        // Siring is okay if they have same owner, or if the matron's owner was given\r\n        // permission to breed with this sire.\r\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\r\n    }\r\n\r\n\r\n\r\n    /// @notice Grants approval to another user to sire with one of your Dragons.\r\n    /// @param _addr The address that will be able to sire with your Dragon. Set to\r\n    ///  address(0) to clear all siring approvals for this Dragon.\r\n    /// @param _sireId A Dragon that you own that _addr will now be able to sire with.\r\n    function approveSiring(address _addr, uint256 _sireId)\r\n    external\r\n    whenNotPaused\r\n    {\r\n        require(_owns(msg.sender, _sireId));\r\n        sireAllowedToAddress[_sireId] = _addr;\r\n    }\r\n\r\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\r\n    ///  be called by the CMO address. (This fee is used to offset the gas cost incurred\r\n    ///  by the autobirth daemon).\r\n    function setAutoBirthFee(uint256 val) external onlyCLevel {\r\n        autoBirthFee = val;\r\n    }\r\n\r\n    /// @dev Checks to see if a given Dragon is pregnant and (if so) if the gestation period has passed.\r\n    function _isReadyToGiveBirth(Dragon storage _matron) private view returns (bool) {\r\n        return (_matron.siringWithId != 0);\r\n    }\r\n\r\n    /// @notice Checks that a given dragon is able to breed (i.e. it is not pregnant or\r\n    ///  in the middle of a siring cooldown).\r\n    /// @param _dragonId reference the id of the dragon, any user can inquire about it\r\n    function isReadyToBreed(uint256 _dragonId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        require(_dragonId > 0);\r\n        Dragon storage dragon = dragons[_dragonId];\r\n        return _isReadyToBreed(dragon);\r\n    }\r\n\r\n    /// @dev Checks whether a dragon is currently pregnant.\r\n    /// @param _dragonId reference the id of the dragon, any user can inquire about it\r\n    function isPregnant(uint256 _dragonId)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        require(_dragonId > 0);\r\n        // A dragon is pregnant if and only if this field is set\r\n        return dragons[_dragonId].siringWithId != 0;\r\n    }\r\n\r\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\r\n    /// check ownership permissions (that is up to the caller).\r\n    /// @param _matron A reference to the Dragon struct of the potential matron.\r\n    /// @param _matronId The matron's ID.\r\n    /// @param _sire A reference to the Dragon struct of the potential sire.\r\n    /// @param _sireId The sire's ID\r\n    function _isValidMatingPair(\r\n        Dragon storage _matron,\r\n        uint256 _matronId,\r\n        Dragon storage _sire,\r\n        uint256 _sireId\r\n    )\r\n    private\r\n    view\r\n    returns(bool)\r\n    {\r\n        if(breeding[_matronId] >= BREEDING_LIMIT) {\r\n            return false;\r\n        }\r\n\r\n        uint256 sireElement = _sire.dna / 1e34;\r\n        uint256 matronElement = _matron.dna / 1e34;\r\n\r\n        if (sireElement != matronElement) {\r\n          return false;\r\n        }\r\n\r\n        // A Dragon can't breed with itself!\r\n        if (_matronId == _sireId) {\r\n            return false;\r\n        }\r\n\r\n        // Dragons can't breed with their parents.\r\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\r\n            return false;\r\n        }\r\n\r\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\r\n            return false;\r\n        }\r\n\r\n        // We can short circuit the sibling check (below) if either dragon is first generation (has a matron ID of zero).\r\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\r\n            return true;\r\n        }\r\n\r\n        // Dragons can't breed with full or half siblings.\r\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\r\n            return false;\r\n        }\r\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\r\n            return false;\r\n        }\r\n\r\n        // Everything seems cool! Let's get DTF.\r\n        return true;\r\n    }\r\n\r\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\r\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\r\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        Dragon storage matron = dragons[_matronId];\r\n        Dragon storage sire = dragons[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\r\n    }\r\n\r\n    /// @notice Checks to see if two dragons can breed together, including checks for\r\n    ///  ownership and siring approvals. Does NOT check that both dragons are ready for\r\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\r\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\r\n    /// @param _matronId The ID of the proposed matron.\r\n    /// @param _sireId The ID of the proposed sire.\r\n    function canBreedWith(uint256 _matronId, uint256 _sireId)\r\n    external\r\n    view\r\n    returns(bool)\r\n    {\r\n        require(_matronId > 0);\r\n        require(_sireId > 0);\r\n        Dragon storage matron = dragons[_matronId];\r\n        Dragon storage sire = dragons[_sireId];\r\n        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&\r\n        _isSiringPermitted(_sireId, _matronId);\r\n    }\r\n\r\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\r\n    ///  requirements have been checked.\r\n    function _breedWith(uint256 _matronId, uint256 _sireId) internal {\r\n        // Grab a reference to the Dragons from storage.\r\n        // Dragon storage sire = dragons[_sireId];\r\n        Dragon storage matron = dragons[_matronId];\r\n\r\n        // Mark the matron as pregnant, keeping track of who the sire is.\r\n        matron.siringWithId = uint32(_sireId);\r\n\r\n        // Trigger the cooldown for both parents.\r\n        // _triggerCooldown(sire);\r\n        // _triggerCooldown(matron);\r\n\r\n        // Clear siring permission for both parents. This may not be strictly necessary but it's likely to avoid confusion!\r\n        delete sireAllowedToAddress[_matronId];\r\n        delete sireAllowedToAddress[_sireId];\r\n\r\n        // Every time a dragon gets pregnant, counter is incremented.\r\n        pregnantDragons++;\r\n\r\n        // Emit the pregnancy event.\r\n        emit Pregnant(dragonIndexToOwner[_matronId], _matronId, _sireId);\r\n    }\r\n\r\n    /// @notice Breed a Dragon you own (as matron) with a sire that you own, or for which you\r\n    ///  have previously been given Siring approval. Will either make your dragon pregnant, or will\r\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\r\n    /// @param _matronId The ID of the Dragon acting as matron (will end up pregnant if successful)\r\n    /// @param _sireId The ID of the Dragon acting as sire (will begin its siring cooldown if successful)\r\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    {\r\n        // Checks for payment.\r\n        require(msg.value >= autoBirthFee);\r\n\r\n        // Caller must own the matron.\r\n        require(_owns(msg.sender, _matronId));\r\n\r\n        // Neither sire nor matron are allowed to be on auction during a normal\r\n        // breeding operation, but we don't need to check that explicitly.\r\n        // For matron: The caller of this function can't be the owner of the matron\r\n        //   because the owner of a Dragon on auction is the auction house, and the\r\n        //   auction house will never call breedWith().\r\n        // For sire: Similarly, a sire on auction will be owned by the auction house\r\n        //   and the act of transferring ownership will have cleared any oustanding\r\n        //   siring approval.\r\n        // Thus we don't need to spend gas explicitly checking to see if either dragon\r\n        // is on auction.\r\n\r\n        // Check that matron and sire are both owned by caller, or that the sire\r\n        // has given siring permission to caller (i.e. matron's owner).\r\n        // Will fail for _sireId = 0\r\n        require(_isSiringPermitted(_sireId, _matronId));\r\n\r\n        // Grab a reference to the potential matron\r\n        Dragon storage matron = dragons[_matronId];\r\n\r\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\r\n        require(_isReadyToBreed(matron));\r\n\r\n        // Grab a reference to the potential sire\r\n        Dragon storage sire = dragons[_sireId];\r\n\r\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\r\n        require(_isReadyToBreed(sire));\r\n\r\n        // Update the breedTime\r\n        matron.breedTime = uint64(now);\r\n\r\n        // Test that these dragons are a valid mating pair.\r\n        require(_isValidMatingPair(\r\n                matron,\r\n                _matronId,\r\n                sire,\r\n                _sireId\r\n            ));\r\n\r\n\r\n        // All checks passed, dragon gets pregnant!\r\n        _breedWith(_matronId, _sireId);\r\n    }\r\n\r\n    /// @notice Have a pregnant Dragon give birth!\r\n    /// @param _matronId A Dragon ready to give birth.\r\n    /// @param _dna Dragon's DNA\r\n    /// @param _agility Dragon's agility initial value\r\n    /// @param _strength Dragon's Strenght initial value\r\n    /// @param _intelligence Dragon's Intelligence initial value\r\n    /// @param _runelevel Dragon's Rune Level initial value\r\n    /// @return The Dragon ID of the new dragon.\r\n    /// @dev Looks at a given Dragon and, if pregnant and if the gestation period has passed,\r\n    ///  combines the genes of the two parents to create a new dragon. The new Dragon is assigned\r\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\r\n    ///  new dragon will be ready to breed again. Note that anyone can call this function (if they\r\n    ///  are willing to pay the gas!), but the new dragon always goes to the mother's owner.\r\n    function giveBirth(uint256 _matronId, uint256 _dna, uint64 _agility, uint64 _strength, uint64 _intelligence, uint64 _runelevel)\r\n    external\r\n    whenNotPaused\r\n    onlyCOO\r\n    returns(uint256)\r\n    {\r\n        // Grab a reference to the matron in storage.\r\n        Dragon storage matron = dragons[_matronId];\r\n\r\n        // Check that the dragon is a valid dragon.\r\n        require(matron.birthTime != 0);\r\n\r\n        // Check that the matron is pregnant, and that its time has come!\r\n        require(_isReadyToGiveBirth(matron));\r\n\r\n        // Grab a reference to the sire in storage.\r\n        uint256 sireId = matron.siringWithId;\r\n        Dragon storage sire = dragons[sireId];\r\n\r\n        // Determine the higher generation number of the two parents\r\n        uint32 parentGen = matron.generation;\r\n        if (sire.generation > matron.generation) {\r\n            parentGen = sire.generation;\r\n        }\r\n\r\n        // Call the sooper-sekret gene mixing operation.\r\n        uint256 matronId = _matronId;\r\n        uint64 agility = _agility;\r\n        uint64 strength = _strength;\r\n        uint64 intelligence = _intelligence;\r\n        uint64 runelevel = _runelevel;\r\n\r\n        uint256 childDNA = _dna;\r\n\r\n        // Make the new dragon!\r\n        address owner = dragonIndexToOwner[matronId];\r\n        //uint256 dragonId = _createDragon(_matronId, matron.siringWithId, parentGen + 1, childDNA, _agility, _strength, _intelligence, _runelevel, owner);\r\n        uint256 dragonId = _createDragon(matronId, sireId, parentGen + 1, childDNA, agility, strength, intelligence, runelevel, owner);\r\n\r\n        //increment the breeding for the matron\r\n        breeding[matronId]++;\r\n\r\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\r\n        // set is what marks a matron as being pregnant.)\r\n        delete matron.siringWithId;\r\n\r\n        // Every time a dragon gives birth counter is decremented.\r\n        pregnantDragons--;\r\n\r\n        // Send the balance fee to the person who made birth happen.\r\n        //msg.sender.send(autoBirthFee);\r\n        msg.sender.transfer(autoBirthFee);\r\n\r\n        // return the new dragon's ID\r\n        return dragonId;\r\n    }\r\n\r\n    function getPregnantDragons() external view returns(uint256[] memory pregnantDragonsList) {\r\n\r\n        if (pregnantDragons == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](pregnantDragons);\r\n            uint256 totalDragons = totalSupply();\r\n            uint256 resultIndex = 0;\r\n\r\n             uint256 dragonId;\r\n\r\n            for (dragonId = 1; dragonId <= totalDragons; dragonId++) {\r\n                if (isPregnant(dragonId)) {\r\n                    result[resultIndex] = dragonId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function setBreedingLimit(uint32 _value) external onlyCLevel {\r\n        BREEDING_LIMIT = _value;\r\n    }\r\n}\r\n\r\n// File: contracts/DragonAuction.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title Handles creating auctions for sale and siring of dragons.\r\n/// @author Zynappse Corporation (https://www.zynapse.com)\r\n///  This wrapper of ReverseAuction exists only so that users can create\r\n///  auctions with only one transaction.\r\ncontract DragonAuction is DragonBreeding {\r\n\r\n    // @notice The auction contract variables are defined in DragonBase to allow\r\n    //  us to refer to them in DragonOwnership to prevent accidental transfers.\r\n    // `saleAuction` refers to the auction for gen0 and p2p sale of dragons.\r\n    // `siringAuction` refers to the auction for siring rights of dragons.\r\n\r\n    /// @dev Sets the reference to the sale auction.\r\n    /// @param _address - Address of sale contract.\r\n    function setSaleAuctionAddress(address _address) external onlyCEO {\r\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isSaleClockAuction());\r\n\r\n        // Set the new contract address\r\n        saleAuction = candidateContract;\r\n    }\r\n\r\n    /// @dev Sets the reference to the siring auction.\r\n    /// @param _address - Address of siring contract.\r\n    function setSiringAuctionAddress(address _address) external onlyCEO {\r\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\r\n\r\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\r\n        require(candidateContract.isSiringClockAuction());\r\n\r\n        // Set the new contract address\r\n        siringAuction = candidateContract;\r\n    }\r\n\r\n    /// @dev Put a dragon up for auction.\r\n    ///  Does some ownership trickery to create auctions in one tx.\r\n    function createSaleAuction(\r\n        uint256 _dragonId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n    external\r\n    whenNotPaused\r\n    {\r\n        // Auction contract checks input sizes\r\n        // If dragon is already on any auction, this will throw\r\n        // because it will be owned by the auction contract.\r\n        require(_owns(msg.sender, _dragonId));\r\n        // Ensure the dragon is not pregnant to prevent the auction\r\n        // contract accidentally receiving ownership of the child.\r\n        // NOTE: the dragon IS allowed to be in a cooldown.\r\n        require(!isPregnant(_dragonId));\r\n        _approve(_dragonId, address(saleAuction));\r\n        // Sale auction throws if inputs are invalid and clears\r\n        // transfer and sire approval after escrowing the dragon.\r\n        saleAuction.createAuction(\r\n            _dragonId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /// @dev Put a dragon up for auction to be sire.\r\n    ///  Performs checks to ensure the dragon can be sired, then\r\n    ///  delegates to reverse auction.\r\n    function createSiringAuction(\r\n        uint256 _dragonId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n    external\r\n    whenNotPaused\r\n    {\r\n        // Auction contract checks input sizes\r\n        // If dragon is already on any auction, this will throw\r\n        // because it will be owned by the auction contract.\r\n        require(_owns(msg.sender, _dragonId));\r\n        require(isReadyToBreed(_dragonId));\r\n        _approve(_dragonId, address(siringAuction));\r\n        // Siring auction throws if inputs are invalid and clears\r\n        // transfer and sire approval after escrowing the dragon.\r\n        siringAuction.createAuction(\r\n            _dragonId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n\r\n    /// @dev Completes a siring auction by bidding.\r\n    ///  Immediately breeds the winning matron with the sire on auction.\r\n    /// @param _sireId - ID of the sire on auction.\r\n    /// @param _matronId - ID of the matron owned by the bidder.\r\n    function bidOnSiringAuction(\r\n        uint256 _sireId,\r\n        uint256 _matronId\r\n    )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    {\r\n        // Auction contract checks input sizes\r\n        require(_owns(msg.sender, _matronId));\r\n        require(isReadyToBreed(_matronId));\r\n        require(_canBreedWithViaAuction(_matronId, _sireId));\r\n\r\n        // Define the current price of the auction.\r\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\r\n        require(msg.value >= currentPrice + autoBirthFee);\r\n\r\n        // Siring auction will throw if the bid fails.\r\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\r\n        _breedWith(uint32(_matronId), uint32(_sireId));\r\n    }\r\n\r\n    /// @dev Transfers the balance of the sale auction contract\r\n    /// to the DragonCore contract. We use two-step withdrawal to\r\n    /// prevent two transfer calls in the auction bid function.\r\n    function withdrawAuctionBalances() external onlyCLevel {\r\n        saleAuction.withdrawBalance();\r\n        siringAuction.withdrawBalance();\r\n    }\r\n\r\n    /// @dev Shows the balance of the auction contracts.\r\n    function getAuctionBalances() external view onlyCLevel returns (uint256, uint256) {\r\n        return (\r\n            address(saleAuction).balance,\r\n            address(siringAuction).balance\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/DragonMinting.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\n/// @title all functions related to creating dragons\r\ncontract DragonMinting is DragonAuction {\r\n\r\n    /// @dev we can create promo dragons, up to a limit. Only callable by CMO\r\n    /// @param _dna the encoded genes of the dragons to be created, any value is accepted\r\n    /// @param _owner the future owner of the created dragons. Default to contract CMO\r\n    function createPromoDragon(\r\n        uint256 _dna,\r\n        uint64 _agility,\r\n        uint64 _strength,\r\n        uint64 _intelligence,\r\n        uint64 _runelevel,\r\n        address _owner)\r\n        external onlyCLevel {\r\n\r\n        address dragonOwner = _owner;\r\n        if (dragonOwner == address(0)) {\r\n            dragonOwner = cmoAddress;\r\n        }\r\n\r\n        _createDragon(0, 0, 0, _dna, _agility, _strength, _intelligence, _runelevel, dragonOwner);\r\n    }\r\n\r\n    /// @dev Creates a new gen0 dragon with the given dna and\r\n    ///  creates an auction for it.\r\n    function createGen0Auction(\r\n        uint256 _dna,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint64 _agility,\r\n        uint64 _strength,\r\n        uint64 _intelligence,\r\n        uint256 _duration )\r\n        external onlyCLevel {\r\n\r\n        //require(gen0CreatedCount < GEN0_CREATION_LIMIT);\r\n\r\n\r\n        uint256 dragonId = _createDragon(0, 0, 0, _dna, _agility, _strength, _intelligence, 0, address(this));\r\n        _approve(dragonId, address(saleAuction));\r\n\r\n        saleAuction.createAuction(\r\n            dragonId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            address(uint160(address(this)))\r\n        );\r\n\r\n        //gen0CreatedCount++;\r\n    }\r\n}\r\n\r\n// File: contracts/DragonCore.sol\r\n\r\npragma solidity ^0.5.10;\r\n\r\n\r\ncontract DragonCore is DragonMinting {\r\n\r\n    // Set in case the core contract is broken and an upgrade is required\r\n    address public newContractAddress;\r\n\r\n    /// @notice Creates the main BlockDragonz smart contract instance.\r\n    constructor () public {\r\n        // Starts paused.\r\n        paused = true;\r\n\r\n        // the creator of the contract is the initial CEO\r\n        ceoAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial CMO\r\n        cmoAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial CIO\r\n        cioAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial CFO\r\n        cfoAddress = msg.sender;\r\n\r\n        // the creator of the contract is also the initial COO\r\n        cooAddress = msg.sender;\r\n\r\n        // ERC-165 Base\r\n        supportedInterfaces[0x01ffc9a7] = true;\r\n\r\n        // ERC-721 Base\r\n        supportedInterfaces[0x80ac58cd] = true;\r\n\r\n        // ERC-721 Metadata\r\n        supportedInterfaces[0x5b5e139f] = true;\r\n\r\n        // ERC-721 Enumerable\r\n        supportedInterfaces[0x780e9d63] = true;\r\n\r\n        //ERC-721 Receiver\r\n        supportedInterfaces[0x150b7a02] = true;\r\n\r\n        // start with the mythical dragon 0 - so we don't have generation-0 parent issues\r\n        _createDragon(0, 0, 0, uint256(-1), 0,0,0,0,  address(0));\r\n    }\r\n\r\n    function setNewAddress(address _newAddress) external onlyCEO whenPaused {\r\n        newContractAddress = _newAddress;\r\n        emit ContractUpgrade(_newAddress);\r\n    }\r\n\r\n    /// @notice No tipping!\r\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\r\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\r\n    function() external payable {\r\n        require(\r\n            msg.sender == address(saleAuction) ||\r\n            msg.sender == address(siringAuction)\r\n        );\r\n    }\r\n    /// @notice Returns all the relevant information about a specific dragon.\r\n    /// @param _id The ID of the dragon of interest.\r\n    function getDragon(uint256 _id)\r\n    external\r\n    view\r\n    returns (\r\n        uint256 dna,\r\n        uint256 birthTime,\r\n        uint256 breedTime,\r\n        uint256 matronId,\r\n        uint256 sireId,\r\n        uint256 siringWithId,\r\n        uint256 generation,\r\n        uint256 runeLevel,\r\n        uint256 agility,\r\n        uint256 strength,\r\n        uint256 intelligence\r\n    ) {\r\n        Dragon storage dragon = dragons[_id];\r\n        DragonAssets storage dragonAsset = dragonAssets[_id];\r\n\r\n        dna = dragon.dna;\r\n        birthTime = uint256(dragon.birthTime);\r\n        breedTime = uint256(dragon.breedTime);\r\n        matronId = uint256(dragon.matronId);\r\n        sireId = uint256(dragon.sireId);\r\n        siringWithId = uint256(dragon.siringWithId);\r\n        generation = uint256(dragon.generation);\r\n        runeLevel = dragonAsset.runeLevel;\r\n        agility = dragonAsset.agility;\r\n        strength = dragonAsset.strength;\r\n        intelligence = dragonAsset.intelligence;\r\n    }\r\n\r\n    /// @dev Override unpause so it requires all external contract addresses\r\n    ///  to be set before contract can be unpaused. Also, we can't have\r\n    ///  newContractAddress set either, because then the contract was upgraded.\r\n    /// @notice This is public rather than external so we can call super.unpause\r\n    ///  without using an expensive CALL.\r\n    function unpause() public onlyCEO whenPaused {\r\n        require(address(saleAuction) != address(0));\r\n        require(address(siringAuction) != address(0));\r\n        require(newContractAddress == address(0));\r\n\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n\r\n    // @dev Allows the CIO to capture the balance available to the contract.\r\n    function withdrawBalance() external onlyCLevel {\r\n        uint256 balance = address(this).balance;\r\n        // Subtract all the currently pregnant dragons we have, plus 1 of margin.\r\n        uint256 subtractFees = (pregnantDragons + 1) * autoBirthFee;\r\n\r\n        if (balance > subtractFees) {\r\n            //cioAddress.send(balance - subtractFees);\r\n            cfoAddress.transfer(balance - subtractFees);\r\n        }\r\n    }\r\n\r\n    /// @dev Shows the contract's current balance.\r\n    function getBalance() external view onlyCLevel returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n}"
    }
  }
}