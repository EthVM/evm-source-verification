{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ConnectCompound.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); // For ERC20\r\n    function liquidateBorrow(address borrower, uint repayAmount, address cTokenCollateral) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function exchangeRateCurrent() external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    function repayBorrowBehalf(address borrower) external payable;\r\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ninterface TokenInterface {\r\n    function allowance(address, address) external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    function exitMarket(address cTokenAddress) external returns (uint);\r\n    function getAssetsIn(address account) external view returns (address[] memory);\r\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n    function claimComp(address) external;\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint _id) external returns (uint _num);\r\n    function setUint(uint _id, uint _val) external;\r\n}\r\n\r\ncontract DSMath {\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Helpers is DSMath {\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getAddressETH() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Memory Variable Address\r\n     */\r\n    function getMemoryAddr() internal pure returns (address) {\r\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n    }\r\n\r\n    // /**\r\n    //  * @dev Return InstaEvent Address.\r\n    //  */\r\n    // function getEventAddr() internal pure returns (address) {\r\n    //     return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n    // }\r\n\r\n    /**\r\n     * @dev Get Uint value from InstaMemory Contract.\r\n    */\r\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Uint value in InstaMemory Contract.\r\n    */\r\n    function setUint(uint setId, uint val) internal {\r\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 57);\r\n    }\r\n}\r\n\r\n\r\ncontract CompoundHelpers is Helpers {\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev Return COMP Token Address.\r\n     */\r\n    function getCompTokenAddress() internal pure returns (address) {\r\n        return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Addresses\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev enter compound market\r\n     */\r\n    function enterMarket(address cToken) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory markets = troller.getAssetsIn(address(this));\r\n        bool isEntered = false;\r\n        for (uint i = 0; i < markets.length; i++) {\r\n            if (markets[i] == cToken) {\r\n                isEntered = true;\r\n            }\r\n        }\r\n        if (!isEntered) {\r\n            address[] memory toEnter = new address[](1);\r\n            toEnter[0] = cToken;\r\n            troller.enterMarkets(toEnter);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BasicResolver is CompoundHelpers {\r\n    event LogDeposit(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogWithdraw(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogBorrow(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n    event LogPayback(address indexed token, address cToken, uint256 tokenAmt, uint256 getId, uint256 setId);\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to deposit.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function deposit(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(CTokenInterface(cToken).mint(_amt) == 0, \"deposit-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogDeposit(token, cToken, _amt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw ETH/ERC20_Token.\r\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to withdraw.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdraw(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        if (_amt == uint(-1)) {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            uint initialBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \"full-withdraw-failed\");\r\n            uint finalBal = token == getAddressETH() ? address(this).balance : tokenContract.balanceOf(address(this));\r\n            _amt = finalBal - initialBal;\r\n        } else {\r\n            require(cTokenContract.redeemUnderlying(_amt) == 0, \"withdraw-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogWithdraw(token, cToken, _amt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Borrow ETH/ERC20_Token.\r\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to borrow.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function borrow(address token, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \"borrow-failed\");\r\n        setUint(setId, _amt);\r\n\r\n        emit LogBorrow(token, cToken, _amt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Payback borrowed ETH/ERC20_Token.\r\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to payback.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function payback(address token, uint amt, uint getId, uint setId) external payable {\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : _amt;\r\n\r\n        if (token == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enough-eth\");\r\n            CETHInterface(cToken).repayBorrow.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(cToken, _amt);\r\n            require(cTokenContract.repayBorrow(_amt) == 0, \"repay-failed.\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogPayback(token, cToken, _amt, getId, setId);\r\n    }\r\n}\r\n\r\ncontract ExtraResolver is BasicResolver {\r\n    event LogClaimedComp(uint256 compAmt, uint256 setId);\r\n    event LogDepositCToken(address indexed token, address cToken, uint256 tokenAmt, uint256 cTokenAmt,uint256 getId, uint256 setId);\r\n    event LogWithdrawCToken(address indexed token, address cToken, uint256 tokenAmt, uint256 cTokenAmt, uint256 getId, uint256 setId);\r\n    event LogLiquidate(\r\n        address indexed borrower,\r\n        address indexed tokenToPay,\r\n        address indexed tokenInReturn,\r\n        uint256 tokenAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n\r\n    /**\r\n     * @dev Deposit ETH/ERC20_Token.\r\n     * @param token token address to depositCToken.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to depositCToken.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function depositCToken(address token, uint amt, uint getId, uint setId) external payable{\r\n        uint _amt = getUint(getId, amt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        enterMarket(cToken);\r\n\r\n        CTokenInterface ctokenContract = CTokenInterface(cToken);\r\n        uint initialBal = ctokenContract.balanceOf(address(this));\r\n\r\n        if (token == getAddressETH()) {\r\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\r\n            CETHInterface(cToken).mint.value(_amt)();\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(token);\r\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\r\n            tokenContract.approve(cToken, _amt);\r\n            require(ctokenContract.mint(_amt) == 0, \"deposit-ctoken-failed.\");\r\n        }\r\n\r\n        uint finalBal = ctokenContract.balanceOf(address(this));\r\n        uint _cAmt = finalBal - initialBal;\r\n        setUint(setId, _cAmt);\r\n\r\n        emit LogDepositCToken(token, cToken, _amt, _cAmt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw CETH/CERC20_Token using cToken Amt.\r\n     * @param token token address to withdraw CToken.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param cTokenAmt ctoken amount to withdrawCToken.\r\n     * @param getId Get ctoken amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function withdrawCToken(address token, uint cTokenAmt, uint getId, uint setId) external payable {\r\n        uint _cAmt = getUint(getId, cTokenAmt);\r\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\r\n        TokenInterface tokenContract = TokenInterface(token);\r\n        _cAmt = _cAmt == uint(-1) ? cTokenContract.balanceOf(address(this)) : _cAmt;\r\n\r\n        uint initialBal = token != getAddressETH() ? tokenContract.balanceOf(address(this)) : address(this).balance;\r\n        require(cTokenContract.redeem(_cAmt) == 0, \"redeem-failed\");\r\n        uint finalBal = token != getAddressETH() ? tokenContract.balanceOf(address(this)) : address(this).balance;\r\n\r\n        uint withdrawAmt = sub(finalBal, initialBal);\r\n        setUint(setId, withdrawAmt);\r\n\r\n        emit LogWithdrawCToken(token, cToken, withdrawAmt, _cAmt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Liquidate a position.\r\n     * @param borrower Borrower's Address.\r\n     * @param tokenToPay token address to pay for liquidation.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param tokenInReturn token address to return for liquidation.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amt token amount to pay for liquidation.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function liquidate(\r\n        address borrower,\r\n        address tokenToPay,\r\n        address tokenInReturn,\r\n        uint amt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable\r\n    {\r\n        uint _amt = getUint(getId, amt);\r\n        address cTokenPay = InstaMapping(getMappingAddr()).cTokenMapping(tokenToPay);\r\n        address cTokenColl = InstaMapping(getMappingAddr()).cTokenMapping(tokenInReturn);\r\n        CTokenInterface cTokenContract = CTokenInterface(cTokenPay);\r\n\r\n        (,, uint shortfal) = ComptrollerInterface(getComptrollerAddress()).getAccountLiquidity(borrower);\r\n        require(shortfal != 0, \"account-cannot-be-liquidated\");\r\n\r\n        _amt = _amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(borrower) : _amt;\r\n        if (tokenToPay == getAddressETH()) {\r\n            require(address(this).balance >= _amt, \"not-enought-eth\");\r\n            CETHInterface(cTokenPay).liquidateBorrow.value(_amt)(borrower, cTokenColl);\r\n        } else {\r\n            TokenInterface tokenContract = TokenInterface(tokenToPay);\r\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\r\n            tokenContract.approve(cTokenPay, _amt);\r\n            require(cTokenContract.liquidateBorrow(borrower, _amt, cTokenColl) == 0, \"liquidate-failed\");\r\n        }\r\n        setUint(setId, _amt);\r\n\r\n        emit LogLiquidate(\r\n            address(this),\r\n            tokenToPay,\r\n            tokenInReturn,\r\n            _amt,\r\n            getId,\r\n            setId\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract ConnectCompound is ExtraResolver {\r\n    string public name = \"Compound-v1.3\";\r\n}"
    }
  }
}