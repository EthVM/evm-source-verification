{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"},"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"},"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"},"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal initializer {\n        __ERC721Holder_init_unchained();\n    }\n\n    function __ERC721Holder_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    uint256[50] private __gap;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"},"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"},"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"},"@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"contracts/UniQuest.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\r\n\r\nimport \"./interfaces/IUninterestedUnicorns.sol\";\r\nimport \"./interfaces/ICandyToken.sol\";\r\n\r\ncontract UniQuest is\r\n    AccessControlUpgradeable,\r\n    ERC721HolderUpgradeable,\r\n    ReentrancyGuardUpgradeable\r\n{\r\n    using SafeMathUpgradeable for uint256;\r\n    using CountersUpgradeable for CountersUpgradeable.Counter;\r\n\r\n    struct Quest {\r\n        address questOwner;\r\n        uint256 questLevel;\r\n        uint256 questStart;\r\n        uint256 questEnd;\r\n        uint256 lastClaim;\r\n        uint256 clanMultiplier;\r\n        uint256 rareMultiplier;\r\n        uint256 lengthMultiplier;\r\n        uint256[] unicornIds;\r\n        QuestState questState;\r\n    }\r\n\r\n    struct ClanCounter {\r\n        uint8 airCount;\r\n        uint8 earthCount;\r\n        uint8 fireCount;\r\n        uint8 waterCount;\r\n        uint8 darkCount;\r\n        uint8 pureCount;\r\n    }\r\n\r\n    // Enums\r\n    enum Clans {\r\n        AIR,\r\n        EARTH,\r\n        FIRE,\r\n        WATER,\r\n        DARK,\r\n        PURE\r\n    }\r\n\r\n    enum QuestState {\r\n        IN_PROGRESS,\r\n        ENDED\r\n    }\r\n\r\n    IUninterestedUnicorns public UU;\r\n    ICandyToken public UCD;\r\n\r\n    uint256 public baseReward;\r\n    uint256 public baseRoboReward;\r\n    uint256 public baseGoldenReward;\r\n    uint256 private timescale;\r\n\r\n    uint256[] public clanMultipliers;\r\n    uint256[] public rareMultipliers;\r\n    uint256[] public lengthMultipliers;\r\n    uint256[] public questLengths;\r\n    bytes public clans;\r\n\r\n    mapping(uint256 => Quest) public quests;\r\n    mapping(address => uint256[]) public userQuests; // Maps user address to questIds\r\n    mapping(uint256 => uint256) public onQuest; // Maps tokenId to QuestId (0 = not questing)\r\n    mapping(uint256 => uint256) clanCounter;\r\n\r\n    mapping(uint256 => bool) private isRoboUni;\r\n    mapping(uint256 => bool) private isGoldenUni;\r\n    mapping(uint256 => uint256) private HODLLastClaim;\r\n\r\n    // Private Variables\r\n    CountersUpgradeable.Counter private _questId;\r\n    bool private initialized;\r\n\r\n    // Reserve Storage\r\n    uint256[50] private ______gap;\r\n\r\n    // Events\r\n    event QuestStarted(\r\n        address indexed user,\r\n        uint256 questId,\r\n        uint256[] unicornIds,\r\n        uint256 questLevel,\r\n        uint256 questStart,\r\n        uint256 questEnd\r\n    );\r\n    event QuestEnded(address indexed user, uint256 questId, uint256 endDate);\r\n    event RewardClaimed(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 claimTime\r\n    );\r\n\r\n    event QuestUpgraded(\r\n        address indexed user,\r\n        uint256 questId,\r\n        uint256 questLevel\r\n    );\r\n\r\n    // Modifiers\r\n    modifier onlyAdmin() {\r\n        require(\r\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\r\n            \"UninterestedUnicorns: OnlyAdmin\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function __UniQuest_init(\r\n        address uu,\r\n        uint256 _baseReward,\r\n        uint256 _baseRoboReward,\r\n        uint256 _baseGoldenReward,\r\n        address deployer,\r\n        address treasury\r\n    ) public initializer {\r\n        require(!initialized, \"Contract instance has already been initialized\");\r\n        __AccessControl_init();\r\n        __ReentrancyGuard_init();\r\n        __ERC721Holder_init();\r\n\r\n        // Constructor init\r\n        _setupRole(DEFAULT_ADMIN_ROLE, deployer); // To revoke access after functions are set\r\n        grantRole(DEFAULT_ADMIN_ROLE, treasury);\r\n        baseReward = _baseReward;\r\n        baseRoboReward = _baseRoboReward;\r\n        baseGoldenReward = _baseGoldenReward;\r\n        UU = IUninterestedUnicorns(uu);\r\n        clanMultipliers = [10000, 10000, 10200, 10400, 10600, 11000];\r\n        rareMultipliers = [10000, 10200, 10400, 10600, 10800, 11000];\r\n        lengthMultipliers = [10000, 10500, 11000];\r\n        questLengths = [30 days, 90 days, 180 days];\r\n        timescale = 1 days;\r\n\r\n        initialized = true;\r\n    }\r\n\r\n    // ------------------------- USER FUNCTION ---------------------------\r\n\r\n    /// @dev Start quest. questLevels = 0,1,2\r\n    /// @notice Sends U_Us (max. 5) on a quest, U_Us of the same clan and if rare will get a bonus multiplier!\r\n    function startQuest(uint256[] memory unicornIds, uint256 questLevel)\r\n        public\r\n    {\r\n        require(\r\n            areOwned(unicornIds),\r\n            \"UniQuest: One or More Unicorns are not owned by you!\"\r\n        );\r\n\r\n        require(questLevel <= 2, \"UniQuest: Invalid Quest Level!\");\r\n        require(unicornIds.length <= 5, \"UniQuest: Maximum of 5 U_U only!\");\r\n        require(unicornIds.length > 0, \"UniQuest: At least 1 U_U required!\");\r\n\r\n        _questId.increment();\r\n        _lockTokens(unicornIds);\r\n\r\n        for (uint256 i = 0; i < unicornIds.length; i++) {\r\n            onQuest[unicornIds[i]] = _questId.current();\r\n        }\r\n\r\n        uint256 _clanMultiplier;\r\n        uint256 _rareMultiplier;\r\n\r\n        (_clanMultiplier, _rareMultiplier) = calculateMultipliers(unicornIds);\r\n\r\n        Quest memory _quest = Quest(\r\n            msg.sender, // address questOwner\r\n            questLevel, // uint256 questLevel;\r\n            block.timestamp, // uint256 questStart;\r\n            block.timestamp.add(questLengths[questLevel]), // uint256 questEnd;\r\n            block.timestamp, // uint256 lastClaim;\r\n            _clanMultiplier, // uint256 clanMultiplier;\r\n            _rareMultiplier, // uint256 rareMultiplier;\r\n            lengthMultipliers[questLevel], // uint256 lengthMultiplier;\r\n            unicornIds, // uint256[] unicornIds;\r\n            QuestState.IN_PROGRESS // QuestState questState;\r\n        );\r\n\r\n        quests[_questId.current()] = _quest;\r\n        userQuests[msg.sender].push(_questId.current());\r\n\r\n        emit QuestStarted(\r\n            msg.sender,\r\n            _questId.current(),\r\n            unicornIds,\r\n            questLevel,\r\n            block.timestamp,\r\n            block.timestamp.add(questLengths[questLevel])\r\n        );\r\n    }\r\n\r\n    /// @dev Start quest. questLevels = 0,1,2\r\n    /// @notice Sends U_Us (max. 5) on a quest, U_Us of the same clan and if rare will get a bonus multiplier!\r\n    function upgradeQuest(uint256 questId, uint256 questLevel) public {\r\n        Quest storage quest = quests[questId];\r\n        require(\r\n            quest.questOwner == msg.sender,\r\n            \"UniQuest: Quest not owned by you!\"\r\n        );\r\n\r\n        require(questLevel <= 2, \"UniQuest: Invalid Quest Level!\");\r\n        require(\r\n            questLevel > quest.questLevel,\r\n            \"UniQuest: Invalid Quest Level!\"\r\n        );\r\n\r\n        // Increase Lockup Duration\r\n        quest.questLevel = questLevel;\r\n        quest.questEnd = block.timestamp + questLengths[questLevel];\r\n        quest.lengthMultiplier = lengthMultipliers[questLevel];\r\n    }\r\n\r\n    /// @dev Claim UCD reward for given quest\r\n    function claimRewards(uint256 questId) public nonReentrant {\r\n        Quest storage quest = quests[questId];\r\n        address questOwner = quest.questOwner;\r\n        require(\r\n            msg.sender == questOwner,\r\n            \"UniQuest: Only quest owner can claim candy\"\r\n        );\r\n        require(\r\n            quest.questState == QuestState.IN_PROGRESS,\r\n            \"UniQuest: Quest has already ended!\"\r\n        );\r\n        uint256 rewards = calculateRewards(questId);\r\n        UCD.mint(questOwner, rewards);\r\n        quest.lastClaim = block.timestamp;\r\n        emit RewardClaimed(msg.sender, rewards, block.timestamp);\r\n    }\r\n\r\n    /// @dev QOL to claim all rewards\r\n    function claimAllRewards() public nonReentrant {\r\n        uint256[] memory questIds = getUserQuests(msg.sender);\r\n        uint256 totalRewards = 0;\r\n        Quest storage quest;\r\n\r\n        for (uint256 i = 0; i < questIds.length; i++) {\r\n            totalRewards = totalRewards.add(calculateRewards(questIds[i]));\r\n            quest = quests[questIds[i]];\r\n            quest.lastClaim = block.timestamp;\r\n        }\r\n        UCD.mint(msg.sender, totalRewards);\r\n    }\r\n\r\n    /// @dev Claim HODLing Rewards for owned pure U_Us\r\n    /// @notice You can only claim HODL rewards for your owned pure U_Us\r\n    function claimHODLRewards(uint256[] memory tokenIds) public nonReentrant {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(\r\n                UU.ownerOf(tokenIds[i]) == msg.sender,\r\n                \"UniQuest: Not Owner of token\"\r\n            );\r\n        }\r\n\r\n        uint256 rewards = calculateHODLRewards(tokenIds);\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            HODLLastClaim[tokenIds[i]] = block.timestamp;\r\n        }\r\n\r\n        UCD.mint(msg.sender, rewards);\r\n    }\r\n\r\n    /// @dev Claim tokens and leave quest\r\n    /// @notice End quest for U_Us. You will stop acumulating UCD.\r\n    function endQuest(uint256 questId) public {\r\n        // Only Quest Owner\r\n        require(\r\n            msg.sender == quests[questId].questOwner,\r\n            \"UniQuest: Not the owner of quest\"\r\n        );\r\n        // Current Time > Quest End Time\r\n        require(\r\n            isQuestEndable(questId),\r\n            \"UniQuest: Unicorns are still questing!\"\r\n        );\r\n        // Must be questing state\r\n        require(\r\n            quests[questId].questState == QuestState.IN_PROGRESS,\r\n            \"UniQuest: Quest already Ended\"\r\n        );\r\n\r\n        // Distribute Remaining Rewards\r\n        claimRewards(questId);\r\n\r\n        // Unlock Tokens\r\n        _unlockTokens(quests[questId].unicornIds);\r\n\r\n        // Change Quest State such that further claims cannot be made\r\n        quests[questId].questState = QuestState.ENDED;\r\n\r\n        emit QuestEnded(msg.sender, questId, block.timestamp);\r\n    }\r\n\r\n    // ----------------------- View FUNCTIONS -----------------------\r\n\r\n    /// @dev Determines if quest is ended\r\n    function isQuestEndable(uint256 questId) public view returns (bool) {\r\n        return block.timestamp > quests[questId].questEnd;\r\n    }\r\n\r\n    /// @dev Retrieves clan multiplier\r\n    function getClanMultiplier(uint256 clanCount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return clanMultipliers[clanCount];\r\n    }\r\n\r\n    /// @dev Retrieves Rare multiplier\r\n    function getRareMultiplier(uint256 rareCount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rareMultipliers[rareCount];\r\n    }\r\n\r\n    /// @dev Retrieves Length multiplier\r\n    function getLengthMultiplier(uint256 questLevel)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return lengthMultipliers[questLevel];\r\n    }\r\n\r\n    /// @dev Calculates Clan Multiplier based on tokenIds\r\n    function calculateMultipliers(uint256[] memory _tokenIds)\r\n        internal\r\n        view\r\n        returns (uint256 _clanMultiplier, uint256 _rareMultiplier)\r\n    {\r\n        uint8[6] memory _clanCounter = [0, 0, 0, 0, 0, 0];\r\n        uint8 maxCount = 0;\r\n        uint8 maxIndex;\r\n        uint256 rareCount = 0;\r\n\r\n        // Count UU per clan\r\n        for (uint8 i = 0; i < _tokenIds.length; i++) {\r\n            _clanCounter[getClan(_tokenIds[i]) - 1] += 1;\r\n        }\r\n\r\n        // Find Maximum Count and Index of Max Count\r\n        for (uint8 i = 0; i < _clanCounter.length; i++) {\r\n            if (_clanCounter[i] > maxCount) {\r\n                maxCount = _clanCounter[i];\r\n                maxIndex = i;\r\n            }\r\n        }\r\n\r\n        // Wildcard bonus\r\n        if (maxIndex < 4) {\r\n            maxCount += _clanCounter[5];\r\n        }\r\n\r\n        _clanMultiplier = getClanMultiplier(maxCount);\r\n\r\n        rareCount = rareCount.add(_clanCounter[4]).add(_clanCounter[5]);\r\n        _rareMultiplier = getRareMultiplier(rareCount);\r\n    }\r\n\r\n    /// @dev Calulate HODLing rewards for tokenIds given\r\n    function calculateHODLRewards(uint256[] memory tokenIds)\r\n        public\r\n        view\r\n        returns (uint256 HODLRewards)\r\n    {\r\n        HODLRewards = 0;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            if (isGoldenUni[tokenIds[i]]) {\r\n                HODLRewards = HODLRewards.add(\r\n                    baseGoldenReward.mul(calcGoldenDuration(tokenIds[i])).div(\r\n                        timescale\r\n                    )\r\n                );\r\n            } else if (isRoboUni[tokenIds[i]]) {\r\n                HODLRewards = HODLRewards.add(\r\n                    baseRoboReward.mul(calcRoboDuration(tokenIds[i])).div(\r\n                        timescale\r\n                    )\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Calculate duration since last claim for golden U_Us\r\n    function calcGoldenDuration(uint256 tokenId)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return block.timestamp.sub(HODLLastClaim[tokenId]);\r\n    }\r\n\r\n    /// @dev Calculate duration since last claim for UniMech U_Us\r\n    function calcRoboDuration(uint256 tokenId) private view returns (uint256) {\r\n        return block.timestamp.sub(HODLLastClaim[tokenId]);\r\n    }\r\n\r\n    /// @dev Caluclate rewards for given Quest Id\r\n    function calculateRewards(uint256 questId)\r\n        public\r\n        view\r\n        returns (uint256 rewardAmount)\r\n    {\r\n        Quest memory quest = quests[questId];\r\n        rewardAmount = baseReward\r\n            .mul(block.timestamp.sub(quest.lastClaim))\r\n            .mul(quest.unicornIds.length)\r\n            .mul(quest.clanMultiplier)\r\n            .mul(quest.rareMultiplier)\r\n            .mul(quest.lengthMultiplier)\r\n            .div(timescale)\r\n            .div(1000000000000);\r\n    }\r\n\r\n    /// @dev Determines if the tokenIds are availiable for questing\r\n    function areAvailiable(uint256[] memory tokenIds)\r\n        public\r\n        view\r\n        returns (bool out)\r\n    {\r\n        out = true;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            if (onQuest[tokenIds[i]] > 0) {\r\n                out = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Determines if the all tokenIds are owned by msg sneder\r\n    function areOwned(uint256[] memory tokenIds)\r\n        public\r\n        view\r\n        returns (bool out)\r\n    {\r\n        out = true;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            if (UU.ownerOf(tokenIds[i]) != msg.sender) {\r\n                out = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUserQuests(address user)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return userQuests[user];\r\n    }\r\n\r\n    function getQuest(uint256 questId) public view returns (Quest memory) {\r\n        return quests[questId];\r\n    }\r\n\r\n    function isQuestOver(uint256 questId) public view returns (bool) {\r\n        Quest memory quest = quests[questId];\r\n        return block.timestamp > quest.questEnd;\r\n    }\r\n\r\n    function getClan(uint256 tokenId) public view returns (uint8) {\r\n        return uint8(clans[tokenId - 1]);\r\n    }\r\n\r\n    // ---------------------- ADMIN FUNCTIONS -----------------------\r\n\r\n    function setBaseReward(uint256 _amount) public onlyAdmin {\r\n        baseReward = _amount;\r\n    }\r\n\r\n    function setRoboReward(uint256 _amount) public onlyAdmin {\r\n        baseRoboReward = _amount;\r\n    }\r\n\r\n    function setGoldenReward(uint256 _amount) public onlyAdmin {\r\n        baseGoldenReward = _amount;\r\n    }\r\n\r\n    /// @dev Storing Clan Metadata as 1 byte hexes on a byte for gas optimization\r\n    function setRoboIds(uint256[] memory _roboTokenIds) public onlyAdmin {\r\n        for (uint256 i = 0; i < _roboTokenIds.length; i++) {\r\n            isRoboUni[_roboTokenIds[i]] = true;\r\n            HODLLastClaim[_roboTokenIds[i]] = block.timestamp;\r\n        }\r\n    }\r\n\r\n    /// @dev Storing Clan Metadata as 1 byte hexes on a byte for gas optimization\r\n    function setGoldenIds(uint256[] memory _goldenTokenIds) public onlyAdmin {\r\n        for (uint256 i = 0; i < _goldenTokenIds.length; i++) {\r\n            isGoldenUni[_goldenTokenIds[i]] = true;\r\n            HODLLastClaim[_goldenTokenIds[i]] = block.timestamp;\r\n        }\r\n    }\r\n\r\n    /// @dev Storing Clan Metadata as 1 byte hexes on a byte for gas optimization\r\n    function updateClans(bytes calldata _clans) public onlyAdmin {\r\n        clans = _clans;\r\n    }\r\n\r\n    function setUniCandy(address uniCandy) public onlyAdmin {\r\n        UCD = ICandyToken(uniCandy);\r\n    }\r\n\r\n    function setTimeScale(uint256 _newTimescale) public onlyAdmin {\r\n        timescale = _newTimescale;\r\n    }\r\n\r\n    function transferQuestOwnership(uint256 questId, address newOwner)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        Quest storage quest = quests[questId];\r\n        quest.questOwner = newOwner;\r\n    }\r\n\r\n    function setQuestLengths(uint256[] memory _newQuestLengths)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        questLengths = _newQuestLengths;\r\n    }\r\n\r\n    function _lockTokens(uint256[] memory tokenIds) private {\r\n        for (uint256 i; i < tokenIds.length; i++) {\r\n            UU.safeTransferFrom(msg.sender, address(this), tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function _unlockTokens(uint256[] memory tokenIds) private {\r\n        for (uint256 i; i < tokenIds.length; i++) {\r\n            UU.safeTransferFrom(address(this), msg.sender, tokenIds[i]);\r\n            // reset last claim for HODL rewards\r\n            HODLLastClaim[tokenIds[i]] = block.timestamp;\r\n        }\r\n    }\r\n}\r\n"},"contracts/interfaces/ICandyToken.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface ICandyToken is IERC20 {\r\n    function updateRewardOnMint(address _user, uint256 _amount) external;\r\n\r\n    function updateReward(address _from, address _to) external;\r\n\r\n    function getReward(address _to) external;\r\n\r\n    function burn(address _from, uint256 _amount) external;\r\n\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    function getTotalClaimable(address _user) external view returns (uint256);\r\n}\r\n"},"contracts/interfaces/IUninterestedUnicorns.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\ninterface IUninterestedUnicorns is IERC721 {\r\n    function mint(uint256 _quantity) external payable;\r\n\r\n    function getPrice(uint256 _quantity) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function lockTokens(uint8[] memory tokenId) external;\r\n\r\n    function unlockTokens(uint8[] memory tokenId) external;\r\n}\r\n"}}}