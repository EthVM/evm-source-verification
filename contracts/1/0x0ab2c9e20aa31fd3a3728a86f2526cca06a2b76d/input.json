{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "RussianRoulette.sol": {
      "content": "pragma solidity ^0.4.25;\r\n\r\n\r\n/** \r\nRussian Roulette: the fair game for ether on smart contract.\r\n\r\nYou and 4 other people place their bets. Placing\r\nthe bet you load a cartridge into the revolver cylinder -\r\ncurrently unknown whether it is blank or live.\r\n\r\nThe cylinder revolves, the revolver shoots players one\r\nby one and the unlucky one who gets live cartridge gets killed,\r\nothers win 120% of their bets.\r\n\r\nStill the unlucky one has a chance for a jackpot.\r\n\r\nThe game uses fair random number generator based on \r\nfuture block, so nobody, nor players nor developers can guess its results.\r\n\r\nJoin the game and win: https://multi.today\r\n*/\r\n\r\n\r\nlibrary Random {\r\n    struct Data {\r\n        uint blockNumber;\r\n        bytes32 hash;\r\n    }\r\n\r\n    function random(Data memory d, uint max) internal view returns (uint) {\r\n        if(d.hash == 0){\r\n            //Use simplified entropy\r\n            d.hash = keccak256(abi.encodePacked(now, block.difficulty, block.number, blockhash(block.number - 1)));\r\n        }else{\r\n            //Use entropy based on blockhash at which transaction has been confirmed\r\n            d.hash = keccak256(abi.encodePacked(d.hash));\r\n        }\r\n\r\n        return uint(d.hash)%max;\r\n    }\r\n\r\n    function init(Data memory d, uint blockNumber) internal view {\r\n        if(blockNumber != d.blockNumber){\r\n            //We have Random for different block. So we must reinit it\r\n            //If, in the unlikely case, the block is too far away, then the blockhash\r\n            //will return 0 and we will use simplified entropy.\r\n            //It is highly unlikely because nor players, nor administration are interested in it\r\n            d.hash = blockhash(blockNumber);\r\n            d.blockNumber = blockNumber;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Cylinder {\r\n    using Random for Random.Data;\r\n\r\n    uint constant CYLINDER_CAPACITY = 5;\r\n    uint constant MULTIPLIER_PERCENT = 120;\r\n    uint constant WITHDRAW_PERCENT = 99;\r\n    uint constant JACKPOT_PERCENT = 2;\r\n    uint constant SERVICE_PERCENT = 1;\r\n    uint constant PROMO_PERCENT = 1;\r\n\r\n    //Jackpot chances - once in a number of games\r\n    uint constant HALF_JACKPOT_CHANCE = 100;\r\n    uint constant FULL_JACKPOT_CHANCE = 1000;\r\n\r\n    address constant SERVICE = 0xDb058D036768Cfa9a94963f99161e3c94aD6f5dA;\r\n    address constant PROMO = 0xdA149b17C154e964456553C749B7B4998c152c9E;\r\n\r\n    //The deposit structure holds all the info about the deposit made\r\n    struct Deposit {\r\n        address depositor; //The depositor address\r\n        uint64 timeAt; //When the deposit was made\r\n    }\r\n\r\n    //The result of the game. Always stored at height%CYLINDER_CAPACITY index\r\n    struct GameResult{\r\n        uint48 timeAt;  //Time of finalization\r\n        uint48 blockAt;  //Block number of finalization\r\n        uint48 height;  //Height of the cylinder slots\r\n        uint8 unlucky;  //index of the unlucky one in slots relative to height\r\n        uint96 jackpot; //The jackpot won (if not 0)\r\n        bool full;      //Full jackpot won\r\n    }\r\n\r\n    struct Data{\r\n        uint dep;\r\n        Deposit[] slots;\r\n        GameResult[] results;\r\n        uint currentCylinderHeight;\r\n        uint jackpot;\r\n    }\r\n\r\n    function checkPercentConsistency() pure internal {\r\n        //All the percent should be consistent with each other\r\n        assert(100 * CYLINDER_CAPACITY == MULTIPLIER_PERCENT * (CYLINDER_CAPACITY-1) + (JACKPOT_PERCENT + SERVICE_PERCENT + PROMO_PERCENT)*CYLINDER_CAPACITY);\r\n        assert(WITHDRAW_PERCENT <= 100);\r\n    }\r\n\r\n    function addDep(Cylinder.Data storage c, address depositor) internal returns (bool){\r\n        c.slots.push(Deposit(depositor, uint64(now)));\r\n        if(c.slots.length % CYLINDER_CAPACITY == 0) {\r\n            //Indicate that we need to put the game to the list of ready to finish games\r\n            c.currentCylinderHeight += CYLINDER_CAPACITY;\r\n            return true; //The game should be finished\r\n        }else{\r\n            return false; //The game continues\r\n        }\r\n    }\r\n\r\n    function finish(Cylinder.Data storage c, uint height, Random.Data memory r) internal {\r\n        GameResult memory gr = computeGameResult(c, height, r);\r\n\r\n        uint dep = c.dep;\r\n        uint unlucky = gr.unlucky; //The loser index\r\n        uint reward = dep*MULTIPLIER_PERCENT/100;\r\n        uint length = height + CYLINDER_CAPACITY;\r\n\r\n        uint total = dep*CYLINDER_CAPACITY;\r\n        uint jackAmount = c.jackpot;\r\n        uint jackWon = gr.jackpot;\r\n\r\n        for(uint i=height; i<length; ++i){\r\n            if(i-height != unlucky){ //Winners\r\n                Deposit storage d = c.slots[i];\r\n                if(!d.depositor.send(reward)) //If we can not send the money (it may be malicious contract)\r\n                    jackAmount += reward;     //add it to jackpot\r\n            }\r\n        }\r\n\r\n        if(jackWon > 0){\r\n            //Jackpot won!!! Send it to (un)lucky one\r\n            Deposit storage win = c.slots[height + unlucky];\r\n            if(win.depositor.send(jackWon))\r\n                jackAmount -= jackWon; //jackWon is always <= jackAmount\r\n        }\r\n\r\n        c.jackpot = jackAmount + total*JACKPOT_PERCENT/100;\r\n\r\n        c.results.push(gr);\r\n\r\n        SERVICE.transfer(total*(SERVICE_PERCENT)/100);\r\n        PROMO.transfer(total*PROMO_PERCENT/100);\r\n    }\r\n\r\n    function computeGameResult(Cylinder.Data storage c, uint height, Random.Data memory r) internal view returns (GameResult memory) {\r\n        assert(height + CYLINDER_CAPACITY <= c.currentCylinderHeight);\r\n\r\n        uint unlucky = r.random(CYLINDER_CAPACITY); //The loser index\r\n        uint jackAmount = c.jackpot;\r\n        uint jackWon = 0;\r\n        bool fullJack = false;\r\n\r\n        uint jpchance = r.random(FULL_JACKPOT_CHANCE);\r\n        if(jpchance % HALF_JACKPOT_CHANCE == 0){\r\n            //Jackpot won!!!\r\n            if(jpchance == 0){\r\n                //Once in FULL_JACKPOT_CHANCE the unlucky one gets full jackpot\r\n                fullJack = true;\r\n                jackWon = jackAmount;\r\n            }else{\r\n                //Once in HALF_JACKPOT_CHANCE the unlucky one gets half of jackpot\r\n                jackWon = jackAmount/2;\r\n            }\r\n            //jackWon is always not more than c.jackpot\r\n        }\r\n\r\n        return GameResult(uint48(now), uint48(block.number), uint48(height), uint8(unlucky), uint96(jackWon), fullJack);\r\n    }\r\n\r\n    function withdraw(Cylinder.Data storage c, address addr) internal returns (bool){\r\n        uint length = c.slots.length;\r\n        uint dep = c.dep;\r\n        for(uint i=c.currentCylinderHeight; i<length; ++i){\r\n            Deposit storage deposit = c.slots[i];\r\n            if(deposit.depositor == addr){ //Return dep\r\n                uint ret = dep*WITHDRAW_PERCENT/100;\r\n                deposit.depositor.transfer(msg.value + ret);\r\n                SERVICE.transfer(dep - ret);\r\n\r\n                --length; //We need only length-1 further on\r\n                if(i < length){\r\n                    c.slots[i] = c.slots[length];\r\n                }\r\n\r\n                c.slots.length = length;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCylinder(Cylinder.Data storage c, uint idx) internal view returns (uint96 dep, uint64 index, address[] deps, uint8 unlucky, int96 jackpot, uint64 lastDepTime){\r\n        dep = uint96(c.dep);\r\n        index = uint64(idx);\r\n        require(idx <= c.slots.length/CYLINDER_CAPACITY, \"Wrong cylinder index\");\r\n\r\n        if(uint(index) >= c.results.length){\r\n            uint size = c.slots.length - index*CYLINDER_CAPACITY;\r\n            if(size > CYLINDER_CAPACITY)\r\n                size = CYLINDER_CAPACITY;\r\n\r\n            deps = new address[](size);\r\n        }else{\r\n            deps = new address[](CYLINDER_CAPACITY);\r\n\r\n            Cylinder.GameResult storage gr = c.results[index];\r\n            unlucky = gr.unlucky;\r\n            jackpot = gr.full ? -int96(gr.jackpot) : int96(gr.jackpot);\r\n            lastDepTime = gr.timeAt;\r\n        }\r\n\r\n        for(uint i=0; i<deps.length; ++i){\r\n            Deposit storage d = c.slots[index*CYLINDER_CAPACITY + i];\r\n            deps[i] = d.depositor;\r\n            if(lastDepTime < uint(d.timeAt))\r\n                lastDepTime = d.timeAt;\r\n        }\r\n    }\r\n\r\n    function getCapacity() internal pure returns (uint) {\r\n        return CYLINDER_CAPACITY;\r\n    }\r\n}\r\n\r\n\r\ncontract RussianRoulette {\r\n    using Cylinder for Cylinder.Data;\r\n    using Random for Random.Data;\r\n\r\n    uint[14] public BETS = [\r\n        0.01 ether,\r\n        0.05 ether,\r\n        0.1  ether,\r\n        0.2  ether,\r\n        0.3  ether,\r\n        0.5  ether,\r\n        0.7  ether,\r\n        1    ether,\r\n        1.5  ether,\r\n        2    ether,\r\n        3    ether,\r\n        5    ether,\r\n        7    ether,\r\n        10   ether\r\n    ];\r\n\r\n    struct GameToFinish{\r\n        uint8 game;\r\n        uint64 blockNumber;\r\n        uint64 height;\r\n    }\r\n\r\n    Cylinder.Data[] private games;\r\n    GameToFinish[] private gtf; //Games that are waiting to be finished\r\n    uint private gtfStart = 0; //Starting index of games to finish queue\r\n\r\n    constructor() public {\r\n        Cylinder.checkPercentConsistency();\r\n        //Initialize games for different bets\r\n        games.length = BETS.length;\r\n    }\r\n\r\n    function() public payable {\r\n        //first choose the game on the basis of the bets table\r\n        for(int i=int(BETS.length)-1; i>=0; i--){\r\n            uint bet = BETS[uint(i)];\r\n            if(msg.value >= bet){\r\n                //Finish the games if there are any waiting\r\n                finishGames();\r\n\r\n                if(msg.value > bet) //return change\r\n                    msg.sender.transfer(msg.value - bet);\r\n\r\n                Cylinder.Data storage game = games[uint(i)];\r\n                if(game.dep == 0){ //Initialize game data on first deposit\r\n                    game.dep = bet;\r\n                }\r\n\r\n                uint height = game.currentCylinderHeight;\r\n                if(game.addDep(msg.sender)){\r\n                    //The game is ready to be finished\r\n                    //Put it to finish queue\r\n                    gtf.push(GameToFinish(uint8(i), uint64(block.number), uint64(height)));\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        if(msg.value == 0.00000112 ether){\r\n            withdraw();\r\n            return;\r\n        }\r\n\r\n        if(msg.value == 0){\r\n            finishGames();\r\n            return;\r\n        }\r\n\r\n        revert(\"Deposit is too small\");\r\n    }\r\n\r\n    function withdrawFrom(uint game) public {\r\n        require(game < BETS.length);\r\n        require(games[game].withdraw(msg.sender), \"You are not betting in this game\");\r\n\r\n        //Finish the games if there are any waiting\r\n        finishGames();\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint length = BETS.length;\r\n        for(uint i=0; i<length; ++i){\r\n            if(games[i].withdraw(msg.sender)){\r\n                //Finish the games if there are any waiting\r\n                finishGames();\r\n                return;\r\n            }\r\n        }\r\n\r\n        revert(\"You are not betting in any game\");\r\n    }\r\n\r\n    function finishGames() private {\r\n        Random.Data memory r;\r\n        uint length = gtf.length;\r\n        for(uint i=gtfStart; i<length; ++i){\r\n            GameToFinish memory g = gtf[i];\r\n            uint bn = g.blockNumber;\r\n            if(bn == block.number)\r\n                break; //We can not finish the game in the same block\r\n\r\n            r.init(bn);\r\n\r\n            Cylinder.Data storage c = games[g.game];\r\n            c.finish(g.height, r);\r\n\r\n            delete gtf[i];\r\n        }\r\n\r\n        if(i > gtfStart)\r\n            gtfStart = i;\r\n    }\r\n\r\n    function getGameState(uint game) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 slotsCount, uint64 resultsCount, uint64 currentCylinderIndex, uint96 jackpot){\r\n        Cylinder.Data storage c = games[game];\r\n        dep = uint96(c.dep);\r\n        slotsCount = uint64(c.slots.length);\r\n        resultsCount = uint64(c.results.length);\r\n        currentCylinderIndex = uint64(c.currentCylinderHeight/Cylinder.getCapacity());\r\n        jackpot = uint96(c.jackpot);\r\n        blockNumber = uint64(block.number-1);\r\n        blockHash = blockhash(block.number-1);\r\n    }\r\n\r\n    function getGameStates() public view returns (uint64 blockNumber, bytes32 blockHash, uint96[] dep, uint64[] slotsCount, uint64[] resultsCount, uint64[] currentCylinderIndex, uint96[] jackpot){\r\n        dep = new uint96[](BETS.length);\r\n        slotsCount = new uint64[](BETS.length);\r\n        resultsCount = new uint64[](BETS.length);\r\n        currentCylinderIndex = new uint64[](BETS.length);\r\n        jackpot = new uint96[](BETS.length);\r\n\r\n        for(uint i=0; i<BETS.length; ++i){\r\n            (blockNumber, blockHash, dep[i], slotsCount[i], resultsCount[i], currentCylinderIndex[i], jackpot[i]) = getGameState(i);\r\n        }\r\n    }\r\n\r\n    function getCylinder(uint game, int _idx) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 index, address[] deps, uint8 unlucky, int96 jackpot, uint64 lastDepTime, uint8 status){\r\n        Cylinder.Data storage c = games[game];\r\n        index = uint64(_idx < 0 ? c.slots.length/Cylinder.getCapacity() : uint(_idx));\r\n\r\n        (dep, index, deps, unlucky, jackpot, lastDepTime) = c.getCylinder(index);\r\n        blockNumber = uint64(block.number-1);\r\n        blockHash = blockhash(block.number-1);\r\n        //status = 0; //The game is running\r\n\r\n        uint8 _unlucky;\r\n        int96 _jackpot;\r\n\r\n        //We will try to get preliminary results of the ready to be finished game\r\n        (_unlucky, _jackpot, status) = _getGameResults(game, index);\r\n        if(status == 2){\r\n            unlucky = _unlucky;\r\n            jackpot = _jackpot;\r\n        }\r\n    }\r\n\r\n    function _getGameResults(uint game, uint index) private view returns (uint8 unlucky, int96 jackpot, uint8 status){\r\n        Cylinder.Data storage c = games[game];\r\n        if(index < c.results.length){\r\n            status = 3; //Finished and has finalized results\r\n        }else if(c.slots.length >= (index+1)*Cylinder.getCapacity()){\r\n            status = 1; //Closed, but no results yet\r\n            //This game needs finishing, so try to find out who wins\r\n            Random.Data memory r;\r\n            uint length = gtf.length;\r\n            for(uint i=gtfStart; i<length; ++i){\r\n                GameToFinish memory g = gtf[i];\r\n                uint bn = g.blockNumber;\r\n                if(blockhash(bn) == 0)\r\n                    break; //We either on the same block or too far from this block\r\n\r\n                r.init(bn);\r\n\r\n                Cylinder.GameResult memory gr = games[g.game].computeGameResult(g.height, r);\r\n\r\n                if(uint(g.height) == index*Cylinder.getCapacity() && uint(g.game) == game){\r\n                    //We have found our game so just fill the results\r\n                    unlucky = gr.unlucky;\r\n                    jackpot = gr.full ? -int96(gr.jackpot) : int96(gr.jackpot); //The jackpot amount may be inaccurate\r\n                    status = 2; //Closed and has preliminary results\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCylinders(uint game, uint idxFrom, uint idxTo) public view returns (uint blockNumber, bytes32 blockHash, uint96 dep, uint64[] index, address[] deps, uint8[] unlucky, int96[] jackpot, uint64[] lastDepTime, uint8[] status){\r\n        Cylinder.Data storage c = games[game];\r\n        uint lastCylinderIndex = c.slots.length/Cylinder.getCapacity();\r\n        blockNumber = block.number-1;\r\n        blockHash = blockhash(block.number-1);\r\n        dep = uint96(c.dep);\r\n\r\n        require(idxFrom <= lastCylinderIndex && idxFrom <= idxTo, \"Wrong cylinder index range\");\r\n\r\n        if(idxTo > lastCylinderIndex)\r\n            idxTo = lastCylinderIndex;\r\n\r\n        uint count = idxTo - idxFrom + 1;\r\n\r\n        index = new uint64[](count);\r\n        deps = new address[](count*Cylinder.getCapacity());\r\n        unlucky = new uint8[](count);\r\n        jackpot = new int96[](count);\r\n        lastDepTime = new uint64[](count);\r\n        status = new uint8[](count);\r\n\r\n        _putCylindersToArrays(game, idxFrom, count, index, deps, unlucky, jackpot, lastDepTime, status);\r\n    }\r\n\r\n    function _putCylindersToArrays(uint game, uint idxFrom, uint count, uint64[] index, address[] deps, uint8[] unlucky, int96[] jackpot, uint64[] lastDepTime, uint8[] status) private view {\r\n        for(uint i=0; i<count; ++i){\r\n            address[] memory _deps;\r\n            (, , , index[i], _deps, unlucky[i], jackpot[i], lastDepTime[i], status[i]) = getCylinder(game, int(idxFrom + i));\r\n            _copyDeps(i*Cylinder.getCapacity(), deps, _deps);\r\n        }\r\n    }\r\n\r\n    function _copyDeps(uint start, address[] deps, address[] memory _deps) private pure {\r\n        for(uint j=0; j<_deps.length; ++j){\r\n            deps[start + j] = _deps[j];\r\n        }\r\n    }\r\n\r\n    function getUnfinishedCount() public view returns (uint) {\r\n        return gtf.length - gtfStart;\r\n    }\r\n\r\n    function getUnfinished(uint i) public view returns (uint game, uint blockNumber, uint cylinder) {\r\n        game = gtf[gtfStart + i].game;\r\n        blockNumber = gtf[gtfStart + i].blockNumber;\r\n        cylinder = gtf[gtfStart + i].height/Cylinder.getCapacity();\r\n    }\r\n\r\n    function getTotalCylindersCount() public view returns (uint) {\r\n        return gtf.length;\r\n    }\r\n\r\n    function testRandom() public view returns (uint[] numbers) {\r\n        numbers = new uint[](32);\r\n        Random.Data memory r;\r\n        for(uint i=0; i<256; i+=8){\r\n            numbers[i/8] = Random.random(r, 10);\r\n        }\r\n    }\r\n}"
    }
  }
}