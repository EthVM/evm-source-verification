{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ccTokenDeSwapFactory.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n// pragma experimental SMTChecker;\r\n\r\n/// @title ERC20If\r\nabstract contract ERC20If {\r\n    function totalSupply() virtual public view returns (uint256);\r\n\r\n    function balanceOf(address _who) virtual public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function allowance(address _owner, address _spender) virtual public view returns (uint256);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) virtual public returns (bool);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\nabstract contract OwnableIf {\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner(), \"not owner......\");\r\n        _;\r\n    }\r\n\r\n    function _owner() view virtual public returns (address);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is OwnableIf {\r\n    address public owner;\r\n\r\n    function _owner() view override public returns (address){\r\n        return owner;\r\n    }\r\n\r\n    //    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    //    /**\r\n    //     * @dev Throws if called by any account other than the owner.\r\n    //     */\r\n    //    modifier onlyOwner() {\r\n    //        require(msg.sender == owner);\r\n    //        _;\r\n    //    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    //   function renounceOwnership() public onlyOwner {\r\n    //     emit OwnershipRenounced(owner);\r\n    //     owner = address(0);\r\n    //   }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) virtual public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0), \"invalid _newOwner\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Claimable.sol\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n    address public pendingOwner;\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"no permission\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) override public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title CanReclaimToken\r\nabstract contract CanReclaimToken is OwnableIf {\r\n\r\n    function reclaimToken(ERC20If _token) external onlyOwner {\r\n        uint256 balance = _token.balanceOf((address)(this));\r\n        require(_token.transfer(_owner(), balance));\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n// \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ncontract ccTokenWrap is Ownable, CanReclaimToken {\r\n    using SafeMath for uint256;\r\n    ERC20If public cctoken;\r\n    string public nativeCoinType;\r\n    address public cctokenRepository;\r\n    uint256 public wrapSeq;\r\n    mapping(bytes32 => uint256) public wrapSeqMap;\r\n\r\n    // bool public checkSignature = true;\r\n\r\n    uint256 constant rate_precision = 1e10;\r\n\r\n    // function _checkSignature(bool _b) public onlyOwner {\r\n    //     checkSignature = _b;\r\n    // }\r\n\r\n    function _cctokenRepositorySet(address newRepository)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newRepository != (address)(0), \"invalid addr\");\r\n        cctokenRepository = newRepository;\r\n    }\r\n\r\n    function wrapHash(string memory nativeCoinAddress, string memory nativeTxId)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(nativeCoinAddress, nativeTxId));\r\n    }\r\n\r\n    event SETUP(\r\n        address _cctoken,\r\n        string _nativeCoinType,\r\n        address _cctokenRepository\r\n    );\r\n\r\n    function setup(\r\n        address _cctoken,\r\n        string memory _nativeCoinType,\r\n        address _cctokenRepository,\r\n        address _initOwner\r\n    )\r\n        public\r\n        returns (\r\n            bool\r\n        )\r\n    {\r\n        if (wrapSeq <= 0) {\r\n            wrapSeq = 1;\r\n            cctoken = (ERC20If)(_cctoken);\r\n            nativeCoinType = _nativeCoinType;\r\n            cctokenRepository = _cctokenRepository;\r\n            owner = _initOwner;\r\n            emit SETUP(_cctoken, _nativeCoinType, _cctokenRepository);\r\n            emit OwnershipTransferred(_owner(), _initOwner);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function uintToString(uint256 _i) public pure returns (string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function toHexString(bytes memory data)\r\n        public\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\r\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function toHexString(address account) public pure returns (string memory) {\r\n        return toHexString(abi.encodePacked(account));\r\n    }\r\n\r\n    function calcCCTokenAmount(\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate\r\n    ) public pure returns (uint256) {\r\n        return amt.sub(fee).mul(rate).div(rate_precision);\r\n    }\r\n\r\n    function encode(\r\n        address receiveCCTokenAddress,\r\n        string memory nativeCoinAddress,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        uint64 deadline\r\n    ) public view returns (bytes memory) {\r\n        uint id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return\r\n            abi.encodePacked(\r\n                \"wrap \",\r\n                nativeCoinType,\r\n                \"\\nto:\",\r\n                toHexString(receiveCCTokenAddress),\r\n                \"\\namt:\",\r\n                uintToString(amt),\r\n                \"\\nfee:\",\r\n                uintToString(fee),\r\n                \"\\nrate:\",\r\n                uintToString(rate),\r\n                \"\\ndeadline:\",\r\n                uintToString(deadline),\r\n                \"\\naddr:\",\r\n                nativeCoinAddress,\r\n                \"\\nchainid:\",\r\n                uintToString(id)\r\n            );\r\n    }\r\n\r\n    function personalMessage(bytes memory _msg)\r\n        public\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n\",\r\n                uintToString(_msg.length),\r\n                _msg\r\n            );\r\n    }\r\n\r\n    function recoverPersonalSignature(\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bytes memory text\r\n    ) public pure returns (address) {\r\n        bytes32 h = keccak256(personalMessage(text));\r\n        return ecrecover(h, v, r, s);\r\n    }\r\n\r\n    function wrap(\r\n        address ethAccount,\r\n        address receiveCCTokenAddress,\r\n        string memory nativeCoinAddress,\r\n        string memory nativeTxId,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        uint64 deadline,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    ) public onlyOwner returns (bool) {\r\n        uint256 cctokenAmount = calcCCTokenAmount(amt, fee, rate);\r\n        // if (checkSignature) \r\n        {\r\n            bytes memory text =\r\n                encode(\r\n                    receiveCCTokenAddress,\r\n                    nativeCoinAddress,\r\n                    amt,\r\n                    fee,\r\n                    rate,\r\n                    deadline\r\n                );\r\n\r\n            address addr = recoverPersonalSignature(r, s, v, text);\r\n            require(addr != address(0), \"0 address\");\r\n            require(addr == ethAccount, \"invalid signature\");\r\n        }\r\n        require(\r\n            wrapSeqMap[wrapHash(nativeCoinAddress, nativeTxId)] <= 0,\r\n            \"wrap dup.\"\r\n        );\r\n        wrapSeqMap[wrapHash(nativeCoinAddress, nativeTxId)] = wrapSeq;\r\n        wrapSeq = wrapSeq + 1;\r\n\r\n        require(\r\n            cctoken.transferFrom(\r\n                cctokenRepository,\r\n                receiveCCTokenAddress,\r\n                cctokenAmount\r\n            ),\r\n            \"transferFrom failed\"\r\n        );\r\n        emit WRAP_EVENT(\r\n            wrapSeq,\r\n            ethAccount,\r\n            receiveCCTokenAddress,\r\n            nativeCoinAddress,\r\n            nativeTxId,\r\n            amt,fee,rate,\r\n            deadline,\r\n            r,\r\n            s,\r\n            v\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    event WRAP_EVENT(\r\n        uint256 indexed wrapSeq,\r\n        address ethAccount,\r\n        address receiveCCTokenAddress,\r\n        string nativeCoinAddress,\r\n        string nativeTxId,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        uint64 deadline,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v\r\n    );\r\n}\r\n\r\n\r\ncontract ccTokenDeSwap is ccTokenWrap {\r\n    using SafeMath for uint256;\r\n\r\n    //PENDING=》CANCELED\r\n    //PENDING=》APPROVED\r\n    //APPROVED=》FINISHED\r\n    enum OrderStatus {PENDING, CANCELED, APPROVED, FINISHED}\r\n\r\n    function getStatusString(OrderStatus status)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (status == OrderStatus.PENDING) {\r\n            return \"pending\";\r\n        } else if (status == OrderStatus.CANCELED) {\r\n            return \"canceled\";\r\n        } else if (status == OrderStatus.APPROVED) {\r\n            return \"approved\";\r\n        } else if (status == OrderStatus.FINISHED) {\r\n            return \"finished\";\r\n        } else {\r\n            // unreachable.\r\n            return \"unknown\";\r\n        }\r\n    }\r\n\r\n    struct UnWrapOrder {\r\n        address ethAccount;\r\n        uint256 nativeCoinAmount;\r\n        uint256 cctokenAmount;\r\n        string nativeCoinAddress;\r\n        string nativeTxId;\r\n        uint256 requestBlockNo;\r\n        uint256 confirmedBlockNo;\r\n        OrderStatus status;\r\n        uint256 fee;\r\n        uint256 rate;\r\n    }\r\n\r\n    UnWrapOrder[] public unWrapOrders;\r\n    bool public paused = false;\r\n    modifier notPaused() {\r\n        require(!paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    function pause(bool _paused) public onlyOwner returns (bool) {\r\n        paused = _paused;\r\n        return true;\r\n    }\r\n\r\n    function getUnWrapOrderNum() public view returns (uint256) {\r\n        return unWrapOrders.length;\r\n    }\r\n\r\n    function getUnWrapOrderInfo(uint256 seq)\r\n        public\r\n        view\r\n        returns (\r\n            address ethAccount,\r\n            uint256 nativeCoinAmount,\r\n            uint256 cctokenAmount,\r\n            string memory nativeCoinAddress,\r\n            string memory nativeTxId,\r\n            uint256 requestBlockNo,\r\n            uint256 confirmedBlockNo,\r\n            string memory status\r\n        )\r\n    {\r\n        require(seq < unWrapOrders.length, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        ethAccount = order.ethAccount;\r\n        nativeCoinAmount = order.nativeCoinAmount;\r\n        cctokenAmount = order.cctokenAmount;\r\n        nativeCoinAddress = order.nativeCoinAddress;\r\n        nativeTxId = order.nativeTxId;\r\n        requestBlockNo = order.requestBlockNo;\r\n        confirmedBlockNo = order.confirmedBlockNo;\r\n        status = getStatusString(order.status);\r\n    }\r\n\r\n    function calcUnWrapAmount(\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate\r\n    ) public pure returns (uint256) {\r\n        return amt.sub(fee).mul(rate).div(rate_precision);\r\n    }\r\n\r\n    function unWrap(\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate,\r\n        string memory nativeCoinAddress\r\n    ) public notPaused returns (bool) {\r\n        address ethAccount = msg.sender;\r\n        uint256 cctokenAmount = amt;\r\n        uint256 nativeCoinAmount = calcUnWrapAmount(amt, fee, rate);\r\n        require(\r\n            cctoken.transferFrom(ethAccount, cctokenRepository, cctokenAmount),\r\n            \"transferFrom failed\"\r\n        );\r\n        uint256 seq = unWrapOrders.length;\r\n        unWrapOrders.push(\r\n            UnWrapOrder({\r\n                ethAccount: ethAccount,\r\n                nativeCoinAmount: nativeCoinAmount,\r\n                cctokenAmount: cctokenAmount,\r\n                nativeCoinAddress: nativeCoinAddress,\r\n                requestBlockNo: block.number,\r\n                status: OrderStatus.PENDING,\r\n                nativeTxId: \"\",\r\n                confirmedBlockNo: 0,\r\n                fee: fee,\r\n                rate: rate\r\n            })\r\n        );\r\n        emit UNWRAP_REQUEST(seq, ethAccount, nativeCoinAddress, amt, fee, rate);\r\n\r\n        return true;\r\n    }\r\n\r\n    event UNWRAP_REQUEST(\r\n        uint256 indexed seq,\r\n        address ethAccount,\r\n        string nativeCoinAddress,\r\n        uint256 amt,\r\n        uint256 fee,\r\n        uint256 rate\r\n    );\r\n\r\n    event UNWRAP_APPROVE(uint256 indexed seq);\r\n\r\n    function approveUnWrapOrder(\r\n        uint256 seq,\r\n        address ethAccount,\r\n        uint256 nativeCoinAmount,\r\n        uint256 cctokenAmount,\r\n        string memory nativeCoinAddress\r\n    ) public onlyOwner returns (bool) {\r\n        require(unWrapOrders.length > seq, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        require(order.status == OrderStatus.PENDING, \"status not pending\");\r\n        require(ethAccount == order.ethAccount, \"invalid param1\");\r\n        require(cctokenAmount == order.cctokenAmount, \"invalid param2\");\r\n        require(nativeCoinAmount == order.nativeCoinAmount, \"invalid param3\");\r\n        require(\r\n            stringEquals(nativeCoinAddress, order.nativeCoinAddress),\r\n            \"invalid param4\"\r\n        );\r\n\r\n        unWrapOrders[seq].status = OrderStatus.APPROVED;\r\n        emit UNWRAP_APPROVE(seq);\r\n        return true;\r\n    }\r\n\r\n    event UNWRAP_CANCEL(uint256 indexed seq);\r\n\r\n    function cancelUnWrapOrder(uint256 seq) public returns (bool) {\r\n        require(unWrapOrders.length > seq, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        require(msg.sender == order.ethAccount, \"invalid auth.\");\r\n        require(order.status == OrderStatus.PENDING, \"status not pending\");\r\n        unWrapOrders[seq].status = OrderStatus.CANCELED;\r\n\r\n        require(\r\n            cctoken.transferFrom(\r\n                cctokenRepository,\r\n                order.ethAccount,\r\n                order.cctokenAmount\r\n            ),\r\n            \"transferFrom failed\"\r\n        );\r\n\r\n        emit UNWRAP_CANCEL(seq);\r\n        return true;\r\n    }\r\n\r\n    function stringEquals(string memory s1, string memory s2)\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (keccak256(abi.encodePacked(s1)) ==\r\n            keccak256(abi.encodePacked(s2)));\r\n    }\r\n\r\n    event UNWRAP_FINISH(uint256 indexed seq, string nativeTxId);\r\n\r\n    function finishUnWrapOrder(uint256 seq, string memory nativeTxId)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(unWrapOrders.length > seq, \"invalid seq\");\r\n        UnWrapOrder memory order = unWrapOrders[seq];\r\n        require(order.status == OrderStatus.APPROVED, \"status not approved\");\r\n\r\n        unWrapOrders[seq].status = OrderStatus.FINISHED;\r\n        unWrapOrders[seq].nativeTxId = nativeTxId;\r\n        unWrapOrders[seq].confirmedBlockNo = block.number;\r\n        emit UNWRAP_FINISH(seq, nativeTxId);\r\n        return true;\r\n    }\r\n\r\n    address public pendingOwner;\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner, \"no permission\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) override public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal virtual {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     *\r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal virtual {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback () external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive () external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     *\r\n     * If overriden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\r\n * implementation address that can be changed. This address is stored in storage in the location specified by\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\r\n * implementation behind the proxy.\r\n *\r\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\r\n * {TransparentUpgradeableProxy}.\r\n */\r\ncontract UpgradeableProxy is Proxy {\r\n    /**\r\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\r\n     *\r\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\r\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\r\n     */\r\n    constructor(address _logic, bytes memory _data) payable {\r\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if(_data.length > 0) {\r\n            Address.functionDelegateCall(_logic, _data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _implementation() internal view virtual override returns (address impl) {\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the proxy to a new implementation.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal virtual {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\r\n\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n *\r\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\r\n * clashing], which can potentially be used in an attack, this contract uses the\r\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\r\n * things that go hand in hand:\r\n *\r\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\r\n * that call matches one of the admin functions exposed by the proxy itself.\r\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\r\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\r\n * \"admin cannot fallback to proxy target\".\r\n *\r\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\r\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\r\n * to sudden errors when trying to call a function from the proxy implementation.\r\n *\r\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\r\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\r\n */\r\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\r\n    /**\r\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\r\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\r\n     */\r\n    constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, \"\") {\r\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(admin_);\r\n\r\n         if(_data.length > 0) {\r\n            Address.functionDelegateCall(_logic, _data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n     */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n     */\r\n    function admin() external ifAdmin returns (address admin_) {\r\n        admin_ = _admin();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n     */\r\n    function implementation() external ifAdmin returns (address implementation_) {\r\n        implementation_ = _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\r\n     */\r\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\r\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\r\n        emit AdminChanged(_admin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\r\n     */\r\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n     * proxied contract.\r\n     *\r\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n        Address.functionDelegateCall(newImplementation, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _admin() internal view virtual returns (address adm) {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\r\n     */\r\n    function _beforeFallback() internal virtual override {\r\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\r\n        super._beforeFallback();\r\n    }\r\n}\r\n\r\n\r\ncontract ccTokenDeSwapFactory is Claimable, CanReclaimToken {\r\n    mapping(bytes32 => address) public deSwaps;\r\n\r\n    function getDeSwap(string memory _nativeCoinType)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        bytes32 nativeCoinTypeHash =\r\n            keccak256(abi.encodePacked(_nativeCoinType));\r\n        return deSwaps[nativeCoinTypeHash];\r\n    }\r\n\r\n    function deployDeSwap(\r\n        address _cctoken,\r\n        string memory _nativeCoinType,\r\n        address _cctokenRepository,\r\n        address _operator\r\n    ) public onlyOwner returns (bool) {\r\n        bytes32 nativeCoinTypeHash =\r\n            keccak256(abi.encodePacked(_nativeCoinType));\r\n        require(_operator!=_owner(), \"owner same as _operator\");\r\n        require(deSwaps[nativeCoinTypeHash] == (address)(0), \"deEx exists.\");\r\n        ccTokenDeSwap cctokenDeSwap = new ccTokenDeSwap();\r\n        TransparentUpgradeableProxy proxy =\r\n            new TransparentUpgradeableProxy(\r\n                (address)(cctokenDeSwap),\r\n                (address)(this),\r\n                abi.encodeWithSignature(\r\n                    \"setup(address,string,address,address)\",\r\n                        _cctoken,\r\n                    _nativeCoinType,\r\n                        _cctokenRepository,\r\n                    _operator\r\n                )\r\n            );\r\n\r\n        proxy.changeAdmin(_owner());\r\n        deSwaps[nativeCoinTypeHash] = (address)(proxy);\r\n\r\n        return true;\r\n    }\r\n}"}}}