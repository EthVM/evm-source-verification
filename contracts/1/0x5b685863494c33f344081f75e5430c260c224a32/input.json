{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/CMCX.sol":{"content":"pragma solidity 0.8.1; /*\n\n======================= Quick Stats ===================\n    => Name        : CORE MultiChain Token\n    => Symbol      : CMCX\n    => Total supply: 20,000,000,000 (20 Billion)\n    => Decimals    : 18\n============= Independant Audit of the code ============\n    => Community Audit by Bug Bounty program\n----------------------------------------------------------------------------\n SPDX-License-Identifier: MIT\n Copyright (c) 2021 CORE. ( https://www.coremultichain.com/ )\n-----------------------------------------------------------------------------\n*/ \n\n//*******************************************************************//\n//------------------------ SafeMath Library -------------------------//\n//*******************************************************************//\n/**\n    * @title SafeMath\n    * @dev Math operations with safety checks that throw on error\n    */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n        return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath mul failed');\n    return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, 'SafeMath sub failed');\n    return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath add failed');\n    return c;\n    }\n}\n\n\n//*******************************************************************//\n//------------------ Contract to Manage Ownership -------------------//\n//*******************************************************************//\n    \ncontract owned {\n    address payable public owner;\n    address payable internal newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() {\n        owner = payable(msg.sender);\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address payable _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\n    function acceptOwnership() external {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = payable(address(0));\n    }\n}\n\n\ninterface IERC1363Spender {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n     * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n     */\n\n    /**\n     * @notice Handle the approval of ERC1363 tokens\n     * @dev Any ERC1363 smart contract calls this function on the recipient\n     * after an `approve`. This function MAY throw to revert and reject the\n     * approval. Return of other than the magic value MUST result in the\n     * transaction being reverted.\n     * Note: the token contract address is always the message sender.\n     * @param sender address The address which called `approveAndCall` function\n     * @param amount uint256 The amount of tokens to be spent\n     * @param data bytes Additional data with no specified format\n     * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))` unless throwing\n     */\n    function onApprovalReceived(address sender, uint256 amount, bytes calldata data) external returns (bytes4);\n}\n\ninterface IERC1363Receiver {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n     * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n     */\n\n    /**\n     * @notice Handle the receipt of ERC1363 tokens\n     * @dev Any ERC1363 smart contract calls this function on the recipient\n     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n     * transfer. Return of other than the magic value MUST result in the\n     * transaction being reverted.\n     * Note: the token contract address is always the message sender.\n     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n     * @param sender address The address which are token transferred from\n     * @param amount uint256 The amount of tokens transferred\n     * @param data bytes Additional data with no specified format\n     * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))` unless throwing\n     */\n    function onTransferReceived(address operator, address sender, uint256 amount, bytes calldata data) external returns (bytes4);\n}\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(type(IERC165).interfaceId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n \n\n    \n//****************************************************************************//\n//---------------------        MAIN CODE STARTS HERE     ---------------------//\n//****************************************************************************//\n    \ncontract CMCXToken is owned, ERC165 {\n    \n\n    /*===============================\n    =         DATA STORAGE          =\n    ===============================*/\n\n    // Public variables of the token\n    using SafeMath for uint256;\n    string constant private _name = \"CORE MultiChain Token\";\n    string constant private _symbol = \"CMCX\";\n    uint256 constant private _decimals = 18;\n    uint256 private _totalSupply = 20000000000 * (10**_decimals);         //20 billion tokens\n    uint256 constant public maxSupply = 20000000000 * (10**_decimals);    //20 billion tokens\n    bool public safeguard;  //putting safeguard on will halt all non-owner functions\n\n    // This creates a mapping with all data storage\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n\n\n    /*===============================\n    =         PUBLIC EVENTS         =\n    ===============================*/\n\n    // This generates a public event of token transfer\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n        \n    // This generates a public event for frozen (blacklisting) accounts\n    event FrozenAccounts(address target, bool frozen);\n    \n    // This will log approval of token Transfer\n    event Approval(address indexed from, address indexed spender, uint256 value);\n\n\n\n    /*======================================\n    =       STANDARD ERC20 FUNCTIONS       =\n    ======================================*/\n    \n    /**\n     * Returns name of token \n     */\n    function name() external pure returns(string memory){\n        return _name;\n    }\n    \n    /**\n     * Returns symbol of token \n     */\n    function symbol() external pure returns(string memory){\n        return _symbol;\n    }\n    \n    /**\n     * Returns decimals of token \n     */\n    function decimals() external pure returns(uint256){\n        return _decimals;\n    }\n    \n    /**\n     * Returns totalSupply of token.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    /**\n     * Returns balance of token \n     */\n    function balanceOf(address user) external view returns(uint256){\n        return _balanceOf[user];\n    }\n    \n    /**\n     * Returns allowance of token \n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n    \n    /**\n     * Internal transfer, only can be called by this contract \n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        \n        //checking conditions\n        require(!safeguard);\n        require (_to != address(0));                      // Prevent transfer to 0x0 address. Use burn() instead\n        \n        // overflow and undeflow checked by SafeMath Library\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);    // Subtract from the sender\n        _balanceOf[_to] = _balanceOf[_to].add(_value);        // Add the same to the recipient\n        \n        // emit Transfer event\n        emit Transfer(_from, _to, _value);\n    }\n\n    /**\n        * Transfer tokens\n        *\n        * Send `_value` tokens to `_to` from your account\n        *\n        * @param _to The address of the recipient\n        * @param _value the amount to send\n        */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //no need to check for input validations, as that is ruled by SafeMath\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n        * Transfer tokens from other address\n        *\n        * Send `_value` tokens to `_to` in behalf of `_from`\n        *\n        * @param _from The address of the sender\n        * @param _to The address of the recipient\n        * @param _value the amount to send\n        */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //checking of allowance and token value is done by SafeMath\n        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n        * Set allowance for other address\n        *\n        * Allows `_spender` to spend no more than `_value` tokens in your behalf\n        *\n        * @param _spender The address authorized to spend\n        * @param _value the max amount they can spend\n        */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require(!safeguard);\n        /* AUDITOR NOTE:\n            Many dex and dapps pre-approve large amount of tokens to save gas for subsequent transaction. This is good use case.\n            On flip-side, some malicious dapp, may pre-approve large amount and then drain all token balance from user.\n            So following condition is kept in commented. It can be be kept that way or not based on client's consent.\n        */\n        //require(_balanceOf[msg.sender] >= _value, \"Balance does not have enough tokens\");\n        _allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to increase the allowance by.\n     */\n    function increase_allowance(address spender, uint256 value) external returns (bool) {\n        require(spender != address(0));\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to decrease the allowance by.\n     */\n    function decrease_allowance(address spender, uint256 value) external returns (bool) {\n        require(spender != address(0));\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n        return true;\n    }\n\n\n    /*=====================================\n    =       CUSTOM PUBLIC FUNCTIONS       =\n    ======================================*/\n    \n    constructor(){\n        //sending all the tokens to Owner\n        _balanceOf[owner] = _totalSupply;\n        \n        //firing event which logs this transaction\n        emit Transfer(address(0), owner, _totalSupply);\n        \n        // register the supported interfaces to conform to ERC1363 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1363_TRANSFER);\n        _registerInterface(_INTERFACE_ID_ERC1363_APPROVE);\n    }\n    \n    receive () external payable {  }\n\n    /**\n        * Destroy tokens\n        *\n        * Remove `_value` tokens from the system irreversibly\n        *\n        * @param _value the amount of money to burn\n        */\n    function burn(uint256 _value) external returns (bool success) {\n        require(!safeguard);\n        //checking of enough token balance is done by SafeMath\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\n        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        emit Transfer(msg.sender, address(0), _value);\n        return true;\n    }\n\n\n    \n    /** \n        * @notice Create `mintedAmount` tokens and send it to `target`\n        * @param target Address to receive the tokens\n        * @param mintedAmount the amount of tokens it will receive\n        */\n    function mintToken(address target, uint256 mintedAmount) onlyOwner external {\n        require(_totalSupply.add(mintedAmount) <= maxSupply, \"Cannot Mint more than maximum supply\");\n        _balanceOf[target] = _balanceOf[target].add(mintedAmount);\n        _totalSupply = _totalSupply.add(mintedAmount);\n        emit Transfer(address(0), target, mintedAmount);\n    }\n\n        \n\n    /**\n        * Owner can transfer tokens from contract to owner address\n        *\n        * When safeguard is true, then all the non-owner functions will stop working.\n        * When safeguard is false, then all the functions will resume working back again!\n        */\n    \n    function manualWithdrawTokens(uint256 tokenAmount) external onlyOwner{\n        // no need for overflow checking as that will be done in transfer function\n        _transfer(address(this), owner, tokenAmount);\n    }\n    \n    //Just in rare case, owner wants to transfer Ether from contract to owner address\n    function manualWithdrawEther()onlyOwner external{\n        owner.transfer(address(this).balance);\n    }\n    \n    /**\n        * Change safeguard status on or off\n        *\n        * When safeguard is true, then all the non-owner functions will stop working.\n        * When safeguard is false, then all the functions will resume working back again!\n        */\n    function changeSafeguardStatus() onlyOwner external{\n        if (safeguard == false){\n            safeguard = true;\n        }\n        else{\n            safeguard = false;    \n        }\n    }\n    \n\n    \n    /*************************************/\n    /*    Section for User Air drop      */\n    /*************************************/\n    \n    /**\n     * Run an ACTIVE Air-Drop\n     *\n     * It requires an array of all the addresses and amount of tokens to distribute\n     * It will only process first 100 recipients. That limit is fixed to prevent gas limit\n     */\n    function airdropACTIVE(address[] memory recipients,uint256[] memory tokenAmount) external returns(bool) {\n        uint256 totalAddresses = recipients.length;\n        address msgSender = msg.sender; //make a local variable to save gas cost in loop\n        require(totalAddresses <= 100,\"Too many recipients\");\n        for(uint i = 0; i < totalAddresses; i++)\n        {\n          //This will loop through all the recipients and send them the specified tokens\n          //Input data validation is unncessary, as that is done by SafeMath and which also saves some gas.\n          _transfer(msgSender, recipients[i], tokenAmount[i]);\n        }\n        return true;\n    }\n   \n    /*****************************************/\n    /*  Section for ERC1363 Implementation   */\n    /*****************************************/\n    \n    \n    /*\n     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.\n     * 0x4bbee2df ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))\n     */\n    bytes4 internal constant _INTERFACE_ID_ERC1363_TRANSFER = 0x4bbee2df;\n\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.\n     * 0xfb9ec8ce ===\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n    bytes4 internal constant _INTERFACE_ID_ERC1363_APPROVE = 0xfb9ec8ce;\n\n    // Equals to `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC1363Receiver(0).onTransferReceived.selector`\n    bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c;\n\n    // Equals to `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC1363Spender(0).onApprovalReceived.selector`\n    bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0;\n\n\n    /**\n     * @dev Transfer tokens to a specified address and then execute a callback on recipient.\n     * @param recipient The address to transfer to.\n     * @param amount The amount to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferAndCall(address recipient, uint256 amount) public virtual  returns (bool) {\n        return transferAndCall(recipient, amount, \"\");\n    }\n\n    /**\n     * @dev Transfer tokens to a specified address and then execute a callback on recipient.\n     * @param recipient The address to transfer to\n     * @param amount The amount to be transferred\n     * @param data Additional data with no specified format\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferAndCall(address recipient, uint256 amount, bytes memory data) public virtual  returns (bool) {\n        transfer(recipient, amount);\n        require(_checkAndCallTransfer(_msgSender(), recipient, amount, data), \"ERC1363: _checkAndCallTransfer reverts\");\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another and then execute a callback on recipient.\n     * @param sender The address which you want to send tokens from\n     * @param recipient The address which you want to transfer to\n     * @param amount The amount of tokens to be transferred\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferFromAndCall(address sender, address recipient, uint256 amount) public virtual  returns (bool) {\n        return transferFromAndCall(sender, recipient, amount, \"\");\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another and then execute a callback on recipient.\n     * @param sender The address which you want to send tokens from\n     * @param recipient The address which you want to transfer to\n     * @param amount The amount of tokens to be transferred\n     * @param data Additional data with no specified format\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferFromAndCall(address sender, address recipient, uint256 amount, bytes memory data) public virtual  returns (bool) {\n        transferFrom(sender, recipient, amount);\n        require(_checkAndCallTransfer(sender, recipient, amount, data), \"ERC1363: _checkAndCallTransfer reverts\");\n        return true;\n    }\n\n    /**\n     * @dev Approve spender to transfer tokens and then execute a callback on recipient.\n     * @param spender The address allowed to transfer to\n     * @param amount The amount allowed to be transferred\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approveAndCall(address spender, uint256 amount) public virtual  returns (bool) {\n        return approveAndCall(spender, amount, \"\");\n    }\n\n    /**\n     * @dev Approve spender to transfer tokens and then execute a callback on recipient.\n     * @param spender The address allowed to transfer to.\n     * @param amount The amount allowed to be transferred.\n     * @param data Additional data with no specified format.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approveAndCall(address spender, uint256 amount, bytes memory data) public virtual  returns (bool) {\n        approve(spender, amount);\n        require(_checkAndCallApprove(spender, amount, data), \"ERC1363: _checkAndCallApprove reverts\");\n        return true;\n    }\n\n    /**\n     * @dev Internal function to invoke `onTransferReceived` on a target address\n     *  The call is not executed if the target address is not a contract\n     * @param sender address Representing the previous owner of the given token value\n     * @param recipient address Target address that will receive the tokens\n     * @param amount uint256 The amount mount of tokens to be transferred\n     * @param data bytes Optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkAndCallTransfer(address sender, address recipient, uint256 amount, bytes memory data) internal virtual returns (bool) {\n        if (!isContract(recipient)) {\n            return false;\n        }\n        bytes4 retval = IERC1363Receiver(recipient).onTransferReceived(\n            _msgSender(), sender, amount, data\n        );\n        return (retval == _ERC1363_RECEIVED);\n    }\n\n    /**\n     * @dev Internal function to invoke `onApprovalReceived` on a target address\n     *  The call is not executed if the target address is not a contract\n     * @param spender address The address which will spend the funds\n     * @param amount uint256 The amount of tokens to be spent\n     * @param data bytes Optional data to send along with the call\n     * @return whether the call correctly returned the expected magic value\n     */\n    function _checkAndCallApprove(address spender, uint256 amount, bytes memory data) internal virtual returns (bool) {\n        if (!isContract(spender)) {\n            return false;\n        }\n        bytes4 retval = IERC1363Spender(spender).onApprovalReceived(\n            _msgSender(), amount, data\n        );\n        return (retval == _ERC1363_APPROVED);\n    }\n    \n    \n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    \n    /**\n     * returns msg.sender\n     */\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    \n    \n    /**\n     * returns msg.data\n     */\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"}}}