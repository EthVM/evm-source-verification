{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":40},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"contracts/Timelock.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n  Timelock contract.\n  Fixed token payout and timing.\n  Can add recipients and multiple grants per recipient.\n\n  @author iain\n  github.com/iainnash/simple-timelock\n */\ncontract Timelock {\n    // From IERC20\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    /**\n        Error codes lookup:\n        1: Recover and recieve grant days need to be greater than 0\n        2: Grant not valid.\n        3: Only owner can add grants.\n        4: Only owner can recover\n        5: Cannot set the recovery grant before the unlock time\n        6: Too early to recover\n        7: Too early to claim\n        8: Recover timestamp needs to be after receive timestamp\n        9: Already granted\n        10: Cannot grant after unlock\n        11: Token not approved or not enough\n        12: Invalid ownership\n    */\n\n    // Timestamp for when the recovery begins\n    uint256 private immutable timeRecoverGrant;\n    // Timestamp for when the receive begins\n    uint256 private immutable timeReceiveGrant;\n    // Owner that can recover grant and add new grant addresses\n    address private immutable owner;\n    // Token to lock\n    IERC20 private immutable token;\n\n    // Mapping of address to grant\n    mapping(address => uint256) private grants;\n\n    // Emitted when a claim is recovered\n    event Recovered(address recipient, uint256 amount);\n\n    // Emitted when a claim is claimed\n    event Claimed(address actor, uint256 amount);\n\n    // Emitted when a grant is added\n    event GrantsAdded(address actor, address[] newRecipients);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"3\");\n        _;\n    }\n\n    /**\n        Sets up grant created by TimelockCreator Contract\n     */\n    constructor(\n        address _owner,\n        IERC20 _token,\n        uint256 unlockTimestamp,\n        uint256 recoverTimestamp\n    ) {\n        token = _token;\n        owner = _owner;\n        require(\n            unlockTimestamp > block.timestamp &&\n                recoverTimestamp > block.timestamp,\n            \"1\"\n        );\n        require(recoverTimestamp > unlockTimestamp, \"8\");\n        timeReceiveGrant = unlockTimestamp;\n        timeRecoverGrant = recoverTimestamp;\n    }\n\n    /**\n        Returns token for timelock and amount per recipient\n     */\n    function getToken() public view returns (IERC20) {\n        return token;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    /** \n        Returns the time users can recieve the grant / when the timelock expires\n     */\n    function getTimeUnlock() public view returns (uint256) {\n        return timeReceiveGrant;\n    }\n\n    /** \n        Returns the admin can recover unclaimed grants\n     */\n    function getTimeRecover() public view returns (uint256) {\n        return timeRecoverGrant;\n    }\n\n    /**\n        Proxied token information for bookkeeping / discoverability\n        Not implemented:\n            1. approvals\n            2. transfers\n            etc.\n    */\n    function balanceOf(address user) public view returns (uint256) {\n        return grants[user];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    function decimals() public view returns (uint8) {\n        return IERC20Metadata(address(token)).decimals();\n    }\n\n    function name() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"Timelocked \",\n                    IERC20Metadata(address(token)).name()\n                )\n            );\n    }\n\n    function symbol() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"LOCK_\",\n                    IERC20Metadata(address(token)).symbol()\n                )\n            );\n    }\n\n    /** \n        @dev Adds a grant to the timelock\n        Grants can be added at any time before claim period.\n    */\n    function addGrants(address[] memory newRecipients, uint256 grantSize)\n        external\n        onlyOwner\n    {\n        require(grantSize > 0, \"2\");\n        require(getTimeUnlock() > block.timestamp, \"10\");\n        require(\n            token.allowance(msg.sender, address(this)) >=\n                newRecipients.length * grantSize,\n            \"11\"\n        );\n\n        uint256 numberRecipients = newRecipients.length;\n        token.transferFrom(\n            msg.sender,\n            address(this),\n            grantSize * numberRecipients\n        );\n        for (uint256 i = 0; i < numberRecipients; i++) {\n            emit Transfer(address(0), newRecipients[i], grantSize);\n            grants[newRecipients[i]] += grantSize;\n        }\n        emit GrantsAdded(owner, newRecipients);\n    }\n\n    /** \n        Returns the status of the grant.\n     */\n    function grantedAmount(address recipient) external view returns (uint256) {\n        return grants[recipient];\n    }\n\n    /**\n        Allows a user to claim their grant. Claimee has to be msg.sender.\n     */\n    function claim() external {\n        address recipient = msg.sender;\n        require(block.timestamp >= timeReceiveGrant, \"7\");\n        uint256 grantAmount = grants[recipient];\n        require(grantAmount > 0, \"2\");\n        token.transfer(recipient, grantAmount);\n        grants[recipient] = 0;\n        // Emit grant claimed event\n        emit Claimed(recipient, grantAmount);\n        // Burn tracker token\n        emit Transfer(recipient, address(0x0), grantAmount);\n    }\n\n    /**\n        The owner of the grant can recover after the recovery timestamp passes.\n        This sweeps remaining funds and destroys the contract data.\n     */\n    function recover() external onlyOwner {\n        address payable sender = payable(msg.sender);\n        require(block.timestamp >= timeRecoverGrant, \"6\");\n        uint256 balance = token.balanceOf(address(this));\n        emit Recovered(sender, balance);\n        token.transfer(sender, balance);\n        selfdestruct(sender);\n    }\n}\n"}}}