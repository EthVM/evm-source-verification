{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/COCETH Stake.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.7.6;\r\n\r\n// ----------------------------------------------------------------------------\r\n// CocktailBar Stake COCETH to earn MOJITO\r\n// Enter our universe : cocktailbar.finance\r\n//\r\n// Come join the disscussion: https://t.me/cocktailbar_discussion\r\n//\r\n//                                          Sincerely, Mr. Martini\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function ceil(uint a, uint m) internal pure returns (uint r) {\r\n        return (a + m - 1) / m * m;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// TRC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\ninterface COC {\r\n    function balanceOf(address _owner) view external  returns (uint256 balance);\r\n\r\n    function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function transfer(address _to, uint256 _amount) external  returns (bool success);\r\n    function transferFrom(address _from,address _to,uint256 _amount) external  returns (bool success);\r\n    function approve(address _to, uint256 _amount) external  returns (bool success);\r\n}\r\n\r\n\r\ninterface MOJITO {\r\n    function balanceOf(address _owner) view external  returns (uint256 balance);\r\n\r\n    function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function transfer(address _to, uint256 _amount) external  returns (bool success);\r\n    function transferFrom(address _from,address _to,uint256 _amount) external  returns (bool success);\r\n    function approve(address _to, uint256 _amount) external  returns (bool success);\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract StakeCOCETH is Owned, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    uint256 private TotalMRewards;\r\n    uint256 public WeekRewardPercent = 100;\r\n    uint256 public TotalStakedETH = 0;\r\n    uint256 StakingFee = 10; // 1.0%\r\n    uint256 UnstakingFee = 30; // 3.0%\r\n    uint256 private TeamFeesCollector = 0;\r\n    address public stakeTokenAdd = 0x39FB7AF42ef12D92A0d577ca44cd54a0f24c4915;\r\n    address constant public rewardToken = 0xda579367c6ca7854009133D1B3739020ba350C23;\r\n    uint256 public creationTimeContract;\r\n\r\n\r\n\r\n    struct USER{\r\n        uint256 stakedAmount;\r\n        uint256 creationTime;\r\n        uint256 TotalMRewarded;\r\n        uint256 lastClaim;\r\n        uint256 MyTotalStaked;\r\n    }\r\n\r\n    mapping(address => USER) public stakers;\r\n    mapping(address=>uint256) public amounts;           // keeps record of each reward payout\r\n    uint256[] private rewardperday = [51063829790000000000,51063829790000000000,51063829790000000000,51063829790000000000,51063829790000000000,44680851060000000000,44680851060000000000,44680851060000000000,44680851060000000000,44680851060000000000,38297872340000000000,38297872340000000000,38297872340000000000,38297872340000000000,38297872340000000000,31914893620000000000,31914893620000000000,31914893620000000000,31914893620000000000,31914893620000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,25531914890000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,19148936170000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,12765957450000000000,6382978723000000000,6382978723000000000,6382978723000000000,6382978723000000000,6382978723000000000];\r\n    event STAKED(address staker, uint256 tokens, uint256 StakingFee);\r\n    event UNSTAKED(address staker, uint256 tokens, uint256 UnstakingFee);\r\n    event CLAIMEDREWARD(address staker, uint256 reward);\r\n    event PERCENTCHANGED(address operator, uint256 percent);\r\n    event FkTake(uint256 amount);\r\n    event JkTake(uint256 amount);\r\n    constructor() {\r\n         creationTimeContract = block.timestamp;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Token holders can stake their tokens using this function\r\n    // @param tokens number of tokens to stake\r\n    // ------------------------------------------------------------------------\r\n    function STAKE(uint256 tokens) external nonReentrant returns(bool){\r\n\r\n        require(COC(stakeTokenAdd).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from user account\");\r\n        uint256 _stakingFee = (onePercentofTokens(tokens).mul(StakingFee)).div(10);\r\n        stakers[msg.sender].stakedAmount = (tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedAmount);\r\n        TeamFeesCollector = TeamFeesCollector.add(_stakingFee);\r\n        stakers[msg.sender].creationTime = block.timestamp;\r\n        stakers[msg.sender].lastClaim =  stakers[msg.sender].creationTime;\r\n\r\n        stakers[msg.sender].MyTotalStaked = stakers[msg.sender].MyTotalStaked.add((tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedAmount));\r\n        TotalStakedETH = TotalStakedETH.add((tokens).sub(_stakingFee));\r\n        emit STAKED(msg.sender, (tokens).sub(_stakingFee), _stakingFee);\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Stakers can claim their pending rewards using this function\r\n    // ------------------------------------------------------------------------\r\n\r\n\r\n    function WITHDRAW(uint256 tokens) external nonReentrant {\r\n        require(stakers[msg.sender].stakedAmount >= tokens && tokens > 0, \"Invalid token amount to withdraw\");\r\n        uint256 _unstakingFee = (onePercentofTokens(tokens).mul(UnstakingFee)).div(10);\r\n       TeamFeesCollector= TeamFeesCollector.add(_unstakingFee);\r\n        uint256 owing = 0;\r\n        require(COC(stakeTokenAdd).transfer(msg.sender, tokens.sub(_unstakingFee)), \"Error in un-staking tokens\");\r\n        stakers[msg.sender].stakedAmount = (stakers[msg.sender].stakedAmount).sub(tokens);\r\n        owing = TotalStakedETH;\r\n        TotalStakedETH = owing.sub(tokens);\r\n        stakers[msg.sender].creationTime = block.timestamp;\r\n        stakers[msg.sender].lastClaim = stakers[msg.sender].creationTime;\r\n        emit UNSTAKED(msg.sender, tokens.sub(_unstakingFee), _unstakingFee);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Private function to calculate 1% percentage\r\n    // ------------------------------------------------------------------------\r\n    function onePercentofTokens(uint256 _tokens) private pure returns (uint256){\r\n        uint256 roundValue = _tokens.ceil(100);\r\n        uint onePerc = roundValue.mul(100).div(100 * 10**uint(2));\r\n        return onePerc;\r\n    }\r\n\r\n\r\n    function calPercentofTokens(uint256 _tokens, uint256 cust) private pure returns (uint256){\r\n        uint256 roundValue = _tokens.ceil(100);\r\n        uint256 custPercentofTokens = roundValue.mul(cust).div(100 * 10**uint(2));\r\n        return custPercentofTokens;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the number of tokens staked by a staker\r\n    // param _staker the address of the staker\r\n    // ------------------------------------------------------------------------\r\n    function yourStakedToken(address staker) external view returns(uint256 stakedT){\r\n        return stakers[staker].stakedAmount;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the TOKEN balance of the token holder\r\n    // @param user the address of the token holder\r\n    // ------------------------------------------------------------------------\r\n    function yourTokenBalance(address user) external view returns(uint256 TBalance){\r\n        return COC(stakeTokenAdd).balanceOf(user);\r\n    }\r\n\r\n    function setPercent(uint256 percent) external onlyOwner {\r\n      require(percent < 30);\r\n        if(percent >= 1)\r\n        {\r\n         WeekRewardPercent = percent;\r\n         emit PERCENTCHANGED(msg.sender, percent);\r\n        }\r\n\r\n    }\r\n\r\n    function OwnerTeamFeesCollectorRead() external view returns(uint256 jKeeper) {\r\n        return TeamFeesCollector;\r\n    }\r\n\r\n\r\n\r\n    function yourDailyReward(address user) external view returns(uint256 RewardBalance){\r\n      uint256 timeToday = block.timestamp - creationTimeContract; //what day it is\r\n            uint256 timeT = timeToday.div(86400);\r\n            if(stakers[user].stakedAmount > 0)\r\n            {\r\n\r\n           //  if(timeT > 0)\r\n             {\r\n                  uint256 rewardToGive = calculateReward(timeT,user);\r\n                  return rewardToGive;\r\n             }//else\r\n             //{\r\n               //  return 0;\r\n             //}\r\n            }\r\n            else\r\n            {\r\n                return 0;\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n function MyTotalRewards(address user) external view returns(uint256 poolreward)\r\n  {\r\n\r\n      if(stakers[user].stakedAmount > 0)\r\n      {\r\n           uint256 timeToday = block.timestamp - creationTimeContract;\r\n            uint256 timeT = timeToday.div(86400);\r\n\r\n        if(timeT > 59)\r\n        {\r\n            return 0;\r\n        }\r\n        else\r\n        {\r\n        uint256 staked = SafeMath.mul(470000000000000000000, (stakers[user].stakedAmount)).div(TotalStakedETH);\r\n        return staked;\r\n\r\n        }\r\n      }\r\n      else\r\n      return 0;\r\n\r\n\r\n\r\n  }\r\n     function CLAIMREWARD() external  {\r\n\r\n            uint256 timeToday = block.timestamp - creationTimeContract; //what day it is\r\n            uint256 timeT = timeToday.div(86400);\r\n            require(stakers[msg.sender].stakedAmount > 0,\"you need to stake some coins\");\r\n            //require(timeT > 0,\"Claim Time has not started yet\");\r\n            uint256 rewardToGive = calculateReward(timeT,msg.sender);\r\n            require(MOJITO(rewardToken).transfer(msg.sender,rewardToGive), \"ERROR: error in sending reward from contract\");\r\n            emit CLAIMEDREWARD(msg.sender, rewardToGive);\r\n            stakers[msg.sender].TotalMRewarded = (stakers[msg.sender].TotalMRewarded).add(rewardToGive);\r\n            stakers[msg.sender].lastClaim = block.timestamp;\r\n            TotalMRewards = TotalMRewards.add(rewardToGive);\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n  function calculateReward(uint timeday, address user) private view returns(uint256 rew){\r\n\r\n\r\n       uint256 totalReward = 0;\r\n\r\n      if(timeday>60) //check reward for 0 day\r\n      {\r\n         uint256 daystocheck = stakers[user].lastClaim - creationTimeContract;\r\n         uint256 daysCount = daystocheck.div(86400);  \r\n         daystocheck = 60 - daysCount;\r\n\r\n\r\n         for(uint i =daystocheck; i<60; i++)\r\n         {\r\n            uint256 rewardpday =    ((stakers[user].stakedAmount)*(rewardperday[i])).div(TotalStakedETH);\r\n            totalReward = totalReward.add(rewardpday);\r\n         }\r\n\r\n\r\n\r\n      }else\r\n      {\r\n          uint256 daystocheck = stakers[user].lastClaim - creationTimeContract;  //when did user last withdrew funds\r\n          uint256 daysCount = daystocheck.div(86400);\r\n\r\n          uint256 daystogive = block.timestamp - creationTimeContract;  //check what day it is\r\n          uint256 daysCounts = daystogive.div(86400);\r\n\r\n          if(stakers[user].lastClaim == stakers[user].creationTime)\r\n          {\r\n         \r\n          uint256 somthing = daysCount * 86400;\r\n          daystogive = 0;\r\n          if(somthing == 0 )\r\n          {\r\n        // daystogive = 86400 - daystocheck;\r\n          daystogive =  block.timestamp - stakers[user].lastClaim;\r\n             \r\n          }\r\n          else{\r\n             daystogive = daystocheck.sub(somthing);\r\n          }\r\n\r\n          if(daysCount ==  daysCounts)\r\n          {\r\n\r\n              totalReward = (((stakers[user].stakedAmount)*(rewardperday[daysCounts]))).div(TotalStakedETH);\r\n              totalReward = (totalReward.mul(daystogive)).div(86400);\r\n\r\n          }\r\n          else\r\n          {\r\n             for(uint i = daysCount; i<daysCounts; i++)\r\n            {\r\n                uint256 rewardpday = ((stakers[user].stakedAmount)*(rewardperday[i])).div(TotalStakedETH);\r\n\r\n            if(i == daysCount)\r\n            {\r\n                rewardpday = (rewardpday.mul(daystogive)).div(86400);\r\n            }\r\n                 totalReward = totalReward.add(rewardpday);\r\n            }\r\n          }\r\n\r\n          }\r\n          else\r\n          {\r\n                if(daysCount == daysCounts)\r\n                {\r\n                daystogive =  block.timestamp - stakers[user].lastClaim;\r\n                totalReward = (((stakers[user].stakedAmount)*(rewardperday[daysCounts]))).div(TotalStakedETH);\r\n                totalReward = (totalReward.mul(daystogive)).div(86400);\r\n                }\r\n                else{\r\n             for(uint i = daysCount; i<daysCounts; i++)\r\n            {\r\n                uint256 rewardpday =    ((stakers[user].stakedAmount)*(rewardperday[i])).div(TotalStakedETH);\r\n                totalReward = totalReward.add(rewardpday);\r\n            }\r\n\r\n                    }\r\n          }\r\n\r\n\r\n      }\r\n        return totalReward;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function TotalPoolRewards() external pure returns(uint256 tpreward)\r\n    {\r\n        return 1500000000000000000000;\r\n    }\r\n\r\n\r\n    function MyTotalStaked(address user) external view returns(uint256 totalstaked)\r\n    {\r\n       return stakers[user].MyTotalStaked;\r\n    }\r\n\r\nfunction CurrentTokenReward() external view returns(uint256 crrtr)\r\n    {\r\n\r\n             uint256 timeToday = block.timestamp - creationTimeContract;\r\n        uint256 timeT = timeToday.div(86400);\r\n        if(timeT > 60)\r\n        {\r\n            return 0;\r\n        }\r\n        else\r\n        {\r\n\r\n        return rewardperday[timeT];\r\n\r\n        }\r\n\r\n    }\r\n\r\nfunction TotalClaimedReward() external view returns (uint256 TotalM)\r\n{\r\n    return TotalMRewards;\r\n}\r\n\r\nfunction SetStakeFee(uint256 percent) external onlyOwner {\r\n  require(percent < 10);\r\n    StakingFee = percent;\r\n}\r\n\r\nfunction SetUNStakeFee(uint256 percent) external onlyOwner {\r\n  require(percent < 10);\r\n    UnstakingFee = percent;\r\n}\r\n\r\n\r\n\r\n}"
    }
  }
}