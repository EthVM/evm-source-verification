{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SavingsContract.sol": {
      "content": "pragma solidity 0.5.16;\r\n\r\n\r\ninterface ISavingsManager {\r\n\r\n    /** @dev Admin privs */\r\n    function distributeUnallocatedInterest(address _mAsset) external;\r\n\r\n    /** @dev Liquidator */\r\n    function depositLiquidation(address _mAsset, uint256 _liquidation) external;\r\n\r\n    /** @dev Liquidator */\r\n    function collectAndStreamInterest(address _mAsset) external;\r\n\r\n    /** @dev Public privs */\r\n    function collectAndDistributeInterest(address _mAsset) external;\r\n}\r\n\r\ninterface ISavingsContractV1 {\r\n    function depositInterest(uint256 _amount) external;\r\n\r\n    function depositSavings(uint256 _amount) external returns (uint256 creditsIssued);\r\n    function redeem(uint256 _amount) external returns (uint256 massetReturned);\r\n\r\n    function exchangeRate() external view returns (uint256);\r\n    function creditBalances(address) external view returns (uint256);\r\n}\r\n\r\ninterface ISavingsContractV2 {\r\n\r\n    // DEPRECATED but still backwards compatible\r\n    function redeem(uint256 _amount) external returns (uint256 massetReturned);\r\n    function creditBalances(address) external view returns (uint256); // V1 & V2 (use balanceOf)\r\n\r\n    // --------------------------------------------\r\n\r\n    function depositInterest(uint256 _amount) external; // V1 & V2\r\n\r\n    function depositSavings(uint256 _amount) external returns (uint256 creditsIssued); // V1 & V2\r\n    function depositSavings(uint256 _amount, address _beneficiary) external returns (uint256 creditsIssued); // V2\r\n\r\n    function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\r\n    function redeemUnderlying(uint256 _amount) external returns (uint256 creditsBurned); // V2\r\n\r\n    function exchangeRate() external view returns (uint256); // V1 & V2\r\n\r\n    function balanceOfUnderlying(address _user) external view returns (uint256 balance); // V2\r\n\r\n    function underlyingToCredits(uint256 _credits) external view returns (uint256 underlying); // V2\r\n    function creditsToUnderlying(uint256 _underlying) external view returns (uint256 credits); // V2\r\n\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\ncontract InitializableERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(string memory nameArg, string memory symbolArg, uint8 decimalsArg) internal {\r\n        _name = nameArg;\r\n        _symbol = symbolArg;\r\n        _decimals = decimalsArg;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract InitializableToken is ERC20, InitializableERC20Detailed {\r\n\r\n    /**\r\n     * @dev Initialization function for implementing contract\r\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\r\n     */\r\n    function _initialize(string memory _nameArg, string memory _symbolArg) internal {\r\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\r\n    }\r\n}\r\n\r\ncontract ModuleKeys {\r\n\r\n    // Governance\r\n    // ===========\r\n    // keccak256(\"Governance\");\r\n    bytes32 internal constant KEY_GOVERNANCE = 0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\r\n    //keccak256(\"Staking\");\r\n    bytes32 internal constant KEY_STAKING = 0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\r\n    //keccak256(\"ProxyAdmin\");\r\n    bytes32 internal constant KEY_PROXY_ADMIN = 0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\r\n\r\n    // mStable\r\n    // =======\r\n    // keccak256(\"OracleHub\");\r\n    bytes32 internal constant KEY_ORACLE_HUB = 0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\r\n    // keccak256(\"Manager\");\r\n    bytes32 internal constant KEY_MANAGER = 0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\r\n    //keccak256(\"Recollateraliser\");\r\n    bytes32 internal constant KEY_RECOLLATERALISER = 0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\r\n    //keccak256(\"MetaToken\");\r\n    bytes32 internal constant KEY_META_TOKEN = 0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\r\n    // keccak256(\"SavingsManager\");\r\n    bytes32 internal constant KEY_SAVINGS_MANAGER = 0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\r\n    // keccak256(\"Liquidator\");\r\n    bytes32 internal constant KEY_LIQUIDATOR = 0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\r\n}\r\n\r\ninterface INexus {\r\n    function governor() external view returns (address);\r\n    function getModule(bytes32 key) external view returns (address);\r\n\r\n    function proposeModule(bytes32 _key, address _addr) external;\r\n    function cancelProposedModule(bytes32 _key) external;\r\n    function acceptProposedModule(bytes32 _key) external;\r\n    function acceptProposedModules(bytes32[] calldata _keys) external;\r\n\r\n    function requestLockModule(bytes32 _key) external;\r\n    function cancelLockModule(bytes32 _key) external;\r\n    function lockModule(bytes32 _key) external;\r\n}\r\n\r\ncontract InitializableModule2 is ModuleKeys {\r\n\r\n    INexus public constant nexus = INexus(0xAFcE80b19A8cE13DEc0739a1aaB7A028d6845Eb3);\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        require(msg.sender == _governor(), \"Only governor can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governance.\r\n     *      Governance is either Governor address or Governance address.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == _governor() || msg.sender == _governance(),\r\n            \"Only governance can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the ProxyAdmin.\r\n     */\r\n    modifier onlyProxyAdmin() {\r\n        require(\r\n            msg.sender == _proxyAdmin(), \"Only ProxyAdmin can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(msg.sender == _manager(), \"Only manager can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governor address from the Nexus\r\n     * @return Address of Governor Contract\r\n     */\r\n    function _governor() internal view returns (address) {\r\n        return nexus.governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governance Module address from the Nexus\r\n     * @return Address of the Governance (Phase 2)\r\n     */\r\n    function _governance() internal view returns (address) {\r\n        return nexus.getModule(KEY_GOVERNANCE);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Staking Module address from the Nexus\r\n     * @return Address of the Staking Module contract\r\n     */\r\n    function _staking() internal view returns (address) {\r\n        return nexus.getModule(KEY_STAKING);\r\n    }\r\n\r\n    /**\r\n     * @dev Return ProxyAdmin Module address from the Nexus\r\n     * @return Address of the ProxyAdmin Module contract\r\n     */\r\n    function _proxyAdmin() internal view returns (address) {\r\n        return nexus.getModule(KEY_PROXY_ADMIN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return MetaToken Module address from the Nexus\r\n     * @return Address of the MetaToken Module contract\r\n     */\r\n    function _metaToken() internal view returns (address) {\r\n        return nexus.getModule(KEY_META_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * @dev Return OracleHub Module address from the Nexus\r\n     * @return Address of the OracleHub Module contract\r\n     */\r\n    function _oracleHub() internal view returns (address) {\r\n        return nexus.getModule(KEY_ORACLE_HUB);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Manager Module address from the Nexus\r\n     * @return Address of the Manager Module contract\r\n     */\r\n    function _manager() internal view returns (address) {\r\n        return nexus.getModule(KEY_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return SavingsManager Module address from the Nexus\r\n     * @return Address of the SavingsManager Module contract\r\n     */\r\n    function _savingsManager() internal view returns (address) {\r\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Recollateraliser Module address from the Nexus\r\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\r\n     */\r\n    function _recollateraliser() internal view returns (address) {\r\n        return nexus.getModule(KEY_RECOLLATERALISER);\r\n    }\r\n}\r\n\r\ninterface IConnector {\r\n\r\n  /**\r\n   * @notice Deposits the mAsset into the connector\r\n   * @param _amount Units of mAsset to receive and deposit\r\n   */\r\n  function deposit(uint256 _amount) external;\r\n\r\n  /**\r\n   * @notice Withdraws a specific amount of mAsset from the connector\r\n   * @param _amount Units of mAsset to withdraw\r\n   */\r\n  function withdraw(uint256 _amount) external;\r\n\r\n  /**\r\n   * @notice Withdraws all mAsset from the connector\r\n   */\r\n  function withdrawAll() external;\r\n\r\n  /**\r\n   * @notice Returns the available balance in the connector. In connections\r\n   * where there is likely to be an initial dip in value due to conservative\r\n   * exchange rates (e.g. with Curves `get_virtual_price`), it should return\r\n   * max(deposited, balance) to avoid temporary negative yield. Any negative yield\r\n   * should be corrected during a withdrawal or over time.\r\n   * @return Balance of mAsset in the connector\r\n   */\r\n  function checkBalance() external view returns (uint256);\r\n}\r\n\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\nlibrary StableMath {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @notice Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * @dev bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x.mul(FULL_SCALE);\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(uint256 x, uint256 y, uint256 scale)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        uint256 z = x.mul(y);\r\n        // return 9e38 / 1e18 = 9e18\r\n        return z.div(scale);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x.mul(y);\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil.div(FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        uint256 z = x.mul(FULL_SCALE);\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return z.div(y);\r\n    }\r\n\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x.mul(ratio);\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled.add(RATIO_SCALE.sub(1));\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil.div(RATIO_SCALE);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        uint256 y = x.mul(RATIO_SCALE);\r\n        // return 1e22 / 1e12 = 1e10\r\n        return y.div(ratio);\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n/**\r\n * @title   SavingsContract\r\n * @author  Stability Labs Pty. Ltd.\r\n * @notice  Savings contract uses the ever increasing \"exchangeRate\" to increase\r\n *          the value of the Savers \"credits\" (ERC20) relative to the amount of additional\r\n *          underlying collateral that has been deposited into this contract (\"interest\")\r\n * @dev     VERSION: 2.0\r\n *          DATE:    2020-12-15\r\n */\r\ncontract SavingsContract is\r\n    ISavingsContractV1,\r\n    ISavingsContractV2,\r\n    Initializable,\r\n    InitializableToken,\r\n    InitializableModule2\r\n{\r\n    using SafeMath for uint256;\r\n    using StableMath for uint256;\r\n\r\n    // Core events for depositing and withdrawing\r\n    event ExchangeRateUpdated(uint256 newExchangeRate, uint256 interestCollected);\r\n    event SavingsDeposited(address indexed saver, uint256 savingsDeposited, uint256 creditsIssued);\r\n    event CreditsRedeemed(address indexed redeemer, uint256 creditsRedeemed, uint256 savingsCredited);\r\n\r\n    event AutomaticInterestCollectionSwitched(bool automationEnabled);\r\n\r\n    // Connector poking\r\n    event PokerUpdated(address poker);\r\n\r\n    event FractionUpdated(uint256 fraction);\r\n    event ConnectorUpdated(address connector);\r\n    event EmergencyUpdate();\r\n\r\n    event Poked(uint256 oldBalance, uint256 newBalance, uint256 interestDetected);\r\n    event PokedRaw();\r\n\r\n    // Rate between 'savings credits' and underlying\r\n    // e.g. 1 credit (1e17) mulTruncate(exchangeRate) = underlying, starts at 10:1\r\n    // exchangeRate increases over time\r\n    uint256 private constant startingRate = 1e17;\r\n    uint256 public exchangeRate;\r\n\r\n    // Underlying asset is underlying\r\n    IERC20 public constant underlying = IERC20(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\r\n    bool private automateInterestCollection;\r\n\r\n    // Yield\r\n    // Poker is responsible for depositing/withdrawing from connector\r\n    address public poker;\r\n    // Last time a poke was made\r\n    uint256 public lastPoke;\r\n    // Last known balance of the connector\r\n    uint256 public lastBalance;\r\n    // Fraction of capital assigned to the connector (100% = 1e18)\r\n    uint256 public fraction;\r\n    // Address of the current connector (all IConnectors are mStable validated)\r\n    IConnector public connector;\r\n    // How often do we allow pokes\r\n    uint256 constant private POKE_CADENCE = 4 hours;\r\n    // Max APY generated on the capital in the connector\r\n    uint256 constant private MAX_APY = 4e18;\r\n    uint256 constant private SECONDS_IN_YEAR = 365 days;\r\n\r\n    // Add these constants to bytecode at deploytime\r\n    function initialize(\r\n        address _poker,\r\n        string calldata _nameArg,\r\n        string calldata _symbolArg\r\n    )\r\n        external\r\n        initializer\r\n    {\r\n        InitializableToken._initialize(_nameArg, _symbolArg);\r\n\r\n        require(_poker != address(0), \"Invalid poker address\");\r\n        poker = _poker;\r\n\r\n        fraction = 2e17;\r\n        automateInterestCollection = true;\r\n        exchangeRate = startingRate;\r\n    }\r\n\r\n    /** @dev Only the savings managaer (pulled from Nexus) can execute this */\r\n    modifier onlySavingsManager() {\r\n        require(msg.sender == _savingsManager(), \"Only savings manager can execute\");\r\n        _;\r\n    }\r\n\r\n\r\n    /***************************************\r\n                    VIEW - E\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Returns the underlying balance of a given user\r\n     * @param _user     Address of the user to check\r\n     * @return balance  Units of underlying owned by the user\r\n     */\r\n    function balanceOfUnderlying(address _user) external view returns (uint256 balance) {\r\n        (balance,) = _creditsToUnderlying(balanceOf(_user));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a given underlying amount into credits\r\n     * @param _underlying  Units of underlying\r\n     * @return credits     Credit units (a.k.a imUSD)\r\n     */\r\n    function underlyingToCredits(uint256 _underlying) external view returns (uint256 credits) {\r\n        (credits,) = _underlyingToCredits(_underlying);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a given credit amount into underlying\r\n     * @param _credits  Units of credits\r\n     * @return amount   Corresponding underlying amount\r\n     */\r\n    function creditsToUnderlying(uint256 _credits) external view returns (uint256 amount) {\r\n        (amount,) = _creditsToUnderlying(_credits);\r\n    }\r\n\r\n    // Deprecated in favour of `balanceOf(address)`\r\n    // Maintained for backwards compatibility\r\n    // Returns the credit balance of a given user\r\n    function creditBalances(address _user) external view returns (uint256) {\r\n        return balanceOf(_user);\r\n    }\r\n\r\n\r\n    /***************************************\r\n                    INTEREST\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Deposit interest (add to savings) and update exchange rate of contract.\r\n     *      Exchange rate is calculated as the ratio between new savings q and credits:\r\n     *                    exchange rate = savings / credits\r\n     *\r\n     * @param _amount   Units of underlying to add to the savings vault\r\n     */\r\n    function depositInterest(uint256 _amount)\r\n        external\r\n        onlySavingsManager\r\n    {\r\n        require(_amount > 0, \"Must deposit something\");\r\n\r\n        // Transfer the interest from sender to here\r\n        require(underlying.transferFrom(msg.sender, address(this), _amount), \"Must receive tokens\");\r\n\r\n        // Calc new exchange rate, protect against initialisation case\r\n        uint256 totalCredits = totalSupply();\r\n        if(totalCredits > 0) {\r\n            // new exchange rate is relationship between _totalCredits & totalSavings\r\n            // _totalCredits * exchangeRate = totalSavings\r\n            // exchangeRate = totalSavings/_totalCredits\r\n            (uint256 totalCollat, ) = _creditsToUnderlying(totalCredits);\r\n            uint256 newExchangeRate = _calcExchangeRate(totalCollat.add(_amount), totalCredits);\r\n            exchangeRate = newExchangeRate;\r\n\r\n            emit ExchangeRateUpdated(newExchangeRate, _amount);\r\n        }\r\n    }\r\n\r\n    /** @dev Enable or disable the automation of fee collection during deposit process */\r\n    function automateInterestCollectionFlag(bool _enabled)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        automateInterestCollection = _enabled;\r\n        emit AutomaticInterestCollectionSwitched(_enabled);\r\n    }\r\n\r\n    /***************************************\r\n                    DEPOSIT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev During a migration period, allow savers to deposit underlying here before the interest has been redirected\r\n     * @param _underlying      Units of underlying to deposit into savings vault\r\n     * @param _beneficiary     Immediately transfer the imUSD token to this beneficiary address\r\n     * @return creditsIssued   Units of credits (imUSD) issued\r\n     */\r\n    function preDeposit(uint256 _underlying, address _beneficiary)\r\n        external\r\n        returns (uint256 creditsIssued)\r\n    {\r\n        require(exchangeRate == startingRate, \"Can only use this method before streaming begins\");\r\n        return _deposit(_underlying, _beneficiary, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit the senders savings to the vault, and credit them internally with \"credits\".\r\n     *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\r\n     *                    credits = underlying / exchangeRate\r\n     *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\r\n     * @param _underlying      Units of underlying to deposit into savings vault\r\n     * @return creditsIssued   Units of credits (imUSD) issued\r\n     */\r\n    function depositSavings(uint256 _underlying)\r\n        external\r\n        returns (uint256 creditsIssued)\r\n    {\r\n        return _deposit(_underlying, msg.sender, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit the senders savings to the vault, and credit them internally with \"credits\".\r\n     *      Credit amount is calculated as a ratio of deposit amount and exchange rate:\r\n     *                    credits = underlying / exchangeRate\r\n     *      We will first update the internal exchange rate by collecting any interest generated on the underlying.\r\n     * @param _underlying      Units of underlying to deposit into savings vault\r\n     * @param _beneficiary     Immediately transfer the imUSD token to this beneficiary address\r\n     * @return creditsIssued   Units of credits (imUSD) issued\r\n     */\r\n    function depositSavings(uint256 _underlying, address _beneficiary)\r\n        external\r\n        returns (uint256 creditsIssued)\r\n    {\r\n        return _deposit(_underlying, _beneficiary, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Internally deposit the _underlying from the sender and credit the beneficiary with new imUSD\r\n     */\r\n    function _deposit(uint256 _underlying, address _beneficiary, bool _collectInterest)\r\n        internal\r\n        returns (uint256 creditsIssued)\r\n    {\r\n        require(_underlying > 0, \"Must deposit something\");\r\n        require(_beneficiary != address(0), \"Invalid beneficiary address\");\r\n\r\n        // Collect recent interest generated by basket and update exchange rate\r\n        IERC20 mAsset = underlying;\r\n        if(_collectInterest){\r\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(mAsset));\r\n        }\r\n\r\n        // Transfer tokens from sender to here\r\n        require(mAsset.transferFrom(msg.sender, address(this), _underlying), \"Must receive tokens\");\r\n\r\n        // Calc how many credits they receive based on currentRatio\r\n        (creditsIssued,) = _underlyingToCredits(_underlying);\r\n\r\n        // add credits to ERC20 balances\r\n        _mint(_beneficiary, creditsIssued);\r\n\r\n        emit SavingsDeposited(_beneficiary, _underlying, creditsIssued);\r\n    }\r\n\r\n\r\n    /***************************************\r\n                    REDEEM\r\n    ****************************************/\r\n\r\n\r\n    // Deprecated in favour of redeemCredits\r\n    // Maintaining backwards compatibility, this fn minimics the old redeem fn, in which\r\n    // credits are redeemed but the interest from the underlying is not collected.\r\n    function redeem(uint256 _credits)\r\n        external\r\n        returns (uint256 massetReturned)\r\n    {\r\n        require(_credits > 0, \"Must withdraw something\");\r\n\r\n        (, uint256 payout) = _redeem(_credits, true);\r\n\r\n        // Collect recent interest generated by basket and update exchange rate\r\n        if(automateInterestCollection) {\r\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\r\n        }\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem specific number of the senders \"credits\" in exchange for underlying.\r\n     *      Payout amount is calculated as a ratio of credits and exchange rate:\r\n     *                    payout = credits * exchangeRate\r\n     * @param _credits         Amount of credits to redeem\r\n     * @return massetReturned  Units of underlying mAsset paid out\r\n     */\r\n    function redeemCredits(uint256 _credits)\r\n        external\r\n        returns (uint256 massetReturned)\r\n    {\r\n        require(_credits > 0, \"Must withdraw something\");\r\n\r\n        // Collect recent interest generated by basket and update exchange rate\r\n        if(automateInterestCollection) {\r\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\r\n        }\r\n\r\n        (, uint256 payout) = _redeem(_credits, true);\r\n\r\n        return payout;\r\n    }\r\n\r\n    /**\r\n     * @dev Redeem credits into a specific amount of underlying.\r\n     *      Credits needed to burn is calculated using:\r\n     *                    credits = underlying / exchangeRate\r\n     * @param _underlying     Amount of underlying to redeem\r\n     * @return creditsBurned  Units of credits burned from sender\r\n     */\r\n    function redeemUnderlying(uint256 _underlying)\r\n        external\r\n        returns (uint256 creditsBurned)\r\n    {\r\n        require(_underlying > 0, \"Must withdraw something\");\r\n\r\n        // Collect recent interest generated by basket and update exchange rate\r\n        if(automateInterestCollection) {\r\n            ISavingsManager(_savingsManager()).collectAndDistributeInterest(address(underlying));\r\n        }\r\n\r\n        // Ensure that the payout was sufficient\r\n        (uint256 credits, uint256 massetReturned) = _redeem(_underlying, false);\r\n        require(massetReturned == _underlying, \"Invalid output\");\r\n\r\n        return credits;\r\n    }\r\n\r\n    /**\r\n     * @dev Internally burn the credits and send the underlying to msg.sender\r\n     */\r\n    function _redeem(uint256 _amt, bool _isCreditAmt)\r\n        internal\r\n        returns (uint256 creditsBurned, uint256 massetReturned)\r\n    {\r\n        // Centralise credit <> underlying calcs and minimise SLOAD count\r\n        uint256 credits_;\r\n        uint256 underlying_;\r\n        uint256 exchangeRate_;\r\n        // If the input is a credit amt, then calculate underlying payout and cache the exchangeRate\r\n        if(_isCreditAmt){\r\n            credits_ = _amt;\r\n            (underlying_, exchangeRate_) = _creditsToUnderlying(_amt);\r\n        }\r\n        // If the input is in underlying, then calculate credits needed to burn\r\n        else {\r\n            underlying_ = _amt;\r\n            (credits_, exchangeRate_) = _underlyingToCredits(_amt);\r\n        }\r\n\r\n        // Burn required credits from the sender FIRST\r\n        _burn(msg.sender, credits_);\r\n\r\n        // Transfer tokens from here to sender\r\n        require(underlying.transfer(msg.sender, underlying_), \"Must send tokens\");\r\n\r\n        // If this withdrawal pushes the portion of stored collateral in the `connector` over a certain\r\n        // threshold (fraction + 20%), then this should trigger a _poke on the connector. This is to avoid\r\n        // a situation in which there is a rush on withdrawals for some reason, causing the connector\r\n        // balance to go up and thus having too large an exposure.\r\n        CachedData memory cachedData = _cacheData();\r\n        ConnectorStatus memory status = _getConnectorStatus(cachedData, exchangeRate_);\r\n        if(status.inConnector > status.limit){\r\n            _poke(cachedData, false);\r\n        }\r\n\r\n        emit CreditsRedeemed(msg.sender, credits_, underlying_);\r\n\r\n        return (credits_, underlying_);\r\n    }\r\n\r\n\r\n    struct ConnectorStatus {\r\n        // Limit is the max amount of units allowed in the connector\r\n        uint256 limit;\r\n        // Derived balance of the connector\r\n        uint256 inConnector;\r\n    }\r\n\r\n    /**\r\n     * @dev Derives the units of collateral held in the connector\r\n     * @param _data         Struct containing data on balances\r\n     * @param _exchangeRate Current system exchange rate\r\n     * @return status       Contains max amount of assets allowed in connector\r\n     */\r\n    function _getConnectorStatus(CachedData memory _data, uint256 _exchangeRate)\r\n        internal\r\n        pure\r\n        returns (ConnectorStatus memory)\r\n    {\r\n        // Total units of underlying collateralised\r\n        uint256 totalCollat = _data.totalCredits.mulTruncate(_exchangeRate);\r\n        // Max amount of underlying that can be held in the connector\r\n        uint256 limit = totalCollat.mulTruncate(_data.fraction.add(2e17));\r\n        // Derives amount of underlying present in the connector\r\n        uint256 inConnector = _data.rawBalance >= totalCollat ? 0 : totalCollat.sub(_data.rawBalance);\r\n\r\n        return ConnectorStatus(limit, inConnector);\r\n    }\r\n\r\n    /***************************************\r\n                    YIELD - E\r\n    ****************************************/\r\n\r\n\r\n    /** @dev Modifier allowing only the designated poker to execute the fn */\r\n    modifier onlyPoker() {\r\n        require(msg.sender == poker, \"Only poker can execute\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev External poke function allows for the redistribution of collateral between here and the\r\n     * current connector, setting the ratio back to the defined optimal.\r\n     */\r\n    function poke()\r\n        external\r\n        onlyPoker\r\n    {\r\n        CachedData memory cachedData = _cacheData();\r\n        _poke(cachedData, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Governance action to set the address of a new poker\r\n     * @param _newPoker     Address of the new poker\r\n     */\r\n    function setPoker(address _newPoker)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        require(_newPoker != address(0) && _newPoker != poker, \"Invalid poker\");\r\n\r\n        poker = _newPoker;\r\n\r\n        emit PokerUpdated(_newPoker);\r\n    }\r\n\r\n    /**\r\n     * @dev Governance action to set the percentage of assets that should be held\r\n     * in the connector.\r\n     * @param _fraction     Percentage of assets that should be held there (where 20% == 2e17)\r\n     */\r\n    function setFraction(uint256 _fraction)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        require(_fraction <= 5e17, \"Fraction must be <= 50%\");\r\n\r\n        fraction = _fraction;\r\n\r\n        CachedData memory cachedData = _cacheData();\r\n        _poke(cachedData, true);\r\n\r\n        emit FractionUpdated(_fraction);\r\n    }\r\n\r\n    /**\r\n     * @dev Governance action to set the address of a new connector, and move funds (if any) across.\r\n     * @param _newConnector     Address of the new connector\r\n     */\r\n    function setConnector(address _newConnector)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        // Withdraw all from previous by setting target = 0\r\n        CachedData memory cachedData = _cacheData();\r\n        cachedData.fraction = 0;\r\n        _poke(cachedData, true);\r\n\r\n        // Set new connector\r\n        CachedData memory cachedDataNew = _cacheData();\r\n        connector = IConnector(_newConnector);\r\n        _poke(cachedDataNew, true);\r\n\r\n        emit ConnectorUpdated(_newConnector);\r\n    }\r\n\r\n    /**\r\n     * @dev Governance action to perform an emergency withdraw of the assets in the connector,\r\n     * should it be the case that some or all of the liquidity is trapped in. This causes the total\r\n     * collateral in the system to go down, causing a hard refresh.\r\n     */\r\n    function emergencyWithdraw(uint256 _withdrawAmount)\r\n        external\r\n        onlyGovernor\r\n    {\r\n        // withdraw _withdrawAmount from connection\r\n        connector.withdraw(_withdrawAmount);\r\n\r\n        // reset the connector\r\n        connector = IConnector(address(0));\r\n        emit ConnectorUpdated(address(0));\r\n\r\n        // set fraction to 0\r\n        fraction = 0;\r\n        emit FractionUpdated(0);\r\n\r\n        // check total collateralisation of credits\r\n        CachedData memory data = _cacheData();\r\n        // use rawBalance as the remaining liquidity in the connector is now written off\r\n        _refreshExchangeRate(data.rawBalance, data.totalCredits, true);\r\n\r\n        emit EmergencyUpdate();\r\n    }\r\n\r\n\r\n    /***************************************\r\n                    YIELD - I\r\n    ****************************************/\r\n\r\n    /** @dev Internal poke function to keep the balance between connector and raw balance healthy */\r\n    function _poke(CachedData memory _data, bool _ignoreCadence) internal {\r\n        require(_data.totalCredits > 0, \"Must have something to poke\");\r\n\r\n        // 1. Verify that poke cadence is valid, unless this is a manual action by governance\r\n        uint256 currentTime = uint256(now);\r\n        uint256 timeSinceLastPoke = currentTime.sub(lastPoke);\r\n        require(_ignoreCadence || timeSinceLastPoke > POKE_CADENCE, \"Not enough time elapsed\");\r\n        lastPoke = currentTime;\r\n\r\n        // If there is a connector, check the balance and settle to the specified fraction %\r\n        IConnector connector_ = connector;\r\n        if(address(connector_) != address(0)){\r\n\r\n            // 2. Check and verify new connector balance\r\n            uint256 lastBalance_ = lastBalance;\r\n            uint256 connectorBalance = connector_.checkBalance();\r\n            //      Always expect the collateral in the connector to increase in value\r\n            require(connectorBalance >= lastBalance_, \"Invalid yield\");\r\n            if(connectorBalance > 0){\r\n                //  Validate the collection by ensuring that the APY is not ridiculous\r\n                _validateCollection(connectorBalance, connectorBalance.sub(lastBalance_), timeSinceLastPoke);\r\n            }\r\n\r\n            // 3. Level the assets to Fraction (connector) & 100-fraction (raw)\r\n            uint256 sum = _data.rawBalance.add(connectorBalance);\r\n            uint256 ideal = sum.mulTruncate(_data.fraction);\r\n            //     If there is not enough mAsset in the connector, then deposit\r\n            if(ideal > connectorBalance){\r\n                uint256 deposit = ideal.sub(connectorBalance);\r\n                underlying.approve(address(connector_), deposit);\r\n                connector_.deposit(deposit);\r\n            }\r\n            //     Else withdraw, if there is too much mAsset in the connector\r\n            else if(connectorBalance > ideal) {\r\n                // If fraction == 0, then withdraw everything\r\n                if(ideal == 0){\r\n                    connector_.withdrawAll();\r\n                    sum = IERC20(underlying).balanceOf(address(this));\r\n                } else {\r\n                    connector_.withdraw(connectorBalance.sub(ideal));\r\n                }\r\n            }\r\n            //     Else ideal == connectorBalance (e.g. 0), do nothing\r\n            require(connector_.checkBalance() >= ideal, \"Enforce system invariant\");\r\n\r\n            // 4i. Refresh exchange rate and emit event\r\n            lastBalance = ideal;\r\n            _refreshExchangeRate(sum, _data.totalCredits, false);\r\n            emit Poked(lastBalance_, ideal, connectorBalance.sub(lastBalance_));\r\n\r\n        } else {\r\n\r\n            // 4ii. Refresh exchange rate and emit event\r\n            lastBalance = 0;\r\n            _refreshExchangeRate(_data.rawBalance, _data.totalCredits, false);\r\n            emit PokedRaw();\r\n\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Internal fn to refresh the exchange rate, based on the sum of collateral and the number of credits\r\n     * @param _realSum          Sum of collateral held by the contract\r\n     * @param _totalCredits     Total number of credits in the system\r\n     * @param _ignoreValidation This is for use in the emergency situation, and ignores a decreasing exchangeRate\r\n     */\r\n    function _refreshExchangeRate(uint256 _realSum, uint256 _totalCredits, bool _ignoreValidation) internal {\r\n        // Based on the current exchange rate, how much underlying is collateralised?\r\n        (uint256 totalCredited, ) = _creditsToUnderlying(_totalCredits);\r\n\r\n        // Require the amount of capital held to be greater than the previously credited units\r\n        require(_ignoreValidation || _realSum >= totalCredited, \"ExchangeRate must increase\");\r\n        // Work out the new exchange rate based on the current capital\r\n        uint256 newExchangeRate = _calcExchangeRate(_realSum, _totalCredits);\r\n        exchangeRate = newExchangeRate;\r\n\r\n        emit ExchangeRateUpdated(newExchangeRate, _realSum > totalCredited ? _realSum.sub(totalCredited) : 0);\r\n    }\r\n\r\n    /**\r\n     * FORKED DIRECTLY FROM SAVINGSMANAGER.sol\r\n     * ---------------------------------------\r\n     * @dev Validates that an interest collection does not exceed a maximum APY. If last collection\r\n     * was under 30 mins ago, simply check it does not exceed 10bps\r\n     * @param _newBalance              New balance of the underlying\r\n     * @param _interest                Increase in total supply since last collection\r\n     * @param _timeSinceLastCollection Seconds since last collection\r\n     */\r\n    function _validateCollection(uint256 _newBalance, uint256 _interest, uint256 _timeSinceLastCollection)\r\n        internal\r\n        pure\r\n        returns (uint256 extrapolatedAPY)\r\n    {\r\n        // Protect against division by 0\r\n        uint256 protectedTime = StableMath.max(1, _timeSinceLastCollection);\r\n\r\n        uint256 oldSupply = _newBalance.sub(_interest);\r\n        uint256 percentageIncrease = _interest.divPrecisely(oldSupply);\r\n\r\n        uint256 yearsSinceLastCollection =\r\n            protectedTime.divPrecisely(SECONDS_IN_YEAR);\r\n\r\n        extrapolatedAPY = percentageIncrease.divPrecisely(yearsSinceLastCollection);\r\n\r\n        if(protectedTime > 30 minutes) {\r\n            require(extrapolatedAPY < MAX_APY, \"Interest protected from inflating past maxAPY\");\r\n        } else {\r\n            require(percentageIncrease < 1e15, \"Interest protected from inflating past 10 Bps\");\r\n        }\r\n    }\r\n\r\n\r\n    /***************************************\r\n                    VIEW - I\r\n    ****************************************/\r\n\r\n    struct CachedData {\r\n        // SLOAD from 'fraction'\r\n        uint256 fraction;\r\n        // ERC20 balance of underlying, held by this contract\r\n        // underlying.balanceOf(address(this))\r\n        uint256 rawBalance;\r\n        // totalSupply()\r\n        uint256 totalCredits;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves generic data to avoid duplicate SLOADs\r\n     */\r\n    function _cacheData() internal view returns (CachedData memory) {\r\n        uint256 balance = underlying.balanceOf(address(this));\r\n        return CachedData(fraction, balance, totalSupply());\r\n    }\r\n\r\n    /**\r\n     * @dev Converts masset amount into credits based on exchange rate\r\n     *               c = (masset / exchangeRate) + 1\r\n     */\r\n    function _underlyingToCredits(uint256 _underlying)\r\n        internal\r\n        view\r\n        returns (uint256 credits, uint256 exchangeRate_)\r\n    {\r\n        // e.g. (1e20 * 1e18) / 1e18 = 1e20\r\n        // e.g. (1e20 * 1e18) / 14e17 = 7.1429e19\r\n        // e.g. 1 * 1e18 / 1e17 + 1 = 11 => 11 * 1e17 / 1e18 = 1.1e18 / 1e18 = 1\r\n        exchangeRate_ = exchangeRate;\r\n        credits = _underlying.divPrecisely(exchangeRate_).add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Works out a new exchange rate, given an amount of collateral and total credits\r\n     *               e = underlying / (credits-1)\r\n     */\r\n    function _calcExchangeRate(uint256 _totalCollateral, uint256 _totalCredits)\r\n        internal\r\n        pure\r\n        returns (uint256 _exchangeRate)\r\n    {\r\n        _exchangeRate = _totalCollateral.divPrecisely(_totalCredits.sub(1));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts credit amount into masset based on exchange rate\r\n     *               m = credits * exchangeRate\r\n     */\r\n    function _creditsToUnderlying(uint256 _credits)\r\n        internal\r\n        view\r\n        returns (uint256 underlyingAmount, uint256 exchangeRate_)\r\n    {\r\n        // e.g. (1e20 * 1e18) / 1e18 = 1e20\r\n        // e.g. (1e20 * 14e17) / 1e18 = 1.4e20\r\n        exchangeRate_ = exchangeRate;\r\n        underlyingAmount = _credits.mulTruncate(exchangeRate_);\r\n    }\r\n}"
    }
  }
}