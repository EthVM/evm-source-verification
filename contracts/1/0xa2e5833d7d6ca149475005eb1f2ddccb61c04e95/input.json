{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"The Wealth Architect ECO Register.sol":{"content":"pragma solidity^0.6.0;\r\n  /*\r\n  * Equitable Builds Inc presents..\r\n  * ====================================*\r\n  *        _____ ___ _______ ______     *\r\n  *       |  _  |  ||  |  __|   __|     *\r\n  *       |     |  |  |  __|   |__      *\r\n  *       |__|__|_____|____|_____|      *\r\n  *                                     *\r\n  *        _____ __________ ______      *\r\n  *       |     |   | | | ||   __|      *\r\n  *       |  |  |     | | ||__   |      *\r\n  *       |_____|_|___|___||_____|      *\r\n  *                                     *\r\n  *        _____ ____________ ___       *\r\n  *       |     |  |  |   | ||  |       *\r\n  *       |  |  |  |  |     ||  |       *\r\n  *       |_____|_|_|_|_|___||__|       *\r\n  *                                     *\r\n  * ====================================*\r\n  */\r\n  contract AVEC{\r\n       /*=================================   \r\n       =            ERC20           =    \r\n       =================================*/\r\n      string public name = \"TheWealthArchitect\";\r\n      string public symbol = \"AVEC\";\r\n      uint8 public decimals = 18;\r\n      uint256 public totalSupply;\r\n      function allowance(address tokenOwner, address spender)\r\n          public\r\n          view returns (uint remaining) {\r\n              return GUsers[tokenOwner]._allowed[spender];\r\n      }\r\n      function balanceOf(address _UserAddress)\r\n          view\r\n          public\r\n          returns(uint256)\r\n      {\r\n          return GUsers[_UserAddress].PropertyAvecBalance[GUsers[_UserAddress].transferingPropertyid_];\r\n      }\r\n      function transfer(\r\n          address _toAddress, \r\n          uint256 _amountOfTokens)\r\n          public\r\n          returns(bool)\r\n      {\r\n          if(GUsers[msg.sender].Set != true){\r\n                  asetMyUser();\r\n          }\r\n          if(GUsers[msg.sender].transferType_ == 1){\r\n                  requireUserPrivilegeLevel(1, msg.sender);\r\n                  requireUserPrivilegeLevel(1, _toAddress);\r\n          } else {\r\n          uint256 _fee = divi(_amountOfTokens, 50);\r\n          uint256 _compare = addi(_amountOfTokens, _fee);\r\n          if(_compare < GUsers[msg.sender].PropertyAvecBalance[GUsers[msg.sender].transferingPropertyid_]\r\n          && GUsers[_toAddress].UserPrivilegeLevel >= 0){\r\n              updateRollingPropertyValueMember(msg.sender, GUsers[msg.sender].transferingPropertyid_);\r\n              updateRollingPropertyValueMember(_toAddress, GUsers[msg.sender].transferingPropertyid_);\r\n              GUsers[msg.sender].PropertyAvecBalance[GUsers[msg.sender].transferingPropertyid_]\r\n              -= _compare;\r\n               GUsers[msg.sender].amountCirculated_\r\n              += _compare;\r\n              GUsers[msg.sender].TokenBalanceLedgersTotal\r\n              -= _compare;\r\n              GUsers[_toAddress].TokenBalanceLedgersTotal\r\n              += _amountOfTokens;\r\n              GUsers[_toAddress].PropertyAvecBalance[GUsers[msg.sender].transferingPropertyid_]\r\n              += _amountOfTokens;\r\n              updateEquityRents(_amountOfTokens);\r\n              GUsers[msg.sender].transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n              emit Transfer(msg.sender, _toAddress, _compare);\r\n              return true;\r\n          } else {\r\n              revert();\r\n          }\r\n      }  } \r\n      function transferFrom(\r\n          address from, \r\n          address to, \r\n          uint256 tokens)\r\n          public\r\n          returns(bool)\r\n      {\r\n          if(GUsers[msg.sender].Set != true){\r\n                  asetMyUser();\r\n              }\r\n          if(GUsers[msg.sender].transferType_ == 1){\r\n                  requireUserPrivilegeLevel(1, msg.sender);\r\n                  requireUserPrivilegeLevel(1, to);\r\n          }\r\n          bytes32 _propertyUniqueID\r\n          = GUsers[from].transferingPropertyid_;\r\n          uint256 _propertyBalanceLedger\r\n          = GUsers[from].PropertyAvecBalance[_propertyUniqueID];\r\n          uint256 _Lvalue\r\n          = addi(tokens, divi(tokens, 50));\r\n          if(_propertyBalanceLedger >= _Lvalue\r\n          && GUsers[to].UserPrivilegeLevel >= 0\r\n          && tokens > 0\r\n          &&from != to\r\n          && _Lvalue <= GUsers[from]._allowed[msg.sender]\r\n          && msg.sender != from){\r\n              updateRollingPropertyValueMember(from, _propertyUniqueID);\r\n              updateRollingPropertyValueMember(to, _propertyUniqueID);\r\n              // setup\r\n              updateEquityRents(tokens);\r\n              GUsers[to].TokenBalanceLedgersTotal\r\n              += tokens;\r\n              GUsers[from].TokenBalanceLedgersTotal\r\n              -= _Lvalue;\r\n              //Reduce Approval Amount\r\n              GUsers[from]._allowed[msg.sender]\r\n              -= tokens;\r\n              GUsers[from].amountCirculated_\r\n              += _Lvalue;\r\n              GUsers[from].PropertyAvecBalance[_propertyUniqueID]\r\n              -= _Lvalue;\r\n              GUsers[to].PropertyAvecBalance[_propertyUniqueID]\r\n              += tokens;\r\n              GUsers[msg.sender].transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n              emit Transfer(from, to, _Lvalue);\r\n              return true;\r\n          } else {\r\n              revert();\r\n          }\r\n      }\r\n      function approve(\r\n          address spender, \r\n          uint256 value)\r\n          public\r\n          returns (bool) {\r\n              requireUserPrivilegeLevel(0, msg.sender);\r\n              if(spender != address(0)){\r\n                  GUsers[msg.sender]._allowed[spender]\r\n                  = value;\r\n                  emit Approval(msg.sender, spender, value);\r\n                  return true;\r\n              } else {\r\n                  revert();\r\n              }\r\n      }\r\n      /*=================================\r\n      =            Structs            =\r\n      =================================*/\r\n      \r\n      struct PropertyEscrow {\r\n          bytes32 PropertyID;\r\n          address payable recipientOfFunds;\r\n          bytes32 recipientName;\r\n          uint8 escrowAgreementNumber;\r\n          bool escrowCompleted;\r\n          uint256 milestonePriceOfEscrowInETH;\r\n          uint256 tokensAvailableTotal;\r\n          uint256 tokensAvailableCurrent;\r\n          uint256 totalETHReceived;\r\n          uint256 ethPerToken;\r\n          uint256 propertyIncrease;\r\n          mapping(address => uint256) AgreementAmountDueInTokens;\r\n      }\r\n      struct TotalHolds {\r\n          mapping(uint8 => uint48) feeHoldsTotalByEnvelope;\r\n      }\r\n      struct FeeWallet {\r\n          bytes32  feeWalletSecretID;\r\n          address  whoaaddress;\r\n          address  whoamaintenanceaddress;\r\n          address  whoarewardsaddress;\r\n          address  cevaaddress;\r\n          address  credibleyouaddress;\r\n          address  techaddress;\r\n          address  existholdingsaddress;\r\n          address  existcryptoaddress;\r\n      }\r\n      struct Property {\r\n          bool Set;\r\n          address Ceva;\r\n          address FounderDeveloper;\r\n          address Owner;\r\n          address holdOne;\r\n          address holdTwo;\r\n          address holdThree;\r\n          uint256 Value;\r\n          uint256 NumberOfTokensToEscrow;\r\n          bytes32 PropertyID;\r\n          uint256 propertyGlobalBalance_;\r\n          uint256 propertyPriceUpdateCountAsset_;\r\n          uint256 lastMintingPrice_;\r\n          mapping(address => uint256) propertyLastKnownValue_;\r\n          uint8[] escrowAgreementNumber;\r\n          uint8 currentEscrowAgreementNumber;\r\n          bool firstEscrowSet;\r\n      }\r\n      struct User {\r\n          bool Set;\r\n          address UserAddress;\r\n          address Ceva;\r\n          address FounderDeveloperTwo;\r\n          address FounderDeveloperOne;\r\n          uint8 UserPrivilegeLevel;\r\n          bytes32 workingPropertyid_;\r\n          bytes32 transferingPropertyid_;\r\n          bytes32 workingMintRequestid_;\r\n          bytes32 workingBurnRequestid_;\r\n          bool approvedByCevaForFD_;\r\n          uint256 TokenBalanceLedgersTotal;\r\n          bytes32[] Properties;\r\n          mapping(bytes32 => uint256) PropertyAvecBalance;\r\n          mapping(address => mapping(bytes32 => uint256)) propertyPriceUpdateCountMember_;\r\n          uint256 mintingDepositsOf_;\r\n          uint256 amountCirculated_;\r\n          mapping(address => uint256) _allowed;\r\n          mapping(bytes32 => bool) burnrequestwhitelist_;\r\n          mapping(bytes32 => uint256) propertyvalueOld_;\r\n          mapping(uint8 => uint256) FeesTotalWithdrawnByEnvelope_;\r\n          mapping(uint8 => uint256) FeesPreviousWithdrawnByEnvelope_;\r\n          mapping(uint8 => uint256) FeeShareholdByEnvelope_;\r\n          mapping(bytes32 => uint8) lastknownPropertyEscrowAgreementNumber;\r\n          uint8 transferType_;\r\n      }\r\n      /*==============================\r\n      =            EVENTS            =\r\n      ==============================*/\r\n      event AVECtoONUS(\r\n          address indexed MemberAddress,\r\n          uint256 tokensConverted,\r\n          bytes32 indexed PropertyID\r\n      );\r\n      event ONUStoAVEC(\r\n          address indexed MemberAddress,\r\n          uint256 tokensConverted,\r\n          bytes32 indexed PropertyID\r\n      );\r\n      event OnWithdraw(\r\n          address indexed MemberAddress,\r\n          uint256 tokensWithdrawn,\r\n          uint8 indexed envelopeNumber\r\n      );\r\n      event Transfer(\r\n          address indexed from,\r\n          address indexed to,\r\n          uint256 value\r\n      );\r\n      event Burn(\r\n          address indexed from,\r\n          uint256 tokens,\r\n          uint256 propertyValue\r\n      );\r\n      event Approval(\r\n          address indexed _UserAddress,\r\n          address indexed _spender,\r\n          uint256 _Lvalue\r\n      );\r\n      event PropertyValuation(\r\n          address indexed from,\r\n          bytes32 indexed _propertyUniqueID,\r\n          uint256 propertyValue\r\n      );\r\n      event ContributionMade(\r\n          address indexed contributor, \r\n          uint256 amount, \r\n          bytes32 indexed PropertyID, \r\n          uint8 indexed escrowNumber, \r\n          bool fundingComplete\r\n      );  \r\n      event UserSet(\r\n          address indexed User\r\n      );\r\n      event LicensePurchase(\r\n          address indexed User,\r\n          address indexed CEVA,\r\n          address indexed FDone,\r\n          address FDTwo\r\n      );\r\n      event AVECMinted(\r\n          address indexed CEVA,\r\n          address indexed FD,\r\n          address indexed USER,\r\n          uint256 Amount,\r\n          uint256 AmountEscrowed\r\n      );\r\n      event EscrowCreated(\r\n          address indexed CEVA,\r\n          address indexed Recipient,\r\n          bytes32 REcipientName,\r\n          uint256 MilestoneETH,\r\n          uint256 TokensAVAILABLE,\r\n          bytes32 indexed PropertyID,\r\n          uint8 EscrowAgreementNumber\r\n      );\r\n      event PropertySet(\r\n          bool Set,\r\n          bytes32 indexed PropertyID,\r\n          address indexed CEVA,\r\n          address FDOne,\r\n          address OWNER,\r\n          uint256 indexed Value\r\n      );\r\n      event AVECWithdrawnFromEscrow(\r\n          address indexed User,\r\n          uint256 amount,\r\n          bytes32 indexed PropertyID\r\n      );\r\n      event FeeShareholdSOLD(\r\n          address indexed Seller,\r\n          address indexed Buyer,\r\n          uint256 amount\r\n      );\r\n      event ValueUpdate(\r\n          address indexed User,\r\n          bytes32 indexed PropertyID,\r\n          uint256 Before,\r\n          uint256 indexed After\r\n      );\r\n      /*=================================\r\n      =            Mapping              =\r\n      =================================*/\r\n      mapping(address => TotalHolds) private LatestTotalHolds;\r\n      mapping(bytes32 => FeeWallet) private GFeeWallets;\r\n      mapping(bytes32 => Property) Properties;\r\n      mapping(address => User) GUsers;\r\n      mapping(address => uint256) amountDueInTokens;\r\n      mapping(bytes32 => mapping(uint8 => PropertyEscrow)) private GEscrowAgreements;\r\n      /*=================================\r\n      =            bytes32              =\r\n      =================================*/\r\n      bytes32 private GfeeWalletSecretID_;\r\n      bytes32[] private GListFeeWalletSecretIDs;\r\n      bytes32[] propertyIDs;\r\n      /*=================================\r\n      =            address              =\r\n      =================================*/\r\n      address[] userAccounts;\r\n     /*================================\r\n      =            uint               =\r\n      ================================*/\r\n      uint256 ETHERTOTALRECEIVED;\r\n      uint256 ETHERESCROWED;\r\n      uint256 ETHERTOTALWITHDRAWN;\r\n      /*================================\r\n      =            bool               =\r\n      ================================*/\r\n      bool internal adminset_ = false;\r\n       /*=================================\r\n      =          pure function          =\r\n      =================================*/\r\n      function agetbytes32ToString(bytes32 _bytes32)\r\n          public\r\n          pure\r\n          returns (string memory) {\r\n              uint8 i = 0;\r\n              while(i < 32 && _bytes32[i] != 0) {\r\n                  i++;\r\n              }\r\n              bytes memory bytesArray = new bytes(i);\r\n              for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n                  bytesArray[i] = _bytes32[i];\r\n              }\r\n              return string(bytesArray);\r\n      }\r\n      function agetstringToBytes32(string memory source)\r\n          pure\r\n          public\r\n          returns (bytes32 result) {\r\n          bytes memory tempEmptyStringTest = bytes(source);\r\n          if (tempEmptyStringTest.length == 0) {\r\n              return 0x0;\r\n          }\r\n          assembly {\r\n              result := mload(add(source, 32))\r\n          }\r\n      }\r\n      function mult(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n      }\r\n      function divi(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n      }\r\n      function subt(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n      }\r\n      function addi(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n      }\r\n      /*=================================\r\n      =        admin  functions         =\r\n      =================================*/\r\n      function setFeeWalletSecret(bytes32 secret) public{\r\n          requireUserPrivilegeLevel(4, msg.sender);\r\n          GfeeWalletSecretID_ = secret;\r\n      }\r\n      function asetFeeWallet(\r\n          bytes32 _LfeeWalletSecretID,\r\n          address _whoaaddress,\r\n          address _whoamaintenanceaddress,\r\n          address _whoarewardsaddress,\r\n          address _cevaaddress,\r\n          address _credibleyouaddress,\r\n          address _techaddress,\r\n          address _existholdingsaddress,\r\n          address _existcryptoaddress) public {\r\n              requireUserPrivilegeLevel(4, msg.sender);\r\n              AVEC.FeeWallet storage feeWallet = GFeeWallets[_LfeeWalletSecretID];\r\n                  if(_whoaaddress == address(0x0)  || _whoamaintenanceaddress == address(0x0) || _whoarewardsaddress == address(0x0) || _cevaaddress == address(0x0) \r\n                  || _credibleyouaddress == address(0x0) || _techaddress == address(0x0) || _existholdingsaddress == address(0x0) || _existcryptoaddress == address(0x0)) {\r\n                      revert();\r\n                  } else {\r\n                      feeWallet.feeWalletSecretID = _LfeeWalletSecretID;\r\n                      feeWallet.whoaaddress = _whoaaddress;\r\n                      feeWallet.whoamaintenanceaddress = _whoamaintenanceaddress;\r\n                      feeWallet.whoarewardsaddress = _whoarewardsaddress;\r\n                      feeWallet.cevaaddress = _cevaaddress;\r\n                      feeWallet.credibleyouaddress = _credibleyouaddress;\r\n                      feeWallet.techaddress = _techaddress;\r\n                      feeWallet.existholdingsaddress = _existholdingsaddress;\r\n                      feeWallet.existcryptoaddress = _existcryptoaddress;\r\n                      Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Owner \r\n                      = _whoaaddress;\r\n                  }\r\n      }\r\n      function agetFeeWallet(bytes32 _LfeeWalletSecretID) view public returns (\r\n          bytes32,\r\n          address,\r\n          address,\r\n          address,\r\n          address,\r\n          address,\r\n          address,\r\n          address,\r\n          address) {\r\n              requireUserPrivilegeLevel(4, msg.sender);\r\n              bytes32 thefeeWalletSecretID = _LfeeWalletSecretID;\r\n              return (\r\n                  GFeeWallets[thefeeWalletSecretID].feeWalletSecretID,\r\n                  GFeeWallets[thefeeWalletSecretID].whoaaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].whoamaintenanceaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].whoarewardsaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].cevaaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].credibleyouaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].techaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].existholdingsaddress,\r\n                  GFeeWallets[thefeeWalletSecretID].existcryptoaddress\r\n              );\r\n      }\r\n      function withdrawEther(uint256 amount)\r\n          public\r\n          returns(bytes memory){\r\n              requireUserPrivilegeLevel(4, msg.sender);\r\n              uint256 etherAvailableAboveEscrow = subt(ETHERTOTALRECEIVED, ETHERESCROWED);\r\n              uint256 etherAvailableAboveWithdrawn = subt(etherAvailableAboveEscrow, ETHERTOTALWITHDRAWN);\r\n              if(address(this).balance > 0\r\n              && ETHERTOTALRECEIVED > ETHERESCROWED\r\n              && etherAvailableAboveEscrow  > ETHERTOTALWITHDRAWN\r\n              && etherAvailableAboveWithdrawn > 0){\r\n                   (bool success, bytes memory tf) = msg.sender.call{value: amount}(\"\");\r\n                   if (success != true){\r\n                      revert();\r\n                   }\r\n                   ETHERTOTALWITHDRAWN += amount;\r\n                   return (tf);\r\n              } else {\r\n                  revert();\r\n              }\r\n      }\r\n      /*=================================\r\n      =        CEVA  functions         =\r\n      =================================*/\r\n      function approveMemberForFD(bool _approve, address _UserAddress)\r\n          public{\r\n          requireUserPrivilegeLevel(3, msg.sender);\r\n          GUsers[_UserAddress].approvedByCevaForFD_ = _approve;\r\n      }\r\n      function adjustPropertyValue(\r\n          uint256 _propertyValue)\r\n          public\r\n          returns(uint256, uint8)\r\n      {\r\n          requireUserPrivilegeLevel(3, msg.sender);\r\n          if(Properties[GUsers[msg.sender].workingPropertyid_].Set = true\r\n          && _propertyValue >= 0\r\n          && GUsers[msg.sender].workingPropertyid_ != 0x676c6f62616c0000000000000000000000000000000000000000000000000000){\r\n              if(Properties[GUsers[msg.sender].workingPropertyid_].Owner != msg.sender){\r\n                  GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].propertyvalueOld_[GUsers[msg.sender].workingPropertyid_]\r\n                  = Properties[GUsers[msg.sender].workingPropertyid_].Value;\r\n                  if(Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].propertyPriceUpdateCountAsset_ == 0){\r\n                      Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Value\r\n                      = _propertyValue;\r\n                  } else if(Properties[GUsers[msg.sender].workingPropertyid_].propertyGlobalBalance_ >= 1e18){\r\n                      Properties[GUsers[msg.sender].workingPropertyid_].Value\r\n                      = _propertyValue;\r\n                      uint256 _LCalculate\r\n                      = divi(mult(divi(mult(GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].propertyvalueOld_[GUsers[msg.sender].workingPropertyid_], 1e18), 100), 1000000), Properties[GUsers[msg.sender].workingPropertyid_].propertyGlobalBalance_);\r\n                      uint256 _SecondCalculate\r\n                      = divi(mult(divi(mult( Properties[GUsers[msg.sender].workingPropertyid_].Value, 1e18), 100), 1000000), _LCalculate);\r\n                      uint256 _propertyGlobalBalanceOld\r\n                      = Properties[GUsers[msg.sender].workingPropertyid_].propertyGlobalBalance_ ;\r\n                      Properties[GUsers[msg.sender].workingPropertyid_].propertyGlobalBalance_\r\n                      = _SecondCalculate;\r\n                      Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Value\r\n                      = subt(addi(Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Value, divi(mult(Properties[GUsers[msg.sender].workingPropertyid_].propertyGlobalBalance_, 100), 1e18))\r\n                      , divi(mult(_propertyGlobalBalanceOld, 100), 1e18));\r\n                  }\r\n                  Properties[GUsers[msg.sender].workingPropertyid_].lastMintingPrice_\r\n                  = _propertyValue;\r\n                  Properties[GUsers[msg.sender].workingPropertyid_].Value\r\n                  = _propertyValue;\r\n                  uint256 _pValue\r\n                  = Properties[GUsers[msg.sender].workingPropertyid_].Value;\r\n                  uint256 _pValueOld\r\n                  = GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].propertyvalueOld_[GUsers[msg.sender].workingPropertyid_];\r\n                  Properties[GUsers[msg.sender].workingPropertyid_].Value\r\n                  = subt(addi(_pValue, _propertyValue), _pValueOld);\r\n                  Properties[GUsers[msg.sender].workingPropertyid_].propertyPriceUpdateCountAsset_\r\n                  += 1;\r\n                  Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].propertyPriceUpdateCountAsset_\r\n                  += 1;\r\n                  if(Properties[GUsers[msg.sender].workingPropertyid_].propertyPriceUpdateCountAsset_ >= 1){\r\n                      totalSupply\r\n                      = subt(addi(totalSupply, divi(mult(Properties[GUsers[msg.sender].workingPropertyid_].Value, 1e18), 100)), divi(mult(GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].propertyvalueOld_[GUsers[msg.sender].workingPropertyid_], 1e18), 100));\r\n                  }\r\n                  emit PropertyValuation(msg.sender, GUsers[msg.sender].workingPropertyid_, Properties[GUsers[msg.sender].workingPropertyid_].Value);\r\n              } else {\r\n                  revert();\r\n              }\r\n          }\r\n      }\r\n      function asetProperty(\r\n          bool _Set,\r\n          address _FounderDeveloper,\r\n          address _Owner,\r\n          address _holdOne,\r\n          address _holdTwo,\r\n          address _holdThree,\r\n          uint256 _Value,\r\n          uint256 _NumberOfTokensToEscrow,\r\n          bytes32 _PropertyID\r\n          ) public {\r\n              requireUserPrivilegeLevel(3, msg.sender);\r\n              if(Properties[_PropertyID].Set == true){\r\n                  Properties[_PropertyID].Set = _Set;\r\n                  Properties[_PropertyID].Ceva = msg.sender;\r\n                  Properties[_PropertyID].FounderDeveloper = _FounderDeveloper;\r\n                  Properties[_PropertyID].Owner = _Owner;\r\n                  Properties[_PropertyID].holdOne = _holdOne;\r\n                  Properties[_PropertyID].holdTwo = _holdTwo;\r\n                  Properties[_PropertyID].holdThree = _holdThree;\r\n                  Properties[_PropertyID].Value = _Value;\r\n                  Properties[_PropertyID].NumberOfTokensToEscrow = _NumberOfTokensToEscrow;\r\n              } else {\r\n              AVEC.Property storage property = Properties[_PropertyID];\r\n              property.Set = _Set;\r\n              property.Ceva = msg.sender;\r\n              property.FounderDeveloper = _FounderDeveloper;\r\n              property.Owner = _Owner;\r\n              property.holdOne = _holdOne;\r\n              property.holdTwo = _holdTwo;\r\n              property.holdThree = _holdThree;\r\n              property.Value = _Value;\r\n              property.NumberOfTokensToEscrow = _NumberOfTokensToEscrow;\r\n              property.PropertyID = _PropertyID;\r\n              GUsers[_FounderDeveloper].workingMintRequestid_\r\n              = _PropertyID;\r\n              GUsers[_FounderDeveloper].workingPropertyid_\r\n              = _PropertyID;\r\n              GUsers[_FounderDeveloper].workingBurnRequestid_ = _PropertyID;\r\n              GUsers[_Owner].burnrequestwhitelist_[_PropertyID]\r\n              = _Set;\r\n              propertyIDs.push(_PropertyID);\r\n              bytes32 wpIDTemp = GUsers[msg.sender].workingPropertyid_;\r\n              GUsers[msg.sender].workingPropertyid_ = _PropertyID;\r\n              adjustPropertyValue(_Value);\r\n              GUsers[msg.sender].workingPropertyid_ = wpIDTemp;\r\n              emit PropertySet(_Set, _PropertyID, GUsers[_Owner].Ceva, _FounderDeveloper, _Owner, _Value);\r\n          }\r\n      }\r\n      function createEscrowForProperty(\r\n          bytes32 _PropertyID, \r\n          address payable _recipientOfFunds, \r\n          bytes32 _recipientName, \r\n          uint8 _escrowAgreementNumber,\r\n          bool _override,\r\n          bool _escrowCompleted,\r\n          uint256 _milestonePriceOfEscrowInETH, \r\n          uint256 _tokensAvailableTotal,\r\n          uint256 _propertyIncrease\r\n          )\r\n          public {\r\n              requireUserPrivilegeLevel(3, msg.sender);\r\n              uint8 _localEscrowAgreementNumber;\r\n              if(Properties[_PropertyID].firstEscrowSet != true){\r\n                  _localEscrowAgreementNumber = 0;\r\n                  Properties[_PropertyID].currentEscrowAgreementNumber = 0;\r\n                  Properties[_PropertyID].firstEscrowSet = true;\r\n              } else {\r\n                  _localEscrowAgreementNumber = uint8(Properties[_PropertyID].currentEscrowAgreementNumber + 1); \r\n              }\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].PropertyID = _PropertyID;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientOfFunds = _recipientOfFunds;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].recipientName = _recipientName;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH = _milestonePriceOfEscrowInETH;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableTotal = _tokensAvailableTotal;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].tokensAvailableCurrent = _tokensAvailableTotal;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].ethPerToken = divi(_milestonePriceOfEscrowInETH, _tokensAvailableTotal);\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowCompleted = _escrowCompleted;\r\n              GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].propertyIncrease = _propertyIncrease;\r\n              ETHERESCROWED += GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].milestonePriceOfEscrowInETH;\r\n              if(_override == true){\r\n                 GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _escrowAgreementNumber; \r\n              } else {\r\n                  GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber = _localEscrowAgreementNumber;\r\n              }\r\n              Properties[_PropertyID].escrowAgreementNumber.push(GEscrowAgreements[_PropertyID][_localEscrowAgreementNumber].escrowAgreementNumber);\r\n              bytes32 prop = _PropertyID;\r\n              emit EscrowCreated(msg.sender, _recipientOfFunds,  _recipientName, _milestonePriceOfEscrowInETH, _tokensAvailableTotal, prop, _localEscrowAgreementNumber);\r\n      }\r\n      function aCEVASetWorkingPropertyID(\r\n          bytes32 _PropertyID)\r\n          public{\r\n              requireUserPrivilegeLevel(3, msg.sender);\r\n              GUsers[msg.sender].workingPropertyid_ = _PropertyID;\r\n          }\r\n      function aBurnProperty(\r\n          uint256 _propertyValue, \r\n          address _clearFrom)\r\n              public\r\n              returns(bool)\r\n          {\r\n              requireUserPrivilegeLevel(3, msg.sender);\r\n              uint256 _amountOfTokens = divi(mult(_propertyValue, 1e18), 100);\r\n              uint256 _difference = subt(_amountOfTokens, GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].PropertyAvecBalance[GUsers[msg.sender].workingPropertyid_]);\r\n              if(GUsers[msg.sender].workingPropertyid_ != 0x676c6f62616c0000000000000000000000000000000000000000000000000000\r\n              && GUsers[_clearFrom].burnrequestwhitelist_[GUsers[msg.sender].transferingPropertyid_] == true\r\n              && Properties[GUsers[msg.sender].workingPropertyid_].Set == true\r\n              && _difference <= GUsers[GFeeWallets[GfeeWalletSecretID_].whoaaddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n              && _amountOfTokens >= 0){\r\n                  //Burn Tokens\r\n                  totalSupply\r\n                  -= _amountOfTokens;\r\n                  // take tokens out of stockpile\r\n                  //Exchange tokens\r\n                  Properties[GUsers[msg.sender].workingPropertyid_].Value\r\n                  = 0;\r\n                  Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Value\r\n                  -= divi(mult(Properties[GUsers[msg.sender].workingPropertyid_].propertyGlobalBalance_, 100), 1e18);\r\n                  GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].TokenBalanceLedgersTotal\r\n                  -= GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].PropertyAvecBalance[GUsers[msg.sender].workingPropertyid_];\r\n                  GUsers[GFeeWallets[GfeeWalletSecretID_].whoaaddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  -= subt(_amountOfTokens, GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].PropertyAvecBalance[GUsers[msg.sender].workingPropertyid_]);\r\n                  GUsers[Properties[GUsers[msg.sender].workingPropertyid_].Owner].PropertyAvecBalance[GUsers[msg.sender].workingPropertyid_]\r\n                  = 0;\r\n                  // returns bool true\r\n                  emit Burn(msg.sender, _amountOfTokens, _propertyValue);\r\n                  return true;\r\n              } else {\r\n                  revert();\r\n              }\r\n      }\r\n      /*=================================\r\n      =   FounderDev only function     =\r\n      =================================*/\r\n      function afounderDeveloperMintAVEC(\r\n          uint256 _founderDeveloperFee)\r\n              public\r\n          {\r\n              address _toAddress = Properties[GUsers[msg.sender].workingPropertyid_].Owner;\r\n              address _holdOne = Properties[GUsers[msg.sender].workingPropertyid_].holdOne;\r\n              address _holdTwo = Properties[GUsers[msg.sender].workingPropertyid_].holdTwo;\r\n              address _holdThree = Properties[GUsers[msg.sender].workingPropertyid_].holdThree;\r\n              uint256 _propertyValue = Properties[GUsers[msg.sender].workingPropertyid_].Value;\r\n              uint256 _numberOfSingleTokensToEscrow = Properties[GUsers[msg.sender].workingPropertyid_].NumberOfTokensToEscrow;\r\n              address _commissionFounderDeveloper = GUsers[_toAddress].FounderDeveloperOne;\r\n              bytes32 _propertyUniqueID = GUsers[msg.sender].workingPropertyid_;\r\n              bytes32 _mintingRequestUniqueid = GUsers[msg.sender].workingMintRequestid_;\r\n              uint256 _amountOfTokens\r\n              = divi(mult(_propertyValue, 1e18), 100);\r\n              if(_propertyValue == Properties[_propertyUniqueID].Value \r\n              && GUsers[_toAddress].UserPrivilegeLevel >= 1\r\n              && GUsers[msg.sender].UserPrivilegeLevel >= 2\r\n              && _founderDeveloperFee >= 20001\r\n              && _founderDeveloperFee <= 100000\r\n              && msg.sender != _toAddress\r\n              && _propertyUniqueID == GUsers[msg.sender].workingPropertyid_\r\n              && _mintingRequestUniqueid == GUsers[msg.sender].workingMintRequestid_){\r\n                  updateHoldsandSupply(_amountOfTokens);\r\n                  GUsers[_commissionFounderDeveloper].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  += divi(mult(_amountOfTokens, 1000), _founderDeveloperFee);\r\n                  GUsers[_commissionFounderDeveloper].TokenBalanceLedgersTotal\r\n                  = addi(GUsers[_commissionFounderDeveloper].TokenBalanceLedgersTotal, divi(mult(_amountOfTokens, 1000), _founderDeveloperFee));\r\n                  creditFeeSharehold(_amountOfTokens, _toAddress, _holdOne, _holdTwo, _holdThree);\r\n                  uint256 _techFee\r\n                  = divi(mult(_amountOfTokens, 100), 25000);\r\n                  GUsers[GFeeWallets[GfeeWalletSecretID_].techaddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  += _techFee;\r\n                  Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Value\r\n                  += divi(mult(_amountOfTokens, 100000000000), 1111234581620);\r\n                  GUsers[GFeeWallets[GfeeWalletSecretID_].techaddress].TokenBalanceLedgersTotal\r\n                  = addi(GUsers[GFeeWallets[GfeeWalletSecretID_].techaddress].TokenBalanceLedgersTotal, _techFee);\r\n                  uint256 _founderDeveloperFeeStacked = _founderDeveloperFee;\r\n                  uint256 _amountOfTokensStacked = _amountOfTokens;\r\n                  uint256 _escrowTokensStacked = _numberOfSingleTokensToEscrow *1e18;\r\n                  address _toAddressStacked = _toAddress;\r\n                  uint256 _whoaFees\r\n                  = divi(mult(_amountOfTokens, 100000000000000), 2500000000000625);\r\n                  uint256 _fee\r\n                  = divi(mult(_amountOfTokens, mult(1000, 100000)), mult(_founderDeveloperFeeStacked, 100000));\r\n                  GUsers[_toAddressStacked].TokenBalanceLedgersTotal\r\n                  = addi(GUsers[_toAddressStacked].TokenBalanceLedgersTotal, subt(subt(subt(_amountOfTokensStacked, _whoaFees), _fee), _escrowTokensStacked));\r\n                  GUsers[_toAddressStacked].mintingDepositsOf_\r\n                  += subt(subt(subt(_amountOfTokensStacked, _whoaFees), _fee), _escrowTokensStacked);\r\n                  GUsers[_toAddressStacked].PropertyAvecBalance[_propertyUniqueID]\r\n                  += subt(subt(subt(_amountOfTokensStacked, _whoaFees), _fee), _escrowTokensStacked);\r\n                  Properties[_propertyUniqueID].propertyGlobalBalance_\r\n                  += addi(_whoaFees, _fee);\r\n                  GUsers[GFeeWallets[GfeeWalletSecretID_].whoaaddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  += subt(_whoaFees, _techFee);\r\n                  GUsers[GFeeWallets[GfeeWalletSecretID_].whoaaddress].TokenBalanceLedgersTotal\r\n                  += subt(_whoaFees, _techFee);\r\n                  updateRollingPropertyValueMember(_toAddressStacked, _propertyUniqueID);\r\n                  updateRollingPropertyValueMember(GUsers[_toAddressStacked].FounderDeveloperOne, _propertyUniqueID);\r\n                  updateRollingPropertyValueMember(GUsers[_toAddressStacked].FounderDeveloperTwo, _propertyUniqueID);\r\n                  GUsers[_toAddressStacked].Properties.push(_propertyUniqueID);\r\n                  emit AVECMinted(GUsers[_toAddressStacked].Ceva, _commissionFounderDeveloper,  _toAddressStacked, _amountOfTokens, _escrowTokensStacked);\r\n              } else {\r\n                  revert();\r\n              }\r\n      }\r\n      /*=================================\r\n      =   Member only function         =\r\n      =================================*/\r\n      /**\r\n       * Convert AVEC into ONUS\r\n       */\r\n      function amemberConvert(\r\n          uint8 oneAVECtwoONUS, \r\n          uint256 tokens, \r\n          bytes32 _PropertyID)\r\n          public\r\n      {\r\n          if( oneAVECtwoONUS == 1){\r\n              requireUserPrivilegeLevel(1, msg.sender);\r\n              bytes32 _propertyUniqueID\r\n              = _PropertyID;\r\n              uint256 _propertyBalanceLedger\r\n              = GUsers[msg.sender].PropertyAvecBalance[_propertyUniqueID];\r\n              uint256 _Lvalue\r\n              = tokens;\r\n              updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n              if(_propertyBalanceLedger >= _Lvalue\r\n              && GUsers[msg.sender].UserPrivilegeLevel == 1\r\n              && tokens > 0){\r\n                  uint256 LcValue;\r\n                  LcValue = divi(mult(Properties[_propertyUniqueID].Value, 1e18), 100);\r\n                  GUsers[msg.sender].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  += tokens;\r\n                  GUsers[msg.sender].PropertyAvecBalance[_propertyUniqueID]\r\n                  -= tokens;\r\n                  Properties[_propertyUniqueID].propertyGlobalBalance_\r\n                  += tokens;\r\n                  Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].propertyLastKnownValue_[msg.sender]\r\n                  = Properties[_propertyUniqueID].Value;\r\n                  emit AVECtoONUS(msg.sender, _Lvalue, _PropertyID);\r\n              } else {\r\n                  revert();\r\n              }\r\n          } else if(oneAVECtwoONUS == 2){\r\n              requireUserPrivilegeLevel(1, msg.sender);\r\n              bytes32 _propertyUniqueID\r\n              = _PropertyID;\r\n              uint256 _propertyBalanceLedger\r\n              = subt(divi(mult(Properties[_propertyUniqueID].Value, 1e18), 100), Properties[_propertyUniqueID].propertyGlobalBalance_);\r\n              uint256 _Lvalue\r\n              = tokens;\r\n              updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n              if(_propertyBalanceLedger >= _Lvalue\r\n              && GUsers[msg.sender].UserPrivilegeLevel == 1\r\n              && tokens > 0){\r\n                  //Exchange tokens\r\n                  GUsers[msg.sender].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  -= tokens;\r\n                  GUsers[msg.sender].PropertyAvecBalance[_propertyUniqueID]\r\n                  += tokens;\r\n                  Properties[_propertyUniqueID].propertyGlobalBalance_\r\n                  -= tokens;\r\n                  Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].propertyLastKnownValue_[msg.sender]\r\n                  = Properties[0x676c6f62616c0000000000000000000000000000000000000000000000000000].Value;\r\n                  emit ONUStoAVEC(msg.sender, _Lvalue, _propertyUniqueID);\r\n              } else {\r\n                  revert();\r\n              }\r\n          }\r\n      }\r\n      function amemberBuyFounderDeveloperLicense()\r\n          public\r\n          returns(bool)\r\n      {\r\n          address _founderDeveloperOne = GUsers[msg.sender].FounderDeveloperOne;\r\n          address _founderDeveloperTwo = GUsers[msg.sender].FounderDeveloperTwo;\r\n          address _ceva = GUsers[msg.sender].Ceva;\r\n          requireUserPrivilegeLevel(1, msg.sender);\r\n          uint256 _licenseprice\r\n          = mult(1000, 1e18); \r\n          address _UserAddress\r\n          = msg.sender;\r\n          if(GUsers[_UserAddress].TokenBalanceLedgersTotal > _licenseprice && GUsers[_UserAddress].approvedByCevaForFD_ == true){\r\n              uint256 _commission = divi(_licenseprice, 5);\r\n              GUsers[_ceva].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n              += _commission;\r\n              GUsers[_UserAddress].TokenBalanceLedgersTotal \r\n              += _commission;\r\n              GUsers[_founderDeveloperOne].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n              +=  _commission;\r\n              GUsers[_founderDeveloperOne].TokenBalanceLedgersTotal\r\n              += _commission;\r\n              _commission = divi(_licenseprice, 10);\r\n              GUsers[_founderDeveloperTwo].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n              +=  _commission; \r\n              GUsers[_founderDeveloperTwo].TokenBalanceLedgersTotal \r\n              += _commission;\r\n              GUsers[_UserAddress].PropertyAvecBalance[GUsers[_UserAddress].transferingPropertyid_]\r\n              = subt(GUsers[_UserAddress].PropertyAvecBalance[GUsers[_UserAddress].transferingPropertyid_], _licenseprice);\r\n              GUsers[_UserAddress].TokenBalanceLedgersTotal\r\n              = subt(GUsers[_UserAddress].TokenBalanceLedgersTotal, _licenseprice);\r\n              GUsers[_UserAddress].UserPrivilegeLevel \r\n              = 2;\r\n              emit LicensePurchase(msg.sender, _ceva, _founderDeveloperOne, _founderDeveloperTwo);\r\n              return true;\r\n          } else {\r\n              revert();\r\n          }\r\n      }\r\n      /**\r\n       * withdraw an envelope hold shareholders specific envelope dividends based on the chosen number\r\n       * 1 = Taxes Envelope\r\n       * 2 = Insurance Envelope\r\n       * 3 = Maintenance Envelope\r\n       * 4 = Wealth Architect Equity Coin Operator Envelope\r\n       * 5 = Hold One Envelope\r\n       * 6 = Hold Two Envelope\r\n       * 7 = Hold Three Envelope\r\n       * 8 = Rewards Envelope(OMNI)\r\n       * 9 = Tech Envelope\r\n       * 10 = Exist Holdings Envelope\r\n       * 11 = Exist Crypto Envelope\r\n       * 12 = WHOA Envelope\r\n       * 13 = Credible You Envelope\r\n       */\r\n      function amemberWithdrawDividends(\r\n          uint8 _envelopeNumber)\r\n              public\r\n          {\r\n              requireUserPrivilegeLevel(1, msg.sender);\r\n              // setup data\r\n              address _UserAddress\r\n              = msg.sender;\r\n              uint256 _dividends;\r\n              if(_envelopeNumber > 0 \r\n              && _envelopeNumber < 13\r\n              && _envelopeNumber != 8){\r\n                  _dividends\r\n                  = agetDividendsOf(msg.sender, _envelopeNumber);\r\n                  GUsers[_UserAddress].FeesTotalWithdrawnByEnvelope_[_envelopeNumber]\r\n                  +=  _dividends;\r\n              } else if(_envelopeNumber == 8){\r\n                  _dividends\r\n                  = agetDividendsOf(msg.sender, _envelopeNumber);\r\n                  GUsers[_UserAddress].FeesTotalWithdrawnByEnvelope_[_envelopeNumber]\r\n                  +=  _dividends;\r\n                  GUsers[_UserAddress].PropertyAvecBalance[0x4f4d4e4900000000000000000000000000000000000000000000000000000000]\r\n                  +=  _dividends;\r\n                  GUsers[_UserAddress].TokenBalanceLedgersTotal \r\n                  = GUsers[_UserAddress].TokenBalanceLedgersTotal +_dividends;\r\n              }\r\n              // update dividend tracker\r\n              if(_envelopeNumber != 8){\r\n                  GUsers[_UserAddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                  +=  _dividends;\r\n              }\r\n              GUsers[_UserAddress].TokenBalanceLedgersTotal\r\n              += _dividends;\r\n              // fire event\r\n              emit OnWithdraw(_UserAddress, _dividends, _envelopeNumber);\r\n      }\r\n      /*=================================\r\n      = UserPrivilegeLevel/set function =\r\n      =================================*/\r\n      function asetMyUser() public{\r\n              if(GUsers[msg.sender].Set != true) {\r\n                  AVEC.User storage LTwouser = GUsers[msg.sender];\r\n                      LTwouser.UserAddress = msg.sender;\r\n                      LTwouser.UserPrivilegeLevel = 0;\r\n                      LTwouser.Set = true;\r\n                      LTwouser.Ceva = address(0x0);\r\n                      LTwouser.FounderDeveloperOne = address(0x0);\r\n                      LTwouser.FounderDeveloperTwo = address(0x0);\r\n                      LTwouser.transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n                      userAccounts.push(msg.sender);\r\n                      emit UserSet(msg.sender);\r\n              } else {\r\n                  revert();\r\n              }\r\n      }\r\n      function asetUser(\r\n          address _UserAddress,\r\n          address _Ceva,\r\n          address _FounderDeveloperOne,\r\n          uint8 _UserPrivilegeLevel) public {\r\n              AVEC.User storage Luser = GUsers[_UserAddress];\r\n              if(GUsers[_UserAddress].Set != true){\r\n                  if(_UserPrivilegeLevel <= GUsers[msg.sender].UserPrivilegeLevel\r\n                      && GUsers[msg.sender].UserPrivilegeLevel >= 4\r\n                      && _FounderDeveloperOne != address(0x0)\r\n                      && _Ceva != address(0x0)\r\n                      && _UserAddress != address(0x0)\r\n                      && _UserAddress != msg.sender\r\n                      && _UserPrivilegeLevel < 5){\r\n                          if(GUsers[_UserAddress].Set == true){\r\n                              GUsers[_UserAddress].Ceva = _Ceva;\r\n                              GUsers[_UserAddress].FounderDeveloperOne = _FounderDeveloperOne;\r\n                              GUsers[_UserAddress].FounderDeveloperTwo = GUsers[_FounderDeveloperOne].FounderDeveloperOne;\r\n                              GUsers[_UserAddress].UserPrivilegeLevel = _UserPrivilegeLevel;\r\n                              GUsers[_UserAddress].transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n                          } else {\r\n                          Luser.UserAddress = _UserAddress;\r\n                          Luser.Set = true;\r\n                          Luser.Ceva = _Ceva;\r\n                          Luser.FounderDeveloperOne = _FounderDeveloperOne;\r\n                          Luser.FounderDeveloperTwo = GUsers[_FounderDeveloperOne].FounderDeveloperOne;\r\n                          Luser.UserPrivilegeLevel = _UserPrivilegeLevel;\r\n                          Luser.transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n                          userAccounts.push(msg.sender);\r\n                          }\r\n                  } else if(GUsers[msg.sender].UserPrivilegeLevel >= subt(_UserPrivilegeLevel, 1)\r\n                      && _UserPrivilegeLevel <= 3\r\n                      && _UserPrivilegeLevel >= 2\r\n                      && _FounderDeveloperOne != address(0x0)\r\n                      && _Ceva != address(0x0)\r\n                      && _UserAddress != address(0x0)\r\n                      && _UserAddress != msg.sender){\r\n                          if(GUsers[_UserAddress].Set == true){\r\n                              GUsers[_UserAddress].Ceva = _Ceva;\r\n                              GUsers[_UserAddress].FounderDeveloperOne = _FounderDeveloperOne;\r\n                              GUsers[_UserAddress].FounderDeveloperTwo = GUsers[_FounderDeveloperOne].FounderDeveloperOne;\r\n                              GUsers[_UserAddress].UserPrivilegeLevel = _UserPrivilegeLevel;\r\n                              GUsers[_UserAddress].transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n                          } else {\r\n                          Luser.UserAddress = _UserAddress;\r\n                          Luser.Set = true;\r\n                          Luser.Ceva = _Ceva;\r\n                          Luser.FounderDeveloperOne = _FounderDeveloperOne;\r\n                          Luser.FounderDeveloperTwo = GUsers[_FounderDeveloperOne].FounderDeveloperOne;\r\n                          Luser.UserPrivilegeLevel = _UserPrivilegeLevel;\r\n                          Luser.transferingPropertyid_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n                          userAccounts.push(msg.sender);\r\n                          }\r\n                  } \r\n              }\r\n              emit UserSet(_UserAddress);\r\n      }\r\n      function requireUserPrivilegeLevel(uint8 _UserPrivilegeLevel, address _UserAddress)\r\n          view\r\n          internal\r\n      {\r\n          if(_UserPrivilegeLevel <= GUsers[_UserAddress].UserPrivilegeLevel){\r\n          } else {\r\n              revert();\r\n          }\r\n      }\r\n      /*=================================\r\n      =       public view function      =\r\n      =================================*/\r\n      function agetProperty(\r\n          bytes32 _PropertyID) \r\n          view\r\n          public\r\n          returns (\r\n          bool,\r\n          address,\r\n          address,\r\n          address,\r\n          uint256,\r\n          uint256,\r\n          bytes32,\r\n          uint256,\r\n          uint256,\r\n          uint256,\r\n          uint256,\r\n          uint8,\r\n          bool) {\r\n              bytes32 _PropertyIDStacked = _PropertyID;\r\n              return (\r\n                  Properties[_PropertyIDStacked].Set,\r\n                  Properties[_PropertyIDStacked].Ceva,\r\n                  Properties[_PropertyIDStacked].FounderDeveloper,\r\n                  Properties[_PropertyIDStacked].Owner,\r\n                  Properties[_PropertyIDStacked].Value,\r\n                  Properties[_PropertyIDStacked].NumberOfTokensToEscrow,\r\n                  Properties[_PropertyIDStacked].PropertyID,\r\n                  Properties[_PropertyIDStacked].propertyPriceUpdateCountAsset_,\r\n                  Properties[_PropertyIDStacked].propertyGlobalBalance_,\r\n                  Properties[_PropertyIDStacked].lastMintingPrice_,\r\n                  uint256(Properties[_PropertyIDStacked].escrowAgreementNumber.length),\r\n                  Properties[_PropertyIDStacked].currentEscrowAgreementNumber,\r\n                  Properties[_PropertyIDStacked].firstEscrowSet\r\n              );\r\n      }\r\n      function agetPropertiesCount() \r\n          view\r\n          public\r\n          returns (uint) {\r\n        return propertyIDs.length;\r\n      }\r\n      function agetUserCard(\r\n          address _UserAddress) \r\n          view \r\n          public \r\n          returns (\r\n              bool, \r\n              bool, \r\n              address, \r\n              address, \r\n              address, \r\n              address, \r\n              uint8) {\r\n                  address _UserAddressStacked = _UserAddress;\r\n                  if(GUsers[_UserAddressStacked].Set == true){\r\n                      return(\r\n                          GUsers[_UserAddressStacked].Set,\r\n                          GUsers[_UserAddressStacked].approvedByCevaForFD_,\r\n                          GUsers[_UserAddressStacked].UserAddress,\r\n                          GUsers[_UserAddressStacked].Ceva,\r\n                          GUsers[_UserAddressStacked].FounderDeveloperTwo,\r\n                          GUsers[_UserAddressStacked].FounderDeveloperOne,\r\n                          GUsers[_UserAddressStacked].UserPrivilegeLevel\r\n                          );\r\n                  } else {\r\n                      revert();\r\n                  }\r\n      }\r\n      function agetUserPropertyCard(\r\n          address _UserAddress) \r\n          view \r\n          public \r\n          returns (\r\n              bytes32, \r\n              bytes32, \r\n              uint256, \r\n              uint256, \r\n              uint256,\r\n              uint256, \r\n              uint256, \r\n              bool, \r\n              uint256, \r\n              uint8, \r\n              uint8) {\r\n                  address _UserAddressStacked = _UserAddress;\r\n                  if(GUsers[_UserAddressStacked].Set == true){\r\n                      return(\r\n                          GUsers[_UserAddressStacked].workingPropertyid_,\r\n                          GUsers[_UserAddressStacked].transferingPropertyid_,\r\n                          GUsers[_UserAddressStacked].TokenBalanceLedgersTotal,\r\n                          GUsers[_UserAddressStacked].PropertyAvecBalance[GUsers[_UserAddressStacked].transferingPropertyid_],\r\n                          GUsers[_UserAddressStacked].propertyPriceUpdateCountMember_[msg.sender][GUsers[_UserAddressStacked].transferingPropertyid_],\r\n                          GUsers[_UserAddressStacked].mintingDepositsOf_,\r\n                          GUsers[_UserAddressStacked].amountCirculated_,\r\n                          GUsers[_UserAddressStacked].burnrequestwhitelist_[GUsers[_UserAddressStacked].transferingPropertyid_],\r\n                          GUsers[_UserAddressStacked].propertyvalueOld_[GUsers[_UserAddressStacked].transferingPropertyid_],\r\n                          GUsers[_UserAddressStacked].lastknownPropertyEscrowAgreementNumber[GUsers[_UserAddressStacked].transferingPropertyid_],\r\n                          GUsers[_UserAddressStacked].transferType_);\r\n                  } else {\r\n                      revert();\r\n                  }\r\n      }\r\n      function agetUserPropertyAvecBalance(\r\n          address _InsUserAddress, \r\n          bytes32 _PropertyID) \r\n          view\r\n          public\r\n          returns (\r\n          address,\r\n          uint256,\r\n          uint256) {\r\n              address _UserAddress = _InsUserAddress;\r\n        return (\r\n            GUsers[_UserAddress].UserAddress,\r\n            GUsers[_UserAddress].TokenBalanceLedgersTotal,\r\n            GUsers[_UserAddress].PropertyAvecBalance[_PropertyID]);\r\n      }\r\n      function agetUserCount() \r\n          view\r\n          public\r\n          returns (uint) {\r\n        return userAccounts.length;\r\n      }\r\n      function agetUserPropertiesCount(\r\n          address _UserAddress) \r\n          view\r\n          public\r\n          returns (uint) {\r\n        return GUsers[_UserAddress].Properties.length;\r\n      }\r\n      function agetDividendsOf(\r\n          address _UserAddress, \r\n          uint8 _envelopeNumber)\r\n          view\r\n          public\r\n          returns(uint256)\r\n      {\r\n        if(GUsers[_UserAddress].amountCirculated_ >= 1){\r\n          if(GUsers[_UserAddress].FeeShareholdByEnvelope_[_envelopeNumber] >= 1){\r\n              uint256 _dividendPershare\r\n              = divi(divi(divi(LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[14], 2) , 8), LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[1]);\r\n              uint256 _taxesSharehold\r\n              = GUsers[_UserAddress].FeeShareholdByEnvelope_[_envelopeNumber];\r\n              uint256 _LCalculate\r\n              = divi(subt(mult(_dividendPershare, _taxesSharehold),\r\n              addi(GUsers[_UserAddress].FeesTotalWithdrawnByEnvelope_[_envelopeNumber], GUsers[_UserAddress].FeesPreviousWithdrawnByEnvelope_[_envelopeNumber])),\r\n              divi(addi(GUsers[_UserAddress].mintingDepositsOf_, 1), addi(GUsers[_UserAddress].amountCirculated_, 1)));\r\n              return  _LCalculate;\r\n          } else {\r\n              return 0;\r\n          }\r\n        } else {\r\n            return 0;\r\n        }\r\n      }\r\n      function agetShareHoldOf(\r\n          address _UserAddress, \r\n          uint8 _envelopeNumber)\r\n          view\r\n          public\r\n          returns(uint256, uint8)\r\n      {\r\n          if(_envelopeNumber >= 1\r\n          && _envelopeNumber <= 13){\r\n              return (GUsers[_UserAddress].FeeShareholdByEnvelope_[_envelopeNumber], 1);\r\n          } else {\r\n              return (0, 0);\r\n          }\r\n      }\r\n      function agetEscrow(\r\n          bytes32 _PropertyID) \r\n          view\r\n          public\r\n          returns (\r\n          bytes32,\r\n          address,\r\n          bytes32,\r\n          uint8,\r\n          bool,\r\n          uint256,\r\n          uint256,\r\n          uint256,\r\n          uint256,\r\n          uint256,\r\n          uint256,\r\n          uint256) {\r\n              bytes32 _PropertyId = _PropertyID;\r\n              return (\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].PropertyID,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].recipientOfFunds,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].recipientName,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].escrowAgreementNumber,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].escrowCompleted,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].milestonePriceOfEscrowInETH,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].tokensAvailableTotal,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].tokensAvailableCurrent,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].totalETHReceived,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].ethPerToken,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].propertyIncrease,\r\n                  GEscrowAgreements[_PropertyId][Properties[_PropertyId].currentEscrowAgreementNumber].AgreementAmountDueInTokens[msg.sender]\r\n              );\r\n      }\r\n      function getBalance() \r\n          public \r\n          view \r\n          returns (uint) {\r\n              return address(this).balance;\r\n          }\r\n      /*==============================\r\n      =        public function       =\r\n      ==============================*/\r\n      constructor()\r\n          public\r\n      {\r\n      }\r\n      function adminInitialSet()\r\n          public\r\n      {\r\n          if(adminset_ \r\n          == false){\r\n              GUsers[msg.sender].Set = true;\r\n              GUsers[msg.sender].UserAddress = msg.sender;\r\n              GUsers[msg.sender].UserPrivilegeLevel = 4;\r\n              GUsers[msg.sender].FounderDeveloperOne = msg.sender;\r\n              GUsers[msg.sender].FounderDeveloperTwo = msg.sender;\r\n              GUsers[msg.sender].Ceva = msg.sender;\r\n              adminset_\r\n              = true;\r\n              emit UserSet(msg.sender);\r\n          } else {\r\n              revert();\r\n          }\r\n      }\r\n      function aSellFeeSharehold(\r\n          address _toAddress, \r\n          uint256 _amount, \r\n          uint8 _envelopeNumber)\r\n          public\r\n          returns(bool)\r\n      {\r\n          requireUserPrivilegeLevel(0, msg.sender);\r\n          requireUserPrivilegeLevel(0, _toAddress);\r\n          if(_amount > 0\r\n          && _envelopeNumber == 1){\r\n          // setup\r\n              address _UserAddress\r\n              = msg.sender;\r\n              if(_amount <= GUsers[_UserAddress].FeeShareholdByEnvelope_[_envelopeNumber]\r\n              && _amount >= 0\r\n              && _toAddress != _UserAddress){\r\n                  GUsers[_toAddress].FeesPreviousWithdrawnByEnvelope_[_envelopeNumber]\r\n                  += mult(divi(GUsers[_UserAddress].FeesTotalWithdrawnByEnvelope_[_envelopeNumber], GUsers[_UserAddress].FeeShareholdByEnvelope_[_envelopeNumber]), _amount);\r\n                  GUsers[_toAddress].FeeShareholdByEnvelope_[_envelopeNumber]\r\n                  += _amount;\r\n                  GUsers[_UserAddress].FeeShareholdByEnvelope_[_envelopeNumber]\r\n                  -= _amount;\r\n              }\r\n          } else {\r\n              revert();\r\n          }\r\n            GUsers[_toAddress].mintingDepositsOf_ += mult(_amount, 1e18);\r\n            GUsers[_toAddress].amountCirculated_ += mult(_amount, 1e18);\r\n            \r\n            emit FeeShareholdSOLD(msg.sender, _toAddress, _amount);\r\n            return true;\r\n      }\r\n      function amemberUpdateRollingPropertyValue(\r\n          address _holderAddress, \r\n          bytes32 _propertyUniqueId)\r\n          public\r\n          returns(uint8)\r\n      {\r\n          requireUserPrivilegeLevel(0, msg.sender);\r\n          if(Properties[_propertyUniqueId].propertyPriceUpdateCountAsset_ != GUsers[_holderAddress].propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]\r\n          && GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId] > 0\r\n          && Properties[_propertyUniqueId].Set == true\r\n          && Properties[_propertyUniqueId].Value > 0){\r\n              updateRollingPropertyValueMember(_holderAddress,_propertyUniqueId);\r\n              return 1;\r\n          } else {\r\n              return 2;\r\n          }\r\n      }\r\n      /**\r\n       * Select a specific property unique id to swap its AVEC when calling the transfer function.\r\n       * 0x676c6f62616c0000000000000000000000000000000000000000000000000000\r\n       * ONUS ^\r\n       * 0x4f4d4e4900000000000000000000000000000000000000000000000000000000\r\n       * OMNI ^\r\n       */\r\n      function aaswapType(\r\n          bytes32 _propertyUniqueID, \r\n          uint8 _tokenType)\r\n              public\r\n              returns(bytes32, uint8)\r\n          {\r\n              if(_tokenType <= 3 \r\n              && _tokenType >= 1\r\n              && GUsers[msg.sender].UserPrivilegeLevel >= 1){\r\n                  updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n                if(_tokenType == 1){\r\n                    updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n                    GUsers[msg.sender].transferingPropertyid_\r\n                    = _propertyUniqueID;\r\n                    GUsers[msg.sender].transferType_\r\n                    = 1;\r\n                } else if(_tokenType == 2){\r\n                    updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n                    GUsers[msg.sender].transferingPropertyid_\r\n                    = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n                    GUsers[msg.sender].transferType_\r\n                    = 2;\r\n                } else if(_tokenType == 3){\r\n                    updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n                    GUsers[msg.sender].transferingPropertyid_\r\n                    = 0x4f4d4e4900000000000000000000000000000000000000000000000000000000;\r\n                    GUsers[msg.sender].transferType_\r\n                    = 3;\r\n                }\r\n                return (GUsers[msg.sender].transferingPropertyid_, _tokenType);\r\n              }\r\n      }\r\n      function withdrawAVECFromEscrow(\r\n          bytes32 _PropertyID) \r\n          public{\r\n              uint256 tokens = GEscrowAgreements[_PropertyID][GUsers[msg.sender].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[msg.sender];\r\n              address _userAddress = msg.sender;\r\n              if(GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress] >= 1e18 \r\n              && GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].escrowCompleted == true\r\n              && GUsers[msg.sender].UserPrivilegeLevel >= 0){\r\n                  if(GUsers[_userAddress].UserPrivilegeLevel == 0){\r\n                      GUsers[_userAddress].TokenBalanceLedgersTotal \r\n                      += GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      GUsers[_userAddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000]\r\n                      += GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      Properties[_PropertyID].propertyGlobalBalance_\r\n                      += GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress]\r\n                      -= GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      emit AVECWithdrawnFromEscrow(msg.sender, tokens, _PropertyID);\r\n                  } else if(GUsers[_userAddress].UserPrivilegeLevel >= 1)\r\n                      GUsers[_userAddress].TokenBalanceLedgersTotal\r\n                      += GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      GUsers[_userAddress].PropertyAvecBalance[_PropertyID]\r\n                      += GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress]\r\n                      -= GEscrowAgreements[_PropertyID][GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID]].AgreementAmountDueInTokens[_userAddress];\r\n                      emit AVECWithdrawnFromEscrow(msg.sender, tokens, _PropertyID);\r\n              } else {\r\n              }\r\n              updateRollingPropertyValueMember(msg.sender, _PropertyID);\r\n      }\r\n      /*==============================\r\n      =        payable function     =\r\n      ==============================*/\r\n      function contributeToEscrowForProperty(\r\n          bytes32 _PropertyID)\r\n          public\r\n          payable\r\n          returns(bytes memory){\r\n              if(GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].escrowCompleted == true){\r\n                  revert();\r\n              } else {\r\n              if(GUsers[msg.sender].Set != true){\r\n                  asetMyUser();\r\n              }\r\n              address _userAddress = msg.sender;\r\n              uint256 _value;\r\n              uint256 _amountOfAVEC = divi(msg.value, GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].ethPerToken);\r\n              bytes32 stacked = _PropertyID;      \r\n              if(GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].escrowCompleted == false\r\n                  && GUsers[msg.sender].UserPrivilegeLevel >= 0\r\n                  && GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].totalETHReceived \r\n                  >= GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].milestonePriceOfEscrowInETH){\r\n                      GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].tokensAvailableCurrent = 0;\r\n                      (bool success, bytes memory tf) = GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].recipientOfFunds.call\r\n                      {value: GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].milestonePriceOfEscrowInETH}(\"\");\r\n                      GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].escrowCompleted = success;\r\n              if(GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].propertyIncrease > 0 \r\n                  && GUsers[msg.sender].UserPrivilegeLevel >= 3 \r\n                  && GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].escrowCompleted == true\r\n                  ){\r\n                      bytes32 wpIDTemp = GUsers[msg.sender].workingPropertyid_;\r\n                      GUsers[msg.sender].workingPropertyid_ = _PropertyID;\r\n                      adjustPropertyValue(addi(Properties[stacked].Value, GEscrowAgreements[stacked][Properties[stacked].currentEscrowAgreementNumber].propertyIncrease));\r\n                      GUsers[msg.sender].workingPropertyid_ = wpIDTemp;\r\n                      GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].propertyIncrease = 0;\r\n                  }\r\n                  emit ContributionMade(_userAddress, msg.value, stacked, Properties[stacked].currentEscrowAgreementNumber, GEscrowAgreements[stacked][Properties[stacked].currentEscrowAgreementNumber].escrowCompleted);\r\n                  return tf;\r\n              } else {\r\n              if(GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].tokensAvailableCurrent <= _amountOfAVEC){\r\n                  _value = subt(GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].milestonePriceOfEscrowInETH, \r\n                  GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].totalETHReceived);\r\n                  _amountOfAVEC = GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].tokensAvailableCurrent;\r\n                  if(msg.value > addi(_value, GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].ethPerToken) || \r\n                  msg.value < GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].ethPerToken){\r\n                      revert();\r\n                  }}\r\n              \r\n              GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].tokensAvailableCurrent -= _amountOfAVEC;\r\n              _value = mult(GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].ethPerToken, _amountOfAVEC);\r\n              withdrawAVECFromEscrow(_PropertyID);\r\n              GUsers[_userAddress].lastknownPropertyEscrowAgreementNumber[_PropertyID] = Properties[_PropertyID].currentEscrowAgreementNumber;\r\n              address(this).call{value: _value};\r\n              updateRollingPropertyValueMember(msg.sender, _PropertyID);\r\n              GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].totalETHReceived += _value;\r\n              ETHERTOTALRECEIVED += _value;\r\n              amountDueInTokens[_userAddress] += mult(_amountOfAVEC, 1e18);\r\n              GEscrowAgreements[_PropertyID][Properties[_PropertyID].currentEscrowAgreementNumber].AgreementAmountDueInTokens[_userAddress] = mult(_amountOfAVEC, 1e18);\r\n              emit ContributionMade(_userAddress, _value, stacked, Properties[stacked].currentEscrowAgreementNumber, GEscrowAgreements[stacked][Properties[stacked].currentEscrowAgreementNumber].escrowCompleted);\r\n              \r\n         \r\n          }\r\n              }\r\n              }\r\n          \r\n          \r\n              \r\n          \r\n          \r\n      /*==============================\r\n      =        internal function     =\r\n      ==============================*/\r\n      function updateRollingPropertyValueMember(\r\n          address _holderAddress, \r\n          bytes32 _propertyUniqueId)\r\n          internal\r\n          returns (uint8)\r\n      {\r\n          uint256 _propertyBalanceLedger\r\n          = GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId];\r\n          //if holding burned value\r\n          if(_propertyBalanceLedger >= 1 && Properties[_propertyUniqueId].Value == 0 && _propertyUniqueId != 0x676c6f62616c0000000000000000000000000000000000000000000000000000){\r\n             GUsers[_holderAddress].PropertyAvecBalance[0x676c6f62616c0000000000000000000000000000000000000000000000000000] = GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId]; \r\n             GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId] -= GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId];\r\n             emit ValueUpdate(_holderAddress, _propertyUniqueId, _propertyBalanceLedger, GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId]);\r\n          } else {\r\n          if(Properties[_propertyUniqueId].propertyPriceUpdateCountAsset_ > GUsers[_holderAddress].propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]\r\n          && GUsers[_holderAddress].propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId] == 0) {\r\n              Properties[_propertyUniqueId].propertyLastKnownValue_[_holderAddress]\r\n              = Properties[_propertyUniqueId].Value;\r\n              GUsers[_holderAddress].propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]\r\n              = Properties[_propertyUniqueId].propertyPriceUpdateCountAsset_;\r\n              emit ValueUpdate(_holderAddress, _propertyUniqueId, _propertyBalanceLedger, GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId]);\r\n          } else if(Properties[_propertyUniqueId].propertyPriceUpdateCountAsset_ > GUsers[_holderAddress].propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]){\r\n              uint256 _divideby\r\n              = divi(mult(divi(mult(Properties[_propertyUniqueId].propertyLastKnownValue_[_holderAddress], 1e18), 100), 1000000), _propertyBalanceLedger);\r\n              uint256 _propertyValue\r\n              = mult(divi(mult(Properties[_propertyUniqueId].Value, 1e18), 100), 1000000);\r\n              uint256 _LCalculate\r\n              = divi(_propertyValue, _divideby);\r\n              GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId]\r\n              = _LCalculate;\r\n              GUsers[_holderAddress].TokenBalanceLedgersTotal\r\n              = subt(addi(GUsers[_holderAddress].TokenBalanceLedgersTotal, _LCalculate), _propertyBalanceLedger);\r\n              GUsers[_holderAddress].propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]\r\n              = Properties[_propertyUniqueId].propertyPriceUpdateCountAsset_;\r\n              Properties[_propertyUniqueId].propertyLastKnownValue_[_holderAddress]\r\n              = Properties[_propertyUniqueId].Value;\r\n              emit ValueUpdate(_holderAddress, _propertyUniqueId, _propertyBalanceLedger, GUsers[_holderAddress].PropertyAvecBalance[_propertyUniqueId]);\r\n          }}\r\n      }\r\n      function updateHoldsandSupply(uint256 _amountOfTokens)\r\n              internal\r\n              returns(bool)\r\n          {\r\n              uint48 _tokenCount = uint48(divi(_amountOfTokens, 1e18));\r\n              totalSupply\r\n              += _amountOfTokens;\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[1]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[1]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[2]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[2]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[3]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[3]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[4]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[4]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[5]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[5]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[6]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[6]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[7]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[7]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[8]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[8]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[9]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[9]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[10]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[10]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[11]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[11]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[12]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[12]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[13]\r\n              = uint48(addi(_tokenCount, LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[13]));\r\n              LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[15]\r\n              = uint48(addi(mult(_tokenCount, 13), LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[15]));\r\n              return true;\r\n      }\r\n      function updateEquityRents(uint256 _amountOfTokens)\r\n              internal\r\n              returns(bool)\r\n          {\r\n              if(_amountOfTokens > 0){\r\n                  LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[14]\r\n                  = uint48(addi(LatestTotalHolds[address(this)].feeHoldsTotalByEnvelope[14], divi(_amountOfTokens, 50)));\r\n              } else {\r\n                  revert();\r\n              }\r\n      }\r\n      function creditFeeSharehold(uint256 _amountOfTokens, address _UserAddress, address _toAddress, address _toAddresstwo, address _toAddressthree)\r\n              internal\r\n              returns(bool)\r\n          {\r\n              GUsers[_UserAddress].FeeShareholdByEnvelope_[1]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[_UserAddress].FeeShareholdByEnvelope_[2]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].whoamaintenanceaddress].FeeShareholdByEnvelope_[3]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[_UserAddress].FeeShareholdByEnvelope_[4]          \r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[_toAddress].FeeShareholdByEnvelope_[5]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[_toAddresstwo].FeeShareholdByEnvelope_[6]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[_toAddressthree].FeeShareholdByEnvelope_[7]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].whoarewardsaddress].FeeShareholdByEnvelope_[8]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].techaddress].FeeShareholdByEnvelope_[9]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].existholdingsaddress].FeeShareholdByEnvelope_[10]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].existcryptoaddress].FeeShareholdByEnvelope_[11]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].whoaaddress].FeeShareholdByEnvelope_[12]\r\n              += divi(_amountOfTokens, 1e18);\r\n              GUsers[GFeeWallets[GfeeWalletSecretID_].credibleyouaddress].FeeShareholdByEnvelope_[13]\r\n              += divi(_amountOfTokens, 1e18);\r\n              return true;\r\n          }\r\n      }\r\n  "}}}