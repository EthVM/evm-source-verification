{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Connector.sol":{"content":"// File: contracts\\NyanFund\\ERC20Interface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface ERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\NyanFund\\UniswapV2Interface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts\\NyanFund\\WETHInterface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface WETH {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n}\r\n\r\n// File: contracts\\NyanFund\\YearnInterface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface YConverter {\r\n    function convert(address) external returns (uint256);\r\n}\r\n\r\ninterface YearnIController {\r\n    function withdraw(address, uint256) external;\r\n\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function earn(address, uint256) external;\r\n\r\n    function want(address) external view returns (address);\r\n\r\n    function rewards() external view returns (address);\r\n\r\n    function vaults(address) external view returns (address);\r\n}\r\n\r\ninterface YMintr {\r\n    function mint(address) external;\r\n}\r\n\r\ninterface YOneSplitAudit {\r\n    function swap(\r\n        address fromToken,\r\n        address destToken,\r\n        uint256 amount,\r\n        uint256 minReturn,\r\n        uint256[] calldata distribution,\r\n        uint256 flags\r\n    ) external payable returns (uint256 returnAmount);\r\n\r\n    function getExpectedReturn(\r\n        address fromToken,\r\n        address destToken,\r\n        uint256 amount,\r\n        uint256 parts,\r\n        uint256 flags // See constants in IOneSplit.sol\r\n    ) external view returns (uint256 returnAmount, uint256[] memory distribution);\r\n}\r\n\r\ninterface YearnStrategy {\r\n    function want() external view returns (address);\r\n\r\n    function deposit() external;\r\n\r\n    // NOTE: must exclude any tokens used in the yield\r\n    // Controller role - withdraw should return to Controller\r\n    function withdraw(address) external;\r\n\r\n    // Controller | Vault role - withdraw should always return to Vault\r\n    function withdraw(uint256) external;\r\n\r\n    // Controller | Vault role - withdraw should always return to Vault\r\n    function withdrawAll() external returns (uint256);\r\n\r\n    function balanceOf() external view returns (uint256);\r\n}\r\n\r\ninterface YearnERC20 {\r\n    function deposit(uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n\r\n    function getPricePerFullShare() external view returns (uint256);\r\n}\r\n\r\ninterface YearnVault {\r\n    function deposit(uint256) external;\r\n\r\n    function depositAll() external;\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function withdrawAll() external;\r\n\r\n    function getPricePerFullShare() external view returns (uint256);\r\n}\r\n\r\n// File: contracts\\NyanFund\\NyanFundInterface.sol\r\n\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface NFund {\r\n    function approveSpendERC20(address, uint256) external;\r\n    \r\n    function approveSpendETH(address, uint256) external;\r\n    \r\n    function newVotingRound() external;\r\n    \r\n    function setVotingAddress(address) external;\r\n    \r\n    function setConnectorAddress(address) external;\r\n    \r\n    function setNewFundAddress(address) external;\r\n    \r\n    function setNyanAddress(address) external;\r\n    \r\n    function setCatnipAddress(address) external;\r\n    \r\n    function setDNyanAddress(address) external;\r\n    \r\n    function setBalanceLimit(uint256) external;\r\n    \r\n    function sendToNewContract(address) external;\r\n}\r\n\r\ninterface NVoting {\r\n    function setConnector(address) external;\r\n    \r\n    function setFundAddress(address) external;\r\n    \r\n    function setRewardsContract(address) external;\r\n    \r\n    function setIsRewardingCatnip(bool) external;\r\n    \r\n    function setVotingPeriodBlockLength(uint256) external;\r\n    \r\n    function setNyanAddress(address) external;\r\n    \r\n    function setCatnipAddress(address) external;\r\n    \r\n    function setDNyanAddress(address) external;\r\n    \r\n    function distributeFunds(address, uint256) external;\r\n    \r\n    function burnCatnip() external;\r\n}\r\n\r\ninterface NConnector {\r\n    function executeBid(\r\n        string calldata, \r\n        string calldata, \r\n        address[] calldata , \r\n        uint256[] calldata, \r\n        string[] calldata, \r\n        bytes[] calldata) external;\r\n}\r\n\r\ninterface NyanV2 {\r\n    function swapNyanV1(uint256) external;\r\n    \r\n    function stakeNyanV2LP(uint256) external;\r\n    \r\n    function unstakeNyanV2LP(uint256) external;\r\n    \r\n    function stakeDNyanV2LP(uint256) external;\r\n    \r\n    function unstakeDNyanV2LP(uint256) external;\r\n    \r\n    function addNyanAndETH(uint256) payable external;\r\n    \r\n    function claimETHLP() external;\r\n    \r\n    function initializeV2ETHPool() external;\r\n}\r\n\r\n// File: contracts\\NyanFund\\CoreInterface.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface CoreVault {\r\n    function deposit(uint256, uint256) external;\r\n    function depositFor(address, uint256, uint256) external;\r\n    function setAllowanceForPoolToken(address, uint256, uint256) external;\r\n    function withdrawFrom(address, uint256, uint256) external;\r\n    function withdraw(uint256, uint256) external;\r\n    function emergencyWithdraw(uint256) external;\r\n}\r\n\r\n// File: contracts\\NyanFund\\Connector.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Proxiable {\r\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\r\n\r\n    function updateCodeAddress(address newAddress) internal {\r\n        require(\r\n            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\r\n            \"Not compatible\"\r\n        );\r\n        assembly { // solium-disable-line\r\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\r\n        }\r\n    }\r\n    function proxiableUUID() public pure returns (bytes32) {\r\n        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n    }\r\n}\r\n\r\ncontract LibraryLockDataLayout {\r\n  bool public initialized = false;\r\n}\r\n\r\ncontract LibraryLock is LibraryLockDataLayout {\r\n    // Ensures no one can manipulate the Logic Contract once it is deployed.\r\n    // PARITY WALLET HACK PREVENTION\r\n\r\n    modifier delegatedOnly() {\r\n        require(initialized == true, \"The library is locked. No direct 'call' is allowed\");\r\n        _;\r\n    }\r\n    function initialize() internal {\r\n        initialized = true;\r\n    }\r\n}\r\n\r\ncontract DataLayout is LibraryLock {\r\n    struct bid {\r\n        address bidder;\r\n        uint256 votes;\r\n        address[] addresses;\r\n        uint256[] integers;\r\n        string[] strings;\r\n        bytes[] bytesArr;\r\n    }\r\n    \r\n    address public votingAddress;\r\n    address public fundAddress;\r\n    address public nyanV2;\r\n    address public owner;\r\n    address public uniswapRouterAddress;\r\n    IUniswapV2Router02 public uniswapRouter;\r\n    \r\n    \r\n    address[] public tokenList;\r\n    mapping(address => bool) public whitelist;\r\n    \r\n    \r\n    modifier _onlyOwner() {\r\n        require((msg.sender == votingAddress) || (msg.sender == owner)  || (msg.sender == address(this)));\r\n        _;\r\n    }\r\n\r\n    address public easyBid;\r\n}\r\n\r\ncontract Connector is DataLayout, Proxiable  {\r\n\r\n    function connectorConstructor(address _votingAddress, address _nyan2) public {\r\n        require(!initialized, \"Contract is already initialized\");\r\n        owner = msg.sender;\r\n        votingAddress = _votingAddress;\r\n        nyanV2 = _nyan2;\r\n        initialize();\r\n    }\r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n    \r\n    /** @notice Updates the logic contract.\r\n      * @param newCode  Address of the new logic contract.\r\n      */\r\n    function updateCode(address newCode) public _onlyOwner delegatedOnly  {\r\n        updateCodeAddress(newCode);\r\n        \r\n    }\r\n    \r\n    function setVotingAddress(address _addr) public _onlyOwner delegatedOnly {\r\n        votingAddress = _addr;\r\n    }\r\n    \r\n    function setFundingAddress(address _addr) internal {\r\n        fundAddress = _addr;\r\n    }\r\n    \r\n    function setOwner(address _owner) public _onlyOwner delegatedOnly {\r\n        owner = _owner;\r\n    }\r\n    \r\n    function setUniswapAddress(address _routerAddress) public _onlyOwner delegatedOnly {\r\n        uniswapRouter = IUniswapV2Router02(_routerAddress);\r\n    }\r\n    \r\n    function addToTokenList(address[] memory _tokenAddresses) public delegatedOnly {\r\n        for (uint256 i = 0; i < _tokenAddresses.length; i++) {\r\n            ERC20 erc20 = ERC20(_tokenAddresses[i]);\r\n            uint256 balance = erc20.balanceOf(fundAddress);\r\n            if (balance > 0) {\r\n                tokenList.push(_tokenAddresses[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setApprovedAddress(address _addr, bool _isAllowed) public _onlyOwner delegatedOnly {\r\n        whitelist[_addr] = _isAllowed;\r\n    }\r\n    \r\n    function checkAddress(address _addr) public view delegatedOnly returns(bool) {\r\n        return whitelist[_addr];\r\n    }\r\n    \r\n    \r\n    function transferToFund() public delegatedOnly {\r\n        for (uint256 i = 0; i < tokenList.length; i++) {\r\n            ERC20 erc20 = ERC20(tokenList[0]);\r\n            uint256 balance = erc20.balanceOf(address(this));\r\n            erc20.transfer(fundAddress, balance);\r\n        }\r\n    }\r\n    \r\n    function sendFundsToNewAddress() public _onlyOwner delegatedOnly {\r\n        NFund fundContract = NFund(fundAddress);\r\n        for (uint256 i = 0; i < tokenList.length; i++) {\r\n            fundContract.sendToNewContract(tokenList[i]);\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    // Only voting contract should be able to call\r\n    function executeBid(\r\n        string memory functionCode, \r\n        string memory functionName, \r\n        address[] memory _addresses, \r\n        uint256[] memory integers, \r\n        string[] memory strings, \r\n        bytes[] memory bytesArr) _onlyOwner delegatedOnly public returns (address addr) {\r\n        \r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"fund\"))) {\r\n            interfaceFund(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"voting\"))) {\r\n            interfaceVoting(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"connector\"))) {\r\n            interfaceConnector(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"nyanV2\"))) {\r\n            interfaceNyanV2(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"erc20\"))) {\r\n            interfaceERC20(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"uniV2\"))) {\r\n            interfaceUniV2(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"weth\"))) {\r\n            interfaceWETH(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"ETH\"))) {\r\n            interfaceETH(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"yearn\"))) {\r\n            interfaceUniV2(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n        if (keccak256(bytes(functionCode)) == keccak256(bytes(\"core\"))) {\r\n            interfaceCore(functionCode,functionName,_addresses,integers,strings,bytesArr);\r\n        }\r\n    }\r\n    \r\n    //NYANV2 CONNECTION\r\n    function interfaceNyanV2(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        NyanV2 nyan2 = NyanV2(nyanV2);\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapNyanV1\"))) {\r\n        //    NFund fund = NFund(fundAddress);\r\n        //    fund.approveSpendERC20(nyanV2, integers[0]);\r\n        //    nyan2.swapNyanV1(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"stakeNyanV2LP\"))) {\r\n        //    NFund fund = NFund(fundAddress);\r\n        //    fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //    nyan2.stakeNyanV2LP(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"unstakeNyanV2LP\"))) {\r\n        //    nyan2.unstakeNyanV2LP(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"stakeDNyanV2LP\"))) {\r\n        //    NFund fund = NFund(fundAddress);\r\n        //    fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //    nyan2.stakeDNyanV2LP(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"unstakeDNyanV2LP\"))) {\r\n        //    nyan2.unstakeDNyanV2LP(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"addNyanAndETH\"))) {\r\n        //    NFund fund = NFund(fundAddress);\r\n        //    fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //    fund.approveSpendETH(address(this), integers[1]);\r\n        //    nyan2.addNyanAndETH{ value: integers[1] }(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"claimETHLP\"))) {\r\n        //    nyan2.claimETHLP();\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"initializeV2ETHPool\"))) {\r\n        //    nyan2.initializeV2ETHPool();\r\n        // }\r\n    }\r\n    \r\n    //CONNECTOR CONNECTION\r\n    function interfaceConnector(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setVotingAddress\"))) {\r\n        //    setVotingAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFundAddress\"))) {\r\n        //    setFundingAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setVotingAddress\"))) {\r\n        //    setVotingAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setUniswapAddress\"))) {\r\n        //    setUniswapAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"addToTokenList\"))) {\r\n        //    addToTokenList(_addresses);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"transferToFund\"))) {\r\n        //    transferToFund();\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setUniswapAddress\"))) {\r\n        //    setUniswapAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"sendToNewContract\"))) {\r\n        //    sendFundsToNewAddress();\r\n        // }\r\n    }\r\n    \r\n    //FUND CONNECTION\r\n    function interfaceFund(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        NFund fund = NFund(fundAddress);\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setVotingAddress\"))) {\r\n        //    fund.setVotingAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setConnectorAddress\"))) {\r\n        //    fund.setConnectorAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setNewFundAddress\"))) {\r\n        //    fund.setNewFundAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setNyanAddress\"))) {\r\n        //    fund.setNyanAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setNyanAddress\"))) {\r\n        //    fund.setNyanAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setCatnipAddress\"))) {\r\n        //    fund.setCatnipAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setDNyanAddress\"))) {\r\n        //    fund.setDNyanAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setBalanceLimit\"))) {\r\n        //    fund.setBalanceLimit(integers[0]);\r\n        // }\r\n    }\r\n    \r\n    //VOTING CONNECTION\r\n    function interfaceVoting(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        NVoting votingContract = NVoting(votingAddress);\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setConnector\"))) {\r\n        //    votingContract.setConnector(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFundAddress\"))) {\r\n        //    votingContract.setFundAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setIsRewardingCatnip\"))) {\r\n        //    votingContract.setIsRewardingCatnip(false);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setRewardsContract\"))) {\r\n        //    votingContract.setRewardsContract(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setVotingPeriodBlockLength\"))) {\r\n        //    votingContract.setVotingPeriodBlockLength(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setNyanAddress\"))) {\r\n        //    votingContract.setNyanAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setCatnipAddress\"))) {\r\n        //    votingContract.setCatnipAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setDNyanAddress\"))) {\r\n        //    votingContract.setDNyanAddress(_addresses[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"distributeFunds\"))) {\r\n        //    votingContract.distributeFunds(_addresses[0], integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"burnCatnip\"))) {\r\n        //    votingContract.burnCatnip();\r\n        // }\r\n    }\r\n    \r\n    //ETH CONNECTION\r\n    function interfaceETH(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        NFund fund = NFund(fundAddress);\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"sendETH\"))) {\r\n           require(checkAddress(_addresses[0]), \"Receiver is not whitelisted\");  \r\n           fund.approveSpendETH(_addresses[0], integers[0]);\r\n        }\r\n    }\r\n    \r\n    //ERC20 CONNECTION\r\n    function interfaceERC20(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        ERC20 erc20 = ERC20(_addresses[0]);\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"totalSupply\"))) {\r\n        //    erc20.totalSupply();\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"balanceOf\"))) {\r\n        //    erc20.balanceOf(_addresses[1]);\r\n        // }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"transfer\"))) {\r\n            NFund fund = NFund(fundAddress);\r\n            fund.approveSpendERC20(_addresses[0], integers[0]);\r\n            erc20.transfer(_addresses[1], integers[0]);\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"allowance\"))) {\r\n           erc20.allowance(_addresses[1], _addresses[2]);\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"approve\"))) {\r\n           require(checkAddress(_addresses[1]), \"Receiver is not whitelisted\");\r\n           erc20.approve(_addresses[1], integers[0]);\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"transferFrom\"))) {\r\n           require(checkAddress(_addresses[2]), \"Receiver is not whitelisted\");    \r\n           erc20.transferFrom(_addresses[1], _addresses[2], integers[0]);\r\n        }\r\n    }\r\n    \r\n    //UNISWAP V2 CONNECTION\r\n    function interfaceUniV2(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        NFund fund = NFund(fundAddress);\r\n        //Does CALLEE need an address?\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"uniswapV2Call\"))) {\r\n           \r\n        // }\r\n        \r\n        //IUniswapV2ERC20 functions\r\n        \r\n        //Router02 functions\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"addLiquidity\"))) {\r\n            fund.approveSpendERC20(_addresses[0], integers[0]);\r\n            fund.approveSpendERC20(_addresses[1], integers[1]);\r\n            uniswapRouter.addLiquidity(\r\n                  _addresses[0],\r\n                  _addresses[1],\r\n                  integers[0],\r\n                  integers[1],\r\n                  integers[2],\r\n                  integers[3],\r\n                  fundAddress,\r\n                  integers[4]\r\n                );\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"addLiquidityETH\"))) {\r\n            fund.approveSpendERC20(_addresses[0], integers[0]);\r\n            uniswapRouter.addLiquidityETH{ value: integers[2] }(\r\n                  _addresses[0],\r\n                  integers[0],\r\n                  integers[1],\r\n                  integers[2],\r\n                  fundAddress,\r\n                  integers[3]\r\n                );\r\n        }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"removeLiquidity\"))) {\r\n        //     fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //     uniswapRouter.removeLiquidity(\r\n        //           _addresses[1],\r\n        //           _addresses[2],\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           integers[2],\r\n        //           fundAddress,\r\n        //           integers[3]\r\n        //         );\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"removeLiquidityETH\"))) {\r\n        //     fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //     uniswapRouter.removeLiquidityETH(\r\n        //           _addresses[0],\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           integers[2],\r\n        //           fundAddress,\r\n        //           integers[3]\r\n        //         );\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"removeLiquidityWithPermit\"))) {\r\n        //     //Need to have a way to transfer bool values\r\n        //     uniswapRouter.removeLiquidityWithPermit(\r\n        //           _addresses[0],\r\n        //           _addresses[1],\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           integers[2],\r\n        //           _addresses[2],\r\n        //           integers[3],\r\n        //           false,\r\n        //           integers[4], bytesArr[0], bytesArr[1]\r\n        //         );\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"removeLiquidityETHSupportingFeeOnTransferTokens\"))) {\r\n        //     fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //     uniswapRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        //           _addresses[0],\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           integers[2],\r\n        //           fundAddress,\r\n        //           integers[3]\r\n        //         );\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\"))) {\r\n        //     uniswapRouter.removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        //           _addresses[0],\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           integers[2],\r\n        //           _addresses[1],\r\n        //           integers[3]\r\n        //         );\r\n        // }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapExactTokensForTokens\"))) {\r\n            fund.approveSpendERC20(_addresses[0], integers[0]);\r\n            uniswapRouter.swapExactTokensForTokens(\r\n                  integers[0],\r\n                  integers[1],\r\n                  _addresses,\r\n                  fundAddress,\r\n                  integers[2]\r\n                );\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapTokensForExactTokens\"))) {\r\n            fund.approveSpendERC20(_addresses[0], integers[0]);\r\n            uniswapRouter.swapTokensForExactTokens(\r\n                  integers[0],\r\n                  integers[1],\r\n                  _addresses,\r\n                  fundAddress,\r\n                  integers[2]\r\n                );\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapExactETHForTokens\"))) {\r\n            // transfer ether\r\n            fund.approveSpendETH(address(this), integers[0]);\r\n            uniswapRouter.swapExactETHForTokens{ value: integers[0] }(\r\n                  integers[1],\r\n                  _addresses,\r\n                  fundAddress,\r\n                  integers[2]\r\n                );\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapExactTokensForETH\"))) {\r\n            fund.approveSpendERC20(_addresses[0], integers[0]);\r\n            uniswapRouter.swapExactTokensForETH(\r\n                  integers[0],\r\n                  integers[1],\r\n                  _addresses,\r\n                  fundAddress,\r\n                  integers[2]\r\n                );\r\n        }\r\n\r\n        \r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapETHForExactTokens\"))) {\r\n            fund.approveSpendERC20(address(this), integers[0]);\r\n            uniswapRouter.swapETHForExactTokens{ value: integers[0] }(\r\n                  integers[1],\r\n                  _addresses,\r\n                  fundAddress,\r\n                  integers[2]\r\n                );\r\n        }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapExactTokensForTokensSupportingFeeOnTransferTokens\"))) {\r\n        //     fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //     uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           _addresses,\r\n        //           fundAddress,\r\n        //           integers[2]\r\n        //         );\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapExactETHForTokensSupportingFeeOnTransferTokens\"))) {\r\n        //     fund.approveSpendERC20(address(this), integers[0]);\r\n        //     uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: integers[0] }(\r\n        //           integers[1],\r\n        //           _addresses,\r\n        //           fundAddress,\r\n        //           integers[2]\r\n        //         );\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"swapExactTokensForETHSupportingFeeOnTransferTokens\"))) {\r\n        //     fund.approveSpendERC20(_addresses[0], integers[0]);\r\n        //     uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        //           integers[0],\r\n        //           integers[1],\r\n        //           _addresses,\r\n        //           fundAddress,\r\n        //           integers[2]\r\n        //         );\r\n        // }\r\n        \r\n        \r\n        \r\n        //IUniswapV2Factory functions\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"feeTo\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.feeTo();\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"feeToSetter\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.feeToSetter();\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"getPair\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.getPair(_addresses[1], _addresses[2]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"allPairs\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.allPairs(integers[0]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"allPairsLength\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.allPairsLength();\r\n        // }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"createPair\"))) {\r\n            IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n            uniV2Factory.createPair(_addresses[1], _addresses[2]);\r\n        }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFeeTo\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.setFeeTo(_addresses[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFeeToSetter\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.setFeeToSetter(_addresses[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFeeToSetter\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.setFeeToSetter(_addresses[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFeeToSetter\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.setFeeToSetter(_addresses[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setFeeToSetter\"))) {\r\n        //     IUniswapV2Factory uniV2Factory = IUniswapV2Factory(_addresses[0]);\r\n        //     uniV2Factory.setFeeToSetter(_addresses[1]);\r\n        // }\r\n        \r\n        //IUniswapV2Pair functions\r\n    }\r\n    \r\n    //WETH CONNECTION\r\n    //Need all the WETH funtions\r\n     function interfaceWETH(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n         if (keccak256(bytes(functionName)) == keccak256(bytes(\"wethDeposit\"))) {\r\n            WETH wethAddr = WETH(_addresses[0]);\r\n            wethAddr.deposit();\r\n        }\r\n        if (keccak256(bytes(functionName)) == keccak256(bytes(\"wethWithdraw\"))) {\r\n            WETH wethAddr = WETH(_addresses[0]);\r\n            wethAddr.withdraw(integers[0]);\r\n        }\r\n     }\r\n     \r\n    //CORE CONNECTION\r\n    function interfaceCore(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n        // CoreVault coreContract = CoreVault(_addresses[0]);\r\n        // NFund fund = NFund(fundAddress);\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"deposit\"))) {\r\n        //     fund.approveSpendERC20(_addresses[1], integers[0]);\r\n        //     coreContract.deposit(integers[1], integers[2]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"depositFor\"))) {\r\n        //     coreContract.deposit(integers[0], integers[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"setAllowanceForPoolToken\"))) {\r\n        //     fund.approveSpendERC20(_addresses[1], integers[0]);\r\n        //     coreContract.deposit(integers[1], integers[2]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"withdrawFrom\"))) {\r\n        //     coreContract.withdrawFrom(_addresses[1], integers[0], integers[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"withdraw\"))) {\r\n        //     coreContract.withdraw(integers[0], integers[1]);\r\n        // }\r\n        // if (keccak256(bytes(functionName)) == keccak256(bytes(\"emergencyWithdraw\"))) {\r\n        //     coreContract.emergencyWithdraw(integers[0]);\r\n        // }\r\n    }\r\n     \r\n    \r\n    //YEARN CONNECTION\r\n    // function interfaceYearn(string memory functionCode, string memory functionName, address[] memory _addresses, uint256[] memory integers, string[] memory strings, bytes[] memory bytesArr) internal {\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"cConvert\"))) {\r\n    //         YConverter convertAddr = YConverter(_addresses[0]);\r\n    //         convertAddr.convert(_addresses[1]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yicWithdraw\"))) {\r\n    //         YearnIController iController = YearnIController(_addresses[0]);\r\n    //         iController.withdraw(_addresses[1], integers[0]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yicBalanceOf\"))) {\r\n    //         YearnIController iController = YearnIController(_addresses[0]);\r\n    //         iController.balanceOf(_addresses[1]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yicEarn\"))) {\r\n    //         YearnIController iController = YearnIController(_addresses[0]);\r\n    //         iController.earn(_addresses[1], integers[0]);\r\n    //     }\r\n    //     // if (keccak256(bytes(functionName)) == keccak256(bytes(\"yicWant\"))) {\r\n    //     //     YearnIController iController = YearnIController(_addresses[0]);\r\n    //     //     iController.want(_addresses[1]);\r\n    //     // }\r\n    //     // if (keccak256(bytes(functionName)) == keccak256(bytes(\"yicRewards\"))) {\r\n    //     //     YearnIController iController = YearnIController(_addresses[0]);\r\n    //     //     iController.rewards();\r\n    //     // }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yicVaults\"))) {\r\n    //         YearnIController iController = YearnIController(_addresses[0]);\r\n    //         iController.vaults(_addresses[1]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"ymMint\"))) {\r\n    //         YMintr mintr = YMintr(_addresses[0]);\r\n    //         mintr.mint(_addresses[1]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yosaSwap\"))) {\r\n    //         YOneSplitAudit oneSplitAudit = YOneSplitAudit(_addresses[0]);\r\n    //         // Needs to accept uint arrays\r\n    //         // oneSplitAudit.swap(_addresses[1], _addresses[2], integers[0], integers[1], integers[3], integers[4]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yosaGetExpectedReturn\"))) {\r\n    //         YOneSplitAudit oneSplitAudit = YOneSplitAudit(_addresses[0]);\r\n    //         // Needs to accept uint arrays\r\n    //         oneSplitAudit.getExpectedReturn(_addresses[1], _addresses[2], integers[0], integers[1], integers[3]);\r\n    //     }\r\n    //     // if (keccak256(bytes(functionName)) == keccak256(bytes(\"yStratWant\"))) {\r\n    //     //     YearnStrategy yStrategy = YearnStrategy(_addresses[0]);\r\n    //     //     yStrategy.want();\r\n    //     // }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yStratDeposit\"))) {\r\n    //         YearnStrategy yStrategy = YearnStrategy(_addresses[0]);\r\n    //         yStrategy.deposit();\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yStratWithdraw\"))) {\r\n    //         YearnStrategy yStrategy = YearnStrategy(_addresses[0]);\r\n    //         yStrategy.withdraw(_addresses[1]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yStratWithdraw1\"))) {\r\n    //         YearnStrategy yStrategy = YearnStrategy(_addresses[0]);\r\n    //         yStrategy.withdraw(integers[0]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yStratWithdrawAll\"))) {\r\n    //         YearnStrategy yStrategy = YearnStrategy(_addresses[0]);\r\n    //         yStrategy.withdrawAll();\r\n    //     }\r\n    //     // if (keccak256(bytes(functionName)) == keccak256(bytes(\"yStratBalanceOf\"))) {\r\n    //     //     YearnStrategy yStrategy = YearnStrategy(_addresses[0]);\r\n    //     //     yStrategy.balanceOf();\r\n    //     // }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yERCDeposit\"))) {\r\n    //         YearnERC20 yERC = YearnERC20(_addresses[0]);\r\n    //         yERC.deposit(integers[0]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yERCWithdraw\"))) {\r\n    //         YearnERC20 yERC = YearnERC20(_addresses[0]);\r\n    //         yERC.withdraw(integers[0]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yERCPricePerFullShare\"))) {\r\n    //         YearnERC20 yERC = YearnERC20(_addresses[0]);\r\n    //         yERC.getPricePerFullShare();\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yVaultsDeposit\"))) {\r\n    //         YearnVault yVaults = YearnVault(_addresses[0]);\r\n    //         yVaults.deposit(integers[0]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yVaultsDepositAll\"))) {\r\n    //         YearnVault yVaults = YearnVault(_addresses[0]);\r\n    //         yVaults.depositAll();\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yVaultsWithdraw\"))) {\r\n    //         YearnVault yVaults = YearnVault(_addresses[0]);\r\n    //         yVaults.withdraw(integers[0]);\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yVaultsWithdrawAll\"))) {\r\n    //         YearnVault yVaults = YearnVault(_addresses[0]);\r\n    //         yVaults.withdrawAll();\r\n    //     }\r\n    //     if (keccak256(bytes(functionName)) == keccak256(bytes(\"yVaultsPricePerFullShare\"))) {\r\n    //         YearnVault yVaults = YearnVault(_addresses[0]);\r\n    //         yVaults.getPricePerFullShare();\r\n    //     }\r\n    // }\r\n\r\n    function setEasyBidAddress(address _easyBid) public _onlyOwner {\r\n        easyBid = _easyBid;\r\n    }\r\n\r\n    function getEasyBidETH(uint256 amount) public {\r\n        NFund fund = NFund(fundAddress);\r\n        require(msg.sender == easyBid);\r\n        fund.approveSpendETH(address(easyBid), amount);\r\n\r\n    }\r\n}"}}}