{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ValueLiquid-newcore/StakePoolCreator.sol":{"content":"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n\npragma solidity >=0.7.6;\npragma abicoder v2;\n\ninterface IStakePoolCreator {\n    function version() external returns (uint256);\n\n    function create() external returns (address);\n}\n\ninterface IValueLiquidRouter {\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n        uint256 maxPrice;\n        bool isBPool;\n    }\n\n    function factory() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address pair,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        address tokenIn,\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        address tokenOut,\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        address tokenOut,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline,\n        uint8 flag\n    ) external;\n\n    function addStakeLiquidity(\n        address stakePool,\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addStakeLiquidityETH(\n        address stakePool,\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 totalAmountIn,\n        uint256 minTotalAmountOut,\n        uint256 deadline,\n        uint8 flag\n    ) external payable returns (uint256 totalAmountOut);\n\n    function multihopBatchSwapExactOut(\n        Swap[][] memory swapSequences,\n        address tokenIn,\n        address tokenOut,\n        uint256 maxTotalAmountIn,\n        uint256 deadline,\n        uint8 flag\n    ) external payable returns (uint256 totalAmountIn);\n}\n\ninterface IValueLiquidFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\n\n    function feeTo() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function protocolFee() external view returns (uint256);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function isPair(address) external view returns (bool);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external returns (address pair);\n\n    function getWeightsAndSwapFee(address pair)\n        external\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        );\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setProtocolFee(uint256) external;\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n\ninterface IValueLiquidPair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b > 0, \"ds-math-division-by-zero\");\n        c = a / b;\n    }\n}\n\ncontract TimeLock {\n    using SafeMath for uint256;\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n    bool private _initialized;\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n    bool public admin_initialized;\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor() {\n        admin_initialized = false;\n        _initialized = false;\n    }\n\n    function initialize(address _admin, uint256 _delay) public {\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        admin = _admin;\n        _initialized = true;\n        emit NewAdmin(admin);\n        emit NewDelay(delay);\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 _delay) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = _delay;\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address _pendingAdmin) public {\n        // allows one time setting of admin for deployment purposes\n        if (admin_initialized) {\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        } else {\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\n            admin_initialized = true;\n        }\n        pendingAdmin = _pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n\ninterface IStakePool {\n    event Deposit(address indexed account, uint256 amount);\n    event AddRewardPool(uint256 indexed poolId);\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardBlock, uint256 rewardPerBlock);\n    event PayRewardPool(\n        uint256 indexed poolId,\n        address indexed rewardToken,\n        address indexed account,\n        uint256 pendingReward,\n        uint256 rebaseAmount,\n        uint256 paidReward\n    );\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n    event Withdraw(address indexed account, uint256 amount);\n\n    function version() external returns (uint256);\n\n    function pair() external returns (address);\n\n    function initialize(\n        address _pair,\n        uint256 _unstakingFrozenTime,\n        address _rewardFund,\n        address _timelock\n    ) external;\n\n    function stake(uint256) external;\n\n    function stakeFor(address _account) external;\n\n    function withdraw(uint256) external;\n\n    function getReward(uint8 _pid, address _account) external;\n\n    function getAllRewards(address _account) external;\n\n    function pendingReward(uint8 _pid, address _account) external view returns (uint256);\n\n    function getEndRewardBlock(uint8 _pid) external view returns (address, uint256);\n\n    function getRewardPerBlock(uint8 pid) external view returns (uint256);\n\n    function rewardPoolInfoLength() external view returns (uint256);\n\n    function unfrozenStakeTime(address _account) external view returns (uint256);\n\n    function emergencyWithdraw() external;\n\n    function updateReward() external;\n\n    function updateReward(uint8 _pid) external;\n\n    function updateRewardPool(\n        uint8 _pid,\n        uint256 _endRewardBlock,\n        uint256 _rewardPerBlock\n    ) external;\n\n    function getRewardMultiplier(\n        uint8 _pid,\n        uint256 _from,\n        uint256 _to,\n        uint256 _rewardPerBlock\n    ) external view returns (uint256);\n\n    function getRewardRebase(\n        uint8 _pid,\n        address _rewardToken,\n        uint256 _pendingReward\n    ) external view returns (uint256);\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n\n    function getUserInfo(uint8 _pid, address _account)\n        external\n        view\n        returns (\n            uint256 amount,\n            uint256 rewardDebt,\n            uint256 accumulatedEarned,\n            uint256 lockReward,\n            uint256 lockRewardReleased\n        );\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startBlock,\n        uint256 _endRewardBlock,\n        uint256 _rewardPerBlock,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingBlock,\n        uint256 _endVestingBlock\n    ) external;\n\n    function removeLiquidity(\n        address provider,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address provider,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address provider,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n}\n\ninterface IValueLiquidProvider {\n    function factory() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function removeLiquidity(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address pair,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address pair,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function stake(\n        address stakePool,\n        uint256 amount,\n        uint256 deadline\n    ) external;\n\n    function stakeWithPermit(\n        address stakePool,\n        uint256 amount,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IStakePoolController {\n    event MasterCreated(address indexed farm, address indexed pair, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n    event ChangeGovernance(address indexed governance);\n    event SetFeeCollector(address indexed feeCollector);\n    event SetFeeToken(address indexed token);\n    event SetFeeAmount(uint256 indexed amount);\n\n    struct PoolRewardInfo {\n        address rewardToken;\n        address rewardRebaser;\n        address rewardMultiplier;\n        uint256 startBlock;\n        uint256 endRewardBlock;\n        uint256 rewardPerBlock;\n        uint256 lockRewardPercent;\n        uint256 startVestingBlock;\n        uint256 endVestingBlock;\n        uint256 unstakingFrozenTime;\n        uint256 rewardFundAmount;\n    }\n\n    function allStakePools(uint256) external view returns (address stakePool);\n\n    function isStakePool(address contractAddress) external view returns (bool);\n\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n\n    function setStakePoolVerifier(address contractAddress, bool state) external;\n\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\n\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\n\n    function addStakePoolCreator(address contractAddress) external;\n\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n\n    function allStakePoolsLength() external view returns (uint256);\n\n    function create(\n        uint256 version,\n        address pair,\n        uint256 delayTimeLock,\n        PoolRewardInfo calldata poolRewardInfo,\n        uint8 flag\n    ) external returns (address);\n\n    function createPair(\n        uint256 version,\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee,\n        uint256 delayTimeLock,\n        PoolRewardInfo calldata poolRewardInfo,\n        uint8 flag\n    ) external returns (address);\n\n    function setGovernance(address) external;\n\n    function setFeeCollector(address _address) external;\n\n    function setFeeToken(address _token) external;\n\n    function setFeeAmount(uint256 _token) external;\n}\n\ninterface IStakePoolRewardRebaser {\n    function getRebaseAmount(address rewardToken, uint256 baseAmount) external view returns (uint256);\n}\n\ninterface IStakePoolRewardMultiplier {\n    function getRewardMultiplier(\n        uint256 _start,\n        uint256 _end,\n        uint256 _from,\n        uint256 _to,\n        uint256 _rewardPerBlock\n    ) external view returns (uint256);\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n\ninterface IStakePoolRewardFund {\n    function initialize(address _stakePool, address _timelock) external;\n\n    function safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) external;\n}\n\n// This implements BPool contract, and allows for generalized staking, yield farming, and token distribution.\ncontract StakePool is IStakePool {\n    using SafeMath for uint256;\n    uint256 public override version;\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        mapping(uint8 => uint256) rewardDebt;\n        mapping(uint8 => uint256) reward;\n        mapping(uint8 => uint256) accumulatedEarned; // will accumulate every time user harvest\n        mapping(uint8 => uint256) lockReward;\n        mapping(uint8 => uint256) lockRewardReleased;\n        uint256 lastStakeTime;\n    }\n\n    // Info of each rewardPool funding.\n    struct RewardPoolInfo {\n        address rewardToken; // Address of rewardPool token contract.\n        address rewardRebaser; // Address of rewardRebaser contract.\n        address rewardMultiplier; // Address of rewardMultiplier contract.\n        uint256 startRewardBlock; // Start reward block number that rewardPool distribution occurs.\n        uint256 lastRewardBlock; // Last block number that rewardPool distribution occurs.\n        uint256 endRewardBlock; // Block number which rewardPool distribution ends.\n        uint256 rewardPerBlock; // Reward token amount to distribute per block.\n        uint256 accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n        uint256 lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n        uint256 startVestingBlock; // Block number which vesting starts.\n        uint256 endVestingBlock; // Block number which vesting ends.\n        uint256 numOfVestingBlocks;\n        uint256 totalPaidRewards;\n    }\n\n    mapping(address => UserInfo) public userInfo;\n    RewardPoolInfo[] public rewardPoolInfo;\n    address public override pair;\n    address public rewardFund;\n    address public timelock;\n    address public controller;\n\n    uint256 public balance;\n    uint256 public unstakingFrozenTime = 3 days;\n    uint256 private unlocked = 1;\n    bool private _initialized = false;\n\n    constructor(address _controller, uint256 _version) {\n        controller = _controller;\n        timelock = _controller;\n        version = _version;\n    }\n\n    modifier lock() {\n        require(unlocked == 1, \"StakePool: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    modifier onlyTimeLock() {\n        require(msg.sender == timelock, \"StakePool: !timelock\");\n        _;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(\n        address _pair,\n        uint256 _unstakingFrozenTime,\n        address _rewardFund,\n        address _timelock\n    ) external override {\n        require(_initialized == false, \"StakePool: Initialize must be false.\");\n        require(unstakingFrozenTime <= 30 days, \"StakePool: unstakingFrozenTime > 30 days\");\n        pair = _pair;\n        unstakingFrozenTime = _unstakingFrozenTime;\n        rewardFund = _rewardFund;\n        timelock = _timelock;\n        _initialized = true;\n    }\n\n    function addRewardPool(\n        address _rewardToken,\n        address _rewardRebaser,\n        address _rewardMultiplier,\n        uint256 _startBlock,\n        uint256 _endRewardBlock,\n        uint256 _rewardPerBlock,\n        uint256 _lockRewardPercent,\n        uint256 _startVestingBlock,\n        uint256 _endVestingBlock\n    ) external override lock onlyTimeLock {\n        require(rewardPoolInfo.length <= 16, \"StakePool: Reward pool length > 16\");\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"StakePool: Invalid reward rebaser\");\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"StakePool: Invalid reward multiplier\");\n        require(_startVestingBlock <= _endVestingBlock, \"StakePool: startVestingBlock > endVestingBlock\");\n        _startBlock = (block.number > _startBlock) ? block.number : _startBlock;\n        require(_startBlock < _endRewardBlock, \"StakePool: startBlock >= endRewardBlock\");\n        require(_lockRewardPercent <= 100, \"StakePool: invalid lockRewardPercent\");\n        updateReward();\n        rewardPoolInfo.push(\n            RewardPoolInfo({\n                rewardToken: _rewardToken,\n                rewardRebaser: _rewardRebaser,\n                startRewardBlock: _startBlock,\n                rewardMultiplier: _rewardMultiplier,\n                lastRewardBlock: _startBlock,\n                endRewardBlock: _endRewardBlock,\n                rewardPerBlock: _rewardPerBlock,\n                accRewardPerShare: 0,\n                lockRewardPercent: _lockRewardPercent,\n                startVestingBlock: _startVestingBlock,\n                endVestingBlock: _endVestingBlock,\n                numOfVestingBlocks: _endVestingBlock - _startVestingBlock,\n                totalPaidRewards: 0\n            })\n        );\n        emit AddRewardPool(rewardPoolInfo.length - 1);\n    }\n\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"StakePool: Invalid reward multiplier\");\n        updateReward(_pid);\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardMultiplier = _rewardMultiplier;\n        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\n    }\n\n    function getEndRewardBlock(uint8 _pid) external view override returns (address, uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        return (rewardPool.rewardToken, rewardPool.endRewardBlock);\n    }\n\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"StakePool: Invalid reward rebaser\");\n        updateReward(_pid);\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        rewardPool.rewardRebaser = _rewardRebaser;\n        emit UpdateRewardRebaser(_pid, _rewardRebaser);\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getRewardMultiplier(\n        uint8 _pid,\n        uint256 _from,\n        uint256 _to,\n        uint256 _rewardPerBlock\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        if (rewardPool.rewardMultiplier == address(0)) {\n            return _to.sub(_from).mul(_rewardPerBlock);\n        }\n        return\n            IStakePoolRewardMultiplier(rewardPool.rewardMultiplier).getRewardMultiplier(\n                rewardPool.startRewardBlock,\n                rewardPool.endRewardBlock,\n                _from,\n                _to,\n                _rewardPerBlock\n            );\n    }\n\n    function getRewardRebase(\n        uint8 _pid,\n        address _rewardToken,\n        uint256 _pendingReward\n    ) public view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        if (rewardPool.rewardRebaser == address(0)) {\n            return _pendingReward;\n        }\n        return IStakePoolRewardRebaser(rewardPool.rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\n    }\n\n    function getRewardPerBlock(uint8 pid) external view override returns (uint256) {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n        uint256 rewardPerBlock = rewardPool.rewardPerBlock;\n        if (block.number < rewardPool.startRewardBlock || block.number > rewardPool.endRewardBlock) return 0;\n        uint256 reward = getRewardMultiplier(pid, block.number, block.number + 1, rewardPerBlock);\n        return getRewardRebase(pid, rewardPool.rewardToken, reward);\n    }\n\n    function updateRewardPool(\n        uint8 _pid,\n        uint256 _endRewardBlock,\n        uint256 _rewardPerBlock\n    ) external override lock onlyTimeLock {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        require(block.number <= rewardPool.endRewardBlock && block.number <= _endRewardBlock, \"StakePool: blockNumber > endRewardBlock\");\n        updateReward(_pid);\n        rewardPool.endRewardBlock = _endRewardBlock;\n        rewardPool.rewardPerBlock = _rewardPerBlock;\n        emit UpdateRewardPool(_pid, _endRewardBlock, _rewardPerBlock);\n    }\n\n    function stake(uint256 _amount) external override lock {\n        IValueLiquidPair(pair).transferFrom(msg.sender, address(this), _amount);\n        _stakeFor(msg.sender);\n    }\n\n    function stakeFor(address _account) external override lock {\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"StakePool: Invalid sender\");\n        _stakeFor(_account);\n    }\n\n    function _stakeFor(address _account) internal {\n        uint256 _amount = IValueLiquidPair(pair).balanceOf(address(this)).sub(balance);\n        require(_amount > 0, \"StakePool: Invalid balance\");\n        balance = balance.add(_amount);\n        UserInfo storage user = userInfo[_account];\n        getAllRewards(_account);\n        user.amount = user.amount.add(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n        user.lastStakeTime = block.timestamp;\n        emit Deposit(_account, _amount);\n    }\n\n    function rewardPoolInfoLength() public view override returns (uint256) {\n        return rewardPoolInfo.length;\n    }\n\n    function unfrozenStakeTime(address _account) public view override returns (uint256) {\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n    }\n\n    function removeStakeInternal(uint256 _amount) internal {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= _amount, \"StakePool: invalid withdraw amount\");\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"StakePool: frozen\");\n        getAllRewards(msg.sender);\n        balance = balance.sub(_amount);\n        user.amount = user.amount.sub(_amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n        }\n    }\n\n    function withdraw(uint256 _amount) external override lock {\n        removeStakeInternal(_amount);\n        IValueLiquidPair(pair).transfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function getAllRewards(address _account) public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            getReward(_pid, _account);\n        }\n    }\n\n    function getReward(uint8 _pid, address _account) public override {\n        updateReward(_pid);\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _pendingReward = user.amount.mul(rewardPool.accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n        uint256 _lockRewardPercent = rewardPool.lockRewardPercent;\n        if (_lockRewardPercent > 0) {\n            if (block.number > rewardPool.endVestingBlock) {\n                uint256 _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n                if (_unlockReward > 0) {\n                    _pendingReward = _pendingReward.add(_unlockReward);\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n                }\n            } else {\n                if (_pendingReward > 0) {\n                    uint256 _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n                    _pendingReward = _pendingReward.sub(_toLocked);\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n                }\n                if (block.number > rewardPool.startVestingBlock) {\n                    uint256 _toReleased = user.lockReward[_pid].mul(block.number.sub(rewardPool.startVestingBlock)).div(rewardPool.numOfVestingBlocks);\n                    uint256 _lockRewardReleased = user.lockRewardReleased[_pid];\n                    if (_toReleased > _lockRewardReleased) {\n                        uint256 _unlockReward = _toReleased.sub(_lockRewardReleased);\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n                        _pendingReward = _pendingReward.add(_unlockReward);\n                    }\n                }\n            }\n        }\n        if (_pendingReward > 0) {\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n            user.rewardDebt[_pid] = user.amount.mul(rewardPool.accRewardPerShare).div(1e18);\n            uint256 reward = user.reward[_pid].add(_pendingReward);\n            user.reward[_pid] = reward;\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n            uint256 rewardBalance = IERC20(rewardPool.rewardToken).balanceOf(rewardFund);\n            if (rewardBalance > 0) {\n                user.reward[_pid] = 0;\n                uint256 rebaseAmount = getRewardRebase(_pid, rewardPool.rewardToken, reward);\n                uint256 paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\n                IStakePoolRewardFund(rewardFund).safeTransfer(rewardPool.rewardToken, _account, paidAmount);\n                emit PayRewardPool(_pid, rewardPool.rewardToken, _account, reward, rebaseAmount, paidAmount);\n            }\n        }\n    }\n\n    function pendingReward(uint8 _pid, address _account) external view override returns (uint256) {\n        UserInfo storage user = userInfo[_account];\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n        uint256 lpSupply = IValueLiquidPair(pair).balanceOf(address(this));\n        uint256 _endRewardBlockApplicable = block.number > rewardPool.endRewardBlock ? rewardPool.endRewardBlock : block.number;\n        if (_endRewardBlockApplicable > rewardPool.lastRewardBlock && lpSupply != 0) {\n            uint256 _incRewardPerShare =\n                getRewardMultiplier(_pid, rewardPool.lastRewardBlock, _endRewardBlockApplicable, rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n        }\n        uint256 pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\n        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw() external override lock {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        balance = balance.sub(amount);\n        user.amount = 0;\n        IValueLiquidPair(pair).transfer(msg.sender, amount);\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            user.rewardDebt[_pid] = 0;\n            user.reward[_pid] = 0;\n        }\n    }\n\n    function getUserInfo(uint8 _pid, address _account)\n        public\n        view\n        override\n        returns (\n            uint256 amount,\n            uint256 rewardDebt,\n            uint256 accumulatedEarned,\n            uint256 lockReward,\n            uint256 lockRewardReleased\n        )\n    {\n        UserInfo storage user = userInfo[_account];\n        amount = user.amount;\n        rewardDebt = user.rewardDebt[_pid];\n        accumulatedEarned = user.accumulatedEarned[_pid];\n        lockReward = user.lockReward[_pid];\n        lockRewardReleased = user.lockRewardReleased[_pid];\n    }\n\n    function updateReward() public override {\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n            updateReward(_pid);\n        }\n    }\n\n    function updateReward(uint8 _pid) public override {\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n        uint256 _endRewardBlockApplicable = block.number > rewardPool.endRewardBlock ? rewardPool.endRewardBlock : block.number;\n        if (_endRewardBlockApplicable > rewardPool.lastRewardBlock) {\n            uint256 lpSupply = IValueLiquidPair(pair).balanceOf(address(this));\n            if (lpSupply > 0) {\n                uint256 _incRewardPerShare =\n                    getRewardMultiplier(_pid, rewardPool.lastRewardBlock, _endRewardBlockApplicable, rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n            }\n            rewardPool.lastRewardBlock = _endRewardBlockApplicable;\n        }\n    }\n\n    function removeLiquidity(\n        address provider,\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) public override lock returns (uint256 amountA, uint256 amountB) {\n        require(IStakePoolController(controller).isWhitelistStakingFor(provider), \"StakePool: Invalid provider\");\n        removeStakeInternal(liquidity);\n        IValueLiquidPair(pair).approve(provider, liquidity);\n        emit Withdraw(msg.sender, liquidity);\n        (amountA, amountB) = IValueLiquidProvider(provider).removeLiquidity(address(pair), tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityETH(\n        address provider,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override lock returns (uint256 amountToken, uint256 amountETH) {\n        require(IStakePoolController(controller).isWhitelistStakingFor(provider), \"StakePool: Invalid provider\");\n        removeStakeInternal(liquidity);\n        IValueLiquidPair(pair).approve(provider, liquidity);\n        emit Withdraw(msg.sender, liquidity);\n        (amountToken, amountETH) = IValueLiquidProvider(provider).removeLiquidityETH(\n            address(pair),\n            token,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address provider,\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external override lock returns (uint256 amountETH) {\n        require(IStakePoolController(controller).isWhitelistStakingFor(provider), \"StakePool: Invalid provider\");\n        removeStakeInternal(liquidity);\n        IValueLiquidPair(pair).approve(provider, liquidity);\n        emit Withdraw(msg.sender, liquidity);\n        amountETH = IValueLiquidProvider(provider).removeLiquidityETHSupportingFeeOnTransferTokens(\n            address(pair),\n            token,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            to,\n            deadline\n        );\n    }\n}\n\ncontract StakePoolCreator is IStakePoolCreator {\n    uint256 public override version = 3001;\n\n    function create() external override returns (address) {\n        StakePool pool = new StakePool(msg.sender, version);\n        return address(pool);\n    }\n}\n"}}}