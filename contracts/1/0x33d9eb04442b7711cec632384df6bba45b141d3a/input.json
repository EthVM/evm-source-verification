{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SparkleAirDrop.sol":{"content":"pragma solidity 0.4.25;\r\n\r\n/*\r\n▒ █ ▀ ▀ ▀ █ 　▒ █ ▀ ▀ █ 　░ █ ▀ ▀ █ 　▒ █ ▀ ▀ █ 　▒ █ ░ ▄ ▀ 　▒ █ ░ ░ ░ 　▒ █ ▀ ▀ ▀ 　\r\n░ ▀ ▀ ▀ ▄ ▄ 　▒ █ ▄ ▄ █ 　▒ █ ▄ ▄ █ 　▒ █ ▄ ▄ ▀ 　▒ █ ▀ ▄ ░ 　▒ █ ░ ░ ░ 　▒ █ ▀ ▀ ▀ 　\r\n▒ █ ▄ ▄ ▄ █ 　▒ █ ░ ░ ░ 　▒ █ ░ ▒ █ 　▒ █ ░ ▒ █ 　▒ █ ░ ▒ █ 　▒ █ ▄ ▄ █ 　▒ █ ▄ ▄ ▄ 　\r\n\r\n\r\n░ █ ▀ ▀ █ 　▀ █ ▀ 　▒ █ ▀ ▀ █ 　▒ █ ▀ ▀ ▄ 　▒ █ ▀ ▀ █ 　▒ █ ▀ ▀ ▀ █ 　▒ █ ▀ ▀ █ 　\r\n▒ █ ▄ ▄ █ 　▒ █ ░ 　▒ █ ▄ ▄ ▀ 　▒ █ ░ ▒ █ 　▒ █ ▄ ▄ ▀ 　▒ █ ░ ░ ▒ █ 　▒ █ ▄ ▄ █ 　\r\n▒ █ ░ ▒ █ 　▄ █ ▄ 　▒ █ ░ ▒ █ 　▒ █ ▄ ▄ ▀ 　▒ █ ░ ▒ █ 　▒ █ ▄ ▄ ▄ █ 　▒ █ ░ ░ ░ 　\r\n\r\nhttps://sparklemobile.io/  \r\n\r\nContract can be paused and resumed, but that could also load/reload for later dates*\r\n\r\n\r\nNOTES: \r\n ,_, _ In order to \"claim tokens\" you must first add our token contract address \"0x4b7aD3a56810032782Afce12d7d27122bDb96efF\"\r\n[0,0] \r\n|)__)       \r\n-”-”-\r\n\r\n  ,_, _ Did you hear FREE Sparkle!\r\n[0,0] \r\n|)__)       \r\n-”-”- 1) Opposed to setting max number of airdrop winners I changed it to just give out the default airdrod reward to any\r\nadded address to the airdrop list(see note 3 below). When the tokens run out then the contract will not honor any\r\nairdrop awards but can still be run and tokens added to continue using the contract for other giveaways.\r\n\r\n\r\n  ,_,  _ Follow us on Twitter!\r\n[0,0] \r\n|)__)       \r\n-”-”- 2) Added functions to allow adding address(es) with a different token reward than the standard 30 for those cases \r\nwhere some addresses we may want them to have more of an airdrop than the default\r\n\r\n\r\n  ,_,  _ Like us on Facebook \r\n[0,0] \r\n|)__)       \r\n-”-”- 3) I tried to make sure that the general cases of people senting eth to the contract is reverted and not accepted\r\nhowever I am not positive this can stop someone that is determined. With that said I did not add anything to withdraw\r\nthat potential eth so it would be stuck in this contract if someone happens to send the contract ETH...\r\n\r\n\r\n  ,_,  _ Join our Telegram and Discord!\r\n[0,0] \r\n|)__)       \r\n-”-”- 4)Contract was built with the intention of security in mind, all contracts are built with OpenZeppelin 2.0 latest release \r\nhttps://github.com/OpenZeppelin/openzeppelin-solidity/releases  \r\n*/\r\n\r\ncontract Ownable {\r\n\r\n    address public ownerField;\r\n\r\n    constructor() public {\r\n        ownerField = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == ownerField, \"Calling address not an owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        ownerField = newOwner;\r\n    }\r\n\r\n    function owner() public view returns(address) {\r\n        return ownerField;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(value <= _allowed[from][msg.sender]);\r\n\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].sub(subtractedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(value <= _balances[from], \"Insignificant balance in from address\");\r\n    require(to != address(0), \"Invalid to address specified [0x0]\");\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != 0);\r\n\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    require(value <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n\r\n  function _burnFrom(address account, uint256 value) internal {\r\n\r\n    require(value <= _allowed[account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    bool public paused;\r\n\r\n    modifier ifNotPaused {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier ifPaused {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    // Called by the owner on emergency, triggers paused state\r\n    function pause() external onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    // Called by the owner on end of emergency, returns to normal state\r\n    function resume() external onlyOwner ifPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract AirDropWinners is Ownable, Pausable {\r\nusing SafeMath for uint256;\r\n\r\n  struct Contribution {  \r\n    uint256 tokenAmount;\r\n    bool    wasClaimed;\r\n    bool    isValid;\r\n  }\r\n\r\n\r\n  address public tokenAddress;       //Smartcontract Address  \r\n  uint256 public totalTokensClaimed; // Totaltokens claimed by winners (you do not set this the contract does as tokens are claimed)\r\n  uint256 public startTime;          // airDrop Start time \r\n   \r\n\r\n  mapping (address => Contribution) contributions;\r\n\r\n  constructor (address _token) \r\n  Ownable() \r\n  public {\r\n    tokenAddress = _token;\r\n    startTime = now;\r\n  }\r\n\r\n  /**\r\n   * @dev getTotalTokensRemaining() provides the function of returning the number of\r\n   * tokens currently left in the airdrop balance\r\n   */\r\n  function getTotalTokensRemaining()\r\n  ifNotPaused\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    return ERC20(tokenAddress).balanceOf(this);\r\n  }\r\n\r\n  /**\r\n   * @dev isAddressInAirdropList() provides the function of testing if the \r\n   * specified address is in fact valid in the airdrop list\r\n   */\r\n  function isAddressInAirdropList(address _addressToLookUp)\r\n  ifNotPaused\r\n  public\r\n  view\r\n  returns (bool)\r\n  {\r\n    Contribution storage contrib = contributions[_addressToLookUp];\r\n    return contrib.isValid;\r\n  }\r\n\r\n  /**\r\n   * @dev _bulkAddAddressesToAirdrop provides the function of adding addresses \r\n   * to the airdrop list with the default of 30 sparkle\r\n   */\r\n  function bulkAddAddressesToAirDrop(address[] _addressesToAdd)\r\n  ifNotPaused\r\n  public\r\n  {\r\n    require(_addressesToAdd.length > 0);\r\n    for (uint i = 0; i < _addressesToAdd.length; i++) {\r\n      _addAddressToAirDrop(_addressesToAdd[i]);\r\n    }\r\n    \r\n  }\r\n\r\n  /**\r\n   * @dev _bulkAddAddressesToAirdropWithAward provides the function of adding addresses \r\n   * to the airdrop list with a specific number of tokens\r\n   */\r\n  function bulkAddAddressesToAirDropWithAward(address[] _addressesToAdd, uint256 _tokenAward)\r\n  ifNotPaused\r\n  public\r\n  {\r\n    require(_addressesToAdd.length > 0);\r\n    require(_tokenAward > 0);\r\n    for (uint i = 0; i < _addressesToAdd.length; i++) {\r\n      _addAddressToAirdropWithAward(_addressesToAdd[i], _tokenAward);\r\n    }\r\n    \r\n  }\r\n\r\n  /**\r\n   * @dev _addAddressToAirdropWithAward provides the function of adding an address to the\r\n   * airdrop list with a specific number of tokens opposed to the default of  \r\n   * 30 Sparkle\r\n   * @dev NOTE: _tokenAward will be converted so value only needs to be whole number\r\n   * Ex: 30 opposed to 30 * (10e7)\r\n   */\r\n  function _addAddressToAirdropWithAward(address _addressToAdd, uint256 _tokenAward)\r\n  onlyOwner\r\n  internal\r\n  {\r\n      require(_addressToAdd != 0);\r\n      require(!isAddressInAirdropList(_addressToAdd));\r\n      require(_tokenAward > 0);\r\n      Contribution storage contrib = contributions[_addressToAdd];\r\n      contrib.tokenAmount = _tokenAward.mul(10e7);\r\n      contrib.wasClaimed = false;\r\n      contrib.isValid = true;\r\n  }\r\n\r\n  /**\r\n   * @dev _addAddressToAirdrop provides the function of adding an address to the\r\n   * airdrop list with the default of 30 sparkle\r\n   */\r\n  function _addAddressToAirDrop(address _addressToAdd)\r\n  onlyOwner\r\n  internal\r\n  {\r\n      require(_addressToAdd != 0);\r\n      require(!isAddressInAirdropList(_addressToAdd));\r\n      Contribution storage contrib = contributions[_addressToAdd];\r\n      contrib.tokenAmount = 30 * 10e7;\r\n      contrib.wasClaimed = false;\r\n      contrib.isValid = true;\r\n  }\r\n\r\n  /**\r\n   * @dev bulkRemoveAddressesFromAirDrop provides the function of removing airdrop \r\n   * addresses from the airdrop list\r\n   */\r\n  function bulkRemoveAddressesFromAirDrop(address[] _addressesToRemove)\r\n  ifNotPaused\r\n  public\r\n  {\r\n    require(_addressesToRemove.length > 0);\r\n    for (uint i = 0; i < _addressesToRemove.length; i++) {\r\n      _removeAddressFromAirDrop(_addressesToRemove[i]);\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev _removeAddressFromAirDrop provides the function of removing an address from \r\n   * the airdrop\r\n   */\r\n  function _removeAddressFromAirDrop(address _addressToRemove)\r\n  onlyOwner\r\n  internal\r\n  {\r\n      require(_addressToRemove != 0);\r\n      require(isAddressInAirdropList(_addressToRemove));\r\n      Contribution storage contrib = contributions[_addressToRemove];\r\n      contrib.tokenAmount = 0;\r\n      contrib.wasClaimed = false;\r\n      contrib.isValid = false;\r\n  }\r\n\r\nfunction setAirdropAddressWasClaimed(address _addressToChange, bool _newWasClaimedValue)\r\n  ifNotPaused\r\n  onlyOwner\r\n  public\r\n  {\r\n    require(_addressToChange != 0);\r\n    require(isAddressInAirdropList(_addressToChange));\r\n    Contribution storage contrib = contributions[ _addressToChange];\r\n    require(contrib.isValid);\r\n    contrib.wasClaimed = _newWasClaimedValue;\r\n  }\r\n\r\n  /**\r\n   * @dev claimTokens() provides airdrop winners the function of collecting their tokens\r\n   */\r\n  function claimTokens() \r\n  ifNotPaused\r\n  public {\r\n    Contribution storage contrib = contributions[msg.sender];\r\n    require(contrib.isValid, \"Address not found in airdrop list\");\r\n    require(contrib.tokenAmount > 0, \"There are currently no tokens to claim.\");\r\n    uint256 tempPendingTokens = contrib.tokenAmount;\r\n    contrib.tokenAmount = 0;\r\n    totalTokensClaimed = totalTokensClaimed.add(tempPendingTokens);\r\n    contrib.wasClaimed = true;\r\n    ERC20(tokenAddress).transfer(msg.sender, tempPendingTokens);\r\n  }\r\n\r\n  /**\r\n   * @dev () is the default payable function. Since this contract should not accept\r\n   * revert the transaction best as possible.\r\n   */\r\n  function() payable public {\r\n    revert(\"ETH not accepted\");\r\n  }\r\n\r\n}\r\n\r\ncontract SparkleAirDrop is AirDropWinners {\r\n  using SafeMath for uint256;\r\n\r\n  address initTokenContractAddress = 0x4b7aD3a56810032782Afce12d7d27122bDb96efF;\r\n  \r\n  constructor()\r\n  AirDropWinners(initTokenContractAddress)\r\n  public  \r\n  {}\r\n\r\n}"}}}