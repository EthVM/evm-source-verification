{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{"BondingManager.sol":{"SortedDoublyLL":"0x1a0b2ca69ca2c7f96e2529faa6d63f881655d81a"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BondingManager.sol":{"content":"// File: contracts/IManager.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\ncontract IManager {\r\n    event SetController(address controller);\r\n    event ParameterUpdate(string param);\r\n\r\n    function setController(address _controller) external;\r\n}\r\n\r\n// File: contracts/zeppelin/Ownable.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/zeppelin/Pausable.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n// File: contracts/IController.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\ncontract IController is Pausable {\r\n    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\r\n\r\n    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\r\n    function updateController(bytes32 _id, address _controller) external;\r\n    function getContract(bytes32 _id) public view returns (address);\r\n}\r\n\r\n// File: contracts/Manager.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\ncontract Manager is IManager {\r\n    // Controller that contract is registered with\r\n    IController public controller;\r\n\r\n    // Check if sender is controller\r\n    modifier onlyController() {\r\n        _onlyController();\r\n        _;\r\n    }\r\n\r\n    // Check if sender is controller owner\r\n    modifier onlyControllerOwner() {\r\n        _onlyControllerOwner();\r\n        _;\r\n    }\r\n\r\n    // Check if controller is not paused\r\n    modifier whenSystemNotPaused() {\r\n        _whenSystemNotPaused();\r\n        _;\r\n    }\r\n\r\n    // Check if controller is paused\r\n    modifier whenSystemPaused() {\r\n        _whenSystemPaused();\r\n        _;\r\n    }\r\n\r\n    constructor(address _controller) public {\r\n        controller = IController(_controller);\r\n    }\r\n\r\n    /**\r\n     * @notice Set controller. Only callable by current controller\r\n     * @param _controller Controller contract address\r\n     */\r\n    function setController(address _controller) external onlyController {\r\n        controller = IController(_controller);\r\n\r\n        emit SetController(_controller);\r\n    }\r\n\r\n    function _onlyController() internal view {\r\n        require(msg.sender == address(controller), \"caller must be Controller\");\r\n    }\r\n\r\n    function _onlyControllerOwner() internal view {\r\n        require(msg.sender == controller.owner(), \"caller must be Controller owner\");\r\n    }\r\n\r\n    function _whenSystemNotPaused() internal view {\r\n        require(!controller.paused(), \"system is paused\");\r\n    }\r\n\r\n    function _whenSystemPaused() internal view {\r\n        require(controller.paused(), \"system is not paused\");\r\n    }\r\n}\r\n\r\n// File: contracts/ManagerProxyTarget.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/**\r\n * @title ManagerProxyTarget\r\n * @notice The base contract that target contracts used by a proxy contract should inherit from\r\n * @dev Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee\r\n that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can\r\n potentially break the delegate proxy upgradeability mechanism\r\n */\r\ncontract ManagerProxyTarget is Manager {\r\n    // Used to look up target contract address in controller's registry\r\n    bytes32 public targetContractId;\r\n}\r\n\r\n// File: contracts/bonding/IBondingManager.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/**\r\n * @title Interface for BondingManager\r\n * TODO: switch to interface type\r\n */\r\ncontract IBondingManager {\r\n    event TranscoderUpdate(address indexed transcoder, uint256 rewardCut, uint256 feeShare);\r\n    event TranscoderActivated(address indexed transcoder, uint256 activationRound);\r\n    event TranscoderDeactivated(address indexed transcoder, uint256 deactivationRound);\r\n    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\r\n    event Reward(address indexed transcoder, uint256 amount);\r\n    event Bond(address indexed newDelegate, address indexed oldDelegate, address indexed delegator, uint256 additionalAmount, uint256 bondedAmount);\r\n    event Unbond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\r\n    event Rebond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount);\r\n    event WithdrawStake(address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\r\n    event WithdrawFees(address indexed delegator);\r\n    event EarningsClaimed(address indexed delegate, address indexed delegator, uint256 rewards, uint256 fees, uint256 startRound, uint256 endRound);\r\n\r\n    // Deprecated events\r\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\r\n    // to these deprecated events.\r\n    // event Bond(address indexed delegate, address indexed delegator);\r\n    // event Unbond(address indexed delegate, address indexed delegator);\r\n    // event WithdrawStake(address indexed delegator);\r\n    // event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\r\n    // event TranscoderEvicted(address indexed transcoder);\r\n    // event TranscoderResigned(address indexed transcoder);\r\n\r\n    // External functions\r\n    function updateTranscoderWithFees(address _transcoder, uint256 _fees, uint256 _round) external;\r\n    function slashTranscoder(address _transcoder, address _finder, uint256 _slashAmount, uint256 _finderFee) external;\r\n    function setCurrentRoundTotalActiveStake() external;\r\n\r\n    // Public functions\r\n    function getTranscoderPoolSize() public view returns (uint256);\r\n    function transcoderTotalStake(address _transcoder) public view returns (uint256);\r\n    function isActiveTranscoder(address _transcoder) public view returns (bool);\r\n    function getTotalBonded() public view returns (uint256);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/SortedDoublyLL.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/**\r\n * @title A sorted doubly linked list with nodes sorted in descending order. Optionally accepts insert position hints\r\n *\r\n * Given a new node with a `key`, a hint is of the form `(prevId, nextId)` s.t. `prevId` and `nextId` are adjacent in the list.\r\n * `prevId` is a node with a key >= `key` and `nextId` is a node with a key <= `key`. If the sender provides a hint that is a valid insert position\r\n * the insert operation is a constant time storage write. However, the provided hint in a given transaction might be a valid insert position, but if other transactions are included first, when\r\n * the given transaction is executed the provided hint may no longer be a valid insert position. For example, one of the nodes referenced might be removed or their keys may\r\n * be updated such that the the pair of nodes in the hint no longer represent a valid insert position. If one of the nodes in the hint becomes invalid, we still try to use the other\r\n * valid node as a starting point for finding the appropriate insert position. If both nodes in the hint become invalid, we use the head of the list as a starting point\r\n * to find the appropriate insert position.\r\n */\r\nlibrary SortedDoublyLL {\r\n    using SafeMath for uint256;\r\n\r\n    // Information for a node in the list\r\n    struct Node {\r\n        uint256 key;                     // Node's key used for sorting\r\n        address nextId;                  // Id of next node (smaller key) in the list\r\n        address prevId;                  // Id of previous node (larger key) in the list\r\n    }\r\n\r\n    // Information for the list\r\n    struct Data {\r\n        address head;                        // Head of the list. Also the node in the list with the largest key\r\n        address tail;                        // Tail of the list. Also the node in the list with the smallest key\r\n        uint256 maxSize;                     // Maximum size of the list\r\n        uint256 size;                        // Current size of the list\r\n        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\r\n    }\r\n\r\n    /**\r\n     * @dev Set the maximum size of the list\r\n     * @param _size Maximum size\r\n     */\r\n    function setMaxSize(Data storage self, uint256 _size) public {\r\n        require(_size > self.maxSize, \"new max size must be greater than old max size\");\r\n\r\n        self.maxSize = _size;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a node to the list\r\n     * @param _id Node's id\r\n     * @param _key Node's key\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function insert(Data storage self, address _id, uint256 _key, address _prevId, address _nextId) public {\r\n        // List must not be full\r\n        require(!isFull(self), \"list is full\");\r\n        // List must not already contain node\r\n        require(!contains(self, _id), \"node already in list\");\r\n        // Node id must not be null\r\n        require(_id != address(0), \"node id is null\");\r\n        // Key must be non-zero\r\n        require(_key > 0, \"key is zero\");\r\n\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (!validInsertPosition(self, _key, prevId, nextId)) {\r\n            // Sender's hint was not a valid insert position\r\n            // Use sender's hint to find a valid insert position\r\n            (prevId, nextId) = findInsertPosition(self, _key, prevId, nextId);\r\n        }\r\n\r\n        self.nodes[_id].key = _key;\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // Insert as head and tail\r\n            self.head = _id;\r\n            self.tail = _id;\r\n        } else if (prevId == address(0)) {\r\n            // Insert before `prevId` as the head\r\n            self.nodes[_id].nextId = self.head;\r\n            self.nodes[self.head].prevId = _id;\r\n            self.head = _id;\r\n        } else if (nextId == address(0)) {\r\n            // Insert after `nextId` as the tail\r\n            self.nodes[_id].prevId = self.tail;\r\n            self.nodes[self.tail].nextId = _id;\r\n            self.tail = _id;\r\n        } else {\r\n            // Insert at insert position between `prevId` and `nextId`\r\n            self.nodes[_id].nextId = nextId;\r\n            self.nodes[_id].prevId = prevId;\r\n            self.nodes[prevId].nextId = _id;\r\n            self.nodes[nextId].prevId = _id;\r\n        }\r\n\r\n        self.size = self.size.add(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a node from the list\r\n     * @param _id Node's id\r\n     */\r\n    function remove(Data storage self, address _id) public {\r\n        // List must contain the node\r\n        require(contains(self, _id), \"node not in list\");\r\n\r\n        if (self.size > 1) {\r\n            // List contains more than a single node\r\n            if (_id == self.head) {\r\n                // The removed node is the head\r\n                // Set head to next node\r\n                self.head = self.nodes[_id].nextId;\r\n                // Set prev pointer of new head to null\r\n                self.nodes[self.head].prevId = address(0);\r\n            } else if (_id == self.tail) {\r\n                // The removed node is the tail\r\n                // Set tail to previous node\r\n                self.tail = self.nodes[_id].prevId;\r\n                // Set next pointer of new tail to null\r\n                self.nodes[self.tail].nextId = address(0);\r\n            } else {\r\n                // The removed node is neither the head nor the tail\r\n                // Set next pointer of previous node to the next node\r\n                self.nodes[self.nodes[_id].prevId].nextId = self.nodes[_id].nextId;\r\n                // Set prev pointer of next node to the previous node\r\n                self.nodes[self.nodes[_id].nextId].prevId = self.nodes[_id].prevId;\r\n            }\r\n        } else {\r\n            // List contains a single node\r\n            // Set the head and tail to null\r\n            self.head = address(0);\r\n            self.tail = address(0);\r\n        }\r\n\r\n        delete self.nodes[_id];\r\n        self.size = self.size.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the key of a node in the list\r\n     * @param _id Node's id\r\n     * @param _newKey Node's new key\r\n     * @param _prevId Id of previous node for the new insert position\r\n     * @param _nextId Id of next node for the new insert position\r\n     */\r\n    function updateKey(Data storage self, address _id, uint256 _newKey, address _prevId, address _nextId) public {\r\n        // List must contain the node\r\n        require(contains(self, _id), \"node not in list\");\r\n\r\n        // Remove node from the list\r\n        remove(self, _id);\r\n\r\n        if (_newKey > 0) {\r\n            // Insert node if it has a non-zero key\r\n            insert(self, _id, _newKey, _prevId, _nextId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the list contains a node\r\n     * @param _id Address of transcoder\r\n     * @return true if '_id' is in list\r\n     */\r\n    function contains(Data storage self, address _id) public view returns (bool) {\r\n        // List only contains non-zero keys, so if key is non-zero the node exists\r\n        return self.nodes[_id].key > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the list is full\r\n     * @return true if list is full\r\n     */\r\n    function isFull(Data storage self) public view returns (bool) {\r\n        return self.size == self.maxSize;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the list is empty\r\n     * @return true if list is empty\r\n     */\r\n    function isEmpty(Data storage self) public view returns (bool) {\r\n        return self.size == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current size of the list\r\n     * @return current size of the list\r\n     */\r\n    function getSize(Data storage self) public view returns (uint256) {\r\n        return self.size;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the maximum size of the list\r\n     */\r\n    function getMaxSize(Data storage self) public view returns (uint256) {\r\n        return self.maxSize;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the key of a node in the list\r\n     * @param _id Node's id\r\n     * @return key for node with '_id'\r\n     */\r\n    function getKey(Data storage self, address _id) public view returns (uint256) {\r\n        return self.nodes[_id].key;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the first node in the list (node with the largest key)\r\n     * @return address for the head of the list\r\n     */\r\n    function getFirst(Data storage self) public view returns (address) {\r\n        return self.head;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the last node in the list (node with the smallest key)\r\n     * @return address for the tail of the list\r\n     */\r\n    function getLast(Data storage self) public view returns (address) {\r\n        return self.tail;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next node (with a smaller key) in the list for a given node\r\n     * @param _id Node's id\r\n     * @return address for the node following node in list with '_id'\r\n     */\r\n    function getNext(Data storage self, address _id) public view returns (address) {\r\n        return self.nodes[_id].nextId;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the previous node (with a larger key) in the list for a given node\r\n     * @param _id Node's id\r\n     * address for the node before node in list with '_id'\r\n     */\r\n    function getPrev(Data storage self, address _id) public view returns (address) {\r\n        return self.nodes[_id].prevId;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given key\r\n     * @param _key Node's key\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     * @return if the insert position is valid\r\n     */\r\n    function validInsertPosition(Data storage self, uint256 _key, address _prevId, address _nextId) public view returns (bool) {\r\n        if (_prevId == address(0) && _nextId == address(0)) {\r\n            // `(null, null)` is a valid insert position if the list is empty\r\n            return isEmpty(self);\r\n        } else if (_prevId == address(0)) {\r\n            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\r\n            return self.head == _nextId && _key >= self.nodes[_nextId].key;\r\n        } else if (_nextId == address(0)) {\r\n            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\r\n            return self.tail == _prevId && _key <= self.nodes[_prevId].key;\r\n        } else {\r\n            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_key` falls between the two nodes' keys\r\n            return self.nodes[_prevId].nextId == _nextId && self.nodes[_prevId].key >= _key && _key >= self.nodes[_nextId].key;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Descend the list (larger keys to smaller keys) to find a valid insert position\r\n     * @param _key Node's key\r\n     * @param _startId Id of node to start ascending the list from\r\n     */\r\n    function descendList(Data storage self, uint256 _key, address _startId) private view returns (address, address) {\r\n        // If `_startId` is the head, check if the insert position is before the head\r\n        if (self.head == _startId && _key >= self.nodes[_startId].key) {\r\n            return (address(0), _startId);\r\n        }\r\n\r\n        address prevId = _startId;\r\n        address nextId = self.nodes[prevId].nextId;\r\n\r\n        // Descend the list until we reach the end or until we find a valid insert position\r\n        while (prevId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\r\n            prevId = self.nodes[prevId].nextId;\r\n            nextId = self.nodes[prevId].nextId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /**\r\n     * @dev Ascend the list (smaller keys to larger keys) to find a valid insert position\r\n     * @param _key Node's key\r\n     * @param _startId Id of node to start descending the list from\r\n     */\r\n    function ascendList(Data storage self, uint256 _key, address _startId) private view returns (address, address) {\r\n        // If `_startId` is the tail, check if the insert position is after the tail\r\n        if (self.tail == _startId && _key <= self.nodes[_startId].key) {\r\n            return (_startId, address(0));\r\n        }\r\n\r\n        address nextId = _startId;\r\n        address prevId = self.nodes[nextId].prevId;\r\n\r\n        // Ascend the list until we reach the end or until we find a valid insertion point\r\n        while (nextId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\r\n            nextId = self.nodes[nextId].prevId;\r\n            prevId = self.nodes[nextId].prevId;\r\n        }\r\n\r\n        return (prevId, nextId);\r\n    }\r\n\r\n    /**\r\n     * @dev Find the insert position for a new node with the given key\r\n     * @param _key Node's key\r\n     * @param _prevId Id of previous node for the insert position\r\n     * @param _nextId Id of next node for the insert position\r\n     */\r\n    function findInsertPosition(Data storage self, uint256 _key, address _prevId, address _nextId) private view returns (address, address) {\r\n        address prevId = _prevId;\r\n        address nextId = _nextId;\r\n\r\n        if (prevId != address(0)) {\r\n            if (!contains(self, prevId) || _key > self.nodes[prevId].key) {\r\n                // `prevId` does not exist anymore or now has a smaller key than the given key\r\n                prevId = address(0);\r\n            }\r\n        }\r\n\r\n        if (nextId != address(0)) {\r\n            if (!contains(self, nextId) || _key < self.nodes[nextId].key) {\r\n                // `nextId` does not exist anymore or now has a larger key than the given key\r\n                nextId = address(0);\r\n            }\r\n        }\r\n\r\n        if (prevId == address(0) && nextId == address(0)) {\r\n            // No hint - descend list starting from head\r\n            return descendList(self, _key, self.head);\r\n        } else if (prevId == address(0)) {\r\n            // No `prevId` for hint - ascend list starting from `nextId`\r\n            return ascendList(self, _key, nextId);\r\n        } else if (nextId == address(0)) {\r\n            // No `nextId` for hint - descend list starting from `prevId`\r\n            return descendList(self, _key, prevId);\r\n        } else {\r\n            // Descend list starting from `prevId`\r\n            return descendList(self, _key, prevId);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/MathUtils.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\nlibrary MathUtils {\r\n    using SafeMath for uint256;\r\n\r\n    // Divisor used for representing percentages\r\n    uint256 public constant PERC_DIVISOR = 1000000;\r\n\r\n    /**\r\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\r\n     * @param _amount Amount that is supposed to be a percentage\r\n     */\r\n    function validPerc(uint256 _amount) internal pure returns (bool) {\r\n        return _amount <= PERC_DIVISOR;\r\n    }\r\n\r\n    /**\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage\r\n     * @param _fracDenom Denominator of fraction representing the percentage\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\r\n        return _amount.mul(_fracNum).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute percentage representation of a fraction\r\n     * @param _fracNum Numerator of fraction represeting the percentage\r\n     * @param _fracDenom Denominator of fraction represeting the percentage\r\n     */\r\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\r\n    }\r\n}\r\n\r\n// File: contracts/libraries/PreciseMathUtils.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\nlibrary PreciseMathUtils {\r\n    using SafeMath for uint256;\r\n\r\n    // Divisor used for representing percentages\r\n    uint256 public constant PERC_DIVISOR = 10 ** 27;\r\n\r\n    /**\r\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\r\n     * @param _amount Amount that is supposed to be a percentage\r\n     */\r\n    function validPerc(uint256 _amount) internal pure returns (bool) {\r\n        return _amount <= PERC_DIVISOR;\r\n    }\r\n\r\n    /**\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage\r\n     * @param _fracDenom Denominator of fraction representing the percentage\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\r\n     * @param _amount Amount to take the percentage of\r\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\r\n     */\r\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\r\n        return _amount.mul(_fracNum).div(PERC_DIVISOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Compute percentage representation of a fraction\r\n     * @param _fracNum Numerator of fraction represeting the percentage\r\n     * @param _fracDenom Denominator of fraction represeting the percentage\r\n     */\r\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\r\n        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\r\n    }\r\n}\r\n\r\n// File: contracts/bonding/libraries/EarningsPool.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EarningsPool\r\n * @dev Manages reward and fee pools for delegators and transcoders\r\n */\r\nlibrary EarningsPool {\r\n    using SafeMath for uint256;\r\n\r\n    // Represents rewards and fees to be distributed to delegators\r\n    // The `hasTranscoderRewardFeePool` flag was introduced so that EarningsPool.Data structs used by the BondingManager\r\n    // created with older versions of this library can be differentiated from EarningsPool.Data structs used by the BondingManager\r\n    // created with a newer version of this library. If the flag is true, then the struct was initialized using the `init` function\r\n    // using a newer version of this library meaning that it is using separate transcoder reward and fee pools\r\n    struct Data {\r\n        uint256 rewardPool;                // Delegator rewards. If `hasTranscoderRewardFeePool` is false, this will contain transcoder rewards as well\r\n        uint256 feePool;                   // Delegator fees. If `hasTranscoderRewardFeePool` is false, this will contain transcoder fees as well\r\n        uint256 totalStake;                // Transcoder's total stake during the earnings pool's round\r\n        uint256 claimableStake;            // Stake that can be used to claim portions of the fee and reward pools\r\n        uint256 transcoderRewardCut;       // Transcoder's reward cut during the earnings pool's round\r\n        uint256 transcoderFeeShare;        // Transcoder's fee share during the earnings pool's round\r\n        uint256 transcoderRewardPool;      // Transcoder rewards. If `hasTranscoderRewardFeePool` is false, this should always be 0\r\n        uint256 transcoderFeePool;         // Transcoder fees. If `hasTranscoderRewardFeePool` is false, this should always be 0\r\n        bool hasTranscoderRewardFeePool;   // Flag to indicate if the earnings pool has separate transcoder reward and fee pools\r\n\r\n        // LIP-36 (https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-36.md) fields\r\n        // See EarningsPoolLIP36.sol\r\n        uint256 cumulativeRewardFactor;\r\n        uint256 cumulativeFeeFactor;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets transcoderRewardCut and transcoderFeeshare for an EarningsPool\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _rewardCut Reward cut of transcoder during the earnings pool's round\r\n     * @param _feeShare Fee share of transcoder during the earnings pool's round\r\n     */\r\n    function setCommission(EarningsPool.Data storage earningsPool, uint256 _rewardCut, uint256 _feeShare) internal {\r\n        earningsPool.transcoderRewardCut = _rewardCut;\r\n        earningsPool.transcoderFeeShare = _feeShare;\r\n        // Prior to LIP-36, we set this flag to true here to differentiate between EarningsPool structs created using older versions of this library.\r\n        // When using a version of this library after the introduction of this flag to read an EarningsPool struct created using an older version\r\n        // of this library, this flag should be false in the returned struct because the default value for EVM storage is 0\r\n        // earningsPool.hasTranscoderRewardFeePool = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets totalStake for an EarningsPool\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Total stake of the transcoder during the earnings pool's round\r\n     */\r\n    function setStake(EarningsPool.Data storage earningsPool, uint256 _stake) internal {\r\n        earningsPool.totalStake = _stake;\r\n        // Prior to LIP-36, we also set the claimableStake\r\n        // earningsPool.claimableStake = _stake;\r\n    }\r\n\r\n    /**\r\n     * @dev Return whether this earnings pool has claimable shares i.e. is there unclaimed stake\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     */\r\n    function hasClaimableShares(EarningsPool.Data storage earningsPool) internal view returns (bool) {\r\n        return earningsPool.claimableStake > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the fee pool share for a claimant. If the claimant is a transcoder, include transcoder fees as well.\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Stake of claimant\r\n     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\r\n     */\r\n    function feePoolShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal view returns (uint256) {\r\n        uint256 delegatorFees = 0;\r\n        uint256 transcoderFees = 0;\r\n\r\n        if (earningsPool.hasTranscoderRewardFeePool) {\r\n            (delegatorFees, transcoderFees) = feePoolShareWithTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\r\n        } else {\r\n            (delegatorFees, transcoderFees) = feePoolShareNoTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\r\n        }\r\n\r\n        return delegatorFees.add(transcoderFees);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the reward pool share for a claimant. If the claimant is a transcoder, include transcoder rewards as well.\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Stake of claimant\r\n     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\r\n     */\r\n    function rewardPoolShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal view returns (uint256) {\r\n        uint256 delegatorRewards = 0;\r\n        uint256 transcoderRewards = 0;\r\n\r\n        if (earningsPool.hasTranscoderRewardFeePool) {\r\n            (delegatorRewards, transcoderRewards) = rewardPoolShareWithTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\r\n        } else {\r\n            (delegatorRewards, transcoderRewards) = rewardPoolShareNoTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\r\n        }\r\n\r\n        return delegatorRewards.add(transcoderRewards);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to calculate fee pool share if the earnings pool has a separate transcoder fee pool\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Stake of claimant\r\n     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\r\n     */\r\n    function feePoolShareWithTranscoderRewardFeePool(\r\n        EarningsPool.Data storage earningsPool,\r\n        uint256 _stake,\r\n        bool _isTranscoder\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        // If there is no claimable stake, the fee pool share is 0\r\n        // If there is claimable stake, calculate fee pool share based on remaining amount in fee pool, remaining claimable stake and claimant's stake\r\n        uint256 delegatorFees = earningsPool.claimableStake > 0 ? MathUtils.percOf(earningsPool.feePool, _stake, earningsPool.claimableStake) : 0;\r\n\r\n        // If claimant is a transcoder, include transcoder fee pool as well\r\n        return _isTranscoder ? (delegatorFees, earningsPool.transcoderFeePool) : (delegatorFees, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to calculate reward pool share if the earnings pool has a separate transcoder reward pool\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Stake of claimant\r\n     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\r\n     */\r\n    function rewardPoolShareWithTranscoderRewardFeePool(\r\n        EarningsPool.Data storage earningsPool,\r\n        uint256 _stake,\r\n        bool _isTranscoder\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        // If there is no claimable stake, the reward pool share is 0\r\n        // If there is claimable stake, calculate reward pool share based on remaining amount in reward pool, remaining claimable stake and claimant's stake\r\n        uint256 delegatorRewards = earningsPool.claimableStake > 0 ? MathUtils.percOf(earningsPool.rewardPool, _stake, earningsPool.claimableStake) : 0;\r\n\r\n        // If claimant is a transcoder, include transcoder reward pool as well\r\n        return _isTranscoder ? (delegatorRewards, earningsPool.transcoderRewardPool) : (delegatorRewards, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to calculate the fee pool share if the earnings pool does not have a separate transcoder fee pool\r\n     * This implements calculation logic from a previous version of this library\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Stake of claimant\r\n     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\r\n     */\r\n    function feePoolShareNoTranscoderRewardFeePool(\r\n        EarningsPool.Data storage earningsPool,\r\n        uint256 _stake,\r\n        bool _isTranscoder\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 transcoderFees = 0;\r\n        uint256 delegatorFees = 0;\r\n\r\n        if (earningsPool.claimableStake > 0) {\r\n            uint256 delegatorsFees = MathUtils.percOf(earningsPool.feePool, earningsPool.transcoderFeeShare);\r\n            transcoderFees = earningsPool.feePool.sub(delegatorsFees);\r\n            delegatorFees = MathUtils.percOf(delegatorsFees, _stake, earningsPool.claimableStake);\r\n        }\r\n\r\n        if (_isTranscoder) {\r\n            return (delegatorFees, transcoderFees);\r\n        } else {\r\n            return (delegatorFees, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to calculate the reward pool share if the earnings pool does not have a separate transcoder reward pool\r\n     * This implements calculation logic from a previous version of this library\r\n     * @param earningsPool Storage pointer to EarningsPool struct\r\n     * @param _stake Stake of claimant\r\n     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\r\n     */\r\n    function rewardPoolShareNoTranscoderRewardFeePool(\r\n        EarningsPool.Data storage earningsPool,\r\n        uint256 _stake,\r\n        bool _isTranscoder\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 transcoderRewards = 0;\r\n        uint256 delegatorRewards = 0;\r\n\r\n        if (earningsPool.claimableStake > 0) {\r\n            transcoderRewards = MathUtils.percOf(earningsPool.rewardPool, earningsPool.transcoderRewardCut);\r\n            delegatorRewards = MathUtils.percOf(earningsPool.rewardPool.sub(transcoderRewards), _stake, earningsPool.claimableStake);\r\n        }\r\n\r\n        if (_isTranscoder) {\r\n            return (delegatorRewards, transcoderRewards);\r\n        } else {\r\n            return (delegatorRewards, 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/bonding/libraries/EarningsPoolLIP36.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n\r\nlibrary EarningsPoolLIP36 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @notice Update the cumulative fee factor stored in an earnings pool with new fees\r\n     * @param earningsPool Storage pointer to EarningsPools.Data struct\r\n     * @param _prevEarningsPool In-memory EarningsPool.Data struct that stores the previous cumulative reward and fee factors\r\n     * @param _fees Amount of new fees\r\n     */\r\n    function updateCumulativeFeeFactor(EarningsPool.Data storage earningsPool, EarningsPool.Data memory _prevEarningsPool, uint256 _fees) internal {\r\n        uint256 prevCumulativeFeeFactor = _prevEarningsPool.cumulativeFeeFactor;\r\n        uint256 prevCumulativeRewardFactor = _prevEarningsPool.cumulativeRewardFactor != 0 ? _prevEarningsPool.cumulativeRewardFactor : PreciseMathUtils.percPoints(1, 1);\r\n\r\n        // Initialize the cumulativeFeeFactor when adding fees for the first time\r\n        if (earningsPool.cumulativeFeeFactor == 0) {\r\n            earningsPool.cumulativeFeeFactor = prevCumulativeFeeFactor.add(\r\n                PreciseMathUtils.percOf(prevCumulativeRewardFactor, _fees, earningsPool.totalStake)\r\n            );\r\n            return;\r\n        }\r\n\r\n        earningsPool.cumulativeFeeFactor = earningsPool.cumulativeFeeFactor.add(\r\n            PreciseMathUtils.percOf(prevCumulativeRewardFactor, _fees, earningsPool.totalStake)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update the cumulative reward factor stored in an earnings pool with new rewards\r\n     * @param earningsPool Storage pointer to EarningsPool.Data struct\r\n     * @param _prevEarningsPool Storage pointer to EarningsPool.Data struct that stores the previous cumulative reward factor\r\n     * @param _rewards Amount of new rewards\r\n     */\r\n    function updateCumulativeRewardFactor(EarningsPool.Data storage earningsPool, EarningsPool.Data memory _prevEarningsPool, uint256 _rewards) internal {\r\n        uint256 prevCumulativeRewardFactor = _prevEarningsPool.cumulativeRewardFactor != 0 ? _prevEarningsPool.cumulativeRewardFactor : PreciseMathUtils.percPoints(1, 1);\r\n\r\n        earningsPool.cumulativeRewardFactor = prevCumulativeRewardFactor.add(\r\n            PreciseMathUtils.percOf(prevCumulativeRewardFactor, _rewards, earningsPool.totalStake)\r\n        );\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n// File: contracts/token/ILivepeerToken.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\ncontract ILivepeerToken is ERC20, Ownable {\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n    function burn(uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/token/IMinter.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n/**\r\n * @title Minter interface\r\n */\r\ncontract IMinter {\r\n    // Events\r\n    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\r\n\r\n    // External functions\r\n    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\r\n    function trustedTransferTokens(address _to, uint256 _amount) external;\r\n    function trustedBurnTokens(uint256 _amount) external;\r\n    function trustedWithdrawETH(address payable _to, uint256 _amount) external;\r\n    function depositETH() external payable returns (bool);\r\n    function setCurrentRewardTokens() external;\r\n    function currentMintableTokens() external view returns (uint256);\r\n    function currentMintedTokens() external view returns (uint256);\r\n    // Public functions\r\n    function getController() public view returns (IController);\r\n}\r\n\r\n// File: contracts/rounds/IRoundsManager.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/**\r\n * @title RoundsManager interface\r\n */\r\ncontract IRoundsManager {\r\n    // Events\r\n    event NewRound(uint256 indexed round, bytes32 blockHash);\r\n\r\n    // Deprecated events\r\n    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\r\n    // to these deprecated events.\r\n    // event NewRound(uint256 round)\r\n\r\n    // External functions\r\n    function initializeRound() external;\r\n    function lipUpgradeRound(uint256 _lip) external view returns (uint256);\r\n\r\n    // Public functions\r\n    function blockNum() public view returns (uint256);\r\n    function blockHash(uint256 _block) public view returns (bytes32);\r\n    function blockHashForRound(uint256 _round) public view returns (bytes32);\r\n    function currentRound() public view returns (uint256);\r\n    function currentRoundStartBlock() public view returns (uint256);\r\n    function currentRoundInitialized() public view returns (bool);\r\n    function currentRoundLocked() public view returns (bool);\r\n}\r\n\r\n// File: contracts/snapshots/IMerkleSnapshot.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\ncontract IMerkleSnapshot {\r\n    function verify(bytes32 _id, bytes32[] calldata _proof, bytes32 _leaf) external view returns (bool);\r\n}\r\n\r\n// File: contracts/bonding/BondingManager.sol\r\n\r\npragma solidity 0.5.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BondingManager\r\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\r\n */\r\ncontract BondingManager is ManagerProxyTarget, IBondingManager {\r\n    using SafeMath for uint256;\r\n    using SortedDoublyLL for SortedDoublyLL.Data;\r\n    using EarningsPool for EarningsPool.Data;\r\n    using EarningsPoolLIP36 for EarningsPool.Data;\r\n\r\n    // Constants\r\n    // Occurances are replaced at compile time\r\n    // and computed to a single value if possible by the optimizer\r\n    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\r\n    uint256 constant MAX_LOOKBACK_ROUNDS = 100;\r\n    // PreciseMathUtils.percPoints(1, 1) / MathUtils.percPoints(1, 1) => (10 ** 27) / 1000000\r\n    uint256 constant RESCALE_FACTOR = 10 ** 21;\r\n\r\n    // Time between unbonding and possible withdrawl in rounds\r\n    uint64 public unbondingPeriod;\r\n    // DEPRECATED - DO NOT USE\r\n    uint256 public numActiveTranscodersDEPRECATED;\r\n    // Max number of rounds that a caller can claim earnings for at once\r\n    uint256 public maxEarningsClaimsRounds;\r\n\r\n    // Represents a transcoder's current state\r\n    struct Transcoder {\r\n        uint256 lastRewardRound;                                        // Last round that the transcoder called reward\r\n        uint256 rewardCut;                                              // % of reward paid to transcoder by a delegator\r\n        uint256 feeShare;                                               // % of fees paid to delegators by transcoder\r\n        uint256 pricePerSegmentDEPRECATED;                              // DEPRECATED - DO NOT USE\r\n        uint256 pendingRewardCutDEPRECATED;                             // DEPRECATED - DO NOT USE\r\n        uint256 pendingFeeShareDEPRECATED;                              // DEPRECATED - DO NOT USE\r\n        uint256 pendingPricePerSegmentDEPRECATED;                       // DEPRECATED - DO NOT USE\r\n        mapping (uint256 => EarningsPool.Data) earningsPoolPerRound;    // Mapping of round => earnings pool for the round\r\n        uint256 lastActiveStakeUpdateRound;                             // Round for which the stake was last updated while the transcoder is active\r\n        uint256 activationRound;                                        // Round in which the transcoder became active - 0 if inactive\r\n        uint256 deactivationRound;                                      // Round in which the transcoder will become inactive\r\n        uint256 activeCumulativeRewards;                                // The transcoder's cumulative rewards that are active in the current round\r\n        uint256 cumulativeRewards;                                      // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\r\n        uint256 cumulativeFees;                                         // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\r\n        uint256 lastFeeRound;                                           // Latest round in which the transcoder received fees\r\n    }\r\n\r\n    // The various states a transcoder can be in\r\n    enum TranscoderStatus { NotRegistered, Registered }\r\n\r\n    // Represents a delegator's current state\r\n    struct Delegator {\r\n        uint256 bondedAmount;                    // The amount of bonded tokens\r\n        uint256 fees;                            // The amount of fees collected\r\n        address delegateAddress;                 // The address delegated to\r\n        uint256 delegatedAmount;                 // The amount of tokens delegated to the delegator\r\n        uint256 startRound;                      // The round the delegator transitions to bonded phase and is delegated to someone\r\n        uint256 withdrawRoundDEPRECATED;         // DEPRECATED - DO NOT USE\r\n        uint256 lastClaimRound;                  // The last round during which the delegator claimed its earnings\r\n        uint256 nextUnbondingLockId;             // ID for the next unbonding lock created\r\n        mapping (uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\r\n    }\r\n\r\n    // The various states a delegator can be in\r\n    enum DelegatorStatus { Pending, Bonded, Unbonded }\r\n\r\n    // Represents an amount of tokens that are being unbonded\r\n    struct UnbondingLock {\r\n        uint256 amount;              // Amount of tokens being unbonded\r\n        uint256 withdrawRound;       // Round at which unbonding period is over and tokens can be withdrawn\r\n    }\r\n\r\n    // Keep track of the known transcoders and delegators\r\n    mapping (address => Delegator) private delegators;\r\n    mapping (address => Transcoder) private transcoders;\r\n\r\n    // DEPRECATED - DO NOT USE\r\n    // The function getTotalBonded() no longer uses this variable\r\n    // and instead calculates the total bonded value separately\r\n    uint256 private totalBondedDEPRECATED;\r\n\r\n    // DEPRECATED - DO NOT USE\r\n    SortedDoublyLL.Data private transcoderPoolDEPRECATED;\r\n\r\n    // DEPRECATED - DO NOT USE\r\n    struct ActiveTranscoderSetDEPRECATED {\r\n        address[] transcoders;\r\n        mapping (address => bool) isActive;\r\n        uint256 totalStake;\r\n    }\r\n\r\n    // DEPRECATED - DO NOT USE\r\n    mapping (uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;\r\n\r\n    // The total active stake (sum of the stake of active set members) for the current round\r\n    uint256 public currentRoundTotalActiveStake;\r\n    // The total active stake (sum of the stake of active set members) for the next round\r\n    uint256 public nextRoundTotalActiveStake;\r\n\r\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\r\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\r\n    // in the pool are locked into the active set for round N + 1\r\n    SortedDoublyLL.Data private transcoderPoolV2;\r\n\r\n    // Check if sender is TicketBroker\r\n    modifier onlyTicketBroker() {\r\n        _onlyTicketBroker();\r\n        _;\r\n    }\r\n\r\n    // Check if sender is RoundsManager\r\n    modifier onlyRoundsManager() {\r\n        _onlyRoundsManager();\r\n        _;\r\n    }\r\n\r\n    // Check if sender is Verifier\r\n    modifier onlyVerifier() {\r\n        _onlyVerifier();\r\n        _;\r\n    }\r\n\r\n    // Check if current round is initialized\r\n    modifier currentRoundInitialized() {\r\n        _currentRoundInitialized();\r\n        _;\r\n    }\r\n\r\n    // Automatically claim earnings from lastClaimRound through the current round\r\n    modifier autoClaimEarnings() {\r\n        _autoClaimEarnings();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\r\n     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\r\n     * should be used to initialize state variables post-deployment:\r\n     * - setUnbondingPeriod()\r\n     * - setNumActiveTranscoders()\r\n     * - setMaxEarningsClaimsRounds()\r\n     * @param _controller Address of Controller that this contract will be registered with\r\n     */\r\n    constructor(address _controller) public Manager(_controller) {}\r\n\r\n    /**\r\n     * @notice Set unbonding period. Only callable by Controller owner\r\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\r\n     */\r\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\r\n        unbondingPeriod = _unbondingPeriod;\r\n\r\n        emit ParameterUpdate(\"unbondingPeriod\");\r\n    }\r\n\r\n    /**\r\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\r\n     * @param _numActiveTranscoders Number of active transcoders\r\n     */\r\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\r\n        transcoderPoolV2.setMaxSize(_numActiveTranscoders);\r\n\r\n        emit ParameterUpdate(\"numActiveTranscoders\");\r\n    }\r\n\r\n    /**\r\n     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner\r\n     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once\r\n     */\r\n    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {\r\n        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;\r\n\r\n        emit ParameterUpdate(\"maxEarningsClaimsRounds\");\r\n    }\r\n\r\n    /**\r\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\r\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\r\n     * @param _rewardCut % of reward paid to transcoder by a delegator\r\n     * @param _feeShare % of fees paid to delegators by a transcoder\r\n     */\r\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\r\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate stake towards a specific address\r\n     * @param _amount The amount of tokens to stake\r\n     * @param _to The address of the transcoder to stake towards\r\n     */\r\n    function bond(uint256 _amount, address _to) external {\r\n        bondWithHint(\r\n            _amount,\r\n            _to,\r\n            address(0),\r\n            address(0),\r\n            address(0),\r\n            address(0)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Unbond an amount of the delegator's bonded stake\r\n     * @param _amount Amount of tokens to unbond\r\n     */\r\n    function unbond(uint256 _amount) external {\r\n        unbondWithHint(_amount, address(0), address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\r\n     * @param _unbondingLockId ID of unbonding lock to rebond with\r\n     */\r\n    function rebond(uint256 _unbondingLockId) external {\r\n        rebondWithHint(_unbondingLockId, address(0), address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\r\n     * @param _to Address of delegate\r\n     * @param _unbondingLockId ID of unbonding lock to rebond with\r\n     */\r\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\r\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\r\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\r\n     */\r\n    function withdrawStake(uint256 _unbondingLockId)\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n    {\r\n        Delegator storage del = delegators[msg.sender];\r\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\r\n\r\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), \"invalid unbonding lock ID\");\r\n        require(lock.withdrawRound <= roundsManager().currentRound(), \"withdraw round must be before or equal to the current round\");\r\n\r\n        uint256 amount = lock.amount;\r\n        uint256 withdrawRound = lock.withdrawRound;\r\n        // Delete unbonding lock\r\n        delete del.unbondingLocks[_unbondingLockId];\r\n\r\n        // Tell Minter to transfer stake (LPT) to the delegator\r\n        minter().trustedTransferTokens(msg.sender, amount);\r\n\r\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws fees to the caller\r\n     */\r\n    function withdrawFees()\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        uint256 fees = delegators[msg.sender].fees;\r\n        require(fees > 0, \"no fees to withdraw\");\r\n        delegators[msg.sender].fees = 0;\r\n\r\n        // Tell Minter to transfer fees (ETH) to the delegator\r\n        minter().trustedWithdrawETH(msg.sender, fees);\r\n\r\n        emit WithdrawFees(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint token rewards for an active transcoder and its delegators\r\n     */\r\n    function reward() external {\r\n        rewardWithHint(address(0), address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\r\n     * @param _transcoder Transcoder address\r\n     * @param _fees Fees to be added to the fee pool\r\n     */\r\n    function updateTranscoderWithFees(\r\n        address _transcoder,\r\n        uint256 _fees,\r\n        uint256 _round\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        onlyTicketBroker\r\n    {\r\n        // Silence unused param compiler warning\r\n        _round;\r\n\r\n        require(isRegisteredTranscoder(_transcoder), \"transcoder must be registered\");\r\n\r\n        uint256 currentRound = roundsManager().currentRound();\r\n\r\n        Transcoder storage t = transcoders[_transcoder];\r\n\r\n        uint256 lastRewardRound = t.lastRewardRound;\r\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\r\n\r\n        // LIP-36: Add fees for the current round instead of '_round'\r\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\r\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\r\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\r\n\r\n        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\r\n        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\r\n        // for cumulative fee calculation this would result in division by zero.\r\n        if (currentRound > lastRewardRound) {\r\n            earningsPool.setCommission(\r\n                t.rewardCut,\r\n                t.feeShare\r\n            );\r\n\r\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\r\n            if (lastUpdateRound < currentRound) {\r\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\r\n            }\r\n\r\n            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\r\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\r\n            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\r\n            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\r\n            activeCumulativeRewards = t.cumulativeRewards;\r\n        }\r\n\r\n        uint256 totalStake = earningsPool.totalStake;\r\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\r\n            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\r\n            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\r\n            // based on rewards for currentRound\r\n            IMinter mtr = minter();\r\n            uint256 rewards = PreciseMathUtils.percOf(mtr.currentMintableTokens().add(mtr.currentMintedTokens()), totalStake, currentRoundTotalActiveStake);\r\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\r\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\r\n\r\n            prevEarningsPool.cumulativeRewardFactor = PreciseMathUtils.percOf(\r\n                earningsPool.cumulativeRewardFactor,\r\n                totalStake,\r\n                delegatorsRewards.add(totalStake)\r\n            );\r\n        }\r\n\r\n        // If the previous cumulativeRewardFactor is 0 and the current round is before the LIP-71 round, set the default value to\r\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) when storing for\r\n        // the LIP-71 round and onwards (see updateCumulativeFeeFactor() in EarningsPoolLIP36.sol)\r\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && currentRound < roundsManager().lipUpgradeRound(71)) {\r\n            prevEarningsPool.cumulativeRewardFactor = MathUtils.percPoints(1, 1);\r\n        }\r\n\r\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\r\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\r\n        // Calculate the fees earned by the transcoder's earned rewards\r\n        uint256 transcoderRewardStakeFees = PreciseMathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);\r\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\r\n        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\r\n        // Update cumulative fee factor with new fees\r\n        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\r\n        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\r\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field\r\n        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\r\n\r\n        t.lastFeeRound = currentRound;\r\n    }\r\n\r\n    /**\r\n     * @notice Slash a transcoder. Only callable by the Verifier\r\n     * @param _transcoder Transcoder address\r\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\r\n     * @param _slashAmount Percentage of transcoder bond to be slashed\r\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\r\n     */\r\n    function slashTranscoder(\r\n        address _transcoder,\r\n        address _finder,\r\n        uint256 _slashAmount,\r\n        uint256 _finderFee\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        onlyVerifier\r\n    {\r\n        Delegator storage del = delegators[_transcoder];\r\n\r\n        if (del.bondedAmount > 0) {\r\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\r\n\r\n            // If active transcoder, resign it\r\n            if (transcoderPoolV2.contains(_transcoder)) {\r\n                resignTranscoder(_transcoder);\r\n            }\r\n\r\n            // Decrease bonded stake\r\n            del.bondedAmount = del.bondedAmount.sub(penalty);\r\n\r\n            // If still bonded decrease delegate's delegated amount\r\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\r\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(penalty);\r\n            }\r\n\r\n            // Account for penalty\r\n            uint256 burnAmount = penalty;\r\n\r\n            // Award finder fee if there is a finder address\r\n            if (_finder != address(0)) {\r\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\r\n                minter().trustedTransferTokens(_finder, finderAmount);\r\n\r\n                // Minter burns the slashed funds - finder reward\r\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\r\n\r\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\r\n            } else {\r\n                // Minter burns the slashed funds\r\n                minter().trustedBurnTokens(burnAmount);\r\n\r\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\r\n            }\r\n        } else {\r\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\r\n     * @param _endRound The last round for which to claim token pools shares for a delegator\r\n     */\r\n    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {\r\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\r\n        require(lastClaimRound < _endRound, \"end round must be after last claim round\");\r\n        // _endRound should be equal to the current round because after LIP-36 using a past _endRound can result\r\n        // in incorrect cumulative factor values used/stored for the _endRound in updateDelegatorWithEarnings().\r\n        // The exception is when claiming through an _endRound before the LIP-36 upgrade round because cumulative factor\r\n        // values will not be used/stored in updateDelegatorWithEarnings() before the LIP-36 upgrade round.\r\n        require(\r\n            _endRound == roundsManager().currentRound() || _endRound < roundsManager().lipUpgradeRound(36),\r\n            \"end round must be equal to the current round or before the LIP-36 upgrade round\"\r\n        );\r\n\r\n        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52\r\n     * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md\r\n     * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)\r\n     * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)\r\n     * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root\r\n     * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings\r\n     */\r\n    function claimSnapshotEarnings(\r\n        uint256 _pendingStake,\r\n        uint256 _pendingFees,\r\n        bytes32[] calldata _earningsProof,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n    {\r\n        Delegator storage del = delegators[msg.sender];\r\n\r\n        uint256 lip52Round = roundsManager().lipUpgradeRound(52);\r\n\r\n        uint256 lastClaimRound = del.lastClaimRound;\r\n\r\n        require(lastClaimRound < lip52Round, \"Already claimed for LIP-52\");\r\n\r\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));\r\n\r\n        require(\r\n            IMerkleSnapshot(controller.getContract(keccak256(\"MerkleSnapshot\"))).verify(keccak256(\"LIP-52\"), _earningsProof, leaf),\r\n            \"Merkle proof is invalid\"\r\n        );\r\n\r\n        emit EarningsClaimed(\r\n            del.delegateAddress,\r\n            msg.sender,\r\n            _pendingStake.sub(del.bondedAmount),\r\n            _pendingFees.sub(del.fees),\r\n            lastClaimRound.add(1),\r\n            lip52Round\r\n        );\r\n\r\n        del.lastClaimRound = lip52Round;\r\n        del.bondedAmount = _pendingStake;\r\n        del.fees = _pendingFees;\r\n\r\n        // allow for execution of subsequent claiming or staking operations\r\n        if (_data.length > 0) {\r\n            (bool success, bytes memory returnData) = address(this).delegatecall(_data);\r\n            require(success, string(returnData));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\r\n     */\r\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\r\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\r\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\r\n     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will\r\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\r\n     * See SortedDoublyLL.sol for details on list hints\r\n     * @param _rewardCut % of reward paid to transcoder by a delegator\r\n     * @param _feeShare % of fees paid to delegators by a transcoder\r\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\r\n     */\r\n    function transcoderWithHint(uint256 _rewardCut, uint256 _feeShare, address _newPosPrev, address _newPosNext)\r\n        public\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n    {\r\n        require(\r\n            !roundsManager().currentRoundLocked(),\r\n            \"can't update transcoder params, current round is locked\"\r\n        );\r\n        require(MathUtils.validPerc(_rewardCut), \"invalid rewardCut percentage\");\r\n        require(MathUtils.validPerc(_feeShare), \"invalid feeShare percentage\");\r\n        require(isRegisteredTranscoder(msg.sender), \"transcoder must be registered\");\r\n\r\n        Transcoder storage t = transcoders[msg.sender];\r\n        uint256 currentRound = roundsManager().currentRound();\r\n\r\n        require(\r\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\r\n            \"caller can't be active or must have already called reward for the current round\"\r\n        );\r\n\r\n        t.rewardCut = _rewardCut;\r\n        t.feeShare = _feeShare;\r\n\r\n        if (!transcoderPoolV2.contains(msg.sender)) {\r\n            tryToJoinActiveSet(msg.sender, delegators[msg.sender].delegatedAmount, currentRound.add(1), _newPosPrev, _newPosNext);\r\n        }\r\n\r\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed\r\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\r\n     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\r\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\r\n     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\r\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\r\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\r\n     * @param _amount The amount of tokens to stake.\r\n     * @param _to The address of the transcoder to stake towards\r\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\r\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\r\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\r\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\r\n     */\r\n    function bondWithHint(\r\n        uint256 _amount,\r\n        address _to,\r\n        address _oldDelegateNewPosPrev,\r\n        address _oldDelegateNewPosNext,\r\n        address _currDelegateNewPosPrev,\r\n        address _currDelegateNewPosNext\r\n    )\r\n        public\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        Delegator storage del = delegators[msg.sender];\r\n\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        // Amount to delegate\r\n        uint256 delegationAmount = _amount;\r\n        // Current delegate\r\n        address currentDelegate = del.delegateAddress;\r\n\r\n        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {\r\n            // New delegate\r\n            // Set start round\r\n            // Don't set start round if delegator is in pending state because the start round would not change\r\n            del.startRound = currentRound.add(1);\r\n            // Unbonded state = no existing delegate and no bonded stake\r\n            // Thus, delegation amount = provided amount\r\n        } else if (currentDelegate != address(0) && currentDelegate != _to) {\r\n            // A registered transcoder cannot delegate its bonded stake toward another address\r\n            // because it can only be delegated toward itself\r\n            // In the future, if delegation towards another registered transcoder as an already\r\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\r\n            // could be removed\r\n            require(!isRegisteredTranscoder(msg.sender), \"registered transcoders can't delegate towards other addresses\");\r\n            // Changing delegate\r\n            // Set start round\r\n            del.startRound = currentRound.add(1);\r\n            // Update amount to delegate with previous delegation amount\r\n            delegationAmount = delegationAmount.add(del.bondedAmount);\r\n\r\n            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\r\n        }\r\n\r\n        Transcoder storage newDelegate = transcoders[_to];\r\n        EarningsPool.Data storage currPool = newDelegate.earningsPoolPerRound[currentRound];\r\n        if (currPool.cumulativeRewardFactor == 0) {\r\n            currPool.cumulativeRewardFactor = newDelegate.earningsPoolPerRound[newDelegate.lastRewardRound].cumulativeRewardFactor;\r\n        }\r\n        if (currPool.cumulativeFeeFactor == 0) {\r\n            currPool.cumulativeFeeFactor = newDelegate.earningsPoolPerRound[newDelegate.lastFeeRound].cumulativeFeeFactor;\r\n        }\r\n\r\n        // cannot delegate to someone without having bonded stake\r\n        require(delegationAmount > 0, \"delegation amount must be greater than 0\");\r\n        // Update delegate\r\n        del.delegateAddress = _to;\r\n        // Update bonded amount\r\n        del.bondedAmount = del.bondedAmount.add(_amount);\r\n\r\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\r\n\r\n        if (_amount > 0) {\r\n            // Transfer the LPT to the Minter\r\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\r\n        }\r\n\r\n        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed\r\n     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the\r\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\r\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\r\n     * @param _amount Amount of tokens to unbond\r\n     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\r\n     */\r\n    function unbondWithHint(uint256 _amount, address _newPosPrev, address _newPosNext)\r\n        public\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, \"caller must be bonded\");\r\n\r\n        Delegator storage del = delegators[msg.sender];\r\n\r\n        require(_amount > 0, \"unbond amount must be greater than 0\");\r\n        require(_amount <= del.bondedAmount, \"amount is greater than bonded amount\");\r\n\r\n        address currentDelegate = del.delegateAddress;\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        uint256 withdrawRound = currentRound.add(unbondingPeriod);\r\n        uint256 unbondingLockId = del.nextUnbondingLockId;\r\n\r\n        // Create new unbonding lock\r\n        del.unbondingLocks[unbondingLockId] = UnbondingLock({\r\n            amount: _amount,\r\n            withdrawRound: withdrawRound\r\n        });\r\n        // Increment ID for next unbonding lock\r\n        del.nextUnbondingLockId = unbondingLockId.add(1);\r\n        // Decrease delegator's bonded amount\r\n        del.bondedAmount = del.bondedAmount.sub(_amount);\r\n\r\n        if (del.bondedAmount == 0) {\r\n            // Delegator no longer delegated to anyone if it does not have a bonded amount\r\n            del.delegateAddress = address(0);\r\n            // Delegator does not have a start round if it is no longer delegated to anyone\r\n            del.startRound = 0;\r\n\r\n            if (transcoderPoolV2.contains(msg.sender)) {\r\n                resignTranscoder(msg.sender);\r\n            }\r\n        }\r\n\r\n        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount\r\n        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);\r\n\r\n        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);\r\n    }\r\n\r\n    /**\r\n     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates\r\n     * the transcoder pool using an optional list hint if needed\r\n     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\r\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\r\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\r\n     * @param _unbondingLockId ID of unbonding lock to rebond with\r\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool\r\n     */\r\n    function rebondWithHint(\r\n        uint256 _unbondingLockId,\r\n        address _newPosPrev,\r\n        address _newPosNext\r\n    )\r\n        public\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, \"caller must be bonded\");\r\n\r\n        // Process rebond using unbonding lock\r\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\r\n    }\r\n\r\n    /**\r\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using\r\n     * an optional list hint if needed\r\n     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\r\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\r\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\r\n     * @param _to Address of delegate\r\n     * @param _unbondingLockId ID of unbonding lock to rebond with\r\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool\r\n     */\r\n    function rebondFromUnbondedWithHint(\r\n        address _to,\r\n        uint256 _unbondingLockId,\r\n        address _newPosPrev,\r\n        address _newPosNext\r\n    )\r\n        public\r\n        whenSystemNotPaused\r\n        currentRoundInitialized\r\n        autoClaimEarnings\r\n    {\r\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, \"caller must be unbonded\");\r\n\r\n        // Set delegator's start round and transition into Pending state\r\n        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);\r\n        // Set delegator's delegate\r\n        delegators[msg.sender].delegateAddress = _to;\r\n        // Process rebond using unbonding lock\r\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed\r\n     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the\r\n     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\r\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\r\n     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool\r\n     */\r\n    function rewardWithHint(address _newPosPrev, address _newPosNext) public whenSystemNotPaused currentRoundInitialized {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n\r\n        require(isActiveTranscoder(msg.sender), \"caller must be an active transcoder\");\r\n        require(transcoders[msg.sender].lastRewardRound != currentRound, \"caller has already called reward for the current round\");\r\n\r\n        Transcoder storage t = transcoders[msg.sender];\r\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\r\n\r\n        // Set last round that transcoder called reward\r\n        earningsPool.setCommission(t.rewardCut, t.feeShare);\r\n\r\n        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round\r\n        // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized\r\n        // Thus we sync the the transcoder's stake to when it was last updated\r\n        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently\r\n        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\r\n        if (lastUpdateRound < currentRound) {\r\n            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\r\n        }\r\n\r\n        // Create reward based on active transcoder's stake relative to the total active stake\r\n        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\r\n        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);\r\n\r\n        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);\r\n\r\n        // Set last round that transcoder called reward\r\n        t.lastRewardRound = currentRound;\r\n\r\n        emit Reward(msg.sender, rewardTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round\r\n     * @param _delegator Address of delegator\r\n     * @param _endRound The last round to compute pending stake from\r\n     * @return Pending bonded stake for '_delegator' since last claiming rewards\r\n     */\r\n    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\r\n        // _endRound should be equal to the current round because after LIP-36 using a past _endRound can result\r\n        // in incorrect cumulative factor values used for the _endRound in pendingStakeAndFees().\r\n        // The exception is when calculating stake through an _endRound before the LIP-36 upgrade round because cumulative factor\r\n        // values will not be used in pendingStakeAndFees() before the LIP-36 upgrade round.\r\n        uint256 endRound = _endRound;\r\n        if (endRound >= roundsManager().lipUpgradeRound(36)) {\r\n            endRound = roundsManager().currentRound();\r\n        }\r\n\r\n        (\r\n            uint256 stake,\r\n        ) = pendingStakeAndFees(_delegator, endRound);\r\n        return stake;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round\r\n     * @param _delegator Address of delegator\r\n     * @param _endRound The last round to compute pending fees from\r\n     * @return Pending fees for '_delegator' since last claiming fees\r\n     */\r\n    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\r\n        // _endRound should be equal to the current round because after LIP-36 using a past _endRound can result\r\n        // in incorrect cumulative factor values used for the _endRound in pendingStakeAndFees().\r\n        // The exception is when calculating fees through an _endRound before the LIP-36 upgrade round because cumulative factor\r\n        // values will not be used in pendingStakeAndFees() before the LIP-36 upgrade round.\r\n        uint256 endRound = _endRound;\r\n        if (endRound >= roundsManager().lipUpgradeRound(36)) {\r\n            endRound = roundsManager().currentRound();\r\n        }\r\n\r\n        (\r\n            ,\r\n            uint256 fees\r\n        ) = pendingStakeAndFees(_delegator, endRound);\r\n        return fees;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total bonded stake for a transcoder\r\n     * @param _transcoder Address of transcoder\r\n     * @return total bonded stake for a delegator\r\n     */\r\n    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\r\n        return delegators[_transcoder].delegatedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes transcoder status\r\n     * @param _transcoder Address of transcoder\r\n     * @return registered or not registered transcoder status\r\n     */\r\n    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\r\n        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;\r\n        return TranscoderStatus.NotRegistered;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes delegator status\r\n     * @param _delegator Address of delegator\r\n     * @return bonded, unbonded or pending delegator status\r\n     */\r\n    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\r\n        Delegator storage del = delegators[_delegator];\r\n\r\n        if (del.bondedAmount == 0) {\r\n            // Delegator unbonded all its tokens\r\n            return DelegatorStatus.Unbonded;\r\n        } else if (del.startRound > roundsManager().currentRound()) {\r\n            // Delegator round start is in the future\r\n            return DelegatorStatus.Pending;\r\n        } else {\r\n            // Delegator round start is now or in the past\r\n            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\r\n            // would trigger the first if clause\r\n            return DelegatorStatus.Bonded;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Return transcoder information\r\n     * @param _transcoder Address of transcoder\r\n     * @return lastRewardRound Trancoder's last reward round\r\n     * @return rewardCut Transcoder's reward cut\r\n     * @return feeShare Transcoder's fee share\r\n     * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active\r\n     * @return activationRound Round in which transcoder became active\r\n     * @return deactivationRound Round in which transcoder will no longer be active\r\n     * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active\r\n     * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)\r\n     * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)\r\n     * @return lastFeeRound Latest round that the transcoder received fees\r\n     */\r\n    function getTranscoder(\r\n        address _transcoder\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 lastRewardRound, uint256 rewardCut, uint256 feeShare, uint256 lastActiveStakeUpdateRound, uint256 activationRound, uint256 deactivationRound, uint256 activeCumulativeRewards, uint256 cumulativeRewards, uint256 cumulativeFees, uint256 lastFeeRound)\r\n    {\r\n        Transcoder storage t = transcoders[_transcoder];\r\n\r\n        lastRewardRound = t.lastRewardRound;\r\n        rewardCut = t.rewardCut;\r\n        feeShare = t.feeShare;\r\n        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;\r\n        activationRound = t.activationRound;\r\n        deactivationRound = t.deactivationRound;\r\n        activeCumulativeRewards = t.activeCumulativeRewards;\r\n        cumulativeRewards = t.cumulativeRewards;\r\n        cumulativeFees = t.cumulativeFees;\r\n        lastFeeRound = t.lastFeeRound;\r\n    }\r\n\r\n    /**\r\n     * @notice Return transcoder's earnings pool for a given round\r\n     * @param _transcoder Address of transcoder\r\n     * @param _round Round number\r\n     * @return rewardPool Reward pool for delegators (only used before LIP-36)\r\n     * @return feePool Fee pool for delegators (only used before LIP-36)\r\n     * @return totalStake Transcoder's total stake in '_round'\r\n     * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)\r\n     * @return transcoderRewardCut Transcoder's reward cut for '_round'\r\n     * @return transcoderFeeShare Transcoder's fee share for '_round'\r\n     * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)\r\n     * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)\r\n     * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)\r\n     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)\r\n     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)\r\n     */\r\n    function getTranscoderEarningsPoolForRound(\r\n        address _transcoder,\r\n        uint256 _round\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 rewardPool, uint256 feePool, uint256 totalStake, uint256 claimableStake, uint256 transcoderRewardCut, uint256 transcoderFeeShare, uint256 transcoderRewardPool, uint256 transcoderFeePool, bool hasTranscoderRewardFeePool, uint256 cumulativeRewardFactor, uint256 cumulativeFeeFactor)\r\n    {\r\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\r\n\r\n        rewardPool = earningsPool.rewardPool;\r\n        feePool = earningsPool.feePool;\r\n        totalStake = earningsPool.totalStake;\r\n        claimableStake = earningsPool.claimableStake;\r\n        transcoderRewardCut = earningsPool.transcoderRewardCut;\r\n        transcoderFeeShare = earningsPool.transcoderFeeShare;\r\n        transcoderRewardPool = earningsPool.transcoderRewardPool;\r\n        transcoderFeePool = earningsPool.transcoderFeePool;\r\n        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;\r\n        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;\r\n        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;\r\n    }\r\n\r\n    /**\r\n     * @notice Return delegator info\r\n     * @param _delegator Address of delegator\r\n     * @return total amount bonded by '_delegator'\r\n     * @return amount of fees collected by '_delegator'\r\n     * @return address '_delegator' has bonded to\r\n     * @return total amount delegated to '_delegator'\r\n     * @return round in which bond for '_delegator' became effective\r\n     * @return round for which '_delegator' has last claimed earnings\r\n     * @return ID for the next unbonding lock created for '_delegator'\r\n     */\r\n    function getDelegator(\r\n        address _delegator\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 bondedAmount, uint256 fees, address delegateAddress, uint256 delegatedAmount, uint256 startRound, uint256 lastClaimRound, uint256 nextUnbondingLockId)\r\n    {\r\n        Delegator storage del = delegators[_delegator];\r\n\r\n        bondedAmount = del.bondedAmount;\r\n        fees = del.fees;\r\n        delegateAddress = del.delegateAddress;\r\n        delegatedAmount = del.delegatedAmount;\r\n        startRound = del.startRound;\r\n        lastClaimRound = del.lastClaimRound;\r\n        nextUnbondingLockId = del.nextUnbondingLockId;\r\n    }\r\n\r\n    /**\r\n     * @notice Return delegator's unbonding lock info\r\n     * @param _delegator Address of delegator\r\n     * @param _unbondingLockId ID of unbonding lock\r\n     * @return amount of stake locked up by unbonding lock\r\n     * @return round in which 'amount' becomes available for withdrawal\r\n     */\r\n    function getDelegatorUnbondingLock(\r\n        address _delegator,\r\n        uint256 _unbondingLockId\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 amount, uint256 withdrawRound)\r\n    {\r\n        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];\r\n\r\n        return (lock.amount, lock.withdrawRound);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns max size of transcoder pool\r\n     * @return transcoder pool max size\r\n     */\r\n    function getTranscoderPoolMaxSize() public view returns (uint256) {\r\n        return transcoderPoolV2.getMaxSize();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns size of transcoder pool\r\n     * @return transcoder pool current size\r\n     */\r\n    function getTranscoderPoolSize() public view returns (uint256) {\r\n        return transcoderPoolV2.getSize();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns transcoder with most stake in pool\r\n     * @return address for transcoder with highest stake in transcoder pool\r\n     */\r\n    function getFirstTranscoderInPool() public view returns (address) {\r\n        return transcoderPoolV2.getFirst();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns next transcoder in pool for a given transcoder\r\n     * @param _transcoder Address of a transcoder in the pool\r\n     * @return address for the transcoder after '_transcoder' in transcoder pool\r\n     */\r\n    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\r\n        return transcoderPoolV2.getNext(_transcoder);\r\n    }\r\n\r\n    /**\r\n     * @notice Return total bonded tokens\r\n     * @return total active stake for the current round\r\n     */\r\n    function getTotalBonded() public view returns (uint256) {\r\n        return currentRoundTotalActiveStake;\r\n    }\r\n\r\n   /**\r\n     * @notice Return whether a transcoder is active for the current round\r\n     * @param _transcoder Transcoder address\r\n     * @return true if transcoder is active\r\n     */\r\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\r\n        Transcoder storage t = transcoders[_transcoder];\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\r\n    }\r\n\r\n    /**\r\n     * @notice Return whether a transcoder is registered\r\n     * @param _transcoder Transcoder address\r\n     * @return true if transcoder is self-bonded\r\n     */\r\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\r\n        Delegator storage d = delegators[_transcoder];\r\n        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Return whether an unbonding lock for a delegator is valid\r\n     * @param _delegator Address of delegator\r\n     * @param _unbondingLockId ID of unbonding lock\r\n     * @return true if unbondingLock for ID has a non-zero withdraw round\r\n     */\r\n    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\r\n        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\r\n        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Return an EarningsPool.Data struct with cumulative factors for a given round that are rescaled if needed\r\n     * @param _transcoder Storage pointer to a transcoder struct\r\n     * @param _round The round to fetch the cumulative factors for\r\n     */\r\n    function cumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round) internal view returns (EarningsPool.Data memory pool) {\r\n        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;\r\n        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;\r\n\r\n        uint256 lip71Round = roundsManager().lipUpgradeRound(71);\r\n        // If we are at or after the LIP-71 round then all cumulative factor values should be scaled using PreciseMathUtils.percPoints(1, 1)\r\n        // If a cumulative factor was stored before the LIP-71 round it will still be scaled using MathUtils.percPoints(1, 1)\r\n        // So, once we are at or after the LIP-71 round, if we read a cumulative factor for a round before the LIP-71 round, we rescale\r\n        // the value by RESCALE_FACTOR so that the end value is scaled by PreciseMathUtils.percPoints(1, 1)\r\n        if (roundsManager().currentRound() >= lip71Round && _round < lip71Round) {\r\n            pool.cumulativeRewardFactor = pool.cumulativeRewardFactor.mul(RESCALE_FACTOR);\r\n            pool.cumulativeFeeFactor = pool.cumulativeFeeFactor.mul(RESCALE_FACTOR);\r\n        }\r\n\r\n        return pool;\r\n    }\r\n\r\n    /**\r\n     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round\r\n     * @param _transcoder Storage pointer to a transcoder struct\r\n     * @param _round The round to fetch the latest cumulative factors for\r\n     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round\r\n     */\r\n    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round) internal view returns (EarningsPool.Data memory pool) {\r\n        pool = cumulativeFactorsPool(_transcoder, _round);\r\n\r\n        uint256 lastRewardRound = _transcoder.lastRewardRound;\r\n        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round\r\n        if (pool.cumulativeRewardFactor == 0 && lastRewardRound < _round) {\r\n            pool.cumulativeRewardFactor = cumulativeFactorsPool(_transcoder, lastRewardRound).cumulativeRewardFactor;\r\n        }\r\n\r\n        uint256 lastFeeRound = _transcoder.lastFeeRound;\r\n        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round\r\n        if (pool.cumulativeFeeFactor == 0 && lastFeeRound < _round) {\r\n            pool.cumulativeFeeFactor = cumulativeFactorsPool(_transcoder, lastFeeRound).cumulativeFeeFactor;\r\n        }\r\n\r\n        return pool;\r\n    }\r\n\r\n    /**\r\n     * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm\r\n     * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate\r\n     * @param _startRound The round for the start cumulative factors\r\n     * @param _endRound The round for the end cumulative factors\r\n     * @param _stake The delegator's initial stake before including earned rewards\r\n     * @param _fees The delegator's initial fees before including earned fees\r\n     * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees\r\n     */\r\n    function delegatorCumulativeStakeAndFees(\r\n        Transcoder storage _transcoder,\r\n        uint256 _startRound,\r\n        uint256 _endRound,\r\n        uint256 _stake,\r\n        uint256 _fees\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256 cStake, uint256 cFees)\r\n    {\r\n        // Fetch start cumulative factors\r\n        EarningsPool.Data memory startPool = cumulativeFactorsPool(_transcoder, _startRound);\r\n\r\n        // We can lookback for a cumulativeRewardFactor if the start cumulativeRewardFactor is 0\r\n        // Do not lookback if the latest cumulativeRewardFactor is 0 because that indicates that the factor was never > 0 for the transcoder in the past\r\n        bool lookbackCumulativeRewardFactor = _transcoder.earningsPoolPerRound[_transcoder.lastRewardRound].cumulativeRewardFactor > 0 && startPool.cumulativeRewardFactor == 0;\r\n        // We can lookback for a cumulativeFeeFactor if the start cumulativeFeeFactor is 0\r\n        // Do not lookback if the latest cumulativeFeeFactor is 0 because that indicates that the factor was never > 0 for the transcoder in the past\r\n        bool lookbackCumulativeFeeFactor = _transcoder.earningsPoolPerRound[_transcoder.lastFeeRound].cumulativeFeeFactor > 0 && startPool.cumulativeFeeFactor == 0;\r\n        // The lookback loop will only be needed for a few accounts delegated to transcoders before the update that ensures start factors are always initialized\r\n        // If we need a cumulativeRewardFactor OR cumulativeFeeFactor lookback up to min(MAX_LOOKBACK_ROUNDS, _startRound) # of rounds\r\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\r\n        for (uint256 lookback = 1; lookback <= MAX_LOOKBACK_ROUNDS && lookback <= _startRound && (lookbackCumulativeRewardFactor || lookbackCumulativeFeeFactor); lookback++) {\r\n            uint256 lookbackRound = _startRound.sub(lookback);\r\n            // Cannot lookback past the LIP-36 upgrade round\r\n            if (lookbackRound < lip36Round) {\r\n                break;\r\n            }\r\n\r\n            EarningsPool.Data storage pool = _transcoder.earningsPoolPerRound[lookbackRound];\r\n            // Short-circuit in the following conditionals by running the boolean check before the storage check\r\n            if (lookbackCumulativeRewardFactor && pool.cumulativeRewardFactor > 0) {\r\n                startPool.cumulativeRewardFactor = cumulativeFactorsPool(_transcoder, lookbackRound).cumulativeRewardFactor;\r\n                lookbackCumulativeRewardFactor = false;\r\n            }\r\n            if (lookbackCumulativeFeeFactor && pool.cumulativeFeeFactor > 0) {\r\n                startPool.cumulativeFeeFactor = cumulativeFactorsPool(_transcoder, lookbackRound).cumulativeFeeFactor;\r\n                lookbackCumulativeFeeFactor = false;\r\n            }\r\n        }\r\n\r\n        // If the start cumulativeRewardFactor is 0 and we are before the LIP-71 round, set the default value to\r\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) from LIP-71 round\r\n        // and onward\r\n        if (startPool.cumulativeRewardFactor == 0) {\r\n            startPool.cumulativeRewardFactor = roundsManager().currentRound() < roundsManager().lipUpgradeRound(71) ?\r\n                MathUtils.percPoints(1, 1) : PreciseMathUtils.percPoints(1, 1);\r\n        }\r\n\r\n        // Fetch end cumulative factors\r\n        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);\r\n\r\n        // If the end cumulativeRewardFactor is 0 and we are before the LIP-71 round, set the default value to\r\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) from LIP-71 round\r\n        // and onward\r\n        if (endPool.cumulativeRewardFactor == 0) {\r\n            endPool.cumulativeRewardFactor = roundsManager().currentRound() < roundsManager().lipUpgradeRound(71) ?\r\n                MathUtils.percPoints(1, 1) : PreciseMathUtils.percPoints(1, 1);\r\n        }\r\n\r\n        cFees = _fees.add(\r\n            PreciseMathUtils.percOf(\r\n                _stake,\r\n                endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),\r\n                startPool.cumulativeRewardFactor\r\n            )\r\n        );\r\n\r\n        cStake = PreciseMathUtils.percOf(\r\n            _stake,\r\n            endPool.cumulativeRewardFactor,\r\n            startPool.cumulativeRewardFactor\r\n        );\r\n\r\n        return (cStake, cFees);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the pending stake and fees for a delegator\r\n     * @param _delegator Address of a delegator\r\n     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees\r\n     * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees\r\n     */\r\n    function pendingStakeAndFees(address _delegator, uint256 _endRound) internal view returns (uint256 stake, uint256 fees) {\r\n        Delegator storage del = delegators[_delegator];\r\n        Transcoder storage t = transcoders[del.delegateAddress];\r\n\r\n        fees = del.fees;\r\n        stake = del.bondedAmount;\r\n\r\n        uint256 startRound = del.lastClaimRound.add(1);\r\n        address delegateAddr = del.delegateAddress;\r\n        bool isTranscoder = _delegator == delegateAddr;\r\n\r\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\r\n        while (startRound <= _endRound && startRound <= lip36Round) {\r\n            EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];\r\n\r\n            // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call\r\n            // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round\r\n            // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round\r\n            if (startRound == lip36Round && !earningsPool.hasTranscoderRewardFeePool) {\r\n                break;\r\n            }\r\n\r\n            if (earningsPool.hasClaimableShares()) {\r\n                // Calculate and add fee pool share from this round\r\n                fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));\r\n                // Calculate new bonded amount with rewards from this round. Updated bonded amount used\r\n                // to calculate fee pool share in next round\r\n                stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));\r\n            }\r\n\r\n            startRound = startRound.add(1);\r\n        }\r\n\r\n        // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round\r\n        // Otherwise, startRound = lip36Round + 1\r\n\r\n        // If the start round is greater than the end round, we've already claimed for the end round so we do not\r\n        // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:\r\n        // - _endRound < lip36Round i.e. we are not claiming through the lip36Round\r\n        // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round\r\n\r\n        // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1\r\n        // and from the specified _endRound\r\n        // We only need to execute this algorithm if the end round >= lip36Round\r\n        if (_endRound >= lip36Round) {\r\n            // Make sure there is a round to claim i.e. end round - (start round - 1) > 0\r\n            if (startRound <= _endRound) {\r\n                (\r\n                    stake,\r\n                    fees\r\n                ) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);\r\n            }\r\n            // cumulativeRewards and cumulativeFees will track *all* rewards/fees earned by the transcoder\r\n            // so it is important that this is only executed with the end round as the current round or else\r\n            // the returned stake and fees will reflect rewards/fees earned in the future relative to the end round\r\n            if (isTranscoder) {\r\n                stake = stake.add(t.cumulativeRewards);\r\n                fees = fees.add(t.cumulativeFees);\r\n            }\r\n        }\r\n\r\n        return (stake, fees);\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\r\n     * @param _delegate The delegate to increase the stake for\r\n     * @param _amount The amount to increase the stake for '_delegate' by\r\n     */\r\n    function increaseTotalStake(address _delegate, uint256 _amount, address _newPosPrev, address _newPosNext) internal {\r\n        if (isRegisteredTranscoder(_delegate)) {\r\n            uint256 currStake = transcoderTotalStake(_delegate);\r\n            uint256 newStake = currStake.add(_amount);\r\n            uint256 currRound = roundsManager().currentRound();\r\n            uint256 nextRound = currRound.add(1);\r\n\r\n            // If the transcoder is already in the active set update its stake and return\r\n            if (transcoderPoolV2.contains(_delegate)) {\r\n                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\r\n                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);\r\n                Transcoder storage t = transcoders[_delegate];\r\n\r\n                // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\r\n                // because it is updated every time lastActiveStakeUpdateRound is updated\r\n                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\r\n                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\r\n                if (t.lastActiveStakeUpdateRound < currRound) {\r\n                    t.earningsPoolPerRound[currRound].setStake(currStake);\r\n                }\r\n\r\n                t.earningsPoolPerRound[nextRound].setStake(newStake);\r\n                t.lastActiveStakeUpdateRound = nextRound;\r\n            } else {\r\n                // Check if the transcoder is eligible to join the active set in the update round\r\n                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);\r\n            }\r\n        }\r\n\r\n        // Increase delegate's delegated amount\r\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\r\n     * @param _delegate The transcoder to decrease the stake for\r\n     * @param _amount The amount to decrease the stake for '_delegate' by\r\n     */\r\n    function decreaseTotalStake(address _delegate, uint256 _amount, address _newPosPrev, address _newPosNext) internal {\r\n        if (transcoderPoolV2.contains(_delegate)) {\r\n            uint256 currStake = transcoderTotalStake(_delegate);\r\n            uint256 newStake = currStake.sub(_amount);\r\n            uint256 currRound = roundsManager().currentRound();\r\n            uint256 nextRound = currRound.add(1);\r\n\r\n            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\r\n            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);\r\n            Transcoder storage t = transcoders[_delegate];\r\n\r\n            // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\r\n            // because it is updated every time lastActiveStakeUpdateRound is updated\r\n            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\r\n            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\r\n            if (t.lastActiveStakeUpdateRound < currRound) {\r\n                t.earningsPoolPerRound[currRound].setStake(currStake);\r\n            }\r\n\r\n            t.lastActiveStakeUpdateRound = nextRound;\r\n            t.earningsPoolPerRound[nextRound].setStake(newStake);\r\n        }\r\n\r\n        // Decrease old delegate's delegated amount\r\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full\r\n     * @param _transcoder The transcoder to insert into the transcoder pool\r\n     * @param _totalStake The total stake for '_transcoder'\r\n     * @param _activationRound The round in which the transcoder should become active\r\n     */\r\n    function tryToJoinActiveSet(\r\n        address _transcoder,\r\n        uint256 _totalStake,\r\n        uint256 _activationRound,\r\n        address _newPosPrev,\r\n        address _newPosNext\r\n    )\r\n        internal\r\n    {\r\n        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;\r\n\r\n        if (transcoderPoolV2.isFull()) {\r\n            address lastTranscoder = transcoderPoolV2.getLast();\r\n            uint256 lastStake = transcoderTotalStake(lastTranscoder);\r\n\r\n            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool\r\n            // then the transcoder is unable to join the active set for the next round\r\n            if (_totalStake <= lastStake) {\r\n                return;\r\n            }\r\n\r\n            // Evict the least stake transcoder from the active set for the next round\r\n            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\r\n            // There should be no side-effects as long as the value is properly updated on stake updates\r\n            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\r\n            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\r\n            transcoderPoolV2.remove(lastTranscoder);\r\n            transcoders[lastTranscoder].deactivationRound = _activationRound;\r\n            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\r\n\r\n            emit TranscoderDeactivated(lastTranscoder, _activationRound);\r\n        }\r\n\r\n        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);\r\n        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);\r\n        Transcoder storage t = transcoders[_transcoder];\r\n        t.lastActiveStakeUpdateRound = _activationRound;\r\n        t.activationRound = _activationRound;\r\n        t.deactivationRound = MAX_FUTURE_ROUND;\r\n        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);\r\n        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;\r\n        emit TranscoderActivated(_transcoder, _activationRound);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a transcoder from the pool and deactivate it\r\n     */\r\n    function resignTranscoder(address _transcoder) internal {\r\n        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\r\n        // There should be no side-effects as long as the value is properly updated on stake updates\r\n        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\r\n        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\r\n        transcoderPoolV2.remove(_transcoder);\r\n        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));\r\n        uint256 deactivationRound = roundsManager().currentRound().add(1);\r\n        transcoders[_transcoder].deactivationRound = deactivationRound;\r\n        emit TranscoderDeactivated(_transcoder, deactivationRound);\r\n    }\r\n\r\n    /**\r\n     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.\r\n     * See SortedDoublyLL.sol for details on list hints\r\n     * @param _transcoder Address of transcoder\r\n     * @param _rewards Amount of rewards\r\n     * @param _round Round that transcoder is updated\r\n     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool\r\n     */\r\n    function updateTranscoderWithRewards(\r\n        address _transcoder,\r\n        uint256 _rewards,\r\n        uint256 _round,\r\n        address _newPosPrev,\r\n        address _newPosNext\r\n    )\r\n        internal\r\n    {\r\n        Transcoder storage t = transcoders[_transcoder];\r\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\r\n        EarningsPool.Data memory prevEarningsPool = cumulativeFactorsPool(t, t.lastRewardRound);\r\n\r\n        // If the previous cumulativeRewardFactor is 0 and we are before the LIP-71 round, set the default value to\r\n        // MathUtils.percPoints(1, 1) because we only set the default value to PreciseMathUtils.percPoints(1, 1) when storing for\r\n        // the LIP-71 round and onwards (see updateCumulativeRewardFactor() in EarningsPoolLIP36.sol)\r\n        if (prevEarningsPool.cumulativeRewardFactor == 0 && _round < roundsManager().lipUpgradeRound(71)) {\r\n            prevEarningsPool.cumulativeRewardFactor = MathUtils.percPoints(1, 1);\r\n        }\r\n\r\n        t.activeCumulativeRewards = t.cumulativeRewards;\r\n\r\n        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);\r\n        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);\r\n        // Calculate the rewards earned by the transcoder's earned rewards\r\n        uint256 transcoderRewardStakeRewards = PreciseMathUtils.percOf(delegatorsRewards, t.activeCumulativeRewards, earningsPool.totalStake);\r\n        // Track rewards earned by the transcoder based on its earned rewards and rewardCut\r\n        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);\r\n        // Update cumulative reward factor with new rewards\r\n        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)\r\n        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using\r\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field\r\n        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);\r\n        // Update transcoder's total stake with rewards\r\n        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);\r\n    }\r\n\r\n    /**\r\n     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\r\n     * @param _delegator Delegator address\r\n     * @param _endRound The last round for which to update a delegator's stake with earnings pool shares\r\n     * @param _lastClaimRound The round for which a delegator has last claimed earnings\r\n     */\r\n    function updateDelegatorWithEarnings(address _delegator, uint256 _endRound, uint256 _lastClaimRound) internal {\r\n        Delegator storage del = delegators[_delegator];\r\n        uint256 startRound = _lastClaimRound.add(1);\r\n        uint256 currentBondedAmount = del.bondedAmount;\r\n        uint256 currentFees = del.fees;\r\n\r\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\r\n\r\n        // Only will have earnings to claim if you have a delegate\r\n        // If not delegated, skip the earnings claim process\r\n        if (del.delegateAddress != address(0)) {\r\n            if (startRound <= lip36Round) {\r\n                // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36\r\n                // This is a number to cause transactions to fail early if\r\n                // we know they will require too much gas to loop through all the necessary rounds to claim earnings\r\n                // The user should instead manually invoke `claimEarnings` to split up the claiming process\r\n                // across multiple transactions\r\n                uint256 endLoopRound = _endRound <= lip36Round ? _endRound : lip36Round;\r\n                require(endLoopRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds, \"too many rounds to claim through\");\r\n            }\r\n\r\n            (\r\n                currentBondedAmount,\r\n                currentFees\r\n            ) = pendingStakeAndFees(_delegator, _endRound);\r\n\r\n            // Only execute cumulative factor logic after LIP-36 upgrade round\r\n            // After LIP-36 upgrade round the following code block should only be executed if _endRound is the current round\r\n            // See claimEarnings() and autoClaimEarnings()\r\n            if (_endRound >= lip36Round) {\r\n                // Check whether the endEarningsPool is initialised\r\n                // If it is not initialised set it's cumulative factors so that they can be used when a delegator\r\n                // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())\r\n                Transcoder storage t = transcoders[del.delegateAddress];\r\n                EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];\r\n                if (endEarningsPool.cumulativeRewardFactor == 0) {\r\n                    uint256 lastRewardRound = t.lastRewardRound;\r\n                    if (lastRewardRound < _endRound) {\r\n                        endEarningsPool.cumulativeRewardFactor = cumulativeFactorsPool(t, lastRewardRound).cumulativeRewardFactor;\r\n                    }\r\n                }\r\n                if (endEarningsPool.cumulativeFeeFactor == 0) {\r\n                    uint256 lastFeeRound = t.lastFeeRound;\r\n                    if (lastFeeRound < _endRound) {\r\n                        endEarningsPool.cumulativeFeeFactor = cumulativeFactorsPool(t, lastFeeRound).cumulativeFeeFactor;\r\n                    }\r\n                }\r\n\r\n                if (del.delegateAddress == _delegator) {\r\n                    t.cumulativeFees = 0;\r\n                    t.cumulativeRewards = 0;\r\n                    // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards\r\n                }\r\n            }\r\n        }\r\n\r\n        emit EarningsClaimed(\r\n            del.delegateAddress,\r\n            _delegator,\r\n            currentBondedAmount.sub(del.bondedAmount),\r\n            currentFees.sub(del.fees),\r\n            startRound,\r\n            _endRound\r\n        );\r\n\r\n        del.lastClaimRound = _endRound;\r\n        // Rewards are bonded by default\r\n        del.bondedAmount = currentBondedAmount;\r\n        del.fees = currentFees;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional\r\n     * list hint if needed. See SortedDoublyLL.sol for details on list hints\r\n     * @param _delegator Address of delegator\r\n     * @param _unbondingLockId ID of unbonding lock to rebond with\r\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool\r\n     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool\r\n     */\r\n    function processRebond(address _delegator, uint256 _unbondingLockId, address _newPosPrev, address _newPosNext) internal {\r\n        Delegator storage del = delegators[_delegator];\r\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\r\n\r\n        require(isValidUnbondingLock(_delegator, _unbondingLockId), \"invalid unbonding lock ID\");\r\n\r\n        uint256 amount = lock.amount;\r\n        // Increase delegator's bonded amount\r\n        del.bondedAmount = del.bondedAmount.add(amount);\r\n\r\n        // Delete lock\r\n        delete del.unbondingLocks[_unbondingLockId];\r\n\r\n        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);\r\n\r\n        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Return LivepeerToken interface\r\n     * @return Livepeer token contract registered with Controller\r\n     */\r\n    function livepeerToken() internal view returns (ILivepeerToken) {\r\n        return ILivepeerToken(controller.getContract(keccak256(\"LivepeerToken\")));\r\n    }\r\n\r\n    /**\r\n     * @dev Return Minter interface\r\n     * @return Minter contract registered with Controller\r\n     */\r\n    function minter() internal view returns (IMinter) {\r\n        return IMinter(controller.getContract(keccak256(\"Minter\")));\r\n    }\r\n\r\n    /**\r\n     * @dev Return RoundsManager interface\r\n     * @return RoundsManager contract registered with Controller\r\n     */\r\n    function roundsManager() internal view returns (IRoundsManager) {\r\n        return IRoundsManager(controller.getContract(keccak256(\"RoundsManager\")));\r\n    }\r\n\r\n    function _onlyTicketBroker() internal view {\r\n        require(\r\n            msg.sender == controller.getContract(keccak256(\"TicketBroker\")),\r\n            \"caller must be TicketBroker\"\r\n        );\r\n    }\r\n\r\n    function _onlyRoundsManager() internal view {\r\n        require(\r\n            msg.sender == controller.getContract(keccak256(\"RoundsManager\")),\r\n            \"caller must be RoundsManager\"\r\n        );\r\n    }\r\n\r\n    function _onlyVerifier() internal view {\r\n        require(msg.sender == controller.getContract(keccak256(\"Verifier\")), \"caller must be Verifier\");\r\n    }\r\n\r\n    function  _currentRoundInitialized() internal view {\r\n        require(roundsManager().currentRoundInitialized(), \"current round is not initialized\");\r\n    }\r\n\r\n    function _autoClaimEarnings() internal {\r\n        uint256 currentRound = roundsManager().currentRound();\r\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\r\n        if (lastClaimRound < currentRound) {\r\n            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);\r\n        }\r\n    }\r\n}"}}}