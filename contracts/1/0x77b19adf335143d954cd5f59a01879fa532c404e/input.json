{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MigrationRebalancer.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// File: libraries/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    // Only used in the  BondingCalculator.sol\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n\r\n}\r\n// File: interfaces/IOlympusAuthority.sol\r\n\r\n\r\npragma solidity =0.7.5;\r\n\r\ninterface IOlympusAuthority {\r\n    /* ========== EVENTS ========== */\r\n    \r\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n\r\n    event GovernorPulled(address indexed from, address indexed to);\r\n    event GuardianPulled(address indexed from, address indexed to);\r\n    event PolicyPulled(address indexed from, address indexed to);\r\n    event VaultPulled(address indexed from, address indexed to);\r\n\r\n    /* ========== VIEW ========== */\r\n    \r\n    function governor() external view returns (address);\r\n    function guardian() external view returns (address);\r\n    function policy() external view returns (address);\r\n    function vault() external view returns (address);\r\n}\r\n// File: types/OlympusAccessControlled.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\nabstract contract OlympusAccessControlled {\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\r\n\r\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IOlympusAuthority public authority;\r\n\r\n\r\n    /* ========== Constructor ========== */\r\n\r\n    constructor(IOlympusAuthority _authority) {\r\n        authority = _authority;\r\n        emit AuthorityUpdated(_authority);\r\n    }\r\n    \r\n\r\n    /* ========== MODIFIERS ========== */\r\n    \r\n    modifier onlyGovernor() {\r\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyGuardian() {\r\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPolicy() {\r\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVault() {\r\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    /* ========== GOV ONLY ========== */\r\n    \r\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n}\r\n\r\n// File: interfaces/IStaking.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IStaking {\r\n    function stake(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _rebasing,\r\n        bool _claim\r\n    ) external returns (uint256);\r\n\r\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\r\n\r\n    function forfeit() external returns (uint256);\r\n\r\n    function toggleLock() external;\r\n\r\n    function unstake(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _trigger,\r\n        bool _rebasing\r\n    ) external returns (uint256);\r\n\r\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\r\n\r\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\r\n\r\n    function rebase() external;\r\n\r\n    function index() external view returns (uint256);\r\n\r\n    function contractBalance() external view returns (uint256);\r\n\r\n    function totalStaked() external view returns (uint256);\r\n\r\n    function supplyInWarmup() external view returns (uint256);\r\n}\r\n\r\n// File: interfaces/ITreasury.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface ITreasury {\r\n    function deposit(\r\n        uint256 _amount,\r\n        address _token,\r\n        uint256 _profit\r\n    ) external returns (uint256);\r\n\r\n    function withdraw(uint256 _amount, address _token) external;\r\n\r\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\r\n\r\n    function mint(address _recipient, uint256 _amount) external;\r\n\r\n    function manage(address _token, uint256 _amount) external;\r\n\r\n    function incurDebt(uint256 amount_, address token_) external;\r\n\r\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\r\n\r\n    function excessReserves() external view returns (uint256);\r\n\r\n    function baseSupply() external view returns (uint256);\r\n}\r\n\r\n// File: interfaces/IERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: interfaces/IsOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IsOHM is IERC20 {\r\n    function rebase( uint256 ohmProfit_, uint epoch_) external returns (uint256);\r\n\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    function gonsForBalance( uint amount ) external view returns ( uint );\r\n\r\n    function balanceForGons( uint gons ) external view returns ( uint );\r\n\r\n    function index() external view returns ( uint );\r\n\r\n    function toG(uint amount) external view returns (uint);\r\n\r\n    function fromG(uint amount) external view returns (uint);\r\n\r\n     function changeDebt(\r\n        uint256 amount,\r\n        address debtor,\r\n        bool add\r\n    ) external;\r\n\r\n    function debtBalances(address _address) external view returns (uint256);\r\n\r\n}\r\n\r\n// File: rebalancer.sol\r\n\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MigrationRebalancer is OlympusAccessControlled {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    IStaking public immutable staking;\r\n    IERC20 public immutable ohm;\r\n    IsOHM public immutable sohm;\r\n    ITreasury public immutable treasury;\r\n\r\n    bool public rebalanced;\r\n\r\n    constructor(\r\n        address _staking,\r\n        address _ohm,\r\n        address _sohm,\r\n        address _treasury,\r\n        address _authority\r\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\r\n        require(_staking != address(0), \"Zero address: Staking\");\r\n        staking = IStaking(_staking);\r\n        require(_ohm != address(0), \"Zero address: Staking\");\r\n        ohm = IERC20(_ohm);\r\n        require(_sohm != address(0), \"Zero address: Staking\");\r\n        sohm = IsOHM(_sohm);\r\n        require(_treasury != address(0), \"Zero address: Staking\");\r\n        treasury = ITreasury(_treasury);\r\n        rebalanced = false;\r\n    }\r\n\r\n    // This function rebalances the staking contract following migration.\r\n    // Because the migrator mints the entire staked supply as migrate-able gOHM,\r\n    // an imbalance may arise in which less OHM liquidity is available than \r\n    // staked tokens outstanding. By calculating the imbalance between circulating\r\n    // sOHM supply (sOHM outstanding + sOHM value of gOHM outstanding + tokens in warmup),\r\n    // we can easily fix this imbalance. The inflated circulating staked supply\r\n    // can then be corrected by migrating DAO-held OHM through the migrator to acquire\r\n    // gOHM and unstake it back to OHM.\r\n    function rebalance() external onlyGovernor {\r\n        require(!rebalanced, \"Already rebalanced\");\r\n        treasury.mint(address(staking), imbalance());\r\n        rebalanced = true;\r\n    }\r\n\r\n    // view imbalance to be corrected\r\n    function imbalance() public view returns (uint256) {\r\n        uint256 ohmInStaking = ohm.balanceOf(address(staking));\r\n        return sohm.circulatingSupply().sub(ohmInStaking);\r\n    }\r\n}"}}}