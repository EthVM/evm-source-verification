{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/PayStaking.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Constant {\n    string constant ERR_CONTRACT_SELF_ADDRESS = \"ERR_CONTRACT_SELF_ADDRESS\";\n    string constant ERR_ZERO_ADDRESS = \"ERR_ZERO_ADDRESS\";\n    string constant ERR_NOT_OWN_ADDRESS = \"ERR_NOT_OWN_ADDRESS\";\n    string constant ERR_VALUE_IS_ZERO = \"ERR_VALUE_IS_ZERO\";\n    string constant ERR_AUTHORIZED_ADDRESS_ONLY = \"ERR_AUTHORIZED_ADDRESS_ONLY\";\n    string constant ERR_NOT_ENOUGH_BALANCE = \"ERR_NOT_ENOUGH_BALANCE\";\n\n    modifier notOwnAddress(address _which) {\n        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\n        _;\n    }\n\n    // validates an address is not zero\n    modifier notZeroAddress(address _which) {\n        require(_which != address(0), ERR_ZERO_ADDRESS);\n        _;\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThisAddress(address _which) {\n        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\n        _;\n    }\n\n    modifier notZeroValue(uint256 _value) {\n        require(_value > 0, ERR_VALUE_IS_ZERO);\n        _;\n    }\n}\n\ncontract Ownable is Constant {\n\n    address payable public owner;\n    address payable public newOwner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        _transferOwnership(msg.sender);\n    }\n\n    function _transferOwnership(address payable _whom) internal {\n        emit OwnershipTransferred(owner,_whom);\n        owner = _whom;\n    }\n\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, ERR_AUTHORIZED_ADDRESS_ONLY);\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address payable _newOwner)\n        external\n        virtual\n        notZeroAddress(_newOwner)\n        onlyOwner\n    {\n        // emit OwnershipTransferred(owner, newOwner);\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() external\n        virtual\n        returns (bool){\n        require(msg.sender == newOwner,\"ERR_ONLY_NEW_OWNER\");\n        owner = newOwner;\n        emit OwnershipTransferred(owner, newOwner);\n        newOwner = address(0);\n        return true;\n    }\n}\n\ncontract SafeMath {\n   /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n        require(b <= a, error);\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return safeDiv(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n        require(b > 0, error);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\n        uint256 result;\n        assembly {\n            result:=exp(a, b)\n        }\n        return result;\n    }\n}\n\ninterface ERC20Interface\n{\n    function totalSupply() external view returns(uint256);\n\n    function balanceOf(address _tokenOwner)external view returns(uint balance );\n\n    function allowance(address _tokenOwner, address _spender)external view returns (uint supply);\n\n    function transfer(address _to,uint _tokens)external returns(bool success);\n\n    function approve(address _spender,uint _tokens)external returns(bool success);\n\n    function transferFrom(address _from,address _to,uint _tokens)external returns(bool success);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _tokens);\n}\n\ncontract StakeStorage {\n\n    /**\n    * @dev check if token is listed\n   **/\n    mapping(address => bool) public listedToken;\n\n    /**\n     * @dev list of tokens\n    **/\n    address[] public tokens;\n\n    mapping(address => uint256)public tokenIndex;\n    mapping(address => mapping(address => uint256)) public stakeBalance;\n    mapping(address => mapping(address => uint256)) public lastStakeClaimed;\n    mapping(address => uint256)public totalTokens;\n\n    /**\n     * @dev annual mint percent of a token\n     **/\n    mapping(address => uint256) public annualMintPercentage;\n    /**\n    * @dev list of particular token's paynoder\n    **/\n    mapping(address => address[])public payNoders;\n    /**\n     * @dev check if address is in paynode\n     **/\n    mapping(address => mapping(address => bool)) public isPayNoder;\n    /**\n     * @dev maintain array index for addresses\n     **/\n    mapping(address => mapping(address => uint256)) public payNoderIndex;\n    /**\n     * @dev token's  paynode slot\n    **/\n    mapping(address => uint256)public tokenPayNoderSlot;\n\n    /**\n     * @dev minimum balance require for be in paynode\n    **/\n    mapping(address => uint256)public tokenMinimumBalance;\n    mapping(address => uint256)public tokenExtraMintForPayNodes;\n\n    event Stake(\n        uint256 indexed _stakeTimestamp,\n        address indexed _token,\n        address indexed _whom,\n        uint256 _amount\n    );\n\n    event StakeClaimed(\n        uint256 indexed _stakeClaimedTimestamp,\n        address indexed _token,\n        address indexed _whom,\n        uint256 _amount\n    );\n\n    event UnStake(\n        uint256 indexed _unstakeTimestamp,\n        address indexed _token,\n        address indexed _whom,\n        uint256 _amount\n    );\n}\n\ncontract Paynodes is Ownable, SafeMath, StakeStorage {\n\n    /**\n     * @dev adding paynode account\n    **/\n    function addaccountToPayNode(address _token, address _whom)\n    external\n    onlyOwner()\n    returns (bool)\n    {\n        require(isPayNoder[_token][_whom] == false, \"ERR_ALREADY_IN_PAYNODE_LIST\");\n\n        require(payNoders[_token].length < tokenPayNoderSlot[_token], \"ERR_PAYNODE_LIST_FULL\");\n\n        require(stakeBalance[_token][_whom] >= tokenMinimumBalance[_token], \"ERR_PAYNODE_MINIMUM_BALANCE\");\n\n        isPayNoder[_token][_whom] = true;\n        payNoderIndex[_token][_whom] = payNoders[_token].length;\n        payNoders[_token].push(_whom);\n        return true;\n    }\n\n    /**\n     * @dev removing paynode account\n     **/\n    function _removeaccountToPayNode(address _token, address _whom) internal returns (bool) {\n\n        require(isPayNoder[_token][_whom], \"ERR_ONLY_PAYNODER\");\n        uint256 _payNoderIndex = payNoderIndex[_token][_whom];\n\n        address _lastAddress = payNoders[_token][safeSub(payNoders[_token].length, 1)];\n        payNoders[_token][_payNoderIndex] = _lastAddress;\n        payNoderIndex[_token][_lastAddress] = _payNoderIndex;\n        delete isPayNoder[_token][_whom];\n        payNoders[_token].pop();\n        return true;\n    }\n\n    /**\n     * @dev remove account from paynode\n     **/\n    function removeaccountToPayNode(address _token, address _whom)\n    external\n    onlyOwner()\n    returns (bool)\n    {\n        return _removeaccountToPayNode(_token, _whom);\n    }\n\n    /**\n     * @dev owner can change minimum balance requirement\n     **/\n    function setMinimumBalanceForPayNoder(address _token, uint256 _minimumBalance)\n    external\n    onlyOwner()\n    returns (bool)\n    {\n        tokenMinimumBalance[_token] = _minimumBalance;\n        return true;\n    }\n\n    /**\n     * @dev owner can change extra mint percent for paynoder\n     * _extraMintForPayNodes is set in percent with mulitply 100\n     * if owner want to set 1.25% then value is 125\n     **/\n    function setExtraMintingForNodes(address _token, uint256 _extraMintForPayNodes)\n    external\n    onlyOwner()\n    returns (bool)\n    {\n        tokenExtraMintForPayNodes[_token] = _extraMintForPayNodes;\n        return true;\n    }\n\n    /**\n     * @dev owner can set paynoder slots\n     **/\n    function setPayNoderSlot(address _token, uint256 _payNoderSlot)\n    external\n    onlyOwner()\n    returns (bool)\n    {\n        tokenPayNoderSlot[_token] = _payNoderSlot;\n        return true;\n    }\n}\n\ncontract Staking is Paynodes {\n\n    constructor(address[] memory _token) public {\n        for (uint8 i = 0; i < _token.length; i++) {\n            listedToken[_token[i]] = true;\n            tokens.push(_token[i]);\n            tokenIndex[_token[i]] = i;\n        }\n    }\n\n    /**\n    * @dev stake token\n    **/\n    function stake(address _token, uint256 _amount) external returns (bool){\n\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\n\n        ERC20Interface(_token).transferFrom(msg.sender, address(this), _amount);\n\n        if (lastStakeClaimed[_token][msg.sender] == 0) {\n            lastStakeClaimed[_token][msg.sender] = now;\n        } else {\n            uint256 _stakeReward = _calculateStake(_token, msg.sender);\n            lastStakeClaimed[_token][msg.sender] = now;\n            stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _stakeReward);\n        }\n\n        totalTokens[_token] = safeAdd(totalTokens[_token], _amount);\n        stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _amount);\n        emit Stake(now, _token, msg.sender, _amount);\n        return true;\n    }\n\n    /**\n     * @dev stake token\n     **/\n    function unStake(address _token) external returns (bool){\n\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\n\n        uint256 userTokenBalance = stakeBalance[_token][msg.sender];\n        uint256 _stakeReward = _calculateStake(_token, msg.sender);\n        ERC20Interface(_token).transfer(msg.sender, safeAdd(userTokenBalance, _stakeReward));\n        emit UnStake(now, _token, msg.sender, safeAdd(userTokenBalance, _stakeReward));\n        totalTokens[_token] = safeSub(totalTokens[_token], userTokenBalance);\n        stakeBalance[_token][msg.sender] = 0;\n        lastStakeClaimed[_token][msg.sender] = 0;\n        return true;\n    }\n\n    /**\n     * @dev withdraw token\n     **/\n    function withdrawToken(address _token) external returns (bool){\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\n        uint256 userTokenBalance = stakeBalance[_token][msg.sender];\n        stakeBalance[_token][msg.sender] = 0;\n        lastStakeClaimed[_token][msg.sender] = 0;\n        ERC20Interface(_token).transfer(msg.sender, userTokenBalance);\n        return true;\n    }\n\n    /**\n     * @dev withdraw token by owner\n     **/\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner() returns (bool) {\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\n        require(totalTokens[_token] == 0, \"ERR_TOTAL_TOKENS_NEEDS_TO_BE_0_FOR_WITHDRAWL\");\n        ERC20Interface(_token).transfer(msg.sender, _amount);\n        return true;\n    }\n\n    // we calculate daily basis stake amount\n    function _calculateStake(address _token, address _whom) internal view returns (uint256) {\n        uint256 _lastRound = lastStakeClaimed[_token][_whom];\n        uint256 totalStakeDays = safeDiv(safeSub(now, _lastRound), 86400);\n        uint256 userTokenBalance = stakeBalance[_token][_whom];\n        uint256 tokenPercentage = annualMintPercentage[_token];\n        if (totalStakeDays > 0) {\n            uint256 stakeAmount = safeDiv(safeMul(safeMul(userTokenBalance, tokenPercentage), totalStakeDays), 3650000);\n            if (isPayNoder[_token][_whom]) {\n                if (stakeBalance[_token][_whom] >= tokenMinimumBalance[_token]) {\n                    uint256 extraPayNode = safeDiv(safeMul(safeMul(userTokenBalance, tokenPercentage), tokenExtraMintForPayNodes[_token]), 3650000);\n                    stakeAmount = safeAdd(stakeAmount, extraPayNode);\n                }\n            }\n            return stakeAmount;\n        }\n        return 0;\n\n    }\n\n    // show stake balance with what user get\n    function balanceOf(address _token, address _whom) external view returns (uint256) {\n        uint256 _stakeReward = _calculateStake(_token, _whom);\n        return safeAdd(stakeBalance[_token][_whom], _stakeReward);\n    }\n\n    // show stake balance with what user get\n    function getOnlyRewards(address _token, address _whom) external view returns (uint256) {\n        return _calculateStake(_token, _whom);\n    }\n\n    // claim only rewards and withdraw it\n    function claimRewardsOnlyAndWithDraw(address _token) external returns (bool) {\n        require(lastStakeClaimed[_token][msg.sender] != 0, \"ERR_TOKEN_IS_NOT_STAKED\");\n        uint256 _stakeReward = _calculateStake(_token, msg.sender);\n        ERC20Interface(_token).transfer(msg.sender, _stakeReward);\n        lastStakeClaimed[_token][msg.sender] = now;\n        emit StakeClaimed(now, _token, msg.sender, _stakeReward);\n        return true;\n    }\n\n    // claim only rewards and restake it\n    function claimRewardsOnlyAndStake(address _token) external returns (bool) {\n        require(lastStakeClaimed[_token][msg.sender] != 0, \"ERR_TOKEN_IS_NOT_STAKED\");\n        uint256 _stakeReward = _calculateStake(_token, msg.sender);\n\n        lastStakeClaimed[_token][msg.sender] = now;\n        stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _stakeReward);\n        emit StakeClaimed(now, _token, msg.sender, _stakeReward);\n        emit Stake(now, _token, msg.sender, stakeBalance[_token][msg.sender]);\n        return true;\n    }\n\n    // _percent should be mulitplied by 100\n    function setAnnualMintPercentage(address _token, uint256 _percent) external onlyOwner() returns (bool) {\n        require(listedToken[_token], \"ERR_TOKEN_IS_NOT_LISTED\");\n        annualMintPercentage[_token] = _percent;\n        return true;\n    }\n\n    // to add new token\n    function addToken(address _token) external onlyOwner() {\n        require(!listedToken[_token], \"ERR_TOKEN_ALREADY_EXISTS\");\n        tokens.push(_token);\n        listedToken[_token] = true;\n        tokenIndex[_token] = tokens.length;\n    }\n\n    // to remove the token\n    function removeToken(address _token) external onlyOwner() {\n        require(listedToken[_token], \"ERR_TOKEN_DOESNOT_EXISTS\");\n        uint256 _lastindex = tokenIndex[_token];\n        address _lastaddress = tokens[safeSub(tokens.length, 1)];\n        tokenIndex[_lastaddress] = _lastindex;\n        tokens[_lastindex] = _lastaddress;\n        tokens.pop();\n        delete tokenIndex[_lastaddress];\n        listedToken[_token] = false;\n    }\n\n    function availabletokens() public view returns (uint){\n        return tokens.length;\n    }\n\n}"}}}