{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "KernelProxy.sol": {
      "content": "// File: contracts/acl/IACL.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IACL {\r\n    function initialize(address permissionsCreator) external;\r\n\r\n    // TODO: this should be external\r\n    // See https://github.com/ethereum/solidity/issues/4832\r\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\r\n}\r\n\r\n// File: contracts/common/IVaultRecoverable.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ninterface IVaultRecoverable {\r\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\r\n\r\n    function transferToVault(address token) external;\r\n\r\n    function allowRecoverability(address token) external view returns (bool);\r\n    function getRecoveryVault() external view returns (address);\r\n}\r\n\r\n// File: contracts/kernel/IKernel.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\ninterface IKernelEvents {\r\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\r\n}\r\n\r\n\r\n// This should be an interface, but interfaces can't inherit yet :(\r\ncontract IKernel is IKernelEvents, IVaultRecoverable {\r\n    function acl() public view returns (IACL);\r\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\r\n\r\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\r\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\r\n}\r\n\r\n// File: contracts/kernel/KernelConstants.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract KernelAppIds {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\"kernel\");\r\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\"acl\");\r\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\"vault\");\r\n    */\r\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\r\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\r\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\r\n}\r\n\r\n\r\ncontract KernelNamespaceConstants {\r\n    /* Hardcoded constants to save gas\r\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\"core\");\r\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\"base\");\r\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\"app\");\r\n    */\r\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\r\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\r\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\r\n}\r\n\r\n// File: contracts/kernel/KernelStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract KernelStorage {\r\n    // namespace => app id => address\r\n    mapping (bytes32 => mapping (bytes32 => address)) public apps;\r\n    bytes32 public recoveryVaultAppId;\r\n}\r\n\r\n// File: contracts/common/IsContract.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract IsContract {\r\n    /*\r\n    * NOTE: this should NEVER be used for authentication\r\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\r\n    *\r\n    * This is only intended to be used as a sanity check that an address is actually a contract,\r\n    * RATHER THAN an address not being a contract.\r\n    */\r\n    function isContract(address _target) internal view returns (bool) {\r\n        if (_target == address(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 size;\r\n        assembly { size := extcodesize(_target) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/misc/ERCProxy.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract ERCProxy {\r\n    uint256 internal constant FORWARDING = 1;\r\n    uint256 internal constant UPGRADEABLE = 2;\r\n\r\n    function proxyType() public pure returns (uint256 proxyTypeId);\r\n    function implementation() public view returns (address codeAddr);\r\n}\r\n\r\n// File: contracts/common/DelegateProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract DelegateProxy is ERCProxy, IsContract {\r\n    uint256 internal constant FWD_GAS_LIMIT = 10000;\r\n\r\n    /**\r\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\r\n    * @param _dst Destination address to perform the delegatecall\r\n    * @param _calldata Calldata for the delegatecall\r\n    */\r\n    function delegatedFwd(address _dst, bytes _calldata) internal {\r\n        require(isContract(_dst));\r\n        uint256 fwdGasLimit = FWD_GAS_LIMIT;\r\n\r\n        assembly {\r\n            let result := delegatecall(sub(gas, fwdGasLimit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\r\n            // if the call returned error data, forward it\r\n            switch result case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/UnstructuredStorage.sol\r\n\r\n/*\r\n * SPDX-License-Identitifer:    MIT\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\nlibrary UnstructuredStorage {\r\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\r\n        assembly { data := sload(position) }\r\n    }\r\n\r\n    function setStorageBool(bytes32 position, bool data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageAddress(bytes32 position, address data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n\r\n    function setStorageUint256(bytes32 position, uint256 data) internal {\r\n        assembly { sstore(position, data) }\r\n    }\r\n}\r\n\r\n// File: contracts/common/DepositableStorage.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract DepositableStorage {\r\n    using UnstructuredStorage for bytes32;\r\n\r\n    // keccak256(\"aragonOS.depositableStorage.depositable\")\r\n    bytes32 internal constant DEPOSITABLE_POSITION = 0x665fd576fbbe6f247aff98f5c94a561e3f71ec2d3c988d56f12d342396c50cea;\r\n\r\n    function isDepositable() public view returns (bool) {\r\n        return DEPOSITABLE_POSITION.getStorageBool();\r\n    }\r\n\r\n    function setDepositable(bool _depositable) internal {\r\n        DEPOSITABLE_POSITION.setStorageBool(_depositable);\r\n    }\r\n}\r\n\r\n// File: contracts/common/DepositableDelegateProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract DepositableDelegateProxy is DepositableStorage, DelegateProxy {\r\n    event ProxyDeposit(address sender, uint256 value);\r\n\r\n    function () external payable {\r\n        uint256 forwardGasThreshold = FWD_GAS_LIMIT;\r\n        bytes32 isDepositablePosition = DEPOSITABLE_POSITION;\r\n\r\n        // Optimized assembly implementation to prevent EIP-1884 from breaking deposits, reference code in Solidity:\r\n        // https://github.com/aragon/aragonOS/blob/v4.2.1/contracts/common/DepositableDelegateProxy.sol#L10-L20\r\n        assembly {\r\n            // Continue only if the gas left is lower than the threshold for forwarding to the implementation code,\r\n            // otherwise continue outside of the assembly block.\r\n            if lt(gas, forwardGasThreshold) {\r\n                // Only accept the deposit and emit an event if all of the following are true:\r\n                // the proxy accepts deposits (isDepositable), msg.data.length == 0, and msg.value > 0\r\n                if and(and(sload(isDepositablePosition), iszero(calldatasize)), gt(callvalue, 0)) {\r\n                    // Equivalent Solidity code for emitting the event:\r\n                    // emit ProxyDeposit(msg.sender, msg.value);\r\n\r\n                    let logData := mload(0x40) // free memory pointer\r\n                    mstore(logData, caller) // add 'msg.sender' to the log data (first event param)\r\n                    mstore(add(logData, 0x20), callvalue) // add 'msg.value' to the log data (second event param)\r\n\r\n                    // Emit an event with one topic to identify the event: keccak256('ProxyDeposit(address,uint256)') = 0x15ee...dee1\r\n                    log1(logData, 0x40, 0x15eeaa57c7bd188c1388020bcadc2c436ec60d647d36ef5b9eb3c742217ddee1)\r\n\r\n                    stop() // Stop. Exits execution context\r\n                }\r\n\r\n                // If any of above checks failed, revert the execution (if ETH was sent, it is returned to the sender)\r\n                revert(0, 0)\r\n            }\r\n        }\r\n\r\n        address target = implementation();\r\n        delegatedFwd(target, msg.data);\r\n    }\r\n}\r\n\r\n// File: contracts/kernel/KernelProxy.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract KernelProxy is IKernelEvents, KernelStorage, KernelAppIds, KernelNamespaceConstants, IsContract, DepositableDelegateProxy {\r\n    /**\r\n    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\r\n    *      can update the reference, which effectively upgrades the contract\r\n    * @param _kernelImpl Address of the contract used as implementation for kernel\r\n    */\r\n    constructor(IKernel _kernelImpl) public {\r\n        require(isContract(address(_kernelImpl)));\r\n        apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID] = _kernelImpl;\r\n\r\n        // Note that emitting this event is important for verifying that a KernelProxy instance\r\n        // was never upgraded to a malicious Kernel logic contract over its lifespan.\r\n        // This starts the \"chain of trust\", that can be followed through later SetApp() events\r\n        // emitted during kernel upgrades.\r\n        emit SetApp(KERNEL_CORE_NAMESPACE, KERNEL_CORE_APP_ID, _kernelImpl);\r\n    }\r\n\r\n    /**\r\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\r\n     */\r\n    function proxyType() public pure returns (uint256 proxyTypeId) {\r\n        return UPGRADEABLE;\r\n    }\r\n\r\n    /**\r\n    * @dev ERC897, the address the proxy would delegate calls to\r\n    */\r\n    function implementation() public view returns (address) {\r\n        return apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID];\r\n    }\r\n}"
    }
  }
}