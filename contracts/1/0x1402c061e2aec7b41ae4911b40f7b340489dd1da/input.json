{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":100},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DOSProxy.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nlibrary BN256 {\r\n    struct G1Point {\r\n        uint x;\r\n        uint y;\r\n    }\r\n\r\n    struct G2Point {\r\n        uint[2] x;\r\n        uint[2] y;\r\n    }\r\n\r\n    function P1() internal pure returns (G1Point memory) {\r\n        return G1Point(1, 2);\r\n    }\r\n\r\n    function P2() internal pure returns (G2Point memory) {\r\n        return G2Point(\r\n            [11559732032986387107991004021392285783925812861821192530917403151452391805634,\r\n            10857046999023057135944570762232829481370756359578518086990519993285655852781],\r\n\r\n            [4082367875863433681332203403145435568316851327593401208105741076214120093531,\r\n            8495653923123431417604973247489272438418190587263600148770280649306958101930]\r\n        );\r\n    }\r\n\r\n    function pointAdd(G1Point memory p1, G1Point memory p2) internal returns (G1Point memory r) {\r\n        uint[4] memory input;\r\n        input[0] = p1.x;\r\n        input[1] = p1.y;\r\n        input[2] = p2.x;\r\n        input[3] = p2.y;\r\n        assembly {\r\n            if iszero(call(sub(gas, 2000), 0x6, 0, input, 0x80, r, 0x40)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function scalarMul(G1Point memory p, uint s) internal returns (G1Point memory r) {\r\n        uint[3] memory input;\r\n        input[0] = p.x;\r\n        input[1] = p.y;\r\n        input[2] = s;\r\n        assembly {\r\n            if iszero(call(sub(gas, 2000), 0x7, 0, input, 0x60, r, 0x40)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\r\n        if (p.x == 0 && p.y == 0) {\r\n            return p;\r\n        }\r\n        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n        return G1Point(p.x, q - p.y % q);\r\n    }\r\n\r\n    function hashToG1(bytes memory data) internal returns (G1Point memory) {\r\n        uint256 h = uint256(keccak256(data));\r\n        return scalarMul(P1(), h);\r\n    }\r\n\r\n    function G2Equal(G2Point memory p1, G2Point memory p2) internal pure returns (bool) {\r\n        return p1.x[0] == p2.x[0] && p1.x[1] == p2.x[1] && p1.y[0] == p2.y[0] && p1.y[1] == p2.y[1];\r\n    }\r\n\r\n    // @return the result of computing the pairing check\r\n    // check passes if e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\r\n    // E.g. pairing([p1, p1.negate()], [p2, p2]) should return true.\r\n    function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) internal returns (bool) {\r\n        require(p1.length == p2.length);\r\n        uint elements = p1.length;\r\n        uint inputSize = elements * 6;\r\n        uint[] memory input = new uint[](inputSize);\r\n\r\n        for (uint i = 0; i < elements; i++)\r\n        {\r\n            input[i * 6 + 0] = p1[i].x;\r\n            input[i * 6 + 1] = p1[i].y;\r\n            input[i * 6 + 2] = p2[i].x[0];\r\n            input[i * 6 + 3] = p2[i].x[1];\r\n            input[i * 6 + 4] = p2[i].y[0];\r\n            input[i * 6 + 5] = p2[i].y[1];\r\n        }\r\n\r\n        uint[1] memory out;\r\n        bool success;\r\n        assembly {\r\n            success := call(\r\n                sub(gas, 2000),\r\n                0x8,\r\n                0,\r\n                add(input, 0x20),\r\n                mul(inputSize, 0x20),\r\n                out, 0x20\r\n            )\r\n        }\r\n        return success && (out[0] != 0);\r\n    }\r\n}\r\n\r\ncontract UserContractInterface {\r\n    // Query callback.\r\n    function __callback__(uint, bytes calldata) external;\r\n    // Random number callback.\r\n    function __callback__(uint, uint) external;\r\n}\r\n\r\ncontract CommitRevealInterface {\r\n    function startCommitReveal(uint, uint, uint, uint) public returns(uint);\r\n    function getRandom(uint) public returns(uint);\r\n}\r\n\r\ncontract DOSAddressBridgeInterface {\r\n    function getCommitRevealAddress() public view returns(address);\r\n    function getPaymentAddress() public view returns(address);\r\n    function getStakingAddress() public view returns(address);\r\n}\r\n\r\ncontract DOSPaymentInterface {\r\n    function hasServiceFee(address, uint) public view returns (bool);\r\n    function chargeServiceFee(address, uint, uint) public;\r\n    function recordServiceFee(uint, address, address[] memory) public;\r\n    function claimGuardianReward(address) public;\r\n    function setPaymentMethod(address, address) public;\r\n}\r\n\r\ncontract DOSStakingInterface {\r\n    function nodeStart(address _nodeAddr) public;\r\n    function nodeStop(address _nodeAddr) public;\r\n    function isValidStakingNode(address _nodeAddr) public view returns(bool);\r\n}\r\n\r\ncontract DOSProxy {\r\n    using BN256 for *;\r\n\r\n    // Metadata of pending request.\r\n    struct PendingRequest {\r\n        uint requestId;\r\n        uint groupId;\r\n        BN256.G2Point handledGroupPubKey;\r\n        // Calling contract who issues the request.\r\n        address callbackAddr;\r\n    }\r\n\r\n    // Metadata of registered group.\r\n    struct Group {\r\n        uint groupId;\r\n        BN256.G2Point groupPubKey;\r\n        uint life;\r\n        uint birthBlkN;\r\n        address[] members;\r\n    }\r\n\r\n    // Metadata of a to-be-registered group whose members are determined already.\r\n    struct PendingGroup {\r\n        uint groupId;\r\n        uint startBlkNum;\r\n        mapping(bytes32 => uint) pubKeyCounts;\r\n        // 0x1 (HEAD) -> member1 -> member2 -> ... -> memberN -> 0x1 (HEAD)\r\n        mapping(address => address) memberList;\r\n    }\r\n\r\n    address private owner;\r\n    uint public initBlkN;\r\n    // calling requestId => PendingQuery metadata\r\n    mapping(uint => PendingRequest) PendingRequests;\r\n\r\n    uint public relayRespondLimit = 100; // in blocks\r\n    uint public refreshSystemRandomHardLimit = 1440; // in blocks, ~6 hour\r\n    uint public groupMaturityPeriod = refreshSystemRandomHardLimit * 28; // in blocks, ~7days\r\n    uint public lifeDiversity = refreshSystemRandomHardLimit * 12; // in blocks, ~3days\r\n    // avoid looping in a big loop that causing over gas.\r\n    uint public loopLimit = 50;\r\n\r\n    // Minimum 4 groups to bootstrap\r\n    uint public bootstrapGroups = 4;\r\n    // When regrouping, picking @groupToPick working groups, plus one group from pending nodes.\r\n    uint public groupToPick = 2;\r\n    uint public groupSize = 3;\r\n\r\n    // Bootstrapping related arguments, in blocks.\r\n    uint public bootstrapCommitDuration = 40;\r\n    uint public bootstrapRevealDuration = 40;\r\n    uint public bootstrapStartThreshold = groupSize * bootstrapGroups;\r\n    uint public bootstrapRound;\r\n    uint public bootstrapEndBlk;\r\n\r\n    DOSAddressBridgeInterface public addressBridge;\r\n    address public proxyFundsAddr;\r\n    address public proxyFundsTokenAddr;\r\n\r\n    uint private constant UINTMAX = uint(-1);\r\n    // Dummy head and placeholder used in linkedlists.\r\n    uint private constant HEAD_I = 0x1;\r\n    address private constant HEAD_A = address(0x1);\r\n\r\n    // Linkedlist of newly registered ungrouped nodes, with HEAD points to the earliest and pendingNodeTail points to the latest.\r\n    // Initial state: pendingNodeList[HEAD_A] == HEAD_A && pendingNodeTail == HEAD_A.\r\n    mapping(address => address) public pendingNodeList;\r\n    address public pendingNodeTail;\r\n    uint public numPendingNodes;\r\n\r\n    // node => a linkedlist of working groupIds the node is in:\r\n    // node => (0x1 -> workingGroupId1 -> workingGroupId2 -> ... -> workingGroupIdm -> 0x1)\r\n    // Initial state: { nodeAddr : { HEAD_I : HEAD_I } }\r\n    mapping(address => mapping(uint => uint)) public nodeToGroupIdList;\r\n\r\n    // groupId => Group\r\n    mapping(uint => Group) workingGroups;\r\n    // Index:groupId\r\n    uint[] public workingGroupIds;\r\n    uint[] public expiredWorkingGroupIds;\r\n\r\n    // groupId => PendingGroup\r\n    mapping(uint => PendingGroup) public pendingGroups;\r\n    uint public pendingGroupMaxLife = 20;  // in blocks\r\n\r\n    // Initial state: pendingGroupList[HEAD_I] == HEAD_I && pendingGroupTail == HEAD_I\r\n    mapping(uint => uint) public pendingGroupList;\r\n    uint public pendingGroupTail;\r\n    uint public numPendingGroups;\r\n\r\n    uint public cachedUpdatedBlock;\r\n    uint public lastUpdatedBlock;\r\n    uint public lastRandomness;\r\n    uint public lastFormGrpReqId;\r\n    Group lastHandledGroup;\r\n\r\n    // Only whitelised guardian are permitted to kick off signalUnregister process\r\n    // TODO : Chose a random group to check and has a consensus about which nodes should be unregister in v2.0.\r\n    mapping(address => bool) public guardianListed;\r\n    enum TrafficType {\r\n        SystemRandom,\r\n        UserRandom,\r\n        UserQuery\r\n    }\r\n\r\n    event LogUrl(uint queryId, uint timeout, string dataSource, string selector, uint randomness, uint dispatchedGroupId);\r\n    event LogRequestUserRandom(uint requestId, uint lastSystemRandomness, uint userSeed, uint dispatchedGroupId);\r\n    event LogNonSupportedType(string invalidSelector);\r\n    event LogNonContractCall(address from);\r\n    event LogCallbackTriggeredFor(address callbackAddr);\r\n    event LogRequestFromNonExistentUC();\r\n    event LogUpdateRandom(uint lastRandomness, uint dispatchedGroupId);\r\n    event LogValidationResult(uint8 trafficType, uint trafficId, bytes message, uint[2] signature, uint[4] pubKey, bool pass);\r\n    event LogInsufficientPendingNode(uint numPendingNodes);\r\n    event LogInsufficientWorkingGroup(uint numWorkingGroups, uint numPendingGroups);\r\n    event LogGrouping(uint groupId, address[] nodeId);\r\n    event LogPublicKeyAccepted(uint groupId, uint[4] pubKey, uint numWorkingGroups);\r\n    event LogPublicKeySuggested(uint groupId, uint pubKeyCount);\r\n    event LogGroupDissolve(uint groupId);\r\n    event LogRegisteredNewPendingNode(address node);\r\n    event LogUnRegisteredNewPendingNode(address node, uint8 unregisterFrom);\r\n    event LogGroupingInitiated(uint pendingNodePool, uint groupsize);\r\n    event LogNoPendingGroup(uint groupId);\r\n    event LogPendingGroupRemoved(uint groupId);\r\n    event LogMessage(string info);\r\n    event GuardianReward(uint blkNum, address guardian);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier fromValidStakingNode {\r\n        require(DOSStakingInterface(addressBridge.getStakingAddress()).isValidStakingNode(msg.sender),\r\n                \"invalid-staking-node\");\r\n        _;\r\n    }\r\n\r\n    modifier hasOracleFee(address from, uint serviceType) {\r\n        require(\r\n            DOSPaymentInterface(addressBridge.getPaymentAddress()).hasServiceFee(from, serviceType),\r\n            \"not-enough-fee-to-oracle\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGuardianListed {\r\n        require(guardianListed[msg.sender], \"not-guardian\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _bridgeAddr, address _proxyFundsAddr, address _proxyFundsTokenAddr) public {\r\n        owner = msg.sender;\r\n        initBlkN = block.number;\r\n        pendingNodeList[HEAD_A] = HEAD_A;\r\n        pendingNodeTail = HEAD_A;\r\n        pendingGroupList[HEAD_I] = HEAD_I;\r\n        pendingGroupTail = HEAD_I;\r\n        addressBridge = DOSAddressBridgeInterface(_bridgeAddr);\r\n        proxyFundsAddr = _proxyFundsAddr;\r\n        proxyFundsTokenAddr = _proxyFundsTokenAddr;\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).setPaymentMethod(proxyFundsAddr, proxyFundsTokenAddr);\r\n    }\r\n\r\n    function addToGuardianList(address _addr) public onlyOwner {\r\n        guardianListed[_addr] = true;\r\n    }\r\n\r\n    function removeFromGuardianList(address _addr) public onlyOwner {\r\n        delete guardianListed[_addr];\r\n    }\r\n\r\n    function setProxyFund(address newFund, address newFundToken) public onlyOwner {\r\n        require(newFund != proxyFundsAddr && newFund != address(0x0), \"invalid-parameter\");\r\n        require(newFundToken != proxyFundsTokenAddr && newFundToken != address(0x0), \"invalid-parameter\");\r\n        proxyFundsAddr = newFund;\r\n        proxyFundsTokenAddr = newFundToken;\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).setPaymentMethod(proxyFundsAddr, proxyFundsTokenAddr);\r\n    }\r\n\r\n    // groupSize must be an odd number.\r\n    function setGroupSize(uint newSize) public onlyOwner {\r\n        require(newSize != groupSize && newSize % 2 != 0, \"invalid-parameter\");\r\n        groupSize = newSize;\r\n    }\r\n\r\n    function setBootstrapStartThreshold(uint newThreshold) public onlyOwner {\r\n        require(newThreshold != bootstrapStartThreshold, \"invalid-parameter\");\r\n        bootstrapStartThreshold = newThreshold;\r\n    }\r\n\r\n    function setBootstrapCommitDuration(uint newDuration) public onlyOwner {\r\n        require(newDuration != bootstrapCommitDuration && newDuration != 0, \"invalid-parameter\");\r\n        bootstrapCommitDuration = newDuration;\r\n    }\r\n\r\n    function setBootstrapRevealDuration(uint newDuration) public onlyOwner {\r\n        require(newDuration != bootstrapRevealDuration && newDuration != 0, \"invalid-parameter\");\r\n        bootstrapRevealDuration = newDuration;\r\n    }\r\n\r\n    function setGroupMaturityPeriod(uint newPeriod) public onlyOwner {\r\n        require(newPeriod != groupMaturityPeriod && newPeriod != 0, \"invalid-parameter\");\r\n        groupMaturityPeriod = newPeriod;\r\n    }\r\n\r\n    function setLifeDiversity(uint newDiversity) public onlyOwner {\r\n        require(newDiversity != lifeDiversity && newDiversity != 0, \"invalid-parameter\");\r\n        lifeDiversity = newDiversity;\r\n    }\r\n\r\n    function setPendingGroupMaxLife(uint newLife) public onlyOwner {\r\n        require(newLife != pendingGroupMaxLife && newLife != 0, \"invalid-parameter\");\r\n        pendingGroupMaxLife = newLife;\r\n    }\r\n\r\n    function setRelayRespondLimit(uint newLimit) public onlyOwner {\r\n        require(newLimit != relayRespondLimit, \"invalid-parameter\");\r\n        relayRespondLimit = newLimit;\r\n    }\r\n\r\n    function setSystemRandomHardLimit(uint newLimit) public onlyOwner {\r\n        require(newLimit != refreshSystemRandomHardLimit && newLimit != 0, \"invalid-parameter\");\r\n        refreshSystemRandomHardLimit = newLimit;\r\n    }\r\n\r\n    function resetOnRecovery(uint cap) public onlyOwner {\r\n        uint len = numPendingNodes + groupSize * (numPendingGroups + workingGroupIds.length + expiredWorkingGroupIds.length);\r\n        cap = cap < len ? cap : len;\r\n\r\n        address n = pendingNodeList[HEAD_A];\r\n        uint prevCap = cap;\r\n        while (cap > 0 && pendingNodeList[HEAD_A] != HEAD_A) {\r\n            nodeToGroupIdList[n][HEAD_I] = 0;\r\n            n = pendingNodeList[n];\r\n            cap--;\r\n        }\r\n        if (prevCap - cap < numPendingNodes) return;\r\n        prevCap = cap;\r\n        pendingNodeList[HEAD_A] = HEAD_A;\r\n        pendingNodeTail = HEAD_A;\r\n        numPendingNodes = 0;\r\n\r\n        uint gid = pendingGroupList[HEAD_I];\r\n        while (cap > 0 && gid != HEAD_I) {\r\n            PendingGroup storage pgrp = pendingGroups[gid];\r\n            address m = pgrp.memberList[HEAD_A];\r\n            while (cap > 0 && m != HEAD_A) {\r\n                nodeToGroupIdList[m][HEAD_I] = 0;\r\n                m = pgrp.memberList[m];\r\n                cap--;\r\n            }\r\n            gid = pendingGroupList[gid];\r\n        }\r\n        if (prevCap - cap < groupSize * numPendingGroups) return;\r\n        prevCap = cap;\r\n        pendingGroupList[HEAD_I] = HEAD_I;\r\n        pendingGroupTail = HEAD_I;\r\n        numPendingGroups = 0;\r\n\r\n        for (uint i = 0; cap > 0 && i < workingGroupIds.length; i++) {\r\n            address[] storage members = workingGroups[workingGroupIds[i]].members;\r\n            for (uint j = 0; cap > 0 && j < members.length; j++) {\r\n                nodeToGroupIdList[members[j]][HEAD_I] = 0;\r\n                cap--;\r\n            }\r\n        }\r\n        if (prevCap - cap < groupSize * workingGroupIds.length) return;\r\n        prevCap = cap;\r\n        workingGroupIds.length = 0;\r\n        for (uint i = 0; cap > 0 && i < expiredWorkingGroupIds.length; i++) {\r\n            address[] storage members = workingGroups[expiredWorkingGroupIds[i]].members;\r\n            for (uint j = 0; cap > 0 && j < members.length; j++) {\r\n                nodeToGroupIdList[members[j]][HEAD_I] = 0;\r\n                cap--;\r\n            }\r\n        }\r\n        if (prevCap - cap < groupSize * expiredWorkingGroupIds.length) return;\r\n        expiredWorkingGroupIds.length = 0;\r\n\r\n        bootstrapRound = 0;\r\n        cachedUpdatedBlock = 0;\r\n        lastUpdatedBlock = 0;\r\n        lastRandomness = 0;\r\n        lastFormGrpReqId = 0;\r\n\r\n        // No need to clear other residual group map states on reset because of unique groupId.\r\n    }\r\n\r\n    function getCodeSize(address addr) private view returns (uint size) {\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n    }\r\n\r\n    function dispatchJobCore(TrafficType trafficType, uint pseudoSeed) private returns(uint idx) {\r\n        uint dissolveIdx = 0;\r\n        do {\r\n            if (workingGroupIds.length == 0) {\r\n                return UINTMAX;\r\n            }\r\n            if (dissolveIdx >= workingGroupIds.length ||\r\n                dissolveIdx >= loopLimit) {\r\n                uint rnd = uint(keccak256(abi.encodePacked(trafficType, pseudoSeed, lastRandomness, block.number)));\r\n                return rnd % workingGroupIds.length;\r\n            }\r\n            Group storage group = workingGroups[workingGroupIds[dissolveIdx]];\r\n            if (groupMaturityPeriod + group.birthBlkN + group.life <= block.number) {\r\n                // Dissolving expired working groups happens in another phase for gas reasons.\r\n                expiredWorkingGroupIds.push(workingGroupIds[dissolveIdx]);\r\n                workingGroupIds[dissolveIdx] = workingGroupIds[workingGroupIds.length - 1];\r\n                workingGroupIds.length--;\r\n            }\r\n            dissolveIdx++;\r\n        } while (true);\r\n    }\r\n\r\n    function dispatchJob(TrafficType trafficType, uint pseudoSeed) private returns(uint) {\r\n        kickoffRandomOnCondition();\r\n        return dispatchJobCore(trafficType, pseudoSeed);\r\n    }\r\n\r\n    function kickoffRandomOnCondition() private returns (bool) {\r\n        if (lastUpdatedBlock + refreshSystemRandomHardLimit > block.number || cachedUpdatedBlock + relayRespondLimit > block.number) {\r\n            return false;\r\n        }\r\n\r\n        uint idx = dispatchJobCore(TrafficType.SystemRandom, uint(blockhash(block.number - 1)));\r\n        // TODO: keep id receipt and handle later in v2.0.\r\n        if (idx == UINTMAX) {\r\n            emit LogMessage(\"no-live-wgrp,try-bootstrap\");\r\n            return false;\r\n        }\r\n\r\n        cachedUpdatedBlock = block.number;\r\n        lastHandledGroup = workingGroups[workingGroupIds[idx]];\r\n        // Signal off-chain clients\r\n        emit LogUpdateRandom(lastRandomness, lastHandledGroup.groupId);\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).chargeServiceFee(proxyFundsAddr, /*requestId=*/lastRandomness, uint(TrafficType.SystemRandom));\r\n        return true;\r\n    }\r\n\r\n    function insertToPendingGroupListTail(uint groupId) private {\r\n        pendingGroupList[groupId] = pendingGroupList[pendingGroupTail];\r\n        pendingGroupList[pendingGroupTail] = groupId;\r\n        pendingGroupTail = groupId;\r\n        numPendingGroups++;\r\n    }\r\n\r\n    function insertToPendingNodeListTail(address node) private {\r\n        pendingNodeList[node] = pendingNodeList[pendingNodeTail];\r\n        pendingNodeList[pendingNodeTail] = node;\r\n        pendingNodeTail = node;\r\n        numPendingNodes++;\r\n    }\r\n\r\n    function insertToPendingNodeListHead(address node) private {\r\n        pendingNodeList[node] = pendingNodeList[HEAD_A];\r\n        pendingNodeList[HEAD_A] = node;\r\n        numPendingNodes++;\r\n    }\r\n\r\n    function insertToListHead(mapping(uint => uint) storage list, uint id) private {\r\n        list[id] = list[HEAD_I];\r\n        list[HEAD_I] = id;\r\n    }\r\n\r\n    /// Remove Node from a storage linkedlist.\r\n    function removeNodeFromList(mapping(address => address) storage list, address node) private returns(address, bool) {\r\n        (address prev, bool found) = findNodeFromList(list, node);\r\n        if (found) {\r\n            list[prev] = list[node];\r\n            delete list[node];\r\n        }\r\n        return (prev, found);\r\n    }\r\n\r\n    /// Find Node from a storage linkedlist.\r\n    function findNodeFromList(mapping(address => address) storage list, address node) private view returns(address, bool) {\r\n        address prev = HEAD_A;\r\n        address curr = list[prev];\r\n        while (curr != HEAD_A && curr != node) {\r\n            prev = curr;\r\n            curr = list[prev];\r\n        }\r\n        if (curr == HEAD_A) {\r\n            return (HEAD_A, false);\r\n        } else {\r\n            return (prev, true);\r\n        }\r\n    }\r\n\r\n    /// Remove id from a storage linkedlist. Need to check tail after this done\r\n    function removeIdFromList(mapping(uint => uint) storage list, uint id) private returns(uint, bool) {\r\n        uint prev = HEAD_I;\r\n        uint curr = list[prev];\r\n        while (curr != HEAD_I && curr != id) {\r\n            prev = curr;\r\n            curr = list[prev];\r\n        }\r\n        if (curr == HEAD_I) {\r\n            return (HEAD_I, false);\r\n        } else {\r\n            list[prev] = list[curr];\r\n            delete list[curr];\r\n            return (prev, true);\r\n        }\r\n    }\r\n\r\n    /// Remove node from a storage linkedlist.\r\n    function checkAndRemoveFromPendingGroup(address node) private returns(bool) {\r\n        uint prev = HEAD_I;\r\n        uint curr = pendingGroupList[prev];\r\n        while (curr != HEAD_I) {\r\n            PendingGroup storage pgrp = pendingGroups[curr];\r\n            (, bool found) = findNodeFromList(pgrp.memberList, node);\r\n            if (found) {\r\n                cleanUpPendingGroup(curr, node);\r\n                return true;\r\n            }\r\n            prev = curr;\r\n            curr = pendingGroupList[prev];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Caller ensures no index overflow. Put members back to pendingNodeList's tail if necessary.\r\n    /// Skip pushing member into pendingNodeList if that_member == skipNode, even when backToPendingPool is set.\r\n    function dissolveWorkingGroup(uint groupId, bool backToPendingPool, address skipNode) private {\r\n        /// Deregister expired working group and remove metadata.\r\n        Group storage grp = workingGroups[groupId];\r\n        for (uint i = 0; i < grp.members.length; i++) {\r\n            address member = grp.members[i];\r\n            // Update nodeToGroupIdList[member] and put members back to pendingNodeList's tail if necessary.\r\n            // Notice: Guardian may need to signal group formation.\r\n            (uint prev, bool removed) = removeIdFromList(nodeToGroupIdList[member], grp.groupId);\r\n            if (removed && prev == HEAD_I) {\r\n                if (backToPendingPool && member != skipNode && pendingNodeList[member] == address(0)) {\r\n                    insertToPendingNodeListTail(member);\r\n                }\r\n            }\r\n        }\r\n        delete workingGroups[groupId];\r\n        emit LogGroupDissolve(groupId);\r\n    }\r\n\r\n    // Returns query id.\r\n    function query(\r\n        address from,\r\n        uint timeout,\r\n        string calldata dataSource,\r\n        string calldata selector\r\n    )\r\n        external\r\n        hasOracleFee(from, uint(TrafficType.UserQuery))\r\n        returns (uint)\r\n    {\r\n        if (getCodeSize(from) > 0) {\r\n            bytes memory bs = bytes(selector);\r\n            // '': Return whole raw response;\r\n            // Starts with '$': response format is parsed as json.\r\n            // Starts with '/': response format is parsed as xml/html.\r\n            if (bs.length == 0 || bs[0] == '$' || bs[0] == '/') {\r\n                uint queryId = uint(keccak256(abi.encode(block.timestamp, from, timeout, dataSource, selector)));\r\n                uint idx = dispatchJob(TrafficType.UserQuery, queryId);\r\n                // TODO: keep id receipt and handle later in v2.0.\r\n                if (idx == UINTMAX) {\r\n                    emit LogMessage(\"skipped-user-query-no-live-wgrp\");\r\n                    return 0;\r\n                }\r\n                Group storage grp = workingGroups[workingGroupIds[idx]];\r\n                PendingRequests[queryId] = PendingRequest(queryId, grp.groupId, grp.groupPubKey, from);\r\n                emit LogUrl(\r\n                    queryId,\r\n                    timeout,\r\n                    dataSource,\r\n                    selector,\r\n                    lastRandomness,\r\n                    grp.groupId\r\n                );\r\n                DOSPaymentInterface(addressBridge.getPaymentAddress()).chargeServiceFee(from, queryId, uint(TrafficType.UserQuery));\r\n                return queryId;\r\n            } else {\r\n                emit LogNonSupportedType(selector);\r\n                return 0;\r\n            }\r\n        } else {\r\n            // Skip if @from is not contract address.\r\n            emit LogNonContractCall(from);\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // Request a new user-level random number.\r\n    function requestRandom(address from, uint userSeed)\r\n        public\r\n        hasOracleFee(from, uint(TrafficType.UserRandom))\r\n        returns (uint)\r\n    {\r\n        uint requestId = uint(keccak256(abi.encode(block.timestamp, from, userSeed)));\r\n        uint idx = dispatchJob(TrafficType.UserRandom, requestId);\r\n        // TODO: keep id receipt and handle later in v2.0.\r\n        if (idx == UINTMAX) {\r\n            emit LogMessage(\"skipped-user-rnd-no-live-wgrp\");\r\n            return 0;\r\n        }\r\n        Group storage grp = workingGroups[workingGroupIds[idx]];\r\n        PendingRequests[requestId] = PendingRequest(requestId, grp.groupId, grp.groupPubKey, from);\r\n        // sign(requestId ||lastSystemRandomness || userSeed ||\r\n        // selected sender in group)\r\n        emit LogRequestUserRandom(\r\n            requestId,\r\n            lastRandomness,\r\n            userSeed,\r\n            grp.groupId\r\n        );\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).chargeServiceFee(\r\n            from == address(this) ? proxyFundsAddr : from,\r\n            requestId,\r\n            uint(TrafficType.UserRandom)\r\n        );\r\n        return requestId;\r\n    }\r\n\r\n    // Random submitter validation + group signature verification.\r\n    function validateAndVerify(\r\n        uint8 trafficType,\r\n        uint trafficId,\r\n        bytes memory data,\r\n        BN256.G1Point memory signature,\r\n        BN256.G2Point memory grpPubKey\r\n    )\r\n        private\r\n        returns (bool)\r\n    {\r\n        // Validation. Clients actually signs (data || addr(selected_submitter)).\r\n        bytes memory message = abi.encodePacked(data, msg.sender);\r\n\r\n        // Verification\r\n        BN256.G1Point[] memory p1 = new BN256.G1Point[](2);\r\n        BN256.G2Point[] memory p2 = new BN256.G2Point[](2);\r\n        p1[0] = BN256.negate(signature);\r\n        p1[1] = BN256.hashToG1(message);\r\n        p2[0] = BN256.P2();\r\n        p2[1] = grpPubKey;\r\n        bool passVerify = BN256.pairingCheck(p1, p2);\r\n        emit LogValidationResult(\r\n            trafficType,\r\n            trafficId,\r\n            message,\r\n            [signature.x, signature.y],\r\n            [grpPubKey.x[0], grpPubKey.x[1], grpPubKey.y[0], grpPubKey.y[1]],\r\n            passVerify\r\n        );\r\n        return passVerify;\r\n    }\r\n\r\n    function triggerCallback(\r\n        uint requestId,\r\n        uint8 trafficType,\r\n        bytes calldata result,\r\n        uint[2] calldata sig\r\n    )\r\n        external\r\n        fromValidStakingNode\r\n    {\r\n        address ucAddr = PendingRequests[requestId].callbackAddr;\r\n        if (ucAddr == address(0x0)) {\r\n            emit LogRequestFromNonExistentUC();\r\n            return;\r\n        }\r\n\r\n        if (!validateAndVerify(\r\n                trafficType,\r\n                requestId,\r\n                result,\r\n                BN256.G1Point(sig[0], sig[1]),\r\n                PendingRequests[requestId].handledGroupPubKey))\r\n        {\r\n            return;\r\n        }\r\n\r\n        emit LogCallbackTriggeredFor(ucAddr);\r\n        delete PendingRequests[requestId];\r\n        if (trafficType == uint8(TrafficType.UserQuery)) {\r\n            UserContractInterface(ucAddr).__callback__(requestId, result);\r\n        } else if (trafficType == uint8(TrafficType.UserRandom)) {\r\n            // Safe random number is the collectively signed threshold signature\r\n            // of the message (requestId || lastRandomness || userSeed ||\r\n            // selected sender in group).\r\n            emit LogMessage(\"UserRandom\");\r\n            UserContractInterface(ucAddr).__callback__(\r\n                requestId, uint(keccak256(abi.encodePacked(sig[0], sig[1]))));\r\n        } else {\r\n            revert(\"unsupported-traffic-type\");\r\n        }\r\n        Group memory grp = workingGroups[PendingRequests[requestId].groupId];\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).recordServiceFee(requestId, msg.sender, grp.members);\r\n    }\r\n\r\n    function toBytes(uint x) private pure returns (bytes memory b) {\r\n        b = new bytes(32);\r\n        assembly { mstore(add(b, 32), x) }\r\n    }\r\n\r\n    // System-level secure distributed random number generator.\r\n    function updateRandomness(uint[2] calldata sig) external fromValidStakingNode {\r\n        if (!validateAndVerify(\r\n                uint8(TrafficType.SystemRandom),\r\n                lastRandomness,\r\n                toBytes(lastRandomness),\r\n                BN256.G1Point(sig[0], sig[1]),\r\n                lastHandledGroup.groupPubKey))\r\n        {\r\n            return;\r\n        }\r\n\r\n        cachedUpdatedBlock = 0;\r\n        lastUpdatedBlock = block.number;\r\n        uint claimFeeId = lastRandomness;\r\n        // Update new randomness = sha3(collectively signed group signature)\r\n        lastRandomness = uint(keccak256(abi.encodePacked(sig[0], sig[1])));\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).recordServiceFee(claimFeeId, msg.sender, lastHandledGroup.members);\r\n    }\r\n\r\n    function cleanUpPendingGroup(uint gid, address skipNode) private {\r\n        PendingGroup storage pgrp = pendingGroups[gid];\r\n        address member = pgrp.memberList[HEAD_A];\r\n        while (member != HEAD_A) {\r\n            // 1. Put member that shouldn't be skipped back to pendingNodeList's head if it's not in any workingGroup.\r\n            // Dissolved endingGroup members have priority to form into a workingGroup.\r\n            if (nodeToGroupIdList[member][HEAD_I] == HEAD_I && member != skipNode && pendingNodeList[member] == address(0)) {\r\n                insertToPendingNodeListHead(member);\r\n            }\r\n            member = pgrp.memberList[member];\r\n        }\r\n        // 2. Update pendingGroupList\r\n        (uint prev, bool removed) = removeIdFromList(pendingGroupList, gid);\r\n        // Reset pendingGroupTail if necessary.\r\n        if (removed && pendingGroupTail == gid) {\r\n            pendingGroupTail = prev;\r\n        }\r\n\r\n        // 3. Update pendingGroup\r\n        delete pendingGroups[gid];\r\n        numPendingGroups--;\r\n        emit LogPendingGroupRemoved(gid);\r\n    }\r\n\r\n    /// Guardian node functions\r\n    /// @dev Guardian signals expiring system randomness and kicks off distributed random engine again.\r\n    ///  Anyone including but not limited to DOS client node can be a guardian and claim rewards.\r\n    function signalRandom() public {\r\n        if (kickoffRandomOnCondition()) {\r\n            emit GuardianReward(block.number, msg.sender);\r\n            DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);\r\n        } else {\r\n            emit LogMessage(\"sys-random-not-expired\");\r\n        }\r\n    }\r\n\r\n    /// @dev Guardian signals to dissolve expired (workingGroup + pendingGroup) and claim guardian rewards.\r\n    function signalGroupDissolve() public {\r\n        // Clean up oldest expired PendingGroup and related metadata. Might be due to failed DKG.\r\n        uint gid = pendingGroupList[HEAD_I];\r\n        if (gid != HEAD_I && pendingGroups[gid].startBlkNum + pendingGroupMaxLife < block.number) {\r\n            cleanUpPendingGroup(gid, HEAD_A);\r\n            emit GuardianReward(block.number, msg.sender);\r\n            DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);\r\n        } else {\r\n            emit LogMessage(\"no-expired-pgrp-to-clean\");\r\n        }\r\n    }\r\n    /// @dev Guardian signals to trigger group formation when there're enough pending nodes.\r\n    ///  If there aren't enough working groups to choose to dossolve, probably a new bootstrap is needed.\r\n    function signalGroupFormation() public {\r\n        if (formGroup()) {\r\n            emit GuardianReward(block.number, msg.sender);\r\n            DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);\r\n        } else {\r\n            emit LogMessage(\"no-grp-formation\");\r\n        }\r\n    }\r\n    function signalBootstrap(uint _cid) public {\r\n        require(bootstrapRound == _cid, \"not-in-bootstrap\");\r\n\r\n        if (block.number <= bootstrapEndBlk) {\r\n            emit LogMessage(\"wait-to-collect-more-entropy\");\r\n            return;\r\n        }\r\n        if (numPendingNodes < bootstrapStartThreshold) {\r\n            emit LogMessage(\"not-enough-p-node-to-bootstrap\");\r\n            return;\r\n        }\r\n        // Reset.\r\n        bootstrapRound = 0;\r\n        bootstrapEndBlk = 0;\r\n        uint rndSeed = CommitRevealInterface(addressBridge.getCommitRevealAddress()).getRandom(_cid);\r\n        if (rndSeed == 0) {\r\n            emit LogMessage(\"bootstrap-commit-reveal-failure\");\r\n            return;\r\n        }\r\n        cachedUpdatedBlock = 0;\r\n        lastUpdatedBlock = block.number;\r\n        lastRandomness = uint(keccak256(abi.encodePacked(lastRandomness, rndSeed)));\r\n\r\n        uint arrSize = bootstrapStartThreshold / groupSize * groupSize;\r\n        address[] memory candidates = new address[](arrSize);\r\n\r\n        pick(arrSize, 0, candidates);\r\n        shuffle(candidates, lastRandomness);\r\n        regroup(candidates, arrSize / groupSize);\r\n        emit GuardianReward(block.number, msg.sender);\r\n        DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);\r\n    }\r\n    // TODO: Chose a random group to check and has a consensus about which nodes should be unregister in v2.0\r\n    function signalUnregister(address member) public onlyGuardianListed {\r\n        if (unregister(member)) {\r\n            emit GuardianReward(block.number, msg.sender);\r\n            DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);\r\n        } else {\r\n            emit LogMessage(\"nothing-to-unregister\");\r\n        }\r\n    }\r\n    /// End of Guardian functions\r\n\r\n    function unregisterNode() public fromValidStakingNode returns (bool) {\r\n        return unregister(msg.sender);\r\n    }\r\n\r\n    // Returns true if successfully unregistered node.\r\n    function unregister(address node) private returns (bool) {\r\n        uint groupId = nodeToGroupIdList[node][HEAD_I];\r\n        bool removed = false;\r\n        uint8 unregisteredFrom = 0;\r\n        // Check if node is in workingGroups or expiredWorkingGroup\r\n        if (groupId != 0 && groupId != HEAD_I) {\r\n            dissolveWorkingGroup(groupId, true, node);\r\n            for (uint idx = 0; idx < workingGroupIds.length; idx++) {\r\n                if (workingGroupIds[idx] == groupId) {\r\n                    if (idx != (workingGroupIds.length - 1)) {\r\n                        workingGroupIds[idx] = workingGroupIds[workingGroupIds.length - 1];\r\n                    }\r\n                    workingGroupIds.length--;\r\n                    removed = true;\r\n                    unregisteredFrom |= 0x1;\r\n                    break;\r\n                }\r\n            }\r\n            if (!removed) {\r\n                for (uint idx = 0; idx < expiredWorkingGroupIds.length; idx++) {\r\n                    if (expiredWorkingGroupIds[idx] == groupId) {\r\n                        if (idx != (expiredWorkingGroupIds.length - 1)) {\r\n                            expiredWorkingGroupIds[idx] = expiredWorkingGroupIds[expiredWorkingGroupIds.length - 1];\r\n                        }\r\n                        expiredWorkingGroupIds.length--;\r\n                        removed = true;\r\n                        unregisteredFrom |= 0x2;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if node is in pendingGroups\r\n        if (!removed && checkAndRemoveFromPendingGroup(node)) {\r\n            unregisteredFrom |= 0x4;\r\n        }\r\n\r\n        // Check if node is in pendingNodeList\r\n        if (pendingNodeList[node] != address(0)) {\r\n            // Update pendingNodeList\r\n            address prev;\r\n            (prev, removed) = removeNodeFromList(pendingNodeList, node);\r\n            if (removed) {\r\n                numPendingNodes--;\r\n                nodeToGroupIdList[node][HEAD_I] = 0;\r\n                // Reset pendingNodeTail if necessary.\r\n                if (pendingNodeTail == node) {\r\n                    pendingNodeTail = prev;\r\n                }\r\n                unregisteredFrom |= 0x8;\r\n            }\r\n        }\r\n        emit LogUnRegisteredNewPendingNode(node, unregisteredFrom);\r\n        DOSStakingInterface(addressBridge.getStakingAddress()).nodeStop(node);\r\n        return (unregisteredFrom != 0);\r\n    }\r\n\r\n    function getWorkingGroupSize() public view returns (uint) {\r\n        return workingGroupIds.length;\r\n    }\r\n\r\n    function getExpiredWorkingGroupSize() public view returns (uint) {\r\n        return expiredWorkingGroupIds.length;\r\n    }\r\n\r\n    function registerNewNode() public fromValidStakingNode {\r\n        // Duplicated pending node\r\n        if (pendingNodeList[msg.sender] != address(0)) {\r\n            return;\r\n        }\r\n        //Already registered in pending or working groups\r\n        if (nodeToGroupIdList[msg.sender][HEAD_I] != 0) {\r\n            return;\r\n        }\r\n        nodeToGroupIdList[msg.sender][HEAD_I] = HEAD_I;\r\n        insertToPendingNodeListTail(msg.sender);\r\n        emit LogRegisteredNewPendingNode(msg.sender);\r\n        DOSStakingInterface(addressBridge.getStakingAddress()).nodeStart(msg.sender);\r\n        formGroup();\r\n    }\r\n\r\n    // Form into new working groups or bootstrap if necessary.\r\n    // Return true if forms a new group.\r\n    function formGroup() private returns(bool) {\r\n        // Clean up oldest expiredWorkingGroup and push back nodes to pendingNodeList if:\r\n        // 1. There's not enough pending nodes to form a group;\r\n        // 2. There's no working group and not enough pending nodes to restart bootstrap.\r\n        if (numPendingNodes < groupSize ||\r\n            (workingGroupIds.length == 0 && numPendingNodes < bootstrapStartThreshold)) {\r\n            if (expiredWorkingGroupIds.length > 0) {\r\n                dissolveWorkingGroup(expiredWorkingGroupIds[0], true, HEAD_A);\r\n                expiredWorkingGroupIds[0] = expiredWorkingGroupIds[expiredWorkingGroupIds.length - 1];\r\n                expiredWorkingGroupIds.length--;\r\n            }\r\n        }\r\n\r\n        if (numPendingNodes < groupSize) {\r\n            emit LogInsufficientPendingNode(numPendingNodes);\r\n            return false;\r\n        }\r\n\r\n        if (workingGroupIds.length > 0) {\r\n            if (expiredWorkingGroupIds.length >= groupToPick) {\r\n                if (lastFormGrpReqId == 0) {\r\n                    lastFormGrpReqId = requestRandom(address(this), block.number);\r\n                    if (lastFormGrpReqId == 0) return false;\r\n                    emit LogGroupingInitiated(numPendingNodes, groupSize);\r\n                    return true;\r\n                } else {\r\n                    emit LogMessage(\"already-in-formation\");\r\n                    return false;\r\n                }\r\n            } else {\r\n                emit LogMessage(\"skipped-formation-not-enough-expired-wgrp\");\r\n            }\r\n        } else if (numPendingNodes >= bootstrapStartThreshold) { // No working group alive and satisfies system re-bootstrap condition.\r\n            if (bootstrapRound == 0) {\r\n                bootstrapRound = CommitRevealInterface(addressBridge.getCommitRevealAddress()).startCommitReveal(\r\n                    block.number,\r\n                    bootstrapCommitDuration,\r\n                    bootstrapRevealDuration,\r\n                    bootstrapStartThreshold\r\n                );\r\n                bootstrapEndBlk = block.number + bootstrapCommitDuration + bootstrapRevealDuration;\r\n                return true;\r\n            } else {\r\n                emit LogMessage(\"already-in-bootstrap\");\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // callback to handle re-grouping using generated random number as random seed.\r\n    function __callback__(uint requestId, uint rndSeed) external {\r\n        require(msg.sender == address(this), \"unauthenticated-resp\");\r\n        require(expiredWorkingGroupIds.length >= groupToPick, \"regroup-not-enough-expired-wgrp\");\r\n        require(numPendingNodes >= groupSize, \"regroup-not-enough-p-node\");\r\n\r\n        lastFormGrpReqId = 0;\r\n        uint arrSize = groupSize * (groupToPick + 1);\r\n        address[] memory candidates = new address[](arrSize);\r\n        for (uint i = 0; i < groupToPick; i++) {\r\n            uint idx = uint(keccak256(abi.encodePacked(rndSeed, requestId, i))) % expiredWorkingGroupIds.length;\r\n            Group storage grpToDissolve = workingGroups[expiredWorkingGroupIds[idx]];\r\n            for (uint j = 0; j < groupSize; j++) {\r\n                candidates[i * groupSize + j] = grpToDissolve.members[j];\r\n            }\r\n            // Do not put selected to-be-dissolved expired working group back to pending node pool.\r\n            dissolveWorkingGroup(grpToDissolve.groupId, false, HEAD_A);\r\n            expiredWorkingGroupIds[idx] = expiredWorkingGroupIds[expiredWorkingGroupIds.length - 1];\r\n            expiredWorkingGroupIds.length--;\r\n        }\r\n\r\n        pick(groupSize, groupSize * groupToPick, candidates);\r\n        shuffle(candidates, rndSeed);\r\n        regroup(candidates, groupToPick + 1);\r\n    }\r\n\r\n    // Pick @num nodes from pendingNodeList's head and put into the @candidates array from @startIndex.\r\n    function pick(uint num, uint startIndex, address[] memory candidates) private {\r\n        for (uint i = 0; i < num; i++) {\r\n            address curr = pendingNodeList[HEAD_A];\r\n            pendingNodeList[HEAD_A] = pendingNodeList[curr];\r\n            delete pendingNodeList[curr];\r\n            candidates[startIndex + i] = curr;\r\n        }\r\n        numPendingNodes -= num;\r\n        // Reset pendingNodeTail if necessary.\r\n        if (numPendingNodes == 0) {\r\n            pendingNodeTail = HEAD_A;\r\n        }\r\n    }\r\n\r\n    // Shuffle a memory array using a secure random seed.\r\n    function shuffle(address[] memory arr, uint rndSeed) private pure {\r\n        for (uint i = arr.length - 1; i > 0; i--) {\r\n            uint j = uint(keccak256(abi.encodePacked(rndSeed, i, arr[i]))) % (i + 1);\r\n            address tmp = arr[i];\r\n            arr[i] = arr[j];\r\n            arr[j] = tmp;\r\n        }\r\n    }\r\n\r\n    // Regroup a shuffled node array.\r\n    function regroup(address[] memory candidates, uint num) private {\r\n        require(candidates.length == groupSize * num, \"candidate-length-mismatch\");\r\n\r\n        address[] memory members = new address[](groupSize);\r\n        uint groupId;\r\n        for (uint i = 0; i < num; i++) {\r\n            groupId = 0;\r\n            for (uint j = 0; j < groupSize; j++) {\r\n                members[j] = candidates[i * groupSize + j];\r\n                groupId = uint(keccak256(abi.encodePacked(groupId, members[j])));\r\n            }\r\n            // groupId = sha3{ sha3(...(sha3(sha3(member 1), member 2), ...), member n), timestamp}\r\n            // This ensures unique groupId even for the same members.\r\n            groupId = uint(keccak256(abi.encodePacked(groupId, block.timestamp)));\r\n            pendingGroups[groupId] = PendingGroup(groupId, block.number);\r\n            mapping(address => address) storage memberList = pendingGroups[groupId].memberList;\r\n            memberList[HEAD_A] = HEAD_A;\r\n            for (uint j = 0; j < groupSize; j++) {\r\n                memberList[members[j]] = memberList[HEAD_A];\r\n                memberList[HEAD_A] = members[j];\r\n            }\r\n            insertToPendingGroupListTail(groupId);\r\n            emit LogGrouping(groupId, members);\r\n        }\r\n    }\r\n\r\n    function registerGroupPubKey(uint groupId, uint[4] calldata suggestedPubKey)\r\n        external\r\n        fromValidStakingNode\r\n    {\r\n        PendingGroup storage pgrp = pendingGroups[groupId];\r\n        if (pgrp.groupId == 0) {\r\n            emit LogNoPendingGroup(groupId);\r\n            return;\r\n        }\r\n\r\n        require(pgrp.memberList[msg.sender] != address(0), \"not-from-authorized-grp-member\");\r\n\r\n        bytes32 hashedPubKey = keccak256(abi.encodePacked(\r\n            suggestedPubKey[0], suggestedPubKey[1], suggestedPubKey[2], suggestedPubKey[3]));\r\n        pgrp.pubKeyCounts[hashedPubKey]++;\r\n        emit LogPublicKeySuggested(groupId, pgrp.pubKeyCounts[hashedPubKey]);\r\n        if (pgrp.pubKeyCounts[hashedPubKey] > groupSize / 2) {\r\n            address[] memory memberArray = new address[](groupSize);\r\n            uint idx = 0;\r\n            address member = pgrp.memberList[HEAD_A];\r\n            while (member != HEAD_A) {\r\n                memberArray[idx++] = member;\r\n                // Update nodeToGroupIdList[member] with new group id.\r\n                insertToListHead(nodeToGroupIdList[member], groupId);\r\n                member = pgrp.memberList[member];\r\n            }\r\n\r\n            workingGroupIds.push(groupId);\r\n            workingGroups[groupId] = Group(\r\n                groupId,\r\n                BN256.G2Point([suggestedPubKey[0], suggestedPubKey[1]], [suggestedPubKey[2], suggestedPubKey[3]]),\r\n                numPendingGroups * lifeDiversity,\r\n                block.number,\r\n                memberArray\r\n            );\r\n            // Update pendingGroupList\r\n            (uint prev, bool removed) = removeIdFromList(pendingGroupList, groupId);\r\n            // Reset pendingGroupTail if necessary.\r\n            if (removed && pendingGroupTail == groupId) {\r\n                pendingGroupTail = prev;\r\n            }\r\n            // Update pendingGroup\r\n            delete pendingGroups[groupId];\r\n            numPendingGroups--;\r\n            emit LogPendingGroupRemoved(groupId);\r\n            emit LogPublicKeyAccepted(groupId, suggestedPubKey, workingGroupIds.length);\r\n        }\r\n    }\r\n}"}}}