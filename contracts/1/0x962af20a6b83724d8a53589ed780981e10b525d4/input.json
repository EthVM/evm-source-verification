{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/UniswapV3Analysor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma abicoder v2;\r\npragma solidity ^0.7.0;\r\n\r\ncontract UniswapV3Analysor {\r\n    struct Pool {\r\n        address pool_address;\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        uint128 liquidity;\r\n        uint256 amount0;\r\n        uint256 amount1;\r\n    }\r\n\r\n    address factory_address = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\r\n    address nfp_manager_address = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\r\n    \r\n    IUniswapV3Factory factory;\r\n    INonfungiblePositionManager nfp_manager;\r\n    \r\n    constructor() {\r\n        factory = IUniswapV3Factory(factory_address);\r\n        nfp_manager = INonfungiblePositionManager(nfp_manager_address);\r\n    }\r\n\r\n    function nftBalanceOf(address account) public view returns (uint) {\r\n        return nfp_manager.balanceOf(account);\r\n    }\r\n\r\n    function nftIDsOf(address account) public view returns (uint[] memory nftIDs) {\r\n        uint nftBalance = nftBalanceOf(account);\r\n        nftIDs = new uint[](nftBalance);\r\n        for (uint i = 0; i < nftBalance; i++) {\r\n            nftIDs[i] = nfp_manager.tokenOfOwnerByIndex(account, i);\r\n        }\r\n    }\r\n    \r\n    function positionOf(uint id) internal view returns (\r\n        address token0,\r\n        address token1,\r\n        uint24 fee,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 liquidity\r\n    ) {\r\n        (\r\n            ,,\r\n            token0,\r\n            token1,\r\n            fee,\r\n            tickLower,\r\n            tickUpper,\r\n            liquidity,\r\n            ,,,\r\n        ) = nfp_manager.positions(id);\r\n    }\r\n    \r\n    function getPools(\r\n        address[] memory token0s,\r\n        address[] memory token1s,\r\n        uint24[] memory fees,\r\n        int24[] memory tickLowers,\r\n        int24[] memory tickUppers,\r\n        uint128[] memory liquidity\r\n    ) public view returns (Pool[] memory pools) {\r\n        require(token0s.length == token1s.length, \"Length of token0s and token1s are different\");\r\n        require(token1s.length == fees.length, \"Length of token1s and fees are different\");\r\n        pools = new Pool[](token0s.length);\r\n\r\n        for (uint i = 0; i < token0s.length; i++) {\r\n            address poolAddress = factory.getPool(token0s[i], token1s[i], fees[i]);\r\n            pools[i].pool_address = poolAddress;\r\n            pools[i].token0 = token0s[i];\r\n            pools[i].token1 = token1s[i];\r\n            pools[i].fee = fees[i];\r\n            pools[i].liquidity = IUniswapV3Pool(pools[i].pool_address).liquidity();\r\n            \r\n            (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(poolAddress).slot0();\r\n            uint160 sqrtRatioAX96 = getSqrtRatioAtTick(tickLowers[i]);\r\n            uint160 sqrtRatioBX96 = getSqrtRatioAtTick(tickUppers[i]);\r\n            \r\n            (uint256 amount0, uint256 amount1) = getAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidity[i]);\r\n            \r\n            pools[i].amount0 = amount0;\r\n            pools[i].amount1 = amount1;\r\n        }\r\n    }\r\n    \r\n    function getSqrtRatioAtTick(int24 tick) public pure returns (uint160) {\r\n        return TickMath.getSqrtRatioAtTick(tick);\r\n    }\r\n    \r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtPriceX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) public pure returns (uint256 amount0, uint256 amount1) {\r\n        return LiquidityAmounts.getAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n    }\r\n}\r\n\r\nlibrary LiquidityAmounts {\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\r\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\r\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\r\n        }\r\n    }\r\n\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                sqrtRatioBX96\r\n            ) / sqrtRatioAX96;\r\n    }\r\n\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\r\n    }\r\n\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\r\n        } else {\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary FixedPoint96 {\r\n    uint8 internal constant RESOLUTION = 96;\r\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\r\n}\r\n\r\nlibrary FullMath {\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        uint256 prod0;\r\n        uint256 prod1;\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n        \r\n        require(denominator > prod1);\r\n\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        uint256 twos = -denominator & denominator;\r\n\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < type(uint256).max);\r\n            result++;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary TickMath {\r\n    int24 internal constant MIN_TICK = -887272;\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(MAX_TICK), 'T');\r\n\r\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n    \r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\r\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n        uint256 r = ratio;\r\n        uint256 msb = 0;\r\n\r\n        assembly {\r\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(5, gt(r, 0xFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(4, gt(r, 0xFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(3, gt(r, 0xFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(2, gt(r, 0xF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(1, gt(r, 0x3))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := gt(r, 0x1)\r\n            msb := or(msb, f)\r\n        }\r\n\r\n        if (msb >= 128) r = ratio >> (msb - 127);\r\n        else r = ratio << (127 - msb);\r\n\r\n        int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(63, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(62, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(61, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(60, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(59, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(58, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(57, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(56, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(55, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(54, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(53, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(52, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(51, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(50, f))\r\n        }\r\n\r\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n    }\r\n}\r\n\r\ninterface IUniswapV3Factory {\r\n    function owner() external view returns (address);\r\n    function feeAmountTickSpacing(uint24) external view returns (int24);\r\n    function getPool(address, address, uint24) external view returns (address);\r\n    function createPool(address, address, uint24) external returns (address);\r\n    function setOwner(address) external;\r\n    function enableFeeAmount(uint24, int24) external;\r\n}\r\n\r\ninterface IUniswapV3Pool\r\n{\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function fee() external view returns (uint24);\r\n    function tickSpacing() external view returns (int24);\r\n    function maxLiquidityPerTick() external view returns (uint128);\r\n    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\r\n    function feeGrowthGlobal0X128() external view returns (uint256);\r\n    function feeGrowthGlobal1X128() external view returns (uint256);\r\n    function protocolFees() external view returns (uint128, uint128);\r\n    function liquidity() external view returns (uint128);\r\n    function ticks(int24) external view returns (uint128, int128, uint256, uint256, int56, uint160, uint32, bool);\r\n    function tickBitmap(int16) external view returns (uint256);\r\n    function positions(bytes32) external view returns (uint128, uint256, uint256, uint128, uint128);\r\n    function observations(uint256) external view returns (uint32, int56, uint160, bool);\r\n    function observe(uint32[] calldata) external view returns (int56[] memory, uint160[] memory);\r\n    function snapshotCumulativesInside(int24, int24) external view returns (int56, uint160, uint32);\r\n    function initialize(uint160) external;\r\n    function mint(address, int24, int24, uint128, bytes calldata) external returns (uint256, uint256);\r\n    function collect(address, int24, int24, uint128, uint128) external returns (uint128, uint128);\r\n    function burn(int24, int24, uint128) external returns (uint256, uint256);\r\n    function swap(address, bool, int256, uint160, bytes calldata) external returns (int256, int256);\r\n    function flash( address, uint256, uint256, bytes calldata) external;\r\n    function increaseObservationCardinalityNext(uint16) external;\r\n    function setFeeProtocol(uint8, uint8) external;\r\n    function collectProtocol( address, uint128, uint128) external returns (uint128, uint128);\r\n}\r\n\r\ninterface INonfungiblePositionManager {\r\n    function positions(uint256) external view returns (uint96, address, address, address, uint24, int24, int24, uint128, uint256, uint256, uint128, uint128);\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function mint(MintParams calldata) external payable returns (uint256, uint128, uint256, uint256);\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function increaseLiquidity(IncreaseLiquidityParams calldata) external payable returns (uint128, uint256, uint256);\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function decreaseLiquidity(DecreaseLiquidityParams calldata) external payable returns (uint256, uint256);\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    function collect(CollectParams calldata) external payable returns (uint256, uint256);\r\n    function burn(uint256) external payable;\r\n    function createAndInitializePoolIfNecessary(address, address, uint24, uint160) external payable returns (address);\r\n    function unwrapWETH9(uint256, address) external payable;\r\n    function refundETH() external payable;\r\n    function sweepToken( address, uint256, address) external payable;\r\n    function factory() external view returns (address);\r\n    function WETH9() external view returns (address);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256) external view returns (string memory);\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address, uint256) external view returns (uint256);\r\n    function tokenByIndex(uint256) external view returns (uint256);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function permit(address, uint256, uint256, uint8, bytes32, bytes32) external payable;\r\n    function balanceOf(address) external view returns (uint256);\r\n    function ownerOf(uint256) external view returns (address);\r\n    function safeTransferFrom(address, address, uint256) external;\r\n    function transferFrom(address, address, uint256) external;\r\n    function approve(address, uint256) external;\r\n    function getApproved(uint256) external view returns (address);\r\n    function setApprovalForAll(address, bool) external;\r\n    function isApprovedForAll(address, address) external view returns (bool);\r\n    function safeTransferFrom(address, address, uint256, bytes calldata) external;\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function allowance(address, address) external view returns (uint);\r\n    function decimals() external view returns(uint);\r\n}"
    }
  }
}