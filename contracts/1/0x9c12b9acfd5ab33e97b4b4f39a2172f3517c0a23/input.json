{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Kektokenlock.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-07-09\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.10;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a/*, \"SafeMath: addition overflow\"*/);\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b <= a/*, errorMessage*/);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        assert(c / a == b/*, \"SafeMath: multiplication overflow\"*/);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b > 0/*, errorMessage*/);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        assert(b != 0/*, errorMessage*/);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract IERC20 {\r\n    function balanceOf(address account) public view virtual returns (uint256);\r\n    function transfer(address to, uint256 value) public virtual returns (bool);\r\n}\r\n\r\n/**\r\n * @dev A token holder contract that will allow a beneficiary to extract the\r\n * tokens after a given release time. \r\n \r\n * This contract was modified to support a daily vesting schedule that will release 1500 everday to Big PP (total locked 50k, more can be locked in the future if desired by community).\r\n */\r\ncontract TokenTimelock {\r\n    using SafeMath for uint256;\r\n\r\n    // ERC20 basic token contract being held\r\n    IERC20 private _token;\r\n\r\n    // Beneficiary of tokens after they are released\r\n    address private _beneficiary;\r\n\r\n    // Timestamp when the timelock started\r\n    uint256 private _startTime;\r\n    \r\n    // Timestamp of the last time vested tokens were claimed\r\n    uint256 private _lastRelease;\r\n    \r\n    // Total days tokens will be locked for\r\n    uint private _totalDays;\r\n    \r\n    // Total tokens the contract holds\r\n    uint private _totalTokens;\r\n    \r\n    // True when the first month of tokens were claimed\r\n    bool private _vestingStarted;\r\n\r\n    constructor (IERC20 token) public {\r\n        _token = token;\r\n        _beneficiary = msg.sender;\r\n        _startTime = block.timestamp;\r\n        _lastRelease = block.timestamp;\r\n        _totalDays = 33;   // tokens will be locked for 33 days\r\n        _vestingStarted = false;\r\n    }\r\n\r\n    /**\r\n     * @return the token being held.\r\n     */\r\n    function token() public view returns (IERC20) {\r\n        return _token;\r\n    }\r\n\r\n    /**\r\n     * @return the beneficiary of the tokens.\r\n     */\r\n    function beneficiary() public view returns (address) {\r\n        return _beneficiary;\r\n    }\r\n\r\n    /**\r\n     * @return the time when the timelock started.\r\n     */\r\n    function startTime() public view returns (uint256) {\r\n        return _startTime;\r\n    }\r\n    \r\n    function lastRelease() public view returns (uint256) {\r\n        return _lastRelease;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by timelock to beneficiary.This will release 1500 tokens a day to beneficiary.\r\n     */\r\n    function release() public {\r\n        \r\n        require(msg.sender == _beneficiary);\r\n        \r\n        if(!_vestingStarted) {\r\n            _totalTokens = _token.balanceOf(address(this));\r\n            _vestingStarted = true;\r\n        }\r\n        \r\n        require(_totalTokens > 0, \"TokenTimelock: no tokens to release\");\r\n         \r\n        \r\n        uint daysSinceLast = block.timestamp.sub(_lastRelease) / 86400;\r\n        \r\n        require(daysSinceLast >= 1);\r\n        \r\n        _lastRelease = block.timestamp;\r\n        \r\n        uint amount = 1500;\r\n\r\n        _token.transfer(_beneficiary, amount);\r\n    }\r\n    \r\n    // Only used in case the above does not work (after 33 days)\r\n    function releaseTheRest() external {\r\n        \r\n        require(msg.sender == _beneficiary);\r\n        \r\n        uint daysSinceStart = block.timestamp.sub(_startTime) / 86400;\r\n        require(daysSinceStart >= 33);\r\n        uint amount = _token.balanceOf(address(this));\r\n        _token.transfer(_beneficiary, amount);\r\n        \r\n    }\r\n    \r\n    function updateBeneficiary(address newBeneficiary) external {\r\n        require(msg.sender == _beneficiary);\r\n        _beneficiary = newBeneficiary;\r\n    }\r\n    \r\n    // Used if more tokens are transferred to be locked\r\n    function syncBalance() external {\r\n        require(msg.sender == _beneficiary);\r\n        _totalTokens = _token.balanceOf(address(this));\r\n    }\r\n    \r\n    function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\r\n          (uint l, uint h) = fullMul (x, y);\r\n          assert (h < z);\r\n          uint mm = mulmod (x, y, z);\r\n          if (mm > l) h -= 1;\r\n          l -= mm;\r\n          uint pow2 = z & -z;\r\n          z /= pow2;\r\n          l /= pow2;\r\n          l += h * ((-pow2) / pow2 + 1);\r\n          uint r = 1;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          r *= 2 - z * r;\r\n          return l * r;\r\n    }\r\n    \r\n    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\r\n          uint mm = mulmod (x, y, uint (-1));\r\n          l = x * y;\r\n          h = mm - l;\r\n          if (mm < l) h -= 1;\r\n    }\r\n}"}}}