{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":99999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Orbet.sol":{"content":"// SPDX-License-Identifier: 0BSD\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary ABDKMath {\r\n    \r\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\r\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\r\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\r\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\r\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\r\n  \r\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\r\n    if (x == 0) return bytes16 (0);\r\n    else {\r\n      uint256 result = x;\r\n\r\n      uint256 _msb = msb (result);\r\n      if (_msb < 112) result <<= 112 - _msb;\r\n      else if (_msb > 112) result >>= _msb - 112;\r\n\r\n      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + _msb << 112;\r\n\r\n      return bytes16 (uint128 (result));\r\n    }\r\n  }\r\n  \r\n  function toUInt (bytes16 x) internal pure returns (uint256) {\r\n    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\r\n\r\n    if (exponent < 16383) return 0; // Underflow\r\n\r\n    require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\r\n\r\n    require (exponent <= 16638); // Overflow\r\n    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\r\n      0x10000000000000000000000000000;\r\n\r\n    if (exponent < 16495) result >>= 16495 - exponent;\r\n    else if (exponent > 16495) result <<= exponent - 16495;\r\n\r\n    return result;\r\n  }\r\n  \r\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\r\n\r\n    if (xExponent == 0x7FFF) {\r\n      if (yExponent == 0x7FFF) { \r\n        if (x == y) return x;\r\n        else return NaN;\r\n      } else return x; \r\n    } else if (yExponent == 0x7FFF) return y;\r\n    else {\r\n      bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\r\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xExponent == 0) xExponent = 1;\r\n      else xSignifier |= 0x10000000000000000000000000000;\r\n\r\n      bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\r\n      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (yExponent == 0) yExponent = 1;\r\n      else ySignifier |= 0x10000000000000000000000000000;\r\n\r\n      if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\r\n      else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\r\n      else {\r\n        int256 delta = int256 (xExponent) - int256 (yExponent);\r\n  \r\n        if (xSign == ySign) {\r\n          if (delta > 112) return x;\r\n          else if (delta > 0) ySignifier >>= uint256 (delta);\r\n          else if (delta < -112) return y;\r\n          else if (delta < 0) {\r\n            xSignifier >>= uint256 (-delta);\r\n            xExponent = yExponent;\r\n          }\r\n  \r\n          xSignifier += ySignifier;\r\n  \r\n          if (xSignifier >= 0x20000000000000000000000000000) {\r\n            xSignifier >>= 1;\r\n            xExponent += 1;\r\n          }\r\n  \r\n          if (xExponent == 0x7FFF)\r\n            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\r\n          else {\r\n            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\r\n            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n  \r\n            return bytes16 (uint128 (\r\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\r\n                (xExponent << 112) |\r\n                xSignifier)); \r\n          }\r\n        } else {\r\n          if (delta > 0) {\r\n            xSignifier <<= 1;\r\n            xExponent -= 1;\r\n          } else if (delta < 0) {\r\n            ySignifier <<= 1;\r\n            xExponent = yExponent - 1;\r\n          }\r\n\r\n          if (delta > 112) ySignifier = 1;\r\n          else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\r\n          else if (delta < -112) xSignifier = 1;\r\n          else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\r\n\r\n          if (xSignifier >= ySignifier) xSignifier -= ySignifier;\r\n          else {\r\n            xSignifier = ySignifier - xSignifier;\r\n            xSign = ySign;\r\n          }\r\n\r\n          if (xSignifier == 0)\r\n            return POSITIVE_ZERO;\r\n\r\n          uint256 _msb = msb (xSignifier);\r\n\r\n          if (_msb == 113) {\r\n            xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            xExponent += 1;\r\n          } else if (_msb < 112) {\r\n            uint256 shift = 112 - _msb;\r\n            if (xExponent > shift) {\r\n              xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n              xExponent -= shift;\r\n            } else {\r\n              xSignifier <<= xExponent - 1;\r\n              xExponent = 0;\r\n            }\r\n          } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n          if (xExponent == 0x7FFF)\r\n            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\r\n          else return bytes16 (uint128 (\r\n              (xSign ? 0x80000000000000000000000000000000 : 0) |\r\n              (xExponent << 112) |\r\n              xSignifier));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    return add (x, y ^ 0x80000000000000000000000000000000);\r\n  }\r\n  \r\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\r\n\r\n    if (xExponent == 0x7FFF) {\r\n      if (yExponent == 0x7FFF) {\r\n        if (x == y) return x ^ y & 0x80000000000000000000000000000000;\r\n        else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\r\n        else return NaN;\r\n      } else {\r\n        if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\r\n        else return x ^ y & 0x80000000000000000000000000000000;\r\n      }\r\n    } else if (yExponent == 0x7FFF) {\r\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\r\n        else return y ^ x & 0x80000000000000000000000000000000;\r\n    } else {\r\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xExponent == 0) xExponent = 1;\r\n      else xSignifier |= 0x10000000000000000000000000000;\r\n\r\n      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (yExponent == 0) yExponent = 1;\r\n      else ySignifier |= 0x10000000000000000000000000000;\r\n\r\n      xSignifier *= ySignifier;\r\n      if (xSignifier == 0)\r\n        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\r\n            NEGATIVE_ZERO : POSITIVE_ZERO;\r\n\r\n      xExponent += yExponent;\r\n\r\n      uint256 _msb =\r\n        xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\r\n        xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\r\n        msb (xSignifier);\r\n\r\n      if (xExponent + _msb < 16496) { // Underflow\r\n        xExponent = 0;\r\n        xSignifier = 0;\r\n      } else if (xExponent + _msb < 16608) { // Subnormal\r\n        if (xExponent < 16496)\r\n          xSignifier >>= 16496 - xExponent;\r\n        else if (xExponent > 16496)\r\n          xSignifier <<= xExponent - 16496;\r\n        xExponent = 0;\r\n      } else if (xExponent + _msb > 49373) {\r\n        xExponent = 0x7FFF;\r\n        xSignifier = 0;\r\n      } else {\r\n        if (_msb > 112)\r\n          xSignifier >>= _msb - 112;\r\n        else if (_msb < 112)\r\n          xSignifier <<= 112 - _msb;\r\n\r\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        xExponent = xExponent + _msb - 16607;\r\n      }\r\n\r\n      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\r\n          xExponent << 112 | xSignifier));\r\n    }\r\n  }\r\n  \r\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\r\n\r\n    if (xExponent == 0x7FFF) {\r\n      if (yExponent == 0x7FFF) return NaN;\r\n      else return x ^ y & 0x80000000000000000000000000000000;\r\n    } else if (yExponent == 0x7FFF) {\r\n      if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\r\n      else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\r\n    } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\r\n      if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\r\n      else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\r\n    } else {\r\n      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (yExponent == 0) yExponent = 1;\r\n      else ySignifier |= 0x10000000000000000000000000000;\r\n\r\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xExponent == 0) {\r\n        if (xSignifier != 0) {\r\n          uint shift = 226 - msb (xSignifier);\r\n\r\n          xSignifier <<= shift;\r\n\r\n          xExponent = 1;\r\n          yExponent += shift - 114;\r\n        }\r\n      }\r\n      else {\r\n        xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\r\n      }\r\n\r\n      xSignifier = xSignifier / ySignifier;\r\n      if (xSignifier == 0)\r\n        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\r\n            NEGATIVE_ZERO : POSITIVE_ZERO;\r\n\r\n      assert (xSignifier >= 0x1000000000000000000000000000);\r\n\r\n      uint256 _msb =\r\n        xSignifier >= 0x80000000000000000000000000000 ? msb (xSignifier) :\r\n        xSignifier >= 0x40000000000000000000000000000 ? 114 :\r\n        xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\r\n\r\n      if (xExponent + _msb > yExponent + 16497) { // Overflow\r\n        xExponent = 0x7FFF;\r\n        xSignifier = 0;\r\n      } else if (xExponent + _msb + 16380  < yExponent) { // Underflow\r\n        xExponent = 0;\r\n        xSignifier = 0;\r\n      } else if (xExponent + _msb + 16268  < yExponent) { // Subnormal\r\n        if (xExponent + 16380 > yExponent)\r\n          xSignifier <<= xExponent + 16380 - yExponent;\r\n        else if (xExponent + 16380 < yExponent)\r\n          xSignifier >>= yExponent - xExponent - 16380;\r\n\r\n        xExponent = 0;\r\n      } else { // Normal\r\n        if (_msb > 112)\r\n          xSignifier >>= _msb - 112;\r\n\r\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        xExponent = xExponent + _msb + 16269 - yExponent;\r\n      }\r\n\r\n      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\r\n          xExponent << 112 | xSignifier));\r\n    }\r\n  }\r\n  \r\n  function msb (uint256 x) private pure returns (uint256) {\r\n    require (x > 0);\r\n\r\n    uint256 result = 0;\r\n\r\n    if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\r\n    if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\r\n    if (x >= 0x100000000) { x >>= 32; result += 32; }\r\n    if (x >= 0x10000) { x >>= 16; result += 16; }\r\n    if (x >= 0x100) { x >>= 8; result += 8; }\r\n    if (x >= 0x10) { x >>= 4; result += 4; }\r\n    if (x >= 0x4) { x >>= 2; result += 2; }\r\n    if (x >= 0x2) result += 1; // No need to shift x anymore\r\n\r\n    return result;\r\n  }\r\n  \r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transfer(address, uint256) external;\r\n    function allowance(address, address) external;\r\n    function approve(address, uint256) external;\r\n    function transferFrom(address, address, uint256) external;\r\n\r\n    event Transfer(address indexed, address indexed, uint256);\r\n    event Approval(address indexed, address indexed, uint256);\r\n    \r\n}\r\n\r\nabstract contract Rebaser {\r\n    uint public orbiSupplyTotal;\r\n}\r\n\r\ncontract Orbet {\r\n    \r\n    address public currencyToken;\r\n    address public rebaser;\r\n    address public liquidityToken;\r\n    address public owner;\r\n    address public badTotalSupplyTokenAddress;\r\n    uint40 public teamMemberCount;\r\n    uint24 public winnerPercentage;\r\n    uint24 public callerPercentage;\r\n    uint24 public initiatorPercentage;\r\n    uint24 public burnPercentage;\r\n    uint24 public vaultPercentage;\r\n    bytes16 public winnerPercentageBytes;\r\n    bytes16 public callerPercentageBytes;\r\n    bytes16 public initiatorPercentageBytes;\r\n    bytes16 public burnPercentageBytes;\r\n    bytes16 public vaultPercentageBytes;\r\n    bytes16 public totalVaultRewards;\r\n    bytes16 public floatErrorOffsetMul;\r\n    uint public totalVaultDeposits;\r\n    uint public betCount;\r\n    bool public frozen;\r\n    uint public percentageDecimals;\r\n    uint public totalOrbits = ~uint(0) - ~uint(0) % 1e17;\r\n    \r\n    struct VaultAccount {\r\n        bytes16 T0TotalVaultRewards;\r\n        uint StoredLiquidity;\r\n    }\r\n    \r\n    struct Position {\r\n        bool Position;\r\n        uint BetAmountOrbits;\r\n        bool RewardClaimed;\r\n    }\r\n    \r\n    struct BetStruct {\r\n        bool UnderThreshold;\r\n        uint8 BetStatus;\r\n        bytes16 ThresholdNoThresholdRatio;\r\n        address ObservedToken;\r\n        address ObservedWallet;\r\n        address Initiator;\r\n        uint Threshold;\r\n        uint ExpiryDate;\r\n        uint TotalThresholdBetAmountOrbits;\r\n        uint TotalNoThresholdBetAmountOrbits;\r\n        mapping(address => Position) Positions;\r\n    }\r\n    \r\n    mapping(address => VaultAccount) public VaultAccounts;\r\n    mapping(uint => BetStruct) public BetStructs;\r\n    uint[] public teamPercentages;\r\n    address[] public teamAddresses;\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    event BetDeposited(uint indexed, bool, uint, address);\r\n    event BetWithdrew(uint indexed, address);\r\n    event BetAdjusted(uint indexed, uint, address);\r\n    event BetRewardClaimed(uint indexed, address);\r\n    event BetEnded(uint indexed, address, bytes16);\r\n    event BetCreated(uint indexed, address);\r\n    \r\n    constructor(address rebaserAddress) {\r\n        owner = msg.sender;\r\n        winnerPercentage = 950000;\r\n        winnerPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(winnerPercentage), 0x4012e848000000000000000000000000);\r\n        callerPercentage = 20000;\r\n        callerPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(callerPercentage), 0x4012e848000000000000000000000000);\r\n        initiatorPercentage = 20000;\r\n        initiatorPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(initiatorPercentage), 0x4012e848000000000000000000000000);\r\n        vaultPercentage = 0;\r\n        vaultPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(vaultPercentage), 0x4012e848000000000000000000000000);\r\n        burnPercentage = 0;\r\n        burnPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(burnPercentage), 0x4012e848000000000000000000000000);\r\n        rebaser = rebaserAddress;\r\n        teamAddresses.push(msg.sender);\r\n        teamPercentages.push(10000);\r\n        teamMemberCount += 1;\r\n        floatErrorOffsetMul = 0x3fff0000000000000000000000000010;\r\n    }\r\n    \r\n    function getOrbitsPerOrbi() internal view returns (uint) {\r\n        if (badTotalSupplyTokenAddress == currencyToken) {\r\n            return totalOrbits / Rebaser(rebaser).orbiSupplyTotal();\r\n        } else {\r\n            return totalOrbits / IERC20(currencyToken).totalSupply();   \r\n        }\r\n    }\r\n    \r\n    function betDeposit(uint betStructId, bool position, uint betAmount) public {\r\n        require(!frozen, \"Frozen!\");\r\n        BetStruct storage betStruct = BetStructs[betStructId];\r\n        require(betStruct.BetStatus == 1, \"Bet Not Active\");\r\n        require(betStruct.Positions[msg.sender].BetAmountOrbits == 0, \"Position Already Exists\");\r\n        uint betAmountOrbits = betAmount * getOrbitsPerOrbi();\r\n        if (!position)\r\n            betStruct.TotalNoThresholdBetAmountOrbits += betAmountOrbits;\r\n        if (position)\r\n            betStruct.TotalThresholdBetAmountOrbits += betAmountOrbits;\r\n        IERC20(currencyToken).transferFrom(msg.sender, address(this), betAmount);\r\n        betStruct.Positions[msg.sender].Position = position;\r\n        betStruct.Positions[msg.sender].BetAmountOrbits = betAmountOrbits;\r\n        emit BetDeposited(betStructId, position, betAmount, msg.sender);\r\n    }\r\n    \r\n    function betWithdraw(uint betStructId) public {\r\n        require(!frozen, \"Frozen!\");\r\n        BetStruct storage betStruct = BetStructs[betStructId];\r\n        require(betStruct.BetStatus == 1, \"Bet Not Active\");\r\n        require(betStruct.Positions[msg.sender].BetAmountOrbits > 0, \"No Position\");\r\n        if (!betStruct.Positions[msg.sender].Position)\r\n            betStruct.TotalNoThresholdBetAmountOrbits -= betStruct.Positions[msg.sender].BetAmountOrbits;\r\n        if (betStruct.Positions[msg.sender].Position)\r\n            betStruct.TotalThresholdBetAmountOrbits -= betStruct.Positions[msg.sender].BetAmountOrbits;\r\n        uint betAmount = betStruct.Positions[msg.sender].BetAmountOrbits / getOrbitsPerOrbi();\r\n        IERC20(currencyToken).transfer(msg.sender, betAmount);\r\n        betStruct.Positions[msg.sender].Position = false;\r\n        betStruct.Positions[msg.sender].BetAmountOrbits = 0;\r\n        emit BetWithdrew(betStructId, msg.sender);\r\n    }\r\n    \r\n    function betAdjust(uint betStructId, uint adjustToAmount) public {\r\n        require(!frozen, \"Frozen!\");\r\n        BetStruct storage betStruct = BetStructs[betStructId];\r\n        require(betStruct.BetStatus == 1, \"Bet Not Active\");\r\n        require(betStruct.Positions[msg.sender].BetAmountOrbits > 0, \"No Position\");\r\n        require(betStruct.Positions[msg.sender].BetAmountOrbits != adjustToAmount, \"No Change\");\r\n        uint betAmount = betStruct.Positions[msg.sender].BetAmountOrbits / (totalOrbits / Rebaser(rebaser).orbiSupplyTotal());\r\n        if (betAmount > adjustToAmount) {\r\n            uint betAmountDiff = betAmount - adjustToAmount;\r\n            uint betAmountOrbitsDiff = betAmountDiff * getOrbitsPerOrbi();\r\n            IERC20(currencyToken).transfer(msg.sender, betAmountDiff);\r\n            if (!betStruct.Positions[msg.sender].Position)\r\n                betStruct.TotalNoThresholdBetAmountOrbits -= betAmountOrbitsDiff;\r\n            if (betStruct.Positions[msg.sender].Position)\r\n                betStruct.TotalThresholdBetAmountOrbits -= betAmountOrbitsDiff;\r\n        } else {\r\n            uint betAmountDiff = adjustToAmount - betStruct.Positions[msg.sender].BetAmountOrbits;\r\n            uint betAmountOrbitsDiff = betAmountDiff * getOrbitsPerOrbi();\r\n            IERC20(currencyToken).transferFrom(msg.sender, address(this), betAmountDiff);\r\n            if (!betStruct.Positions[msg.sender].Position)\r\n                betStruct.TotalNoThresholdBetAmountOrbits += betAmountOrbitsDiff;\r\n            if (betStruct.Positions[msg.sender].Position)\r\n                betStruct.TotalThresholdBetAmountOrbits += betAmountOrbitsDiff;\r\n        }\r\n        betStruct.Positions[msg.sender].BetAmountOrbits = adjustToAmount * getOrbitsPerOrbi();\r\n        emit BetAdjusted(betStructId, adjustToAmount, msg.sender);\r\n    }\r\n    \r\n    function claimReward(uint betStructId) public {\r\n        require(!frozen, \"Frozen!\");\r\n        BetStruct storage betStruct = BetStructs[betStructId];\r\n        require(betStruct.BetStatus == 2, \"Bet Not Finalized\");\r\n        require(betStruct.Positions[msg.sender].RewardClaimed == false, \"Reward Already Claimed\");\r\n        require(betStruct.Positions[msg.sender].Position == betStruct.UnderThreshold, \"Incorrect Position\");\r\n        require(betStruct.Positions[msg.sender].BetAmountOrbits > 0, \"No Bet Amount\");\r\n        bytes16 betAmountDouble = ABDKMath.fromUInt(betStruct.Positions[msg.sender].BetAmountOrbits);\r\n        bytes16 baseCurrencyTokenReward;\r\n        uint finalCurrencyTokenReward;\r\n        if (betStruct.UnderThreshold) {\r\n            if (betStruct.ThresholdNoThresholdRatio == bytes16(0)) {\r\n                baseCurrencyTokenReward = betAmountDouble;\r\n            } else {\r\n                baseCurrencyTokenReward = ABDKMath.add(betAmountDouble, ABDKMath.div(betAmountDouble, betStruct.ThresholdNoThresholdRatio));\r\n            }\r\n        } else {\r\n            if (betStruct.ThresholdNoThresholdRatio == bytes16(0)) {\r\n                baseCurrencyTokenReward = betAmountDouble;\r\n            } else {\r\n                bytes16 thresholdNoThresholdRatioInverse = ABDKMath.div(ABDKMath.fromUInt(1), betStruct.ThresholdNoThresholdRatio);\r\n                baseCurrencyTokenReward = ABDKMath.add(betAmountDouble, ABDKMath.div(betAmountDouble, thresholdNoThresholdRatioInverse));\r\n            }\r\n        }\r\n        finalCurrencyTokenReward = ABDKMath.toUInt(ABDKMath.mul(floatErrorOffsetMul, ABDKMath.mul(baseCurrencyTokenReward, winnerPercentageBytes))) / getOrbitsPerOrbi();\r\n        IERC20(currencyToken).transfer(msg.sender, finalCurrencyTokenReward);\r\n        betStruct.Positions[msg.sender].RewardClaimed = true;\r\n        emit BetRewardClaimed(betStructId, msg.sender);\r\n    }\r\n    \r\n    function endBet(uint betStructId) public {\r\n        require(!frozen, \"Frozen!\");\r\n        BetStruct storage betStruct = BetStructs[betStructId];\r\n        require(betStruct.BetStatus == 1, \"Bet Not Active\");\r\n        require(IERC20(betStruct.ObservedToken).balanceOf(betStruct.ObservedWallet) < betStruct.Threshold || block.timestamp > betStruct.ExpiryDate, \"No End Conditions Met\");\r\n        betStruct.BetStatus = 2;\r\n        uint orbitsPerOrbi = getOrbitsPerOrbi();\r\n        if (betStruct.TotalNoThresholdBetAmountOrbits == 0) {\r\n            betStruct.ThresholdNoThresholdRatio = bytes16(0);\r\n        } else {\r\n            betStruct.ThresholdNoThresholdRatio = ABDKMath.div(ABDKMath.fromUInt(betStruct.TotalThresholdBetAmountOrbits), ABDKMath.fromUInt(betStruct.TotalNoThresholdBetAmountOrbits));\r\n        }\r\n        if (IERC20(betStruct.ObservedToken).balanceOf(betStruct.ObservedWallet) < betStruct.Threshold)\r\n            betStruct.UnderThreshold = true;\r\n        bytes16 combinedOrbitBetAmountBytes = ABDKMath.fromUInt(betStruct.TotalThresholdBetAmountOrbits + betStruct.TotalNoThresholdBetAmountOrbits);\r\n        for (uint i = 0; i < teamAddresses.length; i++) {\r\n            IERC20(currencyToken).transfer(teamAddresses[i], ABDKMath.toUInt(ABDKMath.mul(floatErrorOffsetMul, ABDKMath.mul(ABDKMath.div(ABDKMath.fromUInt(teamPercentages[i]), 0x4012e848000000000000000000000000), combinedOrbitBetAmountBytes))) / orbitsPerOrbi);\r\n        }\r\n        uint _totalVaultDeposits;\r\n        if (totalVaultDeposits > 0) {\r\n            _totalVaultDeposits = totalVaultDeposits;\r\n        } else {\r\n            _totalVaultDeposits = 1;\r\n        }\r\n        if (vaultPercentage > 0) {\r\n            totalVaultRewards = ABDKMath.add(totalVaultRewards, ABDKMath.div(ABDKMath.mul(combinedOrbitBetAmountBytes, vaultPercentageBytes), ABDKMath.fromUInt(_totalVaultDeposits)));\r\n        }\r\n        IERC20(currencyToken).transfer(msg.sender, ABDKMath.toUInt(ABDKMath.mul(floatErrorOffsetMul, ABDKMath.mul(callerPercentageBytes, combinedOrbitBetAmountBytes))) / orbitsPerOrbi);\r\n        IERC20(currencyToken).transfer(betStruct.Initiator, ABDKMath.toUInt(ABDKMath.mul(floatErrorOffsetMul, ABDKMath.mul(initiatorPercentageBytes, combinedOrbitBetAmountBytes))) / orbitsPerOrbi);\r\n        if (burnPercentage > 0) {\r\n            IERC20(currencyToken).transfer(address(0), ABDKMath.toUInt(ABDKMath.mul(floatErrorOffsetMul, ABDKMath.mul(burnPercentageBytes, combinedOrbitBetAmountBytes))) / orbitsPerOrbi);\r\n        }\r\n      emit BetEnded(betStructId, msg.sender, totalVaultRewards);\r\n    }\r\n    \r\n    function createBet(address observedToken, address observedWallet, uint threshold, uint expiryDate) external returns (uint) {\r\n        require(!frozen, \"Frozen!\");\r\n        require(currencyToken != address(0), \"Currency Token Not Set\");\r\n        require(observedToken != address(0) && observedWallet != address(0) && threshold > 0 && expiryDate > block.timestamp, 'Invalid Parameters');\r\n        BetStructs[betCount].ObservedToken = observedToken;\r\n        BetStructs[betCount].ObservedWallet = observedWallet;\r\n        BetStructs[betCount].Threshold = threshold;\r\n        BetStructs[betCount].ExpiryDate = expiryDate;\r\n        BetStructs[betCount].Initiator = msg.sender;\r\n        BetStructs[betCount].BetStatus = 1;\r\n        emit BetCreated(betCount, msg.sender);\r\n        betCount += 1;\r\n        return betCount - 1;\r\n    }\r\n\r\n    function createBet2(address observedToken, address observedWallet, uint threshold, uint expiryDate, bool position, uint betAmount) external returns (uint) {\r\n        require(!frozen, \"Frozen!\");\r\n        require(currencyToken != address(0), \"Currency Token Not Set\");\r\n        require(observedToken != address(0) && observedWallet != address(0) && threshold > 0 && expiryDate > block.timestamp, 'Invalid Parameters');\r\n        BetStructs[betCount].ObservedToken = observedToken;\r\n        BetStructs[betCount].ObservedWallet = observedWallet;\r\n        BetStructs[betCount].Threshold = threshold;\r\n        BetStructs[betCount].ExpiryDate = expiryDate;\r\n        BetStructs[betCount].Initiator = msg.sender;\r\n        BetStructs[betCount].BetStatus = 1;\r\n        emit BetCreated(betCount, msg.sender);\r\n        betCount += 1;\r\n        Orbet.betDeposit(betCount, position, betAmount);\r\n        return betCount - 1;\r\n    }\r\n    \r\n    function vaultCheckRewards() external view returns (uint) {\r\n        require(VaultAccounts[msg.sender].StoredLiquidity > 0, \"No Vault Position Exists\");\r\n        return ABDKMath.toUInt(ABDKMath.div(ABDKMath.mul(ABDKMath.sub(totalVaultRewards, VaultAccounts[msg.sender].T0TotalVaultRewards), ABDKMath.fromUInt(VaultAccounts[msg.sender].StoredLiquidity)), ABDKMath.fromUInt(getOrbitsPerOrbi())));\r\n    }\r\n    \r\n    function vaultWithdrawRewards() external {\r\n        require(VaultAccounts[msg.sender].StoredLiquidity > 0, \"No Vault Position Exists\");\r\n        require(!frozen, \"Frozen!\");\r\n        IERC20(currencyToken).transfer(msg.sender, ABDKMath.toUInt(ABDKMath.div(ABDKMath.mul(ABDKMath.sub(totalVaultRewards, VaultAccounts[msg.sender].T0TotalVaultRewards), ABDKMath.fromUInt(VaultAccounts[msg.sender].StoredLiquidity)), ABDKMath.fromUInt(getOrbitsPerOrbi()))));\r\n        VaultAccounts[msg.sender].T0TotalVaultRewards = totalVaultRewards;\r\n    }\r\n    \r\n    function vaultWithdraw() external {\r\n        require(!frozen, \"Frozen!\");\r\n        require(VaultAccounts[msg.sender].StoredLiquidity > 0, \"No Vault Position Exists\");\r\n        if (this.vaultCheckRewards() > 0) {\r\n            IERC20(currencyToken).transfer(msg.sender, ABDKMath.toUInt(ABDKMath.mul(ABDKMath.sub(totalVaultRewards, VaultAccounts[msg.sender].T0TotalVaultRewards), ABDKMath.fromUInt(VaultAccounts[msg.sender].StoredLiquidity))));\r\n        }\r\n        IERC20(liquidityToken).transfer(msg.sender, VaultAccounts[msg.sender].StoredLiquidity);\r\n        totalVaultDeposits -= VaultAccounts[msg.sender].StoredLiquidity;\r\n        VaultAccounts[msg.sender].StoredLiquidity = 0;\r\n    }\r\n    \r\n    function vaultDeposit(uint depositAmount) external {\r\n        require(!frozen, \"Frozen!\");\r\n        require(VaultAccounts[msg.sender].StoredLiquidity == 0, \"Vault Position Already Exists\");\r\n        IERC20(liquidityToken).transferFrom(msg.sender, address(this), depositAmount);\r\n        VaultAccounts[msg.sender].StoredLiquidity = depositAmount;\r\n        VaultAccounts[msg.sender].T0TotalVaultRewards = totalVaultRewards;\r\n        totalVaultDeposits += depositAmount;\r\n    }\r\n\r\n    function vaultAdjust(uint newDepositAmount) external {\r\n        require(!frozen, \"Frozen!\");\r\n        require(VaultAccounts[msg.sender].StoredLiquidity > 0, \"No Stored Liquidity\");\r\n        require(newDepositAmount != VaultAccounts[msg.sender].StoredLiquidity, \"No Change\");\r\n        if (newDepositAmount > VaultAccounts[msg.sender].StoredLiquidity) {\r\n            IERC20(liquidityToken).transferFrom(msg.sender, address(this), newDepositAmount - VaultAccounts[msg.sender].StoredLiquidity);\r\n        } else {\r\n            IERC20(liquidityToken).transfer(msg.sender, VaultAccounts[msg.sender].StoredLiquidity - newDepositAmount);\r\n        }\r\n        VaultAccounts[msg.sender].StoredLiquidity = newDepositAmount;\r\n        IERC20(currencyToken).transfer(msg.sender, ABDKMath.toUInt(ABDKMath.mul(ABDKMath.sub(totalVaultRewards, VaultAccounts[msg.sender].T0TotalVaultRewards), ABDKMath.fromUInt(VaultAccounts[msg.sender].StoredLiquidity))));\r\n        VaultAccounts[msg.sender].T0TotalVaultRewards = totalVaultRewards;\r\n    }\r\n    \r\n    function setCurrencyToken(address _currencyToken) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        currencyToken = _currencyToken;\r\n    }\r\n    \r\n    function setLiquidityToken(address _liquidityToken) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        liquidityToken = _liquidityToken;\r\n    }\r\n    \r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function setWinnerPercentage(uint24 newWinnerPercentage) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        winnerPercentage = newWinnerPercentage;\r\n        winnerPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(winnerPercentage), 0x4012e848000000000000000000000000);\r\n    }\r\n    \r\n    function setCallerPercentage(uint24 newCallerPercentage) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        callerPercentage = newCallerPercentage;\r\n        callerPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(callerPercentage), 0x4012e848000000000000000000000000);\r\n    }\r\n    \r\n    function setInitiatorPercentage(uint24 newInitiatorPercentage) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        initiatorPercentage = newInitiatorPercentage;\r\n        initiatorPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(initiatorPercentage), 0x4012e848000000000000000000000000);\r\n    }\r\n    \r\n    function setBurnPercentage(uint24 newBurnPercentage) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        burnPercentage = newBurnPercentage;\r\n        burnPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(burnPercentage), 0x4012e848000000000000000000000000);\r\n    }\r\n    \r\n    function setVaultPercentage(uint24 newVaultPercentage) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        vaultPercentage = newVaultPercentage;\r\n        vaultPercentageBytes = ABDKMath.div(ABDKMath.fromUInt(vaultPercentage), 0x4012e848000000000000000000000000);\r\n    }\r\n    \r\n    function addTeamContract(address teamMemberAddress, uint24 teamMemberPercent) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        require(teamMemberPercent > 0 && teamMemberPercent < 10000000, \"Invalid Percent\");\r\n        teamAddresses.push(teamMemberAddress);\r\n        teamPercentages.push(teamMemberPercent);\r\n        teamMemberCount += 1;\r\n    }\r\n    \r\n    function removeTeamContract(address teamMemberAddress) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        for (uint i = 0; i < teamAddresses.length; i++) {\r\n            if (teamAddresses[i] == teamMemberAddress) {\r\n                teamAddresses[i] = teamAddresses[teamAddresses.length - 1];\r\n                teamPercentages[i] = teamPercentages[teamPercentages.length - 1];\r\n                teamAddresses.pop();\r\n                teamPercentages.pop();\r\n                teamMemberCount -= 1;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setBadTotalSupplyTokenAddress(address _badTotalSupplyTokenAddress) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        badTotalSupplyTokenAddress = _badTotalSupplyTokenAddress;\r\n    }\r\n    \r\n    function changeTeamContract(address teamMemberAddress, uint newTeamMemberPercent) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        for (uint i = 0; i < teamAddresses.length; i++) {\r\n            if (teamAddresses[i] == teamMemberAddress)\r\n                teamPercentages[i] = newTeamMemberPercent;\r\n        }\r\n    }\r\n    \r\n    function freeze() external onlyOwner {\r\n        frozen = true;\r\n    } \r\n    \r\n    function unfreeze() external onlyOwner {\r\n        frozen = false;\r\n    } \r\n\r\n    function getBetStructPosition(uint betId, address bettor) public view returns (bool, uint) {\r\n        Position storage position = BetStructs[betId].Positions[bettor];\r\n        return (position.Position, position.BetAmountOrbits / getOrbitsPerOrbi());\r\n    }\r\n    \r\n    function setTotalOrbits(uint _totalOrbits) external onlyOwner {\r\n        require(!frozen, \"Frozen!\");\r\n        totalOrbits = _totalOrbits;\r\n    }\r\n    \r\n}"}}}