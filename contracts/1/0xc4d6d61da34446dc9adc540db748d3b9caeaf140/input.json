{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "CouponTrader.sol": {
      "content": "pragma solidity 0.7.5;\r\npragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\n\r\n/**\r\nCopyright (c) 2020 Austin Williams\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n**/\r\n\r\ninterface IESDS {\r\n    function transferCoupons(address _sender, address _recipient, uint256 _epoch, uint256 _amount) external;\r\n    function balanceOfCoupons(address _account, uint256 _epoch) external view returns (uint256);\r\n    function allowanceCoupons(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _account) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\ncontract CouponTrader {\r\n    using SafeMath for uint256;\r\n\r\n    IESDS constant private ESDS = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\r\n    IERC20 constant private USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    uint256 constant private HOUSE_RATE = 100; // 100 basis points (1%) -- fee taken by the house\r\n    address constant private OPEN_SALE_INDICATOR = 0x0000000000000000000000000000000000000001; // if this is the \"buyer\" then anyone can buy\r\n    address public house = 0xE1dba80BAc43407360c7b0175444893eBaA30098; // collector of house take\r\n    \r\n    struct Offer {\r\n        address buyer; // use OPEN_SALE_INDICATOR as the buyer address if you want to allow anyone to take the offer\r\n        uint256 epoch;\r\n        uint256 numCoupons; // 18 decimals\r\n        uint256 totalUSDCRequiredFromSeller; // 6 decimals\r\n    }\r\n    \r\n    mapping (address => Offer) private offerBySeller;\r\n    \r\n    event OfferSet(address indexed seller, address indexed buyer, uint256 indexed epoch, uint256 numCoupons, uint256 totalUSDCRequiredFromSeller);\r\n    event SuccessfulTrade(address indexed seller, address indexed buyer, uint256 epoch, uint256 numCoupons, uint256 totalUSDCRequiredFromSeller);\r\n    \r\n    /** ======================== \r\n        STATE MUTATING FUNCTIONS\r\n        ======================== **/\r\n    \r\n    // @notice Allows a seller to set or update an offer\r\n    // @notice Caller MUST have approved this contract to move their coupons before calling this function or else this will revert.\r\n    // @dev Does some sanity checks to make sure the seller can hold up their end. This check \r\n    //    is for UX purposes only and can be bypassed trivially. It is not security critical.\r\n    // @param _buyer The buyer who is allowed to take this offer. If the _buyer param is set to OPEN_SALE_INDICATOR then\r\n    //    anyone can take this offer.\r\n    // @param _epoch The epoch of the coupons to be sold.\r\n    // @param _numCoupons The number of coupons to be sold.\r\n    // @param _totalUSDCRequiredFromSeller The amount of USDC the buyer must pay to take this offer. Remember that USDC uses 6 decimal places, not 18.\r\n    function setOffer(address _buyer, uint256 _epoch, uint256 _numCoupons, uint256 _totalUSDCRequiredFromSeller) external {\r\n        // sanity checks\r\n        require(ESDS.balanceOfCoupons(msg.sender, _epoch) >= _numCoupons, \"seller doesn't have enough coupons at that epoch\");\r\n        require(ESDS.allowanceCoupons(msg.sender, address(this)) >= _numCoupons, \"seller hasn't approved this contract to move enough coupons\");\r\n        require(_totalUSDCRequiredFromSeller > 0, \"_totalUSDCRequiredFromSeller is zero -- use the revokeOffer function\");\r\n        \r\n        // store new offer\r\n        Offer memory newOffer = Offer(_buyer, _epoch, _numCoupons, _totalUSDCRequiredFromSeller);\r\n        offerBySeller[msg.sender] = newOffer;\r\n        \r\n        emit OfferSet(msg.sender, _buyer, _epoch, _numCoupons, _totalUSDCRequiredFromSeller);\r\n    }\r\n    \r\n    // @notice A convenience function a seller can use to revoke their offer.\r\n    function revokeOffer() external {\r\n        delete offerBySeller[msg.sender];\r\n        emit OfferSet(msg.sender, address(0), 0, 0, 0);\r\n    }\r\n    \r\n    // @notice Allows a buyer to take an offer.\r\n    // @dev Partial fills are not supported.\r\n    // @dev The buyer must have approved this contract to move enough USDC to pay for this purchase.\r\n    // @param _seller The seller whose offer the caller wants to take.\r\n    // @param _epoch The epoch of the coupons being bought (must match the seller's offer). \r\n    // @param _numCoupons The number of coupons being bought (must match the seller's offer).\r\n    // @param _totalUSDCRequiredFromSeller The amount of USDC the buyer is paying (must match the seller's offer).\r\n    function takeOffer(address _seller, uint256 _epoch, uint256 _numCoupons, uint256 _totalUSDCRequiredFromSeller) external {\r\n        // get offer information\r\n        Offer memory offer = offerBySeller[_seller];\r\n        \r\n        // check that the caller is authorized\r\n        require(msg.sender == offer.buyer || offer.buyer == OPEN_SALE_INDICATOR, \"unauthorized buyer\");\r\n        \r\n        // check that the order details are correct (protects buyer from frontrunning by the seller)\r\n        require(\r\n            offer.epoch == _epoch &&\r\n            offer.numCoupons == _numCoupons &&\r\n            offer.totalUSDCRequiredFromSeller == _totalUSDCRequiredFromSeller,\r\n            \"order details do not match the seller's offer\"\r\n        );\r\n        \r\n        // delete the seller's offer (so this offer cannot be filled twice)\r\n        delete offerBySeller[_seller];\r\n        \r\n        // compute house take and seller take (USDC)\r\n        uint256 houseTake = offer.totalUSDCRequiredFromSeller.mul(HOUSE_RATE).div(10_000);\r\n        uint256 sellerTake = offer.totalUSDCRequiredFromSeller.sub(houseTake);\r\n        \r\n        // pay the seller USDC\r\n        require(USDC.transferFrom(msg.sender, _seller, sellerTake), \"could not pay seller\");\r\n        \r\n        // pay the house USDC\r\n        require(USDC.transferFrom(msg.sender, house, houseTake), \"could not pay house\");\r\n        \r\n        // transfer the coupons to the buyer\r\n        ESDS.transferCoupons(_seller, msg.sender, _epoch, _numCoupons); // @audit-ok reverts on failure\r\n        \r\n        // emit events\r\n        emit SuccessfulTrade(_seller, msg.sender, _epoch, _numCoupons, _totalUSDCRequiredFromSeller);\r\n        emit OfferSet(_seller, address(0), 0, 0, 0);\r\n    }\r\n    \r\n    // @notice Allows house address to change the house address\r\n    function changeHouseAddress(address _newAddress) external {\r\n        require(msg.sender == house);\r\n        house = _newAddress;\r\n    }\r\n    \r\n    /** ======================\r\n        NON-MUTATING FUNCTIONS\r\n        ====================== **/\r\n    \r\n    // @notice A getter for the offers\r\n    // @param _seller The address of the seller whose offer we want to return.\r\n    function getOffer(address _seller) external view returns (address, uint256, uint256, uint256) {\r\n        Offer memory offer = offerBySeller[_seller];\r\n        return (offer.buyer, offer.epoch, offer.numCoupons, offer.totalUSDCRequiredFromSeller);\r\n    }\r\n    \r\n    // @notice Returns true iff the _buyer is authorized to take the _offer offer.\r\n    function isAuthorizedBuyer(Offer memory _offer, address _buyer) public pure returns (bool) {\r\n        return ( _buyer == _offer.buyer || _offer.buyer == OPEN_SALE_INDICATOR );\r\n    }\r\n    \r\n    // @notice Returns true iff all the details passed match the _offer.\r\n    function detailsMatch(Offer memory _offer, uint256 _epoch, uint256 _numCoupons, uint256 _totalUSDCRequiredFromSeller) public pure returns (bool) {\r\n        return (\r\n            _offer.epoch == _epoch &&\r\n            _offer.numCoupons == _numCoupons &&\r\n            _offer.totalUSDCRequiredFromSeller == _totalUSDCRequiredFromSeller\r\n        );\r\n    }\r\n    \r\n    // @notice Returns true iff the _seller holds at least _numCoupons coupons.\r\n    function sellerHasTheCoupons(address _seller, uint256 _epoch, uint256 _numCoupons) public view returns (bool) {\r\n        return ( ESDS.balanceOfCoupons(_seller, _epoch) >= _numCoupons );\r\n    }\r\n    \r\n    // @notice Returns true iff the _seller has approve this contract to move at least _numCoupons coupons.\r\n    function sellerHasApprovedCoupons(address _seller, uint256 _numCoupons) public view returns (bool) {\r\n        return ( ESDS.allowanceCoupons(_seller, address(this)) >= _numCoupons );\r\n    }\r\n    \r\n    // @notice Returns true iff the _buyer holds at least _totalUSDCRequiredFromSeller USDC.\r\n    function buyerHasTheUSDC(address _buyer, uint256 _totalUSDCRequiredFromSeller) public view returns (bool) {\r\n        return ( USDC.balanceOf(_buyer) >= _totalUSDCRequiredFromSeller );\r\n    }\r\n    \r\n    // @notice Returns true iff the _buyer has approve this contract to move at least _totalUSDCRequiredFromSeller USDC.\r\n    function buyerHasApprovedUSDC(address _buyer, uint256 _totalUSDCRequiredFromSeller) public view returns (bool) {\r\n        return ( USDC.allowance(_buyer, address(this)) >= _totalUSDCRequiredFromSeller );\r\n    }\r\n    \r\n    // @notice Returns true iff the entered offer would likely succeed if taken by the _buyer right now.\r\n    // @dev This is just for UI convenience. It should not be relied upon for anything security-related.\r\n    function tradeShouldSucceed(address _buyer, address _seller, uint256 _epoch, uint256 _numCoupons, uint256 _totalUSDCRequiredFromSeller)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        Offer memory offer = offerBySeller[_seller];\r\n\r\n        return (\r\n            isAuthorizedBuyer(offer, _buyer) &&\r\n            detailsMatch(offer, _epoch, _numCoupons, _totalUSDCRequiredFromSeller) &&\r\n            sellerHasTheCoupons(_seller, _epoch, _numCoupons) &&\r\n            sellerHasApprovedCoupons(_seller, _numCoupons) &&\r\n            buyerHasTheUSDC(_buyer, _totalUSDCRequiredFromSeller) &&\r\n            buyerHasApprovedUSDC(_buyer, _totalUSDCRequiredFromSeller)\r\n        );\r\n    }\r\n    \r\n    // @notice Convenience function for encoding offers.\r\n    function offerEncoder(address _buyer, uint256 _epoch, uint256 _numCoupons, uint256 _totalUSDCRequiredFromSeller)\r\n        external\r\n        pure\r\n        returns (Offer memory)\r\n    {\r\n        return Offer(_buyer, _epoch, _numCoupons, _totalUSDCRequiredFromSeller);   \r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    }
  }
}