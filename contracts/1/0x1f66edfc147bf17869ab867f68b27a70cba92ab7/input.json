{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":100},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/arch/Hashing.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Value.sol\";\n\nlibrary Hashing {\n    using Hashing for Value.Data;\n    using Value for Value.CodePoint;\n\n    function keccak1(bytes32 b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(b));\n    }\n\n    function keccak2(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(a, b));\n    }\n\n    function bytes32FromArray(\n        bytes memory arr,\n        uint256 offset,\n        uint256 arrLength\n    ) internal pure returns (uint256) {\n        uint256 res = 0;\n        for (uint256 i = 0; i < 32; i++) {\n            res = res << 8;\n            bytes1 b = arrLength > offset + i ? arr[offset + i] : bytes1(0);\n            res = res | uint256(uint8(b));\n        }\n        return res;\n    }\n\n    /*\n     * !! Note that dataLength must be a power of two !!\n     *\n     * If you have an arbitrary data length, you can round it up with roundUpToPow2.\n     * The boolean return value tells if the data segment data[startOffset..startOffset+dataLength] only included zeroes.\n     * If pack is true, the returned value is the merkle hash where trailing zeroes are ignored, that is,\n     *   if h is the smallest height for which all data[startOffset+2**h..] are zero, merkle hash of data[startOffset..startOffset+2**h] is returned.\n     * If all elements in the data segment are zero (and pack is true), keccak1(bytes32(0)) is returned.\n     */\n    function merkleRoot(\n        bytes memory data,\n        uint256 rawDataLength,\n        uint256 startOffset,\n        uint256 dataLength,\n        bool pack\n    ) internal pure returns (bytes32, bool) {\n        if (dataLength <= 32) {\n            if (startOffset >= rawDataLength) {\n                return (keccak1(bytes32(0)), true);\n            }\n            bytes32 res = keccak1(bytes32(bytes32FromArray(data, startOffset, rawDataLength)));\n            return (res, res == keccak1(bytes32(0)));\n        }\n        (bytes32 h2, bool zero2) =\n            merkleRoot(data, rawDataLength, startOffset + dataLength / 2, dataLength / 2, false);\n        if (zero2 && pack) {\n            return merkleRoot(data, rawDataLength, startOffset, dataLength / 2, pack);\n        }\n        (bytes32 h1, bool zero1) =\n            merkleRoot(data, rawDataLength, startOffset, dataLength / 2, false);\n        return (keccak2(h1, h2), zero1 && zero2);\n    }\n\n    function roundUpToPow2(uint256 len) internal pure returns (uint256) {\n        if (len <= 1) return 1;\n        else return 2 * roundUpToPow2((len + 1) / 2);\n    }\n\n    function bytesToBufferHash(\n        bytes memory buf,\n        uint256 startOffset,\n        uint256 length\n    ) internal pure returns (bytes32) {\n        (bytes32 mhash, ) =\n            merkleRoot(buf, startOffset + length, startOffset, roundUpToPow2(length), true);\n        return keccak2(bytes32(uint256(123)), mhash);\n    }\n\n    function hashInt(uint256 val) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(val));\n    }\n\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {\n        assert(cp.immediate.length < 2);\n        if (cp.immediate.length == 0) {\n            return\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\n        }\n        return\n            keccak256(\n                abi.encodePacked(\n                    Value.codePointTypeCode(),\n                    cp.opcode,\n                    cp.immediate[0].hash(),\n                    cp.nextCodePoint\n                )\n            );\n    }\n\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\n    }\n\n    function hash(Value.Data memory val) internal pure returns (bytes32) {\n        if (val.typeCode == Value.intTypeCode()) {\n            return hashInt(val.intVal);\n        } else if (val.typeCode == Value.codePointTypeCode()) {\n            return hashCodePoint(val.cpVal);\n        } else if (val.typeCode == Value.tuplePreImageTypeCode()) {\n            return hashTuplePreImage(bytes32(val.intVal), val.size);\n        } else if (val.typeCode == Value.tupleTypeCode()) {\n            Value.Data memory preImage = getTuplePreImage(val.tupleVal);\n            return preImage.hash();\n        } else if (val.typeCode == Value.hashOnlyTypeCode()) {\n            return bytes32(val.intVal);\n        } else if (val.typeCode == Value.bufferTypeCode()) {\n            return keccak256(abi.encodePacked(uint256(123), val.bufferHash));\n        } else {\n            require(false, \"Invalid type code\");\n        }\n    }\n\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {\n        require(vals.length <= 8, \"Invalid tuple length\");\n        bytes32[] memory hashes = new bytes32[](vals.length);\n        uint256 hashCount = hashes.length;\n        uint256 size = 1;\n        for (uint256 i = 0; i < hashCount; i++) {\n            hashes[i] = vals[i].hash();\n            size += vals[i].size;\n        }\n        bytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\n        return Value.newTuplePreImage(firstHash, size);\n    }\n}\n"},"contracts/arch/IOneStepProof.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\n\ninterface IOneStepProof {\n    // Bridges is sequencer bridge then delayed bridge\n    function executeStep(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    )\n        external\n        view\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        );\n\n    function executeStepDebug(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    ) external view returns (string memory startMachine, string memory afterMachine);\n}\n"},"contracts/arch/Machine.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Marshaling.sol\";\n\nimport \"../libraries/DebugPrint.sol\";\n\nlibrary Machine {\n    using Hashing for Value.Data;\n\n    // Make sure these don't conflict with Challenge.MACHINE_UNREACHABLE (currently 100)\n    uint256 internal constant MACHINE_EXTENSIVE = 0;\n    uint256 internal constant MACHINE_ERRORSTOP = 1;\n    uint256 internal constant MACHINE_HALT = 2;\n\n    function addStackVal(Value.Data memory stackValHash, Value.Data memory valHash)\n        internal\n        pure\n        returns (Value.Data memory)\n    {\n        Value.Data[] memory vals = new Value.Data[](2);\n        vals[0] = valHash;\n        vals[1] = stackValHash;\n\n        return Hashing.getTuplePreImage(vals);\n    }\n\n    struct Data {\n        bytes32 instructionStackHash;\n        Value.Data dataStack;\n        Value.Data auxStack;\n        Value.Data registerVal;\n        Value.Data staticVal;\n        uint256 arbGasRemaining;\n        bytes32 errHandlerHash;\n        uint256 status;\n    }\n\n    function toString(Data memory machine) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"Machine(\",\n                    DebugPrint.bytes32string(machine.instructionStackHash),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.dataStack.hash()),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.auxStack.hash()),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.registerVal.hash()),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.staticVal.hash()),\n                    \", \\n\",\n                    DebugPrint.uint2str(machine.arbGasRemaining),\n                    \", \\n\",\n                    DebugPrint.bytes32string(machine.errHandlerHash),\n                    \")\\n\"\n                )\n            );\n    }\n\n    function setErrorStop(Data memory machine) internal pure {\n        machine.status = MACHINE_ERRORSTOP;\n    }\n\n    function setHalt(Data memory machine) internal pure {\n        machine.status = MACHINE_HALT;\n    }\n\n    function addDataStackValue(Data memory machine, Value.Data memory val) internal pure {\n        machine.dataStack = addStackVal(machine.dataStack, val);\n    }\n\n    function addAuxStackValue(Data memory machine, Value.Data memory val) internal pure {\n        machine.auxStack = addStackVal(machine.auxStack, val);\n    }\n\n    function addDataStackInt(Data memory machine, uint256 val) internal pure {\n        machine.dataStack = addStackVal(machine.dataStack, Value.newInt(val));\n    }\n\n    function hash(Data memory machine) internal pure returns (bytes32) {\n        if (machine.status == MACHINE_HALT) {\n            return bytes32(uint256(0));\n        } else if (machine.status == MACHINE_ERRORSTOP) {\n            return bytes32(uint256(1));\n        } else {\n            return\n                keccak256(\n                    abi.encodePacked(\n                        machine.instructionStackHash,\n                        machine.dataStack.hash(),\n                        machine.auxStack.hash(),\n                        machine.registerVal.hash(),\n                        machine.staticVal.hash(),\n                        machine.arbGasRemaining,\n                        machine.errHandlerHash\n                    )\n                );\n        }\n    }\n\n    function clone(Data memory machine) internal pure returns (Data memory) {\n        return\n            Data(\n                machine.instructionStackHash,\n                machine.dataStack,\n                machine.auxStack,\n                machine.registerVal,\n                machine.staticVal,\n                machine.arbGasRemaining,\n                machine.errHandlerHash,\n                machine.status\n            );\n    }\n\n    function deserializeMachine(bytes memory data, uint256 offset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Data memory // machine\n        )\n    {\n        Data memory m;\n        m.status = MACHINE_EXTENSIVE;\n        uint256 instructionStack;\n        uint256 errHandler;\n        (offset, instructionStack) = Marshaling.deserializeInt(data, offset);\n\n        (offset, m.dataStack) = Marshaling.deserializeHashPreImage(data, offset);\n        (offset, m.auxStack) = Marshaling.deserializeHashPreImage(data, offset);\n        (offset, m.registerVal) = Marshaling.deserialize(data, offset);\n        (offset, m.staticVal) = Marshaling.deserialize(data, offset);\n        (offset, m.arbGasRemaining) = Marshaling.deserializeInt(data, offset);\n        (offset, errHandler) = Marshaling.deserializeInt(data, offset);\n\n        m.instructionStackHash = bytes32(instructionStack);\n        m.errHandlerHash = bytes32(errHandler);\n        return (offset, m);\n    }\n}\n"},"contracts/arch/Marshaling.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Value.sol\";\nimport \"./Hashing.sol\";\n\nimport \"../libraries/BytesLib.sol\";\n\nlibrary Marshaling {\n    using BytesLib for bytes;\n    using Value for Value.Data;\n\n    // This depends on how it's implemented in arb-os\n    function deserializeMessage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            bool,\n            uint256,\n            address,\n            uint8,\n            bytes memory\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 8, \"too short\");\n        uint256 size = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            size *= 256;\n            size += uint8(data[startOffset + 7 - i]);\n        }\n        (, uint256 sender) = deserializeInt(data, startOffset + 8);\n        (, uint256 kind) = deserializeInt(data, startOffset + 8 + 32);\n        bytes memory res = new bytes(size - 64);\n        for (uint256 i = 0; i < size - 64; i++) {\n            res[i] = data[startOffset + 8 + 64 + i];\n        }\n        return (true, startOffset + 8 + size, address(uint160(sender)), uint8(kind), res);\n    }\n\n    function deserializeRawMessage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            bool,\n            uint256,\n            bytes memory\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 8, \"too short\");\n        uint256 size = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            size *= 256;\n            size += uint8(data[startOffset + 7 - i]);\n        }\n        bytes memory res = new bytes(size);\n        for (uint256 i = 0; i < size; i++) {\n            res[i] = data[startOffset + 8 + i];\n        }\n        return (true, startOffset + 8 + size, res);\n    }\n\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (uint256 offset, Value.Data memory value)\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 64, \"too short\");\n        bytes32 hashData;\n        uint256 size;\n        (offset, hashData) = extractBytes32(data, startOffset);\n        (offset, size) = deserializeInt(data, offset);\n        return (offset, Value.newTuplePreImage(hashData, size));\n    }\n\n    function deserializeInt(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            uint256 // val\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, data.toUint(startOffset));\n    }\n\n    function deserializeBytes32(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            bytes32 // val\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, data.toBytes32(startOffset));\n    }\n\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data memory // val\n        )\n    {\n        uint256 offset = startOffset;\n        uint8 immediateType;\n        uint8 opCode;\n        Value.Data memory immediate;\n        bytes32 nextHash;\n\n        (offset, immediateType) = extractUint8(data, offset);\n        (offset, opCode) = extractUint8(data, offset);\n        if (immediateType == 1) {\n            (offset, immediate) = deserialize(data, offset);\n        }\n        (offset, nextHash) = extractBytes32(data, offset);\n        if (immediateType == 1) {\n            return (offset, Value.newCodePoint(opCode, nextHash, immediate));\n        }\n        return (offset, Value.newCodePoint(opCode, nextHash));\n    }\n\n    function deserializeTuple(\n        uint8 memberCount,\n        bytes memory data,\n        uint256 startOffset\n    )\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data[] memory // val\n        )\n    {\n        uint256 offset = startOffset;\n        Value.Data[] memory members = new Value.Data[](memberCount);\n        for (uint8 i = 0; i < memberCount; i++) {\n            (offset, members[i]) = deserialize(data, offset);\n        }\n        return (offset, members);\n    }\n\n    function deserialize(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data memory // val\n        )\n    {\n        require(startOffset < data.length, \"invalid offset\");\n        (uint256 offset, uint8 valType) = extractUint8(data, startOffset);\n        if (valType == Value.intTypeCode()) {\n            uint256 intVal;\n            (offset, intVal) = deserializeInt(data, offset);\n            return (offset, Value.newInt(intVal));\n        } else if (valType == Value.codePointTypeCode()) {\n            return deserializeCodePoint(data, offset);\n        } else if (valType == Value.bufferTypeCode()) {\n            bytes32 hashVal;\n            (offset, hashVal) = deserializeBytes32(data, offset);\n            return (offset, Value.newBuffer(hashVal));\n        } else if (valType == Value.tuplePreImageTypeCode()) {\n            return deserializeHashPreImage(data, offset);\n        } else if (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {\n            uint8 tupLength = uint8(valType - Value.tupleTypeCode());\n            Value.Data[] memory tupleVal;\n            (offset, tupleVal) = deserializeTuple(tupLength, data, offset);\n            return (offset, Value.newTuple(tupleVal));\n        }\n        require(false, \"invalid typecode\");\n    }\n\n    function extractUint8(bytes memory data, uint256 startOffset)\n        private\n        pure\n        returns (\n            uint256, // offset\n            uint8 // val\n        )\n    {\n        return (startOffset + 1, uint8(data[startOffset]));\n    }\n\n    function extractBytes32(bytes memory data, uint256 startOffset)\n        private\n        pure\n        returns (\n            uint256, // offset\n            bytes32 // val\n        )\n    {\n        return (startOffset + 32, data.toBytes32(startOffset));\n    }\n}\n"},"contracts/arch/OneStepProofCommon.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IOneStepProof.sol\";\nimport \"./Value.sol\";\nimport \"./Machine.sol\";\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\n\nabstract contract OneStepProofCommon is IOneStepProof {\n    using Machine for Machine.Data;\n    using Hashing for Value.Data;\n    using Value for Value.Data;\n\n    uint256 internal constant MAX_UINT256 = ((1 << 128) + 1) * ((1 << 128) - 1);\n\n    uint64 internal constant ERROR_GAS_COST = 5;\n\n    string internal constant BAD_IMM_TYP = \"BAD_IMM_TYP\";\n    string internal constant NO_IMM = \"NO_IMM\";\n    string internal constant STACK_MISSING = \"STACK_MISSING\";\n    string internal constant AUX_MISSING = \"AUX_MISSING\";\n    string internal constant STACK_MANY = \"STACK_MANY\";\n    string internal constant AUX_MANY = \"AUX_MANY\";\n    string internal constant INBOX_VAL = \"INBOX_VAL\";\n\n    // Stop and arithmetic ops\n    uint8 internal constant OP_ADD = 0x01;\n    uint8 internal constant OP_MUL = 0x02;\n    uint8 internal constant OP_SUB = 0x03;\n    uint8 internal constant OP_DIV = 0x04;\n    uint8 internal constant OP_SDIV = 0x05;\n    uint8 internal constant OP_MOD = 0x06;\n    uint8 internal constant OP_SMOD = 0x07;\n    uint8 internal constant OP_ADDMOD = 0x08;\n    uint8 internal constant OP_MULMOD = 0x09;\n    uint8 internal constant OP_EXP = 0x0a;\n    uint8 internal constant OP_SIGNEXTEND = 0x0b;\n\n    // Comparison & bitwise logic\n    uint8 internal constant OP_LT = 0x10;\n    uint8 internal constant OP_GT = 0x11;\n    uint8 internal constant OP_SLT = 0x12;\n    uint8 internal constant OP_SGT = 0x13;\n    uint8 internal constant OP_EQ = 0x14;\n    uint8 internal constant OP_ISZERO = 0x15;\n    uint8 internal constant OP_AND = 0x16;\n    uint8 internal constant OP_OR = 0x17;\n    uint8 internal constant OP_XOR = 0x18;\n    uint8 internal constant OP_NOT = 0x19;\n    uint8 internal constant OP_BYTE = 0x1a;\n    uint8 internal constant OP_SHL = 0x1b;\n    uint8 internal constant OP_SHR = 0x1c;\n    uint8 internal constant OP_SAR = 0x1d;\n\n    // SHA3\n    uint8 internal constant OP_HASH = 0x20;\n    uint8 internal constant OP_TYPE = 0x21;\n    uint8 internal constant OP_ETHHASH2 = 0x22;\n    uint8 internal constant OP_KECCAK_F = 0x23;\n    uint8 internal constant OP_SHA256_F = 0x24;\n\n    // Stack, Memory, Storage and Flow Operations\n    uint8 internal constant OP_POP = 0x30;\n    uint8 internal constant OP_SPUSH = 0x31;\n    uint8 internal constant OP_RPUSH = 0x32;\n    uint8 internal constant OP_RSET = 0x33;\n    uint8 internal constant OP_JUMP = 0x34;\n    uint8 internal constant OP_CJUMP = 0x35;\n    uint8 internal constant OP_STACKEMPTY = 0x36;\n    uint8 internal constant OP_PCPUSH = 0x37;\n    uint8 internal constant OP_AUXPUSH = 0x38;\n    uint8 internal constant OP_AUXPOP = 0x39;\n    uint8 internal constant OP_AUXSTACKEMPTY = 0x3a;\n    uint8 internal constant OP_NOP = 0x3b;\n    uint8 internal constant OP_ERRPUSH = 0x3c;\n    uint8 internal constant OP_ERRSET = 0x3d;\n\n    // Duplication and Exchange operations\n    uint8 internal constant OP_DUP0 = 0x40;\n    uint8 internal constant OP_DUP1 = 0x41;\n    uint8 internal constant OP_DUP2 = 0x42;\n    uint8 internal constant OP_SWAP1 = 0x43;\n    uint8 internal constant OP_SWAP2 = 0x44;\n\n    // Tuple operations\n    uint8 internal constant OP_TGET = 0x50;\n    uint8 internal constant OP_TSET = 0x51;\n    uint8 internal constant OP_TLEN = 0x52;\n    uint8 internal constant OP_XGET = 0x53;\n    uint8 internal constant OP_XSET = 0x54;\n\n    // Logging operations\n    uint8 internal constant OP_BREAKPOINT = 0x60;\n    uint8 internal constant OP_LOG = 0x61;\n\n    // System operations\n    uint8 internal constant OP_SEND = 0x70;\n    // OP_INBOX_PEEK has been removed\n    uint8 internal constant OP_INBOX = 0x72;\n    uint8 internal constant OP_ERROR = 0x73;\n    uint8 internal constant OP_STOP = 0x74;\n    uint8 internal constant OP_SETGAS = 0x75;\n    uint8 internal constant OP_PUSHGAS = 0x76;\n    uint8 internal constant OP_ERR_CODE_POINT = 0x77;\n    uint8 internal constant OP_PUSH_INSN = 0x78;\n    uint8 internal constant OP_PUSH_INSN_IMM = 0x79;\n    // uint8 private constant OP_OPEN_INSN = 0x7a;\n    uint8 internal constant OP_SIDELOAD = 0x7b;\n\n    uint8 internal constant OP_ECRECOVER = 0x80;\n    uint8 internal constant OP_ECADD = 0x81;\n    uint8 internal constant OP_ECMUL = 0x82;\n    uint8 internal constant OP_ECPAIRING = 0x83;\n\n    uint8 internal constant OP_DEBUGPRINT = 0x90;\n\n    // Buffer operations\n    uint8 internal constant OP_NEWBUFFER = 0xa0;\n    uint8 internal constant OP_GETBUFFER8 = 0xa1;\n    uint8 internal constant OP_GETBUFFER64 = 0xa2;\n    uint8 internal constant OP_GETBUFFER256 = 0xa3;\n    uint8 internal constant OP_SETBUFFER8 = 0xa4;\n    uint8 internal constant OP_SETBUFFER64 = 0xa5;\n    uint8 internal constant OP_SETBUFFER256 = 0xa6;\n\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\n    bytes32 internal constant CODE_POINT_ERROR =\n        keccak256(abi.encodePacked(CODE_POINT_TYPECODE, uint8(0), bytes32(0)));\n\n    uint256 internal constant SEND_SIZE_LIMIT = 10000;\n\n    // accs is [sendAcc, logAcc]\n    function executeStep(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    )\n        external\n        view\n        override\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        )\n    {\n        AssertionContext memory context =\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\n\n        executeOp(context);\n\n        return returnContext(context);\n    }\n\n    function executeStepDebug(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    ) external view override returns (string memory startMachine, string memory afterMachine) {\n        AssertionContext memory context =\n            initializeExecutionContext(initialMessagesRead, accs, proof, bproof, bridges);\n\n        executeOp(context);\n        startMachine = Machine.toString(context.startMachine);\n        afterMachine = Machine.toString(context.afterMachine);\n    }\n\n    // fields\n    // startMachineHash,\n    // endMachineHash,\n    // afterInboxAcc,\n    // afterMessagesHash,\n    // afterLogsHash\n\n    function returnContext(AssertionContext memory context)\n        internal\n        pure\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        )\n    {\n        return (\n            context.gas,\n            context.totalMessagesRead,\n            [\n                Machine.hash(context.startMachine),\n                Machine.hash(context.afterMachine),\n                context.sendAcc,\n                context.logAcc\n            ]\n        );\n    }\n\n    struct ValueStack {\n        uint256 length;\n        Value.Data[] values;\n    }\n\n    function popVal(ValueStack memory stack) internal pure returns (Value.Data memory) {\n        Value.Data memory val = stack.values[stack.length - 1];\n        stack.length--;\n        return val;\n    }\n\n    function pushVal(ValueStack memory stack, Value.Data memory val) internal pure {\n        stack.values[stack.length] = val;\n        stack.length++;\n    }\n\n    struct AssertionContext {\n        ISequencerInbox sequencerBridge;\n        IBridge delayedBridge;\n        Machine.Data startMachine;\n        Machine.Data afterMachine;\n        uint256 totalMessagesRead;\n        bytes32 sendAcc;\n        bytes32 logAcc;\n        uint64 gas;\n        ValueStack stack;\n        ValueStack auxstack;\n        bool hadImmediate;\n        uint8 opcode;\n        bytes proof;\n        uint256 offset;\n        // merkle proofs for buffer\n        bytes bufProof;\n        bool errorOccurred;\n    }\n\n    function handleError(AssertionContext memory context) internal pure {\n        context.errorOccurred = true;\n    }\n\n    function deductGas(AssertionContext memory context, uint64 amount)\n        internal\n        pure\n        returns (bool)\n    {\n        if (context.afterMachine.arbGasRemaining < amount) {\n            // ERROR + GAS_SET\n            context.gas += ERROR_GAS_COST;\n            context.afterMachine.arbGasRemaining = MAX_UINT256;\n            return true;\n        } else {\n            context.gas += amount;\n            context.afterMachine.arbGasRemaining -= amount;\n            return false;\n        }\n    }\n\n    function handleOpcodeError(AssertionContext memory context) internal pure {\n        handleError(context);\n    }\n\n    function initializeExecutionContext(\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes memory proof,\n        bytes memory bproof,\n        address[2] calldata bridges\n    ) internal pure returns (AssertionContext memory) {\n        uint8 opCode = uint8(proof[0]);\n        uint8 stackCount = uint8(proof[1]);\n        uint8 auxstackCount = uint8(proof[2]);\n        uint256 offset = 3;\n\n        // Leave some extra space for values pushed on the stack in the proofs\n        Value.Data[] memory stackVals = new Value.Data[](stackCount + 4);\n        Value.Data[] memory auxstackVals = new Value.Data[](auxstackCount + 4);\n        for (uint256 i = 0; i < stackCount; i++) {\n            (offset, stackVals[i]) = Marshaling.deserialize(proof, offset);\n        }\n        for (uint256 i = 0; i < auxstackCount; i++) {\n            (offset, auxstackVals[i]) = Marshaling.deserialize(proof, offset);\n        }\n        Machine.Data memory mach;\n        (offset, mach) = Machine.deserializeMachine(proof, offset);\n\n        uint8 immediate = uint8(proof[offset]);\n        offset += 1;\n\n        AssertionContext memory context;\n        context.sequencerBridge = ISequencerInbox(bridges[0]);\n        context.delayedBridge = IBridge(bridges[1]);\n        context.startMachine = mach;\n        context.afterMachine = mach.clone();\n        context.totalMessagesRead = initialMessagesRead;\n        context.sendAcc = accs[0];\n        context.logAcc = accs[1];\n        context.gas = 0;\n        context.stack = ValueStack(stackCount, stackVals);\n        context.auxstack = ValueStack(auxstackCount, auxstackVals);\n        context.hadImmediate = immediate == 1;\n        context.opcode = opCode;\n        context.proof = proof;\n        context.bufProof = bproof;\n        context.errorOccurred = false;\n        context.offset = offset;\n\n        require(immediate == 0 || immediate == 1, BAD_IMM_TYP);\n        Value.Data memory cp;\n        if (immediate == 0) {\n            cp = Value.newCodePoint(uint8(opCode), context.startMachine.instructionStackHash);\n        } else {\n            // If we have an immediate, there must be at least one stack value\n            require(stackVals.length > 0, NO_IMM);\n            cp = Value.newCodePoint(\n                uint8(opCode),\n                context.startMachine.instructionStackHash,\n                stackVals[stackCount - 1]\n            );\n        }\n        context.startMachine.instructionStackHash = cp.hash();\n\n        // Add the stack and auxstack values to the start machine\n        uint256 i = 0;\n        for (i = 0; i < stackCount - immediate; i++) {\n            context.startMachine.addDataStackValue(stackVals[i]);\n        }\n        for (i = 0; i < auxstackCount; i++) {\n            context.startMachine.addAuxStackValue(auxstackVals[i]);\n        }\n\n        return context;\n    }\n\n    function executeOp(AssertionContext memory context) internal view {\n        (\n            uint256 dataPopCount,\n            uint256 auxPopCount,\n            uint64 gasCost,\n            function(AssertionContext memory) internal view impl\n        ) = opInfo(context.opcode);\n\n        // Require the prover to submit the minimal number of stack items\n        require(\n            ((dataPopCount > 0 || !context.hadImmediate) && context.stack.length <= dataPopCount) ||\n                (context.hadImmediate && dataPopCount == 0 && context.stack.length == 1),\n            STACK_MANY\n        );\n        require(context.auxstack.length <= auxPopCount, AUX_MANY);\n\n        // Update end machine gas remaining before running opcode\n        if (context.stack.length < dataPopCount) {\n            // If we have insufficient values, reject the proof unless the stack has been fully exhausted\n            require(\n                context.afterMachine.dataStack.hash() == Value.newEmptyTuple().hash(),\n                STACK_MISSING\n            );\n            deductGas(context, ERROR_GAS_COST);\n            // If the stack is empty, the instruction underflowed so we have hit an error\n            handleError(context);\n        } else if (context.auxstack.length < auxPopCount) {\n            // If we have insufficient values, reject the proof unless the auxstack has been fully exhausted\n            require(\n                context.afterMachine.auxStack.hash() == Value.newEmptyTuple().hash(),\n                AUX_MISSING\n            );\n            deductGas(context, ERROR_GAS_COST);\n            // If the auxstack is empty, the instruction underflowed so we have hit an error\n            handleError(context);\n        } else if (deductGas(context, gasCost)) {\n            handleError(context);\n        } else {\n            impl(context);\n        }\n\n        if (context.errorOccurred) {\n            if (context.afterMachine.errHandlerHash == CODE_POINT_ERROR) {\n                context.afterMachine.setErrorStop();\n            } else {\n                // Clear error\n                context.errorOccurred = false;\n                context.afterMachine.instructionStackHash = context.afterMachine.errHandlerHash;\n\n                if (!(context.hadImmediate && dataPopCount == 0)) {\n                    context.stack.length = 0;\n                }\n                context.auxstack.length = 0;\n            }\n        }\n\n        // Add the stack and auxstack values to the start machine\n        uint256 i = 0;\n\n        for (i = 0; i < context.stack.length; i++) {\n            context.afterMachine.addDataStackValue(context.stack.values[i]);\n        }\n\n        for (i = 0; i < context.auxstack.length; i++) {\n            context.afterMachine.addAuxStackValue(context.auxstack.values[i]);\n        }\n    }\n\n    function opInfo(uint256 opCode)\n        internal\n        pure\n        virtual\n        returns (\n            uint256, // stack pops\n            uint256, // auxstack pops\n            uint64, // gas used\n            function(AssertionContext memory) internal view // impl\n        );\n}\n"},"contracts/arch/OneStepProofHash.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./OneStepProofCommon.sol\";\n\nimport \"../libraries/Precompiles.sol\";\n\n// Originally forked from https://github.com/leapdao/solEVM-enforcer/tree/master\n\ncontract OneStepProofHash is OneStepProofCommon {\n    function executeHashInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val = popVal(context.stack);\n        pushVal(context.stack, Value.newInt(uint256(val.hash())));\n    }\n\n    function executeTypeInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val = popVal(context.stack);\n        pushVal(context.stack, val.typeCodeVal());\n    }\n\n    function executeEthHash2Insn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 b = val2.intVal;\n        uint256 c = uint256(keccak256(abi.encodePacked(a, b)));\n        pushVal(context.stack, Value.newInt(c));\n    }\n\n    function executeKeccakFInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val = popVal(context.stack);\n        if (!val.isTuple() || val.tupleVal.length != 7) {\n            handleOpcodeError(context);\n            return;\n        }\n\n        Value.Data[] memory values = val.tupleVal;\n        for (uint256 i = 0; i < 7; i++) {\n            if (!values[i].isInt()) {\n                handleOpcodeError(context);\n                return;\n            }\n        }\n        uint256[25] memory data;\n        for (uint256 i = 0; i < 25; i++) {\n            data[5 * (i % 5) + i / 5] = uint256(uint64(values[i / 4].intVal >> ((i % 4) * 64)));\n        }\n\n        data = Precompiles.keccakF(data);\n\n        Value.Data[] memory outValues = new Value.Data[](7);\n        for (uint256 i = 0; i < 7; i++) {\n            outValues[i] = Value.newInt(0);\n        }\n\n        for (uint256 i = 0; i < 25; i++) {\n            outValues[i / 4].intVal |= data[5 * (i % 5) + i / 5] << ((i % 4) * 64);\n        }\n\n        pushVal(context.stack, Value.newTuple(outValues));\n    }\n\n    function executeSha256FInsn(AssertionContext memory context) internal pure {\n        Value.Data memory val1 = popVal(context.stack);\n        Value.Data memory val2 = popVal(context.stack);\n        Value.Data memory val3 = popVal(context.stack);\n        if (!val1.isInt() || !val2.isInt() || !val3.isInt()) {\n            handleOpcodeError(context);\n            return;\n        }\n        uint256 a = val1.intVal;\n        uint256 b = val2.intVal;\n        uint256 c = val3.intVal;\n\n        pushVal(context.stack, Value.newInt(Precompiles.sha256Block([b, c], a)));\n    }\n\n    function opInfo(uint256 opCode)\n        internal\n        pure\n        override\n        returns (\n            uint256, // stack pops\n            uint256, // auxstack pops\n            uint64, // gas used\n            function(AssertionContext memory) internal view // impl\n        )\n    {\n        if (opCode == OP_HASH) {\n            return (1, 0, 7, executeHashInsn);\n        } else if (opCode == OP_TYPE) {\n            return (1, 0, 3, executeTypeInsn);\n        } else if (opCode == OP_ETHHASH2) {\n            return (2, 0, 8, executeEthHash2Insn);\n        } else if (opCode == OP_KECCAK_F) {\n            return (1, 0, 600, executeKeccakFInsn);\n        } else if (opCode == OP_SHA256_F) {\n            return (3, 0, 250, executeSha256FInsn);\n        } else {\n            revert(\"use another contract to handle other opcodes\");\n        }\n    }\n}\n"},"contracts/arch/Value.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary Value {\n    uint8 internal constant INT_TYPECODE = 0;\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\n    uint8 internal constant TUPLE_TYPECODE = 3;\n    uint8 internal constant BUFFER_TYPECODE = TUPLE_TYPECODE + 9;\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 10;\n\n    // The following types do not show up in the marshalled format and is\n    // only used for internal tracking purposes\n    uint8 internal constant HASH_ONLY = 100;\n\n    struct CodePoint {\n        uint8 opcode;\n        bytes32 nextCodePoint;\n        Data[] immediate;\n    }\n\n    struct Data {\n        uint256 intVal;\n        CodePoint cpVal;\n        Data[] tupleVal;\n        bytes32 bufferHash;\n        uint8 typeCode;\n        uint256 size;\n    }\n\n    function tupleTypeCode() internal pure returns (uint8) {\n        return TUPLE_TYPECODE;\n    }\n\n    function tuplePreImageTypeCode() internal pure returns (uint8) {\n        return HASH_PRE_IMAGE_TYPECODE;\n    }\n\n    function intTypeCode() internal pure returns (uint8) {\n        return INT_TYPECODE;\n    }\n\n    function bufferTypeCode() internal pure returns (uint8) {\n        return BUFFER_TYPECODE;\n    }\n\n    function codePointTypeCode() internal pure returns (uint8) {\n        return CODE_POINT_TYPECODE;\n    }\n\n    function valueTypeCode() internal pure returns (uint8) {\n        return VALUE_TYPE_COUNT;\n    }\n\n    function hashOnlyTypeCode() internal pure returns (uint8) {\n        return HASH_ONLY;\n    }\n\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {\n        return size <= 8;\n    }\n\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {\n        if (val.typeCode == 2) {\n            // Map HashPreImage to Tuple\n            return newInt(TUPLE_TYPECODE);\n        }\n        return newInt(val.typeCode);\n    }\n\n    function valLength(Data memory val) internal pure returns (uint8) {\n        if (val.typeCode == TUPLE_TYPECODE) {\n            return uint8(val.tupleVal.length);\n        } else {\n            return 1;\n        }\n    }\n\n    function isInt(Data memory val) internal pure returns (bool) {\n        return val.typeCode == INT_TYPECODE;\n    }\n\n    function isInt64(Data memory val) internal pure returns (bool) {\n        return val.typeCode == INT_TYPECODE && val.intVal < (1 << 64);\n    }\n\n    function isCodePoint(Data memory val) internal pure returns (bool) {\n        return val.typeCode == CODE_POINT_TYPECODE;\n    }\n\n    function isTuple(Data memory val) internal pure returns (bool) {\n        return val.typeCode == TUPLE_TYPECODE;\n    }\n\n    function isBuffer(Data memory val) internal pure returns (bool) {\n        return val.typeCode == BUFFER_TYPECODE;\n    }\n\n    function newEmptyTuple() internal pure returns (Data memory) {\n        return newTuple(new Data[](0));\n    }\n\n    function newBoolean(bool val) internal pure returns (Data memory) {\n        if (val) {\n            return newInt(1);\n        } else {\n            return newInt(0);\n        }\n    }\n\n    function newInt(uint256 _val) internal pure returns (Data memory) {\n        return\n            Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), 0, INT_TYPECODE, uint256(1));\n    }\n\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\n        internal\n        pure\n        returns (Data memory)\n    {\n        return\n            Data(\n                uint256(valueHash),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                0,\n                HASH_ONLY,\n                valueSize\n            );\n    }\n\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {\n        require(isValidTupleSize(_val.length), \"Tuple must have valid size\");\n        uint256 size = 1;\n\n        for (uint256 i = 0; i < _val.length; i++) {\n            size += _val[i].size;\n        }\n\n        return Data(0, CodePoint(0, 0, new Data[](0)), _val, 0, TUPLE_TYPECODE, size);\n    }\n\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\n        internal\n        pure\n        returns (Data memory)\n    {\n        return\n            Data(\n                uint256(preImageHash),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                0,\n                HASH_PRE_IMAGE_TYPECODE,\n                size\n            );\n    }\n\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {\n        return newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\n    }\n\n    function newCodePoint(\n        uint8 opCode,\n        bytes32 nextHash,\n        Data memory immediate\n    ) internal pure returns (Data memory) {\n        Data[] memory imm = new Data[](1);\n        imm[0] = immediate;\n        return newCodePoint(CodePoint(opCode, nextHash, imm));\n    }\n\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {\n        return Data(0, _val, new Data[](0), 0, CODE_POINT_TYPECODE, uint256(1));\n    }\n\n    function newBuffer(bytes32 bufHash) internal pure returns (Data memory) {\n        return\n            Data(\n                uint256(0),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                bufHash,\n                BUFFER_TYPECODE,\n                uint256(1)\n            );\n    }\n}\n"},"contracts/bridge/interfaces/IBridge.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"},"contracts/bridge/interfaces/ISequencerInbox.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ISequencerInbox {\n    event SequencerBatchDelivered(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        bytes32 afterAcc,\n        bytes transactions,\n        uint256[] lengths,\n        uint256[] sectionsMetadata,\n        uint256 seqBatchIndex,\n        address sequencer\n    );\n\n    event SequencerBatchDeliveredFromOrigin(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        bytes32 afterAcc,\n        uint256 seqBatchIndex\n    );\n\n    event DelayedInboxForced(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        uint256 totalDelayedMessagesRead,\n        bytes32[2] afterAccAndDelayed,\n        uint256 seqBatchIndex\n    );\n\n    event SequencerAddressUpdated(address newAddress);\n\n    function setSequencer(address newSequencer) external;\n\n    function messageCount() external view returns (uint256);\n\n    function maxDelayBlocks() external view returns (uint256);\n\n    function maxDelaySeconds() external view returns (uint256);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\n        external\n        view\n        returns (uint256, bytes32);\n}\n"},"contracts/libraries/BytesLib.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.6.11;\n\n/* solhint-disable no-inline-assembly */\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n/* solhint-enable no-inline-assembly */\n"},"contracts/libraries/DebugPrint.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary DebugPrint {\n    function char(bytes1 b) private pure returns (bytes1 c) {\n        if (uint8(b) < 10) {\n            return bytes1(uint8(b) + 0x30);\n        } else {\n            return bytes1(uint8(b) + 0x57);\n        }\n    }\n\n    function bytes32string(bytes32 b32) internal pure returns (string memory out) {\n        bytes memory s = new bytes(64);\n\n        for (uint256 i = 0; i < 32; i++) {\n            bytes1 b = bytes1(b32[i]);\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[i * 2] = char(hi);\n            s[i * 2 + 1] = char(lo);\n        }\n\n        out = string(s);\n    }\n\n    // Taken from https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n    function uint2str(uint256 _iParam) internal pure returns (string memory _uintAsString) {\n        uint256 _i = _iParam;\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len - 1;\n        while (_i != 0) {\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"},"contracts/libraries/Precompiles.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\n///      This algorithm has been extracted from the implementation of smart pool (https://github.com/smartpool)\nlibrary Precompiles {\n    function keccakF(uint256[25] memory a) internal pure returns (uint256[25] memory) {\n        uint256[5] memory c;\n        uint256[5] memory d;\n        //uint D_0; uint D_1; uint D_2; uint D_3; uint D_4;\n        uint256[25] memory b;\n\n        uint256[24] memory rc =\n            [\n                uint256(0x0000000000000001),\n                0x0000000000008082,\n                0x800000000000808A,\n                0x8000000080008000,\n                0x000000000000808B,\n                0x0000000080000001,\n                0x8000000080008081,\n                0x8000000000008009,\n                0x000000000000008A,\n                0x0000000000000088,\n                0x0000000080008009,\n                0x000000008000000A,\n                0x000000008000808B,\n                0x800000000000008B,\n                0x8000000000008089,\n                0x8000000000008003,\n                0x8000000000008002,\n                0x8000000000000080,\n                0x000000000000800A,\n                0x800000008000000A,\n                0x8000000080008081,\n                0x8000000000008080,\n                0x0000000080000001,\n                0x8000000080008008\n            ];\n\n        for (uint256 i = 0; i < 24; i++) {\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                C[x] = A[5*x]^A[5*x+1]^A[5*x+2]^A[5*x+3]^A[5*x+4];\n            }*/\n\n            c[0] = a[0] ^ a[1] ^ a[2] ^ a[3] ^ a[4];\n            c[1] = a[5] ^ a[6] ^ a[7] ^ a[8] ^ a[9];\n            c[2] = a[10] ^ a[11] ^ a[12] ^ a[13] ^ a[14];\n            c[3] = a[15] ^ a[16] ^ a[17] ^ a[18] ^ a[19];\n            c[4] = a[20] ^ a[21] ^ a[22] ^ a[23] ^ a[24];\n\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                D[x] = C[(x+4)%5]^((C[(x+1)%5] * 2)&0xffffffffffffffff | (C[(x+1)%5]/(2**63)));\n            }*/\n\n            d[0] = c[4] ^ (((c[1] * 2) & 0xffffffffffffffff) | (c[1] / (2**63)));\n            d[1] = c[0] ^ (((c[2] * 2) & 0xffffffffffffffff) | (c[2] / (2**63)));\n            d[2] = c[1] ^ (((c[3] * 2) & 0xffffffffffffffff) | (c[3] / (2**63)));\n            d[3] = c[2] ^ (((c[4] * 2) & 0xffffffffffffffff) | (c[4] / (2**63)));\n            d[4] = c[3] ^ (((c[0] * 2) & 0xffffffffffffffff) | (c[0] / (2**63)));\n\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                for( y = 0 ; y < 5 ; y++ ) {\n                    A[5*x+y] = A[5*x+y] ^ D[x];\n                }\n            }*/\n\n            a[0] = a[0] ^ d[0];\n            a[1] = a[1] ^ d[0];\n            a[2] = a[2] ^ d[0];\n            a[3] = a[3] ^ d[0];\n            a[4] = a[4] ^ d[0];\n            a[5] = a[5] ^ d[1];\n            a[6] = a[6] ^ d[1];\n            a[7] = a[7] ^ d[1];\n            a[8] = a[8] ^ d[1];\n            a[9] = a[9] ^ d[1];\n            a[10] = a[10] ^ d[2];\n            a[11] = a[11] ^ d[2];\n            a[12] = a[12] ^ d[2];\n            a[13] = a[13] ^ d[2];\n            a[14] = a[14] ^ d[2];\n            a[15] = a[15] ^ d[3];\n            a[16] = a[16] ^ d[3];\n            a[17] = a[17] ^ d[3];\n            a[18] = a[18] ^ d[3];\n            a[19] = a[19] ^ d[3];\n            a[20] = a[20] ^ d[4];\n            a[21] = a[21] ^ d[4];\n            a[22] = a[22] ^ d[4];\n            a[23] = a[23] ^ d[4];\n            a[24] = a[24] ^ d[4];\n\n            /*Rho and pi steps*/\n            b[0] = a[0];\n            b[8] = (((a[1] * (2**36)) & 0xffffffffffffffff) | (a[1] / (2**28)));\n            b[11] = (((a[2] * (2**3)) & 0xffffffffffffffff) | (a[2] / (2**61)));\n            b[19] = (((a[3] * (2**41)) & 0xffffffffffffffff) | (a[3] / (2**23)));\n            b[22] = (((a[4] * (2**18)) & 0xffffffffffffffff) | (a[4] / (2**46)));\n            b[2] = (((a[5] * (2**1)) & 0xffffffffffffffff) | (a[5] / (2**63)));\n            b[5] = (((a[6] * (2**44)) & 0xffffffffffffffff) | (a[6] / (2**20)));\n            b[13] = (((a[7] * (2**10)) & 0xffffffffffffffff) | (a[7] / (2**54)));\n            b[16] = (((a[8] * (2**45)) & 0xffffffffffffffff) | (a[8] / (2**19)));\n            b[24] = (((a[9] * (2**2)) & 0xffffffffffffffff) | (a[9] / (2**62)));\n            b[4] = (((a[10] * (2**62)) & 0xffffffffffffffff) | (a[10] / (2**2)));\n            b[7] = (((a[11] * (2**6)) & 0xffffffffffffffff) | (a[11] / (2**58)));\n            b[10] = (((a[12] * (2**43)) & 0xffffffffffffffff) | (a[12] / (2**21)));\n            b[18] = (((a[13] * (2**15)) & 0xffffffffffffffff) | (a[13] / (2**49)));\n            b[21] = (((a[14] * (2**61)) & 0xffffffffffffffff) | (a[14] / (2**3)));\n            b[1] = (((a[15] * (2**28)) & 0xffffffffffffffff) | (a[15] / (2**36)));\n            b[9] = (((a[16] * (2**55)) & 0xffffffffffffffff) | (a[16] / (2**9)));\n            b[12] = (((a[17] * (2**25)) & 0xffffffffffffffff) | (a[17] / (2**39)));\n            b[15] = (((a[18] * (2**21)) & 0xffffffffffffffff) | (a[18] / (2**43)));\n            b[23] = (((a[19] * (2**56)) & 0xffffffffffffffff) | (a[19] / (2**8)));\n            b[3] = (((a[20] * (2**27)) & 0xffffffffffffffff) | (a[20] / (2**37)));\n            b[6] = (((a[21] * (2**20)) & 0xffffffffffffffff) | (a[21] / (2**44)));\n            b[14] = (((a[22] * (2**39)) & 0xffffffffffffffff) | (a[22] / (2**25)));\n            b[17] = (((a[23] * (2**8)) & 0xffffffffffffffff) | (a[23] / (2**56)));\n            b[20] = (((a[24] * (2**14)) & 0xffffffffffffffff) | (a[24] / (2**50)));\n\n            /*Xi state*/\n            /*\n            for( x = 0 ; x < 5 ; x++ ) {\n                for( y = 0 ; y < 5 ; y++ ) {\n                    A[5*x+y] = B[5*x+y]^((~B[5*((x+1)%5)+y]) & B[5*((x+2)%5)+y]);\n                }\n            }*/\n\n            a[0] = b[0] ^ ((~b[5]) & b[10]);\n            a[1] = b[1] ^ ((~b[6]) & b[11]);\n            a[2] = b[2] ^ ((~b[7]) & b[12]);\n            a[3] = b[3] ^ ((~b[8]) & b[13]);\n            a[4] = b[4] ^ ((~b[9]) & b[14]);\n            a[5] = b[5] ^ ((~b[10]) & b[15]);\n            a[6] = b[6] ^ ((~b[11]) & b[16]);\n            a[7] = b[7] ^ ((~b[12]) & b[17]);\n            a[8] = b[8] ^ ((~b[13]) & b[18]);\n            a[9] = b[9] ^ ((~b[14]) & b[19]);\n            a[10] = b[10] ^ ((~b[15]) & b[20]);\n            a[11] = b[11] ^ ((~b[16]) & b[21]);\n            a[12] = b[12] ^ ((~b[17]) & b[22]);\n            a[13] = b[13] ^ ((~b[18]) & b[23]);\n            a[14] = b[14] ^ ((~b[19]) & b[24]);\n            a[15] = b[15] ^ ((~b[20]) & b[0]);\n            a[16] = b[16] ^ ((~b[21]) & b[1]);\n            a[17] = b[17] ^ ((~b[22]) & b[2]);\n            a[18] = b[18] ^ ((~b[23]) & b[3]);\n            a[19] = b[19] ^ ((~b[24]) & b[4]);\n            a[20] = b[20] ^ ((~b[0]) & b[5]);\n            a[21] = b[21] ^ ((~b[1]) & b[6]);\n            a[22] = b[22] ^ ((~b[2]) & b[7]);\n            a[23] = b[23] ^ ((~b[3]) & b[8]);\n            a[24] = b[24] ^ ((~b[4]) & b[9]);\n\n            /*Last step*/\n            a[0] = a[0] ^ rc[i];\n        }\n\n        return a;\n    }\n\n    function rightRotate(uint32 x, uint32 n) internal pure returns (uint32) {\n        return ((x) >> (n)) | ((x) << (32 - (n)));\n    }\n\n    function ch(\n        uint32 e,\n        uint32 f,\n        uint32 g\n    ) internal pure returns (uint32) {\n        return ((e & f) ^ ((~e) & g));\n    }\n\n    // SHA256 compression function that operates on a 512 bit chunk\n    // Note that the input must be padded by the caller\n    // For the initial chunk, the initial values from the SHA256 spec should be passed in as hashState\n    // For subsequent rounds, hashState is the output from the previous round\n    function sha256Block(uint256[2] memory inputChunk, uint256 hashState)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint32[64] memory k =\n            [\n                0x428a2f98,\n                0x71374491,\n                0xb5c0fbcf,\n                0xe9b5dba5,\n                0x3956c25b,\n                0x59f111f1,\n                0x923f82a4,\n                0xab1c5ed5,\n                0xd807aa98,\n                0x12835b01,\n                0x243185be,\n                0x550c7dc3,\n                0x72be5d74,\n                0x80deb1fe,\n                0x9bdc06a7,\n                0xc19bf174,\n                0xe49b69c1,\n                0xefbe4786,\n                0x0fc19dc6,\n                0x240ca1cc,\n                0x2de92c6f,\n                0x4a7484aa,\n                0x5cb0a9dc,\n                0x76f988da,\n                0x983e5152,\n                0xa831c66d,\n                0xb00327c8,\n                0xbf597fc7,\n                0xc6e00bf3,\n                0xd5a79147,\n                0x06ca6351,\n                0x14292967,\n                0x27b70a85,\n                0x2e1b2138,\n                0x4d2c6dfc,\n                0x53380d13,\n                0x650a7354,\n                0x766a0abb,\n                0x81c2c92e,\n                0x92722c85,\n                0xa2bfe8a1,\n                0xa81a664b,\n                0xc24b8b70,\n                0xc76c51a3,\n                0xd192e819,\n                0xd6990624,\n                0xf40e3585,\n                0x106aa070,\n                0x19a4c116,\n                0x1e376c08,\n                0x2748774c,\n                0x34b0bcb5,\n                0x391c0cb3,\n                0x4ed8aa4a,\n                0x5b9cca4f,\n                0x682e6ff3,\n                0x748f82ee,\n                0x78a5636f,\n                0x84c87814,\n                0x8cc70208,\n                0x90befffa,\n                0xa4506ceb,\n                0xbef9a3f7,\n                0xc67178f2\n            ];\n\n        uint32[64] memory w;\n        uint32 i;\n        for (i = 0; i < 8; i++) {\n            w[i] = uint32(inputChunk[0] >> (224 - (32 * i)));\n            w[i + 8] = uint32(inputChunk[1] >> (224 - (32 * i)));\n        }\n\n        uint32 s0;\n        uint32 s1;\n        for (i = 16; i < 64; i++) {\n            s0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] >> 3);\n\n            s1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] >> 10);\n            w[i] = w[i - 16] + s0 + w[i - 7] + s1;\n        }\n\n        uint32[8] memory state;\n\n        for (i = 0; i < 8; i++) {\n            state[i] = uint32(hashState >> (224 - (32 * i)));\n        }\n\n        uint32 temp1;\n        uint32 temp2;\n        uint32 maj;\n\n        for (i = 0; i < 64; i++) {\n            s1 = rightRotate(state[4], 6) ^ rightRotate(state[4], 11) ^ rightRotate(state[4], 25);\n            temp1 = state[7] + s1 + ch(state[4], state[5], state[6]) + k[i] + w[i];\n            s0 = rightRotate(state[0], 2) ^ rightRotate(state[0], 13) ^ rightRotate(state[0], 22);\n\n            maj = (state[0] & (state[1] ^ state[2])) ^ (state[1] & state[2]);\n            temp2 = s0 + maj;\n\n            state[7] = state[6];\n            state[6] = state[5];\n            state[5] = state[4];\n            state[4] = state[3] + temp1;\n            state[3] = state[2];\n            state[2] = state[1];\n            state[1] = state[0];\n            state[0] = temp1 + temp2;\n        }\n\n        for (i = 0; i < 8; i++) {\n            state[i] += uint32(hashState >> (224 - (32 * i)));\n        }\n\n        uint256 result;\n\n        for (i = 0; i < 8; i++) {\n            result |= (uint256(state[i]) << (224 - (32 * i)));\n        }\n\n        return result;\n    }\n}\n"}}}