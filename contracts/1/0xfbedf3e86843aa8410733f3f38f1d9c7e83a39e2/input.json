{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DetectBondShape.sol":{"content":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SignedSafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title SignedSafeMath\r\n * @dev Signed math operations with safety checks that revert on error.\r\n */\r\nlibrary SignedSafeMath {\r\n    int256 constant private _INT256_MIN = -2**255;\r\n\r\n    /**\r\n     * @dev Multiplies two signed integers, reverts on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0, \"SignedSafeMath: division by zero\");\r\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two signed integers, reverts on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two signed integers, reverts on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/SafeCast.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// File: contracts/math/UseSafemath.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice ((a - 1) / b) + 1 = (a + b -1) / b\r\n * for example a.add(10**18 -1).div(10**18) = a.sub(1).div(10**18) + 1\r\n */\r\n\r\nlibrary SafeMathDivRoundUp {\r\n    using SafeMath for uint256;\r\n\r\n    function divRoundUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        require(b > 0, errorMessage);\r\n        return ((a - 1) / b) + 1;\r\n    }\r\n\r\n    function divRoundUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return divRoundUp(a, b, \"SafeMathDivRoundUp: modulo by zero\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title UseSafeMath\r\n * @dev One can use SafeMath for not only uint256 but also uin64 or uint16,\r\n * and also can use SafeCast for uint256.\r\n * For example:\r\n *   uint64 a = 1;\r\n *   uint64 b = 2;\r\n *   a = a.add(b).toUint64() // `a` become 3 as uint64\r\n * In addition, one can use SignedSafeMath and SafeCast.toUint256(int256) for int256.\r\n * In the case of the operation to the uint64 value, one needs to cast the value into int256 in\r\n * advance to use `sub` as SignedSafeMath.sub not SafeMath.sub.\r\n * For example:\r\n *   int256 a = 1;\r\n *   uint64 b = 2;\r\n *   int256 c = 3;\r\n *   a = a.add(int256(b).sub(c)); // `a` becomes 0 as int256\r\n *   b = a.toUint256().toUint64(); // `b` becomes 0 as uint64\r\n */\r\nabstract contract UseSafeMath {\r\n    using SafeMath for uint256;\r\n    using SafeMathDivRoundUp for uint256;\r\n    using SafeMath for uint64;\r\n    using SafeMathDivRoundUp for uint64;\r\n    using SafeMath for uint16;\r\n    using SignedSafeMath for int256;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n}\r\n\r\n// File: contracts/bondPricer/Enums.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n    Pure SBT:\r\n        ___________\r\n       /\r\n      /\r\n     /\r\n    /\r\n\r\n    LBT Shape:\r\n              /\r\n             /\r\n            /\r\n           /\r\n    ______/\r\n\r\n    SBT Shape:\r\n              ______\r\n             /\r\n            /\r\n    _______/\r\n\r\n    Triangle:\r\n              /\\\r\n             /  \\\r\n            /    \\\r\n    _______/      \\________\r\n */\r\nenum BondType {NONE, PURE_SBT, SBT_SHAPE, LBT_SHAPE, TRIANGLE}\r\n\r\n// File: contracts/bondPricer/DetectBondShape.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\ncontract DetectBondShape is UseSafeMath {\r\n    /**\r\n     * @notice Detect bond type by polyline of bond.\r\n     * @param fnMap Function mapping of target bond token\r\n     * @param submittedType If this parameter is BondType.NONE, this function checks up all bond types. Otherwise this function checks up only one bond type.\r\n     * @param success Whether bond detection succeeded or not\r\n     * @param points Coodinates of polyline which are needed for price calculation\r\n     **/\r\n    function getBondType(bytes memory fnMap, BondType submittedType)\r\n        public\r\n        pure\r\n        returns (\r\n            bool success,\r\n            BondType,\r\n            uint256[] memory points\r\n        )\r\n    {\r\n        if (submittedType == BondType.NONE) {\r\n            (success, points) = _isSBT(fnMap);\r\n            if (success) {\r\n                return (success, BondType.PURE_SBT, points);\r\n            }\r\n\r\n            (success, points) = _isSBTShape(fnMap);\r\n            if (success) {\r\n                return (success, BondType.SBT_SHAPE, points);\r\n            }\r\n\r\n            (success, points) = _isLBTShape(fnMap);\r\n            if (success) {\r\n                return (success, BondType.LBT_SHAPE, points);\r\n            }\r\n\r\n            (success, points) = _isTriangle(fnMap);\r\n            if (success) {\r\n                return (success, BondType.TRIANGLE, points);\r\n            }\r\n\r\n            return (false, BondType.NONE, points);\r\n        } else if (submittedType == BondType.PURE_SBT) {\r\n            (success, points) = _isSBT(fnMap);\r\n            if (success) {\r\n                return (success, BondType.PURE_SBT, points);\r\n            }\r\n        } else if (submittedType == BondType.SBT_SHAPE) {\r\n            (success, points) = _isSBTShape(fnMap);\r\n            if (success) {\r\n                return (success, BondType.SBT_SHAPE, points);\r\n            }\r\n        } else if (submittedType == BondType.LBT_SHAPE) {\r\n            (success, points) = _isLBTShape(fnMap);\r\n            if (success) {\r\n                return (success, BondType.LBT_SHAPE, points);\r\n            }\r\n        } else if (submittedType == BondType.TRIANGLE) {\r\n            (success, points) = _isTriangle(fnMap);\r\n            if (success) {\r\n                return (success, BondType.TRIANGLE, points);\r\n            }\r\n        }\r\n\r\n        return (false, BondType.NONE, points);\r\n    }\r\n\r\n    /**\r\n     * @notice unzip uint256 to uint256[4].\r\n     */\r\n    function unzipLineSegment(uint256 zip) internal pure returns (uint64[4] memory) {\r\n        uint64 x1 = uint64(zip >> (64 + 64 + 64));\r\n        uint64 y1 = uint64(zip >> (64 + 64));\r\n        uint64 x2 = uint64(zip >> 64);\r\n        uint64 y2 = uint64(zip);\r\n        return [x1, y1, x2, y2];\r\n    }\r\n\r\n    /**\r\n     * @notice unzip the fnMap to uint256[].\r\n     */\r\n    function decodePolyline(bytes memory fnMap) internal pure returns (uint256[] memory) {\r\n        return abi.decode(fnMap, (uint256[]));\r\n    }\r\n\r\n    function _isLBTShape(bytes memory fnMap)\r\n        internal\r\n        pure\r\n        returns (bool isOk, uint256[] memory points)\r\n    {\r\n        uint256[] memory zippedLines = decodePolyline(fnMap);\r\n        if (zippedLines.length != 2) {\r\n            return (false, points);\r\n        }\r\n        uint64[4] memory secondLine = unzipLineSegment(zippedLines[1]);\r\n        if (\r\n            secondLine[0] != 0 &&\r\n            secondLine[1] == 0 &&\r\n            secondLine[2] > secondLine[0] &&\r\n            secondLine[3] != 0\r\n        ) {\r\n            uint256[] memory _lines = new uint256[](3);\r\n            _lines[0] = secondLine[0];\r\n            _lines[1] = secondLine[2];\r\n            _lines[2] = secondLine[3];\r\n            return (true, _lines);\r\n        }\r\n        return (false, points);\r\n    }\r\n\r\n    function _isTriangle(bytes memory fnMap)\r\n        internal\r\n        pure\r\n        returns (bool isOk, uint256[] memory points)\r\n    {\r\n        uint256[] memory zippedLines = decodePolyline(fnMap);\r\n        if (zippedLines.length != 4) {\r\n            return (false, points);\r\n        }\r\n        uint64[4] memory secondLine = unzipLineSegment(zippedLines[1]);\r\n        uint64[4] memory thirdLine = unzipLineSegment(zippedLines[2]);\r\n        uint64[4] memory forthLine = unzipLineSegment(zippedLines[3]);\r\n        if (\r\n            secondLine[0] != 0 &&\r\n            secondLine[1] == 0 &&\r\n            secondLine[2] > secondLine[0] &&\r\n            secondLine[3] != 0 &&\r\n            thirdLine[2] > secondLine[2] &&\r\n            thirdLine[3] == 0 &&\r\n            forthLine[2] > thirdLine[2] &&\r\n            forthLine[3] == 0\r\n        ) {\r\n            uint256[] memory _lines = new uint256[](4);\r\n            _lines[0] = secondLine[0];\r\n            _lines[1] = secondLine[2];\r\n            _lines[2] = secondLine[3];\r\n            _lines[3] = thirdLine[2];\r\n            return (true, _lines);\r\n        }\r\n        return (false, points);\r\n    }\r\n\r\n    function _isSBTShape(bytes memory fnMap)\r\n        internal\r\n        pure\r\n        returns (bool isOk, uint256[] memory points)\r\n    {\r\n        uint256[] memory zippedLines = decodePolyline(fnMap);\r\n        if (zippedLines.length != 3) {\r\n            return (false, points);\r\n        }\r\n        uint64[4] memory secondLine = unzipLineSegment(zippedLines[1]);\r\n        uint64[4] memory thirdLine = unzipLineSegment(zippedLines[2]);\r\n        if (\r\n            secondLine[0] != 0 &&\r\n            secondLine[1] == 0 &&\r\n            secondLine[2] > secondLine[0] &&\r\n            secondLine[3] != 0 &&\r\n            thirdLine[2] > secondLine[2] &&\r\n            thirdLine[3] == secondLine[3]\r\n        ) {\r\n            uint256[] memory _lines = new uint256[](3);\r\n            _lines[0] = secondLine[0];\r\n            _lines[1] = secondLine[2];\r\n            _lines[2] = secondLine[3];\r\n            return (true, _lines);\r\n        }\r\n        return (false, points);\r\n    }\r\n\r\n    function _isSBT(bytes memory fnMap) internal pure returns (bool isOk, uint256[] memory points) {\r\n        uint256[] memory zippedLines = decodePolyline(fnMap);\r\n        if (zippedLines.length != 2) {\r\n            return (false, points);\r\n        }\r\n        uint64[4] memory secondLine = unzipLineSegment(zippedLines[1]);\r\n\r\n        if (\r\n            secondLine[0] != 0 &&\r\n            secondLine[1] == secondLine[0] &&\r\n            secondLine[2] > secondLine[0] &&\r\n            secondLine[3] == secondLine[1]\r\n        ) {\r\n            uint256[] memory _lines = new uint256[](1);\r\n            _lines[0] = secondLine[0];\r\n            return (true, _lines);\r\n        }\r\n\r\n        return (false, points);\r\n    }\r\n}"}}}