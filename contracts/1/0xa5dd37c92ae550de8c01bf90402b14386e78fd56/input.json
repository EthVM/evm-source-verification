{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/eth-oracle.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^ 0.8.6;\r\n\r\ncontract Oracle{\r\n\taddress ORACLE = address(0);\r\n\taddress address0 = address(0);\r\n\r\n\tstruct RequestTicket{\r\n\t\tuint ID;\r\n\t\taddress sender;\r\n\t\tuint timeRequested;\r\n\t\tuint timeWindow;\r\n\t\tbool finalized;\r\n\t\tuint serviceFee;\r\n\t\tbool subjective;\r\n\r\n\t\tmapping(address => mapping(address => bool)) attacks;\r\n\t\tmapping(address => bool) damaged;\r\n\r\n\t\tuint8 dataType; // uint, address\r\n\r\n\t\t//commit\r\n\t\tmapping(address => bool) committed;\r\n\t\tmapping(address => bytes32) commitHash;\r\n\r\n\t\t//reveal\r\n\t\tmapping(address => bool) revealed;\r\n\t\tmapping(address => bool) rejected;\r\n\t\tmapping(address => bool) voted;\r\n\r\n\t\tmapping(address => int) intVotes;\r\n\t\tmapping(address => address) addressVotes;\r\n\r\n\t\t//RESULTS\r\n\t\tbool ticketRejected;\r\n\t\tuint numberOfOptions;\r\n\t\t\r\n\t\t//results\r\n\t\tmapping(uint => uint) weightOfResults;\r\n\t\tmapping(uint => int) resolvedInts;\r\n\t\tmapping(uint => address) resolvedAddresses;\r\n\t}\r\n\r\n\t//oracle configs\r\n\tuint constant ROUNDTABLE_SEATS = 0;\r\n\tuint constant RESPONSE_TIME_WINDOW = 1;\r\n\tuint constant DELEGATE_REWARDSHARE = 2;\r\n\tuint constant FREEZE_TIMEOUT = 3;\r\n\tuint constant SERVICE_FEE = 4;\r\n\tuint constant TX_FEE_PER = 5;\r\n\tuint constant CONFIGS = 6;\r\n\r\n\tuint[] public oracleConfigurations = new uint[](CONFIGS);\r\n\tmapping(uint/*configID*/ => mapping(uint => uint) ) public totalVotes_forEach_configOption;\r\n\tmapping(uint/*configID*/ => mapping(address => uint) ) public individualsSelectedOption;\r\n\t\r\n\tmapping(address => uint) resolveWeight;\r\n\tmapping(address => uint) weightLocked;\r\n\t\r\n\tmapping(uint => RequestTicket) requestTickets;\r\n\tuint requestTicketCount;\r\n\t//ROUND TABLE & Candidates\r\n\tmapping(uint => address) public chairsCandidate; // only looks at the first X indexes\r\n\tmapping(address => uint) candidatesChair;\r\n\tmapping(address => uint) timeSeated; // watchers aren't responsible for requestTickets that came in before them\r\n\tmapping(address => bool) frozen;\r\n\tmapping(address => bool) isWatcher;\r\n\tmapping(address => uint) latestPunishment;\r\n\tmapping(address => uint) timeWhenThawedOut;\r\n\tuint chairs;\r\n\tuint public hotSeats;\r\n\r\n\tuint256 constant scaleFactor = 0x10000000000000000;\r\n\t//PAYROLL\r\n\tmapping(address => uint) earnings;\r\n\tmapping(address => uint) totalShares;\r\n    mapping(address => mapping(address => uint256)) public shares;\r\n    mapping(address => mapping(address => uint256)) payouts;\r\n    mapping(address => uint) earningsPerShare;\r\n\r\n    //Tx Coverage fee\r\n    uint earningsPerWatcher;\r\n\tuint public totalWatchers;\r\n\tmapping(address => uint256) watcherPayouts;\r\n\r\n\r\n    //lazy UI data\r\n    mapping(address => address[]) public yourBacking;\r\n    mapping(address => mapping(address => bool)) public alreadyBacking;\r\n    \r\n\tResolveToken public resolveToken;\r\n\taddress payable pineapples;\r\n\tPyramid public pyramid = Pyramid(0x91683899ed812C1AC49590779cb72DA6BF7971fE);\r\n\tuint genesis;\r\n\t\r\n\tconstructor(){\r\n\t\tresolveToken = pyramid.resolveToken();\r\n\t\tgenesis = _now();\r\n\t\tpineapples = payable(msg.sender);\r\n\t}\r\n\r\n\tfunction _now()internal view returns(uint){\r\n\t\treturn block.timestamp;\r\n\t}\r\n\r\n\tfunction addShares(address pool, address account, uint amount) internal{\r\n\t\tupdate(pool, account);\r\n\t\ttotalShares[pool] += amount;\r\n\t\tshares[pool][account] += amount;\r\n\r\n\t\tif(pool == ORACLE){\r\n\t\t\tupdateWatcherTxEarnings(account,false);\r\n\t\t\tif (account != address0){\r\n\t\t\t\ttotalWatchers += 1;\r\n\t\t\t\tisWatcher[account] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removeShares(address pool, address account, uint amount) internal{\r\n\t\tupdate(pool, account);\r\n\t\ttotalShares[pool] -= amount;\r\n\t\tshares[pool][account] -= amount;\r\n\r\n\t\tif(pool == ORACLE){\r\n\t\t\tupdateWatcherTxEarnings(account,true);\r\n\t\t\tif (account != address0){\r\n\t\t\t\tisWatcher[account] = false;\r\n\r\n\t\t\t\tuint emptiedSeat = candidatesChair[account];\r\n\r\n\t\t\t\taddress tail = chairsCandidate[totalWatchers-1];\r\n\t\t\t\tchairsCandidate[ emptiedSeat ] = tail;\r\n\t\t\t\tcandidatesChair[tail] = emptiedSeat;\r\n\r\n\t\t\t\ttotalWatchers -= 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction dividendsOf(address pool, address account) public view returns(uint){\r\n\t\tuint owedPerShare = earningsPerShare[pool] - payouts[pool][account];\r\n\t\tif(pool == ORACLE && !isWatcher[account] )\r\n\t\t\treturn 0;\r\n\t\treturn shares[pool][account] * owedPerShare / scaleFactor;\r\n\t}\r\n\t\r\n\t\r\n\tevent WatcherPayroll(address watcher, uint paidOut);\t\r\n\tfunction update(address pool, address account) internal {\r\n\t\tuint newMoney = dividendsOf(pool, account);\r\n        payouts[pool][account] = earningsPerShare[pool];\r\n\r\n\t\tif(pool == ORACLE){\r\n\t\t\tuint eth4Watcher = newMoney * oracleConfigurations[DELEGATE_REWARDSHARE] / (1e20);\r\n\t\t\tearnings[account] += eth4Watcher;\r\n\r\n\t\t\tuint newDivs;\r\n\t\t\tif(totalShares[account]>0){\r\n\t\t\t\tnewDivs = (newMoney - eth4Watcher) * scaleFactor / totalShares[account];\r\n\t\t\t}else{\r\n\t\t\t\tnewDivs = 0;\r\n\t\t\t}\r\n\r\n\t\t\tearningsPerShare[account/*this is what the watcher has to distribute to its electorates*/] += newDivs;\r\n\t\t}else{\r\n\t\t\tearnings[account] += newMoney;\r\n\t\t}\r\n    }\r\n\r\n\tevent TxCashout(address watcher, uint amount);\r\n\tfunction updateWatcherTxEarnings(address watcher, bool paying) internal {\r\n\t\tuint owed = earningsPerWatcher - watcherPayouts[watcher];\r\n\t\twatcherPayouts[watcher] = earningsPerWatcher;\r\n\t\tif(paying) earnings[watcher] += owed;\r\n\t\temit TxCashout(watcher, owed);\r\n    }\r\n\r\n    mapping(address => bool) notNew;\r\n\tevent StakeResolves( address indexed addr, uint256 amountStaked, bytes _data );\r\n\tfunction tokenFallback(address from, uint value, bytes calldata _data) external{\r\n\t\tif( msg.sender == address(resolveToken) ){\r\n\t\t\tif(from == address(pyramid)){\r\n\t\t\t\treturn;// if the pyramid is sending resolve tokens back to this contract, then do nothing.\r\n\t\t\t}\r\n\t\t\tresolveWeight[from] += value;\r\n\t\t\t//update option totals\r\n\t\t\tuint option;\r\n\t\t\tif(notNew[from]){\r\n\t\t\t\tfor(uint8 config = 0; config<CONFIGS; config+=1){\r\n\t\t\t\t\toption = individualsSelectedOption[config][from];\r\n\t\t\t\t\ttotalVotes_forEach_configOption[config][option] += value;\r\n\t\t\t\t\tassertOption(config, option);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tnotNew[from] = true;\r\n\t\t\t\tfor(uint8 config = 0; config<CONFIGS; config+=1){\r\n\t\t\t\t\toption = oracleConfigurations[config];\r\n\t\t\t\t\tindividualsSelectedOption[config][from] = option;\r\n\t\t\t\t\ttotalVotes_forEach_configOption[config][option] += value;\r\n\t\t\t\t\tassertOption(config, option);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\temit StakeResolves(from, value, _data);\r\n\t\t\t\r\n\t\t\taddress backImmediately = bytesToAddress( _data );\r\n\r\n\t\t\tif( backImmediately != address0){\r\n\t\t\t\tbackCandidate(from, backImmediately, value);\r\n\t\t\t}\r\n\r\n\t\t\tresolveToken.transfer( address(pyramid), value);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent UnstakeResolves(address sender, uint amount);\r\n\tfunction unstakeResolves(uint amount) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tif( amount <= ( resolveWeight[sender] - weightLocked[sender] ) ){\r\n\t\t\tresolveWeight[sender] -= amount;\r\n\t\t\tfor(uint config = 0; config<CONFIGS; config+=1){\r\n\t\t\t\ttotalVotes_forEach_configOption[config][individualsSelectedOption[config][sender]] -= amount;\r\n\t\t\t}\r\n\r\n\t\t\temit UnstakeResolves(sender, amount);\r\n\t\t\tpyramid.pullResolves(amount);\r\n\r\n\t\t\tresolveToken.transfer(sender, amount);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent BackCandidate(address sender,address candidate, uint amount);\r\n\tfunction stakeCandidate(address candidate, uint amount) public{ backCandidate(msg.sender, candidate, amount); }\r\n\tfunction backCandidate(address sender, address candidate, uint amount) internal{\r\n\t\trequire(candidate!=ORACLE);\r\n\t\tif( amount <= ( resolveWeight[sender] - weightLocked[sender] ) && !frozen[candidate] && !isWatcher[candidate] ){\r\n\t\t\tweightLocked[sender] += amount;\r\n\t\t\taddShares(candidate, sender, amount);\r\n\r\n\t\t\temit BackCandidate(sender, candidate, amount);\r\n\t\t\t//LAZY U.I.\r\n\t\t\tif(!alreadyBacking[sender][candidate]){\r\n\t\t\t\tyourBacking[sender].push(candidate);\r\n\t\t\t\talreadyBacking[sender][candidate] = true;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\t\r\n\t}\r\n\t\r\n\tevent PullBacking(address sender, address candidate, uint amount);\r\n\tfunction pullBacking( address candidate, uint amount ) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tif( amount <= shares[candidate][sender] && !frozen[candidate] && !isWatcher[candidate] ){\r\n\t\t\tweightLocked[sender] -= amount;\r\n\t\t\tremoveShares(candidate, sender, amount);\r\n\t\t\temit PullBacking(sender, candidate, amount);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction pullAllTheWay(address candidate, uint amount) public{\r\n\t\tpullBacking(candidate, amount);\r\n\t\tunstakeResolves(amount);\r\n\t}\r\n\t\r\n\r\n\tevent AssertCandidate(address candidate, bool successfulAssert, address replacedWatcher, uint newSeat);\r\n\tfunction assertCandidate() public returns(bool success){\r\n\t\taddress candidate = msg.sender;\r\n\t\tuint weakestChair;\r\n\t\tbool nullSeat;\r\n\t\trequire( !frozen[candidate] && hotSeats > 0);\r\n\t\taddress thisWatcher;\r\n\r\n\t\tif(hotSeats == totalWatchers){\r\n\t\t\tfor(uint i; i<hotSeats; i+=1){\r\n\t\t\t\tthisWatcher = chairsCandidate[i];\r\n\t\t\t\tif( totalShares[ thisWatcher ] < totalShares[ chairsCandidate[weakestChair] ] ){\r\n\t\t\t\t\tweakestChair = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tnullSeat = true;\r\n\t\t\tweakestChair = totalWatchers;\r\n\t\t}\r\n\r\n\t\tif( (totalShares[candidate] > totalShares[ chairsCandidate[weakestChair] ] || nullSeat ) && !isWatcher[candidate] ){\r\n\t\t\taddress targetCandidate = chairsCandidate[weakestChair];\r\n\r\n\t\t\tif(!nullSeat){\r\n\t\t\t\tremoveShares(ORACLE, targetCandidate, totalShares[targetCandidate]);\r\n\t\t\t}else{\r\n\t\t\t\ttargetCandidate = address0;\r\n\t\t\t}\r\n\r\n\t\t\taddShares(ORACLE, candidate, totalShares[candidate]);\r\n\t\t\ttimeSeated[candidate] = _now();\r\n\r\n\t\t\tchairsCandidate[weakestChair] = candidate; \r\n\t\t\tcandidatesChair[candidate] = weakestChair;\r\n\r\n\t\t\temit AssertCandidate(candidate, true, targetCandidate, weakestChair);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\temit AssertCandidate(candidate, false, address0, weakestChair);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tevent OptionVote(address sender, uint config, uint option, uint weight);\r\n\tfunction optionVote(bool[] memory isModifying, uint[] memory modifiedOptions) public{\r\n\t\taddress sender = msg.sender;\r\n\t\tuint config;\r\n\t\tuint modifiedOption;\r\n\t\tnotNew[sender] = true;\r\n\t\tfor(config = 0; config<CONFIGS; config+=1){\r\n\t\t\tif(isModifying[config]){\r\n\t\t\t\tmodifiedOption = modifiedOptions[config];\r\n\t\t\t\ttotalVotes_forEach_configOption[config][ individualsSelectedOption[config][sender] ] -= resolveWeight[sender];\r\n\t\t\t\tindividualsSelectedOption[config][sender] = modifiedOption;\r\n\t\t\t\ttotalVotes_forEach_configOption[config][ modifiedOption ] += resolveWeight[sender];\r\n\t\t\t\temit OptionVote(sender, config, modifiedOption, resolveWeight[sender]);\r\n\t\t\t\tassertOption( config, modifiedOption );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent AssertOption(uint config, uint option);\r\n\tfunction assertOption(uint config, uint option) public{\r\n\t\tif( totalVotes_forEach_configOption[config][option] > totalVotes_forEach_configOption[config][ oracleConfigurations[config] ] ){\r\n\t\t\tif(config == RESPONSE_TIME_WINDOW){ option = option>180?option:180; }\r\n\t\t\tif(config == ROUNDTABLE_SEATS){\r\n\t\t\t option = option>7?option:7;\r\n\t\t\t}\r\n\t\t\tif(config == DELEGATE_REWARDSHARE){ option = option>1e20?1e20:option; }\r\n\r\n\t\t\toracleConfigurations[config] = option;\r\n\r\n\t\t\tif(config == ROUNDTABLE_SEATS){\r\n\t\t\t\tif(hotSeats<oracleConfigurations[ROUNDTABLE_SEATS]){\r\n\t\t\t\t\thotSeats = oracleConfigurations[ROUNDTABLE_SEATS];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\temit AssertOption(config, option);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getFee() public view returns(uint txCoverageFee, uint serviceFee){\r\n\t\treturn ( oracleConfigurations[TX_FEE_PER]*hotSeats, oracleConfigurations[SERVICE_FEE] );\r\n\t}\r\n\r\n\tuint public devFunds;\r\n\tfunction updatePines(address addr) public{\r\n\t\trequire(msg.sender == pineapples);\r\n\t\tpineapples = payable(addr);\r\n\t}\r\n\r\n\tGreenpoint greenpoint = Greenpoint(0x8dB802D64f97dC6BDE4eE9e8C1aecC64d3E7c028);\r\n\tbool acreLock;\r\n\tfunction updateACRE(address addr, bool lock) public{\r\n\t\trequire(msg.sender == pineapples && !acreLock);\r\n\t\tgreenpoint = Greenpoint(addr);\r\n\t\tacreLock = lock;\r\n\t}\r\n\r\n\tfunction devPull() public{\r\n\t\trequire(msg.sender == pineapples);\r\n\t\tuint money = devFunds;\r\n\t\tdevFunds = 0;\r\n\t\tgreenpoint.payEthToAcreStakers{value: money/2 }();\r\n\t\tpayable(msg.sender).transfer( money-money/2 );\r\n\t}\r\n\r\n\t//------------------------------ Request Ticket Life Cycle\r\n\tevent FileRequestTicket(address sender, uint ticketID, uint8 dataType, bool subjective, uint timeRequested, uint responseTimeWindow, uint feePaid);\r\n\tfunction fileRequestTicket( uint8 returnType, bool subjective) external payable returns(uint ticketID){\r\n\t\tuint ETH = msg.value;\r\n\t\t(uint txCoverageFee, uint serviceFee) = getFee();\r\n\t\t\r\n\t\tuint devFee = ( (block.timestamp - genesis) < 86400*365 )?(serviceFee/20):0;\r\n\r\n\t\trequire(returnType == 1 || returnType == 0);\r\n\r\n\t\tif(ETH >= txCoverageFee + serviceFee + devFee){\r\n\r\n\t\t\tticketID = requestTicketCount;\r\n\t\t\tRequestTicket storage ticket = requestTickets[requestTicketCount];\r\n\t\t\trequestTicketCount++;\r\n\r\n\t\t\tticket.dataType = returnType;\r\n\t\t\tticket.timeRequested = _now();\r\n\t\t\tticket.timeWindow = oracleConfigurations[RESPONSE_TIME_WINDOW];\r\n\t\t\tticket.ID = ticketID;\r\n\t\t\tticket.sender = msg.sender;\r\n\t\t\tticket.subjective = subjective;\r\n\t\t\tticket.serviceFee = ETH - devFee - txCoverageFee;\r\n\t\t\tdevFunds += devFee;\r\n\t\t\tearningsPerWatcher += txCoverageFee / totalWatchers;\r\n\r\n\t\t\temit FileRequestTicket(msg.sender, ticketID, returnType, subjective, _now(), ticket.timeWindow, ETH);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent CommitVote(address voter, uint ticketID, bytes32 hash);\r\n\tfunction commitVote(uint[] memory tickets, bytes32[] memory voteHashes) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tticket = requestTickets[ tickets[R] ];\r\n\t\t\tif( _now() <= ticket.timeRequested + ticket.timeWindow ){\r\n\t\t\t\tticket.committed[sender] = true;\r\n\t\t\t\tticket.commitHash[sender] = voteHashes[R];\r\n\t\t\t\temit CommitVote(sender, tickets[R], voteHashes[R]);\r\n\t\t\t}else{\r\n\t\t\t\trevert();//outside of timewindow\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tevent RevealVote(address voter, uint ticketID, bool rejected, int intVote, address addressVote);\r\n\tfunction revealVote(uint[] memory tickets, bool[] memory rejected, int[] memory intVotes, address[] memory addressVotes, uint[] memory passwords) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tRequestTicket storage ticket;\r\n\t\tbytes memory abiEncodePacked;\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tticket = requestTickets[ tickets[R] ];\r\n\t\t\tif( ticket.committed[sender] ){\r\n\t\t\t\tif(_now() > ticket.timeRequested + ticket.timeWindow && _now() <= ticket.timeRequested + ticket.timeWindow*2 ){\r\n\t\t\t\t\tif(ticket.dataType == 1){\r\n\t\t\t\t\t\tabiEncodePacked = abi.encodePacked( rejected[R], intVotes[R], passwords[R] );\r\n\t\t\t\t\t}else if(ticket.dataType == 0){\r\n\t\t\t\t\t\tabiEncodePacked = abi.encodePacked( rejected[R], addressVotes[R], passwords[R] );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( compareBytes( keccak256(abiEncodePacked), requestTickets[ tickets[R] ].commitHash[sender]) ){\r\n\r\n\t\t\t\t\t\trequestTickets[ tickets[R] ].revealed[sender] = true;\r\n\t\t\t\t\t\tif(rejected[R]){\r\n\t\t\t\t\t\t\trequestTickets[ tickets[R] ].rejected[sender] = true;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\trequestTickets[ tickets[R] ].voted[sender] = true;\r\n\t\t\t\t\t\t\tif(ticket.dataType == 1){\r\n\t\t\t\t\t\t\t\trequestTickets[ tickets[R] ].intVotes[sender] = intVotes[R];\r\n\t\t\t\t\t\t\t}else if(ticket.dataType == 0){\r\n\t\t\t\t\t\t\t\trequestTickets[ tickets[R] ].addressVotes[sender] = addressVotes[R];\r\n\t\t\t\t\t\t\t}\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\temit RevealVote(sender, tickets[R], rejected[R], intVotes[R], addressVotes[R]);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\trevert();//not a match\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\trevert();//outside of timewindow\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent SubjectiveStance(address voter, uint ticketID, address defender, bool stance);\r\n\tfunction subjectiveStance(uint[] memory tickets, address[] memory defenders, bool[] memory stances) external{\r\n\t\taddress sender = msg.sender;\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tticket = requestTickets[ tickets[R] ];\r\n\t\t\tif(timeSeated[sender] <= ticket.timeRequested){\r\n\t\t\t\tif( timeSeated[defenders[R]] <= ticket.timeRequested && _now() > ticket.timeRequested + ticket.timeWindow*2 && _now() <= ticket.timeRequested + ticket.timeWindow*3 ){\r\n\t\t\t\t\tticket.attacks[sender][defenders[R]] = stances[R];\r\n\t\t\t\t\temit SubjectiveStance(sender, tickets[R], defenders[R], stances[R]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\trevert();//outside timewindow\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\trevert();//you just got here homie, whatcha takin' shots for?\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calculateDamage( uint ticketID ) internal view returns(uint combatWeight, uint[] memory damage){\r\n\t\tRequestTicket storage ticket = requestTickets[ticketID];\r\n\t\taddress offensiveWatcher;\r\n\t\taddress defender;\r\n\t\tuint Y;\r\n\t\tuint X;\r\n\t\tdamage = new uint[](hotSeats);\r\n\t\tif(ticket.subjective){\r\n\t\t\tfor(X = 0; X < hotSeats; X+=1){\r\n\t\t\t\toffensiveWatcher = chairsCandidate[X];\r\n\t\t\t\tif( isWatcher[offensiveWatcher] && timeSeated[offensiveWatcher] <= ticket.timeRequested ){\r\n\t\t\t\t\tcombatWeight += totalShares[offensiveWatcher];\r\n\t\t\t\t\tfor(Y = 0; Y < hotSeats; Y+=1){\r\n\t\t\t\t\t\tdefender = chairsCandidate[Y];\r\n\t\t\t\t\t\tif( isWatcher[defender] && timeSeated[defender] <= ticket.timeRequested){\r\n\t\t\t\t\t\t\tif(ticket.attacks[offensiveWatcher][defender]){\r\n\t\t\t\t\t\t\t\tdamage[Y] += totalShares[offensiveWatcher];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent FinalizedRequest(uint ticketID, address[] watchers);\r\n\tfunction finalizeRequests(uint[] memory tickets) external{\r\n\t\tfor(uint R; R<tickets.length; R+=1 ){\r\n\t\t\tfinalizeRequest( tickets[R] );\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction finalizeRequest(uint ticketID) public{\r\n\t\t// if response time window is over or all delegates have voted,\r\n\t\t// anyone can finalize the request to trigger the event\r\n\t\tRequestTicket storage ticket = requestTickets[ticketID];\r\n\t\tif(!ticket.finalized){\r\n\t\t\t\r\n\t\t\taddress watcher;\r\n\t\t\t\r\n\t\t\tint[] memory intOptions = new int[](hotSeats);\r\n\t\t\taddress[] memory addressOptions = new address[](hotSeats);\r\n\t\t\tuint[] memory optionWeights = new uint[](hotSeats);\r\n\r\n\t\t\taddress[] memory watchers = new address[](hotSeats);// lazy UI data\r\n\r\n\t\t\tuint[] memory UINTs = new uint[](7);//0= weight of votes, 1=top Option, 2= number of options, 3=top Option, 4 =total eligible weight, 5 = combat weight, 6  = loop for saving subjectives to storage\r\n\r\n\t\t\tuint opt;\r\n\t\t\tuint[] memory damage;\r\n\t\t\t(UINTs[5]/*combatWeight*/, damage) = calculateDamage(ticketID);\r\n\t\t\tfor(uint chair = 0; chair < hotSeats; chair+=1){\r\n\t\t\t\twatcher = chairsCandidate[chair];\r\n\t\t\t\twatchers[chair] = watcher;\r\n\t\t\t\tif(damage[chair]<=UINTs[5]/*combatWeight*//2){\r\n\t\t\t\t\tif( watcher!=address0 && isWatcher[watcher] && timeSeated[watcher] <= ticket.timeRequested && ticket.revealed[watcher] ){\r\n\t\t\t\t\t\tUINTs[4]/*total Eligible Weight*/ += totalShares[watcher];\r\n\t\t\t\t\t\tif( ticket.voted[watcher] ){\r\n\t\t\t\t\t\t\tUINTs[0]/*weight of votes*/ += totalShares[watcher];\r\n\t\t\t\t\t\t\t//check to see if chosen option already is accounted for, if so, add weight to it.\r\n\t\t\t\t\t\t\tfor(opt = 0; opt<UINTs[2]/*option count*/; opt+=1){\r\n\t\t\t\t\t\t\t\tif( (ticket.dataType == 1 && intOptions[opt] == ticket.intVotes[watcher]) ||\r\n\t\t\t\t\t\t\t\t\t(ticket.dataType == 0 && addressOptions[opt] == ticket.addressVotes[watcher]) \r\n\t\t\t\t\t\t\t\t){\r\n\t\t\t\t\t\t\t\t\toptionWeights[opt] += totalShares[watcher];\r\n\t\t\t\t\t\t\t\t\tif(optionWeights[opt] > optionWeights[UINTs[3]/*top option*/] && !ticket.subjective){\r\n\t\t\t\t\t\t\t\t\t\tUINTs[3]/*top option*/ = opt;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t//add new unique option\r\n\t\t\t\t\t\t\tif(opt == UINTs[2]/*option count*/){\r\n\t\t\t\t\t\t\t\tif(ticket.dataType == 1){\r\n\t\t\t\t\t\t\t\t\tintOptions[UINTs[2]/*option count*/] = ticket.intVotes[watcher];\r\n\t\t\t\t\t\t\t\t}else if(ticket.dataType == 0){\r\n\t\t\t\t\t\t\t\t\taddressOptions[UINTs[2]/*option count*/] = ticket.addressVotes[watcher];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\toptionWeights[UINTs[2]/*option count*/] = totalShares[watcher];\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tUINTs[2]/*option count*/+=1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(ticket.rejected[watcher]){\r\n\t\t\t\t\t\t\tUINTs[1]/*weight of rejections*/ += totalShares[watcher];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tticket.damaged[watcher] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif( (UINTs[4]/*total Eligible Weight*/ == (UINTs[1]/*weight of rejections*/ + UINTs[0]/*weight of votes*/) && !ticket.subjective) || (_now() > ticket.timeRequested + ticket.timeWindow*(ticket.subjective?3:2) ) ){\r\n\t\t\t\t\r\n\t\t\t\tbool rejected;\r\n\t\t\t\tif( UINTs[1]/*weight of rejections*/ > optionWeights[UINTs[3]/*top option*/] ){\r\n\t\t\t\t\trejected = true;\r\n\t\t\t\t}\r\n\t\t\t\tuint8 dataType = ticket.dataType;\r\n\t\t\t\t//write results in stone\r\n\t\t\t\tif(rejected){\r\n\t\t\t\t\tticket.ticketRejected = true;\r\n\t\t\t\t}else{\t\t\t\t\r\n\t\t\t\t\tif(ticket.subjective){\r\n\t\t\t\t\t\tticket.numberOfOptions = UINTs[2]/*option count*/;\r\n\t\t\t\t\t\tfor(UINTs[6]=0;UINTs[6]<UINTs[2];UINTs[6]+=1){\r\n\t\t\t\t\t\t\tticket.weightOfResults[UINTs[6]] = optionWeights[UINTs[6]];\r\n\t\t\t\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\t\t\t\tticket.resolvedInts[UINTs[6]] = intOptions[UINTs[6]];\r\n\t\t\t\t\t\t\t}else if(dataType == 0){\r\n\t\t\t\t\t\t\t\tticket.resolvedAddresses[UINTs[6]] = addressOptions[UINTs[6]];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tticket.numberOfOptions = UINTs[2]==0?0:1;//just in case no one responds the number of options needs to be 0\r\n\t\t\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\t\t\tticket.resolvedInts[0] = intOptions[UINTs[3]/*top option*/];\r\n\t\t\t\t\t\t}else if(dataType == 0){\r\n\t\t\t\t\t\t\tticket.resolvedAddresses[0] = addressOptions[UINTs[3]/*top option*/];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//dish out the rewards\r\n\t\t\t\tearningsPerShare[ORACLE] += ticket.serviceFee * scaleFactor / totalShares[ORACLE];\r\n\r\n\t\t\t\tticket.finalized = true;\r\n\t\t\t\tif(ticket.subjective){\r\n\t\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\t\tRequestor(ticket.sender).oracleIntFallback(ticket.ID, ticket.ticketRejected, ticket.numberOfOptions, optionWeights, intOptions);\r\n\t\t\t\t\t}else if(dataType == 0){\r\n\t\t\t\t\t\tRequestor(ticket.sender).oracleAddressFallback(ticket.ID, ticket.ticketRejected, ticket.numberOfOptions, optionWeights, addressOptions);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(dataType == 1){\r\n\t\t\t\t\t\tRequestor(ticket.sender).oracleObjectiveIntFallback(ticket.ID, ticket.ticketRejected, intOptions);\r\n\t\t\t\t\t}else if(dataType == 0){\r\n\t\t\t\t\t\tRequestor(ticket.sender).oracleObjectiveAddressFallback(ticket.ID, ticket.ticketRejected, addressOptions);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\temit FinalizedRequest(ticket.ID, watchers);\r\n\t\t\t}else{\r\n\t\t\t\trevert();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent Cashout(address addr, uint ETH);\r\n\tfunction cashout(address[] memory pools) external{\r\n\t\taddress payable sender = payable(msg.sender);\r\n\t\tfor(uint p; p < pools.length; p+=1){\r\n\t\t\tupdate(pools[p], sender);\r\n\t\t}\r\n\t\trunWatcherPayroll(sender);\r\n\t\tuint ETH = earnings[sender];\r\n\t\tearnings[sender] = 0;\r\n\t\temit Cashout(sender, ETH);\r\n\t\tsender.transfer( ETH );\r\n\t}\r\n\r\n\tfunction runWatcherPayroll(address watcher) public{\r\n\t\tif( isWatcher[watcher] ){\r\n\t\t\tupdate(ORACLE, watcher );\r\n\t\t\tupdateWatcherTxEarnings( watcher, true );\r\n\t\t}\r\n\t}\r\n\r\n\tfunction tryToPunish(uint[] memory tickets, address[] memory watchers) external{\r\n\t\tfreezeNoncommits(tickets, watchers);\r\n\t\tfreezeUnrevealedCommits(tickets, watchers);\r\n\t\tfreezeWrongWatchers(tickets, watchers);\r\n\t}\r\n\r\n\tevent FreezeNoncommits(uint ticketID, address watcher);\r\n\tfunction freezeNoncommits(uint[] memory tickets, address[] memory watchers) public{\r\n\t\t// get them while they're still at the round table and we're in the reveal phase of a ticket\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint i; i<watchers.length; i+=1){\r\n\t\t\tticket = requestTickets[ tickets[i] ];\r\n\t\t\tif( isWatcher[ watchers[i] ] &&\r\n\t\t\t\t!ticket.committed[ watchers[i] ] &&\r\n\t\t\t\ttimeSeated[ watchers[i] ] <= ticket.timeRequested &&\r\n\t\t\t\t_now() > ticket.timeRequested + ticket.timeWindow\r\n\t\t\t){\r\n\t\t\t\tif(punish(tickets[i] , watchers[i]) ){\r\n\t\t\t\t\temit FreezeNoncommits(tickets[i] , watchers[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tevent FreezeUnrevealedCommits(uint ticketID, address watcher);\r\n\tfunction freezeUnrevealedCommits(uint[] memory tickets, address[] memory watchers) public{\r\n\t\t// get them if they made a commit, but did not reveal it after the reveal window is over\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint i; i<watchers.length; i+=1){\r\n\t\t    ticket = requestTickets[ tickets[i] ];\r\n\t\t\tif( isWatcher[ watchers[i] ] &&\r\n\t\t\t\t!ticket.revealed[ watchers[i] ] &&\r\n\t\t\t\ttimeSeated[ watchers[i] ] <= ticket.timeRequested &&\r\n\t\t\t\t_now() > requestTickets[ tickets[i] ].timeRequested + ticket.timeWindow*2\r\n\t\t\t){\r\n\t\t\t\tif(punish(tickets[i] , watchers[i]) ){\r\n\t\t\t\t\temit FreezeUnrevealedCommits(tickets[i] , watchers[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent FreezeWrongWatchers(uint ticketID, address watcher);\r\n\tfunction freezeWrongWatchers(uint[] memory tickets, address[] memory watchers) public{\r\n\t\t// get them if the ticket is finalized and their vote doesn't match the resolved answer\r\n\t\taddress watcher;\r\n\t\tRequestTicket storage ticket;\r\n\t\tfor(uint i; i<watchers.length; i+=1){\r\n\t\t\tticket = requestTickets[ tickets[i] ];\r\n\t\t\twatcher = watchers[i];\r\n\t\t\tif( ticket.finalized &&\r\n\t\t\t\tisWatcher[ watchers[i] ] &&\r\n\t\t\t\ttimeSeated[ watchers[i] ] <= ticket.timeRequested &&\r\n\t\t\t\t!ticket.ticketRejected &&\r\n\t\t\t\t(\r\n\t\t\t\t\t(!ticket.subjective && (\r\n\t\t\t\t\t\t(ticket.dataType == 1 && ticket.resolvedInts[0] != ticket.intVotes[ watcher ] )||\r\n\t\t\t\t\t\t(ticket.dataType == 0 && ticket.resolvedAddresses[0] != ticket.addressVotes[ watcher ] )\r\n\t\t\t\t\t))||\r\n\t\t\t\t\t(ticket.subjective && ticket.damaged[ watcher ] )||//if their subjective contribution is garbage\r\n\t\t\t\t\tticket.rejected[ watcher ]//if they reject something the majority didn't reject\r\n\t\t\t\t)\r\n\t\t\t){\r\n\t\t\t\tif(punish(tickets[i] , watcher)){\r\n\t\t\t\t\temit FreezeWrongWatchers(tickets[i] , watcher);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tevent Punish(address watcher, uint thawOutTime);\r\n\tfunction punish(uint ticketID, address watcher) internal returns(bool punished){\r\n\t\tRequestTicket storage ticket = requestTickets[ticketID];\r\n\t\tif(latestPunishment[watcher] < ticket.timeRequested+ticket.timeWindow*(ticket.subjective?3:2)){\r\n\t\t\tif( isWatcher[watcher] ){\r\n\t\t\t\tremoveShares(ORACLE, watcher, totalShares[watcher]);\r\n\t\t\t}\r\n\r\n\t\t\tfrozen[watcher] = true;\r\n\t\t\tlatestPunishment[watcher] = ticket.timeRequested;\r\n\t\t\ttimeWhenThawedOut[watcher] = _now() + oracleConfigurations[FREEZE_TIMEOUT];\r\n\r\n\t\t\temit Punish(watcher, timeWhenThawedOut[watcher]);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tevent Thaw(address candidate);\r\n\tfunction thaw(address candidate, bool _assert) public{\r\n\t\tif( _now() >= timeWhenThawedOut[candidate] && frozen[candidate] ) {\r\n\t\t\tfrozen[candidate] = false;\r\n\t\t\tif(_assert){\r\n\t\t\t\tassertCandidate();\r\n\t\t\t}\r\n\t\t\temit Thaw(candidate);\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\tevent UpdateRoundTable(uint newTotalHotSeats);\r\n\tfunction updateRoundTable(uint seats) public{\r\n\t\t// update hotSeats for when they're lower.\r\n\t\tuint s;\r\n\t\tuint i;\r\n\t\tuint weakestChair;\r\n\t\taddress thisWatcher;\r\n\t\tuint configSEATS = oracleConfigurations[ROUNDTABLE_SEATS];\r\n\r\n\t\tif( configSEATS == hotSeats ) return;\r\n\r\n\t\tif( hotSeats > totalWatchers && configSEATS < hotSeats){\r\n\t\t\thotSeats = totalWatchers;\r\n\t\t}\r\n\r\n\t\tfor( s = 0; s<seats; s+=1 ){\r\n\r\n\t\t\tfor( i=0; i<hotSeats; i+=1){\r\n\t\t\t\tthisWatcher = chairsCandidate[i];\r\n\t\t\t\tif( totalShares[ thisWatcher ] < totalShares[ chairsCandidate[weakestChair] ] ){\r\n\t\t\t\t\tweakestChair = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthisWatcher = chairsCandidate[weakestChair];\r\n\t\t\tremoveShares(ORACLE, thisWatcher, totalShares[thisWatcher]);\r\n\r\n\t\t\thotSeats-=1;\r\n\r\n\t\t\tif( configSEATS == hotSeats ){break;}\r\n\t\t}\r\n\r\n\t\temit UpdateRoundTable(hotSeats);\r\n\t}\r\n\r\n\tfunction viewRequestTicket(uint ticketID) public view returns(\r\n\t\taddress sender,\r\n\t\tuint timeRequested,\r\n\t\tuint timeWindow,\r\n\t\tuint numberOfOptions,\r\n\t\tbool finalized,\r\n\t\tbool rejected,\r\n\t\tuint[] memory weightOfResults,\r\n\t\tint[] memory resolvedInts,\r\n\t\taddress[] memory resolvedAddresses\r\n\t){\t\r\n\t\tRequestTicket storage T = requestTickets[ticketID];\r\n\t\tsender = T.sender;\r\n\t\ttimeRequested = T.timeRequested;\r\n\t\ttimeWindow = T.timeWindow;\r\n\t\tfinalized = T.finalized;\r\n\t\tnumberOfOptions = T.numberOfOptions;\r\n\t\trejected = T.ticketRejected;\r\n\r\n\t\tweightOfResults = new uint[](T.numberOfOptions);\r\n\t\tresolvedInts = new int[](T.numberOfOptions);\r\n\t\tresolvedAddresses = new address[](T.numberOfOptions);\r\n\t\t//yikes\r\n\t\tfor(uint i = 0; i< T.numberOfOptions; i+=1){\r\n\t\t\tweightOfResults[i] = T.weightOfResults[i];\r\n\t\t\tresolvedInts[i] = T.resolvedInts[i];\r\n\t\t\tresolvedAddresses[i] = T.resolvedAddresses[i];\t\r\n\t\t}\r\n\t}\r\n\r\n\tfunction viewCandidates(bool personal_or_roundtable, address perspective) public view returns(address[] memory addresses, uint[] memory dividends, uint[] memory seat, uint[] memory weights, uint[] memory clocks, bool[] memory isFrozen, bool[] memory atTable, uint[] memory roundTableDividends){\r\n\t\tuint L;\r\n\t\t\r\n\t\tif(personal_or_roundtable){\r\n\t\t\tL = hotSeats;\r\n\t\t}else{\r\n\t\t\tL = yourBacking[perspective].length;\r\n\t\t}\r\n\r\n\t\tdividends = new uint[](L);\r\n\t\tseat = new uint[](L);\r\n\t\troundTableDividends = new uint[](L);\r\n\r\n\t\tweights = new uint[](L*2);\r\n\t\tclocks = new uint[](L*3);\r\n\r\n\t\tisFrozen = new bool[](L);\r\n\t\tatTable = new bool[](L);\r\n\r\n\t\taddresses = new address[](L);\r\n\r\n\t\taddress candidate;\r\n\t\tfor(uint c = 0; c<L; c+=1){\r\n\t\t\tif(personal_or_roundtable){\r\n\t\t\t\tcandidate = chairsCandidate[c];\r\n\t\t\t}else{\r\n\t\t\t\tcandidate = yourBacking[perspective][c];\r\n\t\t\t}\r\n\t\t\taddresses[c] = candidate;\r\n\t\t\tdividends[c] = dividendsOf(candidate, perspective);\r\n\t\t\troundTableDividends[c] = dividendsOf(ORACLE, candidate);\r\n\t\t\tseat[c] = candidatesChair[candidate];\r\n\t\t\tweights[c] = shares[candidate][perspective];\r\n\t\t\tweights[c+L] = totalShares[candidate];\r\n\t\t\tisFrozen[c] = frozen[candidate];\r\n\t\t\tatTable[c] = isWatcher[candidate];\r\n\t\t\tclocks[c] = timeWhenThawedOut[candidate];\r\n\t\t\tclocks[c+L] = timeSeated[candidate];\r\n\t\t\tclocks[c+L*2] = latestPunishment[candidate];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction viewGovernance(address addr) public view returns(uint[] memory data){\r\n\t\tdata = new uint[](CONFIGS*4);\r\n\t\tfor(uint i = 0; i< CONFIGS; i+=1){\r\n\t\t\tdata[i] = oracleConfigurations[i];\r\n\t\t\tdata[CONFIGS + i] = totalVotes_forEach_configOption[i][ oracleConfigurations[i] ];\r\n\t\t\tdata[CONFIGS*2 + i] = individualsSelectedOption[i][addr];\r\n\t\t\tdata[CONFIGS*3 + i] = totalVotes_forEach_configOption[i][ individualsSelectedOption[i][addr] ];\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction accountData(address account) public view returns(\r\n\t\tuint _resolveWeight,\r\n\t\tuint _weightLocked,\r\n\t\tuint _timeSeated,\r\n\t\tbool _frozen,\r\n\t\tbool _isWatcher,\r\n\t\tuint _earnings,\r\n\t\tuint _totalShares,\r\n\t\tuint[] memory UINTs\r\n\t){\r\n\t\t_resolveWeight = resolveWeight[account];\r\n\t\t_weightLocked = weightLocked[account];\r\n\t\t_timeSeated = timeSeated[account];\r\n\t\t_frozen = frozen[account];\r\n\t\t_isWatcher = isWatcher[account];\r\n\t\t_earnings = earnings[account];\r\n\t\t_totalShares = totalShares[account];\r\n\t\tUINTs = new uint[](5);\r\n\r\n\t\tif( _isWatcher ){\r\n\t\t\tUINTs[0] = earningsPerWatcher - watcherPayouts[account];//txCoverageFee\r\n\t\t\tUINTs[1] = dividendsOf(ORACLE, account) * oracleConfigurations[DELEGATE_REWARDSHARE] / (1e20);\r\n\t\t}\r\n\r\n\t\tUINTs[2] = timeWhenThawedOut[account];\r\n\t\tUINTs[3] = latestPunishment[account];\r\n\t\tUINTs[4] = candidatesChair[account];\r\n\t}\r\n\r\n\tfunction compareStrings(string memory a, string memory b) public pure returns (bool) {\r\n\t\treturn (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n\t}\r\n\tfunction compareBytes(bytes32 a, bytes32 b) public pure returns (bool) {\r\n\t\treturn (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))) );\r\n\t}\r\n\tfunction bytesToAddress(bytes memory bys) private pure returns (address addr){\r\n        assembly {\r\n          addr := mload( add(bys,20) )\r\n        } \r\n    }\r\n}\r\n\r\nabstract contract ResolveToken{\r\n\tfunction transfer(address _to, uint256 _value) public virtual returns (bool);\r\n}\r\n\r\nabstract contract Pyramid{\r\n\tfunction pullResolves(uint amount) public virtual returns (uint forfeiture);\r\n\tfunction resolveToken() public view virtual returns(ResolveToken);\r\n}\r\n\r\nabstract contract Requestor{\r\n\tfunction oracleIntFallback(uint ticketID, bool rejected, uint numberOfOptions, uint[] memory optionWeights, int[] memory intOptions) external virtual;\r\n\tfunction oracleAddressFallback(uint ticketID, bool rejected, uint numberOfOptions, uint[] memory optionWeights, address[] memory addressOptions) external virtual;\r\n\tfunction oracleObjectiveIntFallback(uint ticketID, bool rejected, int[] memory intOptions) external virtual;\r\n\tfunction oracleObjectiveAddressFallback(uint ticketID, bool rejected, address[] memory addressOptions) external virtual;\r\n}\r\n\r\nabstract contract Greenpoint{\r\n\tfunction payEthToAcreStakers() payable public virtual;\r\n}"}}}