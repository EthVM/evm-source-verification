{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ERC721Helper.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC-721 Helper v0.9.3-alpha\r\n//\r\n// https://github.com/bokkypoobah/TokenToolz\r\n//\r\n// Deployed to Mainnet & Rinkeby 0x1CB0bA2E867549Aa7485a91dD90C454C2121b975\r\n//\r\n// SPDX-License-Identifier: MIT\r\n//\r\n// Enjoy.\r\n//\r\n// (c) BokkyPooBah / Bok Consulting Pty Ltd 2021. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface ERC721 is ERC165 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC721Metadata is ERC721 {\r\n    function name() external view returns (string memory _name);\r\n    function symbol() external view returns (string memory _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface ERC721Enumerable is ERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract ERC721Helper {\r\n\r\n    bytes4 private constant ERC721_INTERFACE = 0x80ac58cd;\r\n    bytes4 private constant ERC721METADATA_INTERFACE = 0x5b5e139f;\r\n    bytes4 private constant ERC721ENUMERABLE_INTERFACE = 0x780e9d63;\r\n\r\n    uint public constant ISERC721 = 2**0;\r\n    uint public constant ISERC721METADATA = 2**1;\r\n    uint public constant ISERC721ENUMERABLE = 2**2;\r\n\r\n\r\n    function tokenInfo(address[] memory tokens) external view returns(uint[] memory statuses, string[] memory symbols, string[] memory names, uint[] memory totalSupplys) {\r\n        statuses = new uint[](tokens.length);\r\n        symbols = new string[](tokens.length);\r\n        names = new string[](tokens.length);\r\n        totalSupplys = new uint[](tokens.length);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            uint status = 0;\r\n            try ERC165(token).supportsInterface(ERC721_INTERFACE) returns (bool isERC721) {\r\n                if (isERC721) {\r\n                    status |= ISERC721;\r\n\r\n                    try ERC165(token).supportsInterface(ERC721METADATA_INTERFACE) returns (bool isERC721Metadata) {\r\n                        if (isERC721Metadata) {\r\n                            status |= ISERC721METADATA;\r\n                            try ERC721Metadata(token).symbol() returns (string memory s) {\r\n                                symbols[i] = s;\r\n                            } catch {\r\n                            }\r\n                            try ERC721Metadata(token).name() returns (string memory n) {\r\n                                names[i] = n;\r\n                            } catch {\r\n                            }\r\n                        }\r\n                    } catch {\r\n                    }\r\n                    try ERC165(token).supportsInterface(ERC721ENUMERABLE_INTERFACE) returns (bool isERC721Enumerable) {\r\n                        if (isERC721Enumerable) {\r\n                            status |= ISERC721ENUMERABLE;\r\n                            try ERC721Enumerable(token).totalSupply() returns (uint256 ts) {\r\n                                totalSupplys[i] = ts;\r\n                            } catch {\r\n                            }\r\n                        }\r\n                    } catch {\r\n                    }\r\n                }\r\n                statuses[i] = status;\r\n            } catch {\r\n            }\r\n        }\r\n    }\r\n\r\n    function tokenURIsByTokenIds(address token, uint[] memory tokenIds) external view returns(bool[] memory successes, string[] memory tokenURIs) {\r\n        tokenURIs = new string[](tokenIds.length);\r\n        successes = new bool[](tokenIds.length);\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n            try ERC721Metadata(token).tokenURI(tokenIds[i]) returns (string memory s) {\r\n                tokenURIs[i] = s;\r\n                successes[i] = true;\r\n            } catch {\r\n            }\r\n        }\r\n    }\r\n\r\n    function ownersByTokenIds(address token, uint[] memory tokenIds) external view returns(bool[] memory successes, address[] memory owners) {\r\n        owners = new address[](tokenIds.length);\r\n        successes = new bool[](tokenIds.length);\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n            try ERC721(token).ownerOf(tokenIds[i]) returns (address a) {\r\n                owners[i] = a;\r\n                successes[i] = true;\r\n            } catch {\r\n            }\r\n        }\r\n    }\r\n\r\n    function tokenURIsByEnumerableIndex(address token, uint from, uint to) external view returns(uint[] memory tokenIds, string[] memory tokenURIs) {\r\n        require(from < to);\r\n        tokenIds = new uint[](to - from);\r\n        tokenURIs = new string[](to - from);\r\n        uint i = 0;\r\n        for (uint index = from; index < to; index++) {\r\n            try ERC721Enumerable(token).tokenByIndex(index) returns (uint256 tokenId) {\r\n                tokenIds[i] = tokenId;\r\n                try ERC721Metadata(token).tokenURI(tokenId) returns (string memory s) {\r\n                    tokenURIs[i] = s;\r\n                } catch {\r\n                }\r\n            } catch {\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function ownersByEnumerableIndex(address token, uint from, uint to) external view returns(uint[] memory tokenIds, address[] memory owners) {\r\n        require(from < to);\r\n        tokenIds = new uint[](to - from);\r\n        owners = new address[](to - from);\r\n        uint i = 0;\r\n        for (uint index = from; index < to; index++) {\r\n            try ERC721Enumerable(token).tokenByIndex(index) returns (uint256 tokenId) {\r\n                tokenIds[i] = tokenId;\r\n                try ERC721(token).ownerOf(tokenId) returns (address a) {\r\n                    owners[i] = a;\r\n                } catch {\r\n                }\r\n            } catch {\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function getERC20Info(ERC20 token, address[] memory tokenOwners, address spender) public view returns (uint[] memory balances, uint[] memory allowances) {\r\n        balances = new uint[](tokenOwners.length);\r\n        allowances = new uint[](tokenOwners.length);\r\n        for (uint i = 0; i < tokenOwners.length; i++) {\r\n            try token.balanceOf(tokenOwners[i]) returns (uint b) {\r\n                balances[i] = b;\r\n            } catch {\r\n            }\r\n            try token.allowance(tokenOwners[i], spender) returns (uint a) {\r\n                allowances[i] = a;\r\n            } catch {\r\n            }\r\n        }\r\n    }\r\n}"
    }
  }
}