{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MarketCreationRewards.sol": {
      "content": "// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\r\n        require(b <= a, errorMessage);\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint128 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint128 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b <= a, errorMessage);\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint32 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/external/openzeppelin-solidity/math/Math.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/Governed.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMaster {\r\n    mapping(address => bool) public whitelistedSponsor;\r\n    function dAppToken() public view returns(address);\r\n    function isInternal(address _address) public view returns(bool);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\r\n}\r\n\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IChainLinkOracle.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ninterface IChainLinkOracle\r\n{\r\n\t/**\r\n    * @dev Gets the latest answer of chainLink oracle.\r\n    * @return int256 representing the latest answer of chainLink oracle.\r\n    */\r\n\tfunction latestAnswer() external view returns (int256);\r\n\tfunction decimals() external view returns (uint8);\r\n\tfunction getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  \tfunction latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    ); \r\n}\r\n\r\n// File: contracts/interfaces/IMarketUtility.sol\r\n\r\npragma solidity 0.5.7;\r\ncontract IMarketUtility {\r\n\r\n    function initialize(address payable[] calldata _addressParams, address _initiater) external;\r\n\r\n\t/**\r\n     * @dev to Set authorized address to update parameters \r\n     */\r\n    function setAuthorizedAddres() public;\r\n\r\n\t/**\r\n     * @dev to update uint parameters in Market Config \r\n     */\r\n    function updateUintParameters(bytes8 code, uint256 value) external;\r\n\r\n    /**\r\n     * @dev to Update address parameters in Market Config \r\n     */\r\n    function updateAddressParameters(bytes8 code, address payable value) external;\r\n \r\n     /**\r\n    * @dev Get Parameters required to initiate market\r\n    * @return Addresses of tokens to be distributed as incentives\r\n    * @return Cool down time for market\r\n    * @return Rate\r\n    * @return Commission percent for predictions with ETH\r\n    * @return Commission percent for predictions with PLOT\r\n    **/\r\n    function getMarketInitialParams() public view returns(address[] memory, uint , uint, uint, uint);\r\n\r\n    function getAssetPriceUSD(address _currencyAddress) external view returns(uint latestAnswer);\r\n\r\n    function getAssetValueETH(address _currencyAddress, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256 tokenEthValue);\r\n    \r\n    function checkMultiplier(address _asset, address _user, uint _predictionStake, uint predictionPoints, uint _stakeValue) public view returns(uint, bool);\r\n  \r\n    function calculatePredictionPoints(address _user, bool multiplierApplied, uint _predictionStake, address _asset, uint64 totalPredictionPoints, uint64 predictionPointsOnOption) external view returns(uint64 predictionPoints, bool isMultiplierApplied);\r\n\r\n    function calculateOptionRange(uint _optionRangePerc, uint64 _decimals, uint8 _roundOfToNearest, address _marketFeed) external view returns(uint64 _minValue, uint64 _maxValue);\r\n    \r\n    function getOptionPrice(uint64 totalPredictionPoints, uint64 predictionPointsOnOption) public view returns(uint64 _optionPrice);\r\n    \r\n    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8);\r\n\r\n    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\r\n        public\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function update() external;\r\n    \r\n    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied);\r\n    \r\n    /**\r\n     * @dev Get basic market details\r\n     * @return Minimum amount required to predict in market\r\n     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\r\n     * @return Decimal points for prediction positions\r\n     **/\r\n    function getBasicMarketDetails()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function getDisputeResolutionParams() public view returns (uint256);\r\n    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice);\r\n\r\n    /**\r\n     * @dev Get price of provided feed address\r\n     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\r\n     * @return Current price of the market currency\r\n     **/\r\n    function getSettlemetPrice(\r\n        address _currencyFeedAddress,\r\n        uint256 _settleTime\r\n    ) public view returns (uint256 latestAnswer, uint256 roundId);\r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IToken {\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    \r\n     /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param sender address The address which you want to send tokens from\r\n    * @param recipient address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IAllMarkets.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IAllMarkets {\r\n\r\n\tenum PredictionStatus {\r\n      Live,\r\n      InSettlement,\r\n      Cooling,\r\n      InDispute,\r\n      Settled\r\n    }\r\n\r\n    function marketStatus(uint256 _marketId) public view returns(PredictionStatus);\r\n\r\n    function burnDisputedProposalTokens(uint _proposaId) external;\r\n\r\n    function getTotalStakedValueInPLOT(uint256 _marketId) public view returns(uint256);\r\n\r\n}\r\n\r\n// File: contracts/MarketCreationRewards.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract MarketCreationRewards is Governed {\r\n\r\n    using SafeMath for *;\r\n\r\n\t  event MarketCreatorRewardPoolShare(address indexed createdBy, uint256 indexed marketIndex, uint256 plotIncentive, uint256 ethIncentive);\r\n    event MarketCreationReward(address indexed createdBy, uint256 marketIndex, uint256 plotIncentive, uint256 gasUsed, uint256 gasCost, uint256 gasPriceConsidered, uint256 gasPriceGiven, uint256 maxGasCap, uint256 rewardPoolSharePerc);\r\n    event ClaimedMarketCreationReward(address indexed user, uint256 ethIncentive, uint256 plotIncentive);\r\n\r\n    modifier onlyInternal() {\r\n      IMaster(masterAddress).isInternal(msg.sender);\r\n      _;\r\n    }\r\n    \r\n    struct MarketCreationRewardData {\r\n      uint ethIncentive;\r\n      uint plotIncentive;\r\n      uint64 ethDeposited;\r\n      uint64 plotDeposited;\r\n      uint16 rewardPoolSharePerc;\r\n      address createdBy;\r\n    }\r\n\r\n    struct MarketCreationRewardUserData {\r\n      uint incentives;\r\n      uint128 lastClaimedIndex;\r\n      uint64[] marketsCreated;\r\n    }\r\n\t\r\n\t  uint16 internal maxRewardPoolPercForMC;\r\n    uint16 internal minRewardPoolPercForMC;\r\n    uint256 internal maxGasPrice;\r\n    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address internal plotToken;\r\n    uint256 internal plotStakeForRewardPoolShare;\r\n    uint256 internal rewardPoolShareThreshold;\r\n    uint internal predictionDecimalMultiplier;\r\n    ITokenController internal tokenController;\r\n    IChainLinkOracle internal clGasPriceAggregator;\r\n    IMarketUtility internal marketUtility;\r\n    IAllMarkets internal allMarkets;\r\n    mapping(uint256 => MarketCreationRewardData) internal marketCreationRewardData; //Of market\r\n    mapping(address => MarketCreationRewardUserData) internal marketCreationRewardUserData; //Of user\r\n\r\n    /**\r\n     * @dev Changes the master address and update it's instance\r\n     */\r\n    function setMasterAddress() public {\r\n      OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\r\n      require(msg.sender == proxy.proxyOwner(),\"not owner.\");\r\n      IMaster ms = IMaster(msg.sender);\r\n      masterAddress = msg.sender;\r\n      plotToken = ms.dAppToken();\r\n      tokenController = ITokenController(ms.getLatestAddress(\"TC\"));\r\n      allMarkets = IAllMarkets(ms.getLatestAddress(\"AM\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Function to set inital parameters of contract\r\n    * @param _utility MarketUtility address\r\n    * @param _clGasPriceAggregator Chainlink gas price aggregator address\r\n    */\r\n    function initialise(address _utility, address _clGasPriceAggregator) external {\r\n      require(address(clGasPriceAggregator) == address(0));\r\n      clGasPriceAggregator = IChainLinkOracle(_clGasPriceAggregator);\r\n      marketUtility = IMarketUtility(_utility);\r\n      maxGasPrice = 100 * 10**9;\r\n      maxRewardPoolPercForMC = 500; // Raised by 2 decimals\r\n      minRewardPoolPercForMC = 50; // Raised by 2 decimals\r\n      plotStakeForRewardPoolShare = 25000 ether;\r\n      rewardPoolShareThreshold = 1 ether;\r\n      predictionDecimalMultiplier = 10;\r\n    }\r\n\r\n    /**\r\n    * @dev function to update integer parameters\r\n    */\r\n    function updateUintParameters(bytes8 code, uint256 value) external onlyAuthorizedToGovern {\r\n      if(code == \"MAXGAS\") { // Maximum gas upto which is considered while calculating market creation incentives\r\n        maxGasPrice = value;\r\n      } else if(code == \"MAXRPSP\") { // Max Reward Pool percent for market creator\r\n        maxRewardPoolPercForMC = uint16(value);\r\n      } else if(code == \"MINRPSP\") { // Min Reward Pool percent for market creator\r\n        minRewardPoolPercForMC = uint16(value);\r\n      } else if(code == \"PSFRPS\") { // Reward Pool percent for market creator\r\n        plotStakeForRewardPoolShare = value;\r\n      } else if(code == \"RPSTH\") { // Reward Pool percent for market creator\r\n        rewardPoolShareThreshold = value;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev function to update address parameters\r\n    */\r\n    function updateAddressParameters(bytes8 code, address payable value) external onlyAuthorizedToGovern {\r\n      if(code == \"GASAGG\") { // Incentive to be distributed to user for market creation\r\n        clGasPriceAggregator = IChainLinkOracle(value);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev function to get integer parameters\r\n    */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint256 value) {\r\n      codeVal = code;\r\n      if(code == \"MAXGAS\") { // Maximum gas upto which is considered while calculating market creation incentives\r\n        value = maxGasPrice;\r\n      } else if(code == \"MAXRPSP\") { // Max Reward Pool percent for market creator\r\n        value = maxRewardPoolPercForMC;\r\n      } else if(code == \"MINRPSP\") { // Min Reward Pool percent for market creator\r\n        value = minRewardPoolPercForMC;\r\n      } else if(code == \"PSFRPS\") { // Reward Pool percent for market creator\r\n        value = plotStakeForRewardPoolShare;\r\n      } else if(code == \"RPSTH\") { // Reward Pool percent for market creator\r\n        value = rewardPoolShareThreshold;\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev function to get address parameters\r\n    */\r\n    function getAddressParameters(bytes8 code) external view returns(bytes8 codeVal, address value) {\r\n      codeVal = code;\r\n      if(code == \"GASAGG\") { // Incentive to be distributed to user for market creation\r\n        value = address(clGasPriceAggregator);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate market reward pool share percent to be rewarded to market creator\r\n    */\r\n    function _checkIfCreatorStaked(address _createdBy, uint64 _marketId) internal {\r\n      uint256 tokensLocked = ITokenController(tokenController).tokensLockedAtTime(_createdBy, \"SM\", now);\r\n      marketCreationRewardData[_marketId].createdBy = _createdBy;\r\n      //Intentionally performed mul operation after div, to get absolute value instead of decimals\r\n      marketCreationRewardData[_marketId].rewardPoolSharePerc\r\n       = uint16(Math.min(\r\n          maxRewardPoolPercForMC,\r\n          minRewardPoolPercForMC + tokensLocked.div(plotStakeForRewardPoolShare).mul(minRewardPoolPercForMC)\r\n        ));\r\n    }\r\n\r\n    /**\r\n    * @dev function to calculate user incentive for market creation\r\n    * @param _createdBy Address of market creator\r\n    * @param _gasCosumed Gas consumed by the transaction till now \r\n    * @param _marketId Index of market\r\n    */\r\n    function calculateMarketCreationIncentive(address _createdBy, uint256 _gasCosumed, uint64 _marketId) external onlyInternal {\r\n      _checkIfCreatorStaked(_createdBy, _marketId);\r\n      marketCreationRewardUserData[_createdBy].marketsCreated.push(_marketId);\r\n      uint256 gasUsedTotal;\r\n      //Adding buffer gas for below calculations\r\n      gasUsedTotal = _gasCosumed + 84000;\r\n      uint256 gasPrice = _checkGasPrice();\r\n      uint256 gasCost = gasUsedTotal.mul(gasPrice);\r\n      (, uint256 incentive) = marketUtility.getValueAndMultiplierParameters(ETH_ADDRESS, gasCost);\r\n      marketCreationRewardUserData[_createdBy].incentives = marketCreationRewardUserData[_createdBy].incentives.add(incentive);\r\n      emit MarketCreationReward(_createdBy, _marketId, incentive, gasUsedTotal, gasCost, gasPrice, tx.gasprice, maxGasPrice, marketCreationRewardData[_marketId].rewardPoolSharePerc);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate gas price for market creation incentives\r\n    */\r\n    function _checkGasPrice() internal view returns(uint256) {\r\n      uint fastGas = uint(clGasPriceAggregator.latestAnswer());\r\n      uint fastGasWithMaxDeviation = fastGas.mul(125).div(100);\r\n      return Math.min(Math.min(tx.gasprice,fastGasWithMaxDeviation), maxGasPrice);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to deposit market reward pool share funds for market creator\r\n    * @param _marketId Index of market\r\n    * @param _plotShare PLOT reward pool share\r\n    * msg.value ETH reward pool share\r\n    */\r\n    function depositMarketRewardPoolShare(uint256 _marketId, uint256 _ethShare, uint256 _plotShare, uint64 _ethDeposited, uint64 _plotDeposited) external payable onlyInternal {\r\n    \tmarketCreationRewardData[_marketId].ethIncentive = _ethShare;\r\n    \tmarketCreationRewardData[_marketId].plotIncentive = _plotShare;\r\n      marketCreationRewardData[_marketId].ethDeposited = _ethDeposited;\r\n      marketCreationRewardData[_marketId].plotDeposited = _plotDeposited;\r\n     \temit MarketCreatorRewardPoolShare(marketCreationRewardData[_marketId].createdBy, _marketId, _plotShare, _ethShare);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to return the market reward pool share funds of market creator: To be used in case of dispute\r\n    * @param _marketId Index of market\r\n    */\r\n    function returnMarketRewardPoolShare(uint256 _marketId) external onlyInternal{\r\n      uint256 plotToTransfer = marketCreationRewardData[_marketId].plotIncentive.add(marketCreationRewardData[_marketId].plotDeposited.mul(10**predictionDecimalMultiplier));\r\n      uint256 ethToTransfer = marketCreationRewardData[_marketId].ethIncentive.add(marketCreationRewardData[_marketId].ethDeposited.mul(10**predictionDecimalMultiplier));\r\n      delete marketCreationRewardData[_marketId].ethIncentive;\r\n      delete marketCreationRewardData[_marketId].plotIncentive;\r\n      delete marketCreationRewardData[_marketId].ethDeposited;\r\n      delete marketCreationRewardData[_marketId].plotDeposited;\r\n      _transferAsset(ETH_ADDRESS, msg.sender, ethToTransfer);\r\n      _transferAsset(plotToken, msg.sender, plotToTransfer);\r\n    }\r\n\r\n    /**\r\n    * @dev function to reward user for initiating market creation calls as per the new incetive calculations\r\n    */\r\n    function claimCreationReward(uint256 _maxRecords) external {\r\n      uint256 pendingPLOTReward = marketCreationRewardUserData[msg.sender].incentives;\r\n      delete marketCreationRewardUserData[msg.sender].incentives;\r\n      (uint256 ethIncentive, uint256 plotIncentive) = _getRewardPoolIncentives(_maxRecords);\r\n      pendingPLOTReward = pendingPLOTReward.add(plotIncentive);\r\n      require(pendingPLOTReward > 0 || ethIncentive > 0, \"No pending\");\r\n      _transferAsset(address(plotToken), msg.sender, pendingPLOTReward);\r\n      _transferAsset(ETH_ADDRESS, msg.sender, ethIncentive);\r\n      emit ClaimedMarketCreationReward(msg.sender, ethIncentive, pendingPLOTReward);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer `_amount` number of market registry assets contract to `_to` address\r\n    */\r\n    function transferAssets(address _asset, address payable _to, uint _amount) external onlyAuthorizedToGovern {\r\n      _transferAsset(_asset, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate market reward pool share incentives for market creator\r\n    */\r\n    function _getRewardPoolIncentives(uint256 _maxRecords) internal returns(uint256 ethIncentive, uint256 plotIncentive) {\r\n      MarketCreationRewardUserData storage rewardData = marketCreationRewardUserData[msg.sender];\r\n      uint256 len = rewardData.marketsCreated.length;\r\n      uint256 lastClaimed = len;\r\n      uint256 count;\r\n      uint128 i;\r\n      for(i = rewardData.lastClaimedIndex;i < len && count < _maxRecords; i++) {\r\n        MarketCreationRewardData storage marketData = marketCreationRewardData[rewardData.marketsCreated[i]];\r\n        if(allMarkets.marketStatus(rewardData.marketsCreated[i]) == IAllMarkets.PredictionStatus.Settled) {\r\n          ethIncentive = ethIncentive.add(marketData.ethIncentive);\r\n          plotIncentive = plotIncentive.add(marketData.plotIncentive);\r\n          delete marketData.ethIncentive;\r\n          delete marketData.plotIncentive;\r\n          count++;\r\n        } else {\r\n          if(lastClaimed == len) {\r\n            lastClaimed = i;\r\n          }\r\n        }\r\n      }\r\n      if(lastClaimed == len) {\r\n        lastClaimed = i;\r\n      }\r\n      rewardData.lastClaimedIndex = uint128(lastClaimed);\r\n    }\r\n\r\n    /**\r\n    * @dev function to get pending reward of user for initiating market creation calls as per the new incetive calculations\r\n    * @param _user Address of user for whom pending rewards to be checked\r\n    * @return plotIncentive Incentives given for creating market as per the gas consumed\r\n    * @return pendingPLOTReward PLOT Reward pool share of markets created by user\r\n    * @return pendingETHReward ETH Reward pool share of markets created by user\r\n    */\r\n    function getPendingMarketCreationRewards(address _user) external view returns(uint256 plotIncentive, uint256 pendingPLOTReward, uint256 pendingETHReward){\r\n      plotIncentive = marketCreationRewardUserData[_user].incentives;\r\n      (pendingETHReward, pendingPLOTReward) = _getPendingRewardPoolIncentives(_user);\r\n    }\r\n\r\n    /**\r\n    * @dev Get market reward pool share percent to be rewarded to market creator\r\n    */\r\n    function getMarketCreatorRPoolShareParams(uint256 _market, uint256 plotStaked, uint256 ethStaked) external view returns(uint16, bool) {\r\n      return (marketCreationRewardData[_market].rewardPoolSharePerc, _checkIfThresholdReachedForRPS(_market, plotStaked, ethStaked));\r\n    }\r\n\r\n    /**\r\n    * @dev Check if threshold reached for reward pool share percent for market creator.\r\n    * Calculate total leveraged amount staked in market value in ETH\r\n    * @param _marketId Index of market to check threshold\r\n    */\r\n    function _checkIfThresholdReachedForRPS(uint256 _marketId, uint256 plotStaked, uint256 ethStaked) internal view returns(bool) {\r\n      uint256 _plotStaked;\r\n      _plotStaked = marketUtility.getAssetValueETH(plotToken, plotStaked.mul(1e10));\r\n      return (_plotStaked.add(ethStaked.mul(1e10)) > rewardPoolShareThreshold);\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to calculate market reward pool share incentives for market creator\r\n    */\r\n    function _getPendingRewardPoolIncentives(address _user) internal view returns(uint256 ethIncentive, uint256 plotIncentive) {\r\n      MarketCreationRewardUserData memory rewardData = marketCreationRewardUserData[_user];\r\n      uint256 len = rewardData.marketsCreated.length;\r\n      for(uint256 i = rewardData.lastClaimedIndex;i < len; i++) {\r\n        MarketCreationRewardData memory marketData = marketCreationRewardData[rewardData.marketsCreated[i]];\r\n        if(marketData.ethIncentive > 0 || marketData.plotIncentive > 0) {\r\n          if(allMarkets.marketStatus(rewardData.marketsCreated[i]) == IAllMarkets.PredictionStatus.Settled) {\r\n            ethIncentive = ethIncentive.add(marketData.ethIncentive);\r\n            plotIncentive = plotIncentive.add(marketData.plotIncentive);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the assets to specified address.\r\n    * @param _asset The asset transfer to the specific address.\r\n    * @param _recipient The address to transfer the asset of\r\n    * @param _amount The amount which is transfer.\r\n    */\r\n    function _transferAsset(address _asset, address payable _recipient, uint256 _amount) internal {\r\n      if(_amount > 0) { \r\n        if(_asset == ETH_ADDRESS) {\r\n          _recipient.transfer(_amount);\r\n        } else {\r\n          require(IToken(_asset).transfer(_recipient, _amount));\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Payable Fallback function to receive funds\r\n    */\r\n    function () external payable {\r\n    }\r\n\r\n}"
    }
  }
}