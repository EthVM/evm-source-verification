{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Oracle_v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.4;\n\n/******************************************/\n/*       DEX starts here            */\n/******************************************/\n\nabstract contract DEX \n\n{\n    function sync() external virtual;\n}\n\n/******************************************/\n/*       Benchmark starts here            */\n/******************************************/\n\nabstract contract Benchmark \n\n{\n    function rebase(uint256 supplyDelta, bool increaseSupply) external virtual returns (uint256);\n    \n    function transfer(address to, uint256 value) external virtual returns (bool);\n    \n    function balanceOf(address who) external virtual view returns (uint256);\n}\n\n\n/******************************************/\n/*       multiSigOracle starts here       */\n/******************************************/\n\ncontract MultiSigOracle {\n\n    address owner1;\n    address owner2;\n    address owner3;\n    address owner4;\n    address owner5;\n\n    address public standard;\n    uint256 public standardRewards;\n    \n    Benchmark public bm;\n    DEX[] public Pools;\n\n    Transaction public pendingRebasement;\n    uint256 internal lastRebasementTime;\n\n    struct Transaction {\n        address initiator;\n        uint supplyDelta;\n        bool increaseSupply;\n        bool executed;\n    }\n\n    modifier isOwner() \n    {\n        require (msg.sender == owner1 || msg.sender == owner2 || msg.sender == owner3 || msg.sender == owner4 || msg.sender == owner5);\n        _;\n    }\n\n    constructor(address _Benchmark, address _Standard)\n    {\n        owner1 = 0x2c155e07a1Ee62f229c9968B7A903dC69436e3Ec;\n        owner2 = 0xdBd39C1b439ba2588Dab47eED41b8456486F4Ba5;\n        owner3 = 0x90d33D152A422D63e0Dd1c107b7eD3943C06ABA8;\n        owner4 = 0xE12E421D5C4b4D8193bf269BF94DC8dA28798BA9;\n        owner5 = 0xD4B33C108659A274D8C35b60e6BfCb179a2a6D4C;\n        standard = _Standard;\n        bm = Benchmark(_Benchmark);\n        \n        pendingRebasement.executed = true;\n    }\n\n    /**\n     * @dev Initiates a rebasement proposal that has to be confirmed by another owner of the contract to be executed. Can't be called while another proposal is pending.\n     * @param _supplyDelta Change in totalSupply of the Benchmark token.\n     * @param _increaseSupply Whether to increase or decrease the totalSupply of the Benchmark token.\n     */\n    function initiateRebasement(uint256 _supplyDelta, bool _increaseSupply) public isOwner\n    {\n        require (pendingRebasement.executed == true, \"Pending rebasement.\");\n        require (lastRebasementTime < (block.timestamp - 64800), \"Rebasement has already occured within the past 18 hours.\");\n\n        Transaction storage txn = pendingRebasement; \n        txn.initiator = msg.sender;\n        txn.supplyDelta = _supplyDelta;\n        txn.increaseSupply = _increaseSupply;\n        txn.executed = false;\n    }\n\n    /**\n     * @dev Confirms and executes a pending rebasement proposal. Prohibits further proposals for 18 hours.\n     */\n    function confirmRebasement() public isOwner\n    {\n        require (pendingRebasement.initiator != msg.sender, \"Initiator can't confirm rebasement.\");\n        require (pendingRebasement.executed == false, \"Rebasement already executed.\");\n        \n        pendingRebasement.executed = true;\n        lastRebasementTime = block.timestamp;\n\n        bm.rebase(pendingRebasement.supplyDelta, pendingRebasement.increaseSupply);\n\n        uint256 arrayLength = Pools.length;\n        for (uint256 i = 0; i < arrayLength; i++) \n        {\n            if (address(Pools[i]) != address(0)) {\n                Pools[i].sync();\n            }           \n        }\n\n        bm.transfer(standard, standardRewards);\n    }\n\n    /**\n     * @dev Denies a pending rebasement proposal and allows the creation of a new proposal.\n     */\n    function denyRebasement() public isOwner\n    {\n        require (pendingRebasement.executed == false, \"Rebasement already executed.\");\n        \n        pendingRebasement.executed = true;\n    }\n\n    /**\n     * @dev Add a new Liquidity Pool. \n     * @param _lpPool Address of Liquidity Pool.\n     */\n    function addPool (address _lpPool) public isOwner {\n        Pools.push(DEX(_lpPool));\n    }\n\n    /**\n     * @dev Remove a Liquidity Pool. \n     * @param _index Index of Liquidity Pool.\n     */\n    function removePool (uint256 _index) public isOwner {\n        delete Pools[_index];\n    }\n\n    /**\n     * @dev Change Standard staking rewards. \n     * @param _standardRewards New amount of rewards.\n     */\n    function setStandardRewards (uint256 _standardRewards) public isOwner {\n        standardRewards = _standardRewards;\n    }\n\n    /**\n     * @dev Remove all MARK deposited on this contract. \n     */\n    function withdrawMark () public {\n        require (msg.sender == 0x2c155e07a1Ee62f229c9968B7A903dC69436e3Ec || msg.sender == 0xdBd39C1b439ba2588Dab47eED41b8456486F4Ba5, \"Only Masterchief can withdraw.\");\n        bm.transfer(msg.sender, bm.balanceOf(address(this)));\n    }\n}\n    "
    }
  }
}