{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/P2pSwap-2.sol": {
      "content": "\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/P2pSwap.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0;\r\n\r\n\r\n/**\r\n * @title P2pSwap\r\n * @dev Basic peer to per swap. Alice exchanging X tok1 with Y tok2 with Bob\r\n **/\r\ncontract P2pSwap {\r\n    struct Swap {\r\n        address aliceAddress;\r\n        address token1;\r\n        uint256 value1;\r\n        address token2;\r\n        uint256 value2;\r\n        uint8 executed; // 0 - pending, 1 - executed, 2 - cancelled\r\n    }\r\n\r\n    mapping(uint256 => Swap) swaps;\r\n\r\n    function getSwap(uint256 _id)\r\n    public view returns (address, address, uint256, address, uint256, uint8) {\r\n        Swap memory swap = swaps[_id];\r\n        return (\r\n            swap.aliceAddress,\r\n            swap.token1,\r\n            swap.value1,\r\n            swap.token2,\r\n            swap.value2,\r\n            swap.executed\r\n        );\r\n    }\r\n\r\n    function registerSwap(\r\n        uint256 _id,\r\n        address _aliceAddress,\r\n        address _token1,\r\n        uint256 _value1,\r\n        address _token2,\r\n        uint256 _value2)\r\n    public returns (bool) {\r\n        require(_id != 0);\r\n        require(_aliceAddress != address(0));\r\n        require(_token1 != address(0));\r\n        require(_value1 != 0);\r\n        require(_token2 != address(0));\r\n        require(_value2 != 0);\r\n        Swap storage swap = swaps[_id];\r\n        require(swap.aliceAddress == address(0), \"Swap already exists\");\r\n        swap.aliceAddress = _aliceAddress;\r\n        swap.token1 = _token1;\r\n        swap.value1 = _value1;\r\n        swap.token2 = _token2;\r\n        swap.value2 = _value2;\r\n        return true;\r\n    }\r\n\r\n    function cancelSwap(uint256 _id) public returns (bool) {\r\n        Swap storage swap = swaps[_id];\r\n        require(swap.executed == 0, \"Swap not available\");\r\n        swap.executed = 2;\r\n    }\r\n\r\n    function executeSwap(uint256 _id, address _bob)\r\n    public returns (bool) {\r\n        require(_bob != address(0));\r\n        Swap storage swap = swaps[_id];\r\n        require(swap.aliceAddress != address(0), \"Swap does not exists\");\r\n        require(swap.executed == 2, \"Swap not available\");\r\n        IERC20 Token1 = IERC20(swap.token1);\r\n        IERC20 Token2 = IERC20(swap.token2);\r\n        // Swap. Make sure to set the allowances in advance\r\n        Token1.transferFrom(swap.aliceAddress, _bob, swap.value1);\r\n        Token2.transferFrom(_bob, swap.aliceAddress, swap.value2);\r\n        swap.executed = 1;\r\n        return true;\r\n    }\r\n}\r\n"
    }
  }
}