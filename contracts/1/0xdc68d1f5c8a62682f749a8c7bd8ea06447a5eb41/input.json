{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ScoreLabClientsGnosisSafeModuleCowSwap.sol": {
      "content": "// Sources flattened with hardhat v2.6.3 https://hardhat.org\r\n\r\n// File contracts/libraries/CowSwapUtils.sol\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nlibrary CowSwapUtils {\r\n    struct Order {\r\n        address sellToken;\r\n        address buyToken;\r\n        address receiver;\r\n        uint256 sellAmount;\r\n        uint256 buyAmount;\r\n        uint32 validTo;\r\n        bytes32 appData;\r\n        uint256 feeAmount;\r\n        bytes32 kind;\r\n        bool partiallyFillable;\r\n        bytes32 sellTokenBalance;\r\n        bytes32 buyTokenBalance;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/Enum.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Enum {\r\n    enum GnosisSafeOperation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IGnosisSafe.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IGnosisSafe {\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.GnosisSafeOperation operation\r\n    ) external returns (bool success);\r\n\r\n    function getOwners() external view returns (address[] memory);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IGPv2Settlement.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IGPv2Settlement {\r\n    function filledAmount(bytes calldata) external view returns (uint256);\r\n    function vaultRelayer() external view returns (address);\r\n    function domainSeparator() external view returns (bytes32);\r\n    function setPreSignature(bytes calldata orderUid, bool signed) external;\r\n}\r\n\r\n\r\n// File contracts/ScoreLabClientsGnosisSafeModuleCowSwap.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ncontract ScoreLabClientsGnosisSafeModuleCowSwap {\r\n    struct Allowance {\r\n        uint256 amount;\r\n        uint256 expiration;\r\n    }\r\n\r\n    struct CowSwapOrder {\r\n        address safe;\r\n        uint256 expiration;\r\n        address sellToken;\r\n        address buyToken;\r\n        uint256 sellAmount;\r\n    }\r\n\r\n    event Deposit(address indexed safe, uint256 value);\r\n    event Refund(address indexed safe, uint256 value);\r\n\r\n    address private constant GPV2_SETTLEMENT = address(0x9008D19f58AAbD9eD0D60971565AA8510560ab41);\r\n\r\n    bytes32 private constant COWSWAP_TYPE_HASH =\r\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\r\n    uint256 private constant COWSWAP_UID_LENGTH = 56;\r\n    uint256 private constant COWSWAP_ORDER_TIMEOUT = 720; //12 minutes\r\n\r\n    mapping(address => bool) private _isAdmin;\r\n    mapping(address => bool) private _isScoreLab;\r\n    mapping(address => uint256) private _gasTanks;\r\n    mapping(address => mapping(address => mapping(address => Allowance)))\r\n        private _allowances;\r\n    mapping(bytes => CowSwapOrder) private _cowSwapOrders;\r\n\r\n    /**\r\n      SL#01: admin only operation\r\n      SL#02: ScoreLab only operation\r\n      SL#03: admin cannot revoke itself\r\n      SL#04: invalid token pair parameters\r\n      SL#05: insufficient gas tank\r\n      SL#06: unable to payback gas, recipient may have reverted\r\n      SL#07: insufficient allowance\r\n      SL#08: lapsed allowance\r\n      SL#09: invalid beneficiary\r\n      SL#10: error presigning order\r\n      SL#11: approve error\r\n      SL#12: order in progress\r\n      SL#13: no order found for the specified orderUid\r\n      SL#14: wrong provided order expiration\r\n      SL#15: the orderUid is related to another safe\r\n      SL#16: order already finalized\r\n     */\r\n\r\n    modifier onlyAdmin() {\r\n        require(_isAdmin[msg.sender], \"SL#01\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyScoreLab() {\r\n        require(_isScoreLab[msg.sender], \"SL#02\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyForSafe(address safe, address beneficiary) {\r\n        require(beneficiary == safe, \"SL#09\");\r\n        _;\r\n    }\r\n\r\n    constructor(address admin) {\r\n        _isAdmin[admin] = true;\r\n    }\r\n\r\n    function deposit(address safe) external payable {\r\n        _gasTanks[safe] += msg.value;\r\n\r\n        emit Deposit(safe, msg.value);\r\n    }\r\n\r\n    function refund(\r\n        address safe,\r\n        uint256 value,\r\n        address to\r\n    ) external onlyScoreLab {\r\n        require(_gasTanks[safe] >= value, \"SL#05\");\r\n        (bool success, ) = to.call{value: value}(\"\");\r\n        require(success, \"SL#06\");\r\n        _gasTanks[safe] -= value;\r\n\r\n        emit Refund(safe, value);\r\n    }\r\n\r\n    function placeOrder(\r\n        address safe,\r\n        CowSwapUtils.Order memory order\r\n    ) \r\n        external\r\n        onlyScoreLab\r\n        onlyForSafe(safe, order.receiver) \r\n        {\r\n            Allowance storage allowance = _allowances[safe][order.sellToken][order.buyToken];\r\n            require(allowance.amount >= order.sellAmount, \"SL#07\");\r\n            require(allowance.expiration >= order.validTo, \"SL#08\");\r\n            require(order.validTo <= block.timestamp + COWSWAP_ORDER_TIMEOUT, \"SL#14\");\r\n\r\n            bytes memory orderUid = _generateOrderUid(order);\r\n\r\n            require (\r\n                IGnosisSafe(safe).execTransactionFromModule(\r\n                    GPV2_SETTLEMENT,\r\n                    0,\r\n                    abi.encodeWithSignature(\"setPreSignature(bytes,bool)\", orderUid, true),\r\n                    Enum.GnosisSafeOperation.Call\r\n                ),\r\n                \"SL#10\"\r\n            );\r\n\r\n            allowance.amount -= order.sellAmount;\r\n\r\n            CowSwapOrder storage cowSwapOrder = _cowSwapOrders[orderUid];\r\n\r\n            cowSwapOrder.safe = safe;\r\n            cowSwapOrder.expiration = uint256(order.validTo);\r\n            cowSwapOrder.sellToken = order.sellToken;\r\n            cowSwapOrder.buyToken = order.buyToken;\r\n            cowSwapOrder.sellAmount = order.sellAmount;\r\n        }\r\n\r\n    function finalizeOrder(\r\n        address safe,\r\n        bytes memory orderUid\r\n    )\r\n        external\r\n        onlyScoreLab\r\n        {\r\n            CowSwapOrder storage cowSwapOrder = _cowSwapOrders[orderUid];\r\n            require(cowSwapOrder.sellAmount > 0, \"SL#13\");\r\n            require(cowSwapOrder.safe == safe, \"SL#15\");\r\n            require(cowSwapOrder.expiration > 0, \"SL#16\");\r\n\r\n            Allowance storage allowance = _allowances[safe][cowSwapOrder.sellToken][cowSwapOrder.buyToken];\r\n\r\n            uint256 orderFilledAmount = IGPv2Settlement(GPV2_SETTLEMENT)\r\n                        .filledAmount(orderUid);\r\n\r\n            if (orderFilledAmount == cowSwapOrder.sellAmount) {\r\n                //Order successfull\r\n                cowSwapOrder.expiration = 0;\r\n            } else if (orderFilledAmount == type(uint256).max) {\r\n                //Order killed\r\n                cowSwapOrder.expiration = 0;\r\n\r\n                allowance.amount += cowSwapOrder.sellAmount; \r\n            } else if (cowSwapOrder.expiration < block.timestamp) {\r\n                //Order expired\r\n                cowSwapOrder.expiration = 0;\r\n\r\n                allowance.amount += cowSwapOrder.sellAmount; \r\n            } else {\r\n                revert(\"SL#12\");\r\n            } \r\n        }\r\n\r\n    function approveSwap(\r\n        address safe,\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 amount\r\n        ) \r\n        external\r\n        onlyScoreLab\r\n        {\r\n            Allowance storage allowance = _allowances[safe][fromToken][toToken];\r\n            require(allowance.amount >= amount, \"SL#07\");\r\n            require(allowance.expiration >= block.timestamp, \"SL#08\");\r\n\r\n            address vaultRelayer = IGPv2Settlement(GPV2_SETTLEMENT)\r\n                        .vaultRelayer();\r\n\r\n            //Init approval to 0 to avoid attack vectors\r\n            require (\r\n                IGnosisSafe(safe).execTransactionFromModule(\r\n                    fromToken,\r\n                    0,\r\n                    abi.encodeWithSelector(0x095ea7b3, vaultRelayer, 0),\r\n                    Enum.GnosisSafeOperation.Call\r\n                ),\r\n                \"SL#11\"\r\n            );\r\n\r\n            //Approval with the specified amount\r\n            require(\r\n                IGnosisSafe(safe).execTransactionFromModule(\r\n                    fromToken,\r\n                    0,\r\n                    abi.encodeWithSelector(0x095ea7b3, vaultRelayer, amount),\r\n                    Enum.GnosisSafeOperation.Call\r\n                ),\r\n                \"SL#11\"\r\n            );\r\n    }\r\n\r\n    function setTokenPair(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 expiration\r\n    ) external {\r\n        require(amount == 0 || expiration > block.timestamp, \"SL#04\");\r\n        require(amount != 0 || expiration == 0, \"SL#04\");\r\n\r\n        _allowances[msg.sender][from][to] = Allowance({\r\n            amount: amount,\r\n            expiration: expiration\r\n        });\r\n    }\r\n\r\n    function setAdmin(address account, bool isAdmin) external onlyAdmin {\r\n        require(isAdmin || msg.sender != account, \"SL#03\");\r\n\r\n        _isAdmin[account] = isAdmin;\r\n    }\r\n\r\n    function setScoreLab(address account, bool isScoreLab) external onlyAdmin {\r\n        _isScoreLab[account] = isScoreLab;\r\n    }\r\n\r\n    function getGasTankResidue(\r\n        address safe\r\n    )\r\n        external\r\n        view\r\n        returns(uint256)\r\n        {\r\n            return _gasTanks[safe];\r\n        }\r\n\r\n    function getAllowance(\r\n        address safe,\r\n        address fromToken,\r\n        address toToken\r\n    )\r\n        external\r\n        view\r\n        returns(uint256 amount, uint256 expiration)\r\n        {\r\n            Allowance storage allowance = _allowances[safe][fromToken][toToken];\r\n\r\n            amount = allowance.amount;\r\n\r\n            expiration = allowance.expiration;\r\n        }\r\n\r\n    function getOrderFinalizationStatus(\r\n        bytes memory orderUid\r\n    )\r\n        external\r\n        view\r\n        returns(bool)\r\n        {\r\n            CowSwapOrder storage cowSwapOrder = _cowSwapOrders[orderUid];\r\n\r\n            require(cowSwapOrder.sellAmount > 0, \"SL#13\");\r\n\r\n            return cowSwapOrder.expiration == 0;\r\n        }\r\n\r\n    function _generateOrderUid(CowSwapUtils.Order memory order)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n        {\r\n            bytes32 domainSeparator = IGPv2Settlement(GPV2_SETTLEMENT)\r\n                            .domainSeparator();\r\n\r\n            bytes32 orderDigest;\r\n\r\n            bytes32 structHash;\r\n\r\n            assembly {\r\n                let dataStart := sub(order, 32)\r\n                let temp := mload(dataStart)\r\n                mstore(dataStart, COWSWAP_TYPE_HASH)\r\n                structHash := keccak256(dataStart, 416)\r\n                mstore(dataStart, temp)\r\n            }\r\n\r\n            assembly {\r\n                let freeMemoryPointer := mload(0x40)\r\n                mstore(freeMemoryPointer, \"\\x19\\x01\")\r\n                mstore(add(freeMemoryPointer, 2), domainSeparator)\r\n                mstore(add(freeMemoryPointer, 34), structHash)\r\n                orderDigest := keccak256(freeMemoryPointer, 66)\r\n            }\r\n\r\n            address receiver = order.receiver;\r\n\r\n            uint32 validTo = order.validTo;\r\n\r\n            bytes memory orderUid = new bytes(COWSWAP_UID_LENGTH);\r\n\r\n            assembly {\r\n                mstore(add(orderUid, 56), validTo)\r\n                mstore(add(orderUid, 52), receiver)\r\n                mstore(add(orderUid, 32), orderDigest)\r\n            }\r\n\r\n            return orderUid;\r\n        }\r\n}"
    }
  }
}