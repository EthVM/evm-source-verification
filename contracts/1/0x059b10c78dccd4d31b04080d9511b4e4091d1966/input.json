{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"exchange.sol":{"content":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface InterfaceERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract exchange {\r\n    using SafeMath for uint256;\r\n    address public manager;\r\n    address public USDT;\r\n    address public GWTB;\r\n    uint256 public USDT_GWTB; // default 0.19\r\n    bool public USDT_GWTB_IS_OPEN;\r\n    bool public GWTB_USDT_IS_OPEN;\r\n    \r\n    struct user{\r\n        address user;\r\n        address referrer;\r\n        uint256 gwtb_total; // usdt -> gwtb 总量\r\n        uint256 usdt_total; // gwtb -> usdt 总量\r\n    }\r\n    user[] public UserData;\r\n    mapping(address => uint256) public UserIndex;\r\n\r\n    event usdt_gwtb_event(address user,uint256 from_usdt,uint256 to_gwtb);\r\n    event gwtb_usdt_event(address user,uint256 from_gwtb,uint256 to_usdt);\r\n    \r\n    constructor(address usdt,address gwtb)public{\r\n        USDT = usdt;\r\n        GWTB = gwtb;\r\n        manager = msg.sender;\r\n    }\r\n    \r\n    // USDT - GWTB \r\n    function usdt_gwtb(address referrer,uint256 value)public{\r\n        require(value > 0 && USDT_GWTB_IS_OPEN == true);\r\n        // 转入USDT\r\n        InterfaceERC20(USDT).transferFrom(msg.sender,address(this),value);\r\n        uint256 total = getUSDT_GWTB(value);\r\n        // 将GWTB转到用户地址\r\n        InterfaceERC20(GWTB).transfer(msg.sender,total);\r\n        uint256 index = UserIndex[msg.sender];\r\n        if(index == 0){\r\n            if(referrer != msg.sender && referrer != address(0)){\r\n                UserData.push(user({user:msg.sender,referrer:referrer,gwtb_total:total,usdt_total:0}));\r\n            }else{\r\n                UserData.push(user({user:msg.sender,referrer:address(0),gwtb_total:total,usdt_total:0}));\r\n            }\r\n            UserIndex[msg.sender] = UserData.length;\r\n        }else if(UserData[UserIndex[msg.sender].sub(1)].referrer == address(0) && referrer != msg.sender){\r\n            UserData[UserIndex[msg.sender].sub(1)].referrer = referrer;\r\n        }\r\n        if(index != 0){\r\n            UserData[UserIndex[msg.sender].sub(1)].gwtb_total += total;\r\n        }\r\n        emit usdt_gwtb_event(msg.sender,value,total);\r\n    }\r\n    \r\n    // GWTB - USDT\r\n    function gwtb_usdt(address referrer,uint256 value)public{\r\n        require(value > 0 && GWTB_USDT_IS_OPEN == true);\r\n        // 转入GWTB\r\n        InterfaceERC20(GWTB).transferFrom(msg.sender,address(this),value);\r\n        uint256 total = getGWTB_USDT(value);\r\n        InterfaceERC20(USDT).transfer(msg.sender,total);\r\n        \r\n        uint256 index = UserIndex[msg.sender];\r\n        if(index == 0){\r\n            if(referrer != msg.sender && referrer != address(0)){\r\n                UserData.push(user({user:msg.sender,referrer:referrer,gwtb_total:0,usdt_total:total}));\r\n            }else{\r\n                UserData.push(user({user:msg.sender,referrer:address(0),gwtb_total:0,usdt_total:total}));\r\n            }\r\n            UserIndex[msg.sender] = UserData.length;\r\n        }else if(UserData[UserIndex[msg.sender].sub(1)].referrer == address(0) && referrer != msg.sender){\r\n            UserData[UserIndex[msg.sender].sub(1)].referrer = referrer;\r\n        }\r\n        if(index != 0){\r\n            UserData[UserIndex[msg.sender].sub(1)].usdt_total += total;\r\n        }\r\n        emit gwtb_usdt_event(msg.sender,value,total);\r\n    }\r\n    \r\n    function getUserData() view public returns(user[] memory){\r\n        return UserData;\r\n    }\r\n    \r\n    // 计算交换金额\r\n    // 公式：1 / 190 * 1000\r\n    function getUSDT_GWTB(uint256 value) view public returns(uint256){\r\n        return value.div(USDT_GWTB).mul(1000);\r\n    }\r\n    \r\n    // 公式：1 * 190 / 1000\r\n    function getGWTB_USDT(uint256 value) view public returns(uint256){\r\n        return value.mul(USDT_GWTB).div(1000);\r\n    }\r\n    \r\n    // 设置USDT当前兑换价格\r\n    function ownerSetUSDT_GWTB(uint256 value)public onlyOwner{\r\n        require(value > 0);\r\n        USDT_GWTB = value;\r\n    }\r\n    \r\n    // 开启USDT-GWTB\r\n    function ownerIsOpenExchange(bool b,uint256 i) public onlyOwner{\r\n        if (i == 1){\r\n            USDT_GWTB_IS_OPEN = b;\r\n        }else if(i == 2){\r\n            GWTB_USDT_IS_OPEN = b;\r\n        }\r\n    }\r\n    \r\n    // Owner转移\r\n    function ownerTransfer(address newOwner) public onlyOwner{\r\n        require(newOwner != address(0));\r\n        manager = newOwner;\r\n    }\r\n    \r\n    // 提币\r\n    function ownerWithdrawal(uint256 value,uint256 i) public onlyOwner{\r\n        if(i == 1){\r\n            InterfaceERC20(USDT).transfer(msg.sender,value);\r\n        }else if(i == 2){\r\n            InterfaceERC20(GWTB).transfer(msg.sender,value);\r\n        }\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(manager == msg.sender);\r\n        _;\r\n    }\r\n}"}}}