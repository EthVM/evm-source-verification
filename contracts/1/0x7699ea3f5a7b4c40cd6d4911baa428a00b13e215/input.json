{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NftFactory.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title ArtDeco Finance\r\n  *\r\n  * @notice ArtDeco NFT Factory: ERC-721 NFT token generated by user selfly  \r\n  * \r\n  */\r\n  \r\n/***\r\n* \r\n* MIT License\r\n* ===========\r\n* \r\n*  Copyright (c) 2020 ArtDeco\r\n* \r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\ninterface AnftToken {\r\n  function mint(address account, uint256 tokenId) external returns (bool);\r\n  function safeMint(address to, uint256 tokenId, bytes calldata _data) external returns (bool);\r\n  function ownerOf(uint256 tokenId) external returns (address owner);\r\n  function totalSupply() external view returns (uint256);\r\n}  \r\n\r\ninterface ApwrToken {\r\n  function mint(address account, uint256 amount) external;\r\n  function totalSupply() external returns (uint256);\r\n  function burnFrom(address account, uint256 _value) external;\r\n} \r\n\r\ninterface ArtdToken {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function mint(address account, uint256 amount) external;\r\n}\r\n\r\ninterface NFTFactory{\r\n    function getMeta( uint256 resId ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, address);\r\n    function getMeta2( uint256 nftId ) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256);\r\n    function getFactory( uint256 nftId ) external view returns (address);\r\n    function renewPromote( uint256 nftId, uint256 value ) external;\r\n    function renewAmount( uint256 nftId, uint256 value ) external;\r\n    function renewAPWR( uint256 nftId, uint256 value ) external;\r\n    function renewSKILL( uint256 nftId, uint256 value ) external;\r\n    function renewLocktime( uint256 nftId, uint256 value ) external;\r\n    function getAuthor( uint256 nftId ) external view returns (address);\r\n    function getcreatedTime( uint256 nftId ) external view returns (uint256);\r\n    function getLock( uint256 nftId ) external view returns (uint256);\r\n}\r\n\r\ninterface validfactory {\r\n  function isValidfactory( address _factory ) external view returns (bool);\r\n} \r\n\r\ninterface ArttToken {\r\n  function transferFrom(address src, address dst, uint rawAmount) external returns (bool);\r\n} \r\n\r\ninterface RandomSeed {\r\n  function random_getSeed( address sender, uint256 num ) external view returns (uint256);\r\n  function random_get9999( address sender, uint256 random ) external view returns (uint);\r\n  function random_get9999x( address sender, uint256 num ) external returns (uint);\r\n} \r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract nftMeta {\r\n\r\n     mapping(uint256 => uint256) internal _era;\r\n     mapping(uint256 => uint256) internal _grade;\r\n     mapping(uint256 => uint256) internal _promote;\r\n     mapping(uint256 => uint256) internal _artdamount;\r\n     mapping(uint256 => uint256) internal _apwramount;\r\n     mapping(uint256 => uint256) internal _skill;\r\n     mapping(uint256 => address) internal _factory;\r\n     \r\n     mapping(uint256 => address) internal _author;\r\n     mapping(uint256 => uint256) internal _createdTime;\r\n     mapping(uint256 => uint256) internal _lock;\r\n}    \r\n \r\n\r\n\r\ncontract NftFactory is  Ownable, nftMeta {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    uint256 private releaseDate;\r\n    \r\n    address public _artd =  address(0xA23F8462d90dbc60a06B9226206bFACdEAD2A26F);\r\n    address public _anft =  address(0x99a7e1188CE9a0b7514d084878DFb8A405D8529F);\r\n    address public _apwr = address(0xb60F072494c7f1b5a8ba46bc735C71A83D940D1A);\r\n    address public _artt = address(0x77dF79539083DCd4a8898dbA296d899aFef20067);\r\n    address public _fundpool = address(0x37C8fC383e037f92f501E5884B8B5E37e3f5170E);\r\n    \r\n    address public _validchecker = address(0x58F62d9B184BE5D7eE6881854DD16898Afe0cf90);\r\n    address private _randseed = address(0x75A7c0f3c7E59D0Aa323cc8832EaF2729Fe2127C);\r\n    \r\n    address public _relay = address(0);\r\n        \r\n    address public _burnPool = 0x6666666666666666666666666666666666666666;\r\n    \r\n    uint256 public _eraNFT = 1;   //  NEW Generration \r\n    uint256 private pwrdist = 0.01 * 1e18;  // APWR amount\r\n     \r\n    address[] public _allfactorylist;\r\n    uint256 public _storestartTime =  now + 365 days;\r\n    uint256 private nonce = 0;\r\n    uint256 private max_promote = 9999;\r\n    uint256 public constant _rateBase = 10000; \r\n    uint256 public _burnRate = 250;       \r\n    uint256 public _rewardRate = 250;\r\n    uint256 public _claimdays = 60 days;\r\n    \r\n    bytes _data = new bytes(0);\r\n    \r\n    mapping(uint256 => uint256) public _lastStoreTime;\r\n    mapping(uint256 => uint) private _allowchallenge;\r\n        \r\n    // Mapping from airdrop receiver to boolean \r\n    mapping (address => bool) public hasClaimed;\r\n\r\n    event TokenParameter(uint256 indexed resId, uint256 era, uint256 grade, uint256 promote, uint256 artdamount, uint256 apwramount,uint256 skill, address factory, address author, uint256 createdTime);\r\n    event DataParameter( bytes _data );\r\n    event Store(uint256 indexed Id, address user, uint256 amount);\r\n    event Withdraw(uint256 indexed Id, address user, uint256 amount);\r\n    event MetaUpdated(address addr, uint256 nftid, uint256 value);\r\n    event Fusion(uint256 nftId1, uint256 nftId2, uint256 value);\r\n    event Challenge(uint256 nftId, bool winlose, uint256 diffamount, uint256 finalamount);\r\n    event RaisePower(uint256 indexed Id, address user, uint256 amount);\r\n    event ADDSKILL(uint256 indexed Id, address user, uint256 amount);\r\n    event SwChallenge(uint256 nftId, bool onoff);\r\n    event LockTime(uint256 nftId, uint256 time);\r\n    event Grade1(address user, uint256 time, uint256 block);\r\n    event Grade2(address user, uint256 time, uint256 block);\r\n    event Grade3(address user, uint256 time, uint256 block);\r\n    event Grade4(address user, uint256 time, uint256 block);\r\n    event Grade5(address user, uint256 time, uint256 block);\r\n    event Grade6(address user, uint256 time, uint256 block);\r\n    \r\n    // Throws when msg.sender has already claimed the airdrop \r\n    modifier hasNotClaimed() {\r\n        require(hasClaimed[msg.sender] == false);\r\n        _;\r\n    }\r\n    \r\n    // Throws when the 30 day airdrop period has passed \r\n    modifier canClaim() {\r\n        require(releaseDate + _claimdays >= now);\r\n        _;\r\n    }\r\n\r\n    modifier checkstoreStart() {\r\n        require(block.timestamp > _storestartTime, \"store not start\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        // Set releaseDate\r\n        releaseDate = now;\r\n        _allfactorylist.push( address(this) );\r\n    }\r\n\r\n    function _random_get_seed( uint256 num ) internal view returns (uint256) {\r\n\r\n        RandomSeed _rc = RandomSeed(_randseed);\r\n        return _rc.random_getSeed(msg.sender,num);\r\n    }\r\n\r\n    function _randomGrade( uint random ) internal view returns (uint8) {\r\n\r\n        RandomSeed _rc = RandomSeed(_randseed);\r\n        uint256 num = _rc.random_get9999(msg.sender,random);   \r\n        \r\n        uint8 grade = 1;\r\n\r\n        if ( num >= 9995 ){   // 0.05 % \r\n            grade = 6;  \r\n        }   \r\n        else if ( num >= 9965 ){   // 0.30 %\r\n            grade = 5;  \r\n        }  \r\n        else if ( num >= 9800 ){   // 1.65 %\r\n            grade = 4;  \r\n        }  \r\n        else if ( num >= 9500 ){   // 3 %\r\n            grade = 3;  \r\n        }  \r\n        else if ( num >= 7000 ){  // 25 %\r\n            grade = 2;  \r\n        }  \r\n        return grade;        // 70%\r\n    }\r\n\r\n    function _randomGradeX() internal returns (uint8) \r\n    {\r\n        nonce = nonce + 1;\r\n        RandomSeed _rc = RandomSeed(_randseed);\r\n        uint256 num = _rc.random_get9999x(msg.sender,nonce);   \r\n        \r\n        uint8 grade = 1;\r\n\r\n        if ( num >= 9995 ){    \r\n            grade = 6;  \r\n        }   \r\n        else if ( num >= 9965 ){  \r\n            grade = 5;  \r\n        }  \r\n        else if ( num >= 9800 ){   \r\n            grade = 4;  \r\n        }  \r\n        else if ( num >= 9500 ){   \r\n            grade = 3;  \r\n        }  \r\n        else if ( num >= 7000 ){  \r\n            grade = 2;  \r\n        }  \r\n        return grade;        \r\n    }\r\n    \r\n    function _randomPromote() internal view returns (uint256) {\r\n\r\n        uint256 num = _random_get_seed( nonce ) % 1000;\r\n        \r\n        return num;\r\n    }\r\n\r\n    function setPower( uint256 newpwrdist ) external onlyOwner {\r\n        pwrdist = newpwrdist;\r\n    }\r\n\r\n    function setRate(uint256 burn_rate, uint256 reward_rate) external onlyOwner\r\n    {\r\n        _burnRate = burn_rate;\r\n        _rewardRate = reward_rate;\r\n    }    \r\n    \r\n    function setArtd( address artd ) external onlyOwner {\r\n        _artd = artd;\r\n    }\r\n    \r\n    function setAnft( address anft ) external onlyOwner {\r\n        _anft = anft;\r\n    }\r\n\r\n    function setApwr( address apwr ) external onlyOwner {\r\n        _apwr = apwr;\r\n    }\r\n\r\n    function setArtt( address artt ) external onlyOwner {\r\n        _artt = artt;\r\n    }\r\n    \r\n    function setFundPool( address fundpool ) external onlyOwner {\r\n       _fundpool = fundpool;\r\n    }\r\n    \r\n    function seteraNFT( uint256 era ) external onlyOwner {\r\n        _eraNFT = era;\r\n    }\r\n    \r\n    function setvalidchecker( address checker ) external onlyOwner {\r\n        _validchecker = checker;\r\n    }\r\n    \r\n    function setstoreStart( uint256 starttime ) external onlyOwner {\r\n        _storestartTime = starttime;\r\n    }\r\n\r\n    function setclaimDays( uint256 claimdays ) external onlyOwner {\r\n        _claimdays = claimdays;\r\n    }\r\n\r\n    function setranseed( address ranseed ) external onlyOwner {\r\n        _randseed = ranseed;\r\n    }\r\n\r\n    function getMeta_current( uint256 nftId ) internal view returns (uint256, uint256, uint256, uint256, uint256, uint256, address) \r\n    {\r\n       return ( _era[nftId], _grade[nftId], _promote[nftId], _artdamount[nftId], _apwramount[nftId], _skill[nftId], _factory[nftId]); \r\n    }\r\n\r\n    function getMeta( uint256 nftId ) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, address) \r\n    {    \r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            return getMeta_current(nftId);\r\n        }\r\n        else{\r\n            for (uint i = 0; i < _allfactorylist.length; i++) {\r\n               NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n               (uint256 t1,,,,,,) = _nftfactoryx.getMeta( nftId );  \r\n               if( t1 != 0){\r\n                    return _nftfactoryx.getMeta( nftId );  \r\n                }\r\n            }\r\n            return (0, 0, 0, 0, 0, 0, address(0) );\r\n        } \r\n    }  \r\n\r\n\r\n    function getMeta_current2( uint256 nftId ) internal view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) \r\n    {\r\n          return ( _era[nftId], _grade[nftId], _promote[nftId], _artdamount[nftId], _apwramount[nftId], _skill[nftId], _lock[nftId] );\r\n    }\r\n    \r\n    function getMeta2( uint256 nftId ) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) \r\n    {    \r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            return getMeta_current2(nftId);\r\n        }\r\n        else{\r\n            for (uint i = 0; i < _allfactorylist.length; i++) {\r\n               NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n               (uint256 t1,,,,,,) = _nftfactoryx.getMeta2( nftId );  \r\n               if( t1 != 0){\r\n                    return _nftfactoryx.getMeta2( nftId );  \r\n                }\r\n            }\r\n            return (0, 0, 0, 0, 0, 0, 0 );\r\n        } \r\n    }  \r\n    \r\n    function setlinkFactory( address[] calldata _factorylist ) external onlyOwner {\r\n        _allfactorylist = _factorylist;\r\n    }\r\n\r\n    function fusion( uint256 nftId1, uint256 nftId2 ) external\r\n    {\r\n        address owner1 = NFTownerOf(nftId1);\r\n        address owner2 = NFTownerOf(nftId2);\r\n        require(msg.sender == owner1 && msg.sender == owner2);\r\n        require(nftId1 != nftId2, \"TWO NFTs ID can not same\");\r\n        uint256 sum = 0;\r\n        owner1 = address(0);\r\n        owner2 = address(0);\r\n\r\n        uint256 pm1 = 0;\r\n        uint256 pm2 = 0;\r\n        uint256 grade1 = 0;\r\n        uint256 grade2 = 0;\r\n        uint256 locktime1 = 0;\r\n        uint256 locktime2 = 0;\r\n        pm1 = this.getPormote( nftId1 );\r\n        pm2 = this.getPormote( nftId2 );\r\n        grade1 = this.getGrade( nftId1 );\r\n        grade2 = this.getGrade( nftId2 );\r\n        \r\n        owner1 = this.getFactory(nftId1);\r\n        owner2 = this.getFactory(nftId2);\r\n        require(owner1 != address(0), \"NFT ID1 not found\");\r\n        require(owner2 != address(0), \"NFT ID2 not found\");\r\n\r\n        locktime1 = this.getLock(nftId1);\r\n        locktime2 = this.getLock(nftId2);\r\n        require(locktime1 < now && locktime2 < now, \"Wait for locktime\");\r\n        \r\n        if( pm1 > 0 && pm2 > 0 && grade1 >0 && grade2 >0 )\r\n        {\r\n             sum = pm1 + pm2;\r\n             if( sum > max_promote )\r\n                     sum = max_promote;\r\n             if( grade2 > grade1 )\r\n             {\r\n                 updatePromote(owner2,nftId2,owner1,nftId1,sum);     \r\n                 emit MetaUpdated(owner2,nftId2,sum);\r\n                 emit MetaUpdated(owner1,nftId1,0);\r\n             }\r\n             else{\r\n                 updatePromote(owner1,nftId1,owner2,nftId2,sum);     \r\n                 emit MetaUpdated(owner1,nftId1,sum);\r\n                 emit MetaUpdated(owner2,nftId2,0);\r\n             }\r\n             emit Fusion( nftId1, nftId2, sum);\r\n        }\r\n    }\r\n    \r\n    \r\n    function updatePromote( address factory1, uint256 nftId1, address factory2, uint256 nftId2, uint256 value )\r\n     private\r\n    {\r\n                if( nftId1 !=0 )\r\n                {\r\n                    NFTFactory f1 =  NFTFactory(factory1);\r\n                    f1.renewPromote( nftId1, value );\r\n                }\r\n                if( nftId2 !=0 )\r\n                {\r\n                    NFTFactory f2 =  NFTFactory(factory2);\r\n                    f2.renewPromote(  nftId2, 0 );\r\n                }\r\n    }\r\n    \r\n    function renewPromote( uint256 nftId, uint256 value ) external\r\n    {\r\n        validfactory _checker = validfactory(_validchecker);\r\n        require( _checker.isValidfactory(msg.sender)==true );\r\n        _promote[nftId] = value;\r\n    }\r\n\r\n    function updateAmount( address factory1, uint256 nftId1, uint256 value )\r\n     private\r\n    {\r\n                if( nftId1 !=0 )\r\n                {\r\n                    NFTFactory f1 =  NFTFactory(factory1);\r\n                    f1.renewAmount( nftId1, value );\r\n                }\r\n    }\r\n    \r\n    function renewAmount( uint256 nftId, uint256 value ) external\r\n    {\r\n        validfactory _checker = validfactory(_validchecker);\r\n        require( _checker.isValidfactory(msg.sender)==true );\r\n        _artdamount[nftId] = value;\r\n    }\r\n\r\n\r\n    function updateLocktime( address factory, uint256 nftId, uint256 value )\r\n     private\r\n    {\r\n                if( nftId !=0 )\r\n                {\r\n                    NFTFactory f1 =  NFTFactory(factory);\r\n                    f1.renewLocktime( nftId, value );\r\n                }\r\n    }\r\n    \r\n    function renewLocktime( uint256 nftId, uint256 value ) external\r\n    {\r\n        validfactory _checker = validfactory(_validchecker);\r\n        require( _checker.isValidfactory(msg.sender)==true );\r\n        _lock[nftId] = value;\r\n    }\r\n\r\n\r\n    function updateAPWR( address factory1, uint256 nftId1, uint256 value )\r\n     private\r\n    {\r\n                if( nftId1 !=0 )\r\n                {\r\n                    NFTFactory f1 =  NFTFactory(factory1);\r\n                    f1.renewAPWR( nftId1, value );\r\n                }\r\n    }\r\n    \r\n    function renewAPWR( uint256 nftId, uint256 value ) external\r\n    {\r\n        validfactory _checker = validfactory(_validchecker);\r\n        require( _checker.isValidfactory(msg.sender)==true );\r\n        _apwramount[nftId] = value;\r\n    }\r\n    \r\n    function updateSKILL( address factory1, uint256 nftId1, uint256 value )\r\n     private\r\n    {\r\n                if( nftId1 !=0 )\r\n                {\r\n                    NFTFactory f1 =  NFTFactory(factory1);\r\n                    f1.renewSKILL( nftId1, value );\r\n                }\r\n    }\r\n    \r\n    function renewSKILL( uint256 nftId, uint256 value ) external\r\n    {\r\n        validfactory _checker = validfactory(_validchecker);\r\n        require( _checker.isValidfactory(msg.sender)==true );\r\n        _skill[nftId] = value;\r\n    }\r\n\r\n    function lockNft( uint256 nftId ) external \r\n    {\r\n        uint256 locktime = 0;\r\n        address factory = NFTownerOf(nftId);\r\n        require(msg.sender == factory);\r\n\r\n        factory = this.getFactory(nftId);\r\n        locktime = now + 14 days;\r\n        updateLocktime( factory, nftId, locktime );\r\n\r\n        emit LockTime( nftId, locktime );\r\n    }\r\n    \r\n    \r\n    function isAllowChallenge(uint256 nftId) external view returns (bool)\r\n    {\r\n        if( _allowchallenge[nftId]==0 )\r\n           return false;\r\n        return true;\r\n    }\r\n    \r\n    function challengeSwitch( uint256 nftId, uint key) external \r\n    {\r\n        address owner = NFTownerOf(nftId);\r\n        require(msg.sender == owner);\r\n        _allowchallenge[nftId] = key;\r\n        if( key != 0 )\r\n            emit SwChallenge( nftId, true );\r\n        else\r\n            emit SwChallenge( nftId, false );\r\n    }\r\n\r\n    function randomChallenge( uint256 mynftId, uint256 targetId ) internal view returns (bool) \r\n    {\r\n        uint256 num = _random_get_seed( mynftId +  targetId + nonce ) % 10000;\r\n        if ( num >= 5000 )\r\n        { \r\n            if( _allowchallenge[mynftId] >= _allowchallenge[targetId])\r\n                return true;  \r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            if( _allowchallenge[mynftId] < _allowchallenge[targetId])\r\n                return true;  \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function challenge( uint256 mynftId, uint256 targetId) public\r\n    {\r\n        address owner1 = NFTownerOf(mynftId);\r\n        require(msg.sender == owner1);\r\n        address owner2 = NFTownerOf(targetId);\r\n        \r\n        require(owner1 != owner2, \"NFTID owner can not same\");\r\n        require(mynftId != targetId, \"TWO NFTs ID can not same\");\r\n        require(owner1 != address(0) && owner2 != address(0));\r\n        require(_allowchallenge[targetId] != 0, \"TargetId must turn-on switch\");\r\n        \r\n        uint256 myStore = this.currentStore(mynftId);\r\n        uint256 targetStore = this.currentStore(targetId);\r\n        uint256 left = 0;\r\n        uint256 diff_amount = 0;\r\n        uint256 final_amount = 0;\r\n        uint256 locktime1 = 0;\r\n        uint256 locktime2 = 0;       \r\n        \r\n        owner1 = this.getFactory(mynftId);\r\n        owner2 = this.getFactory(targetId);\r\n        require(owner1 != address(0), \"mynftId not found\");\r\n        require(owner2 != address(0), \"targetId not found\");\r\n    \r\n        locktime1 = this.getLock(mynftId);\r\n        locktime2 = this.getLock(targetId);\r\n        require(locktime1 < now && locktime2 < now, \"Wait for locktime\");\r\n\r\n        if( randomChallenge( mynftId, targetId ) == false)\r\n        {\r\n            left = myStore.mul(95).div(100);\r\n            diff_amount = myStore - left;\r\n            final_amount = diff_amount + targetStore; \r\n        \r\n            updateAmount(owner1, mynftId, left);\r\n            updateAmount(owner2, targetId, final_amount);\r\n            emit Challenge(mynftId, false, diff_amount, left);\r\n            emit Challenge(targetId, true, diff_amount, final_amount);\r\n        }\r\n        else\r\n        {\r\n            left = targetStore.mul(95).div(100);\r\n            diff_amount = targetStore - left;\r\n            final_amount = diff_amount + myStore; \r\n            \r\n            updateAmount(owner1, mynftId, final_amount);\r\n            updateAmount(owner2, targetId, left);\r\n            emit Challenge(mynftId, true, diff_amount, final_amount);\r\n            emit Challenge(targetId, false, diff_amount, left);\r\n        }\r\n        nonce = nonce + 1;\r\n    }\r\n\r\n\r\n\r\n    function getSkill( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        uint256 currentskill = 0;\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        \r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (,,,,,currentskill,) = getMeta_current(nftId);\r\n            return currentskill;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n           NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n           if( aa == 0 )\r\n           {\r\n               (,s1,,,,currentskill,) = _nftfactoryx.getMeta( nftId );  \r\n               if( s1 != 0){\r\n                    aa = s1;\r\n               }\r\n           }\r\n        }\r\n \r\n        return currentskill;\r\n    }\r\n\r\n    function getEra( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        uint256 era = 0;\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        \r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (era,,,,,,) = getMeta_current(nftId);\r\n            return era;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n                   NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n                   if( aa == 0 )\r\n                   {\r\n                       (era,s1,,,,,) = _nftfactoryx.getMeta( nftId );  \r\n                       if( s1 != 0){\r\n                            aa = s1;\r\n                       }\r\n                   }\r\n        }\r\n\r\n        return era;   \r\n    }\r\n\r\n    function getGrade( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        uint256 grade = 0;\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (,grade,,,,,) = getMeta_current(nftId);\r\n            return grade;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n                   NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n                   if( aa == 0 )\r\n                   {\r\n                       (,grade,,,,,) = _nftfactoryx.getMeta( nftId );  \r\n                       if( s1 != 0){\r\n                            aa = grade;\r\n                       }\r\n                   }\r\n        }\r\n           \r\n        return grade;   \r\n    }\r\n\r\n    function getPormote( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        uint256 promote = 0;\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (,,promote,,,,) = getMeta_current(nftId);\r\n            return promote;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n                   NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n                   if( aa == 0 )\r\n                   {\r\n                       (,s1,promote,,,,) = _nftfactoryx.getMeta( nftId );  \r\n                       if( s1 != 0){\r\n                            aa = s1;\r\n                       }\r\n                   }\r\n        }\r\n\r\n        return promote;   \r\n    }\r\n    \r\n    function getFactory( uint256 nftId ) external view returns (address)\r\n    {\r\n        address factory = address(0);\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (,,,,,,factory) = getMeta_current(nftId);\r\n            return factory;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n                   NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n                   if( aa == 0 )\r\n                   {\r\n                       (,s1,,,,,factory) = _nftfactoryx.getMeta( nftId );  \r\n                       if( s1 != 0){\r\n                            aa = s1;\r\n                       }\r\n                   }\r\n        }\r\n        \r\n        return factory;   \r\n    }    \r\n\r\n    function getPower( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        uint256 currentpower = 0;\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        \r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (,,,,currentpower,,) = getMeta_current(nftId);\r\n            return currentpower;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n           NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n           if( aa == 0 )\r\n           {\r\n               (,s1,,,currentpower,,) = _nftfactoryx.getMeta( nftId );  \r\n               if( s1 != 0){\r\n                    aa = s1;\r\n               }\r\n           }\r\n        }\r\n        return currentpower;\r\n    }\r\n\r\n    function getAuthor( uint256 nftId ) external view returns (address)\r\n    {\r\n        address factory = address(0);\r\n        factory = this.getFactory(nftId);\r\n        if( factory == address(this) )\r\n        {\r\n             return _author[nftId];\r\n        }\r\n        else{\r\n            NFTFactory f =  NFTFactory(factory);\r\n            return f.getAuthor(nftId);\r\n        }\r\n    }\r\n\r\n    function getLock( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        address factory = address(0);\r\n        factory = this.getFactory(nftId);\r\n        if( factory == address(this) )\r\n        {\r\n             return _lock[nftId];\r\n        }\r\n        else{\r\n            NFTFactory f =  NFTFactory(factory);\r\n            return f.getLock(nftId);\r\n        }\r\n    }\r\n    \r\n    function getcreatedTime( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        address factory = address(0);\r\n        factory = this.getFactory(nftId);\r\n        if( factory == address(this) )\r\n        {\r\n             return _createdTime[nftId];\r\n        }\r\n        else{\r\n            NFTFactory f =  NFTFactory(factory);\r\n            return f.getcreatedTime(nftId);\r\n        }        \r\n    }\r\n    \r\n    function AddSkill( uint256 ARTTamount, uint256 nftId )\r\n        public\r\n        checkstoreStart\r\n    {\r\n        address factory = address(0);\r\n        uint256 currentskill = 0;\r\n        uint256 exskill = 0;\r\n        uint256 locktime = 0;\r\n        \r\n        currentskill = this.getSkill( nftId );\r\n        factory = this.getFactory(nftId);\r\n        require(factory != address(0), \"NFT ID not found\");\r\n        require(ARTTamount > 0, \"Cannot burn 0 ARTT\");\r\n        \r\n        locktime = this.getLock(nftId);\r\n        require(locktime < now, \"Wait for locktime\");\r\n        \r\n        ArttToken _arttx =  ArttToken(_artt);\r\n        _arttx.transferFrom(msg.sender, address(_burnPool), ARTTamount);\r\n        \r\n        exskill = ARTTamount/uint256(1e18);\r\n        currentskill = currentskill.add(exskill);\r\n        \r\n        updateSKILL(factory, nftId, currentskill);\r\n        \r\n        emit ADDSKILL(nftId, msg.sender, ARTTamount);\r\n    }\r\n\r\n\r\n\r\n    function raisePower( uint256 APWRamount, uint256 nftId )\r\n        public\r\n        checkstoreStart\r\n    {\r\n        address factory = address(0);\r\n        uint256 currentpower = 0;\r\n        uint256 locktime = 0;\r\n        \r\n        currentpower = this.getPower( nftId );\r\n        factory = this.getFactory(nftId);\r\n        require(factory != address(0), \"NFT ID not found\");\r\n        require(APWRamount > 0, \"Cannot burn 0 APWR\");\r\n\r\n        locktime = this.getLock(nftId);\r\n        require(locktime < now, \"Wait for locktime\");\r\n        \r\n        ApwrToken _apwrx =  ApwrToken(_apwr);\r\n        _apwrx.burnFrom(msg.sender, APWRamount);\r\n        \r\n        currentpower = currentpower.add(APWRamount);\r\n        updateAPWR(factory, nftId, currentpower);\r\n        \r\n        emit RaisePower(nftId, msg.sender, APWRamount);\r\n    }\r\n    \r\n\r\n    function currentStore( uint256 nftId ) external view returns (uint256)\r\n    {\r\n        uint256 currentamount = 0;\r\n        uint256 aa = 0;\r\n        uint256 s1 = 0;\r\n        if( _grade[nftId] != 0 ) \r\n        {\r\n            (,,,currentamount,,,) = getMeta_current(nftId);\r\n            return currentamount;\r\n        }\r\n        for (uint i = 0; i < _allfactorylist.length; i++) {\r\n           NFTFactory _nftfactoryx =  NFTFactory(_allfactorylist[i]);\r\n           if( aa == 0 )\r\n           {\r\n               (,s1,,currentamount,,,) = _nftfactoryx.getMeta( nftId );  \r\n               if( s1 != 0){\r\n                    aa = s1;\r\n               }\r\n           }\r\n        }\r\n\r\n        return currentamount;\r\n    }\r\n\r\n\r\n    function store( uint256 amount, uint256 nftId )\r\n        public\r\n        checkstoreStart\r\n    {\r\n        uint256 locktime = 0;\r\n        address factory = address(0);\r\n        uint256 currentamount = 0;\r\n        currentamount = this.currentStore( nftId );\r\n        factory = this.getFactory(nftId);\r\n        require(factory != address(0), \"NFT ID not found\");\r\n        require(amount > 0, \"Cannot store 0\");\r\n        \r\n        locktime = this.getLock(nftId);\r\n        require(locktime < now, \"Wait for locktime\");\r\n        \r\n        /**\r\n         * @dev Check the owner of the NFT ID\r\n         */\r\n        // address owner = NFTownerOf(nftId);\r\n        // require(msg.sender == owner);\r\n\r\n        ArtdToken _artdx =  ArtdToken(_artd);\r\n        _artdx.transferFrom(msg.sender, address(_fundpool), amount);\r\n        \r\n        uint256 left_amount = calcSendamount(amount);\r\n        currentamount = currentamount.add(left_amount);\r\n        \r\n        updateAmount(factory, nftId, currentamount);\r\n        _lastStoreTime[nftId] = now;\r\n         \r\n        emit Store(nftId, msg.sender, left_amount);\r\n    }\r\n\r\n\r\n    function withdraw( uint256 amount, uint256 nftId )\r\n        public\r\n        checkstoreStart\r\n    {\r\n        uint256 locktime = 0;\r\n        address factory = address(0);\r\n        uint256 currentamount = 0;\r\n        currentamount = this.currentStore( nftId );\r\n        \r\n        factory = this.getFactory(nftId);\r\n        require(factory != address(0), \"NFT ID not found\");\r\n        address owner = NFTownerOf(nftId);\r\n        require(msg.sender == owner);\r\n        require(amount > 0 && currentamount >= amount, \"withdraw amount error\");\r\n\r\n        locktime = this.getLock(nftId);\r\n        require(locktime < now, \"Wait for locktime\");\r\n        \r\n        currentamount = currentamount.sub(amount);\r\n        updateAmount(factory, nftId, currentamount);\r\n        \r\n        ArtdToken _artdx =  ArtdToken(_artd);\r\n        _artdx.transferFrom(address(_fundpool), msg.sender, amount);\r\n\r\n        emit Withdraw(nftId, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the NFT ID\r\n     * @param nftId uint256 ID of the token to query the owner of\r\n     * @return owner address currently marked as the owner of the given NFT ID\r\n     */\r\n    function NFTownerOf(uint256 nftId) private returns (address) {\r\n        AnftToken _anftx =  AnftToken(_anft);\r\n        address owner = _anftx.ownerOf(nftId);\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n\r\n    function addresstoBytes(address x) internal pure returns (bytes memory b) \r\n    {\r\n         b = new bytes(32);\r\n         for (uint i = 0; i < 32; i++)\r\n            b[i] = byte(uint8(uint(x) / (2**(8*(31 - i)))));\r\n    }\r\n    \r\n    function toBytesEth(uint256 x) internal pure returns (bytes memory b) {\r\n        b = new bytes(32);\r\n        for (uint i = 0; i < 32; i++) {\r\n            b[i] = byte(uint8(x / (2**(8*(31 - i))))); \r\n        }\r\n    }\r\n\r\n    function bytesConcat_uint256( bytes memory source, uint256 _a ) internal pure returns (bytes memory) {\r\n             bytes memory _xbyte;\r\n             uint256 k = 0;\r\n             if( source.length == 0 ){\r\n                  _xbyte = toBytesEth(_a);\r\n                  return _xbyte;\r\n             }\r\n            _xbyte = toBytesEth(_a);\r\n            bytes memory ext_source = new bytes( source.length + _xbyte.length );\r\n            for (uint256 i = 0; i < source.length; i++) ext_source[k++] = source[i];\r\n            for (uint256 j = 0; j < _xbyte.length; j++) ext_source[k++] = _xbyte[j];\r\n            return ext_source;\r\n    }\r\n\r\n    function bytesConcat_address( bytes memory source, address _a ) internal pure returns (bytes memory) {\r\n             bytes memory _xbyte;\r\n             uint256 k = 0;\r\n             if( source.length == 0 ){\r\n                  _xbyte = addresstoBytes(_a);\r\n                  return _xbyte;\r\n             }\r\n            _xbyte = addresstoBytes(_a);\r\n            bytes memory ext_source = new bytes( source.length + _xbyte.length );\r\n            for (uint256 i = 0; i < source.length; i++) ext_source[k++] = source[i];\r\n            for (uint256 j = 0; j < _xbyte.length; j++) ext_source[k++] = _xbyte[j];\r\n            return ext_source;\r\n    }\r\n\r\n    function claim_process( uint32 random_grade) internal {\r\n        \r\n        nonce = nonce + 1;\r\n        uint256 id = 0; \r\n        \r\n        uint256 grade = random_grade;\r\n        uint256 promote =  _randomPromote();\r\n        uint256 artdAmount = 1000000000000000000;\r\n        uint256 apwrAmount = 0;\r\n        uint256 skill = 0;\r\n        uint256 createdTime = now;\r\n        address factory = address(this);\r\n        address author = msg.sender;\r\n\r\n        _data = new bytes(0);\r\n        if( grade >= 3 )\r\n        {\r\n            artdAmount = 0;\r\n        }\r\n\r\n        AnftToken _anftx =  AnftToken(_anft);\r\n        id = _anftx.totalSupply();\r\n        id = id + 1;\r\n        _anftx.safeMint(msg.sender, id, _data);\r\n        \r\n        _era[id] = _eraNFT;\r\n        _grade[id] = grade;\r\n        _promote[id] = promote;\r\n        _artdamount[id] = artdAmount;\r\n        _apwramount[id] = apwrAmount;\r\n        _skill[id] = skill;        \r\n        _factory[id] = factory;\r\n        _author[id] = author;\r\n        _createdTime[id] = createdTime;\r\n        _lock[id] = 0;\r\n     \r\n        emit TokenParameter(id, _eraNFT, grade, promote, artdAmount, apwrAmount, skill, factory, author, createdTime );\r\n        emit DataParameter(_data);\r\n        if ( grade == 6 )\r\n        { \r\n            emit Grade6( msg.sender, block.timestamp, block.number); \r\n        }\r\n        else if ( grade == 5 )\r\n        { \r\n            emit Grade5( msg.sender, block.timestamp, block.number); \r\n        }   \r\n        else if ( grade == 4 )\r\n        { \r\n            emit Grade4( msg.sender, block.timestamp, block.number); \r\n        }  \r\n        else if ( grade == 3 )\r\n        { \r\n            emit Grade3( msg.sender, block.timestamp, block.number); \r\n        }          \r\n        else if ( grade == 2 )\r\n        { \r\n            emit Grade2( msg.sender, block.timestamp, block.number); \r\n        }   \r\n        else if ( grade == 1 )\r\n        { \r\n            emit Grade1( msg.sender, block.timestamp, block.number); \r\n        }   \r\n        \r\n        \r\n        ApwrToken _apwrx = ApwrToken(_apwr);\r\n        _apwrx.mint (msg.sender, pwrdist );\r\n        \r\n        if( artdAmount > 0 )\r\n        {\r\n            ArtdToken _artdx =  ArtdToken(_artd);\r\n            _artdx.mint( address(_fundpool) , artdAmount ); \r\n        }     \r\n\r\n        // Set boolean for hasClaimed\r\n        hasClaimed[msg.sender] = true;\r\n    }\r\n\r\n    function claim() public hasNotClaimed canClaim {\r\n        uint32 random  = _randomGrade(0);\r\n        claim_process( random );\r\n    } \r\n\r\n    \r\n    function claimbynum( uint number ) public hasNotClaimed canClaim {\r\n        uint32 random  = _randomGrade(number);\r\n        claim_process( random );\r\n    } \r\n\r\n    function claimbyrelay() public //canClaim \r\n    {\r\n        require( msg.sender == _relay, \"Invalid caller\");\r\n        uint32 random  = _randomGradeX();\r\n        claim_process( random );\r\n    }\r\n\r\n    function calcSendamount(uint256 value) internal view returns (uint256)  \r\n    {\r\n        uint256 sendAmount = value;\r\n        uint256 burnFee = (value.mul(_burnRate)).div(_rateBase);\r\n        if (burnFee > 0) {\r\n           sendAmount = sendAmount.sub(burnFee);    \r\n        }\r\n        uint256 rewardFee = (value.mul(_rewardRate)).div(_rateBase);\r\n        if (rewardFee > 0) {\r\n           sendAmount = sendAmount.sub(rewardFee);    \r\n        }\r\n        return sendAmount;\r\n    }\r\n    \r\n            \r\n    function setRelay( address relay ) external onlyOwner\r\n    {\r\n        _relay = relay;\r\n    }\r\n\r\n}"}}}