{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RubiconMarket.sol":{"content":"/// @title RubiconMarket.sol\r\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon_protocol\r\n\r\npragma solidity 0.5.16;\r\n\r\n/// @notice DSAuth events for authentication schema\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority(address indexed authority);\r\n    event LogSetOwner(address indexed owner);\r\n}\r\n\r\n/// @notice DSAuth library for setting owner of the contract\r\n/// @dev Provides the auth modifier for authenticated function calls\r\ncontract DSAuth is DSAuthEvents {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_) external auth {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice DSMath library for safe math without integer overflow/underflow\r\ncontract DSMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint256 constant WAD = 10**18;\r\n    uint256 constant RAY = 10**27;\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice ERC-20 interface as derived from EIP-20\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address guy) public view returns (uint256);\r\n\r\n    function allowance(address src, address guy) public view returns (uint256);\r\n\r\n    function approve(address guy, uint256 wad) public returns (bool);\r\n\r\n    function transfer(address dst, uint256 wad) public returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 wad\r\n    ) public returns (bool);\r\n}\r\n\r\n/// @notice Events contract for logging trade activity on Rubicon Market\r\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\r\ncontract EventfulMarket {\r\n    event LogItemUpdate(uint256 id);\r\n    event LogTrade(\r\n        uint256 pay_amt,\r\n        address indexed pay_gem,\r\n        uint256 buy_amt,\r\n        address indexed buy_gem\r\n    );\r\n\r\n    event LogMake(\r\n        bytes32 indexed id,\r\n        bytes32 indexed pair,\r\n        address indexed maker,\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        uint128 pay_amt,\r\n        uint128 buy_amt,\r\n        uint64 timestamp\r\n    );\r\n\r\n    event LogBump(\r\n        bytes32 indexed id,\r\n        bytes32 indexed pair,\r\n        address indexed maker,\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        uint128 pay_amt,\r\n        uint128 buy_amt,\r\n        uint64 timestamp\r\n    );\r\n\r\n    event LogTake(\r\n        bytes32 id,\r\n        bytes32 indexed pair,\r\n        address indexed maker,\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        address indexed taker,\r\n        uint128 take_amt,\r\n        uint128 give_amt,\r\n        uint64 timestamp\r\n    );\r\n\r\n    event LogKill(\r\n        bytes32 indexed id,\r\n        bytes32 indexed pair,\r\n        address indexed maker,\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        uint128 pay_amt,\r\n        uint128 buy_amt,\r\n        uint64 timestamp\r\n    );\r\n\r\n    event LogInt(string lol, uint256 input);\r\n\r\n    event FeeTake(\r\n        bytes32 id,\r\n        bytes32 indexed pair,\r\n        address indexed maker,\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        address indexed taker,\r\n        uint128 take_amt,\r\n        uint128 give_amt,\r\n        uint256 feeAmt,\r\n        address feeTo,\r\n        uint64 timestamp\r\n    );\r\n}\r\n\r\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\r\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\r\ncontract SimpleMarket is EventfulMarket, DSMath {\r\n    uint256 public last_offer_id;\r\n\r\n    /// @dev The mapping that makes up the core orderbook of the exchange\r\n    mapping(uint256 => OfferInfo) public offers;\r\n\r\n    bool locked;\r\n\r\n    /// @notice This parameter provides the ability for a protocol fee on taker trades\r\n    /// @dev This parameter is in basis points\r\n    uint256 internal feeBPS;\r\n\r\n    /// @notice This parameter provides the address to which fees are sent\r\n    address internal feeTo;\r\n\r\n    struct OfferInfo {\r\n        uint256 pay_amt;\r\n        ERC20 pay_gem;\r\n        uint256 buy_amt;\r\n        ERC20 buy_gem;\r\n        address owner;\r\n        uint64 timestamp;\r\n    }\r\n\r\n    constructor(address _feeTo) public {\r\n        feeTo = _feeTo;\r\n\r\n        /// @notice The starting fee on taker trades in basis points\r\n        feeBPS = 20;\r\n    }\r\n\r\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\r\n    modifier can_buy(uint256 id) {\r\n        require(isActive(id));\r\n        _;\r\n    }\r\n\r\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\r\n    modifier can_cancel(uint256 id) {\r\n        require(isActive(id));\r\n        require(getOwner(id) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier can_offer {\r\n        _;\r\n    }\r\n\r\n    modifier synchronized {\r\n        require(!locked);\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function isActive(uint256 id) public view returns (bool active) {\r\n        return offers[id].timestamp > 0;\r\n    }\r\n\r\n    function getOwner(uint256 id) public view returns (address owner) {\r\n        return offers[id].owner;\r\n    }\r\n\r\n    function getOffer(uint256 id)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            ERC20,\r\n            uint256,\r\n            ERC20\r\n        )\r\n    {\r\n        OfferInfo memory offer = offers[id];\r\n        return (offer.pay_amt, offer.pay_gem, offer.buy_amt, offer.buy_gem);\r\n    }\r\n\r\n    /// @notice Below are the main public entrypoints\r\n\r\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\r\n        uint256 id = uint256(id_);\r\n        emit LogBump(\r\n            id_,\r\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\r\n            offers[id].owner,\r\n            offers[id].pay_gem,\r\n            offers[id].buy_gem,\r\n            uint128(offers[id].pay_amt),\r\n            uint128(offers[id].buy_amt),\r\n            offers[id].timestamp\r\n        );\r\n    }\r\n\r\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\r\n    /// @notice The fee for taker trades is paid in this function.\r\n    function buy(uint256 id, uint256 quantity)\r\n        public\r\n        can_buy(id)\r\n        synchronized\r\n        returns (bool)\r\n    {\r\n        OfferInfo memory offer = offers[id];\r\n        uint256 spend = mul(quantity, offer.buy_amt) / offer.pay_amt;\r\n\r\n        require(uint128(spend) == spend, \"spend is not an int\");\r\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\r\n\r\n        ///@dev For backwards semantic compatibility.\r\n        if (\r\n            quantity == 0 ||\r\n            spend == 0 ||\r\n            quantity > offer.pay_amt ||\r\n            spend > offer.buy_amt\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        ///@dev Below is the basis point math logic for calculating the fee on a given trade\r\n        ///@notice The fee is paid in the asset that the caller (taker) is market buying or selling with\r\n        uint256 fee = mul(spend, feeBPS) / 10000;\r\n        require(\r\n            offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\r\n            \"Insufficient funds to cover fee\"\r\n        );\r\n\r\n        offers[id].pay_amt = sub(offer.pay_amt, quantity);\r\n        offers[id].buy_amt = sub(offer.buy_amt, spend);\r\n        require(\r\n            offer.buy_gem.transferFrom(msg.sender, offer.owner, spend),\r\n            \"offer.buy_gem.transferFrom(msg.sender, offer.owner, spend) failed\"\r\n        );\r\n        require(\r\n            offer.pay_gem.transfer(msg.sender, quantity),\r\n            \"offer.pay_gem.transfer(msg.sender, quantity) failed\"\r\n        );\r\n\r\n        emit LogItemUpdate(id);\r\n        emit LogTake(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(offer.pay_gem, offer.buy_gem)),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            msg.sender,\r\n            uint128(quantity),\r\n            uint128(spend),\r\n            uint64(now)\r\n        );\r\n        emit FeeTake(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(offer.pay_gem, offer.buy_gem)),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            msg.sender,\r\n            uint128(quantity),\r\n            uint128(spend),\r\n            fee,\r\n            feeTo,\r\n            uint64(now)\r\n        );\r\n        emit LogTrade(\r\n            quantity,\r\n            address(offer.pay_gem),\r\n            spend,\r\n            address(offer.buy_gem)\r\n        );\r\n\r\n        if (offers[id].pay_amt == 0) {\r\n            delete offers[id];\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the caller to cancel the offer if it is their own.\r\n    /// @notice This function refunds the offer to the maker.\r\n    function cancel(uint256 id)\r\n        public\r\n        can_cancel(id)\r\n        synchronized\r\n        returns (bool success)\r\n    {\r\n        /// @dev This is a read-only offer. Modify an offer by directly accessing offers[id]\r\n        OfferInfo memory offer = offers[id];\r\n        delete offers[id];\r\n\r\n        require(offer.pay_gem.transfer(offer.owner, offer.pay_amt));\r\n\r\n        emit LogItemUpdate(id);\r\n        emit LogKill(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(offer.pay_gem, offer.buy_gem)),\r\n            offer.owner,\r\n            offer.pay_gem,\r\n            offer.buy_gem,\r\n            uint128(offer.pay_amt),\r\n            uint128(offer.buy_amt),\r\n            uint64(now)\r\n        );\r\n\r\n        success = true;\r\n    }\r\n\r\n    function kill(bytes32 id) external {\r\n        require(cancel(uint256(id)));\r\n    }\r\n\r\n    function make(\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        uint128 pay_amt,\r\n        uint128 buy_amt\r\n    ) external returns (bytes32 id) {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(\r\n        uint256 pay_amt,\r\n        ERC20 pay_gem,\r\n        uint256 buy_amt,\r\n        ERC20 buy_gem\r\n    ) public can_offer synchronized returns (uint256 id) {\r\n        require(uint128(pay_amt) == pay_amt);\r\n        require(uint128(buy_amt) == buy_amt);\r\n        require(pay_amt > 0);\r\n        require(pay_gem != ERC20(0x0));\r\n        require(buy_amt > 0);\r\n        require(buy_gem != ERC20(0x0));\r\n        require(pay_gem != buy_gem);\r\n\r\n        OfferInfo memory info;\r\n        info.pay_amt = pay_amt;\r\n        info.pay_gem = pay_gem;\r\n        info.buy_amt = buy_amt;\r\n        info.buy_gem = buy_gem;\r\n        info.owner = msg.sender;\r\n        info.timestamp = uint64(now);\r\n        id = _next_id();\r\n        offers[id] = info;\r\n\r\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\r\n\r\n        emit LogItemUpdate(id);\r\n        emit LogMake(\r\n            bytes32(id),\r\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\r\n            msg.sender,\r\n            pay_gem,\r\n            buy_gem,\r\n            uint128(pay_amt),\r\n            uint128(buy_amt),\r\n            uint64(now)\r\n        );\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount) external {\r\n        require(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function _next_id() internal returns (uint256) {\r\n        last_offer_id++;\r\n        return last_offer_id;\r\n    }\r\n\r\n    // Fee logic\r\n    function getFeeBPS() internal view returns (uint256) {\r\n        return feeBPS;\r\n    }\r\n}\r\n\r\n/// @notice Expiring market is a Simple Market with a market lifetime.\r\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\r\ncontract ExpiringMarket is DSAuth, SimpleMarket {\r\n    uint64 public close_time;\r\n    bool public stopped;\r\n\r\n    /// @dev After close_time has been reached, no new offers are allowed.\r\n    modifier can_offer {\r\n        require(!isClosed());\r\n        _;\r\n    }\r\n\r\n    /// @dev After close, no new buys are allowed.\r\n    modifier can_buy(uint256 id) {\r\n        require(isActive(id));\r\n        require(!isClosed());\r\n        _;\r\n    }\r\n\r\n    /// @dev After close, anyone can cancel an offer.\r\n    modifier can_cancel(uint256 id) {\r\n        require(isActive(id));\r\n        require((msg.sender == getOwner(id)) || isClosed());\r\n        _;\r\n    }\r\n\r\n    constructor(uint64 _close_time) public {\r\n        close_time = _close_time;\r\n    }\r\n\r\n    function isClosed() public view returns (bool closed) {\r\n        return stopped || getTime() > close_time;\r\n    }\r\n\r\n    function getTime() public view returns (uint64) {\r\n        return uint64(now);\r\n    }\r\n\r\n    function stop() external auth {\r\n        stopped = true;\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4 indexed sig,\r\n        address indexed guy,\r\n        bytes32 indexed foo,\r\n        bytes32 indexed bar,\r\n        uint256 wad,\r\n        bytes fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue\r\n        }\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MatchingEvents {\r\n    event LogBuyEnabled(bool isEnabled);\r\n    event LogMinSell(address pay_gem, uint256 min_amount);\r\n    event LogMatchingEnabled(bool isEnabled);\r\n    event LogUnsortedOffer(uint256 id);\r\n    event LogSortedOffer(uint256 id);\r\n    event LogInsert(address keeper, uint256 id);\r\n    event LogDelete(address keeper, uint256 id);\r\n}\r\n\r\n/// @notice The core Rubicon Market smart contract\r\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\r\n/// @dev This contract inherits the key trading functionality from SimpleMarket\r\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\r\n    bool public buyEnabled = true; //buy enabled\r\n    bool public matchingEnabled = true; //true: enable matching,\r\n    //false: revert to expiring market\r\n    struct sortInfo {\r\n        uint256 next; //points to id of next higher offer\r\n        uint256 prev; //points to id of previous lower offer\r\n        uint256 delb; //the blocknumber where this entry was marked for delete\r\n    }\r\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\r\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\r\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\r\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\r\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\r\n    uint256 _head; //first unsorted offer id\r\n    uint256 public dustId; // id of the latest offer marked as dust\r\n    address public AqueductAddress;\r\n    bool public AqueductDistributionLive;\r\n\r\n    /// @dev Below is Mainnet WETH Address\r\n    address public WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    constructor(\r\n        uint64 close_time,\r\n        bool RBCNDist,\r\n        address _feeTo\r\n    ) public ExpiringMarket(close_time) SimpleMarket(_feeTo) {\r\n        AqueductDistributionLive = RBCNDist;\r\n    }\r\n\r\n    // After close, anyone can cancel an offer\r\n    modifier can_cancel(uint256 id) {\r\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\r\n        require(\r\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\r\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ---- Public entrypoints ---- //\r\n\r\n    function make(\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        uint128 pay_amt,\r\n        uint128 buy_amt\r\n    ) public returns (bytes32) {\r\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\r\n    }\r\n\r\n    function take(bytes32 id, uint128 maxTakeAmount) public {\r\n        require(buy(uint256(id), maxTakeAmount));\r\n    }\r\n\r\n    function kill(bytes32 id) external {\r\n        require(cancel(uint256(id)));\r\n    }\r\n\r\n    // Routing function to make a trade where the user is sending Native ETH\r\n    function offerInETH(\r\n        uint256 buy_amt, //taker (ask) buy how much\r\n        ERC20 buy_gem //taker (ask) buy which token\r\n    ) external payable returns (uint256) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n\r\n        IWETH(WETHAddress).deposit.value(msg.value)();\r\n        IWETH(WETHAddress).transfer(msg.sender, msg.value);\r\n\r\n        ERC20 WETH = ERC20(WETHAddress);\r\n\r\n        if (matchingEnabled) {\r\n            return _matcho(msg.value, WETH, buy_amt, buy_gem, 0, true);\r\n        }\r\n        return super.offer(msg.value, WETH, buy_amt, buy_gem);\r\n    }\r\n\r\n    function buyInETH(uint256 id) external payable can_buy(id) returns (bool) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        ERC20 WETH = ERC20(WETHAddress);\r\n        require(offers[id].buy_gem == WETH, \"offer you buy must be in WETH\");\r\n        IWETH(WETHAddress).deposit.value(msg.value)();\r\n        IWETH(WETHAddress).transfer(msg.sender, msg.value);\r\n\r\n        super.buy(id, msg.value);\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    //\r\n    // If matching is enabled:\r\n    //     * creates new offer without putting it in\r\n    //       the sorted list.\r\n    //     * available to authorized contracts only!\r\n    //     * keepers should call insert(id,pos)\r\n    //       to put offer in the sorted list.\r\n    //\r\n    // If matching is disabled:\r\n    //     * calls expiring market's offer().\r\n    //     * available to everyone without authorization.\r\n    //     * no sorting is done.\r\n    //\r\n    function offer(\r\n        uint256 pay_amt, //maker (ask) sell how much\r\n        ERC20 pay_gem, //maker (ask) sell which token\r\n        uint256 buy_amt, //taker (ask) buy how much\r\n        ERC20 buy_gem //taker (ask) buy which token\r\n    ) public returns (uint256) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        function(uint256, ERC20, uint256, ERC20) returns (uint256) fn =\r\n            matchingEnabled ? _offeru : super.offer;\r\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\r\n    }\r\n\r\n    // Make a new offer. Takes funds from the caller into market escrow.\r\n    function offer(\r\n        uint256 pay_amt, //maker (ask) sell how much\r\n        ERC20 pay_gem, //maker (ask) sell which token\r\n        uint256 buy_amt, //maker (ask) buy how much\r\n        ERC20 buy_gem, //maker (ask) buy which token\r\n        uint256 pos //position to insert offer, 0 should be used if unknown\r\n    ) external can_offer returns (uint256) {\r\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\r\n    }\r\n\r\n    function offer(\r\n        uint256 pay_amt, //maker (ask) sell how much\r\n        ERC20 pay_gem, //maker (ask) sell which token\r\n        uint256 buy_amt, //maker (ask) buy how much\r\n        ERC20 buy_gem, //maker (ask) buy which token\r\n        uint256 pos, //position to insert offer, 0 should be used if unknown\r\n        bool matching //match \"close enough\" orders?\r\n    ) public can_offer returns (uint256) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        require(_dust[address(pay_gem)] <= pay_amt);\r\n\r\n        if (matchingEnabled) {\r\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\r\n        }\r\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\r\n    }\r\n\r\n    //Transfers funds from caller to offer maker, and from market to caller.\r\n    function buy(uint256 id, uint256 amount) public can_buy(id) returns (bool) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n\r\n        //RBCN distribution on the trade\r\n        if (AqueductDistributionLive) {\r\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\r\n                getOwner(id),\r\n                msg.sender\r\n            );\r\n        }\r\n        function(uint256, uint256) returns (bool) fn =\r\n            matchingEnabled ? _buys : super.buy; \r\n\r\n        return fn(id, amount);\r\n    }\r\n\r\n    // Cancel an offer. Refunds offer maker.\r\n    function cancel(uint256 id) public can_cancel(id) returns (bool success) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        if (matchingEnabled) {\r\n            if (isOfferSorted(id)) {\r\n                require(_unsort(id));\r\n            } else {\r\n                require(_hide(id));\r\n            }\r\n        }\r\n        return super.cancel(id); //delete the offer.\r\n    }\r\n\r\n    //insert offer into the sorted list\r\n    //keepers need to use this function\r\n    function insert(\r\n        uint256 id, //maker (ask) id\r\n        uint256 pos //position to insert into\r\n    ) public returns (bool) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\r\n        require(isActive(id)); //make sure offers[id] is active\r\n\r\n        _hide(id); //remove offer from unsorted offers list\r\n        _sort(id, pos); //put offer into the sorted offers list\r\n        emit LogInsert(msg.sender, id);\r\n        return true;\r\n    }\r\n\r\n    //deletes _rank [id]\r\n    //  Function should be called by keepers.\r\n    function del_rank(uint256 id) external returns (bool) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        require(\r\n            !isActive(id) &&\r\n                _rank[id].delb != 0 &&\r\n                _rank[id].delb < block.number - 10\r\n        );\r\n        delete _rank[id];\r\n        emit LogDelete(msg.sender, id);\r\n        return true;\r\n    }\r\n\r\n    //set the minimum sell amount for a token\r\n    //    Function is used to avoid \"dust offers\" that have\r\n    //    very small amount of tokens to sell, and it would\r\n    //    cost more gas to accept the offer, than the value\r\n    //    of tokens received.\r\n    function setMinSell(\r\n        ERC20 pay_gem, //token to assign minimum sell amount to\r\n        uint256 dust //maker (ask) minimum sell amount\r\n    ) external auth note returns (bool) {\r\n        _dust[address(pay_gem)] = dust;\r\n        emit LogMinSell(address(pay_gem), dust);\r\n        return true;\r\n    }\r\n\r\n    //returns the minimum sell amount for an offer\r\n    function getMinSell(\r\n        ERC20 pay_gem //token for which minimum sell amount is queried\r\n    ) external view returns (uint256) {\r\n        return _dust[address(pay_gem)];\r\n    }\r\n\r\n    //set buy functionality enabled/disabled\r\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\r\n        buyEnabled = buyEnabled_;\r\n        emit LogBuyEnabled(buyEnabled);\r\n        return true;\r\n    }\r\n\r\n    //set matching enabled/disabled\r\n    //    If matchingEnabled true(default), then inserted offers are matched.\r\n    //    Except the ones inserted by contracts, because those end up\r\n    //    in the unsorted list of offers, that must be later sorted by\r\n    //    keepers using insert().\r\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\r\n    //    and matching is not done, and sorted lists are disabled.\r\n    function setMatchingEnabled(bool matchingEnabled_)\r\n        external\r\n        auth\r\n        returns (bool)\r\n    {\r\n        matchingEnabled = matchingEnabled_;\r\n        emit LogMatchingEnabled(matchingEnabled);\r\n        return true;\r\n    }\r\n\r\n    //return the best offer for a token pair\r\n    //      the best offer is the lowest one if it's an ask,\r\n    //      and highest one if it's a bid offer\r\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _best[address(sell_gem)][address(buy_gem)];\r\n    }\r\n\r\n    //return the next worse offer in the sorted list\r\n    //      the worse offer is the higher one if its an ask,\r\n    //      a lower one if its a bid offer,\r\n    //      and in both cases the newer one if they're equal.\r\n    function getWorseOffer(uint256 id) public view returns (uint256) {\r\n        return _rank[id].prev;\r\n    }\r\n\r\n    //return the next better offer in the sorted list\r\n    //      the better offer is in the lower priced one if its an ask,\r\n    //      the next higher priced one if its a bid offer\r\n    //      and in both cases the older one if they're equal.\r\n    function getBetterOffer(uint256 id) external view returns (uint256) {\r\n        return _rank[id].next;\r\n    }\r\n\r\n    //return the amount of better offers for a token pair\r\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _span[address(sell_gem)][address(buy_gem)];\r\n    }\r\n\r\n    //get the first unsorted offer that was inserted by a contract\r\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\r\n    //      Their offers get put in the unsorted list of offers.\r\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\r\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\r\n    function getFirstUnsortedOffer() public view returns (uint256) {\r\n        return _head;\r\n    }\r\n\r\n    //get the next unsorted offer\r\n    //      Can be used to cycle through all the unsorted offers.\r\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\r\n        return _near[id];\r\n    }\r\n\r\n    function isOfferSorted(uint256 id) public view returns (bool) {\r\n        return\r\n            _rank[id].next != 0 ||\r\n            _rank[id].prev != 0 ||\r\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\r\n            id;\r\n    }\r\n\r\n    function sellAllAmount(\r\n        ERC20 pay_gem,\r\n        uint256 pay_amt,\r\n        ERC20 buy_gem,\r\n        uint256 min_fill_amount\r\n    ) external returns (uint256 fill_amt) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        uint256 offerId;\r\n        while (pay_amt > 0) {\r\n            //while there is amount to sell\r\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\r\n            require(offerId != 0); //Fails if there are not more offers\r\n\r\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\r\n            if (\r\n                pay_amt * 1 ether <\r\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\r\n            ) {\r\n                break; //We consider that all amount is sold\r\n            }\r\n            if (pay_amt >= offers[offerId].buy_amt) {\r\n                //If amount to sell is higher or equal than current offer amount to buy\r\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\r\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\r\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\r\n            } else {\r\n                // if lower\r\n                uint256 baux =\r\n                    rmul(\r\n                        pay_amt * 10**9,\r\n                        rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\r\n                    ) / 10**9;\r\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\r\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\r\n                pay_amt = 0; //All amount is sold\r\n            }\r\n        }\r\n        require(fill_amt >= min_fill_amount);\r\n    }\r\n\r\n    function buyAllAmount(\r\n        ERC20 buy_gem,\r\n        uint256 buy_amt,\r\n        ERC20 pay_gem,\r\n        uint256 max_fill_amount\r\n    ) external returns (uint256 fill_amt) {\r\n        require(!locked, \"Reentrancy attempt\");\r\n        uint256 offerId;\r\n        while (buy_amt > 0) {\r\n            //Meanwhile there is amount to buy\r\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\r\n            require(offerId != 0);\r\n\r\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\r\n            if (\r\n                buy_amt * 1 ether <\r\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\r\n            ) {\r\n                break; //We consider that all amount is sold\r\n            }\r\n            if (buy_amt >= offers[offerId].pay_amt) {\r\n                //If amount to buy is higher or equal than current offer amount to sell\r\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\r\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\r\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\r\n            } else {\r\n                //if lower\r\n                fill_amt = add(\r\n                    fill_amt,\r\n                    rmul(\r\n                        buy_amt * 10**9,\r\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\r\n                    ) / 10**9\r\n                ); //Add amount sold to acumulator\r\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\r\n                buy_amt = 0; //All amount is bought\r\n            }\r\n        }\r\n        require(fill_amt <= max_fill_amount);\r\n    }\r\n\r\n    function getBuyAmount(\r\n        ERC20 buy_gem,\r\n        ERC20 pay_gem,\r\n        uint256 pay_amt\r\n    ) external view returns (uint256 fill_amt) {\r\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\r\n        while (pay_amt > offers[offerId].buy_amt) {\r\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\r\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\r\n            if (pay_amt > 0) {\r\n                //If we still need more offers\r\n                offerId = getWorseOffer(offerId); //We look for the next best offer\r\n                require(offerId != 0); //Fails if there are not enough offers to complete\r\n            }\r\n        }\r\n        fill_amt = add(\r\n            fill_amt,\r\n            rmul(\r\n                pay_amt * 10**9,\r\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\r\n            ) / 10**9\r\n        ); //Add proportional amount of last offer to buy accumulator\r\n    }\r\n\r\n    function getPayAmount(\r\n        ERC20 pay_gem,\r\n        ERC20 buy_gem,\r\n        uint256 buy_amt\r\n    ) external view returns (uint256 fill_amt) {\r\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\r\n        while (buy_amt > offers[offerId].pay_amt) {\r\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\r\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\r\n            if (buy_amt > 0) {\r\n                //If we still need more offers\r\n                offerId = getWorseOffer(offerId); //We look for the next best offer\r\n                require(offerId != 0); //Fails if there are not enough offers to complete\r\n            }\r\n        }\r\n        fill_amt = add(\r\n            fill_amt,\r\n            rmul(\r\n                buy_amt * 10**9,\r\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\r\n            ) / 10**9\r\n        ); //Add proportional amount of last offer to pay accumulator\r\n    }\r\n\r\n    // ---- Internal Functions ---- //\r\n\r\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\r\n        require(buyEnabled);\r\n        if (amount == offers[id].pay_amt) {\r\n            if (isOfferSorted(id)) {\r\n                //offers[id] must be removed from sorted list because all of it is bought\r\n                _unsort(id);\r\n            } else {\r\n                _hide(id);\r\n            }\r\n        }\r\n\r\n        require(super.buy(id, amount));\r\n\r\n        // If offer has become dust during buy, we cancel it\r\n        if (\r\n            isActive(id) &&\r\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\r\n        ) {\r\n            dustId = id; //enable current msg.sender to call cancel(id)\r\n            cancel(id);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //find the id of the next higher offer after offers[id]\r\n    function _find(uint256 id) internal view returns (uint256) {\r\n        require(id > 0);\r\n\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        uint256 top = _best[pay_gem][buy_gem];\r\n        uint256 old_top = 0;\r\n\r\n        // Find the larger-than-id order whose successor is less-than-id.\r\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\r\n            old_top = top;\r\n            top = _rank[top].prev;\r\n        }\r\n        return old_top;\r\n    }\r\n\r\n    //find the id of the next higher offer after offers[id]\r\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\r\n        require(id > 0);\r\n\r\n        // Look for an active order.\r\n        while (pos != 0 && !isActive(pos)) {\r\n            pos = _rank[pos].prev;\r\n        }\r\n\r\n        if (pos == 0) {\r\n            //if we got to the end of list without a single active offer\r\n            return _find(id);\r\n        } else {\r\n            // if we did find a nearby active offer\r\n            // Walk the order book down from there...\r\n            if (_isPricedLtOrEq(id, pos)) {\r\n                uint256 old_pos;\r\n\r\n                // Guaranteed to run at least once because of\r\n                // the prior if statements.\r\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\r\n                    old_pos = pos;\r\n                    pos = _rank[pos].prev;\r\n                }\r\n                return old_pos;\r\n\r\n                // ...or walk it up.\r\n            } else {\r\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\r\n                    pos = _rank[pos].next;\r\n                }\r\n                return pos;\r\n            }\r\n        }\r\n    }\r\n\r\n    //return true if offers[low] priced less than or equal to offers[high]\r\n    function _isPricedLtOrEq(\r\n        uint256 low, //lower priced offer's id\r\n        uint256 high //higher priced offer's id\r\n    ) internal view returns (bool) {\r\n        return\r\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\r\n            mul(offers[high].buy_amt, offers[low].pay_amt);\r\n    }\r\n\r\n    //these variables are global only because of solidity local variable limit\r\n\r\n    //match offers with taker offer, and execute token transactions\r\n    function _matcho(\r\n        uint256 t_pay_amt, //taker sell how much\r\n        ERC20 t_pay_gem, //taker sell which token\r\n        uint256 t_buy_amt, //taker buy how much\r\n        ERC20 t_buy_gem, //taker buy which token\r\n        uint256 pos, //position id\r\n        bool rounding //match \"close enough\" orders?\r\n    ) internal returns (uint256 id) {\r\n        uint256 best_maker_id; //highest maker id\r\n        uint256 t_buy_amt_old; //taker buy how much saved\r\n        uint256 m_buy_amt; //maker offer wants to buy this much token\r\n        uint256 m_pay_amt; //maker offer wants to sell this much token\r\n\r\n        // there is at least one offer stored for token pair\r\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\r\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\r\n            m_buy_amt = offers[best_maker_id].buy_amt;\r\n            m_pay_amt = offers[best_maker_id].pay_amt;\r\n\r\n            // Ugly hack to work around rounding errors. Based on the idea that\r\n            // the furthest the amounts can stray from their \"true\" values is 1.\r\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\r\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\r\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\r\n            // c * d > a * b + a + b + c + d, we write...\r\n            if (\r\n                mul(m_buy_amt, t_buy_amt) >\r\n                mul(t_pay_amt, m_pay_amt) +\r\n                    (\r\n                        rounding\r\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\r\n                            : 0\r\n                    )\r\n            ) {\r\n                break;\r\n            }\r\n            // ^ The `rounding` parameter is a compromise borne of a couple days\r\n            // of discussion.\r\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\r\n            t_buy_amt_old = t_buy_amt;\r\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\r\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\r\n\r\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (\r\n            t_buy_amt > 0 &&\r\n            t_pay_amt > 0 &&\r\n            t_pay_amt >= _dust[address(t_pay_gem)]\r\n        ) {\r\n            //new offer should be created\r\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\r\n            //insert offer into the sorted list\r\n            _sort(id, pos);\r\n        }\r\n    }\r\n\r\n    // Make a new offer without putting it in the sorted list.\r\n    // Takes funds from the caller into market escrow.\r\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\r\n    function _offeru(\r\n        uint256 pay_amt, //maker (ask) sell how much\r\n        ERC20 pay_gem, //maker (ask) sell which token\r\n        uint256 buy_amt, //maker (ask) buy how much\r\n        ERC20 buy_gem //maker (ask) buy which token\r\n    ) internal returns (uint256 id) {\r\n        require(_dust[address(pay_gem)] <= pay_amt);\r\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\r\n        _near[id] = _head;\r\n        _head = id;\r\n        emit LogUnsortedOffer(id);\r\n    }\r\n\r\n    //put offer into the sorted list\r\n    function _sort(\r\n        uint256 id, //maker (ask) id\r\n        uint256 pos //position to insert into\r\n    ) internal {\r\n        require(isActive(id));\r\n\r\n        ERC20 buy_gem = offers[id].buy_gem;\r\n        ERC20 pay_gem = offers[id].pay_gem;\r\n        uint256 prev_id; //maker (ask) id\r\n\r\n        pos = pos == 0 ||\r\n            offers[pos].pay_gem != pay_gem ||\r\n            offers[pos].buy_gem != buy_gem ||\r\n            !isOfferSorted(pos)\r\n            ? _find(id)\r\n            : _findpos(id, pos);\r\n\r\n        if (pos != 0) {\r\n            //offers[id] is not the highest offer\r\n            //requirement below is satisfied by statements above\r\n            //require(_isPricedLtOrEq(id, pos));\r\n            prev_id = _rank[pos].prev;\r\n            _rank[pos].prev = id;\r\n            _rank[id].next = pos;\r\n        } else {\r\n            //offers[id] is the highest offer\r\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\r\n            _best[address(pay_gem)][address(buy_gem)] = id;\r\n        }\r\n\r\n        if (prev_id != 0) {\r\n            //if lower offer does exist\r\n            //requirement below is satisfied by statements above\r\n            //require(!_isPricedLtOrEq(id, prev_id));\r\n            _rank[prev_id].next = id;\r\n            _rank[id].prev = prev_id;\r\n        }\r\n\r\n        _span[address(pay_gem)][address(buy_gem)]++;\r\n        emit LogSortedOffer(id);\r\n    }\r\n\r\n    // Remove offer from the sorted list (does not cancel offer)\r\n    function _unsort(\r\n        uint256 id //id of maker (ask) offer to remove from sorted list\r\n    ) internal returns (bool) {\r\n        address buy_gem = address(offers[id].buy_gem);\r\n        address pay_gem = address(offers[id].pay_gem);\r\n        require(_span[pay_gem][buy_gem] > 0);\r\n\r\n        require(\r\n            _rank[id].delb == 0 && //assert id is in the sorted list\r\n                isOfferSorted(id)\r\n        );\r\n\r\n        if (id != _best[pay_gem][buy_gem]) {\r\n            // offers[id] is not the highest offer\r\n            require(_rank[_rank[id].next].prev == id);\r\n            _rank[_rank[id].next].prev = _rank[id].prev;\r\n        } else {\r\n            //offers[id] is the highest offer\r\n            _best[pay_gem][buy_gem] = _rank[id].prev;\r\n        }\r\n\r\n        if (_rank[id].prev != 0) {\r\n            //offers[id] is not the lowest offer\r\n            require(_rank[_rank[id].prev].next == id);\r\n            _rank[_rank[id].prev].next = _rank[id].next;\r\n        }\r\n\r\n        _span[pay_gem][buy_gem]--;\r\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\r\n        return true;\r\n    }\r\n\r\n    //Hide offer from the unsorted order book (does not cancel offer)\r\n    function _hide(\r\n        uint256 id //id of maker offer to remove from unsorted list\r\n    ) internal returns (bool) {\r\n        uint256 uid = _head; //id of an offer in unsorted offers list\r\n        uint256 pre = uid; //id of previous offer in unsorted offers list\r\n\r\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\r\n\r\n        if (_head == id) {\r\n            //check if offer is first offer in unsorted offers list\r\n            _head = _near[id]; //set head to new first unsorted offer\r\n            _near[id] = 0; //delete order from unsorted order list\r\n            return true;\r\n        }\r\n        while (uid > 0 && uid != id) {\r\n            //find offer in unsorted order list\r\n            pre = uid;\r\n            uid = _near[uid];\r\n        }\r\n        if (uid != id) {\r\n            //did not find offer id in unsorted offers list\r\n            return false;\r\n        }\r\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\r\n        _near[id] = 0; //delete order from unsorted order list\r\n        return true;\r\n    }\r\n\r\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\r\n        feeBPS = _newFeeBPS;\r\n        return true;\r\n    }\r\n\r\n    function setAqueductDistributionLive(bool live)\r\n        external\r\n        auth\r\n        returns (bool)\r\n    {\r\n        AqueductDistributionLive = live;\r\n        return true;\r\n    }\r\n\r\n    function setAqueductAddress(address _Aqueduct)\r\n        external\r\n        auth\r\n        returns (bool)\r\n    {\r\n        AqueductAddress = _Aqueduct;\r\n        return true;\r\n    }\r\n\r\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\r\n        feeTo = newFeeTo;\r\n        return true;\r\n    }\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function approve(address guy, uint256 wad) external returns (bool);\r\n}\r\n\r\ninterface IAqueduct {\r\n    function distributeToMakerAndTaker(address maker, address taker)\r\n        external\r\n        returns (bool);\r\n}"}}}