{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/WasabiQuery.sol": {
      "content": "// Dependency file: contracts/interface/IERC20.sol\n\n//SPDX-License-Identifier: MIT\n// pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n\n// Dependency file: contracts/interface/IWasabi.sol\n\n//SPDX-License-Identifier: MIT\n// pragma solidity >=0.5.0;\n\ninterface IWasabi {\n    function getOffer(address  _lpToken,  uint index) external view returns (address offer);\n    function getOfferLength(address _lpToken) external view returns (uint length);\n    function pool(address _token) external view returns (uint);\n    function increaseProductivity(uint amount) external;\n    function decreaseProductivity(uint amount) external;\n    function decreaseProductivityAll() external;\n    function tokenAddress() external view returns(address);\n    function addTakerOffer(address _offer, address _user) external returns (uint);\n    function getUserOffer(address _user, uint _index) external view returns (address);\n    function getUserOffersLength(address _user) external view returns (uint length);\n    function getTakerOffer(address _user, uint _index) external view returns (address);\n    function getTakerOffersLength(address _user) external view returns (uint length);\n    function offerStatus() external view returns(uint amountIn, address masterChef, uint sushiPid);\n    function cancel(address _from, address _sushi, uint amountWasabi) external ;\n    function take(address taker,uint amountWasabi) external;\n    function payback(address _from) external;\n    function close(address _from, uint8 _state, address _sushi) external  returns (address tokenToOwner, address tokenToTaker, uint amountToOwner, uint amountToTaker);\n    function upgradeGovernance(address _newGovernor) external;\n    function acceptToken() external view returns(address);\n    function rewardAddress() external view returns(address);\n    function getTokensLength() external view returns (uint);\n    function tokens(uint _index) external view returns(address);\n    function offers(address _offer) external view returns(address tokenIn, address tokenOut, uint amountIn, uint amountOut, uint expire, uint interests, uint duration);\n    function getRateForOffer(address _offer) external view returns (uint offerFeeRate, uint offerInterestrate);\n}\n\n\n// Dependency file: contracts/interface/IWasabiOffer.sol\n\n//SPDX-License-Identifier: MIT\n// pragma solidity >=0.5.0;\n\ninterface IWasabiOffer {\n    function tokenIn() external view returns (address);\n    function tokenOut() external view returns (address);\n    function amountIn() external view returns (uint);\n    function amountOut() external view returns (uint);\n    function expire() external view returns (uint);\n    function interests() external view returns (uint);\n    function duration() external view returns (uint);\n    function owner() external view returns (address);\n    function taker() external view returns (address);\n    function state() external view returns (uint);\n    function pool() external view returns (address);\n    function getEstimatedWasabi() external view returns(uint amount);\n    function getEstimatedSushi() external view returns(uint amount);\n}\n\n\n// Root file: contracts/WasabiQuery.sol\n\n//SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity >=0.6.6;\n\n// import 'contracts/interface/IERC20.sol';\n// import 'contracts/interface/IWasabi.sol';\n// import 'contracts/interface/IWasabiOffer.sol';\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ncontract WasabiQuery {\n    address public WETH;\n    address public wasabi;\n    address public owner;\n    bool public hasTokenValue;\n    enum OfferState { Created, Opened, Taken, Paidback, Expired, Closed }\n\n    struct OfferData {\n        address tokenIn;\n        address tokenOut;\n        uint amountIn;\n        uint amountOut;\n        uint expire;\n        uint interests;\n        uint duration;\n        uint state;\n        uint feeRate;\n        uint interestrate;\n        uint wasabiReward;\n        uint sushiReward;\n        address owner;\n        address taker;\n        uint8 tokenInDecimals;\n        uint8 tokenOutDecimals;\n        uint tokenInTotalSupply;\n        uint tokenInEthValue;\n    }\n\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function initialize(address _wasabi, address _weth, bool _hasTokenValue) public onlyOwner {\n        wasabi = _wasabi;\n        WETH = _weth;\n        hasTokenValue = _hasTokenValue;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\n        emit OwnerChanged(owner, _newOwner);\n        owner = _newOwner;\n    }\n \n    function iterateOffers(address _token, uint _start, uint _end) public view returns (address[] memory) {\n        if (_start > _end) return iterateReverseOffers(_token, _start, _end);\n\n        uint count = IWasabi(wasabi).getOfferLength(_token);\n        if (_end >= count) _end = count;\n        require(_start <= _end && _start >= 0 && _end >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](_end-_start);\n        uint index = 0;\n        for (uint i = _start; i < _end; i++) {\n            res[index] = IWasabi(wasabi).getOffer(_token, i);\n            index++;\n        }\n        return res;\n    }\n\n    function iterateReverseOffers(address _token, uint _start, uint _end) public view returns (address[] memory) {\n        uint count = IWasabi(wasabi).getOfferLength(_token);\n        if (_start >= count) _start = count;\n        require(_end <= _start && _end >= 0 && _start >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](_start-_end);\n        if (_end == _start) return res;\n        uint index = 0;\n        uint len = 0;\n        for (uint i = _start-1; i >= _end; i--) {\n            res[index] = IWasabi(wasabi).getOffer(_token, i);\n            index++;\n            len++;\n            if (len>=_start - _end) break;\n        }\n        return res;\n    }\n\n    function iterateUserOffers(uint _start, uint _end) public view returns (address[] memory) {\n        if (_start > _end) return iterateReverseUserOffers(_start, _end);\n\n        uint count = IWasabi(wasabi).getUserOffersLength(msg.sender);\n        if (_end >= count) _end = count;\n        require(_start <= _end && _start >= 0 && _end >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](_end-_start);\n        uint index = 0;\n        for (uint i = _start; i < _end; i++) {\n            res[index] = IWasabi(wasabi).getUserOffer(msg.sender, i);\n            index++;\n        }\n        return res;\n    }\n\n    function iterateReverseUserOffers(uint _start, uint _end) public view returns (address[] memory) {\n        uint count = IWasabi(wasabi).getUserOffersLength(msg.sender);\n        if (_start >= count) _start = count;\n        require(_end <= _start && _end >= 0 && _start >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](_start-_end);\n        if (_end == _start) return res;\n        uint index = 0;\n        uint len = 0;\n        for (uint i = _start-1; i >= _end; i--) {\n            res[index] = IWasabi(wasabi).getUserOffer(msg.sender, i);\n            index++;\n            len++;\n            if (len>=_start - _end) break;\n        }\n        return res;\n    }\n\n    function iterateTakerOffers(uint _start, uint _end) public view returns (address[] memory) {\n        if (_start > _end) return iterateReverseTakerOffers(_start, _end);\n\n        uint count = IWasabi(wasabi).getTakerOffersLength(msg.sender);\n        if (_end >= count) _end = count;\n        require(_start <= _end && _start >= 0 && _end >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](count);\n        uint index = 0;\n        for (uint i = _start; i < _end; i++) {\n            res[index] = IWasabi(wasabi).getTakerOffer(msg.sender, i);\n            index++;\n        }\n        return res;\n    }\n\n    function iterateReverseTakerOffers(uint _start, uint _end) public view returns (address[] memory) {\n        uint count = IWasabi(wasabi).getTakerOffersLength(msg.sender);\n        if (_start >= count) _start = count;\n        require(_end <= _start && _end >= 0 && _start >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](_start-_end);\n        if (_end == _start) return res;\n        uint index = 0;\n        uint len = 0;\n        for (uint i = _start-1; i >= _end; i--) {\n            res[index] = IWasabi(wasabi).getTakerOffer(msg.sender, i);\n            index++;\n            len++;\n            if (len>=_start - _end) break;\n        }\n        return res;\n    }\n\n    function getOfferInfo(address _offer) external view returns (OfferData memory offer) {\n        (\n            offer.tokenIn,\n            offer.tokenOut,\n            offer.amountIn,\n            offer.amountOut,\n            offer.expire,\n            offer.interests,\n            offer.duration\n        ) = IWasabi(wasabi).offers(_offer);\n\n        (offer.feeRate, offer.interestrate) = IWasabi(wasabi).getRateForOffer(_offer);\n        offer.state = IWasabiOffer(_offer).state();\n        if (offer.state == uint(OfferState.Taken) && block.number >= offer.expire) {\n            offer.state = uint(OfferState.Expired);\n        }\n        offer.owner = IWasabiOffer(_offer).owner();\n        offer.taker = IWasabiOffer(_offer).taker();\n\n        offer.wasabiReward = IWasabiOffer(_offer).getEstimatedWasabi();\n        offer.sushiReward = IWasabiOffer(_offer).getEstimatedSushi();\n\n        offer.tokenInDecimals = uint8(IERC20(offer.tokenIn).decimals());\n        offer.tokenOutDecimals = uint8(IERC20(offer.tokenOut).decimals());\n\n        (offer.tokenInTotalSupply, offer.tokenInEthValue) = getTokenValue(offer.tokenIn);\n    }\n\n    function iterateTokens(uint _start, uint _end) external view returns (address[] memory) {\n        uint count = IWasabi(wasabi).getTokensLength();\n        if (_end >= count) _end = count;\n        require(_start <= _end && _start >= 0 && _end >= 0, \"INVAID_PARAMTERS\");\n        address[] memory res = new address[](_end-_start);\n        uint index = 0;\n        for (uint i = _start; i < _end; i++) {\n            res[index] = IWasabi(wasabi).tokens(i);\n            index++;\n        }\n        return res;\n    }\n\n    function getChainId() public pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n\n    function getTokenValue(address _token) public view returns (uint totalSupply, uint ethValue) {\n        if (!hasTokenValue) {\n            return (0, 0);\n        }\n\n        totalSupply = IERC20(_token).totalSupply();\n        (uint reserve0, uint reserve1, ) = IUniswapV2Pair(_token).getReserves();\n        if (IUniswapV2Pair(_token).token0() == WETH) {\n            ethValue = reserve0 * 2;\n        } else if (IUniswapV2Pair(_token).token1() == WETH) {\n            ethValue = reserve1 * 2;\n        } else {\n            ethValue = 0;\n        }\n    }\n}\n"
    }
  }
}