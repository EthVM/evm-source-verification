{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DIEDED_MASTERPIECE.sol":{"content":"// File: contracts/erc721.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\ninterface ERC721\r\n{\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  constructor()  {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  \r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/erc721-token-receiver.sol\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n\r\n// File: contracts/erc165.sol\r\n\r\ninterface ERC165\r\n{\r\n\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n    \r\n}\r\n\r\n// File: contracts/supports-interface.sol\r\n\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/address-utils.sol\r\n\r\nlibrary AddressUtils\r\n{\r\n\r\n\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/nf-token.sol\r\n\r\ninterface BaseInterface{\r\n    function isEligibleToFutureMints(address who, uint256 _modulo) external view returns (bool);\r\n}\r\n\r\ncontract DIEDED_MASTERPIECE is\r\n  ERC721,\r\n  SupportsInterface,\r\n  Ownable\r\n{\r\n\r\n  using AddressUtils for address;\r\n\r\n  //Mainnet vs. testnet address\r\n  //Testnet is: 0x35EEB32Ed3A4741c6a731Ad9B6257f04f9C376D1\r\n  //Mainnet is: 0x7349d9324Fe190Ca96C7fC4EE4f1F3CBbb0d502a\r\n  //Usage baseDiededContract.isEligibleToFutureMints(msg.sender, ID_TO_BE_MINTED)\r\n\r\n  address ckAddress = 0x7349d9324Fe190Ca96C7fC4EE4f1F3CBbb0d502a;\r\n  BaseInterface baseDiededContract = BaseInterface(ckAddress);\r\n\r\n  uint256 public nextMintID;\r\n\r\n  string baseURI;\r\n  string _symbol;\r\n  string _name;\r\n\r\n  // Masterpiece cycle counter\r\n  // 1 cycle consist of 20 masterpieces\r\n  uint8 public cycleCounter;\r\n\r\n  address [] whitelisted;\r\n  \r\n  bool public isMintWindowOpen;\r\n\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  mapping (address => uint256) internal ownerToNFTokenCount;\r\n\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  //Each ID belongs to which masterpiece basically\r\n  mapping (uint256 => uint256) internal idToType;\r\n  //Each masterpieceMintID shall contain less than 70 mints !\r\n  mapping (uint256 => uint8) internal mpieceToCount;\r\n\r\n  //Whitelisted addresses\r\n  mapping(address => uint8) internal whitelistedClaimed;\r\n\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      \"003003\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      \"003004\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), \"003002\");\r\n    _;\r\n  }\r\n\r\n  function addToWhitelistArray(address[] memory _whitelisted) public onlyOwner {\r\n    for (uint8 i=0; i<_whitelisted.length; i++)\r\n    {\r\n        whitelisted.push(_whitelisted[i]);\r\n        whitelistedClaimed[_whitelisted[i]] = 10; //not claimed\r\n    }\r\n  }\r\n\r\n  constructor(address[] memory _whitelisted)\r\n  {\r\n    _name = \"DIEDED_MASTERPIECES\";\r\n    _symbol = \"DIEDEDMP\";\r\n    setBaseTokenURI(\"https://dieded.art/URIS_MP/\");\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n    isMintWindowOpen = true;\r\n    cycleCounter = 1;\r\n    nextMintID = 0;\r\n    for (uint8 i=0; i<_whitelisted.length; i++)\r\n    {\r\n        whitelisted.push(_whitelisted[i]);\r\n        whitelistedClaimed[_whitelisted[i]] = 10; //not claimed\r\n    }\r\n  }\r\n\r\n//On 'closing' we shall increment cycle counter\r\n  function openCloseMint(bool _status) public onlyOwner{\r\n      isMintWindowOpen = _status;\r\n      if(_status != false)\r\n      {\r\n        cycleCounter +=1;\r\n      }\r\n  }\r\n\r\n//Just in case needed\r\n  function adjustCycleCounter(uint8 _counter) public onlyOwner{\r\n      cycleCounter = _counter;\r\n  }\r\n\r\n  function setBaseTokenURI(string memory _baseURI) public onlyOwner{\r\n      baseURI = _baseURI;\r\n  }\r\n\r\n  function name() external view returns (string memory name_ret){\r\n      return _name;\r\n  }\r\n\r\n  function symbol() external view returns (string memory symbol_ret){\r\n      return _symbol;\r\n  }\r\n\r\n\r\n  function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\r\n    require(tokenId <= nextMintID, \"ERC721: URI query for nonexistent token\");\r\n    return string(abi.encodePacked(baseURI, uint2str(tokenId), \".json\"));\r\n  }\r\n\r\n  function isWhitelistedAndNotClaimedYet(address isWhitelistedAddr) public view returns (bool) {\r\n    bool result = false;\r\n    for (uint256 i=0; i<whitelisted.length; i++)\r\n    {\r\n        if( whitelisted[i] == isWhitelistedAddr && whitelistedClaimed[isWhitelistedAddr] == 10)\r\n        {\r\n          return true;\r\n        }\r\n    }\r\n    return result;\r\n  } \r\n\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(_to != address(0), \"003001\");\r\n    require(idToOwner[_tokenId] == address(0), \"003006\");\r\n\r\n    _addNFToken(_to, _tokenId);\r\n    nextMintID += 1;\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  function claim(uint256 masterpieceID, uint8 extra) external payable{\r\n    require(isMintWindowOpen && masterpieceID < (uint256(cycleCounter * 20) - 1) && masterpieceID >= (uint256((cycleCounter-1) * 20)), \"Mint window is not open\");\r\n    require(mpieceToCount[masterpieceID] < 70, \"The amount of mints/masterpiece would exceed the hard cap of 70!\");\r\n    \r\n    //Extra for whitelisted members costs : 0.01 ETH\r\n    //Extra for non-whitelisted memebrs: costs: 0.02 ETH\r\n\r\n    //Check free mints\r\n    bool freeClaim = false;\r\n    bool isfreeClaimFromMembership = false;\r\n    bool isfreeClaimFromWL = isWhitelistedAndNotClaimedYet(msg.sender);\r\n    if(!isfreeClaimFromWL){\r\n      isfreeClaimFromMembership = baseDiededContract.isEligibleToFutureMints(msg.sender, masterpieceID);\r\n      if(isfreeClaimFromMembership)\r\n      {\r\n        //So if anyone want he/she can mint the whole number up to 70\r\n        freeClaim = true;\r\n      }\r\n    }\r\n\r\n    //Setting freeClaim flag\r\n    if(isfreeClaimFromWL)\r\n    {\r\n      whitelistedClaimed[msg.sender] = 20; //claimed\r\n      freeClaim = true;\r\n    }\r\n\r\n    //If whitelisted and want an extra masterpiece it costs +0.01 ETH\r\n    if (freeClaim == true && extra > 0)\r\n    {\r\n        require(msg.value >= 0.01 ether, \"Claiming a masterpiece +1 extra costs 0.01 ETH for this address\");\r\n    }\r\n    \r\n    //If non-whitelisted and want an extra masterpiece it costs +0.02 ETH (and the original 0.03 ETH)\r\n    if( freeClaim == false && extra > 0 )\r\n    {\r\n        require(msg.value >= 0.05 ether, \"Claiming a masterpiece +1 extra costs 0.05 ETH for this address\"); \r\n    }\r\n    else if( freeClaim == false && extra == 0)\r\n    {\r\n        require(msg.value >= 0.03 ether, \"Claiming a masterpiece costs 0.03 ETH for this address\");\r\n    }\r\n\r\n    idToType[nextMintID] = masterpieceID;\r\n    mpieceToCount[masterpieceID] += 1;\r\n    _mint(msg.sender,nextMintID);\r\n\r\n    if( extra > 0 )\r\n    {\r\n      idToType[nextMintID] = masterpieceID;\r\n      mpieceToCount[masterpieceID] += 1;\r\n      _mint(msg.sender,nextMintID);\r\n    }\r\n  }\r\n\r\n  function viewMpieceType(uint256 tokenID) public view returns(uint256) {\r\n    return idToType[tokenID];\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, \"003007\");\r\n    require(_to != address(0), \"003001\");\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, \"003008\");\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), \"003001\");\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), \"003002\");\r\n  }\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, \"003007\");\r\n    ownerToNFTokenCount[_from] -= 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), \"003006\");\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] += 1;\r\n  }\r\n\r\n\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, \"003007\");\r\n    require(_to != address(0), \"003001\");\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, \"003005\");\r\n    }\r\n  }\r\n\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    delete idToApproval[_tokenId];\r\n  }\r\n\r\n  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n    if (_i == 0) {\r\n        return \"0\";\r\n    }\r\n    uint j = _i;\r\n    uint len;\r\n    while (j != 0) {\r\n        len++;\r\n        j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len;\r\n    while (_i != 0) {\r\n        k = k-1;\r\n        uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n        bytes1 b1 = bytes1(temp);\r\n        bstr[k] = b1;\r\n        _i /= 10;\r\n    }\r\n    return string(bstr);\r\n  }\r\n\r\n  function withdraw(address payable recipient) public onlyOwner {\r\n      uint256 balance = address(this).balance;\r\n      recipient.transfer(balance);\r\n  }\r\n\r\n}"}}}