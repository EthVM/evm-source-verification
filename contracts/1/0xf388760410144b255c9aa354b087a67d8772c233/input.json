{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/FixedMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport {ABDKMath64x64} from \"../util/ABDKMath64x64.sol\";\nimport {Base64} from \"../util/Base64.sol\";\nimport {Roots} from \"../util/Roots.sol\";\nimport {Strings} from \"../util/Strings.sol\";\n\ninterface IFixedMetadata {\n    function tokenMetadata(\n        uint256 tokenId,\n        uint256 rarity,\n        uint256 tokenMass,\n        uint256 alphaMass,\n        bool isAlpha,\n        uint256 mergeCount) external view returns (string memory);\n}\n\ncontract FixedMetadata is IFixedMetadata {\n\n    struct ERC721MetadataStructure {\n        bool isImageLinked;\n        string name;\n        string description;\n        string createdBy;\n        string image;\n        ERC721MetadataAttribute[] attributes;\n    }\n\n    struct ERC721MetadataAttribute {\n        bool includeDisplayType;\n        bool includeTraitType;\n        bool isValueAString;\n        string displayType;\n        string traitType;\n        string value;\n    }\n\n    using ABDKMath64x64 for int128;\n    using Base64 for string;\n    using Roots for uint;\n    using Strings for uint256;\n\n    address public owner;\n\n    string private _name;\n    string private _imageBaseURI;\n    string private _imageExtension;\n    uint256 private _maxRadius;\n    string[] private _imageParts;\n    mapping (string => string) private _classStyles;\n    mapping (string => string) private _spheres;\n    mapping (string => string) private _sphereDefs;\n\n    string constant private _RADIUS_TAG = '<RADIUS>';\n    string constant private _SPHERE_TAG = '<SPHERE>';\n    string constant private _SPHERE_DEFS_TAG = '<SPHERE_DEFS>';\n    string constant private _CLASS_TAG = '<CLASS>';\n    string constant private _CLASS_STYLE_TAG = '<CLASS_STYLE>';\n\n    constructor() {\n        owner = msg.sender;\n        _name = \"f\";\n        _imageBaseURI = \"\"; // Set to empty string - results in on-chain SVG generation by default unless this is set later\n        _imageExtension = \"\"; // Set to empty string - can be changed later to remain empty, .png, .mp4, etc\n        _maxRadius = 1000;\n\n        // Deploy with default SVG image parts - can be completely replaced later\n        _imageParts.push(\"<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='2000' height='2000'>\");\n        _imageParts.push(\"<style>\");\n        _imageParts.push(\".m1 #c{fill: #fff;}\");\n        _imageParts.push(\".m1 #r{fill: #000;}\");\n        _imageParts.push(\".m2 #c{fill: #fc3;}\");\n        _imageParts.push(\".m2 #r{fill: #000;}\");\n        _imageParts.push(\".m3 #c{fill: #fff;}\");\n        _imageParts.push(\".m3 #r{fill: #33f;}\");\n        _imageParts.push(\".m4 #c{fill: #fff;}\");\n        _imageParts.push(\".m4 #r{fill: #f33;}\");\n        _imageParts.push(\".a #c{fill: #000 !important;}\");\n        _imageParts.push(\".a #r{fill: #fff !important;}\");\n        _imageParts.push(\".s{transform:scale(calc(\");\n        _imageParts.push(_RADIUS_TAG);\n        _imageParts.push(\" / 1000));transform-origin:center}\");\n        _imageParts.push(_CLASS_STYLE_TAG);\n        _imageParts.push(\"</style>\");\n        _imageParts.push(\"<g class='\");\n        _imageParts.push(_CLASS_TAG);\n        _imageParts.push(\"'>\");\n        _imageParts.push(\"<rect id='r' width='2000' height='2000'/>\");\n        _imageParts.push(\"<circle id='c' cx='1000' cy='1000' r='\");\n        _imageParts.push(_RADIUS_TAG);\n        _imageParts.push(\"'/>\");\n        _imageParts.push(\"<g class='s'>\");\n        _imageParts.push(\"<svg width='2000' height='2000' viewBox='0 0 800 800' fill='none' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\");\n        _imageParts.push(_SPHERE_TAG);\n        _imageParts.push(\"<defs>\");\n        _imageParts.push(_SPHERE_DEFS_TAG);\n        _imageParts.push(\"<image id='i0' width='96' height='96' xlink:href='data:image/png;base64,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'/>\");\n        _imageParts.push(\"</defs></svg></g></g>\");\n        _imageParts.push(\"<defs></defs>\");\n        _imageParts.push(\"</svg>\");\n\n        \n        string memory defaultSphere = \"<circle cx='400' cy='400' r='400' fill='url(#pt0)'/> <g> <mask id='m0' style='mask-type:alpha' maskUnits='userSpaceOnUse' x='0' y='0' width='800' height='800'> <circle cx='400' cy='400' r='400' fill='url(#pt1)'/> </mask> <g mask='url(#m0)'> <rect x='-695.895' y='-297.542' width='1819.48' height='1854.64' transform='rotate(-13.0766 -695.895 -297.542)' fill='url(#p0)'/> </g> </g> <g style='mix-blend-mode:screen'> <circle cx='400' cy='400' r='400' fill='url(#pt2)'/> </g> <g style='mix-blend-mode:screen'> <circle cx='400' cy='400' r='400' fill='url(#pt3)'/> </g>\";\n        string memory alphaSphere = \"<circle cx='400' cy='400' r='400' fill='url(#pt0)'/> <g style='mix-blend-mode:screen'> <circle cx='400' cy='400' r='400' fill='url(#pt1)'/> </g> <g opacity='0.2'> <mask id='m0' style='mask-type:alpha' maskUnits='userSpaceOnUse' x='0' y='0' width='800' height='800'> <circle cx='400' cy='400' r='400' fill='url(#pt2)'/> </mask> <g mask='url(#m0)'> <rect x='-695.895' y='-297.543' width='1819.48' height='1854.64' transform='rotate(-13.0766 -695.895 -297.543)' fill='url(#pattern0)'/> </g> </g>\";\n\n        _spheres[\"a\"] = alphaSphere;\n        _spheres[\"1\"] = defaultSphere;\n        _spheres[\"2\"] = defaultSphere;\n        _spheres[\"3\"] = defaultSphere;\n        _spheres[\"4\"] = defaultSphere;\n\n        string memory defaultSphereDef = \"<pattern id='p0' patternContentUnits='objectBoundingBox' width='0.0325926' height='0.0325926'> <use xlink:href='#i0' transform='scale(0.0004)'/> </pattern> <radialGradient id='pt0' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#E1E1E1'/> <stop offset='1'/> </radialGradient> <radialGradient id='pt1' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#C4C4C4'/> <stop offset='1'/> </radialGradient> <radialGradient id='pt2' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='white'/> <stop offset='0.404291' stop-color='#A2A2A2'/> <stop offset='1'/> </radialGradient> <radialGradient id='pt3' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#F4F4F4'/> <stop offset='1'/> </radialGradient>\";\n        string memory alphaSphereDef = \"<pattern id='p0' patternContentUnits='objectBoundingBox' width='0.0325926' height='0.0325926'> <use xlink:href='#i0' transform='scale(0.0004)'/> </pattern> <radialGradient id='pt0' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#C4C4C4'/> <stop offset='0.197917'/> </radialGradient> <radialGradient id='pt1' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop offset='0.203125' stop-color='#C4C4C4' stop-opacity='0.9'/> <stop offset='0.723958'/> </radialGradient> <radialGradient id='pt2' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#C4C4C4'/> <stop offset='1'/> </radialGradient>\";\n        string memory yellowSphereDef = \"<pattern id='p0' patternContentUnits='objectBoundingBox' width='0.0325926' height='0.0325926'> <use xlink:href='#i0' transform='scale(0.0004)' opacity='0.25'/> </pattern> <radialGradient id='pt0' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#C4C4C4'/> <stop offset='0.197917' stop-color='#FFCC33'/> </radialGradient> <radialGradient id='pt1' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#C4C4C4'/> <stop offset='1' stop-color='#FFCC33'/> </radialGradient> <radialGradient id='pt2' cx='0' cy='0' r='1' gradientUnits='userSpaceOnUse' gradientTransform='translate(555.396 214.388) rotate(133.821) scale(691.992)'> <stop stop-color='#C4C4C4'/> <stop offset='1'/> </radialGradient>\";\n\n        _sphereDefs[\"a\"] = alphaSphereDef;\n        _sphereDefs[\"1\"] = defaultSphereDef;\n        _sphereDefs[\"2\"] = yellowSphereDef;\n        _sphereDefs[\"3\"] = defaultSphereDef;\n        _sphereDefs[\"4\"] = defaultSphereDef;\n\n    }\n\n    function setName(string calldata name_) external {\n        _requireOnlyOwner();\n        _name = name_;\n    }\n\n    function setImageBaseURI(string calldata imageBaseURI_, string calldata imageExtension_) external {\n        _requireOnlyOwner();\n        _imageBaseURI = imageBaseURI_;\n        _imageExtension = imageExtension_;\n    }\n\n    function setMaxRadius(uint256 maxRadius_) external {\n        _requireOnlyOwner();\n        _maxRadius = maxRadius_;\n    }\n\n    function tokenMetadata(uint256 tokenId, uint256 rarity, uint256 tokenMass, uint256 alphaMass, bool isAlpha, uint256 mergeCount) external view override returns (string memory) {\n        string memory base64Json = Base64.encode(bytes(string(abi.encodePacked(_getJson(tokenId, rarity, tokenMass, alphaMass, isAlpha, mergeCount)))));\n        return string(abi.encodePacked('data:application/json;base64,', base64Json));\n    }\n\n    function updateImageParts(string[] memory imageParts_) public {\n        _requireOnlyOwner();\n        _imageParts = imageParts_;\n    }\n\n    function pushToImageParts(string[] memory imageParts_) public {\n        _requireOnlyOwner();\n\n        for (uint i = 0; i < imageParts_.length; i++) {\n            _imageParts.push(imageParts_[i]);\n        }\n    }\n\n    function updateClassStyle(string calldata cssClass, string calldata cssStyle) external {\n        _requireOnlyOwner();\n        _classStyles[cssClass] = cssStyle;\n    }\n\n    function getClassStyle(string memory cssClass) public view returns (string memory) {\n        return _classStyles[cssClass];\n    }\n\n    function updateSphere(string calldata cssClass, string calldata cssStyle) external {\n        _requireOnlyOwner();\n        _spheres[cssClass] = cssStyle;\n    }\n\n    function getSphere(string memory cssClass) public view returns (string memory) {\n        return _spheres[cssClass];\n    }\n\n    function updateSphereDef(string calldata cssClass, string calldata cssStyle) external {\n        _requireOnlyOwner();\n        _sphereDefs[cssClass] = cssStyle;\n    }\n\n    function getSphereDef(string memory cssClass) public view returns (string memory) {\n        return _sphereDefs[cssClass];\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function imageBaseURI() public view returns (string memory) {\n        return _imageBaseURI;\n    }\n\n    function imageExtension() public view returns (string memory) {\n        return _imageExtension;\n    }\n\n    function maxRadius() public view returns (uint256) {\n        return _maxRadius;\n    }\n\n    function getClassString(uint256 tokenId, uint256 rarity, bool isAlpha, bool offchainImage) public pure returns (string memory) {\n        return _getClassString(tokenId, rarity, isAlpha, offchainImage);\n    }\n\n    function _getJson(uint256 tokenId, uint256 rarity, uint256 tokenMass, uint256 alphaMass, bool isAlpha, uint256 mergeCount) private view returns (string memory) {\n        string memory imageData =\n        bytes(_imageBaseURI).length == 0 ?\n        _getSvg(tokenId, rarity, tokenMass, alphaMass, isAlpha) :\n        string(abi.encodePacked(imageBaseURI(), _getClassString(tokenId, rarity, isAlpha, true), \"_\", uint256(int256(_getScaledRadius(tokenMass, alphaMass, _maxRadius).toInt())).toString(), imageExtension()));\n\n        ERC721MetadataStructure memory metadata = ERC721MetadataStructure({\n        isImageLinked: bytes(_imageBaseURI).length > 0,\n        name: string(abi.encodePacked(name(), \"(\", tokenMass.toString(), \") #\", tokenId.toString())),\n        description: tokenMass.toString(),\n        createdBy: \"Non\",\n        image: imageData,\n        attributes: _getJsonAttributes(tokenId, rarity, tokenMass, mergeCount, isAlpha)\n        });\n\n        return _generateERC721Metadata(metadata);\n    }\n\n    function _getJsonAttributes(uint256 tokenId, uint256 rarity, uint256 tokenMass, uint256 mergeCount, bool isAlpha) private pure returns (ERC721MetadataAttribute[] memory) {\n        uint256 tensDigit = tokenId % 100 / 10;\n        uint256 onesDigit = tokenId % 10;\n        uint256 class = tensDigit * 10 + onesDigit;\n\n        ERC721MetadataAttribute[] memory metadataAttributes = new ERC721MetadataAttribute[](5);\n        metadataAttributes[0] = _getERC721MetadataAttribute(false, true, false, \"\", \"Mass\", tokenMass.toString());\n        metadataAttributes[1] = _getERC721MetadataAttribute(false, true, false, \"\", \"Alpha\", isAlpha ? \"1\" : \"0\");\n        metadataAttributes[2] = _getERC721MetadataAttribute(false, true, false, \"\", \"Tier\", rarity.toString());\n        metadataAttributes[3] = _getERC721MetadataAttribute(false, true, false, \"\", \"Class\", class.toString());\n        metadataAttributes[4] = _getERC721MetadataAttribute(false, true, false, \"\", \"Merges\", mergeCount.toString());\n        return metadataAttributes;\n    }\n\n    function _getERC721MetadataAttribute(bool includeDisplayType, bool includeTraitType, bool isValueAString, string memory displayType, string memory traitType, string memory value) private pure returns (ERC721MetadataAttribute memory) {\n        ERC721MetadataAttribute memory attribute = ERC721MetadataAttribute({\n        includeDisplayType: includeDisplayType,\n        includeTraitType: includeTraitType,\n        isValueAString: isValueAString,\n        displayType: displayType,\n        traitType: traitType,\n        value: value\n        });\n\n        return attribute;\n    }\n\n    function _getSvg(uint256 tokenId, uint256 rarity, uint256 tokenMass, uint256 alphaMass, bool isAlpha) private view returns (string memory) {\n        bytes memory byteString;\n        for (uint i = 0; i < _imageParts.length; i++) {\n            if (_checkTag(_imageParts[i], _RADIUS_TAG)) {\n                byteString = abi.encodePacked(byteString, _floatToString(_getScaledRadius(tokenMass, alphaMass, _maxRadius)));\n            } else if (_checkTag(_imageParts[i], _SPHERE_TAG)) {\n                if (isAlpha) {\n                    byteString = abi.encodePacked(byteString, _spheres['a']);\n                } else {\n                    byteString = abi.encodePacked(byteString, _spheres[rarity.toString()]);\n                }\n            } else if (_checkTag(_imageParts[i], _SPHERE_DEFS_TAG)) {\n                if (isAlpha) {\n                    byteString = abi.encodePacked(byteString, _sphereDefs['a']);\n                } else {\n                    byteString = abi.encodePacked(byteString, _sphereDefs[rarity.toString()]);\n                }\n            } else if (_checkTag(_imageParts[i], _CLASS_TAG)) {\n                byteString = abi.encodePacked(byteString, _getClassString(tokenId, rarity, isAlpha, false));\n            } else if (_checkTag(_imageParts[i], _CLASS_STYLE_TAG)) {\n                uint256 tensDigit = tokenId % 100 / 10;\n                uint256 onesDigit = tokenId % 10;\n                uint256 class = tensDigit * 10 + onesDigit;\n                string memory classCss = getClassStyle(_getTokenIdClass(class));\n                if(bytes(classCss).length > 0) {\n                    byteString = abi.encodePacked(byteString, classCss);\n                }\n            } else {\n                byteString = abi.encodePacked(byteString, _imageParts[i]);\n            }\n        }\n        return string(byteString);\n    }\n\n    function _getScaledRadius(uint256 tokenMass, uint256 alphaMass, uint256 maximumRadius) private pure returns (int128) {\n        int128 radiusMass = _getRadius64x64(tokenMass);\n        int128 radiusAlphaMass = _getRadius64x64(alphaMass);\n        int128 scalePercentage = ABDKMath64x64.div(radiusMass, radiusAlphaMass);\n        int128 scaledRadius = ABDKMath64x64.mul(ABDKMath64x64.fromUInt(maximumRadius), scalePercentage);\n        if(uint256(int256(scaledRadius.toInt())) == 0) {\n            scaledRadius = ABDKMath64x64.fromUInt(1);\n        }\n        return scaledRadius;\n    }\n\n    // Radius = Cube Root(Mass) * Cube Root (0.23873241463)\n    // Radius = Cube Root(Mass) * 0.62035049089\n    function _getRadius64x64(uint256 mass) private pure returns (int128) {\n        int128 cubeRootScalar = ABDKMath64x64.divu(62035049089, 100000000000);\n        int128 cubeRootMass = ABDKMath64x64.divu(mass.nthRoot(3, 6, 32), 1000000);\n        int128 radius = ABDKMath64x64.mul(cubeRootMass, cubeRootScalar);\n        return radius;\n    }\n\n    function _generateERC721Metadata(ERC721MetadataStructure memory metadata) private pure returns (string memory) {\n        bytes memory byteString;\n\n        byteString = abi.encodePacked(\n            byteString,\n            _openJsonObject());\n\n        byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveStringAttribute(\"name\", metadata.name, true));\n\n        byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveStringAttribute(\"description\", metadata.description, true));\n\n        byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveStringAttribute(\"created_by\", metadata.createdBy, true));\n\n        if(metadata.isImageLinked) {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"image\", metadata.image, true));\n        } else {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"image_data\", metadata.image, true));\n        }\n\n        byteString = abi.encodePacked(\n            byteString,\n            _pushJsonComplexAttribute(\"attributes\", _getAttributes(metadata.attributes), false));\n\n        byteString = abi.encodePacked(\n            byteString,\n            _closeJsonObject());\n\n        return string(byteString);\n    }\n\n    function _getAttributes(ERC721MetadataAttribute[] memory attributes) private pure returns (string memory) {\n        bytes memory byteString;\n\n        byteString = abi.encodePacked(\n            byteString,\n            _openJsonArray());\n\n        for (uint i = 0; i < attributes.length; i++) {\n            ERC721MetadataAttribute memory attribute = attributes[i];\n\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonArrayElement(_getAttribute(attribute), i < (attributes.length - 1)));\n        }\n\n        byteString = abi.encodePacked(\n            byteString,\n            _closeJsonArray());\n\n        return string(byteString);\n    }\n\n    function _getAttribute(ERC721MetadataAttribute memory attribute) private pure returns (string memory) {\n        bytes memory byteString;\n\n        byteString = abi.encodePacked(\n            byteString,\n            _openJsonObject());\n\n        if(attribute.includeDisplayType) {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"display_type\", attribute.displayType, true));\n        }\n\n        if(attribute.includeTraitType) {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"trait_type\", attribute.traitType, true));\n        }\n\n        if(attribute.isValueAString) {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"value\", attribute.value, false));\n        } else {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveNonStringAttribute(\"value\", attribute.value, false));\n        }\n\n        byteString = abi.encodePacked(\n            byteString,\n            _closeJsonObject());\n\n        return string(byteString);\n    }\n\n    function _getClassString(uint256 tokenId, uint256 rarity, bool isAlpha, bool offchainImage) private pure returns (string memory) {\n        bytes memory byteString;\n\n        byteString = abi.encodePacked(byteString, _getRarityClass(rarity));\n\n        if(isAlpha) {\n            byteString = abi.encodePacked(\n                byteString,\n                string(abi.encodePacked(offchainImage ? \"_\" : \" \", \"a\")));\n        }\n\n        uint256 tensDigit = tokenId % 100 / 10;\n        uint256 onesDigit = tokenId % 10;\n        uint256 class = tensDigit * 10 + onesDigit;\n\n        byteString = abi.encodePacked(\n            byteString,\n            string(abi.encodePacked(offchainImage ? \"_\" : \" \", _getTokenIdClass(class))));\n\n        return string(byteString);\n    }\n\n    function _getRarityClass(uint256 rarity) private pure returns (string memory) {\n        return string(abi.encodePacked(\"m\", rarity.toString()));\n    }\n\n    function _getTokenIdClass(uint256 class) private pure returns (string memory) {\n        return string(abi.encodePacked(\"c\", class.toString()));\n    }\n\n    function _checkTag(string storage a, string memory b) private pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    function _floatToString(int128 value) private pure returns (string memory) {\n        uint256 decimal4 = (value & 0xFFFFFFFFFFFFFFFF).mulu(10000);\n        return string(abi.encodePacked(uint256(int256(value.toInt())).toString(), '.', _decimal4ToString(decimal4)));\n    }\n\n    function _decimal4ToString(uint256 decimal4) private pure returns (string memory) {\n        bytes memory decimal4Characters = new bytes(4);\n        for (uint i = 0; i < 4; i++) {\n            decimal4Characters[3 - i] = bytes1(uint8(0x30 + decimal4 % 10));\n            decimal4 /= 10;\n        }\n        return string(abi.encodePacked(decimal4Characters));\n    }\n\n    function _requireOnlyOwner() private view {\n        require(msg.sender == owner, \"You are not the owner\");\n    }\n\n    function _openJsonObject() private pure returns (string memory) {\n        return string(abi.encodePacked(\"{\"));\n    }\n\n    function _closeJsonObject() private pure returns (string memory) {\n        return string(abi.encodePacked(\"}\"));\n    }\n\n    function _openJsonArray() private pure returns (string memory) {\n        return string(abi.encodePacked(\"[\"));\n    }\n\n    function _closeJsonArray() private pure returns (string memory) {\n        return string(abi.encodePacked(\"]\"));\n    }\n\n    function _pushJsonPrimitiveStringAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked('\"', key, '\": \"', value, '\"', insertComma ? ',' : ''));\n    }\n\n    function _pushJsonPrimitiveNonStringAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked('\"', key, '\": ', value, insertComma ? ',' : ''));\n    }\n\n    function _pushJsonComplexAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked('\"', key, '\": ', value, insertComma ? ',' : ''));\n    }\n\n    function _pushJsonArrayElement(string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked(value, insertComma ? ',' : ''));\n    }\n}"
    },
    "util/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.6;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n    /*\n     * Minimum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n    /*\n     * Maximum value signed 64.64-bit fixed point number may have.\n     */\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n    /**\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n    function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n        require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n        return int128 (x << 64);\n    }\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\n     * rounding down.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n    function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n        return int64 (x >> 64);\n    }\n    }\n\n    /**\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n     * number.  Revert on overflow.\n     *\n     * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n    function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n        require (x <= 0x7FFFFFFFFFFFFFFF);\n        return int128 (int256 (x << 64));\n    }\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n     * number rounding down.  Revert on underflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n    function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n        require (x >= 0);\n        return uint64 (uint128 (x >> 64));\n    }\n    }\n\n    /**\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n     * number rounding down.  Revert on overflow.\n     *\n     * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n        int256 result = x >> 64;\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n     * number.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n    function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n        return int256 (x) << 64;\n    }\n    }\n\n    /**\n     * Calculate x + y.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n        int256 result = int256(x) + y;\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate x - y.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n        int256 result = int256(x) - y;\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate x * y rounding down.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n        int256 result = int256(x) * y >> 64;\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n     * number and y is signed 256-bit integer number.  Revert on overflow.\n     *\n     * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n    function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n        if (x == MIN_64x64) {\n            require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n            y <= 0x1000000000000000000000000000000000000000000000000);\n            return -y << 63;\n        } else {\n            bool negativeResult = false;\n            if (x < 0) {\n                x = -x;\n                negativeResult = true;\n            }\n            if (y < 0) {\n                y = -y; // We rely on overflow behavior here\n                negativeResult = !negativeResult;\n            }\n            uint256 absoluteResult = mulu (x, uint256 (y));\n            if (negativeResult) {\n                require (absoluteResult <=\n                    0x8000000000000000000000000000000000000000000000000000000000000000);\n                return -int256 (absoluteResult); // We rely on overflow behavior here\n            } else {\n                require (absoluteResult <=\n                    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n                return int256 (absoluteResult);\n            }\n        }\n    }\n    }\n\n    /**\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\n     *\n     * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n    function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n        if (y == 0) return 0;\n\n        require (x >= 0);\n\n        uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n        uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n        require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        hi <<= 64;\n\n        require (hi <=\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n        return hi + lo;\n    }\n    }\n\n    /**\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n     * zero.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n        require (y != 0);\n        int256 result = (int256 (x) << 64) / y;\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n     * integer numbers.  Revert on overflow or when y is zero.\n     *\n     * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n    function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n        require (y != 0);\n\n        bool negativeResult = false;\n        if (x < 0) {\n            x = -x; // We rely on overflow behavior here\n            negativeResult = true;\n        }\n        if (y < 0) {\n            y = -y; // We rely on overflow behavior here\n            negativeResult = !negativeResult;\n        }\n        uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n        if (negativeResult) {\n            require (absoluteResult <= 0x80000000000000000000000000000000);\n            return -int128 (absoluteResult); // We rely on overflow behavior here\n        } else {\n            require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n            return int128 (absoluteResult); // We rely on overflow behavior here\n        }\n    }\n    }\n\n    /**\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n     * integer numbers.  Revert on overflow or when y is zero.\n     *\n     * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n    function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n        require (y != 0);\n        uint128 result = divuu (x, y);\n        require (result <= uint128 (MAX_64x64));\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate -x.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x != MIN_64x64);\n        return -x;\n    }\n    }\n\n    /**\n     * Calculate |x|.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x != MIN_64x64);\n        return x < 0 ? -x : x;\n    }\n    }\n\n    /**\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n     * zero.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x != 0);\n        int256 result = int256 (0x100000000000000000000000000000000) / x;\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n        return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n    }\n\n    /**\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n     * Revert on overflow or in case x * y is negative.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n        int256 m = int256 (x) * int256 (y);\n        require (m >= 0);\n        require (m <\n            0x4000000000000000000000000000000000000000000000000000000000000000);\n        return int128 (sqrtu (uint256 (m)));\n    }\n    }\n\n    /**\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n    function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n        bool negative = x < 0 && y & 1 == 1;\n\n        uint256 absX = uint128 (x < 0 ? -x : x);\n        uint256 absResult;\n        absResult = 0x100000000000000000000000000000000;\n\n        if (absX <= 0x10000000000000000) {\n            absX <<= 63;\n            while (y != 0) {\n                if (y & 0x1 != 0) {\n                    absResult = absResult * absX >> 127;\n                }\n                absX = absX * absX >> 127;\n\n                if (y & 0x2 != 0) {\n                    absResult = absResult * absX >> 127;\n                }\n                absX = absX * absX >> 127;\n\n                if (y & 0x4 != 0) {\n                    absResult = absResult * absX >> 127;\n                }\n                absX = absX * absX >> 127;\n\n                if (y & 0x8 != 0) {\n                    absResult = absResult * absX >> 127;\n                }\n                absX = absX * absX >> 127;\n\n                y >>= 4;\n            }\n\n            absResult >>= 64;\n        } else {\n            uint256 absXShift = 63;\n            if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n            if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n            if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n            if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n            if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n            if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n            uint256 resultShift = 0;\n            while (y != 0) {\n                require (absXShift < 64);\n\n                if (y & 0x1 != 0) {\n                    absResult = absResult * absX >> 127;\n                    resultShift += absXShift;\n                    if (absResult > 0x100000000000000000000000000000000) {\n                        absResult >>= 1;\n                        resultShift += 1;\n                    }\n                }\n                absX = absX * absX >> 127;\n                absXShift <<= 1;\n                if (absX >= 0x100000000000000000000000000000000) {\n                    absX >>= 1;\n                    absXShift += 1;\n                }\n\n                y >>= 1;\n            }\n\n            require (resultShift < 64);\n            absResult >>= 64 - resultShift;\n        }\n        int256 result = negative ? -int256 (absResult) : int256 (absResult);\n        require (result >= MIN_64x64 && result <= MAX_64x64);\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x >= 0);\n        return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n    }\n\n    /**\n     * Calculate binary logarithm of x.  Revert if x <= 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x > 0);\n\n        int256 msb = 0;\n        int256 xc = x;\n        if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        int256 result = msb - 64 << 64;\n        uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n        for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n            ux *= ux;\n            uint256 b = ux >> 255;\n            ux >>= 127 + b;\n            result += bit * int256 (b);\n        }\n\n        return int128 (result);\n    }\n    }\n\n    /**\n     * Calculate natural logarithm of x.  Revert if x <= 0.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x > 0);\n\n        return int128 (int256 (\n                uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n    }\n\n    /**\n     * Calculate binary exponent of x.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x < 0x400000000000000000); // Overflow\n\n        if (x < -0x400000000000000000) return 0; // Underflow\n\n        uint256 result = 0x80000000000000000000000000000000;\n\n        if (x & 0x8000000000000000 > 0)\n            result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n        if (x & 0x4000000000000000 > 0)\n            result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n        if (x & 0x2000000000000000 > 0)\n            result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n        if (x & 0x1000000000000000 > 0)\n            result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n        if (x & 0x800000000000000 > 0)\n            result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n        if (x & 0x400000000000000 > 0)\n            result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n        if (x & 0x200000000000000 > 0)\n            result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n        if (x & 0x100000000000000 > 0)\n            result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n        if (x & 0x80000000000000 > 0)\n            result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n        if (x & 0x40000000000000 > 0)\n            result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n        if (x & 0x20000000000000 > 0)\n            result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n        if (x & 0x10000000000000 > 0)\n            result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n        if (x & 0x8000000000000 > 0)\n            result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n        if (x & 0x4000000000000 > 0)\n            result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n        if (x & 0x2000000000000 > 0)\n            result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n        if (x & 0x1000000000000 > 0)\n            result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n        if (x & 0x800000000000 > 0)\n            result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n        if (x & 0x400000000000 > 0)\n            result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n        if (x & 0x200000000000 > 0)\n            result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n        if (x & 0x100000000000 > 0)\n            result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n        if (x & 0x80000000000 > 0)\n            result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n        if (x & 0x40000000000 > 0)\n            result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n        if (x & 0x20000000000 > 0)\n            result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n        if (x & 0x10000000000 > 0)\n            result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n        if (x & 0x8000000000 > 0)\n            result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n        if (x & 0x4000000000 > 0)\n            result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n        if (x & 0x2000000000 > 0)\n            result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n        if (x & 0x1000000000 > 0)\n            result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n        if (x & 0x800000000 > 0)\n            result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n        if (x & 0x400000000 > 0)\n            result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n        if (x & 0x200000000 > 0)\n            result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n        if (x & 0x100000000 > 0)\n            result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n        if (x & 0x80000000 > 0)\n            result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n        if (x & 0x40000000 > 0)\n            result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n        if (x & 0x20000000 > 0)\n            result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n        if (x & 0x10000000 > 0)\n            result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n        if (x & 0x8000000 > 0)\n            result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n        if (x & 0x4000000 > 0)\n            result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n        if (x & 0x2000000 > 0)\n            result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n        if (x & 0x1000000 > 0)\n            result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n        if (x & 0x800000 > 0)\n            result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n        if (x & 0x400000 > 0)\n            result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n        if (x & 0x200000 > 0)\n            result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n        if (x & 0x100000 > 0)\n            result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n        if (x & 0x80000 > 0)\n            result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n        if (x & 0x40000 > 0)\n            result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n        if (x & 0x20000 > 0)\n            result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n        if (x & 0x10000 > 0)\n            result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n        if (x & 0x8000 > 0)\n            result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n        if (x & 0x4000 > 0)\n            result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n        if (x & 0x2000 > 0)\n            result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n        if (x & 0x1000 > 0)\n            result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n        if (x & 0x800 > 0)\n            result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n        if (x & 0x400 > 0)\n            result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n        if (x & 0x200 > 0)\n            result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n        if (x & 0x100 > 0)\n            result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n        if (x & 0x80 > 0)\n            result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n        if (x & 0x40 > 0)\n            result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n        if (x & 0x20 > 0)\n            result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n        if (x & 0x10 > 0)\n            result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n        if (x & 0x8 > 0)\n            result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n        if (x & 0x4 > 0)\n            result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n        if (x & 0x2 > 0)\n            result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n        if (x & 0x1 > 0)\n            result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n        result >>= uint256 (int256 (63 - (x >> 64)));\n        require (result <= uint256 (int256 (MAX_64x64)));\n\n        return int128 (int256 (result));\n    }\n    }\n\n    /**\n     * Calculate natural exponent of x.  Revert on overflow.\n     *\n     * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n    function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n        require (x < 0x400000000000000000); // Overflow\n\n        if (x < -0x400000000000000000) return 0; // Underflow\n\n        return exp_2 (\n            int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n    }\n\n    /**\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n     * integer numbers.  Revert on overflow or when y is zero.\n     *\n     * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n    function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n        require (y != 0);\n\n        uint256 result;\n\n        if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            result = (x << 64) / y;\n        else {\n            uint256 msb = 192;\n            uint256 xc = x >> 192;\n            if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n            if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n            if (xc >= 0x100) { xc >>= 8; msb += 8; }\n            if (xc >= 0x10) { xc >>= 4; msb += 4; }\n            if (xc >= 0x4) { xc >>= 2; msb += 2; }\n            if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n            result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n            require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            uint256 hi = result * (y >> 128);\n            uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n            uint256 xh = x >> 192;\n            uint256 xl = x << 64;\n\n            if (xl < lo) xh -= 1;\n            xl -= lo; // We rely on overflow behavior here\n            lo = hi << 128;\n            if (xl < lo) xh -= 1;\n            xl -= lo; // We rely on overflow behavior here\n\n            assert (xh == hi >> 128);\n\n            result += xl / y;\n        }\n\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return uint128 (result);\n    }\n    }\n\n    /**\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n     * number.\n     *\n     * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n    function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n        if (x == 0) return 0;\n        else {\n            uint256 xx = x;\n            uint256 r = 1;\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n            if (xx >= 0x8) { r <<= 1; }\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1;\n            r = (r + x / r) >> 1; // Seven iterations should be enough\n            uint256 r1 = x / r;\n            return uint128 (r < r1 ? r : r1);\n        }\n    }\n    }\n}"
    },
    "util/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nbytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\nhex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\nhex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\nhex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\nfunction encode(bytes memory data) internal pure returns (string memory) {\nif (data.length == 0) return '';\n\n// load the table into memory\nstring memory table = TABLE_ENCODE;\n\n// multiply by 4/3 rounded up\nuint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n// add some extra buffer at the end required for the writing\nstring memory result = new string(encodedLen + 32);\n\nassembly {\n// set the actual output length\nmstore(result, encodedLen)\n\n// prepare the lookup table\nlet tablePtr := add(table, 1)\n\n// input ptr\nlet dataPtr := data\nlet endPtr := add(dataPtr, mload(data))\n\n// result ptr, jump over length\nlet resultPtr := add(result, 32)\n\n// run over the input, 3 bytes at a time\nfor {} lt(dataPtr, endPtr) {}\n{\n// read 3 bytes\ndataPtr := add(dataPtr, 3)\nlet input := mload(dataPtr)\n\n// write 4 characters\nmstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\nresultPtr := add(resultPtr, 1)\nmstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\nresultPtr := add(resultPtr, 1)\nmstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\nresultPtr := add(resultPtr, 1)\nmstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\nresultPtr := add(resultPtr, 1)\n}\n\n// padding with '='\nswitch mod(mload(data), 3)\ncase 1 {mstore(sub(resultPtr, 2), shl(240, 0x3d3d))}\ncase 2 {mstore(sub(resultPtr, 1), shl(248, 0x3d))}\n}\n\nreturn result;\n}\n\nfunction decode(string memory _data) internal pure returns (bytes memory) {\nbytes memory data = bytes(_data);\n\nif (data.length == 0) return new bytes(0);\nrequire(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n// load the table into memory\nbytes memory table = TABLE_DECODE;\n\n// every 4 characters represent 3 bytes\nuint256 decodedLen = (data.length / 4) * 3;\n\n// add some extra buffer at the end required for the writing\nbytes memory result = new bytes(decodedLen + 32);\n\nassembly {\n// padding with '='\nlet lastBytes := mload(add(data, mload(data)))\nif eq(and(lastBytes, 0xFF), 0x3d) {\ndecodedLen := sub(decodedLen, 1)\nif eq(and(lastBytes, 0xFFFF), 0x3d3d) {\ndecodedLen := sub(decodedLen, 1)\n}\n}\n\n// set the actual output length\nmstore(result, decodedLen)\n\n// prepare the lookup table\nlet tablePtr := add(table, 1)\n\n// input ptr\nlet dataPtr := data\nlet endPtr := add(dataPtr, mload(data))\n\n// result ptr, jump over length\nlet resultPtr := add(result, 32)\n\n// run over the input, 4 characters at a time\nfor {} lt(dataPtr, endPtr) {}\n{\n// read 4 characters\ndataPtr := add(dataPtr, 4)\nlet input := mload(dataPtr)\n\n// write 3 bytes\nlet output := add(\nadd(\nshl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\nshl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\nadd(\nshl(6, and(mload(add(tablePtr, and(shr(8, input), 0xFF))), 0xFF)),\nand(mload(add(tablePtr, and(input, 0xFF))), 0xFF)\n)\n)\nmstore(resultPtr, shl(232, output))\nresultPtr := add(resultPtr, 3)\n}\n}\n\nreturn result;\n}\n}"
    },
    "util/Roots.sol": {
      "content": "pragma solidity ^0.8.6;\n\nlibrary Roots {\n\n    // calculates a^(1/n) to dp decimal places\n    // maxIts bounds the number of iterations performed\n    function nthRoot(uint _a, uint _n, uint _dp, uint _maxIts) pure internal returns(uint) {\n        assert (_n > 1);\n\n        // The scale factor is a crude way to turn everything into integer calcs.\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\n        // We calculate to one extra dp and round at the end\n        uint one = 10 ** (1 + _dp);\n        uint a0 = one ** _n * _a;\n\n        // Initial guess: 1.0\n        uint xNew = one;\n\n        uint iter = 0;\n        while (iter < _maxIts) {\n            uint x = xNew;\n            uint t0 = x ** (_n - 1);\n            if (x * t0 > a0) {\n                xNew = x - (x - a0 / t0) / _n;\n            } else {\n                xNew = x + (a0 / t0 - x) / _n;\n            }\n            ++iter;\n            if(xNew == x) {\n                break;\n            }\n        }\n\n        // Round to nearest in the last dp.\n        return (xNew + 5) / 10;\n    }\n}"
    },
    "util/Strings.sol": {
      "content": "/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n}"
    }
  }
}