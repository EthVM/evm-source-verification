{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/MiningPayV1.sol": {
      "content": "// SPDX-License-Identifier: Copyright 2020-2021 Mining Pay, All rights reserved.\r\n\r\npragma solidity 0.7.0;\r\n\r\n// Mining Pay Version-1 (ETH)\r\ncontract MiningPayV1 {\r\n    struct Member {\r\n        bool join;\r\n        string referrerCode;\r\n        address[] referrers;\r\n        uint256 balance;\r\n        mapping (uint8 => bool) clears;\r\n        mapping (uint8 => uint256) processes;\r\n        mapping (uint8 => uint8) processUnits;\r\n    }\r\n    \r\n    struct Pool {\r\n        uint8 unit;\r\n        uint256 price;\r\n        address[] indexes;\r\n    }\r\n    \r\n    event JoinRewardEvent (\r\n        address indexed _member,\r\n        address indexed _referrer,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n    \r\n    event ExitPoolEvent (\r\n        address indexed _member,\r\n        uint8 _poolNumber,\r\n        uint256 _index,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n    \r\n    event ClearPoolEvent (\r\n        address indexed _member,\r\n        uint8 _poolNumber,\r\n        uint256 _time\r\n    );\r\n    \r\n    event PoolRewardEvent (\r\n        address indexed _member,\r\n        address indexed _referrer,\r\n        uint8 _poolNumber,\r\n        uint256 _index,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n    \r\n    event WithdrawEvent (\r\n        address indexed _member,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n    \r\n    uint256 public balance = 0;\r\n    address public developer = 0xC8B98bd9415cb58E07F2fcB6Fb38856D399E71Dc;\r\n    uint256 public joinFee = 1 ether;\r\n    mapping (uint8 => Pool) public pools;\r\n    mapping (address => Member) public members;\r\n    address[] public memberList;\r\n    mapping (string => address) public referrerCodes;\r\n    \r\n    constructor() public {\r\n        members[developer].join = true;\r\n        memberList.push(developer);\r\n    }\r\n    \r\n    function joinMember(string memory _referrerCode) public payable {\r\n        require(members[msg.sender].join == false, 'Member exists.');\r\n        require(referrerCodes[_referrerCode] != address(0), 'Referrer not exists.');\r\n        require(msg.value == joinFee, 'Join fee is incorrect.');\r\n        \r\n        balance += joinFee;\r\n        \r\n        members[msg.sender].join = true;\r\n        memberList.push(msg.sender);\r\n        \r\n        address _referrer = referrerCodes[_referrerCode];\r\n        while (members[msg.sender].referrers.length < 100) {\r\n            members[msg.sender].referrers.push(_referrer);\r\n            if (members[_referrer].referrers.length == 0) {\r\n                break;\r\n            }\r\n            _referrer = members[_referrer].referrers[0];\r\n        }\r\n        \r\n        uint256 _remainingReward = joinFee;\r\n        for (uint i = 0; i < members[msg.sender].referrers.length; i++) {\r\n            uint256 _reward = joinFee / 1000;\r\n            if (i == 0) {\r\n                _reward = joinFee / 2;\r\n            } else if (i == 1) {\r\n                _reward = joinFee / 5;\r\n            } else if (i == 2) {\r\n                _reward = joinFee / 10;\r\n            }\r\n            members[members[msg.sender].referrers[i]].balance += _reward;\r\n            _remainingReward -= _reward;\r\n            emit JoinRewardEvent(msg.sender, members[msg.sender].referrers[i], _reward, block.timestamp);\r\n        }\r\n        \r\n        members[developer].balance += _remainingReward;\r\n        emit JoinRewardEvent(msg.sender, developer, _remainingReward, block.timestamp);\r\n    }\r\n    \r\n    \r\n    function createPool(uint8 _poolNumber, uint8 _unit, uint256 _price) public {\r\n        require(msg.sender == developer, 'Only developer can operate.');\r\n        require(pools[_poolNumber].indexes.length == 0, 'Already started pool.');\r\n        \r\n        pools[_poolNumber].unit = _unit;\r\n        pools[_poolNumber].price = _price;\r\n        \r\n        members[developer].processes[_poolNumber] = 0;\r\n        members[developer].processUnits[_poolNumber] = 0;\r\n        pools[_poolNumber].indexes.push(developer);\r\n    }\r\n    \r\n    function enterPool(uint8 _poolNumber) public payable {\r\n        require(members[msg.sender].join, 'Member not exists.');\r\n        require(msg.sender != developer, 'Developer cannot enter.');\r\n        require(pools[_poolNumber].unit > 0 && pools[_poolNumber].price > 0, 'Unset pool.');\r\n        require(members[msg.sender].processes[_poolNumber] == 0, 'Already progress pool.');\r\n        require(msg.value == pools[_poolNumber].price * 11 / 10, 'Pool price is incorrect.');\r\n        \r\n        if (\r\n            _poolNumber != 1 && \r\n            _poolNumber != 6\r\n        ) {\r\n            require(members[msg.sender].clears[_poolNumber - 1], 'Not meeting enter pool requirements.');\r\n        }\r\n        \r\n        if (members[msg.sender].clears[_poolNumber]) {\r\n            require(members[msg.sender].clears[_poolNumber + 1] || members[msg.sender].processes[_poolNumber + 1] != 0, 'Not meeting enter pool requirements.');\r\n        }\r\n        \r\n        balance += pools[_poolNumber].price * 11 / 10;\r\n\r\n        uint256 _poolIndex = pools[_poolNumber].indexes.length;\r\n        members[msg.sender].processes[_poolNumber] = _poolIndex;\r\n        members[msg.sender].processUnits[_poolNumber] = 0;\r\n        pools[_poolNumber].indexes.push(msg.sender);\r\n        \r\n        uint256 _exitIndex = (_poolIndex - 1) / pools[_poolNumber].unit;\r\n        address _exitMemberAddress = pools[_poolNumber].indexes[_exitIndex];\r\n        members[_exitMemberAddress].balance += pools[_poolNumber].price * 9 / 10;\r\n        members[_exitMemberAddress].processUnits[_poolNumber]++;\r\n        emit ExitPoolEvent(_exitMemberAddress, _poolNumber, _poolIndex, pools[_poolNumber].price * 9 / 10, block.timestamp);\r\n        \r\n        if (members[_exitMemberAddress].processUnits[_poolNumber] == pools[_poolNumber].unit) {\r\n            members[_exitMemberAddress].clears[_poolNumber] = true;\r\n            members[_exitMemberAddress].processes[_poolNumber] = 0;\r\n            members[_exitMemberAddress].processUnits[_poolNumber] = 0;\r\n            emit ClearPoolEvent(_exitMemberAddress, _poolNumber, block.timestamp);\r\n        }\r\n        \r\n        uint256 _remainingReward = pools[_poolNumber].price / 10;\r\n        for (uint i = 0; i < members[msg.sender].referrers.length; i++) {\r\n            if (i >= 10) {\r\n                break;\r\n            }\r\n            uint256 _reward = pools[_poolNumber].price * 3 / 1000;\r\n            if (i == 0) {\r\n                _reward = pools[_poolNumber].price * 3 / 100;\r\n            } else if (i == 1) {\r\n                _reward = pools[_poolNumber].price * 2 / 100;\r\n            } else if (i == 2) {\r\n                _reward = pools[_poolNumber].price * 15 / 1000;\r\n            }\r\n            members[members[msg.sender].referrers[i]].balance += _reward;\r\n            _remainingReward -= _reward;\r\n            emit PoolRewardEvent(msg.sender, members[msg.sender].referrers[i], _poolNumber, _poolIndex, _reward, block.timestamp);\r\n        }\r\n        \r\n        members[developer].balance += _remainingReward;\r\n        emit PoolRewardEvent(msg.sender, developer, _poolNumber, _poolIndex, _remainingReward, block.timestamp);\r\n        \r\n        members[developer].balance += pools[_poolNumber].price / 10;\r\n        emit PoolRewardEvent(msg.sender, developer, _poolNumber, _poolIndex, pools[_poolNumber].price / 10, block.timestamp);\r\n    }\r\n    \r\n    function withdraw() public {\r\n        require(members[msg.sender].balance > 0, 'Balance not exists.');\r\n        \r\n        msg.sender.transfer(members[msg.sender].balance);\r\n        balance -= members[msg.sender].balance;\r\n        emit WithdrawEvent(msg.sender, members[msg.sender].balance, block.timestamp);\r\n        \r\n        members[msg.sender].balance = 0;\r\n    }\r\n    \r\n    function changeReferrerCode(string memory _code) public {\r\n        require(members[msg.sender].join, 'Member not exists.');\r\n        require(referrerCodes[_code] == address(0), 'Already code exists.');\r\n        \r\n        referrerCodes[members[msg.sender].referrerCode] = address(0);\r\n        \r\n        members[msg.sender].referrerCode = _code;\r\n        referrerCodes[_code] = msg.sender;\r\n    }\r\n    \r\n    function getMemberReferrers(address _memberAddress) public view returns (address[] memory) {\r\n        return members[_memberAddress].referrers;\r\n    }\r\n    \r\n    function getMemberClears(address _memberAddress, uint8 _poolNumber) public view returns (bool) {\r\n        return members[_memberAddress].clears[_poolNumber];\r\n    }\r\n    \r\n    function getMemberProcesses(address _memberAddress, uint8 _poolNumber) public view returns (uint256) {\r\n        return members[_memberAddress].processes[_poolNumber];\r\n    }\r\n    \r\n    function getPoolIndexes(uint8 _poolNumber) public view returns (address[] memory) {\r\n        return pools[_poolNumber].indexes;\r\n    }\r\n    \r\n    function getMemberList() public view returns (address[] memory) {\r\n        return memberList;\r\n    }\r\n}"
    }
  }
}