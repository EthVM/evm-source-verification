{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"PRDZprediction.sol":{"content":"pragma solidity 0.6.12;\r\n\r\n    // SPDX-License-Identifier: No License\r\n\r\n    /**\r\n    * @title SafeMath\r\n    * @dev Math operations with safety checks that throw on error\r\n    */\r\n    library SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    }\r\n\r\n    /**\r\n    * @dev Library for managing\r\n    * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n    * types.\r\n    *\r\n    * Sets have the following properties:\r\n    *\r\n    * - Elements are added, removed, and checked for existence in constant time\r\n    * (O(1)).\r\n    * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n    *\r\n    * ```\r\n    * contract Example {\r\n    *     // Add the library methods\r\n    *     using EnumerableSet for EnumerableSet.AddressSet;\r\n    *\r\n    *     // Declare a set state variable\r\n    *     EnumerableSet.AddressSet private mySet;\r\n    * }\r\n    * ```\r\n    *\r\n    * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n    * (`UintSet`) are supported.\r\n    */\r\n    library EnumerableSet {\r\n        \r\n\r\n        struct Set {\r\n        \r\n            bytes32[] _values;\r\n    \r\n            mapping (bytes32 => uint256) _indexes;\r\n        }\r\n    \r\n        function _add(Set storage set, bytes32 value) private returns (bool) {\r\n            if (!_contains(set, value)) {\r\n                set._values.push(value);\r\n                \r\n                set._indexes[value] = set._values.length;\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n        * @dev Removes a value from a set. O(1).\r\n        *\r\n        * Returns true if the value was removed from the set, that is if it was\r\n        * present.\r\n        */\r\n        function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n            // We read and store the value's index to prevent multiple reads from the same storage slot\r\n            uint256 valueIndex = set._indexes[value];\r\n\r\n            if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n                \r\n\r\n                uint256 toDeleteIndex = valueIndex - 1;\r\n                uint256 lastIndex = set._values.length - 1;\r\n\r\n            \r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n                set._values.pop();\r\n\r\n                delete set._indexes[value];\r\n\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        \r\n        function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n            return set._indexes[value] != 0;\r\n        }\r\n\r\n        \r\n        function _length(Set storage set) private view returns (uint256) {\r\n            return set._values.length;\r\n        }\r\n\r\n    \r\n        function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n            require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n            return set._values[index];\r\n        }\r\n\r\n        \r\n\r\n        struct AddressSet {\r\n            Set _inner;\r\n        }\r\n    \r\n        function add(AddressSet storage set, address value) internal returns (bool) {\r\n            return _add(set._inner, bytes32(uint256(value)));\r\n        }\r\n\r\n    \r\n        function remove(AddressSet storage set, address value) internal returns (bool) {\r\n            return _remove(set._inner, bytes32(uint256(value)));\r\n        }\r\n\r\n        \r\n        function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n            return _contains(set._inner, bytes32(uint256(value)));\r\n        }\r\n\r\n    \r\n        function length(AddressSet storage set) internal view returns (uint256) {\r\n            return _length(set._inner);\r\n        }\r\n    \r\n        function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n            return address(uint256(_at(set._inner, index)));\r\n        }\r\n\r\n\r\n    \r\n        struct UintSet {\r\n            Set _inner;\r\n        }\r\n\r\n        \r\n        function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n            return _add(set._inner, bytes32(value));\r\n        }\r\n\r\n    \r\n        function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n            return _remove(set._inner, bytes32(value));\r\n        }\r\n\r\n        \r\n        function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n            return _contains(set._inner, bytes32(value));\r\n        }\r\n\r\n        \r\n        function length(UintSet storage set) internal view returns (uint256) {\r\n            return _length(set._inner);\r\n        }\r\n\r\n    \r\n        function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n            return uint256(_at(set._inner, index));\r\n        }\r\n    }\r\n    \r\n    contract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    \r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    }\r\n\r\n\r\n    interface Token {\r\n        function transferFrom(address, address, uint) external returns (bool);\r\n        function transfer(address, uint) external returns (bool);\r\n    }\r\n\r\n    contract PRDZprediction is Ownable {\r\n        using SafeMath for uint;\r\n        using EnumerableSet for EnumerableSet.AddressSet;\r\n        \r\n    \r\n        /*\r\n        participanta[i] = [\r\n            0 => user staked,\r\n            1 => amount staked,\r\n            2 => result time,\r\n            3 => prediction time,\r\n            4 => market pair,\r\n            5 => value predicted at,\r\n            6 => result value,\r\n            7 => prediction type  0 => Down, 1 => up ,\r\n            8 => result , 0 => Pending , 2 => Lost, 1 => Won, 3 => Withdrawn\r\n        ]\r\n        */\r\n\r\n        // PRDZ token contract address\r\n        address public constant tokenAddress = 0x4e085036A1b732cBe4FfB1C12ddfDd87E7C3664d;\r\n        // Lost token contract address\r\n        address public constant lossPool = 0x639d0AFE157Fbb367084fc4b5c887725112148F9; \r\n        \r\n    \r\n        \r\n        // mapping(address => uint[]) internal participants;\r\n        \r\n        struct Prediction {\r\n            address user;\r\n            uint betAmount;\r\n            uint resultTime;\r\n            uint betTime;\r\n            uint marketPair;\r\n            uint marketType;\r\n            uint valuePredictedAt;\r\n            uint valueResult;\r\n            uint predictionType;\r\n            uint result;       \r\n            bool exists;\r\n        }\r\n        \r\n\r\n        mapping(uint => Prediction)  predictions;\r\n        \r\n        mapping (address => uint) public totalEarnedTokens;\r\n        mapping (address => uint) public totalClaimedTokens;\r\n        mapping (address => uint) public totalAvailableRewards;\r\n        mapping (address => uint) public totalPoints;\r\n        mapping (address => uint) public totalStaked;\r\n        event PredictionMade(address indexed user, uint matchid);\r\n        event PointsEarned(address indexed user, uint indexed time ,  uint score);\r\n    \r\n        event RewardsTransferred(address indexed user, uint amount);\r\n        event ResultDeclared(address indexed user, uint matchID);\r\n        \r\n        uint public payoutPercentage = 6500 ;\r\n        uint public expresultime = 24 hours;\r\n        uint public maximumToken = 5e18 ; \r\n        uint public minimumToken = 1e17 ; \r\n        uint public totalClaimedRewards = 0;\r\n        \r\n        uint public scorePrdzEq = 50 ;\r\n        uint public contractBalance = 0;\r\n\r\n        uint[] public matches;\r\n\r\n    \r\n    function getallmatches() view public  returns (uint[] memory){\r\n        return matches;\r\n    }\r\n        \r\n        function predict(uint matchID , uint amountToPredict, uint resultTime, uint predictedtime, uint marketPair, uint valuePredictedAt, uint predictionType,uint marketType) public returns (uint)  {\r\n            require(amountToPredict >= minimumToken && amountToPredict <= maximumToken, \"Cannot predict with 0 Tokens\");\r\n            require(resultTime > predictedtime, \"Cannot predict at the time of result\");\r\n            require(Token(tokenAddress).transferFrom(msg.sender, address(this), amountToPredict), \"Insufficient Token Allowance\");\r\n            \r\n            require(predictions[matchID].exists !=  true  , \"Match already Exists\" );\r\n            \r\n            \r\n\r\n            Prediction storage newprediction = predictions[matchID];\r\n            newprediction.user =  msg.sender;\r\n            newprediction.betAmount =  amountToPredict; \r\n            newprediction.resultTime =  resultTime ;\r\n            newprediction.betTime =  predictedtime; \r\n            newprediction.marketPair =  marketPair ;\r\n            newprediction.marketType =  marketType ;\r\n            newprediction.valuePredictedAt =  valuePredictedAt ;\r\n            newprediction.valueResult =  0 ;\r\n            newprediction.predictionType =  predictionType ;\r\n            newprediction.result =  0 ;\r\n            newprediction.exists =  true ;\r\n            matches.push(matchID) ;\r\n\r\n            totalPoints[msg.sender] = totalPoints[msg.sender].add(amountToPredict.mul(scorePrdzEq).div(1e18));\r\n            emit PointsEarned(msg.sender, now , amountToPredict.mul(scorePrdzEq).div(1e18));\r\n\r\n            totalStaked[msg.sender] =  totalStaked[msg.sender].add(amountToPredict) ;\r\n            emit PredictionMade(msg.sender, matchID);\r\n\r\n        }\r\n        \r\n        function declareresult(uint curMarketValue , uint matchID  ) public  onlyOwner returns (bool)   {\r\n\r\n\r\n                    Prediction storage eachparticipant = predictions[matchID];\r\n\r\n                        if(eachparticipant.resultTime <= now && eachparticipant.result == 0 && curMarketValue > 0 ){\r\n\r\n                            /* When User Predicted Up && Result is Up */\r\n                                if(eachparticipant.valuePredictedAt  < curMarketValue && eachparticipant.predictionType  == 1  ){\r\n                                    eachparticipant.result  = 1 ;\r\n                                    eachparticipant.valueResult  = curMarketValue ;\r\n                                    uint reward = eachparticipant.betAmount.mul(payoutPercentage).div(1e4);\r\n                                    totalEarnedTokens[eachparticipant.user] = totalEarnedTokens[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n                                    \r\n                                    totalAvailableRewards[eachparticipant.user] = totalAvailableRewards[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n                                }\r\n\r\n                            /* When User Predicted Up && Result is Down */\r\n                                if(eachparticipant.valuePredictedAt  > curMarketValue && eachparticipant.predictionType  == 1  ){\r\n                                    eachparticipant.result  = 2 ;\r\n                                    eachparticipant.valueResult  = curMarketValue ;\r\n                                    Token(tokenAddress).transfer(lossPool, eachparticipant.betAmount);\r\n\r\n                                }\r\n\r\n                            /* When User Predicted Down && Result is Up */\r\n                                if(eachparticipant.valuePredictedAt  < curMarketValue && eachparticipant.predictionType  == 0  ){\r\n                                    eachparticipant.result  = 2 ;\r\n                                    eachparticipant.valueResult  = curMarketValue ;\r\n                                    Token(tokenAddress).transfer(lossPool, eachparticipant.betAmount);\r\n\r\n                                }\r\n\r\n                            /* When User Predicted Down && Result is Down */\r\n                                if(eachparticipant.valuePredictedAt  > curMarketValue && eachparticipant.predictionType  == 0  ){\r\n                                    eachparticipant.result  = 1 ;\r\n                                    eachparticipant.valueResult  = curMarketValue ;\r\n                                    uint reward = eachparticipant.betAmount.mul(payoutPercentage).div(1e4);\r\n                                    totalEarnedTokens[eachparticipant.user] = totalEarnedTokens[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n                                    totalAvailableRewards[eachparticipant.user] = totalAvailableRewards[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n\r\n                                }\r\n                        emit ResultDeclared(msg.sender, matchID);\r\n                    \r\n                }\r\n                \r\n            \r\n                return true ;\r\n\r\n            }\r\n\r\n\r\n            function getmatchBasic(uint  _matchID ) view public returns (address , uint , uint , uint , uint  ) {\r\n                        return (predictions[_matchID].user , predictions[_matchID].betAmount , predictions[_matchID].resultTime , predictions[_matchID].betTime , predictions[_matchID].marketPair  );\r\n            }\r\n\r\n            function getmatchAdv(uint  _matchID ) view public returns (uint , uint , uint , uint , uint  , bool  ) {\r\n                        return (predictions[_matchID].marketType , predictions[_matchID].valuePredictedAt, predictions[_matchID].valueResult, predictions[_matchID].predictionType , predictions[_matchID].result  , predictions[_matchID].exists );\r\n            }\r\n\r\n            \r\n    \r\n\r\n        function withdrawNotExecutedResult(uint  _matchID) \r\n            public \r\n            \r\n            returns (bool) {\r\n            \r\n            if(predictions[_matchID].result == 0 && predictions[_matchID].user == msg.sender && now.sub(predictions[_matchID].resultTime) > expresultime){\r\n                Prediction storage eachparticipant = predictions[_matchID];\r\n                eachparticipant.result =  3 ;\r\n                Token(tokenAddress).transfer(predictions[_matchID].user, predictions[_matchID].betAmount);\r\n            }\r\n            \r\n            return true ;\r\n        }\r\n\r\n    function addContractBalance(uint amount) public {\r\n            require(Token(tokenAddress).transferFrom(msg.sender, address(this), amount), \"Cannot add balance!\");\r\n            contractBalance = contractBalance.add(amount);\r\n        }\r\n\r\n        function updateMaximum(uint  amount) \r\n            public \r\n            onlyOwner\r\n            returns (bool) {\r\n            maximumToken = amount;\r\n            \r\n            return true ;\r\n        }\r\n\r\n        function updateMinimum(uint  amount) \r\n            public \r\n            onlyOwner\r\n            returns (bool) {\r\n            minimumToken = amount;\r\n            \r\n            return true ;\r\n        }\r\n\r\n        \r\n\r\n        function updatePayout(uint  percentage) \r\n            public \r\n            onlyOwner\r\n            returns (bool) {\r\n            payoutPercentage = percentage;\r\n            \r\n            return true ;\r\n        }\r\n\r\n    function updateScoreEq(uint  prdzeq) \r\n            public \r\n            onlyOwner\r\n            returns (bool) {\r\n            scorePrdzEq = prdzeq;\r\n            \r\n            return true ;\r\n        }\r\n\r\n\r\n    \r\n    \r\n\r\n\r\n        function updateAccount(address account) private {\r\n            uint pendingDivs = totalAvailableRewards[account];\r\n            if (pendingDivs > 0 && contractBalance > 0) {\r\n                require(Token(tokenAddress).transfer(account, pendingDivs), \"Could not transfer tokens.\");\r\n                totalClaimedTokens[account] = totalClaimedTokens[account].add(pendingDivs);\r\n                contractBalance = contractBalance.sub(pendingDivs);\r\n                totalAvailableRewards[account] = 0 ;\r\n                totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\r\n                emit RewardsTransferred(account, pendingDivs);\r\n            }\r\n        \r\n            \r\n        }\r\n        \r\n            \r\n        function claimDivs() public {\r\n            updateAccount(msg.sender);\r\n        }\r\n        \r\n        \r\n        \r\n    \r\n\r\n    }"}}}