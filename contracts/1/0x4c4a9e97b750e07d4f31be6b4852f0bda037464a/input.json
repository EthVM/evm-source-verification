{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Nfts.sol":{"content":"pragma solidity 0.8.4;\r\n\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.1pragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() {\r\n\t\t_setOwner(_msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == _msgSender(), 'Ownable: caller is not the owner');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_setOwner(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(\r\n\t\t\tnewOwner != address(0),\r\n\t\t\t'Ownable: new owner is the zero address'\r\n\t\t);\r\n\t\t_setOwner(newOwner);\r\n\t}\r\n\r\n\tfunction _setOwner(address newOwner) private {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.3.1\r\n\r\npragma solidity 0.8.4; // CAUTION\r\n\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryAdd(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tuint256 c = a + b;\r\n\t\t\tif (c < a) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction trySub(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tif (b > a) return (false, 0);\r\n\t\t\treturn (true, a - b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMul(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t\t// benefit is lost if 'b' is also tested.\r\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\t\tif (a == 0) return (true, 0);\r\n\t\t\tuint256 c = a * b;\r\n\t\t\tif (c / a != b) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryDiv(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a / b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMod(uint256 a, uint256 b)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bool, uint256)\r\n\t{\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a % b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a + b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a * b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {trySub}.\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b <= a, errorMessage);\r\n\t\t\treturn a - b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a / b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting with custom message when dividing by zero.\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a % b;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ninterface IReferral {\r\n\t/**\r\n\t * @dev Record referral.\r\n\t */\r\n\tfunction recordReferral(address user, address referrer) external;\r\n\r\n\t/**\r\n\t * @dev Record referral share.\r\n\t */\r\n\tfunction recordReferralShare(address referrer, uint256 share) external;\r\n\r\n\t/**\r\n\t * @dev Get the referrer address that referred the user.\r\n\t */\r\n\tfunction getReferrer(address user) external view returns (address);\r\n}\r\n\r\ncontract Nfts is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public price = 10000000 gwei;\r\n\tuint256 public priceStep = 10000000 gwei;\r\n\tuint256 public maxSupply = 100;\r\n\tuint256 public premint = 30;\r\n    uint256 public totalSupply = premint;\r\n\tuint16 public refShare = 1000; // in basis points, so it's 10%\r\n\tuint256 public startTime = 0;\r\n\tIReferral public referralContract;\r\n\r\n    event Mint(\r\n        address indexed user,\r\n\t\tuint256 fromId,\r\n        uint256 amount\r\n    );\r\n\r\n\tevent ReferralSharePaid(\r\n\t\taddress indexed user,\r\n\t\taddress indexed referrer,\r\n\t\tuint256 shareAmount\r\n\t);\r\n\t\r\n\tfunction getNextPrice() internal returns (uint) {\r\n\t    return price + priceStep * (totalSupply - premint);\r\n\t}\r\n\r\n\tfunction mint(address _referrer) external payable {\r\n\t    require(block.timestamp >= startTime);\r\n\t    \r\n\t\tif (\r\n\t\t\tmsg.value > 0 &&\r\n\t\t\taddress(referralContract) != address(0) &&\r\n\t\t\t_referrer != address(0) &&\r\n\t\t\t_referrer != msg.sender\r\n\t\t) {\r\n\t\t\treferralContract.recordReferral(msg.sender, _referrer);\r\n\t\t}\r\n\t\t\r\n\t\tuint rest = msg.value;\r\n\t\tuint currentPrice = getNextPrice();\r\n\r\n\t\tuint prevTotalSupply = totalSupply;\r\n\r\n\t\twhile (currentPrice <= rest) {\r\n\t\t    require(this.totalSupply() < maxSupply, 'Sold out');\r\n\r\n            totalSupply++;\r\n\t\t\t\r\n\t\t\trest -= currentPrice;\r\n\t\t\tcurrentPrice = getNextPrice();\r\n\t\t}\r\n\r\n\t\tuint256 amount = totalSupply - prevTotalSupply;\r\n\r\n\t\tif (amount > 0) {\r\n\t\t\temit Mint(msg.sender, prevTotalSupply, amount);\r\n\t\t}\r\n\t\t\r\n\t\tpayable(msg.sender).transfer(rest);\r\n\t\tpayReferral(msg.sender, msg.value - rest);\r\n\t}\r\n\r\n\t// Update the referral contract address by the owner\r\n\tfunction setReferralAddress(IReferral _referralAddress) public onlyOwner {\r\n\t\treferralContract = _referralAddress;\r\n\t}\r\n\r\n\t// Pay referral share to the referrer who referred this user.\r\n\tfunction payReferral(address _to, uint256 _amount) internal {\r\n\t\tif (address(referralContract) != address(0) && refShare > 0) {\r\n\t\t\taddress referrer = referralContract.getReferrer(_to);\r\n\t\t\tuint256 shareAmount = _amount.mul(refShare).div(10000);\r\n\r\n\t\t\tif (referrer != address(0) && shareAmount > 0) {\r\n\t\t\t\tpayable(referrer).transfer(shareAmount);\r\n\r\n\t\t\t\treferralContract.recordReferralShare(referrer, shareAmount);\r\n\t\t\t\temit ReferralSharePaid(_to, referrer, shareAmount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract Referral is IReferral, Ownable {\r\n\tmapping(address => bool) public operators;\r\n\tmapping(address => address) public referrers; // user address => referrer address\r\n\tmapping(address => uint256) public referralsCount; // referrer address => referrals count\r\n\tmapping(address => uint256) public totalReferralShares; // referrer address => total referral commissions\r\n\r\n\tevent ReferralRecorded(address indexed user, address indexed referrer);\r\n\tevent ReferralShareRecorded(address indexed referrer, uint256 commission);\r\n\tevent OperatorUpdated(address indexed operator, bool indexed status);\r\n\r\n\tmodifier onlyOperator() {\r\n\t\trequire(operators[msg.sender], 'Operator: caller is not the operator');\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction recordReferral(address _user, address _referrer)\r\n\t\tpublic\r\n\t\toverride\r\n\t\tonlyOperator\r\n\t{\r\n\t\tif (\r\n\t\t\t_user != address(0) &&\r\n\t\t\t_referrer != address(0) &&\r\n\t\t\t_user != _referrer &&\r\n\t\t\treferrers[_user] == address(0)\r\n\t\t) {\r\n\t\t\treferrers[_user] = _referrer;\r\n\t\t\treferralsCount[_referrer] += 1;\r\n\t\t\temit ReferralRecorded(_user, _referrer);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction recordReferralShare(address _referrer, uint256 _share)\r\n\t\tpublic\r\n\t\toverride\r\n\t\tonlyOperator\r\n\t{\r\n\t\tif (_referrer != address(0) && _share > 0) {\r\n\t\t\ttotalReferralShares[_referrer] += _share;\r\n\t\t\temit ReferralShareRecorded(_referrer, _share);\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the referrer address that referred the user\r\n\tfunction getReferrer(address _user) public view override returns (address) {\r\n\t\treturn referrers[_user];\r\n\t}\r\n\r\n\t// Update the status of the operator\r\n\tfunction updateOperator(address _operator, bool _status)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\toperators[_operator] = _status;\r\n\t\temit OperatorUpdated(_operator, _status);\r\n\t}\r\n}"}}}