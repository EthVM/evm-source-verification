{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FIRE.sol": {
      "content": "pragma solidity =0.6.6;\r\n\r\ncontract FIRE {\r\n    string public constant name = \"Fire Protocol\";\r\n    string public constant symbol = \"FIRE\";\r\n    uint8 public constant decimals = 8;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) internal allowances;\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 balance;\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    constructor () public {\r\n        mint(address(0xfcF0d7C6Ca6F65cC2C9f44Ce484D014ae4073404), 10000000 * 1e8);\r\n        mint(address(0x04A93A90CB8E96399c4492Bb8B2eAe8be5599AB6), 10000000 * 1e8);\r\n        mint(address(0x67c356A98c7A0Cf52f8a0E43b0538Fe2a235d8e4), 5000000 * 1e8);\r\n        mint(address(0xFd63912199922BDc256d3AA0b189986C7a0A9D02), 5000000 * 1e8);\r\n        mint(address(0xb1676e5e542e68d226AC0b9B7d4314Df528A8078), 15000000 * 1e8);\r\n        mint(address(0x8f5B105830055506119c1F8Bb3aA879669db7FDc), 55000000 * 1e8);\r\n    }\r\n\r\n    function mint(address _account, uint256 _number) internal {\r\n        balances[_account] = _number;\r\n        totalSupply += _number;\r\n        emit Transfer(address(0), _account, _number);\r\n        _moveDelegates(address(0), _account, _number);\r\n    }\r\n\r\n    function allowance(address account, address spender) external view returns (uint) {\r\n        return allowances[account][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\r\n        uint256 amount;\r\n        if (rawAmount == uint256(-1)) {\r\n            amount = uint256(-1);\r\n        } else {\r\n            amount = safe256(rawAmount, \"FIRE::approve: amount exceeds 256 bits\");\r\n        }\r\n\r\n        allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return balances[account];\r\n    }\r\n\r\n    function transfer(address dst, uint rawAmount) external returns (bool) {\r\n        uint256 amount = safe256(rawAmount, \"FIRE::transfer: amount exceeds 256 bits\");\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint256 spenderAllowance = allowances[src][spender];\r\n        uint256 amount = safe256(rawAmount, \"FIRE::approve: amount exceeds 256 bits\");\r\n\r\n        if (spender != src && spenderAllowance != uint256(-1)) {\r\n            uint256 newAllowance = sub256(spenderAllowance, amount, \"FIRE::transferFrom: transfer amount exceeds spender allowance\");\r\n            allowances[src][spender] = newAllowance;\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint256 amount) internal {\r\n        require(src != address(0), \"FIRE::_transferTokens: cannot transfer from the zero address\");\r\n        require(dst != address(0), \"FIRE::_transferTokens: cannot transfer to the zero address\");\r\n\r\n        balances[src] = sub256(balances[src], amount, \"FIRE::_transferTokens: transfer amount exceeds balance\");\r\n        balances[dst] = add256(balances[dst], amount, \"FIRE::_transferTokens: transfer amount overflows\");\r\n\r\n        emit Transfer(src, dst, amount);\r\n        _moveDelegates(src, dst, amount);\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].balance : 0;\r\n                uint256 srcRepNew = sub256(srcRepOld, amount, \"FIRE::_moveDelegates: amount underflows\");\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].balance : 0;\r\n                uint256 dstRepNew = add256(dstRepOld, amount, \"FIRE::_moveDelegates: amount overflows\");\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address account, uint32 nCheckpoints, uint256 newBalance) internal {\r\n      uint32 blockNumber = safe32(block.number, \"FIRE::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n      if (nCheckpoints > 0 && checkpoints[account][nCheckpoints - 1].fromBlock == blockNumber) {\r\n          checkpoints[account][nCheckpoints - 1].balance = newBalance;\r\n      } else {\r\n          checkpoints[account][nCheckpoints] = Checkpoint(blockNumber, newBalance);\r\n          numCheckpoints[account] = nCheckpoints + 1;\r\n      }\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function safe256(uint256 n, string memory errorMessage) internal pure returns (uint256) {\r\n        require(n <= uint(2**256-1), errorMessage);\r\n        return uint256(n);\r\n    }\r\n\r\n    function add256(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n        return c;\r\n    }\r\n\r\n    function sub256(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n}"
    }
  }
}