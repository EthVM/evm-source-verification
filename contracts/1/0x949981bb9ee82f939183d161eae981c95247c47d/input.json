{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ChainLink.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\ninterface ChainLink {\r\n  function getRate(address coincontract) external view returns (uint16,uint16,uint16,uint16,uint16);\r\n  function checkPrice(address coincontract,uint256 price) external view returns (bool);\r\n  function getIsOpen()external view returns (bool);\r\n  function getBorrowRate(address coincontract) external view returns (uint16);\r\n}"
    },
    "Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}"
    },
    "ERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\nimport \"./IERC20.sol\";\r\nimport \"./ChainLink.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./TransferHelper.sol\";\r\ncontract ERC20Token is IERC20, Ownable{\r\n  using SafeMath for uint256;\r\n  string private _symbol= \"wSHIB\";\r\n  string private _name= \"WeToken SHIB\";\r\n  uint8 private _decimals =18;\r\n  uint256 private _totalSupply =10000000000000000000000000000;\r\n  uint256 private _tokenBalance=10000000000000000000000000000;\r\n  address private _usdtcontract=0xdAC17F958D2ee523a2206206994597C13D831ec7;// USDT\r\n  uint8 private _usdtdecimals=18;\r\n  address private _coincontract=0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;\r\n  address private _linkpricecontract= 0x250aC92EfF498d41DCAbe9d96484c92A01D55Ed0;\r\n  mapping(address=>uint256) private _balances;\r\n  mapping(address=>mapping(address=>uint256)) private _allowed;\r\n\r\n  struct UserInfo {\r\n     uint256 amount;\r\n     uint256 time;\r\n     uint256 price;\r\n  }\r\n  mapping(address=>mapping(uint8=>UserInfo)) private _userpool;\r\n  uint16[5] private _hour=[0,168,720,4320,8760];\r\n  constructor () {\r\n  }\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n   function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n          _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n     function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n         _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n     function udecimals() public view returns (uint8){\r\n      return _usdtdecimals;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowed[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function allowanceCall(address owner) public view returns (uint256) {\r\n      return IERC20(_coincontract).allowance(owner, address(this));\r\n    }\r\n    function setLockTime(uint16 h2,uint16 h3,uint16 h4,uint16 h5)public onlyOwner returns (bool) {\r\n      _hour=[0,h2,h3,h4,h5];\r\n      return true;\r\n    }\r\n    function setLinkPriceContract(address coincontract)public onlyOwner returns (bool) {\r\n        require(address(coincontract)!=address(0),\"Error address(0)\");\r\n        _linkpricecontract=coincontract;\r\n        return true;\r\n    }\r\n    function getLinkPriceContract()public view returns (address) {\r\n        return _linkpricecontract;\r\n    }\r\n    function setUserData(address spender,uint256 amount,uint256 time,uint256 price,uint8 num)public onlyOwner returns (bool) {\r\n      _userpool[spender][num]=UserInfo(amount,time,price);\r\n      return true;\r\n    }    \r\n    function getLockTime() public view returns (uint16,uint16,uint16,uint16,uint16){\r\n      return (_hour[0],_hour[1],_hour[2],_hour[3],_hour[4]);\r\n    }\r\n    function getRate() public view returns (uint16,uint16,uint16,uint16,uint16){\r\n      return ChainLink(_linkpricecontract).getRate(_coincontract);\r\n    }\r\n    function getIsOpen() public view returns (bool){\r\n      return ChainLink(_linkpricecontract).getIsOpen();\r\n    }    \r\n    function getDeposit(address spender) public view returns (uint256,uint256,uint256,uint256,uint256) {\r\n      uint256 n1=_userpool[spender][0].amount;\r\n      uint256 n2=_userpool[spender][1].amount;\r\n      uint256 n3=_userpool[spender][2].amount;\r\n      uint256 n4=_userpool[spender][3].amount;\r\n      uint256 n5=_userpool[spender][4].amount;\r\n      uint256 nowtime=block.timestamp;\r\n      for(uint8 i=1;i<5;i++){\r\n        if(_timesub(spender,nowtime,i)>_hourtosecond(i))\r\n        {\r\n          if(n2>0 && i==1)\r\n          {\r\n            n1=n1.add(n2);\r\n            n2=0;\r\n          }else if(n3>0 && i==2)\r\n          {\r\n            n1=n1.add(n3);\r\n            n3=0;\r\n          }else if(n4>0 && i==3)\r\n          {\r\n            n1=n1.add(n4);\r\n            n4=0;\r\n          }else if( n5>0 && i==4)\r\n          {\r\n            n1=n1.add(n5);\r\n            n5=0;\r\n          }\r\n        }\r\n      }\r\n      return (n1,n2,n3,n4,n5);\r\n    }\r\n    function getAmountTime(address spender,uint8 num) public view returns (uint256,uint256,uint256) {\r\n      uint256 n=_userpool[spender][num].amount;\r\n      uint256 t=_userpool[spender][num].time;\r\n      uint256 p=_userpool[spender][num].price;\r\n       return (n,t,p);\r\n    }\r\n    function interest(address spender) public view returns (uint256){\r\n      uint256 nowtime=block.timestamp;\r\n      uint256 amount=_interest(spender,nowtime,0).add(_interest(spender,nowtime,1));\r\n      amount=amount.add(_interest(spender,nowtime,2));\r\n      amount=amount.add(_interest(spender,nowtime,3));\r\n      amount=amount.add(_interest(spender,nowtime,4));\r\n      return amount;\r\n    }\r\n    function _interest(address spender,uint256 nowtime,uint8 num)  private view returns (uint256){\r\n      uint256 i_n=0; \r\n      uint256 a_n_0=0;  \r\n      (i_n,a_n_0)= _interestCalculation(spender,nowtime,num);     \r\n      return i_n;     \r\n    }\r\n    function withdraw(uint256 amount,uint256 unitprice)public payable returns (bool) {\r\n      require(ChainLink(_linkpricecontract).checkPrice(_coincontract,unitprice)==true,\"ChainLink price verification failed\");\r\n      uint256 nowtime=block.timestamp;\r\n      _calculation(_msgSender(),nowtime,0,0,unitprice);\r\n      uint256 n_0=_userpool[_msgSender()][0].amount;\r\n      if(n_0<amount){\r\n        amount=n_0;\r\n      }\r\n      require(amount <= IERC20(_coincontract).allowance(_owner, address(this)), \"ERC20: _owner amount exceeds allowance\");\r\n      uint256 beforeAmount = IERC20(_coincontract).balanceOf(_owner);\r\n      TransferHelper.safeTransferFrom(_coincontract,_owner ,_msgSender(), amount);\r\n      uint256 afterAmount = IERC20(_coincontract).balanceOf(_owner);\r\n      uint256 balance =beforeAmount.sub(afterAmount, \"ERC20: beforeAmount amount afterAmount balance\");\r\n      require(balance == amount, \"ERC20: error balance\");\r\n\r\n       _userpool[_msgSender()][0]=UserInfo(\r\n                      _userpool[_msgSender()][0].amount.sub(amount),\r\n                      _userpool[_msgSender()][0].time,\r\n                      _userpool[_msgSender()][0].price);\r\n      \r\n      _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\r\n      _tokenBalance=_tokenBalance.add(amount);\r\n      emit Transfer(_msgSender(),address(0),amount);\r\n      return true;\r\n    }\r\n\r\n    function draw(uint256 unitprice)public payable returns (bool) {\r\n      require(ChainLink(_linkpricecontract).checkPrice(_coincontract,unitprice)==true,\"ChainLink price verification failed\");\r\n      uint256 nowtime=block.timestamp;\r\n      _calculation(_msgSender(),nowtime,0,0,unitprice);\r\n      return true;\r\n    }\r\n    function _interestCalculation(address spender,uint256 nowtime,uint8 num)  private view returns (uint256,uint256)\r\n    {\r\n      uint16[5] memory _rate;\r\n      (_rate[0],_rate[1],_rate[2],_rate[3],_rate[4])=ChainLink(_linkpricecontract).getRate(_coincontract);\r\n      uint256 i_0=0;\r\n      uint256 i_n=0;      \r\n      uint256 a_n_0=0;       \r\n      if(num==0){\r\n       i_0=(_userpool[spender][num].price);\r\n        i_0=i_0.mul(_userpool[spender][num].amount).div(100000000);\r\n        i_0=i_0.mul(nowtime.sub(_userpool[spender][num].time));\r\n        i_0=i_0.mul(_rate[num]).div(86400000000);\r\n      }else{\r\n        uint256 p_0=_userpool[spender][0].price;\r\n        if(_userpool[spender][num].time==0){\r\n        }else if(_timesub(spender,nowtime,num)>=_hourtosecond(num)){\r\n          i_n= (_userpool[spender][num].price);\r\n          i_n=i_n.mul(_userpool[spender][num].amount).div(100000000);\r\n          i_n=i_n.mul(_hour[num]);\r\n          i_n=i_n.mul((_rate[num])-(_rate[0]));\r\n          i_n=i_n.div(24000000);\r\n          if((p_0==0 || _userpool[spender][num].price<p_0) && _userpool[spender][num].price>0 ){\r\n            p_0=_userpool[spender][num].price;\r\n          }\r\n          a_n_0=_userpool[spender][num].amount;\r\n          if(_userpool[spender][0].time>0){\r\n              if(_timesub(spender,nowtime,0)>=_hourtosecond(num)){\r\n              i_0=p_0.mul(_userpool[spender][num].amount).div(100000000);\r\n              i_0=i_0.mul(nowtime-_userpool[spender][0].time-_hourtosecond(num));\r\n              i_0=i_0.mul(_rate[0]).div(86400000000);\r\n             }\r\n          }else{\r\n            if(_timesub(spender,nowtime,num)>=_hourtosecond(num)){\r\n              i_0=p_0.mul(_userpool[spender][num].amount).div(100000000);\r\n              i_0=i_0.mul(nowtime-_userpool[spender][num].time-_hourtosecond(num));\r\n              i_0=i_0.mul(_rate[0]).div(86400000000);\r\n            }\r\n          }\r\n        }else{\r\n           if((p_0==0 || _userpool[spender][num].price<p_0) && _userpool[spender][num].price>0){p_0=_userpool[spender][num].price;}\r\n           if(_userpool[spender][0].time>0){\r\n             if(nowtime>_userpool[spender][0].time){\r\n              i_0=p_0.mul(_userpool[spender][num].amount).div(100000000);\r\n              i_0=i_0.mul(nowtime-_userpool[spender][0].time);\r\n              i_0=i_0.mul(_rate[0]).div(86400000000);\r\n             }\r\n           }else{\r\n             if(nowtime>_userpool[spender][num].time){\r\n              i_0=p_0.mul(_userpool[spender][num].amount).div(100000000);\r\n              i_0=i_0.mul(nowtime-_userpool[spender][num].time);\r\n              i_0=i_0.mul(_rate[0]).div(86400000000);\r\n             }\r\n           }\r\n        }\r\n      }\r\n      return (i_0.add(i_n),a_n_0);\r\n    }\r\n     function _calculation(address spender,uint256 nowtime,uint256 amount,uint8 num,uint256 unitprice) internal virtual{\r\n      uint256 a_0=_userpool[spender][0].amount;\r\n      uint256 i_all=0;\r\n      uint256 i_n=0;\r\n      uint256 a_n_0=0;\r\n      (i_n,a_n_0)=_interestCalculation(spender,nowtime,0);\r\n      if(i_n>0){ i_all+=i_n;}\r\n\r\n      for(uint8 i=1;i<5;i++){\r\n          (i_n,a_n_0)=_interestCalculation(spender,nowtime,i);\r\n          a_0+=a_n_0;\r\n          if(i_n>0){\r\n              i_all+=i_n;\r\n              if(num==i){\r\n                if(a_n_0>0){\r\n                  _userpool[spender][i]=UserInfo(amount,nowtime,unitprice);\r\n                }else{\r\n                   _userpool[spender][i]=UserInfo(\r\n                    amount.add(_userpool[spender][i].amount),\r\n                    _calculationtime(spender,nowtime,amount,i),\r\n                    _calculationprice(spender,unitprice,amount,i)\r\n                  );\r\n                }\r\n              }else if(a_n_0>0){\r\n                _userpool[spender][i]=UserInfo(0,0,0);\r\n              }\r\n          }else{\r\n            if(num==i){\r\n              if(a_n_0>0){\r\n                _userpool[spender][i]=UserInfo(amount,nowtime,unitprice);\r\n              }else{\r\n                _userpool[spender][i]=UserInfo(\r\n                      amount.add(_userpool[spender][i].amount),\r\n                      _calculationtime(spender,nowtime,amount,i),\r\n                      _calculationprice(spender,unitprice,amount,i)\r\n                    );\r\n              }\r\n            }else if(a_n_0>0){\r\n              _userpool[spender][i]=UserInfo(0,0,0);\r\n            }\r\n        }\r\n      }\r\n      uint256 p_0=_userpool[spender][0].price;\r\n      if(p_0==0 || unitprice<p_0){p_0=unitprice;}\r\n      if(num==0){a_0=a_0.add(amount);}\r\n      _userpool[spender][0]=UserInfo(a_0,nowtime,p_0);\r\n       if(i_all>0){\r\n        if(_usdtdecimals>_decimals){\r\n          i_all=i_all.mul(_pow10(_usdtdecimals,_decimals));\r\n        }else if(_usdtdecimals<_decimals){\r\n          i_all=i_all.div(_pow10(_decimals,_usdtdecimals));\r\n        }\r\n        require(i_all <= IERC20(_usdtcontract).allowance(_owner, address(this)), \"ERC20: _owner amount exceeds allowance\");\r\n        uint256 beforeAmount = IERC20(_usdtcontract).balanceOf(_owner);\r\n        TransferHelper.safeTransferFrom(_usdtcontract,_owner, spender, i_all);\r\n        uint256 afterAmount = IERC20(_usdtcontract).balanceOf(_owner);\r\n        uint256 balance =beforeAmount.sub(afterAmount, \"ERC20: beforeAmount amount afterAmount balance\");\r\n        require(balance == i_all, \"ERC20: error balance\");\r\n       }\r\n    }\r\n    function _pow10(uint8 big,uint8 small) private pure returns(uint256){\r\n      uint256 v=big;\r\n      v=v-small;\r\n      uint256 ret=10 ** v;\r\n      return ret;\r\n    }\r\n    function _calculationtime(address spender,uint256 nowtime,uint256 amount,uint8 num) private view returns(uint256){\r\n       uint256 time= _userpool[spender][num].time;\r\n       if(_userpool[spender][num].amount==0){\r\n        time=nowtime;\r\n       }else{\r\n        time=time.add((nowtime-_userpool[spender][num].time).mul(amount).div(_userpool[spender][num].amount));\r\n       }\r\n       return time;\r\n    }\r\n    function _calculationprice(address spender,uint256 unitprice,uint256 amount,uint8 num) private view returns(uint256){\r\n       uint256 price= _userpool[spender][num].price;\r\n       if(_userpool[spender][num].amount==0){\r\n        price=unitprice;\r\n       }else{\r\n        if(unitprice>0){\r\n          price=price.add((unitprice-_userpool[spender][num].price).mul(amount).div(_userpool[spender][num].amount));\r\n        }\r\n       }\r\n       return price;\r\n    }\r\n    function deposit(uint256 amount,uint8 num,uint256 unitprice) public payable returns (bool) {\r\n      require(ChainLink(_linkpricecontract).checkPrice(_coincontract,unitprice)==true,\"ChainLink price verification failed\");\r\n      require(amount <= IERC20(_coincontract).allowance(_msgSender(), address(this)), \"ERC20: owner amount exceeds allowance\");\r\n      uint256 beforeAmount = IERC20(_coincontract).balanceOf(_msgSender());\r\n      TransferHelper.safeTransferFrom(_coincontract, _msgSender(), _owner, amount);\r\n      uint256 afterAmount = IERC20(_coincontract).balanceOf(_msgSender());\r\n      uint256 balance =beforeAmount.sub(afterAmount, \"ERC20: beforeAmount amount afterAmount balance\");\r\n      require(balance == amount, \"ERC20: error balance\");\r\n      _tokenBalance=_tokenBalance.sub(amount);\r\n      _balances[_msgSender()] = _balances[_msgSender()].add(amount);\r\n      emit Transfer(address(0),_msgSender(),amount);\r\n      uint256 nowtime=block.timestamp;\r\n      _calculation(_msgSender(),nowtime,amount,num,unitprice);\r\n      return true;\r\n    }\r\n    function _timesub(address spender,uint256 nowtime,uint8 num)  private view returns (uint256)\r\n    {\r\n       uint256 time= _userpool[spender][num].time;\r\n        uint256 subval=nowtime;\r\n        subval=subval.sub(time);\r\n        return subval;\r\n    }\r\n    function _hourtosecond(uint8 num)  private view returns (uint256)\r\n    {\r\n        uint256 second=_hour[num];\r\n        second=second.mul(3600);\r\n        return second;\r\n    }\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowed[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\nimport \"./Context.sol\";\r\nabstract contract Ownable is Context {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor ()  {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
    },
    "SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    },
    "TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n}"
    }
  }
}