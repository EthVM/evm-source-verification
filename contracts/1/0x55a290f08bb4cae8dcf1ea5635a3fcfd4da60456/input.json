{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/b.sol":{"content":"    pragma solidity 0.7.1;\n\n    library SafeMath {\n        function add(uint a, uint b) internal pure returns (uint c) {\n            c = a + b;\n            require(c >= a);\n        }\n        function sub(uint a, uint b) internal pure returns (uint c) {\n            require(b <= a);\n            c = a - b;\n        }\n        function mul(uint a, uint b) internal pure returns (uint c) {\n            c = a * b;\n            require(a == 0 || c / a == b);\n        }\n        function div(uint a, uint b) internal pure returns (uint c) {\n            require(b > 0);\n            c = a / b;\n        }\n    }\n\n    interface ERC20Interface {\n        function totalSupply() external view returns (uint256);\n        function balanceOf(address account) external view returns (uint256);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function allowance(address owner, address spender) external view returns (uint256);\n        function approve(address spender, uint256 amount) external returns (bool);\n        function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n\n\n    abstract contract ApproveAndCallFallBack {\n        function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\n    }\n\n    contract Owned {\n        address public owner;\n        address public newOwner;\n\n        event OwnershipTransferred(address indexed _from, address indexed _to);\n\n        constructor() public  {\n            owner = msg.sender;\n        }\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n\n        function transferOwnership(address _newOwner) public onlyOwner {\n            newOwner = _newOwner;\n        }\n        function acceptOwnership() public {\n            require(msg.sender == newOwner);\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            newOwner = address(0);\n        }\n    }\n\n    contract BITTO is ERC20Interface, Owned {\n        using SafeMath for uint;\n\n        string public symbol;\n        string public  name;\n        uint8 public decimals;\n        uint _totalSupply;\n\n        mapping(address => uint) balances;\n        mapping(address => mapping(address => uint)) allowed;\n\n        constructor() public {\n            symbol = \"BITTO\";\n            name = \"BITTO\";\n            decimals = 18;\n            _totalSupply = 17709627 * 10**uint(decimals);\n            balances[owner] = _totalSupply;\n            emit Transfer(address(0), owner, _totalSupply);\n        }\n\n        function totalSupply() public view override returns (uint) {\n            return _totalSupply.sub(balances[address(0)]);\n        }\n\n        function balanceOf(address tokenOwner) public view override returns (uint balance) {\n            return balances[tokenOwner];\n        }\n\n        function transfer(address to, uint tokens) public override returns (bool success) {\n            balances[msg.sender] = balances[msg.sender].sub(tokens);\n            balances[to] = balances[to].add(tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n\n        function approve(address spender, uint tokens) public override returns (bool success) {\n            allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n            balances[from] = balances[from].sub(tokens);\n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n            balances[to] = balances[to].add(tokens);\n            emit Transfer(from, to, tokens);\n            return true;\n        }\n\n\n        function allowance(address tokenOwner, address spender) public view override returns (uint remaining) {\n            return allowed[tokenOwner][spender];\n        }\n\n\n        function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n            allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n            return true;\n        }\n\n        fallback () external {\n            revert();\n        }\n\n\n        function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n            return ERC20Interface(tokenAddress).transfer(owner, tokens);\n        }\n    }"}}}