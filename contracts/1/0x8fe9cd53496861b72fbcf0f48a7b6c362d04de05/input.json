{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/staking.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"t001\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"t002\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"t003\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"t004\");\r\n\r\n        (bool success,) = recipient.call{value : amount}(\"\");\r\n        require(success, \"t005\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"m001\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"m002\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"t006\");\r\n        require(isContract(target), \"t007\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value : value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"m003\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"t008\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"m004\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"t009\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC721Enumerable {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"t010\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"t011\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"t012\");\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"t013\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"m006\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"m007\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"t014\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface Chao {\r\n    function claim(address _to, uint256 _num, uint256 _poolId, uint256 _randNum, uint256 _minNum, uint256 _MaxNum) external;\r\n}\r\n\r\ncontract Staking is ReentrancyGuard, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    uint256 private PoolIdNow = 0;\r\n    mapping(address => mapping(uint256 => uint256)) public staking_num;\r\n    mapping(address => mapping(uint256 => uint256[])) public staking_token_id;\r\n    mapping(uint256 => mapping(uint256 => bool)) private staking_token_id_status;\r\n    mapping(address => mapping(uint256 => uint256)) public staking_time;\r\n    mapping(uint256 => PoolInfo) public PoolInfoList;\r\n    IERC721Enumerable public stakingNftAddress;\r\n    IERC20 public RewardAddress;\r\n    Chao public RewardNft;\r\n\r\n    struct PoolInfo {\r\n        uint256 poolId;\r\n        bool canStakeNft;\r\n        uint256 stakingLength;\r\n        uint256 RandTotal;\r\n        uint256 RandMin;\r\n        uint256 RandMax;\r\n        uint256 RewardNum;\r\n    }\r\n\r\n    // event widthdrawNftEvent(address _user, uint _tokenId, uint rand_num);\r\n    // _RandTotal:800; _RandMin:200;_RandMax:600;\r\n    function addPool(uint256 _stakingLength, uint256 _RandTotal, uint256 _RandMin, uint256 _RandMax, uint256 _RewardNum) public onlyOwner {\r\n        require(_RandTotal >= _RandMin && _RandTotal >= _RandMin && _RandMax > _RandMin, \"t015\");\r\n        PoolIdNow = PoolIdNow.add(1);\r\n        PoolInfoList[PoolIdNow] = PoolInfo(PoolIdNow, true, _stakingLength, _RandTotal, _RandMin, _RandMax, _RewardNum);\r\n    }\r\n\r\n    function updatePool(uint256 _poolId, bool canStakeNft, uint256 _stakingLength, uint256 _RandTotal, uint256 _RandMin, uint256 _RandMax, uint256 _RewardNum) public onlyOwner {\r\n        require(_RandTotal >= _RandMin && _RandTotal >= _RandMin && _RandMax > _RandMin, \"t016\");\r\n        PoolInfoList[_poolId] = PoolInfo(PoolIdNow, canStakeNft, _stakingLength, _RandTotal, _RandMin, _RandMax, _RewardNum);\r\n    }\r\n\r\n    function enableCanStakeNft(uint256 _poolId) public onlyOwner {\r\n        require(PoolInfoList[_poolId].canStakeNft == false && PoolInfoList[_poolId].RewardNum > 0, \"t017\");\r\n        PoolInfoList[_poolId].canStakeNft = true;\r\n    }\r\n\r\n    function disableCanStakeNft(uint256 _poolId) public onlyOwner {\r\n        require(PoolInfoList[_poolId].canStakeNft == true && PoolInfoList[_poolId].RewardNum > 0, \"t018\");\r\n        PoolInfoList[_poolId].canStakeNft = false;\r\n    }\r\n\r\n    // function setStakingNftAddress(IERC721Enumerable stakingNftAddress_) public onlyOwner {\r\n    //     stakingNftAddress = stakingNftAddress_;\r\n    // }\r\n\r\n    // function setRewardAddress(IERC20 RewardAddress_) public onlyOwner {\r\n    //     RewardAddress = RewardAddress_;\r\n    // }\r\n\r\n    // function setRewardNft(Chao RewardNft_) public onlyOwner {\r\n    //     RewardNft = RewardNft_;\r\n    // }\r\n\r\n    function setTokens(IERC721Enumerable stakingNftAddress_, Chao RewardNft_, IERC20 RewardAddress_) public onlyOwner {\r\n        stakingNftAddress = stakingNftAddress_;\r\n        RewardNft = RewardNft_;\r\n        RewardAddress = RewardAddress_;\r\n    }\r\n\r\n    // function setRewardAddress(IERC20 RewardAddress_) public onlyOwner {\r\n    //     RewardAddress = RewardAddress_;\r\n    // }\r\n\r\n    // function setRewardNft(Chao RewardNft_) public onlyOwner {\r\n    //     RewardNft = RewardNft_;\r\n    // }\r\n\r\n    function getStakeNftNum(uint256 _poolId, address _user) public view returns (uint256 num) {\r\n        if (PoolInfoList[_poolId].canStakeNft == false)\r\n            num = 0;\r\n        else if (stakingNftAddress.balanceOf(_user) == 0)\r\n            num = 0;\r\n        else {\r\n            uint256 num2 = stakingNftAddress.balanceOf(_user);\r\n            for (uint256 i = 0; i < num2; i++) {\r\n                if (staking_token_id_status[_poolId][stakingNftAddress.tokenOfOwnerByIndex(_user, i)] == false) {\r\n                    num = num.add(1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStakeNftList(uint256 _poolId, uint256 _maxNum, address _user) internal view returns (uint256[] memory, uint256) {\r\n        require(PoolInfoList[_poolId].canStakeNft == true, \"t019\");\r\n        require(stakingNftAddress.balanceOf(_user) > 0, \"t020\");\r\n        require(stakingNftAddress.isApprovedForAll(_user, address(this)), \"t021\");\r\n        uint256 num = stakingNftAddress.balanceOf(_user);\r\n        uint256 num2 = 0;\r\n        for (uint256 i = 0; i < num; i++) {\r\n            if (staking_token_id_status[_poolId][stakingNftAddress.tokenOfOwnerByIndex(_user, i)] == false)\r\n            {\r\n                num2 = num2.add(1);\r\n            }\r\n        }\r\n        require(num2 > 0, \"t022\");\r\n        if (num2 >= _maxNum) {\r\n            num2 = _maxNum;\r\n        }\r\n        uint256[] memory num3 = new uint256[](num2);\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < num; i++) {\r\n            if (staking_token_id_status[_poolId][stakingNftAddress.tokenOfOwnerByIndex(_user, i)] == false)\r\n            {\r\n                if (j < num2)\r\n                {\r\n                    num3[j] = stakingNftAddress.tokenOfOwnerByIndex(_user, i);\r\n                    j = j.add(1);\r\n                }\r\n            }\r\n        }\r\n        return (num3, num3.length);\r\n    }\r\n\r\n    function stakeNft(uint256 _poolId, uint256 _maxNum) public {\r\n        (uint256[] memory num3,) = getStakeNftList(_poolId, _maxNum, msg.sender);\r\n        for (uint256 i = 0; i < num3.length; i++) {\r\n            if (staking_token_id_status[_poolId][num3[i]] == false)\r\n            {\r\n                staking_token_id[msg.sender][_poolId].push(num3[i]);\r\n                stakingNftAddress.transferFrom(msg.sender, address(this), num3[i]);\r\n                staking_token_id_status[_poolId][num3[i]] = true;\r\n            }\r\n        }\r\n        staking_num[msg.sender][_poolId] = staking_num[msg.sender][_poolId] + num3.length;\r\n        staking_time[msg.sender][_poolId] = block.number;\r\n    }\r\n\r\n    function rand(uint256 _length, address _address, uint256 _tokenId) internal view returns (uint256) {\r\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _address, _tokenId)));\r\n        return random % _length;\r\n    }\r\n\r\n    function widthdrawNft(uint256 _poolId) public {\r\n        require(block.number > staking_time[msg.sender][_poolId] + PoolInfoList[_poolId].stakingLength, \"t023\");\r\n        require(staking_num[msg.sender][_poolId] > 0, \"t024\");\r\n        for (uint256 i = 0; i < staking_token_id[msg.sender][_poolId].length; i++) {\r\n            stakingNftAddress.transferFrom(address(this), msg.sender, staking_token_id[msg.sender][_poolId][i]);\r\n            uint rand_num = rand(PoolInfoList[_poolId].RandTotal, msg.sender, staking_token_id[msg.sender][_poolId][i]);\r\n            // emit widthdrawNftEvent(msg.sender, staking_token_id[msg.sender][_poolId][i], rand_num);\r\n            if (rand_num > PoolInfoList[_poolId].RandMin && rand_num < PoolInfoList[_poolId].RandMax) {\r\n                RewardNft.claim(msg.sender, 1, _poolId, rand_num, PoolInfoList[_poolId].RandMin, PoolInfoList[_poolId].RandMax);\r\n            }\r\n        }\r\n        uint256 reward_num = PoolInfoList[_poolId].RewardNum.mul(staking_num[msg.sender][_poolId]).mul(10 ** RewardAddress.decimals());\r\n        RewardAddress.safeApprove(address(this), reward_num);\r\n        RewardAddress.safeTransferFrom(address(this), msg.sender, reward_num);\r\n        staking_num[msg.sender][_poolId] = 0;\r\n        staking_time[msg.sender][_poolId] = 0;\r\n        delete staking_token_id[msg.sender][_poolId];\r\n    }\r\n\r\n    function widthdrawNftWithoutReward(uint256 _poolId) public {\r\n        // require(block.number > staking_time[msg.sender][_poolId] + PoolInfoList[_poolId].stakingLength, \"t025\");\r\n        require(staking_num[msg.sender][_poolId] > 0, \"t026\");\r\n        for (uint256 i = 0; i < staking_token_id[msg.sender][_poolId].length; i++) {\r\n            stakingNftAddress.transferFrom(address(this), msg.sender, staking_token_id[msg.sender][_poolId][i]);\r\n            staking_token_id_status[_poolId][staking_token_id[msg.sender][_poolId][i]] = false;\r\n        }\r\n        staking_num[msg.sender][_poolId] = 0;\r\n        staking_time[msg.sender][_poolId] = 0;\r\n        delete staking_token_id[msg.sender][_poolId];\r\n    }\r\n\r\n    // function massTransferFrom(address _to, uint256 _num) public {\r\n    //     uint256 num = stakingNftAddress.balanceOf(msg.sender);\r\n    //     require(num > 0 && _num > 0, \"t027\");\r\n    //     require(stakingNftAddress.isApprovedForAll(msg.sender, address(this)), \"t028\");\r\n    //     if (num >= _num) {\r\n    //         num = _num;\r\n    //     }\r\n    //     for (uint256 i = 0; i < num; i++) {\r\n    //         stakingNftAddress.transferFrom(msg.sender, _to, stakingNftAddress.tokenOfOwnerByIndex(msg.sender, 0));\r\n    //     }\r\n    // }\r\n\r\n    function getErc20Token(IERC20 _token) public onlyOwner {\r\n        _token.safeApprove(address(this), _token.balanceOf(address(this)));\r\n        _token.safeTransferFrom(address(this), msg.sender, _token.balanceOf(address(this)));\r\n    }\r\n}"}}}