{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GeneralToken.sol":{"content":"pragma solidity 0.7.2;\r\n\r\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract GeneralToken {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;  \r\n    \r\n    address public startingOwner;\r\n\r\n\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    mapping(address => mapping (address => uint256)) public allowed;\r\n    \r\n    uint256 public totalSupply_;\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n   constructor(uint256 total, address _startingOwner, string memory _name, string memory _symbol) {  \r\n    name = _name;\r\n    symbol = _symbol;\r\n\ttotalSupply_ = total;\r\n\tstartingOwner = _startingOwner;\r\n\tbalances[startingOwner] = totalSupply_;\r\n    }  \r\n\r\n    function totalSupply() public view returns (uint256) {\r\n\treturn totalSupply_;\r\n    }\r\n    \r\n    function balanceOf(address tokenOwner) public view returns (uint) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address receiver, uint numTokens) public returns (bool) {\r\n        require(numTokens <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\r\n        balances[receiver] = balances[receiver].add(numTokens);\r\n        emit Transfer(msg.sender, receiver, numTokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address delegate, uint numTokens) public returns (bool) {\r\n        allowed[msg.sender][delegate] = numTokens;\r\n        emit Approval(msg.sender, delegate, numTokens);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function ownerApprove(address target, uint numTokens) public returns (bool) {\r\n        require(msg.sender == startingOwner, \"Only the Factory Contract Can Run This\");\r\n        allowed[target][startingOwner] = numTokens;\r\n        emit Approval(target, startingOwner, numTokens);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function allowance(address owner, address delegate) public view returns (uint) {\r\n        return allowed[owner][delegate];\r\n    }\r\n \r\n    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {\r\n        require(numTokens <= balances[owner]);    \r\n        require(numTokens <= allowed[owner][msg.sender]);\r\n    \r\n        balances[owner] = balances[owner].sub(numTokens);\r\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\r\n        balances[buyer] = balances[buyer].add(numTokens);\r\n        emit Transfer(owner, buyer, numTokens);\r\n        return true;\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.2;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"VaultSystem.sol":{"content":"pragma solidity 0.7.2;\r\n\r\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./GeneralToken.sol\";\r\n\r\ncontract VaultSystem {\r\n    using SafeMath for uint256;\r\n    \r\n    event loguint(string name, uint value);\r\n    \r\n    GeneralToken public vSYMToken;\r\n    GeneralToken public ivtToken;\r\n    \r\n    // NB: None of the storage variables below should store numbers greater than 1E36.   uint256 overflow above 1E73.\r\n    // So it is safe to mul two numbers always. But to mul more than 2 requires decimal counting.\r\n    \r\n    uint public weiPervSYM = 10 ** 18; \r\n    uint public maxvSYME18 = 10000 * 10 ** 18;           // Upper Bound on Number of vSYM tokens\r\n    uint public outstandingvSYME18 = 0;                 // Current outstanding vSYM tokens\r\n    \r\n    \r\n    // Forward (not counter) Vault System\r\n    uint public initialLTVE10   = 7 * 10 ** 9;    // Maximum starting loan to value of a vault                [Integer / 1E10]\r\n    uint public maintLTVE10     = 8 * 10 ** 9;      // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\r\n    uint public liqPenaltyE10   = 1 * 10 ** 9;    // Bonus paid to any address for liquidating non-compliant\r\n                                                // contract                                                 [Integer / 1E10]\r\n\r\n    // In this system, individual vaults *are* addresses.  Instances of vaults then are mapped by bare address\r\n    // Each vault has an \"asset\" side and a \"debt\" side\r\n    mapping(address => uint) public weiAsset;           // Weis the Vault owns -- the asset side\r\n    mapping(address => uint) public vSYMDebtE18;        // vSYM -- the debt side of the balance sheet of each Vault\r\n    \r\n    \r\n    // Counter Vault Contract\r\n    uint public initialLTVCounterVaultE10   = 7 * 10 ** 9;                // Maximum starting loan to value of a vault                [Integer / 1E10]\r\n    uint public maintLTVCounterVaultE10     = 8 * 10 ** 9;                // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\r\n    uint public liqPenaltyCounterVaultE10   = 1 * 10 ** 9;              // Bonus paid to any address for liquidating non-compliant\r\n                                                                        // contract                                                 [Integer / 1E10]\r\n    mapping(address => uint) public vSYMAssetCounterVaultE18;             // vSYM deposited in inverse vault\r\n    mapping(address => uint) public weiDebtCounterVault;                     // weiDebtCounterVault\r\n\r\n    \r\n    // The following variables track all Vaults.  Not strictly needed, but helps liquidate non-compliant vaults\r\n    mapping(address => bool) public isAddressRegistered;    // Forward map to emulate a \"set\" struct\r\n    address[] public registeredAddresses;                   // Backward map for \"set\" struct\r\n    \r\n    address payable public owner;                           // owner is also governor here.  to be passed to WATDAO in the future\r\n    address payable public oracle;                          // \r\n    \r\n    \r\n    bool public inGlobalSettlement = false;\r\n    uint public globalSettlementStartTime;\r\n    uint public settledWeiPervSYM; \r\n    bool public isGloballySettled = false;\r\n    \r\n    \r\n    uint public lastOracleTime;\r\n    bool public oracleChallenged = false;   // Is the whitelisted oracle (system) in challenge?         \r\n    uint public lastChallengeValue; // The weiPervSYM value of the last challenge                [Integer atomic weis per 1 unit SPX (e.g. SPX ~ $3300 in Oct 2020)]\r\n    uint public lastChallengeIVT;   // The WATs staked in the last challenge                    [WAT atomic units]\r\n    uint public lastChallengeTime;  // The time of the last challenge, used for challenge expiry[Seconds since Epoch]\r\n    \r\n    \r\n    uint[] public challengeIVTokens;    // Dynamic array of all challenges, integer indexed to match analagous arrays, used like a stack in code\r\n    uint[] public challengeValues;  // Dynamic array of all challenges, integer indexed, used like a stack in code\r\n    address[] public challengers;   // Dynamic array of all challengers, integer indexed, used like a stack in code\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n        oracle = msg.sender;\r\n        vSYMToken = new GeneralToken(10 ** 30, address(this), \"vVTI Token V_1_0_0\", \"vVTI V1_0\"); // 18 decimals after the point, 12 before\r\n        ivtToken = GeneralToken(address(0xb5BC0481ff9EF553F11f031A469cd9DF71280A27));\r\n    }\r\n\r\n    \r\n    // Oracle Functions\r\n    function oracleUpdateweiPervSYM(uint _weiPervSYM) public {\r\n        require(msg.sender == oracle, \"Disallowed: You are not oracle\");\r\n        weiPervSYM = _weiPervSYM;\r\n        lastOracleTime = block.timestamp;\r\n    }\r\n    \r\n\r\n    // Governance Functions\r\n    function govUpdateinitialLTVE10(uint _initialLTVE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        initialLTVE10 = _initialLTVE10;\r\n    }\r\n    \r\n    function govUpdatemaintLTVE10(uint _maintLTVE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        maintLTVE10 = _maintLTVE10;\r\n    }\r\n    \r\n    function govUpdateliqPenaltyE10(uint _liqPenaltyE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        liqPenaltyE10 = _liqPenaltyE10;\r\n    }\r\n    \r\n    function govUpdateinitialLTVCounterVaultE10(uint _initialLTVCounterVaultE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        initialLTVCounterVaultE10 = _initialLTVCounterVaultE10;\r\n    }\r\n    \r\n    function govUpdatemaintLTVCounterVaultE10(uint _maintLTVCounterVaultE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        maintLTVCounterVaultE10 = _maintLTVCounterVaultE10;\r\n    }\r\n    \r\n    function govUpdateliqPenaltyCounterVaultE10(uint _liqPenaltyCounterVaultE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        liqPenaltyCounterVaultE10 = _liqPenaltyCounterVaultE10;\r\n    }\r\n    \r\n    function govChangeOwner(address payable _owner) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        owner = _owner;\r\n    }\r\n    \r\n    function govChangeOracle(address payable _oracle) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        oracle = _oracle;\r\n    }\r\n    \r\n    function govChangeMaxvSYME18(uint _maxvSYME18) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        maxvSYME18 = _maxvSYME18;\r\n    }\r\n    \r\n    function govStartGlobalSettlement() public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        inGlobalSettlement = true;\r\n        globalSettlementStartTime = block.timestamp;\r\n    }\r\n    \r\n    \r\n    \r\n    // Vault Functions\r\n    function depositWEI() public payable { // same as receive fallback; but explictily declared for symmetry\r\n        require(msg.value > 0, \"Must Deposit Nonzero Wei\"); \r\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\r\n        \r\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\r\n            isAddressRegistered[msg.sender] = true;\r\n            registeredAddresses.push(msg.sender);\r\n        }\r\n    }\r\n    \r\n    receive() external payable { // same as receive fallback; but explictily declared for symmetry\r\n        require(msg.value > 0, \"Must Deposit Nonzero Wei\"); \r\n        \r\n        // Receiving is automatic so double entry accounting not possible here\r\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\r\n        \r\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\r\n            isAddressRegistered[msg.sender] = true;\r\n            registeredAddresses.push(msg.sender);\r\n        }\r\n    }\r\n\r\n    function withdrawWEI(uint _weiWithdraw) public {  // NB: Security model is against msg.sender\r\n        // presuming contract withdrawal is from own vault\r\n        require( _weiWithdraw < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        // Maintenence Equation: (vSYMDebtE18/1E18) * weiPervSYM <= (weiAsset) * (initialLTVE10/1E10)\r\n        // I need: (vSYMDebtE18)/1E18 * weiPervSYM <= (weiAsset - _weiWithdraw) * (initialLTVE10/1E10)\r\n        uint LHS = vSYMDebtE18[msg.sender].mul( weiPervSYM ).mul( 10 ** 10 );\r\n        uint RHS = (weiAsset[msg.sender].sub( _weiWithdraw )).mul( initialLTVE10 ).mul( 10 ** 18 );\r\n        require ( LHS <= RHS, \"Your initial margin is insufficient for withdrawing.\");\r\n        \r\n        // Double Entry Accounting\r\n        weiAsset[msg.sender] = weiAsset[msg.sender].sub( _weiWithdraw ); // penalize wei deposited before sending money out\r\n        msg.sender.transfer(_weiWithdraw);\r\n    }\r\n    \r\n    \r\n    function lendvSYM(uint _vSYMLendE18) public {\r\n        //presuming message sender is using his own vault\r\n        require(_vSYMLendE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        require(outstandingvSYME18.add( _vSYMLendE18 ) <= maxvSYME18, \"Current version limits max amount of vSYM possible\");\r\n        \r\n        // Maintenence Equation: (vSYMDebtE18/1E18) * weiPervSYM <= (weiAsset) * (initialLTVE10/1E10)\r\n        // I need: (_vSYMLendE18 + vSYMDebtE18)/1E18 * weiPervSYM  < weiAsset * (initialLTVE10/1E10)\r\n        uint LHS = vSYMDebtE18[msg.sender].add( _vSYMLendE18 ).mul( weiPervSYM ).mul( 10 ** 10 );\r\n        uint RHS = weiAsset[msg.sender].mul( initialLTVE10 ).mul( 10 ** 18 );\r\n        require(LHS < RHS, \"Your initial margin is insufficient for lending\");\r\n        \r\n        // Double Entry Accounting\r\n        vSYMDebtE18[msg.sender] = vSYMDebtE18[msg.sender].add( _vSYMLendE18 ); // penalize debt first.\r\n        outstandingvSYME18 = outstandingvSYME18.add(_vSYMLendE18);\r\n        vSYMToken.transfer(msg.sender, _vSYMLendE18);\r\n    }\r\n    \r\n    function repayvSYM(uint _vSYMRepayE18) public {\r\n        require(_vSYMRepayE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        vSYMToken.ownerApprove(msg.sender, _vSYMRepayE18); \r\n        \r\n        // Double Entry Accounting\r\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMRepayE18); // the actual deduction from the token contract\r\n        vSYMDebtE18[msg.sender] = vSYMDebtE18[msg.sender].sub( _vSYMRepayE18 );\r\n        outstandingvSYME18 = outstandingvSYME18.sub(_vSYMRepayE18);\r\n    }\r\n    \r\n    \r\n    function liquidateNonCompliant(uint _vSYMProvidedE18, address payable target_address) public { // liquidates a portion of the contract for non-compliance\r\n\r\n        // While it possible to have a more complex liquidation system, since liqudations are off-equilibrium, for the MVP \r\n        // We have decided we want overly aggressive liqudiations \r\n        \r\n        // Maintenence Equation: (vSYMDebtE18/1E18) * weiPervSYM <= (weiAsset) * (maintLTVE10/1E10)\r\n        // For a violation, the above will be flipped: (vSYMDebtE18/1E18) * weiPervSYM > (weiAsset) * (maintLTVE10/1E10)\r\n        \r\n        require( _vSYMProvidedE18 <= vSYMDebtE18[target_address], \"You cannot provide more vSYM than vSYMDebt outstanding\");\r\n        \r\n        uint LHS = vSYMDebtE18[target_address].mul( weiPervSYM ).mul( 10 ** 10);\r\n        uint RHS = weiAsset[target_address].mul( maintLTVE10 ).mul( 10 ** 18);\r\n        require(LHS > RHS, \"Current contract is within maintainance margin, so you cannot run this\");\r\n        \r\n        \r\n\r\n        \r\n        \r\n        // If this vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata\r\n        // underater iff: weiAsset[target_address] < vSYMDebtE18[target_address]/1E18 * weiPervSYM * (liqPenaltyE10+1E10)/1E10\r\n        uint LHS2 = weiAsset[target_address].mul( 10 ** 18 ).mul( 10 ** 10);\r\n        uint RHS2 = vSYMDebtE18[target_address].mul( weiPervSYM ).mul( liqPenaltyE10.add( 10 ** 10 ));\r\n        \r\n        uint weiClaim;\r\n        if( LHS2 < RHS2 ) { // pro-rata claim\r\n            // weiClaim = ( _vSYMProvidedE18 /  vSYMDebtE18[target_address]) * weiAsset[target_address];\r\n            weiClaim = _vSYMProvidedE18.mul( weiAsset[target_address] ).div( vSYMDebtE18[target_address] );\r\n        } else {\r\n            // maxWeiClaim = _vSYMProvidedE18/1E18 * weiPervSYM * (1+liqPenaltyE10/1E10)\r\n            weiClaim = _vSYMProvidedE18.mul( weiPervSYM ).mul( liqPenaltyE10.add( 10 ** 10 )).div( 10 ** 18 ).div( 10 ** 10 );\r\n        }\r\n        require(weiClaim <= weiAsset[target_address], \"Code Error if you reached this point\");\r\n        \r\n        \r\n        // Double Entry Accounting for returning vSYM Debt back\r\n        vSYMToken.ownerApprove(msg.sender, _vSYMProvidedE18); \r\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMProvidedE18); // the actual deduction from the token contract\r\n        vSYMDebtE18[target_address] = vSYMDebtE18[target_address].sub( _vSYMProvidedE18 );\r\n        outstandingvSYME18 = outstandingvSYME18.sub( _vSYMProvidedE18 );\r\n        \r\n        \r\n        // Double Entry Accounting for deducting the vault's assets\r\n        weiAsset[target_address] = weiAsset[target_address].sub( weiClaim );\r\n        msg.sender.transfer( weiClaim );\r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    // Counter Vault Functions\r\n    function depositvSYMCounterVault(uint _vSYMDepositE18) public { \r\n        require( _vSYMDepositE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        // Transfer Tokens from sender, then double-entry account for it\r\n        vSYMToken.ownerApprove(msg.sender, _vSYMDepositE18); \r\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMDepositE18);\r\n        vSYMAssetCounterVaultE18[msg.sender] = vSYMAssetCounterVaultE18[msg.sender].add(_vSYMDepositE18);\r\n        \r\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\r\n            isAddressRegistered[msg.sender] = true;\r\n            registeredAddresses.push(msg.sender);\r\n        }\r\n    }\r\n    \r\n\r\n    function withdrawvSYMCounterVault(uint _vSYMWithdrawE18) public {\r\n        require( _vSYMWithdrawE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        // Master equation for countervault: (weiDebtCounterVault ) < (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (initialLTVCounterVaultE10/1E10) \r\n        // I need: (weiDebtCounterVault ) < (vSYMAssetCounterVaultE18 - _vSYMLendE18)/1E18 * weiPervSYM * (initialLTVCounterVaultE10/1E10) \r\n        uint LHS = weiDebtCounterVault[msg.sender].mul( 10 ** 10 ).mul( 10 ** 18 );\r\n        uint RHS = vSYMAssetCounterVaultE18[msg.sender].sub( _vSYMWithdrawE18 ).mul( weiPervSYM ).mul( initialLTVCounterVaultE10 );\r\n        require ( LHS <= RHS, 'Your initial margin is insufficient for withdrawing.' );\r\n        \r\n        vSYMAssetCounterVaultE18[msg.sender] =  vSYMAssetCounterVaultE18[msg.sender].sub( _vSYMWithdrawE18 ); // Penalize Account First\r\n        vSYMToken.transfer(msg.sender, _vSYMWithdrawE18);\r\n    }\r\n    \r\n    \r\n    function lendWeiCounterVault(uint _weiLend) public {\r\n        //presuming message sender is using his own vault\r\n        require(_weiLend < 10 ** 30, \"Protective Max Bound for Input Hit\");\r\n\r\n        // Master equation for countervault: (weiDebtCounterVault ) < (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (initialLTVCounterVaultE10/1E10) \r\n        // I need: (weiDebtCounterVault + _weiWithdraw ) < weiPervSYM * (vSYMAssetCounterVaultE18/1E18) * (initialLTVCounterVaultE10/1E10) \r\n        \r\n        uint LHS = weiDebtCounterVault[msg.sender].add( _weiLend ).mul( 10** 18 ).mul( 10 ** 10 );\r\n        uint RHS = weiPervSYM.mul( vSYMAssetCounterVaultE18[msg.sender] ).mul( initialLTVCounterVaultE10 );\r\n        \r\n        require(LHS <= RHS, \"Your initial margin is insufficient for lending.\");\r\n        \r\n        // Double-entry accounting\r\n        weiDebtCounterVault[msg.sender] = weiDebtCounterVault[msg.sender].add( _weiLend );    // penalize debt first.\r\n        msg.sender.transfer(_weiLend);\r\n    }\r\n    \r\n    function repayWeiCounterVault() public payable {\r\n        require(msg.value < 10 ** 30, \"Protective Max Bound for Input Hit\");\r\n        require(msg.value <= weiDebtCounterVault[msg.sender], \"You cannot pay down more Wei debt than exists in this counterVault\");\r\n        \r\n        // Single entry accounting\r\n        weiDebtCounterVault[msg.sender] = weiDebtCounterVault[msg.sender].sub( msg.value );\r\n    }\r\n    \r\n    \r\n\r\n\r\n    \r\n\r\n    function liquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public { // liquidates a portion of the counterVault for non-compliance\r\n        \r\n        // Security Presumption here is against favor of the runner of this function\r\n        require( msg.value < 10 ** 30 , \"Protective Max Bound for WEI Hit\");\r\n        require( msg.value <= weiDebtCounterVault[_targetCounterVault], \"You cannot provide more Wei than Wei debt outstanding\");\r\n        \r\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) > (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\r\n        uint LHS = weiDebtCounterVault[_targetCounterVault].mul( 10 ** 18 ).mul( 10 ** 10 );\r\n        uint RHS = vSYMAssetCounterVaultE18[_targetCounterVault].mul( weiPervSYM ).mul( maintLTVCounterVaultE10 );\r\n        emit loguint(\"RHS\", RHS);\r\n        emit loguint(\"LHS\", LHS);\r\n        \r\n        require(LHS > RHS, \"Current contract is within maintenence margin\");\r\n        \r\n        \r\n        // If this Counter Vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata  \r\n        // underater iff: vSYMAssetCounterVaultE18[_targetCounterVault] <  (weiDebtCounterVault[_targetCounterVault]/ weiPervSYM) * 1E18 * (liqPenaltyCounterVaultE10+1E10)/1E10\r\n        uint LHS2 = vSYMAssetCounterVaultE18[_targetCounterVault];\r\n        uint RHS2 = weiDebtCounterVault[_targetCounterVault].mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div( weiPervSYM );\r\n        \r\n        emit loguint(\"RHS2\", RHS2);\r\n        emit loguint(\"LHS2\", LHS2);\r\n        \r\n        uint vSYMClaimE18;\r\n        if( LHS2 < RHS2 ) { // if vault is rewards-underwater, pro-rate\r\n            // vSYMClaimE18 = ( msg.value /  weiDebtCounterVault[_targetCounterVault]) * vSYMAssetCounterVaultE18[_targetCounterVault];\r\n            vSYMClaimE18 = msg.value.mul( vSYMAssetCounterVaultE18[_targetCounterVault] ).div( weiDebtCounterVault[_targetCounterVault] );\r\n            require(vSYMClaimE18 <= vSYMAssetCounterVaultE18[_targetCounterVault], \"Code Error Branch 1 if you reached this point\");\r\n        } else { // if we have more than enough assets in this countervault\r\n            // vSYMClaimE18 = (msg.value / weiPervSYM) * 1E18 * (1E10+liqPenaltyE10) /1E10\r\n            vSYMClaimE18 = msg.value.mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div(weiPervSYM) ;\r\n            require(vSYMClaimE18 <= vSYMAssetCounterVaultE18[_targetCounterVault], \"Code Error Branch 2 if you reached this point\");\r\n            \r\n        }\r\n        \r\n        \r\n        // Single Entry Accounting for Returning the wei Debt\r\n        weiDebtCounterVault[_targetCounterVault] = weiDebtCounterVault[_targetCounterVault].sub( msg.value );\r\n        \r\n\r\n        // Double Entry Accounting\r\n        vSYMAssetCounterVaultE18[_targetCounterVault] = vSYMAssetCounterVaultE18[_targetCounterVault].sub( vSYMClaimE18 ); // Amount of Assets to Transfer override\r\n        vSYMToken.transfer( msg.sender , vSYMClaimE18 );\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function partial1LiquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public returns(uint, uint)  { // liquidates a portion of the counterVault for non-compliance\r\n        \r\n        // Security Presumption here is against favor of the runner of this function\r\n        require( msg.value < 10 ** 30 , \"Protective Max Bound for WEI Hit\");\r\n        require( msg.value <= weiDebtCounterVault[_targetCounterVault], \"You cannot provide more Wei than Wei debt outstanding\");\r\n        \r\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) > (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\r\n        uint LHS = weiDebtCounterVault[_targetCounterVault].mul( 10 ** 18 ).mul( 10 ** 10 );\r\n        uint RHS = vSYMAssetCounterVaultE18[_targetCounterVault].mul( weiPervSYM ).mul( maintLTVCounterVaultE10 );\r\n        \r\n        require(LHS > RHS, \"Current contract is within maintenence margin\");\r\n        \r\n        return(LHS, RHS);\r\n        \r\n    }\r\n    \r\n    \r\n    function partial2LiquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public returns(uint, uint)  { // liquidates a portion of the counterVault for non-compliance\r\n        \r\n        // Security Presumption here is against favor of the runner of this function\r\n        require( msg.value < 10 ** 30 , \"Protective Max Bound for WEI Hit\");\r\n        require( msg.value <= weiDebtCounterVault[_targetCounterVault], \"You cannot provide more Wei than Wei debt outstanding\");\r\n        \r\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) > (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\r\n\r\n        \r\n        \r\n        // If this Counter Vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata  \r\n        // underater iff: vSYMAssetCounterVaultE18[_targetCounterVault] <  (weiDebtCounterVault[_targetCounterVault]/ weiPervSYM) * 1E18 * (liqPenaltyCounterVaultE10+1E10)/1E10\r\n        uint LHS2 = vSYMAssetCounterVaultE18[_targetCounterVault];\r\n        uint RHS2 = weiDebtCounterVault[_targetCounterVault].mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div( weiPervSYM );\r\n        return(LHS2, RHS2);\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function findNoncompliantVaults(uint _limitNum) public view returns(address[] memory, uint[] memory, uint[] memory, uint[] memory, uint[] memory, uint) {   // Return the first N noncompliant vaults\r\n        require(_limitNum > 0, 'Must run this on a positive integer');\r\n        address[] memory noncompliantAddresses = new address[](_limitNum);\r\n        uint[] memory LHSs_vault = new uint[](_limitNum);\r\n        uint[] memory RHSs_vault = new uint[](_limitNum);\r\n        \r\n        uint[] memory LHSs_counterVault = new uint[](_limitNum);\r\n        uint[] memory RHSs_counterVault = new uint[](_limitNum);\r\n        \r\n        \r\n        uint j = 0;  // Iterator up to _limitNum\r\n        for (uint i=0; i<registeredAddresses.length; i++) {\r\n            if(j>= _limitNum) {\r\n                break;\r\n            } \r\n            // Vault maintainance margin violation: (vSYMDebtE18)/1E18 * weiPervSYM  > weiAsset * (maintLTVE10)/1E10 for a violation\r\n            uint LHS_vault = vSYMDebtE18[registeredAddresses[i]].mul(weiPervSYM);\r\n            uint RHS_vault  = weiAsset[registeredAddresses[i]].mul( maintLTVE10 ).mul( 10 ** 8);\r\n            \r\n            \r\n            // Countervault maintenance margin violation:  (weiDebtCounterVault ) > (vSYMAssetCounterVaultE18)/1E18 * weiPervSYM * (maintLTVE10InverseVault/1E10)\r\n            uint LHS_counterVault = weiDebtCounterVault[registeredAddresses[i]].mul( 10 ** 18 ).mul( 10 ** 10 );\r\n            uint RHS_counterVault = vSYMAssetCounterVaultE18[registeredAddresses[i]].mul( weiPervSYM ).mul( maintLTVCounterVaultE10 );\r\n            \r\n            if( (LHS_vault > RHS_vault) || (LHS_counterVault > RHS_counterVault) ) {\r\n                noncompliantAddresses[j] = registeredAddresses[i];\r\n                LHSs_vault[j] = LHS_vault;\r\n                RHSs_vault[j] = RHS_vault;\r\n                LHSs_counterVault[j] = LHS_counterVault;\r\n                RHSs_counterVault[j] = RHS_counterVault;\r\n\r\n                j = j + 1;\r\n            }\r\n        }\r\n        return(noncompliantAddresses, LHSs_vault, RHSs_vault, LHSs_counterVault, RHSs_counterVault,  j);\r\n    }\r\n    \r\n\r\n    // The following functions are off off-equilibrium.  Thus they are vetted to be safe, but not necessarily efficient/optimal.\r\n\r\n\r\n    // Global Settlement Functions\r\n    function registerGloballySettled() public { // Anyone can run this closing function\r\n        require(inGlobalSettlement, \"Register function can only be run if governance has declared global settlement\");\r\n        require(block.timestamp > (globalSettlementStartTime + 14 days), \"Need to wait 14 days to finalize global settlement\");\r\n        require(!isGloballySettled, \"This function has already be run; can only be run once.\");\r\n        settledWeiPervSYM = weiPervSYM;\r\n        isGloballySettled = true;\r\n    }\r\n    \r\n    function settledConvertvSYMtoWei(uint _vSYMTokenToConvertE18) public {\r\n        require(isGloballySettled);\r\n        require(_vSYMTokenToConvertE18 < 10 ** 30, \"Protective max bound for input hit\");\r\n        \r\n        uint weiToReturn = _vSYMTokenToConvertE18.mul( settledWeiPervSYM ).div( 10 ** 18); // Rounds down\r\n        \r\n        // vSYM accounting is no longer double entry.  Destroy vSYM to get wei\r\n        vSYMToken.ownerApprove(msg.sender, _vSYMTokenToConvertE18);                     // Factory gives itself approval\r\n        vSYMToken.transferFrom(msg.sender, address(this), _vSYMTokenToConvertE18);    // the actual deduction from the token contract\r\n        msg.sender.transfer(weiToReturn);                                           // return wei\r\n    }\r\n    \r\n    \r\n    function settledConvertVaulttoWei() public {\r\n        require(isGloballySettled);\r\n        \r\n        uint weiDebt = vSYMDebtE18[msg.sender].mul( settledWeiPervSYM ).div( 10 ** 18).add( 1 );               // Round up value of debt\r\n        require(weiAsset[msg.sender] > weiDebt, \"This CTV is not above water, cannot convert\");     \r\n        \r\n        uint weiEquity = weiAsset[msg.sender] - weiDebt;\r\n        \r\n        \r\n        // Zero out CTV and transfer equity remaining\r\n        vSYMDebtE18[msg.sender] = 0;\r\n        weiAsset[msg.sender] = 0;\r\n        msg.sender.transfer(weiEquity);  \r\n    }\r\n\r\n    \r\n\r\n    // Challenge Functions -- non-optimized\r\n    function startChallengeWeiPervSYM(uint _proposedWeiPervSYM, uint _ivtStaked) public {\r\n        // Checking we're in the right state\r\n        require(lastOracleTime > 0, \"Cannot challenge a newly created smart contract\");\r\n        require(block.timestamp.sub( lastOracleTime ) > 14 days, \"You must wait for the whitelist oracle to not respond for 14 days\" );\r\n        require(_ivtStaked >= 10 * 10 ** 18, 'You must challenge with at least ten IVT');\r\n        require(_proposedWeiPervSYM != weiPervSYM, 'You do not disagree with current value of weiPervSYM');\r\n        require(oracleChallenged == false);\r\n        \r\n        \r\n        // Deducting tokens and crediting\r\n        uint256 allowance = ivtToken.allowance(msg.sender, address(this));\r\n        require(allowance >= _ivtStaked, 'You have not allowed this contract access to the number of IVTs you claim');\r\n        ivtToken.transferFrom(msg.sender, address(this), _ivtStaked); // the actual deduction from the token contract\r\n        \r\n        // Credit this challenger\r\n        challengers.push(msg.sender);\r\n        \r\n        // Start the challenge\r\n        oracleChallenged = true;\r\n        challengeValues.push(_proposedWeiPervSYM);\r\n        challengeIVTokens.push(_ivtStaked);\r\n        lastChallengeValue = _proposedWeiPervSYM;\r\n        lastChallengeTime = block.timestamp;\r\n    }\r\n    \r\n    function rechallengeWeiPervSYM(uint _proposedWeiPervSYM, uint _ivtStaked) public {\r\n        require(oracleChallenged == true, \"rechallenge cannot be run if challenge has not started.  consider startChallengeWeiPervSYM()\");\r\n        require(_ivtStaked >= lastChallengeIVT * 2, \"You must double the IVT from the last challenge\");\r\n        require(_proposedWeiPervSYM != lastChallengeValue, \"You do not disagree with last challenge of weiPervSYM\");\r\n        \r\n        \r\n        // Deducting tokens and crediting\r\n        uint256 allowance = ivtToken.allowance(msg.sender, address(this));\r\n        require(allowance >= _ivtStaked, 'You have not allowed this contract access to the number of WATs you claim');\r\n        ivtToken.transferFrom(msg.sender, address(this), _ivtStaked); // the actual deduction from the token contract\r\n        \r\n        // Credit this challenger\r\n        challengers.push(msg.sender);\r\n        \r\n        // Actually do the challenge\r\n        challengeValues.push(_proposedWeiPervSYM);\r\n        challengeIVTokens.push(_ivtStaked);\r\n        lastChallengeValue = _proposedWeiPervSYM;\r\n        lastChallengeTime = block.timestamp;\r\n        lastChallengeIVT = _ivtStaked;\r\n    }\r\n    \r\n    function endChallegeWeiPerSPX() public {\r\n        require(oracleChallenged == true, \"Consider startChallengeWeiPervSYM()\");\r\n        require(block.timestamp.sub( lastChallengeTime ) > 2 days, \"You must wait 2 days since the last challenge to end the challenge\");\r\n        \r\n        // This now makes effective the challenge oracle\r\n        weiPervSYM = lastChallengeValue;\r\n        \r\n        // initialize cumulative counter of correct vs incorrect wats\r\n        uint incorrectIvts = 0;\r\n        uint correctIvts = 0; \r\n        \r\n        // calculate the payback ratio\r\n        for(uint i = 0; i < challengeIVTokens.length; i++) {\r\n            if(challengeValues[i] == weiPervSYM) {\r\n                correctIvts += challengeIVTokens[i];\r\n            } else {\r\n                incorrectIvts += challengeIVTokens[i];\r\n            }\r\n        }\r\n        \r\n        // Distribute the tokens\r\n        for(uint i = 0; i < challengeIVTokens.length; i++) {  //NB -- this should not be very long due to block gas limits\r\n            if(challengeValues[i] == weiPervSYM) {\r\n                uint toTransfer =  incorrectIvts.add(correctIvts).mul( challengeIVTokens[i] ).div( correctIvts );\r\n                \r\n                // best practice: remove this person's credit first\r\n                challengeIVTokens[i] = 0;\r\n                vSYMToken.transfer(challengers[i], toTransfer);\r\n            } else {\r\n                // erase the challengeIVTokens\r\n                challengeIVTokens[i] = 0;\r\n            }\r\n        }\r\n        \r\n        // reset arrays to zero type\r\n        delete challengeIVTokens;\r\n        delete challengeValues;\r\n        delete challengers;\r\n        \r\n        lastChallengeValue = 0;\r\n        lastChallengeIVT = 0;\r\n        lastChallengeTime = 0;\r\n        \r\n        // end challenge\r\n        oracleChallenged = false;\r\n    }\r\n\r\n\r\n    function detachOwner() public { // an emergency function to commitally shut off the owner account while retaining residual functionality of tokens\r\n        require(msg.sender == owner);\r\n        initialLTVE10 = 4 * 10 ** 9; // 40% LTV at start\r\n        maintLTVE10 = 5 * 10 ** 9; // 50% LTV to maintain\r\n        liqPenaltyE10 = 15 * 10 ** 8; // 15% liquidation penalty\r\n        oracle = address(0);\r\n        owner = address(0);\r\n    }\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n"}}}