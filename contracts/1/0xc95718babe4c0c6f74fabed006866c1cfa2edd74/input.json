{"language":"Solidity","sources":{"LendingPair.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity 0.8.6;\n\nimport \"IERC20.sol\";\nimport \"IERC721.sol\";\nimport \"ICallee.sol\";\nimport \"ILendingPair.sol\";\nimport \"ILPTokenMaster.sol\";\nimport \"ILendingController.sol\";\nimport \"IUniswapV3Helper.sol\";\nimport \"INonfungiblePositionManagerSimple.sol\";\n\nimport \"Math.sol\";\nimport \"Clones.sol\";\nimport \"ReentrancyGuard.sol\";\nimport \"AddressLibrary.sol\";\n\nimport \"LPTokenMaster.sol\";\n\nimport \"ERC721Receivable.sol\";\nimport \"TransferHelper.sol\";\n\ncontract LendingPair is ILendingPair, ReentrancyGuard, TransferHelper, ERC721Receivable {\n\n  INonfungiblePositionManagerSimple internal constant positionManager = INonfungiblePositionManagerSimple(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  IERC721 internal constant uniPositions = IERC721(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  uint    public   constant LIQ_MIN_HEALTH = 1e18;\n  uint    private  constant MIN_DECIMALS = 6;\n\n  using AddressLibrary for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public override supplySharesOf;\n  mapping (address => mapping (address => uint)) public debtSharesOf;\n  mapping (address => uint) public override pendingSystemFees;\n  mapping (address => uint) public lastBlockAccrued;\n  mapping (address => uint) public override totalSupplyShares;\n  mapping (address => uint) public override totalSupplyAmount;\n  mapping (address => uint) public override totalDebtShares;\n  mapping (address => uint) public override totalDebtAmount;\n  mapping (address => uint) public uniPosition;\n  mapping (address => uint) private decimals;\n  mapping (address => address) public override lpToken;\n\n  IUniswapV3Helper   private uniV3Helper;\n  ILendingController public  lendingController;\n\n  address public feeRecipient;\n  address public override tokenA;\n  address public override tokenB;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed account, address indexed token, uint amount);\n  event Borrow(address indexed account, address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n  event CollectSystemFee(address indexed token, uint amount);\n  event DepositUniPosition(address indexed account, uint positionID);\n  event WithdrawUniPosition(address indexed account, uint positionID);\n\n  modifier onlyLpToken() {\n    require(lpToken[tokenA] == msg.sender || lpToken[tokenB] == msg.sender, \"LendingController: caller must be LP token\");\n    _;\n  }\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external override {\n    require(tokenA == address(0), \"LendingPair: already initialized\");\n\n    lendingController = ILendingController(_lendingController);\n    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);\n    feeRecipient      = _feeRecipient;\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    lastBlockAccrued[tokenA] = block.number;\n    lastBlockAccrued[tokenB] = block.number;\n\n    decimals[tokenA] = IERC20(tokenA).decimals();\n    decimals[tokenB] = IERC20(tokenB).decimals();\n\n    require(decimals[tokenA] >= MIN_DECIMALS && decimals[tokenB] >= MIN_DECIMALS, \"LendingPair: MIN_DECIMALS\");\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);\n  }\n\n  function operate(\n    uint[] calldata _actions,\n    bytes[] calldata _data\n  ) external override payable nonReentrant {\n\n    if (msg.value > 0) {\n      _depositWeth();\n      _safeTransfer(address(WETH), msg.sender, msg.value);\n    }\n\n    bool needReserveCheck = false;\n\n    for (uint i = 0; i < _actions.length; i++) {\n\n      if (_actions[i] == 0) {\n        (address account, uint positionID) = abi.decode(_data[i], (address, uint));\n        _depositUniPosition(account, positionID);\n      }\n\n      else if (_actions[i] == 1) {\n        _withdrawUniPosition();\n        needReserveCheck = true;\n      }\n\n      else if (_actions[i] == 2) {\n        (address account, address token, uint amount) = abi.decode(_data[i], (address, address, uint));\n        _deposit(account, token, amount);\n      }\n\n      else if (_actions[i] == 3) {\n        (address recipient, address token, uint amount) = abi.decode(_data[i], (address, address, uint));\n        _withdraw(recipient, token, amount);\n        needReserveCheck = true;\n      }\n\n      else if (_actions[i] == 4) {\n        (address recipient, address token) = abi.decode(_data[i], (address, address));\n        _withdrawAll(recipient, token);\n        needReserveCheck = true;\n      }\n\n      else if (_actions[i] == 5) {\n        (address recipient, address token, uint amount) = abi.decode(_data[i], (address, address, uint));\n        _borrow(recipient, token, amount);\n        needReserveCheck = true;\n      }\n\n      else if (_actions[i] == 6) {\n        (address account, address token, uint maxAmount) = abi.decode(_data[i], (address, address, uint));\n        _repay(account, token, maxAmount);\n      }\n\n      else if (_actions[i] == 7) {\n        (address account, address repayToken, uint repayAmount) = abi.decode(_data[i], (address, address, uint));\n        _liquidateAccount(account, repayToken, repayAmount);\n        needReserveCheck = true;\n      }\n\n      else if (_actions[i] == 8) {\n        (address callee, bytes memory data) = abi.decode(_data[i], (address, bytes));\n        _call(callee, data);\n      }\n\n      else {\n        revert(\"LendingPair: unknown action\");\n      }\n    }\n\n    if (needReserveCheck) {\n      checkAccountHealth(msg.sender);\n      _checkReserve(tokenA);\n      _checkReserve(tokenB);\n    }\n  }\n\n  function depositUniPosition(address _account, uint _positionID) external nonReentrant {\n    _depositUniPosition(_account, _positionID);\n  }\n\n  function withdrawUniPosition() external nonReentrant {\n    _withdrawUniPosition();\n    checkAccountHealth(msg.sender);\n  }\n\n  function deposit(address _account, address _token, uint _amount) external nonReentrant {\n    _deposit(_account, _token, _amount);\n  }\n\n  function withdraw(address _recipient, address _token, uint _amount) external nonReentrant {\n    _withdraw(_recipient, _token, _amount);\n    checkAccountHealth(msg.sender);\n    _checkReserve(_token);\n  }\n\n  function withdrawAll(address _recipient, address _token) external nonReentrant {\n    _withdrawAll(_recipient, _token);\n    checkAccountHealth(msg.sender);\n    _checkReserve(_token);\n  }\n\n  function borrow(address _recipient, address _token, uint _amount) external nonReentrant {\n    _borrow(_recipient, _token, _amount);\n    checkAccountHealth(msg.sender);\n    _checkReserve(_token);\n  }\n\n  function repay(address _account, address _token, uint _maxAmount) external nonReentrant {\n    _repay(_account, _token, _maxAmount);\n  }\n\n  function liquidateAccount(address _account, address _repayToken, uint _repayAmount) external nonReentrant {\n    _liquidateAccount(_account, _repayToken, _repayAmount);\n    checkAccountHealth(msg.sender);\n    _checkReserve(tokenA);\n    _checkReserve(tokenB);\n  }\n\n  function accrue(address _token) public {\n    if (lastBlockAccrued[_token] < block.number) {\n      uint newDebt   = _accrueDebt(_token);\n      uint newSupply = newDebt * _lpRate() / 100e18;\n      totalSupplyAmount[_token] += newSupply;\n\n      // '-1' helps prevent _checkReserve fails due to rounding errors\n      uint newFees = (newDebt - newSupply) == 0 ? 0 : (newDebt - newSupply - 1);\n      pendingSystemFees[_token] += newFees;\n\n      lastBlockAccrued[_token] = block.number;\n    }\n  }\n\n  function collectSystemFee(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    pendingSystemFees[_token] -= _amount;\n    _safeTransfer(_token, feeRecipient, _amount);\n    _checkReserve(_token);\n    emit CollectSystemFee(_token, _amount);\n  }\n\n  function transferLp(address _token, address _from, address _to, uint _amount) external override onlyLpToken {\n    require(debtSharesOf[_token][_to] == 0, \"LendingPair: cannot receive borrowed token\");\n    supplySharesOf[_token][_from] -= _amount;\n    supplySharesOf[_token][_to]   += _amount;\n    checkAccountHealth(_from);\n  }\n\n  function accountHealth(address _account) external view returns(uint) {\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n    return _accountHealth(_account, priceA, priceB);\n  }\n\n  function debtOf(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _debtOf(_token, _account);\n  }\n\n  function supplyOf(address _token, address _account) external view override returns(uint) {\n    _validateToken(_token);\n    return _supplyOf(_token, _account);\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    (uint borrowPrice, uint returnPrice) = lendingController.tokenPrices(_borrowedToken, _returnToken);\n    return _borrowBalanceConverted(_account, _borrowedToken, _returnToken, borrowPrice, returnPrice);\n  }\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view override returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    (uint supplyPrice, uint returnPrice) = lendingController.tokenPrices(_suppliedToken, _returnToken);\n    return _supplyBalanceConverted(_account, _suppliedToken, _returnToken, supplyPrice, returnPrice);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    if (totalSupplyAmount[_token] == 0 || totalDebtAmount[_token] == 0) { return 0; }\n    return _interestRatePerBlock(_token) * utilizationRate(_token) * _lpRate() / 100e18 / 100e18;\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token);\n  }\n\n  function utilizationRate(address _token) public view returns(uint) {\n    uint totalSupply = totalSupplyAmount[_token];\n    uint totalDebt = totalDebtAmount[_token];\n    if (totalSupply == 0 || totalDebt == 0) { return 0; }\n    return Math.min(totalDebt * 100e18 / totalSupply, 100e18);\n  }\n\n  function checkAccountHealth(address _account) public view {\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n    uint health = _accountHealth(_account, priceA, priceB);\n    require(health >= LIQ_MIN_HEALTH, \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    (uint fromPrice, uint toPrice) = lendingController.tokenPrices(_fromToken, _toToken);\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount, fromPrice, toPrice);\n  }\n\n  // Deposit limits do not apply to Uniswap positions\n  function _depositUniPosition(address _account, uint _positionID) internal {\n    _validateUniPosition(_positionID);\n    require(_positionID > 0, \"LendingPair: invalid position\");\n    require(uniPosition[_account] == 0, \"LendingPair: one position per account\");\n\n    uniPositions.safeTransferFrom(msg.sender, address(this), _positionID);\n    uniPosition[_account] = _positionID;\n\n    emit DepositUniPosition(_account, _positionID);\n  }\n\n  function _withdrawUniPosition() internal {\n    uint positionID = uniPosition[msg.sender];\n    require(positionID > 0, \"LendingPair: nothing to withdraw\");\n    uniPositions.safeTransferFrom(address(this), msg.sender, positionID);\n    uniPosition[msg.sender] = 0;\n\n    accrue(tokenA);\n    accrue(tokenB);\n\n    emit WithdrawUniPosition(msg.sender, positionID);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n    _validateToken(_token);\n    accrue(_token);\n\n    require(debtSharesOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _checkDepositLimit(_token, _amount);\n    _mintSupplyAmount(_token, _account, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _withdraw(address _recipient, address _token, uint _amount) internal {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawShares(_token, _supplyToShares(_token, _amount));\n    _transferAsset(_token, _recipient, _amount);\n  }\n\n  function _borrow(address _recipient, address _token, uint _amount) internal {\n    _validateToken(_token);\n    accrue(_token);\n\n    require(supplySharesOf[_token][msg.sender] == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _checkBorrowLimits(_token, msg.sender, _amount);\n    _mintDebtAmount(_token, msg.sender, _amount);\n    _transferAsset(_token, _recipient, _amount);\n\n    emit Borrow(msg.sender, _token, _amount);\n  }\n\n  function _withdrawAll(address _recipient, address _token) internal {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint shares = supplySharesOf[_token][msg.sender];\n    uint amount = _sharesToSupply(_token, shares);\n    _withdrawShares(_token, shares);\n    _transferAsset(_token, _recipient, amount);\n  }\n\n  function _repay(address _account, address _token, uint _maxAmount) internal {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint maxShares    = _debtToShares(_token, _maxAmount);\n    uint sharesAmount = Math.min(debtSharesOf[_token][_account], maxShares);\n    uint repayAmount  = _repayShares(_account, _token, sharesAmount);\n\n    _safeTransferFrom(_token, msg.sender, repayAmount);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to type(uint).max to repay all debt, inc. pending interest\n  function _liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount\n  ) internal {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    accrue(supplyToken);\n    accrue(_repayToken);\n\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n\n    uint health = _accountHealth(_account, priceA, priceB);\n    require(health < LIQ_MIN_HEALTH, \"LendingPair: account health < LIQ_MIN_HEALTH\");\n\n    // Fully unwrap Uni position - withdraw & mint supply\n\n    _unwrapUniPosition(_account, priceA, priceB);\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, _debtOf(_repayToken, _account));\n\n    // Avoiding stack too deep error\n    uint supplyDebt = _convertTokenValues(\n      _repayToken,\n      supplyToken,\n      _repayAmount,\n      _repayToken == tokenA ? priceA : priceB, // repayPrice\n      supplyToken == tokenA ? priceA : priceB  // supplyPrice\n    );\n\n    uint callerFee    = supplyDebt * lendingController.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * lendingController.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    // Adjust balances\n\n    _burnSupplyShares(supplyToken, _account, _supplyToShares(supplyToken, supplyBurn));\n    pendingSystemFees[supplyToken] += systemFee;\n    _burnDebtShares(_repayToken, _account, _debtToShares(_repayToken, _repayAmount));\n\n    // Uni position unwrapping can mint supply of already borrowed tokens\n\n    _repayDebtFromSupply(_account, tokenA);\n    _repayDebtFromSupply(_account, tokenB);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _mintSupplyAmount(supplyToken, msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function _call(address _callee, bytes memory _data) internal {\n    ICallee(_callee).wildCall(_data);\n  }\n\n  // Uses price oracle to estimate min outputs to reduce MEV\n  // Liquidation might be temporarily unavailable due to this\n  function _unwrapUniPosition(address _account, uint _priceA, uint _priceB) internal {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint amount0, uint amount1) = _positionAmounts(uniPosition[_account], _priceA, _priceB);\n      uint uniMinOutput = lendingController.uniMinOutputPct();\n\n      uniPositions.approve(address(uniV3Helper), uniPosition[_account]);\n      (uint amountA, uint amountB) = uniV3Helper.removeLiquidity(\n        uniPosition[_account],\n        amount0 * uniMinOutput / 100e18,\n        amount1 * uniMinOutput / 100e18\n      );\n      uniPosition[_account] = 0;\n\n      _mintSupplyAmount(tokenA, _account, amountA);\n      _mintSupplyAmount(tokenB, _account, amountB);\n    }\n  }\n\n  // Ensure we never have borrow + supply balances of the same token on the same account\n  function _repayDebtFromSupply(address _account, address _token) internal {\n\n    uint burnAmount = Math.min(_debtOf(_token, _account), _supplyOf(_token, _account));\n\n    if (burnAmount > 0) {\n      _burnDebtShares(_token, _account, _debtToShares(_token, burnAmount));\n      _burnSupplyShares(_token, _account, _supplyToShares(_token, burnAmount));\n    }\n  }\n\n  function _mintSupplyAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _supplyToShares(_token, _amount);\n      supplySharesOf[_token][_account] += shares;\n      totalSupplyShares[_token] += shares;\n      totalSupplyAmount[_token] += _amount;\n    }\n  }\n\n  function _burnSupplyShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      // Fix rounding error which can make issues during depositRepay / withdrawBorrow\n      if (supplySharesOf[_token][_account] - _shares == 1) { _shares += 1; }\n      amount = _sharesToSupply(_token, _shares);\n      supplySharesOf[_token][_account] -= _shares;\n      totalSupplyShares[_token] -= _shares;\n      totalSupplyAmount[_token] -= amount;\n    }\n  }\n\n  function _mintDebtAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _debtToShares(_token, _amount);\n      debtSharesOf[_token][_account] += shares;\n      totalDebtShares[_token] += shares;\n      totalDebtAmount[_token] += _amount;\n    }\n  }\n\n  function _burnDebtShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      // Fix rounding error which can make issues during depositRepay / withdrawBorrow\n      if (debtSharesOf[_token][_account] - _shares == 1) { _shares += 1; }\n      amount = _sharesToDebt(_token, _shares);\n      debtSharesOf[_token][_account] -= _shares;\n      totalDebtShares[_token] -= _shares;\n      totalDebtAmount[_token] -= amount;\n    }\n  }\n\n  function _accrueDebt(address _token) internal returns(uint newDebt) {\n    if (totalDebtAmount[_token] > 0) {\n      uint blocksElapsed = block.number - lastBlockAccrued[_token];\n      uint pendingInterestRate = _interestRatePerBlock(_token) * blocksElapsed;\n      newDebt = totalDebtAmount[_token] * pendingInterestRate / 100e18;\n      totalDebtAmount[_token] += newDebt;\n    }\n  }\n\n  function _withdrawShares(address _token, uint _shares) internal {\n    uint amount = _burnSupplyShares(_token, msg.sender, _shares);\n    emit Withdraw(msg.sender, _token, amount);\n  }\n\n  function _repayShares(address _account, address _token, uint _shares) internal returns(uint amount) {\n    amount = _burnDebtShares(_token, _account, _shares);\n    emit Repay(_account, _token, amount);\n  }\n\n  function _transferAsset(address _asset, address _to, uint _amount) internal {\n    if (_asset == address(WETH)) {\n      _wethWithdrawTo(_to, _amount);\n    } else {\n      _safeTransfer(_asset, _to, _amount);\n    }\n  }\n\n  function _createLpToken(address _lpTokenMaster, address _underlying) internal returns(address) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize(_underlying, address(lendingController));\n    return address(newLPToken);\n  }\n\n  // Compare all supply & borrow balances converted into the the same token - tokenA\n  function _accountHealth(address _account, uint _priceA, uint _priceB) internal view returns(uint) {\n\n    if (debtSharesOf[tokenA][_account] == 0 && debtSharesOf[tokenB][_account] == 0) {\n      return LIQ_MIN_HEALTH;\n    }\n\n    uint colFactorA = lendingController.colFactor(tokenA);\n    uint colFactorB = lendingController.colFactor(tokenB);\n\n    uint creditA   = _supplyOf(tokenA, _account) * colFactorA / 100e18;\n    uint creditB   = _supplyBalanceConverted(_account, tokenB, tokenA, _priceB, _priceA) * colFactorB / 100e18;\n    uint creditUni = _convertedCreditAUni(_account, _priceA, _priceB, colFactorA, colFactorB);\n\n    uint totalAccountSupply = creditA + creditB + creditUni;\n\n    uint totalAccountBorrow = _debtOf(tokenA, _account) + _borrowBalanceConverted(_account, tokenB, tokenA, _priceB, _priceA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrow;\n  }\n\n  function _amountToShares(uint _totalShares, uint _totalAmount, uint _inputSupply) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputSupply * _totalShares / _totalAmount;\n    } else {\n      return _inputSupply;\n    }\n  }\n\n  function _sharesToAmount(uint _totalShares, uint _totalAmount, uint _inputShares) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputShares * _totalAmount / _totalShares;\n    } else {\n      return _inputShares;\n    }\n  }\n\n  function _debtToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalDebtShares[_token], totalDebtAmount[_token], _amount);\n  }\n\n  function _sharesToDebt(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalDebtShares[_token], totalDebtAmount[_token], _shares);\n  }\n\n  function _supplyToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalSupplyShares[_token], totalSupplyAmount[_token], _amount);\n  }\n\n  function _sharesToSupply(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalSupplyShares[_token], totalSupplyAmount[_token], _shares);\n  }\n\n  function _debtOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToDebt(_token, debtSharesOf[_token][_account]);\n  }\n\n  function _supplyOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToSupply(_token, supplySharesOf[_token][_account]);\n  }\n\n  // Get borrow balance converted to the units of _returnToken\n  function _borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken,\n    uint    _borrowPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _borrowedToken,\n      _returnToken,\n      _debtOf(_borrowedToken, _account),\n      _borrowPrice,\n      _returnPrice\n    );\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken,\n    uint    _supplyPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _suppliedToken,\n      _returnToken,\n      _supplyOf(_suppliedToken, _account),\n      _supplyPrice,\n      _returnPrice\n    );\n  }\n\n  function _convertedCreditAUni(\n    address _account,\n    uint    _priceA,\n    uint    _priceB,\n    uint    _colFactorA,\n    uint    _colFactorB\n  ) internal view returns(uint) {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint amountA, uint amountB) = _positionAmounts(uniPosition[_account], _priceA, _priceB);\n\n      uint creditA = amountA * _colFactorA / 100e18;\n      uint creditB = _convertTokenValues(tokenB, tokenA, amountB, _priceB, _priceA) * _colFactorB / 100e18;\n\n      return (creditA + creditB);\n\n    } else {\n      return 0;\n    }\n  }\n\n  function _positionAmounts(\n    uint _position,\n    uint _priceA,\n    uint _priceB\n  ) internal view returns(uint, uint) {\n\n    uint priceA = 1 * 10 ** decimals[tokenB];\n    uint priceB = _priceB * 10 ** decimals[tokenA] / _priceA;\n\n    return uniV3Helper.positionAmounts(_position, priceA, priceB);\n  }\n\n  // Not calling priceOracle.convertTokenValues() to save gas by reusing already fetched prices\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount,\n    uint    _fromPrice,\n    uint    _toPrice\n  ) internal view returns(uint) {\n\n    uint fromPrice = _fromPrice * 1e18 / 10 ** decimals[_fromToken];\n    uint toPrice   = _toPrice   * 1e18 / 10 ** decimals[_toToken];\n\n    return _inputAmount * fromPrice / toPrice;\n  }\n\n  // To convert time rate to block rate, use this formula:\n  // annualRate * BLOCK_TIME / (365 * 86400 * 1e18)\n  // where annualRate is in format: 1e18 = 1%\n  function _interestRatePerBlock(address _token) internal view returns(uint) {\n    uint minRate  = 0;\n    uint lowRate  = 8371385083713;   // 20%\n    uint highRate = 418569254185692; // 1,000%\n    uint targetUtilization = 80e18;\n\n    uint totalSupply = totalSupplyAmount[_token];\n    uint totalDebt = totalDebtAmount[_token];\n\n    if (totalSupply == 0 || totalDebt == 0) { return minRate; }\n\n    // Same as: (totalDebt * 100e18 / totalSupply) * 100e18 / targetUtilization\n    uint utilization = totalDebt * 100e18 * 100e18 / totalSupply / targetUtilization;\n\n    if (utilization < 100e18) {\n      uint rate = lowRate * utilization / 100e18;\n      return Math.max(rate, minRate);\n    } else {\n      utilization = 100e18 * ( totalDebt - (totalSupply * targetUtilization / 100e18) ) / (totalSupply * (100e18 - targetUtilization) / 100e18);\n      utilization = Math.min(utilization, 100e18);\n      return lowRate + (highRate - lowRate) * utilization / 100e18;\n    }\n  }\n\n  function _checkReserve(address _token) internal view {\n    IERC20 token = IERC20(_token);\n\n    uint balance = token.balanceOf(address(this));\n    uint debt    = totalDebtAmount[_token];\n    uint supply  = totalSupplyAmount[_token];\n    uint fees    = pendingSystemFees[_token];\n\n    require(int(balance) + int(debt) - int(supply) - int(fees) >= 0, \"LendingPair: reserve check failed\");\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _validateUniPosition(uint _positionID) internal view {\n    (, , address uniTokenA, address uniTokenB, , , , uint liquidity, , , ,) = positionManager.positions(_positionID);\n    require(liquidity > 0, \"LendingPair: liquidity > 0\");\n    _validateToken(uniTokenA);\n    _validateToken(uniTokenB);\n  }\n\n  function _checkDepositLimit(address _token, uint _amount) internal view {\n    uint depositLimit = lendingController.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require(\n        totalSupplyAmount[_token] + _amount <= depositLimit,\n        \"LendingPair: deposit limit reached\"\n      );\n    }\n  }\n\n  function _checkBorrowLimits(address _token, address _account, uint _amount) internal view {\n    require(\n      _debtOf(_token, _account) + _amount >= lendingController.minBorrow(_token),\n      \"LendingPair: borrow amount below minimum\"\n    );\n\n    uint borrowLimit = lendingController.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebtAmount[_token] + _amount <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _lpRate() internal view returns(uint) {\n    return 50e18;\n  }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address account) external view returns(uint);\n  function transfer(address recipient, uint256 amount) external returns(bool);\n  function allowance(address owner, address spender) external view returns(uint);\n  function decimals() external view returns(uint8);\n  function approve(address spender, uint amount) external returns(bool);\n  function transferFrom(address sender, address recipient, uint amount) external returns(bool);\n}"},"IERC721.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IERC721 {\n\n  function approve(address to, uint tokenId) external;\n  function ownerOf(uint _tokenId) external view returns (address);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint tokenId\n  ) external;\n}\n"},"ICallee.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0;\n\ninterface ICallee {\n\n  function wildCall(bytes calldata _data) external;\n}"},"ILendingPair.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface ILendingPair {\n\n  function tokenA() external view returns(address);\n  function tokenB() external view returns(address);\n  function lpToken(address _token) external view returns(address);\n  function operate(uint[] calldata _actions, bytes[] calldata _data) external payable;\n  function transferLp(address _token, address _from, address _to, uint _amount) external;\n  function supplySharesOf(address _token, address _account) external view returns(uint);\n  function totalSupplyShares(address _token) external view returns(uint);\n  function totalSupplyAmount(address _token) external view returns(uint);\n  function totalDebtShares(address _token) external view returns(uint);\n  function totalDebtAmount(address _token) external view returns(uint);\n  function supplyOf(address _token, address _account) external view returns(uint);\n  function pendingSystemFees(address _token) external view returns(uint);\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view returns(uint);\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external;\n}"},"ILPTokenMaster.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\nimport \"IERC20.sol\";\n\ninterface ILPTokenMaster is IOwnable, IERC20 {\n  function initialize(address _underlying, address _lendingController) external;\n  function underlying() external view returns(address);\n  function lendingPair() external view returns(address);\n}\n"},"IOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IOwnable {\n  function owner() external view returns(address);\n  function transferOwnership(address _newOwner) external;\n  function acceptOwnership() external;\n}"},"ILendingController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ninterface ILendingController is IOwnable {\n  function liqFeeSystem(address _token) external view returns(uint);\n  function liqFeeCaller(address _token) external view returns(uint);\n  function uniMinOutputPct() external view returns(uint);\n  function colFactor(address _token) external view returns(uint);\n  function depositLimit(address _lendingPair, address _token) external view returns(uint);\n  function borrowLimit(address _lendingPair, address _token) external view returns(uint);\n  function depositsEnabled() external view returns(bool);\n  function borrowingEnabled() external view returns(bool);\n  function tokenPrice(address _token) external view returns(uint);\n  function minBorrow(address _token) external view returns(uint);\n  function tokenPrices(address _tokenA, address _tokenB) external view returns (uint, uint);\n  function tokenSupported(address _token) external view returns(bool);\n}\n"},"IUniswapV3Helper.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >0.7.0;\n\ninterface IUniswapV3Helper {\n  function removeLiquidity(uint _tokenId, uint _minOutput0, uint _minOutput1) external returns (uint, uint);\n  function collectFees(uint _tokenId) external returns (uint amount0, uint amount1);\n  function positionTokens(uint _tokenId) external view returns(address, address);\n  function positionAmounts(uint _tokenId, uint _price0, uint _price1) external view returns(uint, uint);\n}"},"INonfungiblePositionManagerSimple.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\n// We can't use full INonfungiblePositionManager as provided by Uniswap since it's on Solidity 0.7\n\ninterface INonfungiblePositionManagerSimple {\n\n  function positions(uint256 tokenId)\n    external\n    view\n    returns (\n      uint96 nonce,\n      address operator,\n      address token0,\n      address token1,\n      uint24 fee,\n      int24 tickLower,\n      int24 tickUpper,\n      uint128 liquidity,\n      uint256 feeGrowthInside0LastX128,\n      uint256 feeGrowthInside1LastX128,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    );\n}"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nlibrary Math {\n\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow, so we distribute.\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n  }\n\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a / b + (a % b == 0 ? 0 : 1);\n  }\n}"},"Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}"},"ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ncontract ReentrancyGuard {\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor () {\n    _status = _NOT_ENTERED;\n  }\n\n  modifier nonReentrant() {\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n    _status = _ENTERED;\n    _;\n    _status = _NOT_ENTERED;\n  }\n}"},"AddressLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressLibrary {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"},"LPTokenMaster.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity 0.8.6;\n\nimport \"ILPTokenMaster.sol\";\nimport \"ILendingPair.sol\";\nimport \"ILendingController.sol\";\nimport \"SafeOwnable.sol\";\n\ncontract LPTokenMaster is ILPTokenMaster, SafeOwnable {\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event NameChange(string _name, string _symbol);\n\n  mapping (address => mapping (address => uint)) public override allowance;\n\n  address public override underlying;\n  address public lendingController;\n  string  public constant name = \"WILD-LP\";\n  string  public constant symbol = \"WILD-LP\";\n  uint8   public constant override decimals = 18;\n  bool    private initialized;\n\n  modifier onlyOperator() {\n    require(msg.sender == ILendingController(lendingController).owner(), \"LPToken: caller is not an operator\");\n    _;\n  }\n\n  function initialize(address _underlying, address _lendingController) external override {\n    require(initialized != true, \"LPToken: already intialized\");\n    owner = msg.sender;\n    underlying = _underlying;\n    lendingController = _lendingController;\n    initialized = true;\n  }\n\n  function transfer(address _recipient, uint _amount) external override returns(bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  function approve(address _spender, uint _amount) external override returns(bool) {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transferFrom(address _sender, address _recipient, uint _amount) external override returns(bool) {\n    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);\n    _transfer(_sender, _recipient, _amount);\n    return true;\n  }\n\n  function lendingPair() external view override returns(address) {\n    return owner;\n  }\n\n  function balanceOf(address _account) external view override returns(uint) {\n    return ILendingPair(owner).supplySharesOf(underlying, _account);\n  }\n\n  function totalSupply() external view override returns(uint) {\n    return ILendingPair(owner).totalSupplyShares(underlying);\n  }\n\n  function _transfer(address _sender, address _recipient, uint _amount) internal {\n    require(_sender != address(0), \"ERC20: transfer from the zero address\");\n    require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    ILendingPair(owner).transferLp(underlying, _sender, _recipient, _amount);\n\n    emit Transfer(_sender, _recipient, _amount);\n  }\n\n  function _approve(address _owner, address _spender, uint _amount) internal {\n    require(_owner != address(0), \"ERC20: approve from the zero address\");\n    require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n    allowance[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n}"},"SafeOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ncontract SafeOwnable is IOwnable {\n\n  uint public constant RENOUNCE_TIMEOUT = 1 hours;\n\n  address public override owner;\n  address public pendingOwner;\n  uint public renouncedAt;\n\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\n  }\n\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function isOwner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function transferOwnership(address _newOwner) external override onlyOwner {\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferInitiated(owner, _newOwner);\n    pendingOwner = _newOwner;\n  }\n\n  function acceptOwnership() external override {\n    require(msg.sender == pendingOwner, \"Ownable: caller is not pending owner\");\n    emit OwnershipTransferConfirmed(msg.sender, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  function initiateRenounceOwnership() external onlyOwner {\n    require(renouncedAt == 0, \"Ownable: already initiated\");\n    renouncedAt = block.timestamp;\n  }\n\n  function acceptRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    require(block.timestamp - renouncedAt > RENOUNCE_TIMEOUT, \"Ownable: too early\");\n    owner = address(0);\n    pendingOwner = address(0);\n    renouncedAt = 0;\n  }\n\n  function cancelRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    renouncedAt = 0;\n  }\n}"},"ERC721Receivable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity >0.7.0;\n\ncontract ERC721Receivable {\n\n  function onERC721Received(\n    address _operator,\n    address _user,\n    uint _tokenId,\n    bytes memory _data\n  ) public returns (bytes4) {\n    return 0x150b7a02;\n  }\n}\n"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"IWETH.sol\";\nimport \"IERC20.sol\";\nimport \"SafeERC20.sol\";\n\ncontract TransferHelper {\n\n  using SafeERC20 for IERC20;\n\n  // Mainnet\n  IWETH internal constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  // Goerli\n  // IWETH internal constant WETH = IWETH(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6);\n\n  function _safeTransferFrom(address _token, address _sender, uint _amount) internal {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    IERC20(_token).safeTransferFrom(_sender, address(this), _amount);\n  }\n\n  function _safeTransfer(address _token, address _recipient, uint _amount) internal {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    IERC20(_token).safeTransfer(_recipient, _amount);\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    require(_to != address(0), \"TransferHelper: invalid recipient\");\n\n    WETH.withdraw(_amount);\n    (bool success, ) = _to.call { value: _amount }(new bytes(0));\n    require(success, 'TransferHelper: ETH transfer failed');\n  }\n\n  function _depositWeth() internal {\n    require(msg.value > 0, \"TransferHelper: amount must be > 0\");\n    WETH.deposit { value: msg.value }();\n  }\n}\n"},"IWETH.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IERC20.sol\";\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n}\n"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"IERC20.sol\";\nimport \"SafeMath.sol\";\nimport \"AddressLibrary.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using AddressLibrary for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"}},"settings":{"evmVersion":"istanbul","optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}}