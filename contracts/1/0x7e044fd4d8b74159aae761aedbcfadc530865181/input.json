{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "StakeLogic.sol": {
      "content": "// File: @openzeppelin/contracts/math/SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/common/Validating.sol\n\npragma solidity 0.7.1;\n\n\ninterface Validating {\n  modifier notZero(uint number) { require(number > 0, \"invalid 0 value\"); _; }\n  modifier notEmpty(string memory text) { require(bytes(text).length > 0, \"invalid empty string\"); _; }\n  modifier validAddress(address value) { require(value != address(0x0), \"invalid address\"); _; }\n}\n\n// File: contracts/external/BytesLib.sol\n\npragma solidity 0.7.1;\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *    The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\nlibrary BytesLib {\n  function concat(\n    bytes memory _preBytes,\n    bytes memory _postBytes\n  )\n    internal\n    pure\n    returns (bytes memory)\n  {\n    bytes memory tempBytes;\n\n    assembly {\n      // Get a location of some free memory and store it in tempBytes as\n      // Solidity does for memory variables.\n      tempBytes := mload(0x40)\n\n      // Store the length of the first bytes array at the beginning of\n      // the memory for tempBytes.\n      let length := mload(_preBytes)\n      mstore(tempBytes, length)\n\n      // Maintain a memory counter for the current write location in the\n      // temp bytes array by adding the 32 bytes for the array length to\n      // the starting location.\n      let mc := add(tempBytes, 0x20)\n      // Stop copying when the memory counter reaches the length of the\n      // first bytes array.\n      let end := add(mc, length)\n\n      for {\n        // Initialize a copy counter to the start of the _preBytes data,\n        // 32 bytes into its memory.\n        let cc := add(_preBytes, 0x20)\n      } lt(mc, end) {\n        // Increase both counters by 32 bytes each iteration.\n        mc := add(mc, 0x20)\n        cc := add(cc, 0x20)\n      } {\n        // Write the _preBytes data into the tempBytes memory 32 bytes\n        // at a time.\n        mstore(mc, mload(cc))\n      }\n\n      // Add the length of _postBytes to the current length of tempBytes\n      // and store it as the new length in the first 32 bytes of the\n      // tempBytes memory.\n      length := mload(_postBytes)\n      mstore(tempBytes, add(length, mload(tempBytes)))\n\n      // Move the memory counter back from a multiple of 0x20 to the\n      // actual end of the _preBytes data.\n      mc := end\n      // Stop copying when the memory counter reaches the new combined\n      // length of the arrays.\n      end := add(mc, length)\n\n      for {\n        let cc := add(_postBytes, 0x20)\n      } lt(mc, end) {\n        mc := add(mc, 0x20)\n        cc := add(cc, 0x20)\n      } {\n        mstore(mc, mload(cc))\n      }\n\n      // Update the free-memory pointer by padding our last write location\n      // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n      // next 32 byte block, then round down to the nearest multiple of\n      // 32. If the sum of the length of the two arrays is zero then add\n      // one before rounding down to leave a blank 32 bytes (the length block with 0).\n      mstore(0x40, and(\n        add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n        not(31) // Round down to the nearest 32 bytes.\n      ))\n    }\n\n    return tempBytes;\n  }\n\n  function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n    assembly {\n      // Read the first 32 bytes of _preBytes storage, which is the length\n      // of the array. (We don't need to use the offset into the slot\n      // because arrays use the entire slot.)\n      let fslot := sload(_preBytes.slot)\n      // Arrays of 31 bytes or less have an even value in their slot,\n      // while longer arrays have an odd value. The actual length is\n      // the slot divided by two for odd values, and the lowest order\n      // byte divided by two for even values.\n      // If the slot is even, bitwise and the slot with 255 and divide by\n      // two to get the length. If the slot is odd, bitwise and the slot\n      // with -1 and divide by two.\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n      let mlength := mload(_postBytes)\n      let newlength := add(slength, mlength)\n      // slength can contain both the length and contents of the array\n      // if length < 32 bytes so let's prepare for that\n      // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n      switch add(lt(slength, 32), lt(newlength, 32))\n      case 2 {\n        // Since the new array still fits in the slot, we just need to\n        // update the contents of the slot.\n        // uint(bytes_storage) = uint(bytes_storage) + uint(bytes_memory) + new_length\n        sstore(\n          _preBytes.slot,\n          // all the modifications to the slot are inside this\n          // next block\n          add(\n            // we can just add to the slot contents because the\n            // bytes we want to change are the LSBs\n            fslot,\n            add(\n              mul(\n                div(\n                  // load the bytes from memory\n                  mload(add(_postBytes, 0x20)),\n                  // zero all bytes to the right\n                  exp(0x100, sub(32, mlength))\n                ),\n                // and now shift left the number of bytes to\n                // leave space for the length in the slot\n                exp(0x100, sub(32, newlength))\n              ),\n              // increase length by the double of the memory\n              // bytes length\n              mul(mlength, 2)\n            )\n          )\n        )\n      }\n      case 1 {\n        // The stored value fits in the slot, but the combined value\n        // will exceed it.\n        // get the keccak hash to get the contents of the array\n        mstore(0x0, _preBytes.slot)\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n        // save new length\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n        // The contents of the _postBytes array start 32 bytes into\n        // the structure. Our first read should obtain the `submod`\n        // bytes that can fit into the unused space in the last word\n        // of the stored array. To get this, we read 32 bytes starting\n        // from `submod`, so the data we read overlaps with the array\n        // contents by `submod` bytes. Masking the lowest-order\n        // `submod` bytes allows us to add that value directly to the\n        // stored value.\n\n        let submod := sub(32, slength)\n        let mc := add(_postBytes, submod)\n        let end := add(_postBytes, mlength)\n        let mask := sub(exp(0x100, submod), 1)\n\n        sstore(\n          sc,\n          add(\n            and(\n              fslot,\n              0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n            ),\n            and(mload(mc), mask)\n          )\n        )\n\n        for {\n          mc := add(mc, 0x20)\n          sc := add(sc, 1)\n        } lt(mc, end) {\n          sc := add(sc, 1)\n          mc := add(mc, 0x20)\n        } {\n          sstore(sc, mload(mc))\n        }\n\n        mask := exp(0x100, sub(mc, end))\n\n        sstore(sc, mul(div(mload(mc), mask), mask))\n      }\n      default {\n        // get the keccak hash to get the contents of the array\n        mstore(0x0, _preBytes.slot)\n        // Start copying to the last used word of the stored array.\n        let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n        // save new length\n        sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n        // Copy over the first `submod` bytes of the new data as in\n        // case 1 above.\n        let slengthmod := mod(slength, 32)\n        let mlengthmod := mod(mlength, 32)\n        let submod := sub(32, slengthmod)\n        let mc := add(_postBytes, submod)\n        let end := add(_postBytes, mlength)\n        let mask := sub(exp(0x100, submod), 1)\n\n        sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n        for {\n          sc := add(sc, 1)\n          mc := add(mc, 0x20)\n        } lt(mc, end) {\n          sc := add(sc, 1)\n          mc := add(mc, 0x20)\n        } {\n          sstore(sc, mload(mc))\n        }\n\n        mask := exp(0x100, sub(mc, end))\n\n        sstore(sc, mul(div(mload(mc), mask), mask))\n      }\n    }\n  }\n\n  function slice(\n    bytes memory _bytes,\n    uint _start,\n    uint _length\n  )\n    internal\n    pure\n    returns (bytes memory)\n  {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_start + _length >= _start, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n    bytes memory tempBytes;\n\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n        tempBytes := mload(0x40)\n\n        // The first word of the slice result is potentially a partial\n        // word read from the original array. To read it, we calculate\n        // the length of that partial word and start copying that many\n        // bytes into the array. The first word we copy will start with\n        // data we don't care about, but the last `lengthmod` bytes will\n        // land at the beginning of the contents of the new array. When\n        // we're done copying, we overwrite the full first word with\n        // the actual length of the slice.\n        let lengthmod := and(_length, 31)\n\n        // The multiplication in the next line is necessary\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\n        // the following copy loop was copying the origin's length\n        // and then ending prematurely not copying everything it should.\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n\n        for {\n          // The multiplication in the next line has the same exact purpose\n          // as the one above.\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n\n        mstore(tempBytes, _length)\n\n        //update free-memory pointer\n        //allocating the array padded to 32 bytes like the compiler does now\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      //if we want a zero-length slice let's just return a zero-length array\n      default {\n        tempBytes := mload(0x40)\n\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n\n    return tempBytes;\n  }\n\n  function toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\n    require(_start + 20 >= _start, \"toAddress_overflow\");\n    require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n    address tempAddress;\n\n    assembly {\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n    }\n\n    return tempAddress;\n  }\n\n  function toUint8(bytes memory _bytes, uint _start) internal pure returns (uint8) {\n    require(_start + 1 >= _start, \"toUint8_overflow\");\n    require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n    uint8 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x1), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint16(bytes memory _bytes, uint _start) internal pure returns (uint16) {\n    require(_start + 2 >= _start, \"toUint16_overflow\");\n    require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n    uint16 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x2), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint32(bytes memory _bytes, uint _start) internal pure returns (uint32) {\n    require(_start + 4 >= _start, \"toUint32_overflow\");\n    require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n    uint32 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x4), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint64(bytes memory _bytes, uint _start) internal pure returns (uint64) {\n    require(_start + 8 >= _start, \"toUint64_overflow\");\n    require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n    uint64 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x8), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint96(bytes memory _bytes, uint _start) internal pure returns (uint96) {\n    require(_start + 12 >= _start, \"toUint96_overflow\");\n    require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n    uint96 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0xc), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint128(bytes memory _bytes, uint _start) internal pure returns (uint128) {\n    require(_start + 16 >= _start, \"toUint128_overflow\");\n    require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n    uint128 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x10), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint256(bytes memory _bytes, uint _start) internal pure returns (uint) {\n    require(_start + 32 >= _start, \"toUint256_overflow\");\n    require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n    uint tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x20), _start))\n    }\n\n    return tempUint;\n  }\n\n  function toUint(bytes memory _bytes, uint _start) internal pure returns (uint) {\n    return toUint256(_bytes, _start);\n  }\n\n  function toBytes32(bytes memory _bytes, uint _start) internal pure returns (bytes32) {\n    require(_start + 32 >= _start, \"toBytes32_overflow\");\n    require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n    bytes32 tempBytes32;\n\n    assembly {\n      tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n    }\n\n    return tempBytes32;\n  }\n\n  function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n    bool success = true;\n\n    assembly {\n      let length := mload(_preBytes)\n\n      // if lengths don't match the arrays are not equal\n      switch eq(length, mload(_postBytes))\n      case 1 {\n        // cb is a circuit breaker in the for loop since there's\n        //  no said feature for inline assembly loops\n        // cb = 1 - don't breaker\n        // cb = 0 - break\n        let cb := 1\n\n        let mc := add(_preBytes, 0x20)\n        let end := add(mc, length)\n\n        for {\n          let cc := add(_postBytes, 0x20)\n        // the next line is the loop condition:\n        // while(uint(mc < end) + cb == 2)\n        } eq(add(lt(mc, end), cb), 2) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          // if any of these checks fails then arrays are not equal\n          if iszero(eq(mload(mc), mload(cc))) {\n            // unsuccess:\n            success := 0\n            cb := 0\n          }\n        }\n      }\n      default {\n        // unsuccess:\n        success := 0\n      }\n    }\n\n    return success;\n  }\n\n  function equalStorage(\n    bytes storage _preBytes,\n    bytes memory _postBytes\n  )\n    internal\n    view\n    returns (bool)\n  {\n    bool success = true;\n\n    assembly {\n      // we know _preBytes_offset is 0\n      let fslot := sload(_preBytes.slot)\n      // Decode the length of the stored array like in concatStorage().\n      let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n      let mlength := mload(_postBytes)\n\n      // if lengths don't match the arrays are not equal\n      switch eq(slength, mlength)\n      case 1 {\n        // slength can contain both the length and contents of the array\n        // if length < 32 bytes so let's prepare for that\n        // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n        if iszero(iszero(slength)) {\n          switch lt(slength, 32)\n          case 1 {\n            // blank the last byte which is the length\n            fslot := mul(div(fslot, 0x100), 0x100)\n\n            if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n              // unsuccess:\n              success := 0\n            }\n          }\n          default {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n            let cb := 1\n\n            // get the keccak hash to get the contents of the array\n            mstore(0x0, _preBytes.slot)\n            let sc := keccak256(0x0, 0x20)\n\n            let mc := add(_postBytes, 0x20)\n            let end := add(mc, mlength)\n\n            // the next line is the loop condition:\n            // while(uint(mc < end) + cb == 2)\n            for {} eq(add(lt(mc, end), cb), 2) {\n              sc := add(sc, 1)\n              mc := add(mc, 0x20)\n            } {\n              if iszero(eq(sload(sc), mload(mc))) {\n                // unsuccess:\n                success := 0\n                cb := 0\n              }\n            }\n          }\n        }\n      }\n      default {\n        // unsuccess:\n        success := 0\n      }\n    }\n\n    return success;\n  }\n}\n\n// File: contracts/gluon/AppGovernance.sol\n\npragma solidity 0.7.1;\n\n\ninterface AppGovernance {\n  function approve(uint32 id) external;\n  function disapprove(uint32 id) external;\n  function activate(uint32 id) external;\n}\n\n// File: contracts/gluon/AppLogic.sol\n\npragma solidity 0.7.1;\n\n\n/**\n  * @notice representing an app's in-and-out transfers of assets\n  * @dev an account/asset based app should implement its own bookkeeping\n  */\ninterface AppLogic {\n\n  /// @notice when an app proposal has been activated, Gluon will call this method on the previously active app version\n  /// @dev each app must implement, providing a future upgrade path, and call retire_() at the very end.\n  /// this is the chance for the previously active app version to migrate to the new version\n  /// i.e.: migrating data, deprecate prior behavior, releasing resources, etc.\n  function upgrade() external;\n\n  /// @dev once an asset has been deposited into the app's safe within Gluon, the app is given the chance to do\n  /// it's own per account/asset bookkeeping\n  ///\n  /// @param account any Ethereum address\n  /// @param asset any ERC20 token or ETH (represented by address 0x0)\n  /// @param quantity quantity of asset\n  function credit(address account, address asset, uint quantity) external;\n\n  /// @dev before an asset can be withdrawn from the app's safe within Gluon, the quantity and asset to withdraw must be\n  /// derived from `parameters`. if the app is account/asset based, it should take this opportunity to:\n  /// - also derive the owning account from `parameters`\n  /// - prove that the owning account indeed has the derived quantity of the derived asset\n  /// - do it's own per account/asset bookkeeping\n  /// notice that the derived account is not necessarily the same as the provided account; a classic usage example is\n  /// an account transfers assets across app (in which case the provided account would be the target app)\n  ///\n  /// @param account any Ethereum address to which `quantity` of `asset` would be transferred to\n  /// @param parameters a bytes-marshalled record containing all data needed for the app-specific logic\n  /// @return asset any ERC20 token or ETH (represented by address 0x0)\n  /// @return quantity quantity of asset\n  function debit(address account, bytes calldata parameters) external returns (address asset, uint quantity);\n}\n\n// File: contracts/gluon/AppState.sol\n\npragma solidity 0.7.1;\n\n/**\n  * @title representing an app's life-cycle\n  * @notice an app's life-cycle starts in the ON state, then it is either move to the final OFF state,\n  * or to the RETIRED state when it upgrades itself to its successor version.\n  */\ncontract AppState {\n\n  enum State { OFF, ON, RETIRED }\n  State public state = State.ON;\n  event Off();\n  event Retired();\n\n  /// @notice app must be active (when current)\n  modifier whenOn() { require(state == State.ON, \"must be on\"); _; }\n\n  /// @notice app must be halted\n  modifier whenOff() { require(state == State.OFF, \"must be off\"); _; }\n\n  /// @notice app must be retired (when no longer current, after being upgraded)\n  modifier whenRetired() { require(state == State.RETIRED, \"must be retired\"); _; }\n\n  /// @dev retire the app. this action is irreversible.\n  /// called during a normal upgrade operation. by the end of this call the approved proposal would be active.\n  function retire_() internal whenOn {\n    state = State.RETIRED;\n    emit Retired();\n  }\n\n  /// @notice halt the app. this action is irreversible.\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\n  /// should be called by an app-owner when the app has been compromised.\n  function switchOff_() internal whenOn {\n    state = State.OFF;\n    emit Off();\n  }\n\n  /// @notice app state is active, i.e: current & active\n  function isOn() external view returns (bool) { return state == State.ON; }\n\n}\n\n// File: contracts/common/Versioned.sol\n\npragma solidity 0.7.1;\n\n\ncontract Versioned {\n\n  string public version;\n\n  constructor(string memory version_) { version = version_; }\n\n}\n\n// File: contracts/gluon/GluonWallet.sol\n\npragma solidity 0.7.1;\n\n\ninterface GluonWallet {\n  function depositEther(uint32 id) external payable;\n  function depositToken(uint32 id, address token, uint quantity) external;\n  function withdraw(uint32 id, bytes calldata parameters) external;\n  function transfer(uint32 from, uint32 to, bytes calldata parameters) external;\n}\n\n// File: contracts/apps/stake/Governing.sol\n\npragma solidity 0.7.1;\n\n\ninterface Governing {\n  function deleteVoteTally(address proposal) external;\n  function activationInterval() external view returns (uint);\n  function governanceToken() external returns (address);\n}\n\n// File: contracts/common/HasOwners.sol\n\npragma solidity 0.7.1;\n\n\n\n/// @notice providing an ownership access control mechanism\ncontract HasOwners is Validating {\n\n  address[] public owners;\n  mapping(address => bool) public isOwner;\n\n  event OwnerAdded(address indexed owner);\n  event OwnerRemoved(address indexed owner);\n\n  /// @notice initializing the owners list (with at least one owner)\n  constructor(address[] memory owners_) {\n    require(owners_.length > 0, \"there must be at least one owner\");\n    for (uint i = 0; i < owners_.length; i++) addOwner_(owners_[i]);\n  }\n\n  /// @notice requires the sender to be one of the contract owners\n  modifier onlyOwner { require(isOwner[msg.sender], \"invalid sender; must be owner\"); _; }\n\n  /// @notice list all accounts with an owner access\n  function getOwners() public view returns (address[] memory) { return owners; }\n\n  /// @notice authorize an `account` with owner access\n  function addOwner(address owner) external onlyOwner { addOwner_(owner); }\n\n  function addOwner_(address owner) private validAddress(owner) {\n    if (!isOwner[owner]) {\n      isOwner[owner] = true;\n      owners.push(owner);\n      emit OwnerAdded(owner);\n    }\n  }\n\n  /// @notice revoke an `account` owner access (while ensuring at least one owner remains)\n  function removeOwner(address owner) external onlyOwner {\n    require(isOwner[owner], 'only owners can be removed');\n    require(owners.length > 1, 'can not remove last owner');\n    isOwner[owner] = false;\n    for (uint i = 0; i < owners.length; i++) {\n      if (owners[i] == owner) {\n        owners[i] = owners[owners.length - 1];\n        owners.pop();\n        emit OwnerRemoved(owner);\n        break;\n      }\n    }\n  }\n\n}\n\n// File: contracts/gluon/HasAppOwners.sol\n\npragma solidity 0.7.1;\n\n\n\n/// @notice providing a per-app ownership access control\ncontract HasAppOwners is HasOwners {\n\n  mapping(uint32 => address[]) public appOwners;\n\n  event AppOwnerAdded (uint32 appId, address appOwner);\n  event AppOwnerRemoved (uint32 appId, address appOwner);\n\n  constructor(address[] memory owners_) HasOwners(owners_) { }\n\n  /// @notice requires the sender to be one of the app owners (of `appId`)\n  ///\n  /// @param appId index of the target app\n  modifier onlyAppOwner(uint32 appId) { require(isAppOwner(appId, msg.sender), \"invalid sender; must be app owner\"); _; }\n\n  function isAppOwner(uint32 appId, address appOwner) public view returns (bool) {\n    address[] memory currentOwners = appOwners[appId];\n    for (uint i = 0; i < currentOwners.length; i++) {\n      if (currentOwners[i] == appOwner) return true;\n    }\n    return false;\n  }\n\n  /// @notice list all accounts with an app-owner access for `appId`\n  ///\n  /// @param appId index of the target app\n  function getAppOwners(uint32 appId) public view returns (address[] memory) { return appOwners[appId]; }\n\n  function addAppOwners(uint32 appId, address[] calldata toBeAdded) external onlyAppOwner(appId) {\n    addAppOwners_(appId, toBeAdded);\n  }\n\n  /// @notice authorize each of `toBeAdded` with app-owner access\n  ///\n  /// @param appId index of the target app\n  /// @param toBeAdded accounts to be authorized\n  /// (the initial app-owners are established during app registration)\n  function addAppOwners_(uint32 appId, address[] memory toBeAdded) internal {\n    for (uint i = 0; i < toBeAdded.length; i++) {\n      if (!isAppOwner(appId, toBeAdded[i])) {\n        appOwners[appId].push(toBeAdded[i]);\n        emit AppOwnerAdded(appId, toBeAdded[i]);\n      }\n    }\n  }\n\n\n  /// @notice revokes app-owner access for each of `toBeRemoved` (while ensuring at least one app-owner remains)\n  ///\n  /// @param appId index of the target app\n  /// @param toBeRemoved accounts to have their membership revoked\n  function removeAppOwners(uint32 appId, address[] calldata toBeRemoved) external onlyAppOwner(appId) {\n    address[] storage currentOwners = appOwners[appId];\n    require(currentOwners.length > toBeRemoved.length, \"can not remove last owner\");\n    for (uint i = 0; i < toBeRemoved.length; i++) {\n      for (uint j = 0; j < currentOwners.length; j++) {\n        if (currentOwners[j] == toBeRemoved[i]) {\n          currentOwners[j] = currentOwners[currentOwners.length - 1];\n          currentOwners.pop();\n          emit AppOwnerRemoved(appId, toBeRemoved[i]);\n          break;\n        }\n      }\n    }\n  }\n\n}\n\n// File: contracts/gluon/Gluon.sol\n\npragma solidity 0.7.1;\n\n\n\n\n\n\n\n\n\n\n\n/**\n  * @title the Gluon-Plasma contract for upgradable side-chain apps (see: https://leverj.io/GluonPlasma.pdf)\n  * @notice once an app has been provisioned with me, I enable:\n  * - depositing an asset into an app\n  * - withdrawing an asset from an app\n  * - transferring an asset across apps\n  * - submitting (and discarding) an upgrade proposal for an app\n  * - voting for/against app proposals\n  * - upgrading an approved app proposal\n  */\ncontract Gluon is Validating, Versioned, AppGovernance, GluonWallet, HasAppOwners {\n  using SafeMath for uint;\n\n  struct App {\n    address[] history;\n    address proposal;\n    uint activationBlock;\n    mapping(address => uint) balances;\n  }\n\n  address private constant ETH = address(0x0);\n  uint32 private constant REGISTRY_INDEX = 0;\n  uint32 private constant STAKE_INDEX = 1;\n\n  mapping(uint32 => App) public apps;\n  mapping(address => bool) public proposals;\n  uint32 public totalAppsCount = 0;\n\n  event AppRegistered (uint32 appId);\n  event AppProvisioned(uint32 indexed appId, uint8 version, address logic);\n  event ProposalAdded(uint32 indexed appId, uint8 version, address logic, uint activationBlock);\n  event ProposalRemoved(uint32 indexed appId, uint8 version, address logic);\n  event Activated(uint32 indexed appId, uint8 version, address logic);\n\n  constructor(address[] memory owners_, string memory version_) Versioned(version_) HasAppOwners(owners_) {\n    registerApp_(REGISTRY_INDEX, owners);\n    registerApp_(STAKE_INDEX, owners);\n  }\n\n  /// @notice requires the sender to be the currently active (latest) version of the app contract (identified by appId)\n  ///\n  /// @param appId index of the provisioned app in question\n  modifier onlyCurrentLogic(uint32 appId) { require(msg.sender == current(appId), \"invalid sender; must be latest logic contract\"); _; }\n\n  modifier provisioned(uint32 appId) { require(apps[appId].history.length > 0, \"App is not yet provisioned\"); _; }\n\n  function registerApp(uint32 appId, address[] calldata accounts) external onlyOwner { registerApp_(appId, accounts); }\n\n  function registerApp_(uint32 appId, address[] memory accounts) private {\n    require(appOwners[appId].length == 0, \"App already has app owner\");\n    require(totalAppsCount == appId, \"app ids are incremented by 1\");\n    totalAppsCount++;\n    emit AppRegistered(appId);\n    addAppOwners_(appId, accounts);\n  }\n\n  /// @notice on-boarding an app\n  ///\n  /// @param logic address of the app's contract (the first version)\n  /// @param appId index of the provisioned app in question\n  function provisionApp(uint32 appId, address logic) external onlyAppOwner(appId) validAddress(logic) {\n    App storage app = apps[appId];\n    require(app.history.length == 0, \"App is already provisioned\");\n    app.history.push(logic);\n    emit AppProvisioned(appId, uint8(app.history.length - 1), logic);\n  }\n\n  /************************************************* Governance ************************************************/\n\n  function addProposal(uint32 appId, address logic) external onlyAppOwner(appId) provisioned(appId) validAddress(logic) {\n    App storage app = apps[appId];\n    require(app.proposal == address(0x0), \"Proposal already exists. remove proposal before adding new one\");\n    app.proposal = logic;\n    app.activationBlock = block.number + Governing(current(STAKE_INDEX)).activationInterval();\n    proposals[logic] = true;\n    emit ProposalAdded(appId, uint8(app.history.length - 1), app.proposal, app.activationBlock);\n  }\n\n  function removeProposal(uint32 appId) external onlyAppOwner(appId) provisioned(appId) {\n    App storage app = apps[appId];\n    emit ProposalRemoved(appId, uint8(app.history.length - 1), app.proposal);\n    deleteProposal(app);\n  }\n\n  function deleteProposal(App storage app) private {\n    Governing(current(STAKE_INDEX)).deleteVoteTally(app.proposal);\n    delete proposals[app.proposal];\n    delete app.proposal;\n    app.activationBlock = 0;\n  }\n\n  /************************************************* AppGovernance ************************************************/\n\n  function approve(uint32 appId) external override onlyCurrentLogic(STAKE_INDEX) {\n    apps[appId].activationBlock = block.number;\n  }\n\n  function disapprove(uint32 appId) external override onlyCurrentLogic(STAKE_INDEX) {\n    App storage app = apps[appId];\n    emit ProposalRemoved(appId, uint8(app.history.length - 1), app.proposal);\n    deleteProposal(app);\n  }\n\n  function activate(uint32 appId) external override onlyCurrentLogic(appId) provisioned(appId) {\n    App storage app = apps[appId];\n    require(app.activationBlock > 0, \"nothing to activate\");\n    require(app.activationBlock < block.number, \"new app can not be activated before activation block\");\n    app.history.push(app.proposal); // now make it the current\n    deleteProposal(app);\n    emit Activated(appId, uint8(app.history.length - 1), current(appId));\n  }\n\n  /**************************************************** GluonWallet ****************************************************/\n\n  /// @notice deposit ETH asset on behalf of the sender into an app's safe\n  ///\n  /// @param appId index of the target app\n  function depositEther(uint32 appId) external override payable provisioned(appId) {\n    App storage app = apps[appId];\n    app.balances[ETH] = app.balances[ETH].add(msg.value);\n    AppLogic(current(appId)).credit(msg.sender, ETH, msg.value);\n  }\n\n  /// @notice deposit ERC20 token asset (represented by address 0x0) on behalf of the sender into an app's safe\n  /// @dev an account must call token.approve(logic, quantity) beforehand\n  ///\n  /// @param appId index of the target app\n  /// @param token address of ERC20 token contract\n  /// @param quantity how much of token\n  function depositToken(uint32 appId, address token, uint quantity) external override provisioned(appId) {\n    transferTokensToGluonSecurely(appId, IERC20(token), quantity);\n    AppLogic(current(appId)).credit(msg.sender, token, quantity);\n  }\n\n  function transferTokensToGluonSecurely(uint32 appId, IERC20 token, uint quantity) private {\n    uint balanceBefore = token.balanceOf(address(this));\n    require(token.transferFrom(msg.sender, address(this), quantity), \"failure to transfer quantity from token\");\n    uint balanceAfter = token.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) == quantity, \"bad Token; transferFrom erroneously reported of successful transfer\");\n    App storage app = apps[appId];\n    app.balances[address(token)] = app.balances[address(token)].add(quantity);\n  }\n\n  /// @notice withdraw a quantity of asset from an app's safe\n  /// @dev quantity & asset should be derived by the app\n  ///\n  /// @param appId index of the target app\n  /// @param parameters a bytes-marshalled record containing at the very least quantity & asset\n  function withdraw(uint32 appId, bytes calldata parameters) external override provisioned(appId) {\n    (address asset, uint quantity) = AppLogic(current(appId)).debit(msg.sender, parameters);\n    if (quantity > 0) {\n      App storage app = apps[appId];\n      require(app.balances[asset] >= quantity, \"not enough funds to transfer\");\n      app.balances[asset] = apps[appId].balances[asset].sub(quantity);\n      asset == ETH ?\n        require(address(uint160(msg.sender)).send(quantity), \"failed to transfer ether\") : // explicit casting to `address payable`\n        transferTokensToAccountSecurely(IERC20(asset), quantity, msg.sender);\n    }\n  }\n\n  function transferTokensToAccountSecurely(IERC20 token, uint quantity, address to) private {\n    uint balanceBefore = token.balanceOf(to);\n    require(token.transfer(to, quantity), \"failure to transfer quantity from token\");\n    uint balanceAfter = token.balanceOf(to);\n    require(balanceAfter.sub(balanceBefore) == quantity, \"bad Token; transferFrom erroneously reported of successful transfer\");\n  }\n\n  /// @notice withdraw a quantity of asset from a source app's safe and transfer it (within Gluon) to a target app's safe\n  /// @dev quantity & asset should be derived by the source app\n  ///\n  /// @param from index of the source app\n  /// @param to index of the target app\n  /// @param parameters a bytes-marshalled record containing at the very least quantity & asset\n  function transfer(uint32 from, uint32 to, bytes calldata parameters) external override provisioned(from) provisioned(to) {\n    (address asset, uint quantity) = AppLogic(current(from)).debit(msg.sender, parameters);\n    if (quantity > 0) {\n      if (from != to) {\n        require(apps[from].balances[asset] >= quantity, \"not enough balance in logic to transfer\");\n        apps[from].balances[asset] = apps[from].balances[asset].sub(quantity);\n        apps[to].balances[asset] = apps[to].balances[asset].add(quantity);\n      }\n      AppLogic(current(to)).credit(msg.sender, asset, quantity);\n    }\n  }\n\n  /**************************************************** GluonView  ****************************************************/\n\n  /// @notice view of current app data\n  ///\n  /// @param appId index of the provisioned app in question\n  /// @return current address of the app's current contract\n  /// @return proposal address of the app's pending proposal contract (if any)\n  /// @return activationBlock the block in which the proposal can be activated\n  function app(uint32 appId) external view returns (address current, address proposal, uint activationBlock) {\n    App storage app_ = apps[appId];\n    current = app_.history[app_.history.length - 1];\n    proposal = app_.proposal;\n    activationBlock = app_.activationBlock;\n  }\n\n  function current(uint32 appId) public view returns (address) { return apps[appId].history[apps[appId].history.length - 1]; }\n\n  /// @notice view of the full chain of (contract addresses) of the app versions, up to and including the current one\n  function history(uint32 appId) external view returns (address[] memory) { return apps[appId].history; }\n\n  /// @notice is the `logic` contract one of the `appId` app?\n  function isAnyLogic(uint32 appId, address logic) public view returns (bool) {\n    address[] memory history_ = apps[appId].history;\n    for (uint i = history_.length; i > 0; i--) {\n      if (history_[i - 1] == logic) return true;\n    }\n    return false;\n  }\n\n  /// @notice what is the current balance of `asset` in the `appId` app's safe?\n  function getBalance(uint32 appId, address asset) external view returns (uint) { return apps[appId].balances[asset]; }\n\n}\n\n// File: contracts/gluon/GluonCentric.sol\n\npragma solidity 0.7.1;\n\n\n\n/**\n  * @title the essentials of a side-chain app participating in Gluon-Plasma\n  * @dev both Logic & Data (if exists) contracts should inherit this contract\n  */\ncontract GluonCentric {\n\n  uint32 internal constant REGISTRY_INDEX = 0;\n  uint32 internal constant STAKE_INDEX = 1;\n\n  uint32 public id;\n  Gluon public gluon;\n\n  /// @param id_ index of the app within gluon\n  /// @param gluon_ address of the Gluon contract\n  constructor(uint32 id_, address gluon_) {\n    id = id_;\n    gluon = Gluon(gluon_);\n  }\n\n  /// @notice requires the sender to be the currently active (latest) version of me (the app contract)\n  modifier onlyCurrentLogic { require(currentLogic() == msg.sender, \"invalid sender; must be current logic contract\"); _; }\n\n  /// @notice requires the sender must be gluon contract\n  modifier onlyGluon { require(address(gluon) == msg.sender, \"invalid sender; must be gluon contract\"); _; }\n\n  /// @notice requires the sender must be my app owner\n  modifier onlyOwner { require(gluon.isAppOwner(id, msg.sender), \"invalid sender; must be app owner\"); _; }\n\n  /// @return address the address of currently active (latest) version of me (the app contract)\n  function currentLogic() public view returns (address) { return gluon.current(id); }\n\n}\n\n// File: contracts/gluon/GluonLogic.sol\n\npragma solidity 0.7.1;\n\n\n\n\nabstract contract GluonLogic is GluonCentric {\n  address public upgradeOperator;\n\n  constructor(uint32 id_, address gluon_) GluonCentric(id_, gluon_) { }\n\n  modifier onlyUpgradeOperator { require(upgradeOperator == msg.sender, \"invalid sender; must be upgrade operator\"); _; }\n\n  function setUpgradeOperator(address upgradeOperator_) external onlyOwner { upgradeOperator = upgradeOperator_; }\n\n  function upgrade_(AppGovernance appGovernance, uint32 id) internal {\n    appGovernance.activate(id);\n    delete upgradeOperator;\n  }\n}\n\n// File: contracts/apps_history/registry/OldRegistry.sol\n\npragma solidity 0.7.1;\n\n\ninterface OldRegistry {\n  function contains(address apiKey) external view returns (bool);\n  function register(address apiKey) external;\n  function registerWithUserAgreement(address apiKey, bytes32 userAgreement) external;\n  function translate(address apiKey) external view returns (address);\n}\n\n// File: contracts/apps/registry/RegistryData.sol\n\npragma solidity 0.7.1;\n\n\n\ncontract RegistryData is GluonCentric {\n\n  mapping(address => address) public accounts;\n\n  constructor(address gluon_) GluonCentric(REGISTRY_INDEX, gluon_) { }\n\n  function addKey(address apiKey, address account) external onlyCurrentLogic {\n    accounts[apiKey] = account;\n  }\n\n}\n\n// File: contracts/apps/registry/RegistryLogic.sol\n\npragma solidity 0.7.1;\n\n\n\n\n\n\n\n\n\n/**\n  * @title enabling Zero Knowledge API Keys as described in: https://blog.leverj.io/zero-knowledge-api-keys-43280cc93647\n  * @notice the Registry app consists of the RegistryLogic & RegistryData contracts.\n  * api-key registrations are held within RegistryData for an easier upgrade path.\n  * @dev although Registry enable account-based apps needing log-less logins, no app is required to use it.\n  */\ncontract RegistryLogic is Validating, AppLogic, AppState, GluonLogic {\n\n  RegistryData public data;\n  OldRegistry public old;\n\n  event Registered(address apiKey, address indexed account);\n\n  constructor(address gluon_, address old_, address data_) GluonLogic(REGISTRY_INDEX, gluon_) {\n    data = RegistryData(data_);\n    old = OldRegistry(old_);\n  }\n\n  modifier isAbsent(address apiKey) { require(translate(apiKey) == address (0x0), \"api key already in use\"); _; }\n\n  /// @notice register an api-key on behalf of the sender\n  /// @dev irreversible operation; the apiKey->sender association cannot be broken or overwritten\n  /// (but further apiKey->sender associations can be provided)\n  ///\n  /// @param apiKey the account to be used to stand-in for the registering sender\n  function register(address apiKey) external whenOn validAddress(apiKey) isAbsent(apiKey) {\n    data.addKey(apiKey, msg.sender);\n    emit Registered(apiKey, msg.sender);\n  }\n\n  /// @notice retrieve the stand-in-for account\n  ///\n  /// @param apiKey the account to be used to stand-in for the registering sender\n  function translate(address apiKey) public view returns (address) {\n    address account = data.accounts(apiKey);\n    if (account == address(0x0)) account = old.translate(apiKey);\n    return account;\n  }\n\n  /**************************************************** AppLogic ****************************************************/\n\n  /// @notice upgrade the app to a new version; the approved proposal.\n  /// by the end of this call the approved proposal would be the current and active version of the app.\n  function upgrade() external override onlyUpgradeOperator {\n    retire_();\n    upgrade_(AppGovernance(gluon), id);\n  }\n\n  function credit(address, address, uint) external override pure { revert(\"not supported\"); }\n\n  function debit(address, bytes calldata) external override pure returns (address, uint) { revert(\"not supported\"); }\n\n  /***************************************************** AppState *****************************************************/\n\n  /// @notice halt the app. this action is irreversible.\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\n  /// should be called by an app-owner when the app has been compromised.\n  ///\n  /// Note the constraint that all apps but Registry & Stake must be halted first!\n  function switchOff() external onlyOwner {\n    uint32 totalAppsCount = gluon.totalAppsCount();\n    for (uint32 i = 2; i < totalAppsCount; i++) {\n      AppState appState = AppState(gluon.current(i));\n      require(!appState.isOn(), \"One of the apps is still ON\");\n    }\n    switchOff_();\n  }\n\n  /********************************************************************************************************************/\n}\n\n// File: contracts/apps/stake/Redeeming.sol\n\npragma solidity 0.7.1;\n\n\ninterface Redeeming {\n  function redeem(address account, uint quantity) external returns (uint toRestake, uint toStake, uint toWithdraw);\n}\n\n// File: contracts/apps/stake/StakeData.sol\n\npragma solidity 0.7.1;\n\n\n\n\ncontract StakeData is GluonCentric {\n  using SafeMath for uint;\n\n  mapping(address => address[]) public accountToProposals;\n  mapping(address => bool[]) public accountToSides;\n  mapping(address => mapping(bool => uint)) public voteTally; /// proposal => side(true/false) => totalVotes\n  mapping(address => address) public accountLocation;         /// account => logic\n  mapping(address => uint) public balance;\n\n  constructor(address gluon) GluonCentric(STAKE_INDEX, gluon) { }\n\n  function updateAccountLocation(address account, address logic) external onlyCurrentLogic { accountLocation[account] = logic; }\n\n  function updateBalance(address account, uint quantity) external onlyCurrentLogic { balance[account] = quantity; }\n\n  function voteAppUpgrade(address proposal, address account, bool side, uint quantity) external onlyCurrentLogic returns (uint, uint) {\n    uint index = getVoteIndex(account, proposal);\n    bool firstVote = index == accountToProposals[account].length;\n    require(firstVote || accountToSides[account][index] != side, \"cannot vote same side again\");\n    if (firstVote) {\n      accountToProposals[account].push(proposal);\n      accountToSides[account].push(side);\n    } else {\n      voteTally[proposal][!side] = voteTally[proposal][!side].sub(quantity);\n      accountToSides[account][index] = side;\n    }\n    voteTally[proposal][side] = voteTally[proposal][side].add(quantity);\n    return getVoteTally(proposal);\n  }\n\n  function deleteVoteTally(address proposal) external onlyCurrentLogic {\n    voteTally[proposal][true] = voteTally[proposal][false] = 0;\n  }\n\n  function getVoteIndex(address account, address proposal) public view returns (uint) {\n    address[] memory proposals = accountToProposals[account];\n    for (uint i = 0; i < proposals.length; i++) {\n      if (proposals[i] == proposal) return i;\n    }\n    return proposals.length;\n  }\n\n  function getAllProposals(address account) external view returns (address[] memory proposals, bool[] memory sides) {\n    proposals = accountToProposals[account];\n    sides = accountToSides[account];\n  }\n\n  function removeResolvedProposals(address account) external onlyCurrentLogic {\n    if (accountToProposals[account].length == 0) return;\n    address[] storage allProposed = accountToProposals[account];\n    bool[] storage sides = accountToSides[account];\n    for (uint i = allProposed.length; i > 0; i--) {\n      if (!gluon.proposals(allProposed[i - 1])) {\n        allProposed[i - 1] = allProposed[allProposed.length - 1];\n        allProposed.pop();\n        sides[i - 1] = sides[sides.length - 1];\n        sides.pop();\n      }\n    }\n  }\n\n  function updateVotes(address proposal, bool side, uint quantity, bool increased) external onlyCurrentLogic returns (uint approvals, uint disapprovals) {\n    uint tally = voteTally[proposal][side];\n    voteTally[proposal][side] = increased ? tally.add(quantity) : tally.sub(quantity);\n    return getVoteTally(proposal);\n  }\n\n  function getVoteTally(address proposal) public view returns (uint approvals, uint disapprovals) {\n    approvals = voteTally[proposal][true];\n    disapprovals = voteTally[proposal][false];\n  }\n\n}\n\n// File: contracts/apps/stake/StakeLogic.sol\n\npragma solidity 0.7.1;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n  * @notice the Stake app consists of the StakeLogic & StakeData contracts.\n  * voting data and staked balances are held within StakeData for an easier upgrade path.\n  *\n  * staking governanceToken tokens allows for:\n  *  a. distribution of awards to stakers\n  *  b. governance of apps; as stakers can vote for or against proposals (proposed app upgrades)\n  */\ncontract StakeLogic is Validating, AppLogic, AppState, GluonLogic, Governing, Redeeming {\n  using BytesLib for bytes;\n  using SafeMath for uint;\n\n  /// per stake interval data\n  struct Interval {\n    uint worth;\n    uint[] rewards;\n    uint start;\n    uint end;\n  }\n\n  /// account\n  struct UserStake {\n    uint intervalIndex;\n    uint quantity;\n    uint worth;\n  }\n\n  address constant private ETH = address(0x0);\n  uint public constant name = uint(keccak256(\"StakeLogic\"));\n  bool initiated;\n  StakeData public data;\n  address public override governanceToken;\n  address[] public tokens;\n  uint[] public toBeDistributed;\n\n  uint public intervalSize;\n  uint public currentIntervalIndex;\n  uint public quorumPercentage;\n  uint public override activationInterval;\n  mapping(uint => Interval) public intervals;\n  mapping(address => UserStake) public stakes;\n\n  event Staked(address indexed user, uint quantity, uint start, uint end, uint intervalIndex);\n  event Restaked(address indexed user, uint quantity, uint start, uint end, uint intervalIndex);\n  event Redeemed(address indexed user, uint quantity, uint start, uint end, uint intervalIndex);\n  event Reward(address indexed user, address asset, uint reward, uint start, uint end, uint intervalIndex);\n  event NewInterval(uint start, uint end, uint intervalIndex);\n  event Voted(uint32 indexed appId, address indexed proposal, uint approvals, uint disapprovals, address account);\n  event VotingConcluded(uint32 indexed appId, address indexed proposal, uint approvals, uint disapprovals, bool result);\n\n  constructor(address gluon_, address data_, address governanceToken_, address[] memory tokens_, address apiKey_, uint intervalSize_, uint quorumPercentage_, uint activationInterval_)\n    GluonLogic(STAKE_INDEX, gluon_)\n    validAddress(gluon_)\n    validAddress(governanceToken_)\n    validAddress(apiKey_)\n    notZero(intervalSize_)\n    notZero(activationInterval_)\n  {\n    data = StakeData(data_);\n    governanceToken = governanceToken_;\n    tokens = tokens_;\n    for (uint i = 0; i < tokens.length; i++) toBeDistributed.push(0);\n    quorumPercentage = quorumPercentage_;\n    intervalSize = intervalSize_;\n    registerApiKey_(apiKey_);\n    activationInterval = activationInterval_;\n  }\n\n  receive() external payable {}\n\n  function init(uint intervalId) external onlyOwner {\n    require(initiated == false, \"already initiated\");\n    currentIntervalIndex = intervalId;\n    intervals[currentIntervalIndex].start = block.number;\n    intervals[currentIntervalIndex].end = block.number.add(intervalSize);\n    for (uint i = 0; i < tokens.length; i++) intervals[currentIntervalIndex].rewards.push(0);\n    initiated = true;\n  }\n\n  function setIntervalSize(uint intervalSize_) external notZero(intervalSize_) onlyOwner {\n    ensureInterval();\n    intervalSize = intervalSize_;\n  }\n\n  function addToken(address token) external validAddress(token) onlyOwner whenOn {\n    require(tokens.length < 50, \"Can not add more than 50 tokens\");\n    tokens.push(token);\n    toBeDistributed.push(0);\n    intervals[currentIntervalIndex].rewards.push(0);\n  }\n\n  /// @notice establish an interval if none exists\n  function ensureInterval() public whenOn {\n    if (intervals[currentIntervalIndex].end > block.number) return;\n\n    Interval storage interval = intervals[currentIntervalIndex];\n    for (uint i = 0; i < interval.rewards.length; i++) {\n      uint reward = interval.worth == 0 ? 0 : calculateIntervalReward(interval.start, interval.end, i);\n      toBeDistributed[i] = toBeDistributed[i].add(reward);\n      interval.rewards[i] = reward;\n    }\n\n    uint diff = block.number.sub(interval.end) % intervalSize;\n    currentIntervalIndex += 1;\n    uint start = interval.end;\n    uint end = block.number.sub(diff).add(intervalSize);\n    intervals[currentIntervalIndex].start = start;\n    intervals[currentIntervalIndex].end = end;\n    for (uint i = 0; i < tokens.length; i++) intervals[currentIntervalIndex].rewards.push(0);\n    emit NewInterval(start, end, currentIntervalIndex);\n  }\n\n  function restake(address account, uint quantity) private returns (uint, uint) {\n    (uint toRestake, uint toStake, uint toWithdraw) = Redeeming(stakeLocation(account)).redeem(account, quantity);\n    if (toRestake == 0) return (toStake, toWithdraw);\n\n    UserStake storage stake = stakes[account];\n    stake.quantity = toRestake;\n    Interval storage interval = intervals[currentIntervalIndex];\n    stake.intervalIndex = currentIntervalIndex;\n    stake.worth = stake.quantity.mul(interval.end.sub(interval.start));\n    interval.worth = interval.worth.add(stake.worth);\n    emit Restaked(account, stake.quantity, interval.start, interval.end, currentIntervalIndex);\n    return (toStake, toWithdraw);\n  }\n\n  function stake(address account, uint quantity) private whenOn returns (uint toStake, uint toWithdraw) {\n    ensureInterval();\n    (toStake, toWithdraw) = restake(account, quantity);\n    data.removeResolvedProposals(account);\n    if (toWithdraw > 0) {\n      updateVotes(account, toWithdraw, false);\n    }\n    if (toStake > 0) {\n      updateVotes(account, toStake, true);\n      stakeInCurrentPeriod(account, toStake);\n    }\n    data.updateBalance(account, quantity);\n    data.updateAccountLocation(account, stakes[account].worth == 0 ? address(0x0) : address(this));\n  }\n\n  function stakeInCurrentPeriod(address account, uint quantity) private {\n    Interval storage interval = intervals[currentIntervalIndex];\n    stakes[account].intervalIndex = currentIntervalIndex;\n    uint worth = quantity.mul(interval.end.sub(block.number));\n    stakes[account].worth = stakes[account].worth.add(worth);\n    stakes[account].quantity = stakes[account].quantity.add(quantity);\n    interval.worth = interval.worth.add(worth);\n    emit Staked(account, quantity, interval.start, interval.end, currentIntervalIndex);\n  }\n\n  /// @notice calculate the reward for token for the interval: [`start`, `end`)\n  /// provided for on-going operational queries\n  function calculateIntervalReward(uint start, uint end, uint index) public view returns (uint) {\n    uint balance = tokens[index] == ETH ? address(this).balance : IERC20(tokens[index]).balanceOf(address(this));\n    return balance.sub(toBeDistributed[index]).mul(end.sub(start)).div(block.number.sub(start));\n  }\n\n  function registerApiKey(address apiKey) public onlyOwner { registerApiKey_(apiKey); }\n\n  function registerApiKey_(address apiKey) private {\n    RegistryLogic registry = RegistryLogic(gluon.current(REGISTRY_INDEX));\n    registry.register(apiKey);\n  }\n\n  function withdrawFromApp(uint32 appId, bytes memory withdrawData) public {\n    uint action = withdrawData.toUint(0);\n    require(action == 1 || action == 5, \"only assisted withdraw or exit on halt is allowed\");\n    GluonWallet(gluon).withdraw(appId, withdrawData);\n  }\n\n  function transferToLatestStakeAfterRetire() public whenRetired {\n    for (uint i = 0; i < tokens.length; i++) {\n      uint balance = tokens[i] == ETH ? address(this).balance : IERC20(tokens[i]).balanceOf(address(this));\n      uint quantity = balance.sub(toBeDistributed[i]);\n      transfer(tokens[i], currentLogic(), quantity);\n    }\n  }\n\n  /**************************************************** Redeeming *****************************************************/\n\n  /// @notice redeeming enables both withdrawing and restaking.\n  /// first, the quantities {toRestake, toStake, toWithdraw} are calculated from the last staked amount and the given quantity\n  /// to redeem, then `toWithdraw` will be transfer to the account, and `toRestake` will be staked in the current interval.\n  /// the calculated values are returned to calling functions for further processing.\n  ///\n  /// @param account the staking account\n  /// @param quantity how much to redeem\n  /// @return toRestake how much of the staked amount from previously staked interval will be carried over to current stake interval\n  /// @return toStake how much (beyond toRestake) will be staked for the remainder of the current interval\n  /// @return toWithdraw how much would no longer be staked and instead transferred back to the staker account\n  function redeem(address account, uint quantity) public override onlyCurrentLogic returns (uint /* toRestake */, uint  /* toStake */, uint  /* toWithdraw */) {\n    UserStake memory userStake = stakes[account];\n    if (userStake.intervalIndex == 0) return (0, quantity, 0);\n    // non staked thus far, so stake quantity in full\n\n    uint staked = userStake.quantity;\n    uint intervalIndex = userStake.intervalIndex;\n    Interval memory interval = intervals[intervalIndex];\n    uint toWithdraw = staked > quantity ? staked.sub(quantity) : 0;\n    if (intervalIndex == currentIntervalIndex) {\n      if (toWithdraw > 0) {\n        // => quantity > staked\n        uint worth = toWithdraw.mul(intervals[currentIntervalIndex].end.sub(block.number));\n        stakes[account].worth = userStake.worth.sub(worth);\n        stakes[account].quantity = userStake.quantity.sub(toWithdraw);\n        intervals[currentIntervalIndex].worth = intervals[currentIntervalIndex].worth.sub(worth);\n        emit Redeemed(account, toWithdraw, interval.start, interval.end, intervalIndex);\n        return (0, 0, toWithdraw);\n      } else {\n        // => quantity <= staked\n        uint toStake = quantity.sub(staked); // some is already staked, so stake the difference\n        return (0, toStake, 0);\n      }\n    }\n\n    // some is staked in previous interval\n    uint toRestake = staked.sub(toWithdraw);\n    // staker get previous staked amount carried over to current interval (minus the withdrawn amount)\n    uint toStake = quantity > staked ? quantity.sub(staked) : 0;\n    // staker get the extra amount (beyond what is already carried over) staked in the remainder of current interval\n    uint worth = userStake.worth;\n    delete stakes[account];\n    distributeRewards(account, worth, interval, intervalIndex);\n    emit Redeemed(account, toWithdraw, interval.start, interval.end, intervalIndex);\n    return (toRestake, toStake, toWithdraw);\n  }\n\n  function distributeRewards(address account, uint worth, Interval memory interval, uint intervalIndex) private {\n    if (worth == 0) return;\n\n    for (uint i = 0; i < tokens.length; i++) {\n      uint reward = interval.rewards[i].mul(worth).div(interval.worth);\n      if (reward == 0) continue;\n      toBeDistributed[i] = toBeDistributed[i].sub(reward);\n      transfer(tokens[i], account, reward);\n      emit Reward(account, tokens[i], reward, interval.start, interval.end, intervalIndex);\n    }\n  }\n\n  function transfer(address token, address to, uint quantity) private {\n    if (quantity == 0) return;\n\n    token == ETH ?\n      require(address(uint160(to)).send(quantity), \"failed to transfer ether\") : // explicit casting to `address payable`\n      transferTokensToAccountSecurely(IERC20(token), quantity, to);\n  }\n\n  function transferTokensToAccountSecurely(IERC20 token, uint quantity, address to) private {\n    uint balanceBefore = token.balanceOf(to);\n    require(token.transfer(to, quantity), \"failure to transfer quantity from token\");\n    uint balanceAfter = token.balanceOf(to);\n    require(balanceAfter.sub(balanceBefore) == quantity, \"bad Token; transferFrom erroneously reported of successful transfer\");\n  }\n\n  function getTokens() public view returns (address[] memory) { return tokens; }\n\n  function getToBeDistributed() public view returns (uint[] memory) { return toBeDistributed; }\n\n  function getInterval(uint intervalIndex) public view returns (uint worth, uint[] memory rewards, uint start, uint end) {\n    Interval memory interval = intervals[intervalIndex];\n    worth = interval.worth;\n    rewards = interval.rewards;\n    start = interval.start;\n    end = interval.end;\n  }\n\n  /**************************************************** Governing ****************************************************/\n\n  /// @dev cleanup when deleting a proposal\n  function deleteVoteTally(address proposal) external override onlyGluon { data.deleteVoteTally(proposal); }\n\n  /**************************************************** AppLogic ****************************************************/\n\n  /// @notice upgrade the app to a new version; the approved proposal.\n  /// by the end of this call the approved proposal would be the current and active version of the app.\n  function upgrade() external override whenOn onlyUpgradeOperator {\n    (, address proposal, uint activationBlock) = gluon.app(id);\n    require(activationBlock > 0, \"nothing to activate\");\n    address[] memory logics = gluon.history(id);\n    require(proposal != address(this), \"can not be the same contract\");\n    require(GluonCentric(proposal).id() == id, \"invalid app id\");\n    for (uint i = 0; i < logics.length; i++) require(proposal != logics[i], \"can not be old contract\");\n    require(StakeLogic(payable(proposal)).name() == name, \"proposal name is different\");\n    intervals[currentIntervalIndex].end = block.number;\n    ensureInterval();\n    retire_();\n    upgrade_(AppGovernance(gluon), id);\n  }\n\n  function stakeLocation(address account) public view returns (address) {\n    address accountStakeLocation = data.accountLocation(account);\n    if (accountStakeLocation == address(0x0) || accountStakeLocation == address(this)) return address(this);\n\n    (, , uint worth) = StakeLogic(payable(accountStakeLocation)).stakes(account);\n    return worth == 0 ?\n      address(this) :       // this is a new staker\n      accountStakeLocation; // this is an old staker that already withdrew their LEV from previous contract\n  }\n\n  function credit(address account, address asset, uint quantity) external override whenOn onlyGluon {\n    require(address(governanceToken) == Governing(stakeLocation(account)).governanceToken(), \"cannot stake new governance-token (L2) before all of old governance-token (LEV) are redeemed\");\n    require(asset == address(governanceToken), \"can only stake governance-token (L2)\");\n    stake(account, data.balance(account).add(quantity));\n  }\n\n  function debit(address account, bytes calldata parameters) external override whenOn onlyGluon returns (address asset, uint quantity) {\n    (asset, quantity) = abi.decode(parameters, (address, uint));\n    address stakedGovernanceToken = Governing(stakeLocation(account)).governanceToken();\n    bool newWorld = asset == address(governanceToken) && asset == stakedGovernanceToken;\n    require(\n      newWorld || /* old world */ asset != address(governanceToken) && asset == stakedGovernanceToken,\n      \"can only redeem new governance-token (L2) or all of old governance-token (LEV)\"\n    );\n    if (newWorld) {\n      stake(account, data.balance(account).sub(quantity));\n    } else {\n      require(data.balance(account) == quantity, \"must redeem all of staked quantity\");\n      stake(account, 0);\n    }\n  }\n\n  /***************************************************** vote to upgrade ****************************************************/\n\n  /// @notice vote for the current app proposal\n  ///\n  /// @param appId the app the sender is voting for\n  /// @param side yay or nay: true => approve, false => disapprove\n  function voteAppUpgrade(uint32 appId, bool side) external whenOn {\n    (, address proposal, uint activationBlock) = gluon.app(appId);\n    require(activationBlock > block.number, \"can not be voted\");\n    uint quantity = data.balance(msg.sender);\n    (uint approvals, uint disapprovals) = data.voteAppUpgrade(proposal, msg.sender, side, quantity);\n    emit Voted(appId, proposal, approvals, disapprovals, msg.sender);\n    concludeVoting(appId, proposal, approvals, disapprovals);\n  }\n\n  function updateVotes(address account, uint quantity, bool increased) private {\n    (address[] memory allProposed, bool[] memory sides) = data.getAllProposals(account);\n    for (uint i; i < allProposed.length; i++) {\n      uint32 appId = GluonCentric(allProposed[i]).id();\n      (, , uint activationBlock) = gluon.app(appId);\n      if (block.number > activationBlock) continue;\n      (uint approvals, uint disapprovals) = data.updateVotes(allProposed[i], sides[i], quantity, increased);\n      emit Voted(appId, allProposed[i], approvals, disapprovals, msg.sender);\n      concludeVoting(appId, allProposed[i], approvals, disapprovals);\n    }\n  }\n\n  function concludeVoting(uint32 appId, address proposal, uint approvals, uint disapprovals) private {\n    if (approvals.add(disapprovals) >= IERC20(governanceToken).totalSupply().mul(quorumPercentage).div(100)) {\n      if (approvals > disapprovals) {\n        AppGovernance(gluon).approve(appId);\n        emit VotingConcluded(appId, proposal, approvals, disapprovals, true);\n      } else {\n        AppGovernance(gluon).disapprove(appId);\n        emit VotingConcluded(appId, proposal, approvals, disapprovals, false);\n      }\n    }\n  }\n\n  /***************************************************** halting *****************************************************/\n\n  /// @notice halt the app. this action is irreversible.\n  /// (the only option at this point is have a proposal that will get to approval, then activated.)\n  /// should be called by an app-owner when the app has been compromised.\n  ///\n  /// Note the constraint that all apps but Registry & Stake must be halted first!\n  function switchOff() external onlyOwner {\n    uint32 totalAppsCount = gluon.totalAppsCount();\n    for (uint32 appId = 2; appId < totalAppsCount; appId++) {\n      AppState appState = AppState(gluon.current(appId));\n      require(!appState.isOn(), \"One of the apps is still ON\");\n    }\n    switchOff_();\n  }\n\n  /********************************************************************************************************************/\n}\n"
    }
  }
}