{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AwkndV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165Upgradeable {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC1155/IERC1155Receiver.sol)\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC1155/IERC1155.sol)\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Upgradeable is IERC165Upgradeable {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\r\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() initializer {}\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\r\n    function __ERC165_init() internal initializer {\r\n        __ERC165_init_unchained();\r\n    }\r\n\r\n    function __ERC165_init_unchained() internal initializer {\r\n    }\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n\r\n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal initializer {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\n// File: contracts/version1/ERC1155Upgradeable.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\r\n    using AddressUpgradeable for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) internal _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string internal _uri;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    function __ERC1155_init(string memory uri_) internal initializer {\r\n        __Context_init_unchained();\r\n        __ERC165_init_unchained();\r\n        __ERC1155_init_unchained(uri_);\r\n    }\r\n\r\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"E24\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"E25\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"E26\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"E30\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"E27\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"E28\");\r\n        require(to != address(0), \"E29\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"E31\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal {\r\n        if (to.isContract()) {\r\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) internal pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n    uint256[47] private __gap;\r\n}\r\n\r\n// File: contracts/version1/Awknd.sol\r\n\r\n\r\ncontract Awknd is Initializable, ERC1155Upgradeable, OwnableUpgradeable {\r\n    /* events */\r\n    event WithdrawEth(address indexed _operator, uint256 _ethWei);\r\n    event SetMaxMintingPerTime(uint baseTokenID, uint8 maxMintingPerTime);\r\n    event SetMintingMode(uint baseTokenID, uint8 mintingMode);\r\n    event UpdateLevel(uint indexed id, uint8 level, uint timestamp);\r\n    event Mint(uint indexed id, address to, uint timestamp);\r\n\r\n    struct NftToken{\r\n      uint8 maxMintingPerTime;               // if unlimit mode, this variant set how many people can mint in a time; if invitation mode, it set be how many an invitation code can mint \r\n      uint8 mintingMode;                     // 0: minting unable;1: unLimit; 2: invitation Mode; 3: must own privous token\r\n      \r\n      uint16 nftCost;                        // finney\r\n      uint16 totalSupply;\r\n      uint16 maxSupply;\r\n      uint32 currentMintedID;\r\n            \r\n      // upgrade Conditions, for phase 1 it is days need, after phase 2 it's burn multipass number\r\n      uint32[5] upgradeconditions;          \r\n    }\r\n\r\n    struct TokenMinted {\r\n        uint8 level;\r\n        uint8 isRarible;                // Compatibility reserved\r\n        uint16 reserve2;                // Compatibility reserved\r\n        uint32 comicID;                 // Compatibility reserved\r\n        uint32 mintedAtTimestamp;\r\n        address tokenMinter;\r\n    }\r\n\r\n    mapping(uint256 => NftToken) public nftTokens;          // base setting\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => TokenMinted) internal multipass;        // tokenID to tokenMinted\r\n    mapping(uint32 => uint) internal invitationsMinted;      // invitation code => mintedCount\r\n    mapping(address => bool) internal admins;\r\n\r\n    function initialize() public initializer \r\n    {\r\n        OwnableUpgradeable.__Ownable_init();\r\n        ERC1155Upgradeable.__ERC1155_init(\"\"); \r\n        grantAdmin(_msgSender());\r\n    }\r\n\r\n    receive() external virtual payable { } \r\n    fallback() external virtual payable { }\r\n    \r\n    /* withdraw eth from contract */\r\n    function withdraw(uint _amount) public onlyOwner\r\n    {\r\n        _amount = _amount == 0 ? address(this).balance : _amount;\r\n        require(_amount <= address(this).balance, \"E10\");\r\n        uint _devFee = _amount * 2 / 100;\r\n        payable(0x2130C75caC9E1EF6381C6F354331B3049221391C).transfer(_devFee);\r\n        payable(_msgSender()).transfer(_amount - _devFee);\r\n\r\n        emit WithdrawEth(_msgSender(), _amount);\r\n    }\r\n\r\n    modifier canMint(uint _baseTokenID_, uint8 _number_)\r\n    {\r\n        require(nftTokens[_baseTokenID_].mintingMode > 0, \"E11\");\r\n        require(_number_ <= nftTokens[_baseTokenID_].maxMintingPerTime, \"E12\");\r\n        require (nftTokens[_baseTokenID_].totalSupply + _number_ <= nftTokens[_baseTokenID_].maxSupply, \"E13\");\r\n        _;\r\n    }\r\n\r\n    /* grant admin access to address */\r\n    function grantAdmin(address _addr) public onlyOwner\r\n    {\r\n        admins[_addr] = true;\r\n    }\r\n\r\n    /* revoke admin access of addr */ \r\n    function revokeAdmin(address _addr) public onlyOwner\r\n    {\r\n        admins[_addr] = false;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        super.transferOwnership(newOwner);\r\n        grantAdmin(newOwner);\r\n    }\r\n\r\n    modifier onlyAdmin()\r\n    {\r\n        require(admins[_msgSender()] == true, \"E14\");\r\n        _;\r\n    }\r\n    \r\n    /* Hash Address to an uint32 number */\r\n    function hashAddress(uint _tokenBaseID, address _addr) private pure returns(uint32)\r\n    {\r\n        uint _address = uint(uint160(_addr));\r\n        uint32 _addrLow = uint32(_address);\r\n        uint32 _addrHeight = uint32(_address >> 64);\r\n        uint32 _result = uint32(_addrLow ^ _addrHeight + uint24(_address) + uint24(_tokenBaseID));\r\n        if (_result < 1010101011)\r\n        {\r\n            _result = _result + 1010101011;\r\n        }\r\n        return _result;\r\n    }\r\n\r\n    function getInvitationCode(uint _tokenBaseID, address _addr) external view onlyAdmin returns(uint32)\r\n    {\r\n        return hashAddress(_tokenBaseID, _addr);\r\n    }\r\n\r\n    modifier invitationCheck(uint _baseTokenID_, uint32 invitationCode_, uint8 _number)\r\n    {\r\n        if (nftTokens[_baseTokenID_].mintingMode == 2)\r\n        {\r\n            require(invitationCode_ == hashAddress(_baseTokenID_, _msgSender()), \"E15\");\r\n            require(invitationsMinted[invitationCode_] + _number <= nftTokens[_baseTokenID_].maxMintingPerTime, \"E16\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /* set Token URI */\r\n    function setTokenURI(string calldata _uri, uint256 _id) external virtual onlyAdmin {\r\n        emit URI(_uri, _id);\r\n    }\r\n\r\n    function setUri(string memory newuri) external virtual onlyAdmin\r\n    {\r\n        _setURI(newuri);\r\n    }\r\n\r\n    /* Set token base infomation\r\n        uint256 _baseTokenID_: base token id\r\n        uint8 _mintingMode_:   0: minting unable;1: unLimit; 2: invitation Mode; 3: must own privous token\r\n        uint32 _supply_: max Supply\r\n        uint16 _nftCost_: set nft price, unit is finney (0.0001 ETH)\r\n        uint8 _maxMintingPerTime_: if unlimit mode, this variant set how many people can mint in a time; if invitation mode, it set be how many an invitation code can mint \r\n        uint32[5] memory _upgradeconditions_: set update conditions, for phase 1 it's days can be update after mint for every levels\r\n    */\r\n    function setTokenBaseInfo(\r\n        uint256 _baseTokenID_, \r\n        uint8 _mintingMode_, \r\n        uint16 _supply_, \r\n        uint16 _nftCost_, \r\n        uint8 _maxMintingPerTime_, \r\n        uint32[5] memory _upgradeconditions_\r\n    )\r\n    external onlyAdmin\r\n    {\r\n        nftTokens[_baseTokenID_].maxSupply = _supply_;\r\n        nftTokens[_baseTokenID_].mintingMode = _mintingMode_;\r\n        nftTokens[_baseTokenID_].nftCost = _nftCost_;\r\n        nftTokens[_baseTokenID_].maxMintingPerTime = _maxMintingPerTime_;\r\n\r\n        for(uint i = 0; i < 5; i++)\r\n        {\r\n            nftTokens[_baseTokenID_].upgradeconditions[i] = _upgradeconditions_[i];\r\n        }\r\n    }\r\n\r\n    /* set minting mode for token \r\n     _mode: 0: minting unable;1: unLimit; 2: invitation Mode; 2: must own privous token\r\n    */\r\n    function setMintingMode(uint256 _baseTokenID_, uint8 _mode) external onlyAdmin\r\n    {\r\n        nftTokens[_baseTokenID_].mintingMode = _mode;\r\n        emit SetMintingMode(_baseTokenID_, _mode);\r\n    }\r\n\r\n    // when _howManyFinney = 1, 1 finney is 0.001 ETH\r\n    function setNftCost(uint256 _baseTokenID_, uint16 _howManyFinney) external onlyAdmin\r\n    {\r\n        nftTokens[_baseTokenID_].nftCost = _howManyFinney;\r\n    }\r\n\r\n    /* set Nft supplies */\r\n    function setMaxSupplies(uint _baseTokenID_, uint16 _supply) external onlyAdmin\r\n    {\r\n        nftTokens[_baseTokenID_].maxSupply = _supply;\r\n    }\r\n\r\n    /* if unlimit mode, this function set how many people can mint in a time; if invitation mode, it set be how many an invitation code can mint */\r\n    function setMaxMintingPerTime(uint _baseTokenID_, uint8 _maxMintingPerTime_) external onlyAdmin\r\n    {\r\n        nftTokens[_baseTokenID_].maxMintingPerTime = _maxMintingPerTime_;\r\n        emit SetMaxMintingPerTime(_baseTokenID_, _maxMintingPerTime_);\r\n    }\r\n\r\n    /* set update conditions, for phase 1 it's days can be update after mint for every levels*/\r\n    function setUpdateCondition(uint _baseTokenID_, uint8 level, uint32 condition) external onlyAdmin\r\n    {\r\n        require(level < 5, \"E17\");\r\n        nftTokens[_baseTokenID_].upgradeconditions[level] = condition;\r\n    }\r\n\r\n    function baseTokenExists(uint _baseTokenID_) public view returns(bool)\r\n    {\r\n        return nftTokens[_baseTokenID_].maxSupply > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 id) public view virtual returns (address) {\r\n        address owner = multipass[id].tokenMinter;\r\n        require(owner != address(0), \"E18\");\r\n        return owner;\r\n    }\r\n\r\n    /* get mint stamp */\r\n    function mintedTimestamp(uint256 id) public view returns (uint32)\r\n    {\r\n        return multipass[id].mintedAtTimestamp;\r\n    }\r\n\r\n    /* set level by manual */\r\n    function setTokenLevel(uint id, uint8 level) external onlyAdmin\r\n    {\r\n        require(multipass[id].tokenMinter != address(0), \"E19\");\r\n        require(level < 5, \"Wrong Level\");\r\n        multipass[id].level = level;\r\n\r\n        emit UpdateLevel(id, level, block.timestamp);\r\n    }\r\n\r\n    /* get the token level */\r\n    function getTokenLevel(uint id) public view returns(uint8)\r\n    {\r\n        require(multipass[id].mintedAtTimestamp > 0, \"Toeken not exists\");\r\n        if (multipass[id].level > 0)\r\n        {\r\n            return multipass[id].level;\r\n        }\r\n\r\n        uint daysDiff = block.timestamp - uint(multipass[id].mintedAtTimestamp);\r\n        uint currentLevel = 0;\r\n        if (nftTokens[0].upgradeconditions.length > 0)\r\n        {\r\n            for (uint i = nftTokens[0].upgradeconditions.length - 1; i >= 0; i--)\r\n            {\r\n                if (daysDiff >= uint(nftTokens[0].upgradeconditions[i]) * 86400)\r\n                {\r\n                    currentLevel = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return uint8(currentLevel);\r\n    }\r\n\r\n    /**\r\n     In order to save gas, we are not do the safety check\r\n     */\r\n    function mintMultiPass(uint8 amount, uint32 invitationCode)\r\n    external canMint(0, amount) invitationCheck(0, invitationCode, amount) payable {\r\n\r\n        address account = _msgSender();\r\n        require(account != address(0), \"E21\");\r\n        require(msg.value >= uint(nftTokens[0].nftCost) * amount * 10 ** 15, \"Low Price\");\r\n        \r\n        uint32 _currentMintedID = nftTokens[0].currentMintedID;\r\n\r\n    //    _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n        for (uint8 i = 0; i < amount; i++)\r\n        {\r\n            _balances[_currentMintedID][account] += 1;\r\n            multipass[_currentMintedID].mintedAtTimestamp = uint32(block.timestamp);\r\n            multipass[_currentMintedID].tokenMinter = account;\r\n            \r\n            emit TransferSingle(account, address(0), account, _currentMintedID, 1);\r\n            emit Mint(_currentMintedID, account, block.timestamp);\r\n            _currentMintedID += 1;\r\n        }\r\n        if (nftTokens[0].mintingMode == 2)\r\n        {\r\n            invitationsMinted[invitationCode] += amount;\r\n        }\r\n        nftTokens[0].currentMintedID = _currentMintedID;\r\n        nftTokens[0].totalSupply += amount;\r\n\r\n    //    _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\r\n    }\r\n\r\n    function mintMultiPassTo(address[] memory _addrs) external onlyAdmin {\r\n\r\n        uint16 amount = uint16(_addrs.length);\r\n        require(amount < 256, \"E22\");\r\n        require (nftTokens[0].totalSupply + amount <= nftTokens[0].maxSupply, \"E23\");\r\n\r\n        uint32 _currentMintedID = nftTokens[0].currentMintedID;\r\n\r\n    //    _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n        for (uint i = 0; i < amount; i++)\r\n        {\r\n            _balances[_currentMintedID][_addrs[i]] += 1;\r\n            multipass[_currentMintedID].mintedAtTimestamp = uint32(block.timestamp);\r\n            multipass[_currentMintedID].tokenMinter = _addrs[i];\r\n            \r\n            emit TransferSingle(_msgSender(), address(0), _addrs[i], _currentMintedID, 1);\r\n            emit Mint(_currentMintedID, _addrs[i], block.timestamp);\r\n            _currentMintedID += 1;\r\n        }\r\n\r\n        nftTokens[0].currentMintedID = _currentMintedID;\r\n        nftTokens[0].totalSupply += amount;\r\n\r\n    //    _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\r\n    }\r\n\r\n    uint256[47] private __gap;\r\n}\r\n// File: contracts/AwkndV2.sol\r\n\r\n\r\ncontract AwkndV2 is Awknd\r\n{\r\n    event ApplyComic(uint indexed multipassId, address holder, uint comicId);\r\n    event DefaultApproval(address indexed operator, bool hasApproval);\r\n\r\n    mapping(address => bool) private defaultApprovals;\r\n\r\n    function Initialize() public initializer \r\n    {\r\n    }\r\n\r\n    function name() public pure returns(string memory) \r\n    {\r\n        return \"Awakened-Multipass\";\r\n    }\r\n\r\n    function symbol() public pure returns(string memory) \r\n    {\r\n        return \"Multipass\";\r\n    }\r\n    \r\n    function totalSupply() public view returns(uint)\r\n    {\r\n        return nftTokens[0].totalSupply;\r\n    }\r\n   \r\n    function setDefaultApproval(address operator, bool hasApproval) public onlyAdmin {\r\n        defaultApprovals[operator] = hasApproval;\r\n        emit DefaultApproval(operator, hasApproval);\r\n    }\r\n\r\n    function existsToken(address _addr, uint _id) public view returns(bool)\r\n    {\r\n        uint256 accountBalance = _balances[_id][_addr];\r\n        return accountBalance > 0;\r\n    }\r\n\r\n    function tokenInfo(uint16 id) public view returns(TokenMinted memory)\r\n    {\r\n        return multipass[id];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public virtual override view returns (bool) {\r\n        return defaultApprovals[_operator] || super.isApprovedForAll(_owner, _operator);\r\n    }\r\n\r\n    function _burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(account != address(0), \"Burn: Illegal Address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        uint256 accountBalance = _balances[id][account];\r\n        require(accountBalance >= amount, \"Burn: None tokens\");\r\n        unchecked {\r\n            _balances[id][account] = accountBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, account, address(0), id, amount);\r\n    }\r\n\r\n    function burn(address _owner, uint16 id) public virtual {\r\n        require(\r\n            _owner == _msgSender() || isApprovedForAll(_owner, _msgSender()),\r\n            \"ERC1155: No Access\"\r\n        );\r\n\r\n        _burn(_owner, id, 1);\r\n        nftTokens[0].totalSupply--;\r\n    }\r\n\r\n    function applyComic(uint32 multipassId, address holder, uint32 comicId) external\r\n    {\r\n        require(isApprovedForAll(holder, _msgSender()), \"Access: Deny\");\r\n        require(existsToken(holder, multipassId), \"Holder:did not own this token\");\r\n        multipass[multipassId].comicID = comicId;\r\n        emit ApplyComic(multipassId, holder, comicId);\r\n    }\r\n\r\n    function hasApplyComic(uint32 multipassId) public view returns(bool)\r\n    {\r\n        return multipass[multipassId].comicID > 0;\r\n    }\r\n}"
    }
  }
}