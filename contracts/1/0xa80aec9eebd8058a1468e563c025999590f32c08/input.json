{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"raiden/Token.sol":{"content":"pragma solidity 0.6.4;\n\ninterface Token {\n\n    /// @return supply total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n"},"raiden/Utils.sol":{"content":"pragma solidity 0.6.4;\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n    enum MessageTypeId {\n        None,\n        BalanceProof,\n        BalanceProofUpdate,\n        Withdraw,\n        CooperativeSettle,\n        IOU,\n        MSReward\n    }\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly {\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n}\n"},"services/ServiceRegistry.sol":{"content":"pragma solidity 0.6.4;\n\nimport \"raiden/Token.sol\";\nimport \"raiden/Utils.sol\";\n\ncontract ServiceRegistryConfigurableParameters {\n    address public controller;\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"caller is not the controller\");\n        _;\n    }\n\n    // After a price is set to set_price at timestamp set_price_at,\n    // the price decays according to decayedPrice().\n    uint256 public set_price;\n    uint256 public set_price_at;\n\n    /// The amount of time (in seconds) till the price decreases to roughly 1/e.\n    uint256 public decay_constant = 200 days;\n\n    // Once the price is at min_price, it can't decay further.\n    uint256 public min_price = 1000;\n\n    // Whenever a deposit comes in, the price is multiplied by numerator / denominator.\n    uint256 public price_bump_numerator = 1;\n    uint256 public price_bump_denominator = 1;\n\n    // The duration of service registration/extension in seconds\n    uint256 public registration_duration = 180 days;\n\n    // If true, new deposits are no longer accepted.\n    bool public deprecated = false;\n\n    function setDeprecationSwitch() public onlyController returns (bool _success) {\n        deprecated = true;\n        return true;\n    }\n\n    function changeParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) public onlyController returns (bool _success) {\n        changeParametersInternal(\n            _price_bump_numerator,\n            _price_bump_denominator,\n            _decay_constant,\n            _min_price,\n            _registration_duration\n        );\n        return true;\n    }\n\n    function changeParametersInternal(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) internal {\n        refreshPrice();\n        setPriceBumpParameters(_price_bump_numerator, _price_bump_denominator);\n        setMinPrice(_min_price);\n        setDecayConstant(_decay_constant);\n        setRegistrationDuration(_registration_duration);\n    }\n\n    // Updates set_price to be currentPrice() and set_price_at to be now\n    function refreshPrice() private {\n        set_price = currentPrice();\n        set_price_at = now;\n    }\n\n    function setPriceBumpParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator\n    ) private {\n        require(_price_bump_denominator > 0, \"divide by zero\");\n        require(_price_bump_numerator >= _price_bump_denominator, \"price dump instead of bump\");\n        require(_price_bump_numerator < 2 ** 40, \"price dump numerator is too big\");\n        price_bump_numerator = _price_bump_numerator;\n        price_bump_denominator = _price_bump_denominator;\n    }\n\n    function setMinPrice(uint256 _min_price) private {\n        // No checks.  Even allowing zero.\n        min_price = _min_price;\n        // No checks or modifications on set_price.\n        // Even if set_price is smaller than min_price, currentPrice() function returns min_price.\n    }\n\n    function setDecayConstant(uint256 _decay_constant) private {\n        require(_decay_constant > 0, \"attempt to set zero decay constant\");\n        require(_decay_constant < 2 ** 40, \"too big decay constant\");\n        decay_constant = _decay_constant;\n    }\n\n    function setRegistrationDuration(uint256 _registration_duration) private {\n        // No checks.  Even allowing zero (when no new registrations are possible).\n        registration_duration = _registration_duration;\n    }\n\n\n    /// @notice The amount to deposit for registration or extension\n    /// Note: the price moves quickly depending on what other addresses do.\n    /// The current price might change after you send a `deposit()` transaction\n    /// before the transaction is executed.\n    function currentPrice() public view returns (uint256) {\n        require(now >= set_price_at, \"An underflow in price computation\");\n        uint256 seconds_passed = now - set_price_at;\n\n        return decayedPrice(set_price, seconds_passed);\n    }\n\n\n    /// @notice Calculates the decreased price after a number of seconds\n    /// @param _set_price The initial price\n    /// @param _seconds_passed The number of seconds passed since the initial\n    /// price was set\n    function decayedPrice(uint256 _set_price, uint256 _seconds_passed) public\n        view returns (uint256) {\n        // We are here trying to approximate some exponential decay.\n        // exp(- X / A) where\n        //   X is the number of seconds since the last price change\n        //   A is the decay constant (A = 200 days corresponds to 0.5% decrease per day)\n\n        // exp(- X / A) ~~ P / Q where\n        //   P = 24 A^4\n        //   Q = 24 A^4 + 24 A^3X + 12 A^2X^2 + 4 AX^3 + X^4\n        // Note: swap P and Q, and then think about the Taylor expansion.\n\n        uint256 X = _seconds_passed;\n\n        if (X >= 2 ** 40) { // The computation below overflows.\n            return min_price;\n        }\n\n        uint256 A = decay_constant;\n\n        uint256 P = 24 * (A ** 4);\n        uint256 Q = P + 24*(A**3)*X + 12*(A**2)*(X**2) + 4*A*(X**3) + X**4;\n\n        // The multiplication below is not supposed to overflow because\n        // _set_price should be at most 2 ** 90 and\n        // P should be at most 24 * (2 ** 40).\n        uint256 price = _set_price * P / Q;\n\n        // Not allowing a price smaller than min_price.\n        // Once it's too low it's too low forever.\n        if (price < min_price) {\n            price = min_price;\n        }\n        return price;\n    }\n}\n\n\ncontract Deposit {\n    // This contract holds ERC20 tokens as deposit until a predetemined point of time.\n\n    // The ERC20 token contract that the deposit is about.\n    Token public token;\n\n    // The address of ServiceRegistry contract that this deposit is associated with.\n    // If the address has no code, service_registry.deprecated() call will fail.\n    ServiceRegistryConfigurableParameters service_registry;\n\n    // The address that can withdraw the deposit after the release time.\n    address public withdrawer;\n\n    // The timestamp after which the withdrawer can withdraw the deposit.\n    uint256 public release_at;\n\n    /// @param _token The address of the ERC20 token contract where the deposit is accounted\n    /// @param _release_at The timestap after which the withdrawer can withdraw the deposit\n    /// @param _withdrawer The address that can withdraw the deposit after the release time\n    /// @param _service_registry The address of ServiceRegistry whose deprecation enables immediate withdrawals\n    constructor(address _token, uint256 _release_at, address _withdrawer, address _service_registry) public {\n        token = Token(_token);\n        // Don't care even if it's in the past.\n        release_at = _release_at;\n        withdrawer = _withdrawer;\n        service_registry = ServiceRegistryConfigurableParameters(_service_registry);\n    }\n\n    // In order to make a deposit, transfer the ERC20 token into this contract.\n    // If you transfer a wrong kind of ERC20 token or ETH into this contract,\n    // these tokens will be lost forever.\n\n    /// @notice Withdraws the tokens that have been deposited\n    /// Only `withdrawer` can call this.\n    /// @param _to The address where the withdrawn tokens should go\n    function withdraw(address payable _to) external {\n        uint256 balance = token.balanceOf(address(this));\n        require(msg.sender == withdrawer, \"the caller is not the withdrawer\");\n        require(now >= release_at || service_registry.deprecated(), \"deposit not released yet\");\n        require(balance > 0, \"nothing to withdraw\");\n        require(token.transfer(_to, balance), \"token didn't transfer\");\n        selfdestruct(_to); // The contract can disappear.\n    }\n}\n\n\ncontract ServiceRegistry is Utils, ServiceRegistryConfigurableParameters {\n    Token public token;\n\n    mapping(address => uint256) public service_valid_till;\n    mapping(address => string) public urls;  // URLs of services for HTTP access\n\n    // An append-only list of addresses that have ever made a deposit.\n    // Starting from this list, all alive registrations can be figured out.\n    address[] public ever_made_deposits;\n\n    // @param service The address of the registered service provider\n    // @param valid_till The timestamp of the moment when the registration expires\n    // @param deposit_amount The amount of deposit transferred\n    // @param deposit The address of Deposit instance where the deposit is stored\n    event RegisteredService(address indexed service, uint256 valid_till, uint256 deposit_amount, Deposit deposit_contract);\n\n    // @param _token_for_registration The address of the ERC20 token contract that services use for registration fees\n    // @param _controller The address that can change parameters and deprecate the ServiceRegistry\n    // @param _initial_price The amount of tokens needed initially for a slot\n    // @param _price_bump_numerator The ratio of price bump after deposit is made (numerator)\n    // @param _price_bump_denominator The ratio of price bump after deposit is made (denominator)\n    // @param _decay_constant The number of seconds after which the price becomes roughly 1/e\n    // @param _min_price The minimum amount of tokens needed for a slot\n    // @param _registration_duration The number of seconds (roughly, barring block time & miners'\n    // timestamp errors) of a slot gained for a successful deposit\n    constructor(\n            address _token_for_registration,\n            address _controller,\n            uint256 _initial_price,\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) public {\n        require(_token_for_registration != address(0x0), \"token at address zero\");\n        require(contractExists(_token_for_registration), \"token has no code\");\n        require(_initial_price >= min_price, \"initial price too low\");\n        require(_initial_price <= 2 ** 90, \"intiial price too high\");\n\n        token = Token(_token_for_registration);\n        // Check if the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"total supply zero\");\n        controller = _controller;\n\n        // Set up the price and the set price timestamp\n        set_price = _initial_price;\n        set_price_at = now;\n\n        // Set the parameters\n        changeParametersInternal(_price_bump_numerator, _price_bump_denominator, _decay_constant, _min_price, _registration_duration);\n    }\n\n    // @notice Locks tokens and registers a service or extends the registration\n    // @param _limit_amount The biggest amount of tokens that the caller is willing to deposit\n    // The call fails if the current price is higher (this is always possible\n    // when other parties have just called `deposit()`)\n    function deposit(uint _limit_amount) public returns (bool _success) {\n        require(! deprecated, \"this contract was deprecated\");\n\n        uint256 amount = currentPrice();\n        require(_limit_amount >= amount, \"not enough limit\");\n\n        // Extend the service position.\n        uint256 valid_till = service_valid_till[msg.sender];\n        if (valid_till == 0) { // a first time joiner\n            ever_made_deposits.push(msg.sender);\n        }\n        if (valid_till < now) { // a first time joiner or an expired service.\n            valid_till = now;\n        }\n        // Check against overflow.\n        require(valid_till < valid_till + registration_duration, \"overflow during extending the registration\");\n        valid_till = valid_till + registration_duration;\n        assert(valid_till > service_valid_till[msg.sender]);\n        service_valid_till[msg.sender] = valid_till;\n\n        // Record the price\n        set_price = amount * price_bump_numerator / price_bump_denominator;\n        if (set_price > 2 ** 90) {\n            set_price = 2 ** 90; // Preventing overflows.\n        }\n        set_price_at = now;\n\n        // Move the deposit in a new Deposit contract.\n        assert(now < valid_till);\n        Deposit depo = new Deposit(address(token), valid_till, msg.sender, address(this));\n        require(token.transferFrom(msg.sender, address(depo), amount), \"Token transfer for deposit failed\");\n\n        // Fire event\n        emit RegisteredService(msg.sender, valid_till, amount, depo);\n\n        return true;\n    }\n\n    /// @notice Sets the URL used to access a service via HTTP\n    /// Only a currently registered service can call this successfully\n    /// @param new_url The new URL string to be stored\n    function setURL(string memory new_url) public returns (bool _success) {\n        require(hasValidRegistration(msg.sender), \"registration expired\");\n        require(bytes(new_url).length != 0, \"new url is empty string\");\n        urls[msg.sender] = new_url;\n        return true;\n    }\n\n    /// A getter function for seeing the length of ever_made_deposits array\n    function everMadeDepositsLen() public view returns (uint256 _len) {\n        return ever_made_deposits.length;\n    }\n\n    function hasValidRegistration(address _address) public view returns (bool _has_registration) {\n        return now < service_valid_till[_address];\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"}}}