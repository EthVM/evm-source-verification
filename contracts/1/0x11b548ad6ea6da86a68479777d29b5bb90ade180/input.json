{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"guniResolver.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\ninterface IERC20 {\n\n}\n\ninterface IGUniPool {\n    function token0() external view returns (IERC20);\n\n    function token1() external view returns (IERC20);\n\n    // function pool() external view returns (IUniswapV3Pool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // function mint(uint256 mintAmount, address receiver)\n    //     external\n    //     returns (\n    //         uint256 amount0,\n    //         uint256 amount1,\n    //         uint128 liquidityMinted\n    //     );\n\n    // function burn(uint256 burnAmount, address receiver)\n    //     external\n    //     returns (\n    //         uint256 amount0,\n    //         uint256 amount1,\n    //         uint128 liquidityBurned\n    //     );\n\n    // function getMintAmounts(uint256 amount0Max, uint256 amount1Max)\n    //     external\n    //     view\n    //     returns (\n    //         uint256 amount0,\n    //         uint256 amount1,\n    //         uint256 mintAmount\n    //     );\n\n    // function getPositionID() external view returns (bytes32 positionID);\n}\n\ninterface IGUniRouter {\n\n    function getPoolUnderlyingBalances(IGUniPool pool)\n        external\n        view\n        returns (uint256 amount0, uint256 amount1);\n\n    function getUnderlyingBalances(\n        IGUniPool pool,\n        address account,\n        uint256 balance\n    ) external view returns (uint256 amount0, uint256 amount1);\n\n}\n\nstruct StakingRewardsInfo {\n    address stakingRewards;\n    uint rewardAmount;\n}\ninterface StakingFactoryInterface {\n\n    function stakingRewardsInfoByStakingToken(address) external view returns(StakingRewardsInfo memory);\n\n}\n\ninterface StakingInterface {\n    function totalSupply() external view returns (uint256);\n    function rewardRate() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function earned(address account) external view returns (uint256);\n    function rewardPerToken() external view returns (uint256);\n}\n\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n}\n\ncontract Helpers is DSMath {\n\n    StakingFactoryInterface public constant getStakingFactory = StakingFactoryInterface(0xf39eC5a471edF20Ecc7db1c2c34B4C73ab4B2C19);\n    IGUniRouter public constant gelatoRouter = IGUniRouter(0x8CA6fa325bc32f86a12cC4964Edf1f71655007A7);\n\n    struct UserData {\n        address pool; // address of pool contract\n        address staking; // address of staking contract\n        address token0Addr; // address of token 0\n        address token1Addr; // address of token 1\n        uint poolTokenSupply; // Total supply of Pool token\n        uint poolToken0Bal; // balance of total pool for token0\n        uint poolToken1Bal; // balance of total pool for token1\n        uint poolTokenSupplyStaked; // total pool token locked in staking contract\n        uint stakingToken0Bal; // total balance of token0 in Staking\n        uint stakingToken1Bal; // total balance of token1 in Staking\n        uint rewardRate; // INST distributing per second\n        uint token0Bal; // balance of token 0 of user\n        uint token1Bal; // balance of token 1 of user\n        uint earned; // INST earned from staking\n        uint stakedBal; // user's pool token bal in staking contract\n        uint poolBal; // ideal pool token in user's DSA\n        uint totalBal; // stakedBal + poolTknBal\n    }\n\n}\n\ncontract Resolver is Helpers {\n\n    function getSinglePosition(address user, address pool) public view returns(UserData memory _data) {\n        _data.pool = pool;\n        StakingInterface stakingContract = StakingInterface(getStakingFactory.stakingRewardsInfoByStakingToken(pool).stakingRewards);\n        _data.staking = address(stakingContract);\n        IGUniPool poolContract = IGUniPool(pool);\n        _data.token0Addr = address(poolContract.token0());\n        _data.token1Addr = address(poolContract.token1());\n        if (_data.staking == address(0)) {\n            _data.earned = 0;\n            _data.stakedBal = 0;\n        } else {\n            _data.earned = stakingContract.earned(user);\n            _data.stakedBal = stakingContract.balanceOf(user);\n        }\n        _data.poolBal = poolContract.balanceOf(user);\n        _data.totalBal = add(_data.stakedBal, _data.poolBal);\n        (_data.token0Bal, _data.token1Bal) = gelatoRouter.getUnderlyingBalances(poolContract, user, _data.totalBal);\n        _data.poolTokenSupply = poolContract.balanceOf(user);\n        (_data.poolToken0Bal, _data.poolToken1Bal) = gelatoRouter.getPoolUnderlyingBalances(poolContract);\n        _data.poolTokenSupplyStaked = stakingContract.totalSupply();\n        (_data.stakingToken0Bal, _data.stakingToken1Bal) = gelatoRouter.getUnderlyingBalances(poolContract, _data.staking, _data.poolTokenSupplyStaked);\n        _data.rewardRate = stakingContract.rewardRate();\n    }\n\n    function getPosition(address user, address[] memory pools) public view returns(UserData[] memory _data) {\n        _data = new UserData[](pools.length); \n        for (uint i = 0; i < pools.length; i++) {\n            _data[i] = getSinglePosition(user, pools[i]);\n        }\n    }\n\n}\n"}}}