{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":0},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BatchReader.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC1820Registry {\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\r\n    function setManager(address _addr, address _newManager) external;\r\n    function getManager(address _addr) public view returns (address);\r\n}\r\n\r\n\r\n/// Base client to interact with the registry.\r\ncontract ERC1820Client {\r\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\r\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\r\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\r\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\r\n    }\r\n\r\n    function delegateManagement(address _newManager) internal {\r\n        ERC1820REGISTRY.setManager(address(this), _newManager);\r\n    }\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\ncontract ERC1820Implementer {\r\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n  mapping(bytes32 => bool) internal _interfaceHashes;\r\n\r\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\r\n    external\r\n    view\r\n    returns(bytes32)\r\n  {\r\n    if(_interfaceHashes[interfaceHash]) {\r\n      return ERC1820_ACCEPT_MAGIC;\r\n    } else {\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  function _setInterface(string memory interfaceLabel) internal {\r\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\r\n  }\r\n\r\n}\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n/**\r\n * @title IERC1400 security token standard\r\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\r\n */\r\ninterface IERC1400 /*is IERC20*/ { // Interfaces can currently not inherit interfaces, but IERC1400 shall include IERC20\r\n\r\n  // ****************** Document Management *******************\r\n  function getDocument(bytes32 name) external view returns (string memory, bytes32);\r\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\r\n\r\n  // ******************* Token Information ********************\r\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\r\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\r\n\r\n  // *********************** Transfers ************************\r\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\r\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\r\n\r\n  // *************** Partition Token Transfers ****************\r\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\r\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\r\n\r\n  // ****************** Controller Operation ******************\r\n  function isControllable() external view returns (bool);\r\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorTransferByPartition\"\r\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \"operatorRedeemByPartition\"\r\n\r\n  // ****************** Operator Management *******************\r\n  function authorizeOperator(address operator) external;\r\n  function revokeOperator(address operator) external;\r\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\r\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\r\n\r\n  // ****************** Operator Information ******************\r\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\r\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\r\n\r\n  // ********************* Token Issuance *********************\r\n  function isIssuable() external view returns (bool);\r\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\r\n\r\n  // ******************** Token Redemption ********************\r\n  function redeem(uint256 value, bytes calldata data) external;\r\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\r\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\r\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\r\n\r\n  // ******************* Transfer Validity ********************\r\n  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\r\n  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\r\n  //\r\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\r\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \r\n\r\n  // ******************* Controller Events ********************\r\n  // We don't use this event as we don't use \"controllerTransfer\"\r\n  //   event ControllerTransfer(\r\n  //       address controller,\r\n  //       address indexed from,\r\n  //       address indexed to,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n  //\r\n  // We don't use this event as we don't use \"controllerRedeem\"\r\n  //   event ControllerRedemption(\r\n  //       address controller,\r\n  //       address indexed tokenHolder,\r\n  //       uint256 value,\r\n  //       bytes data,\r\n  //       bytes operatorData\r\n  //   );\r\n\r\n  // ******************** Document Events *********************\r\n  event Document(bytes32 indexed name, string uri, bytes32 documentHash);\r\n\r\n  // ******************** Transfer Events *********************\r\n  event TransferByPartition(\r\n      bytes32 indexed fromPartition,\r\n      address operator,\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 value,\r\n      bytes data,\r\n      bytes operatorData\r\n  );\r\n\r\n  event ChangedPartition(\r\n      bytes32 indexed fromPartition,\r\n      bytes32 indexed toPartition,\r\n      uint256 value\r\n  );\r\n\r\n  // ******************** Operator Events *********************\r\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\r\n\r\n  // ************** Issuance / Redemption Events **************\r\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\r\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\r\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\r\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\r\n\r\n}\r\n\r\n/**\r\n * Reason codes - ERC-1066\r\n *\r\n * To improve the token holder experience, canTransfer MUST return a reason byte code\r\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\r\n * An implementation can also return arbitrary data as a bytes32 to provide additional\r\n * information not captured by the reason code.\r\n * \r\n * Code\tReason\r\n * 0x50\ttransfer failure\r\n * 0x51\ttransfer success\r\n * 0x52\tinsufficient balance\r\n * 0x53\tinsufficient allowance\r\n * 0x54\ttransfers halted (contract paused)\r\n * 0x55\tfunds locked (lockup period)\r\n * 0x56\tinvalid sender\r\n * 0x57\tinvalid receiver\r\n * 0x58\tinvalid operator (transfer agent)\r\n * 0x59\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5a\t\r\n * 0x5b\t\r\n * 0x5c\t\r\n * 0x5d\t\r\n * 0x5e\t\r\n * 0x5f\ttoken meta or info\r\n *\r\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\r\n */\r\n\r\n/*\r\n * This code has not been reviewed.\r\n * Do not use or deploy this code before reviewing it personally first.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Interface to the extension types\r\n */\r\ninterface IExtensionTypes {\r\n  enum CertificateValidation {\r\n    None,\r\n    NonceBased,\r\n    SaltBased\r\n  }\r\n}\r\n\r\ninterface IERC1400Extended {\r\n    // Not a real interface but added here for functions which don't belong to IERC1400\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function controllers() external view returns (address[] memory);\r\n\r\n    function totalPartitions() external view returns (bytes32[] memory);\r\n\r\n    function getDefaultPartitions() external view returns (bytes32[] memory);\r\n\r\n    function totalSupplyByPartition(bytes32 partition) external view returns (uint256);\r\n}\r\n\r\ncontract IERC1400TokensValidatorExtended is IExtensionTypes {\r\n    // Not a real interface but added here for functions which don't belong to IERC1400TokensValidator\r\n\r\n    function retrieveTokenSetup(address token) external view returns (CertificateValidation, bool, bool, bool, bool, address[] memory);\r\n\r\n    function spendableBalanceOfByPartition(address token, bytes32 partition, address account) external view returns (uint256);\r\n\r\n    function isAllowlisted(address token, address account) public view returns (bool);\r\n\r\n    function isBlocklisted(address token, address account) public view returns (bool);\r\n}\r\n\r\n/**\r\n * @title BatchReader\r\n * @dev Proxy contract to read multiple information from the smart contract in a single contract call.\r\n */\r\ncontract BatchReader is IExtensionTypes, ERC1820Client, ERC1820Implementer {\r\n    using SafeMath for uint256;\r\n\r\n    string internal constant BALANCE_READER = \"BatchReader\";\r\n\r\n    string constant internal ERC1400_TOKENS_VALIDATOR = \"ERC1400TokensValidator\";\r\n\r\n    // Mapping from token to token extension address\r\n    mapping(address => address) internal _extension;\r\n\r\n    constructor() public {\r\n        ERC1820Implementer._setInterface(BALANCE_READER);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token supplies.\r\n     * @return Batch of token supplies.\r\n     */\r\n    function batchTokenSuppliesInfos(address[] calldata tokens) external view returns (uint256[] memory, uint256[] memory, bytes32[] memory, uint256[] memory, uint256[] memory, bytes32[] memory) {\r\n        uint256[] memory batchTotalSupplies = new uint256[](tokens.length);\r\n        for (uint256 j = 0; j < tokens.length; j++) {\r\n            batchTotalSupplies[j] = IERC20(tokens[j]).totalSupply();\r\n        }\r\n\r\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions, uint256[] memory batchPartitionSupplies) = batchTotalPartitions(tokens);\r\n\r\n        (uint256[] memory defaultPartitionsLengths, bytes32[] memory batchDefaultPartitions) = batchDefaultPartitions(tokens);\r\n\r\n        return (batchTotalSupplies, totalPartitionsLengths, batchTotalPartitions, batchPartitionSupplies, defaultPartitionsLengths, batchDefaultPartitions);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token roles.\r\n     * @return Batch of token roles.\r\n     */\r\n    function batchTokenRolesInfos(address[] calldata tokens) external view returns (address[] memory, uint256[] memory, address[] memory, uint256[] memory, address[] memory) {\r\n        (uint256[] memory batchExtensionControllersLength, address[] memory batchExtensionControllers) = batchExtensionControllers(tokens);\r\n\r\n        (uint256[] memory batchControllersLength, address[] memory batchControllers) = batchControllers(tokens);\r\n\r\n        address[] memory batchOwners = new address[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            batchOwners[i] = IERC1400Extended(tokens[i]).owner();\r\n        }\r\n        return (batchOwners, batchControllersLength, batchControllers, batchExtensionControllersLength, batchExtensionControllers);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token controllers.\r\n     * @return Batch of token controllers.\r\n     */\r\n    function batchControllers(address[] memory tokens) public view returns (uint256[] memory, address[] memory) {\r\n        uint256[] memory batchControllersLength = new uint256[](tokens.length);\r\n        uint256 controllersLength=0;\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            address[] memory controllers = IERC1400Extended(tokens[i]).controllers();\r\n            batchControllersLength[i] = controllers.length;\r\n            controllersLength = controllersLength.add(controllers.length);\r\n        }\r\n\r\n        address[] memory batchControllersResponse = new address[](controllersLength);\r\n\r\n        uint256 counter = 0;\r\n        for (uint256 j = 0; j < tokens.length; j++) {\r\n            address[] memory controllers = IERC1400Extended(tokens[j]).controllers();\r\n\r\n            for (uint256 k = 0; k < controllers.length; k++) {\r\n                batchControllersResponse[counter] = controllers[k];\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return (batchControllersLength, batchControllersResponse);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token extension controllers.\r\n     * @return Batch of token extension controllers.\r\n     */\r\n    function batchExtensionControllers(address[] memory tokens) public view returns (uint256[] memory, address[] memory) {\r\n        address[] memory batchTokenExtension = new address[](tokens.length);\r\n\r\n        uint256[] memory batchExtensionControllersLength = new uint256[](tokens.length);\r\n        uint256 extensionControllersLength=0;\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            batchTokenExtension[i] = interfaceAddr(tokens[i], ERC1400_TOKENS_VALIDATOR);\r\n\r\n            if (batchTokenExtension[i] != address(0)) {\r\n                (,,,,,address[] memory extensionControllers) = IERC1400TokensValidatorExtended(batchTokenExtension[i]).retrieveTokenSetup(tokens[i]);\r\n                batchExtensionControllersLength[i] = extensionControllers.length;\r\n                extensionControllersLength = extensionControllersLength.add(extensionControllers.length);\r\n            } else {\r\n                batchExtensionControllersLength[i] = 0;\r\n            }\r\n        }\r\n\r\n        address[] memory batchExtensionControllersResponse = new address[](extensionControllersLength);\r\n\r\n        uint256 counter = 0;\r\n        for (uint256 j = 0; j < tokens.length; j++) {\r\n            if (batchTokenExtension[j] != address(0)) {\r\n                (,,,,,address[] memory extensionControllers) = IERC1400TokensValidatorExtended(batchTokenExtension[j]).retrieveTokenSetup(tokens[j]);\r\n\r\n                for (uint256 k = 0; k < extensionControllers.length; k++) {\r\n                    batchExtensionControllersResponse[counter] = extensionControllers[k];\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (batchExtensionControllersLength, batchExtensionControllersResponse);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token extension setup.\r\n     * @return Batch of token extension setup.\r\n     */\r\n    function batchTokenExtensionSetup(address[] calldata tokens) external view returns (address[] memory, CertificateValidation[] memory, bool[] memory, bool[] memory, bool[] memory, bool[] memory) {\r\n        (address[] memory batchTokenExtension, CertificateValidation[] memory batchCertificateActivated, bool[] memory batchAllowlistActivated, bool[] memory batchBlocklistActivated) = batchTokenExtensionSetup1(tokens);\r\n\r\n        (bool[] memory batchGranularityByPartitionActivated, bool[] memory batchHoldsActivated) = batchTokenExtensionSetup2(tokens);\r\n        return (batchTokenExtension, batchCertificateActivated, batchAllowlistActivated, batchBlocklistActivated, batchGranularityByPartitionActivated, batchHoldsActivated);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token extension setup (part 1).\r\n     * @return Batch of token extension setup (part 1).\r\n     */\r\n    function batchTokenExtensionSetup1(address[] memory tokens) public view returns (address[] memory, CertificateValidation[] memory, bool[] memory, bool[] memory) {\r\n        address[] memory batchTokenExtension = new address[](tokens.length);\r\n        CertificateValidation[] memory batchCertificateActivated = new CertificateValidation[](tokens.length);\r\n        bool[] memory batchAllowlistActivated = new bool[](tokens.length);\r\n        bool[] memory batchBlocklistActivated = new bool[](tokens.length);\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            batchTokenExtension[i] = interfaceAddr(tokens[i], ERC1400_TOKENS_VALIDATOR);\r\n\r\n            if (batchTokenExtension[i] != address(0)) {\r\n                (CertificateValidation certificateActivated, bool allowlistActivated, bool blocklistActivated,,,) = IERC1400TokensValidatorExtended(batchTokenExtension[i]).retrieveTokenSetup(tokens[i]);\r\n                batchCertificateActivated[i] = certificateActivated;\r\n                batchAllowlistActivated[i] = allowlistActivated;\r\n                batchBlocklistActivated[i] = blocklistActivated;\r\n            } else {\r\n                batchCertificateActivated[i] = CertificateValidation.None;\r\n                batchAllowlistActivated[i] = false;\r\n                batchBlocklistActivated[i] = false;\r\n            }\r\n        }\r\n\r\n        return (batchTokenExtension, batchCertificateActivated, batchAllowlistActivated, batchBlocklistActivated);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token extension setup (part 2).\r\n     * @return Batch of token extension setup (part 2).\r\n     */\r\n    function batchTokenExtensionSetup2(address[] memory tokens) public view returns (bool[] memory, bool[] memory) {\r\n        address[] memory batchTokenExtension = new address[](tokens.length);\r\n        bool[] memory batchGranularityByPartitionActivated = new bool[](tokens.length);\r\n        bool[] memory batchHoldsActivated = new bool[](tokens.length);\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            batchTokenExtension[i] = interfaceAddr(tokens[i], ERC1400_TOKENS_VALIDATOR);\r\n\r\n            if (batchTokenExtension[i] != address(0)) {\r\n                (,,, bool granularityByPartitionActivated, bool holdsActivated,) = IERC1400TokensValidatorExtended(batchTokenExtension[i]).retrieveTokenSetup(tokens[i]);\r\n                batchGranularityByPartitionActivated[i] = granularityByPartitionActivated;\r\n                batchHoldsActivated[i] = holdsActivated;\r\n            } else {\r\n                batchGranularityByPartitionActivated[i] = false;\r\n                batchHoldsActivated[i] = false;\r\n            }\r\n        }\r\n\r\n        return (batchGranularityByPartitionActivated, batchHoldsActivated);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of ERC1400 balances.\r\n     * @return Batch of ERC1400 balances.\r\n     */\r\n    function batchERC1400Balances(address[] calldata tokens, address[] calldata tokenHolders) external view returns (uint256[] memory, uint256[] memory, uint256[] memory, bytes32[] memory, uint256[] memory, uint256[] memory) {\r\n        (,, uint256[] memory batchSpendableBalancesOfByPartition) = batchSpendableBalanceOfByPartition(tokens, tokenHolders);\r\n\r\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions, uint256[] memory batchBalancesOfByPartition) = batchBalanceOfByPartition(tokens, tokenHolders);\r\n\r\n        uint256[] memory batchBalancesOf = batchBalanceOf(tokens, tokenHolders);\r\n\r\n        uint256[] memory batchEthBalances = batchEthBalance(tokenHolders);\r\n\r\n        return (batchEthBalances, batchBalancesOf, totalPartitionsLengths, batchTotalPartitions, batchBalancesOfByPartition, batchSpendableBalancesOfByPartition);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of ERC20 balances.\r\n     * @return Batch of ERC20 balances.\r\n     */\r\n    function batchERC20Balances(address[] calldata tokens, address[] calldata tokenHolders) external view returns (uint256[] memory, uint256[] memory) {\r\n        uint256[] memory batchBalancesOf = batchBalanceOf(tokens, tokenHolders);\r\n\r\n        uint256[] memory batchEthBalances = batchEthBalance(tokenHolders);\r\n\r\n        return (batchEthBalances, batchBalancesOf);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of ETH balances.\r\n     * @return Batch of token ETH balances.\r\n     */\r\n    function batchEthBalance(address[] memory tokenHolders) public view returns (uint256[] memory) {\r\n        uint256[] memory batchEthBalanceResponse = new uint256[](tokenHolders.length);\r\n\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            batchEthBalanceResponse[i] = tokenHolders[i].balance;\r\n        }\r\n\r\n        return batchEthBalanceResponse;\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token balances.\r\n     * @return Batch of token balances.\r\n     */\r\n    function batchBalanceOf(address[] memory tokens, address[] memory tokenHolders) public view returns (uint256[] memory) {\r\n        uint256[] memory batchBalanceOfResponse = new uint256[](tokenHolders.length * tokens.length);\r\n\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                batchBalanceOfResponse[i*tokens.length + j] = IERC20(tokens[j]).balanceOf(tokenHolders[i]);\r\n            }\r\n        }\r\n\r\n        return batchBalanceOfResponse;\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of partition balances.\r\n     * @return Batch of token partition balances.\r\n     */\r\n    function batchBalanceOfByPartition(address[] memory tokens, address[] memory tokenHolders) public view returns (uint256[] memory, bytes32[] memory, uint256[] memory) {\r\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions,) = batchTotalPartitions(tokens);\r\n        \r\n        uint256[] memory batchBalanceOfByPartitionResponse = new uint256[](tokenHolders.length * batchTotalPartitions.length);\r\n\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            uint256 counter = 0;\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                for (uint256 k = 0; k < totalPartitionsLengths[j]; k++) {\r\n                    batchBalanceOfByPartitionResponse[i*batchTotalPartitions.length + counter] = IERC1400(tokens[j]).balanceOfByPartition(batchTotalPartitions[counter], tokenHolders[i]);\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (totalPartitionsLengths, batchTotalPartitions, batchBalanceOfByPartitionResponse);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of spendable partition balances.\r\n     * @return Batch of token spendable partition balances.\r\n     */\r\n    function batchSpendableBalanceOfByPartition(address[] memory tokens, address[] memory tokenHolders) public view returns (uint256[] memory, bytes32[] memory, uint256[] memory) {\r\n        (uint256[] memory totalPartitionsLengths, bytes32[] memory batchTotalPartitions,) = batchTotalPartitions(tokens);\r\n        \r\n        uint256[] memory batchSpendableBalanceOfByPartitionResponse = new uint256[](tokenHolders.length * batchTotalPartitions.length);\r\n\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            uint256 counter = 0;\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                address tokenExtension = interfaceAddr(tokens[j], ERC1400_TOKENS_VALIDATOR);\r\n\r\n                for (uint256 k = 0; k < totalPartitionsLengths[j]; k++) {\r\n                    if (tokenExtension != address(0)) {\r\n                        batchSpendableBalanceOfByPartitionResponse[i*batchTotalPartitions.length + counter] = IERC1400TokensValidatorExtended(tokenExtension).spendableBalanceOfByPartition(tokens[j], batchTotalPartitions[counter], tokenHolders[i]);\r\n                    } else {\r\n                        batchSpendableBalanceOfByPartitionResponse[i*batchTotalPartitions.length + counter] = IERC1400(tokens[j]).balanceOfByPartition(batchTotalPartitions[counter], tokenHolders[i]);\r\n                    }\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (totalPartitionsLengths, batchTotalPartitions, batchSpendableBalanceOfByPartitionResponse);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token partitions.\r\n     * @return Batch of token partitions.\r\n     */\r\n    function batchTotalPartitions(address[] memory tokens) public view returns (uint256[] memory, bytes32[] memory, uint256[] memory) {\r\n        uint256[] memory batchTotalPartitionsLength = new uint256[](tokens.length);\r\n        uint256 totalPartitionsLength=0;\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            bytes32[] memory totalPartitions = IERC1400Extended(tokens[i]).totalPartitions();\r\n            batchTotalPartitionsLength[i] = totalPartitions.length;\r\n            totalPartitionsLength = totalPartitionsLength.add(totalPartitions.length);\r\n        }\r\n\r\n        bytes32[] memory batchTotalPartitionsResponse = new bytes32[](totalPartitionsLength);\r\n        uint256[] memory batchPartitionSupplies = new uint256[](totalPartitionsLength);\r\n\r\n        uint256 counter = 0;\r\n        for (uint256 j = 0; j < tokens.length; j++) {\r\n            bytes32[] memory totalPartitions = IERC1400Extended(tokens[j]).totalPartitions();\r\n\r\n            for (uint256 k = 0; k < totalPartitions.length; k++) {\r\n                batchTotalPartitionsResponse[counter] = totalPartitions[k];\r\n                batchPartitionSupplies[counter] = IERC1400Extended(tokens[j]).totalSupplyByPartition(totalPartitions[k]);\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return (batchTotalPartitionsLength, batchTotalPartitionsResponse, batchPartitionSupplies);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of token default partitions.\r\n     * @return Batch of token default partitions.\r\n     */\r\n    function batchDefaultPartitions(address[] memory tokens) public view returns (uint256[] memory, bytes32[] memory) {\r\n        uint256[] memory batchDefaultPartitionsLength = new uint256[](tokens.length);\r\n        uint256 defaultPartitionsLength=0;\r\n\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            bytes32[] memory defaultPartitions = IERC1400Extended(tokens[i]).getDefaultPartitions();\r\n            batchDefaultPartitionsLength[i] = defaultPartitions.length;\r\n            defaultPartitionsLength = defaultPartitionsLength.add(defaultPartitions.length);\r\n        }\r\n\r\n        bytes32[] memory batchDefaultPartitionsResponse = new bytes32[](defaultPartitionsLength);\r\n\r\n        uint256 counter = 0;\r\n        for (uint256 j = 0; j < tokens.length; j++) {\r\n            bytes32[] memory defaultPartitions = IERC1400Extended(tokens[j]).getDefaultPartitions();\r\n\r\n            for (uint256 k = 0; k < defaultPartitions.length; k++) {\r\n                batchDefaultPartitionsResponse[counter] = defaultPartitions[k];\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return (batchDefaultPartitionsLength, batchDefaultPartitionsResponse);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of validation status.\r\n     * @return Batch of validation status.\r\n     */\r\n    function batchValidations(address[] memory tokens, address[] memory tokenHolders) public view returns (bool[] memory, bool[] memory) {\r\n        bool[] memory batchAllowlisted = batchAllowlisted(tokens, tokenHolders);\r\n        bool[] memory batchBlocklisted = batchBlocklisted(tokens, tokenHolders);\r\n\r\n        return (batchAllowlisted, batchBlocklisted);\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of allowlisted status.\r\n     * @return Batch of allowlisted status.\r\n     */\r\n    function batchAllowlisted(address[] memory tokens, address[] memory tokenHolders) public view returns (bool[] memory) {\r\n        bool[] memory batchAllowlistedResponse = new bool[](tokenHolders.length * tokens.length);\r\n\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                address tokenExtension = interfaceAddr(tokens[j], ERC1400_TOKENS_VALIDATOR);\r\n                if (tokenExtension != address(0)) {\r\n                    batchAllowlistedResponse[i*tokens.length + j] = IERC1400TokensValidatorExtended(tokenExtension).isAllowlisted(tokens[j], tokenHolders[i]);\r\n                } else {\r\n                    batchAllowlistedResponse[i*tokens.length + j] = false;\r\n                }\r\n            }\r\n        }\r\n        return batchAllowlistedResponse;\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch of blocklisted status.\r\n     * @return Batch of blocklisted status.\r\n     */\r\n    function batchBlocklisted(address[] memory tokens, address[] memory tokenHolders) public view returns (bool[] memory) {\r\n        bool[] memory batchBlocklistedResponse = new bool[](tokenHolders.length * tokens.length);\r\n\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                address tokenExtension = interfaceAddr(tokens[j], ERC1400_TOKENS_VALIDATOR);\r\n                if (tokenExtension != address(0)) {\r\n                    batchBlocklistedResponse[i*tokens.length + j] = IERC1400TokensValidatorExtended(tokenExtension).isBlocklisted(tokens[j], tokenHolders[i]);\r\n                } else {\r\n                    batchBlocklistedResponse[i*tokens.length + j] = false;\r\n                }\r\n            }\r\n        }\r\n        return batchBlocklistedResponse;\r\n    }\r\n\r\n}"}}}