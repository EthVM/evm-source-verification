{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"/C/Users/axgoa/Projects/Solidity/defitest/contracts/DefiPool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract DefiPool is Ownable {\n    \n    event Output(uint output);\n    \n    event convertEthToTokenEvent(address sender, uint ethInput, uint tokenOutput, address tokenAddress);\n    \n    using SafeMath for uint;\n    \n    uint16[5] public defaultAllocation;\n    \n    address payable[5] public defaultTokenAddress;\n    \n    address payable public walletTo;\n    \n    bool public returnToSender;\n    \n    address public wETHAddress;\n    \n    address internal UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    IUniswapV2Router02 public uniswapRouter;\n    \n    uint16 public goodWill;\n    \n    constructor() public {\n        \n        walletTo = 0xA2E00FBd1e9315f490aE356F69c1f6624e2ed992;\n        \n        returnToSender = true;\n        \n        goodWill = 100;\n        \n        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n        \n        defaultAllocation[0] = 4000;\n        defaultAllocation[1] = 2500;\n        defaultAllocation[2] = 1000;\n        defaultAllocation[3] = 2500;\n        defaultAllocation[4] = 0;\n        \n        //MAINNET\n        //Contract deployed at: 0x33800fd4d99da92d5320fdd7858dbe6eb7909298\n        //Metadata: dweb:/ipfs/Qmd67f4PPHrNapZmk5KznDpMhYoPsSCtUQqpgZS2FdMhiD\n        wETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n        defaultTokenAddress[0] = 0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b; //DPI\n        defaultTokenAddress[1] = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; //WBTC\n        defaultTokenAddress[2] = 0x514910771AF9Ca656af840dff83E8264EcF986CA; //LINK\n        defaultTokenAddress[3] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; //WETH\n        defaultTokenAddress[4] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n        \n        //GOERLI\n        //Contract deployed at: 0xfa795a8623527c8d88a2044ac7ab20f28229419a\n        //wETHAddress = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6;\n        //defaultTokenAddress[0] = 0x92B30dF9b169FAC44c86983B2aAAa465FDC2CDB8; //FARM\n        //defaultTokenAddress[1] = 0x3ec9D3236C25e71c01057C37cE41423360565812; //DBTC\n        //defaultTokenAddress[2] = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984; //UNI\n        //defaultTokenAddress[3] = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; //WETH\n        //defaultTokenAddress[4] = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n        \n    }\n    \n    function changeAllocation(uint16 _index, uint16 _allocation) public onlyOwner {\n        defaultAllocation[_index] = _allocation;\n    }\n\n    function changeTokenAddress(uint16 _index, address payable _address) public onlyOwner {\n        defaultTokenAddress[_index] = _address;\n    }\n    \n    function changeWalletTo(address payable _address) public onlyOwner {\n        walletTo = _address;\n    }\n    \n    function changeUniswapRouter(address _address) public onlyOwner {\n        UNISWAP_ROUTER_ADDRESS = _address;\n         uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n    }\n    \n    function changeReturnToSender(bool _returnToSender) public onlyOwner {\n        returnToSender = _returnToSender;\n    }\n\n    function changeGoodWill(uint16 _amount) public onlyOwner {\n        goodWill = _amount;\n    }\n\n    function doMagic(uint16[5] memory _allocations, address payable[5] memory _defaultTokenAddress) public payable {\n\n        uint _amountRecieved = msg.value;\n        \n        //do goodWill\n        uint _amountGoodWill = _amountRecieved.mul(goodWill).div(10000);\n        uint _amountToConvert = _amountRecieved.sub(_amountGoodWill);\n        \n        uint tokens;\n        \n        uint[5] memory amount;\n        \n        //check that allocations sum up to 100\n        uint _num1 = 0;\n        for (uint i = 0; i < 5; ++i) {\n            _num1 = _num1 + _allocations[i];\n        }\n        require(_num1 == 10000,\"Error in Allocations\");\n\n        amount[0] = _amountToConvert.mul(_allocations[0]).div(10000);\n        amount[1] = _amountToConvert.mul(_allocations[1]).div(10000);\n        amount[2] = _amountToConvert.mul(_allocations[2]).div(10000);\n        amount[3] = _amountToConvert.mul(_allocations[3]).div(10000);\n        amount[4] = _amountToConvert.mul(_allocations[4]).div(10000);\n        \n        for (uint256 i = 0; i < 5; ++i) {\n            //Convert to the appropiate tokens\n            if (defaultAllocation[i] > 0) {\n                tokens = convertEthToToken(amount[i], _defaultTokenAddress[i], 0);\n                emit convertEthToTokenEvent(msg.sender, amount[i], tokens, _defaultTokenAddress[i]);\n                //emit Output(tokens);\n            }\n        }\n        \n        \n        \n    }\n     \n     \n     \n    //UNISWAP STUFF\n    function convertEthToToken(uint _ethAmount, address _addressToken, uint _amountTokenMin) public payable returns(uint){\n        \n        uint _outputTokenCount;\n        address payable _walletTo;\n        \n        if (returnToSender) {\n            _walletTo = msg.sender;\n        } else {\n            _walletTo = walletTo;\n        }\n        \n        if (_addressToken == wETHAddress) {\n            _walletTo.transfer(_ethAmount);\n            _outputTokenCount = _ethAmount;\n        } else {\n            uint _deadline = block.timestamp + 300; // using 'now' for convenience, for mainnet pass deadline from frontend!\n            uint[] memory _amounts = uniswapRouter.swapExactETHForTokens{value: _ethAmount }(_amountTokenMin, getPathForETHtoToken(_addressToken), _walletTo, _deadline);\n            _outputTokenCount = uint256(_amounts[1]);\n        }\n        \n        return _outputTokenCount;\n    }\n    \n    function getPathForETHtoToken(address _addressToken) private view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = uniswapRouter.WETH();\n        path[1] = _addressToken;\n        \n        return path;\n    }\n     \n    // - to withdraw any ETH balance sitting in the contract\n    function withdrawAllEth(address payable _returnAddress) public onlyOwner {\n        uint256 balance = address(this).balance;\n        _returnAddress.transfer(balance);\n    }\n \n    function withdrawEth(address payable _returnAddress, uint _amount) public onlyOwner {\n        require(_amount <= address(this).balance, \"There are not enough funds stored in the contract\");\n        _returnAddress.transfer(_amount);\n    }\n \n    receive () external payable {\n        doMagic(defaultAllocation,defaultTokenAddress);\n    }\n}"},"@openzeppelin/contracts/GSN/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"@openzeppelin/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"}}}