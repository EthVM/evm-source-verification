{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ArmorMaster.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * \r\n * @dev Completely default OpenZeppelin.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initializeOwnable() internal {\r\n        require(_owner == address(0), \"already initialized\");\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"msg.sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    function receiveOwnership() public {\r\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\r\n        _transferOwnership(_pendingOwner);\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\ninterface IArmorMaster {\r\n    function registerModule(bytes32 _key, address _module) external;\r\n    function getModule(bytes32 _key) external view returns(address);\r\n    function keep() external;\r\n}\r\n\r\ninterface IKeeperRecipient {\r\n    function keep() external;\r\n}\r\n\r\n// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\r\n\r\n/**\r\n * @dev ArmorMaster controls all jobs, address, and ownership in the Armor Core system.\r\n *      It is used when contracts call each other, when contracts restrict functions to\r\n *      each other, when onlyOwner functionality is needed, and when keeper functions must be run.\r\n * @author Armor.fi -- Taek Lee\r\n**/\r\ncontract ArmorMaster is Ownable, IArmorMaster {\r\n    mapping(bytes32 => address) internal _modules;\r\n\r\n    // Keys for different jobs to be run. A job correlates to an address with a keep()\r\n    // function, which is then called to run maintenance functions on the contract.\r\n    bytes32[] internal _jobs;\r\n\r\n    function initialize() external {\r\n        Ownable.initializeOwnable();\r\n        _modules[bytes32(\"MASTER\")] = address(this);\r\n    }\r\n\r\n    /**\r\n     * @dev Register a contract address with corresponding job key.\r\n     * @param _key The key that will point a job to an address.\r\n    **/\r\n    function registerModule(bytes32 _key, address _module) external override onlyOwner {\r\n        _modules[_key] = _module;\r\n    }\r\n\r\n    function getModule(bytes32 _key) external override view returns(address) {\r\n        return _modules[_key];\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new job that correlates to a registered module.\r\n     * @param _key Key of the job used to point to module.\r\n    **/\r\n    function addJob(bytes32 _key) external onlyOwner {\r\n        require(_jobs.length < 3, \"cannot have more than 3 jobs\");\r\n        require(_modules[_key] != address(0), \"module is not listed\");\r\n        for(uint256 i = 0; i< _jobs.length; i++){\r\n            require(_jobs[i] != _key, \"already registered\");\r\n        }\r\n        _jobs.push(_key);\r\n    }\r\n\r\n    function deleteJob(bytes32 _key) external onlyOwner {\r\n        for(uint256 i = 0; i < _jobs.length; i++) {\r\n            if(_jobs[i] == _key) {\r\n                _jobs[i] = _jobs[_jobs.length - 1];\r\n                _jobs.pop();\r\n                return;\r\n            }\r\n        }\r\n        revert(\"job not found\");\r\n    }\r\n\r\n    /**\r\n     * @dev Anyone can call keep to run jobs in this system that need to be periodically done.\r\n     *      To begin with, these jobs including expiring plans and expiring NFTs.\r\n    **/\r\n    function keep() external override {\r\n        for(uint256 i = 0; i < _jobs.length; i++) {\r\n            IKeeperRecipient(_modules[_jobs[i]]).keep();\r\n        }\r\n    }\r\n\r\n    function jobs() external view returns(bytes32[] memory) {\r\n        return _jobs;\r\n    }\r\n\r\n}"}}}