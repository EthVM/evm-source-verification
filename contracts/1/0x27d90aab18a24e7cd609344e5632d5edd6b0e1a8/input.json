{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SponsorPool.sol": {
      "content": "pragma solidity =0.7.0;\r\n\r\ncontract SponsorPool {\r\n    using SafeMathLT for uint256;\r\n\r\n    address public owner;\r\n\r\n    IERC20Token public tokenA;\r\n    IERC20Token public tokenB;\r\n\r\n    uint256 public maxTriggerTotal = 20 ether;\r\n    uint256 public timeout = block.timestamp.add(2 hours);\r\n\r\n    UniswapRouterV2 public constant UNISWAP_ROUTER = UniswapRouterV2(\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D // mainnet\r\n    );\r\n    \r\n    event ReceiveETH(address account, uint256 amount);\r\n    event SwapExactETHForTokens(uint256 balance, uint256 tokens);\r\n    event AddLiquidity(uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    modifier onlyOwner() {\r\n       require(msg.sender == owner, 'wrong sender');\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20Token _tokenA,IERC20Token _tokenB) {\r\n        owner = msg.sender;\r\n        tokenA = _tokenA;\r\n        tokenB = _tokenB;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit ReceiveETH(msg.sender, msg.value);\r\n    }\r\n\r\n    function getTokensBalance()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 _aBalance = tokenA.balanceOf(address(this));\r\n        uint256 _bBalance = tokenB.balanceOf(address(this));\r\n\r\n        return (_aBalance, _bBalance);\r\n    }\r\n\r\n    function forwardLiquidity(/*ğŸ¦„*/) public\r\n    {\r\n        if (address(this).balance > 0) {\r\n            uint256[] memory amounts = UNISWAP_ROUTER.swapExactETHForTokens{value: address(this).balance}(0, getPath(), address(this), timeout);\r\n            emit SwapExactETHForTokens(address(this).balance, amounts[1]);\r\n        }\r\n        \r\n        uint256 _aBalance;\r\n        uint256 _bBalance;\r\n\r\n        (_aBalance, _bBalance) = getTokensBalance();\r\n\r\n        if (_aBalance == 0 || _bBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        tokenA.approve(address(UNISWAP_ROUTER), _aBalance);\r\n        tokenB.approve(address(UNISWAP_ROUTER), _bBalance);\r\n\r\n        (uint256 amountA, uint256 amountB, uint256 liquidity) = UNISWAP_ROUTER\r\n            .addLiquidity(\r\n            address(tokenA),\r\n            address(tokenB),\r\n            _aBalance,\r\n            _bBalance,\r\n            0,\r\n            0,\r\n            address(0x0),\r\n            timeout\r\n        );\r\n        \r\n        emit AddLiquidity(amountA, amountB, liquidity);\r\n    }\r\n    \r\n\r\n    function getPath() internal view returns (address[] memory) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = UNISWAP_ROUTER.WETH();\r\n        path[1] = address(tokenB);\r\n\r\n        return path;\r\n    }\r\n\r\n    function setMaxTriggerTotal(uint256 _v) external onlyOwner {\r\n        maxTriggerTotal = _v;\r\n    }\r\n\r\n    function setOwner(address _v) external onlyOwner {\r\n        owner = _v;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (\r\n        address pair\r\n    );\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n\r\n    function getReserves() external view returns (\r\n        uint112 reserve0,\r\n        uint112 reserve1,\r\n        uint32 blockTimestampLast\r\n    );\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(\r\n        address owner\r\n    ) external view returns (uint256);\r\n\r\n    function token1() external view returns (address);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface UniswapRouterV2 {\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenMax,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n        ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadlin\r\n    ) external payable returns (\r\n        uint[] memory amounts\r\n    );\r\n}\r\n\r\ninterface IERC20Token {\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        returns (bool success);\r\n}\r\n\r\nlibrary SafeMathLT {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"modulo by zero\");\r\n        return a % b;\r\n    }\r\n}"
    }
  }
}