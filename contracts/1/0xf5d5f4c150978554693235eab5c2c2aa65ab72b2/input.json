{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/interfaces/IAtopia.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IBucks.sol\";\n\ninterface IAtopia {\n\tfunction owner() external view returns (address);\n\n\tfunction bucks() external view returns (IBucks);\n\n\tfunction getAge(uint256 tokenId) external view returns (uint256);\n\n\tfunction ownerOf(uint256 tokenId) external view returns (address);\n\n\tfunction update(uint256 tokenId) external;\n\n\tfunction exitCenter(\n\t\tuint256 tokenId,\n\t\tuint256 grown,\n\t\tuint256 enjoyFee\n\t) external returns (uint256);\n\n\tfunction addReward(uint256 tokenId, uint256 reward) external;\n\n\tfunction claimGrowth(\n\t\tuint256 tokenId,\n\t\tuint256 grown,\n\t\tuint256 enjoyFee\n\t) external returns (uint256);\n\n\tfunction claimBucks(address user, uint256 amount) external;\n\n\tfunction buyAndUseItem(\n\t\tuint256 tokenId,\n\t\tuint256 itemInfo\n\t) external;\n}\n"
    },
    "contracts/interfaces/IBucks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBucks {\n\tfunction mint(address account, uint256 amount) external;\n\n\tfunction burn(uint256 amount) external;\n\n\tfunction burnFrom(address account, uint256 amount) external;\n\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\tfunction balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICenter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICenter {\n\tfunction setId(uint256 _id) external;\n\n\tfunction addFeeAmount(uint256 feeAmount) external;\n\n\tfunction enter(uint256 tokenId) external returns (uint256);\n\n\tfunction exit(uint256 tokenId) external returns (uint256);\n\n\tfunction work(\n\t\tuint256 tokenId,\n\t\tuint16 task,\n\t\tuint256 working\n\t) external returns (uint256 info, uint256 reward);\n\n\tfunction enjoyFee() external view returns (uint16);\n\n\tfunction grown(uint256 tokenId) external view returns (uint256);\n\n\tfunction rewards(uint256 tokenId) external view returns (uint256);\n\n\tfunction metadata() external view returns (string memory);\n\n\tfunction grow(uint256 tokenId) external returns (uint256 _growing);\n}\n"
    },
    "contracts/utils/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\n/// including the MetaData, and partially, Enumerable extensions.\ncontract ERC721 {\n\t/*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n\tevent Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\n\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\t/*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n\taddress implementation_;\n\taddress public admin;\n\n\tstring public name;\n\tstring public symbol;\n\n\t/*///////////////////////////////////////////////////////////////\n                             ERC-721 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n\tmapping(address => uint256) public balanceOf;\n\n\tmapping(uint256 => address) public ownerOf;\n\n\tmapping(uint256 => address) public getApproved;\n\n\tmapping(address => mapping(address => bool)) public isApprovedForAll;\n\n\t/*///////////////////////////////////////////////////////////////\n                             VIEW FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == admin);\n\t\t_;\n\t}\n\n\tfunction owner() external view returns (address) {\n\t\treturn admin;\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                              ERC-20-LIKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction transfer(address to, uint256 tokenId) external {\n\t\trequire(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\n\n\t\t_transfer(msg.sender, to, tokenId);\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                              ERC-721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\n\t\tsupported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\n\t}\n\n\tfunction approve(address spender, uint256 tokenId) external {\n\t\taddress owner_ = ownerOf[tokenId];\n\n\t\trequire(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \"NOT_APPROVED\");\n\n\t\tgetApproved[tokenId] = spender;\n\n\t\temit Approval(owner_, spender, tokenId);\n\t}\n\n\tfunction setApprovalForAll(address operator, bool approved) external {\n\t\tisApprovedForAll[msg.sender][operator] = approved;\n\n\t\temit ApprovalForAll(msg.sender, operator, approved);\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public {\n\t\trequire(\n\t\t\tmsg.sender == from || msg.sender == getApproved[tokenId] || isApprovedForAll[from][msg.sender],\n\t\t\t\"NOT_APPROVED\"\n\t\t);\n\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public {\n\t\ttransferFrom(from, to, tokenId);\n\n\t\tif (to.code.length != 0) {\n\t\t\t// selector = `onERC721Received(address,address,uint,bytes)`\n\t\t\t(, bytes memory returned) = to.staticcall(\n\t\t\t\tabi.encodeWithSelector(0x150b7a02, msg.sender, from, tokenId, data)\n\t\t\t);\n\n\t\t\tbytes4 selector = abi.decode(returned, (bytes4));\n\n\t\t\trequire(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\n\t\t}\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                          INTERNAL UTILS\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal {\n\t\trequire(ownerOf[tokenId] == from);\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\tbalanceOf[from]--;\n\t\tbalanceOf[to]++;\n\n\t\tdelete getApproved[tokenId];\n\n\t\townerOf[tokenId] = to;\n\t\temit Transfer(msg.sender, to, tokenId);\n\t}\n\n\tfunction _mint(address to, uint256 tokenId) internal {\n\t\trequire(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\n\n\t\t// This is safe because the sum of all user\n\t\t// balances can't exceed type(uint256).max!\n\t\tunchecked {\n\t\t\tbalanceOf[to]++;\n\t\t}\n\n\t\townerOf[tokenId] = to;\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\tfunction _burn(uint256 tokenId) internal {\n\t\taddress owner_ = ownerOf[tokenId];\n\n\t\trequire(owner_ != address(0), \"NOT_MINTED\");\n\t\t_beforeTokenTransfer(owner_, address(0), tokenId);\n\n\t\tbalanceOf[owner_]--;\n\n\t\tdelete ownerOf[tokenId];\n\n\t\temit Transfer(owner_, address(0), tokenId);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal virtual {}\n}\n"
    },
    "contracts/utils/Space.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"../interfaces/IAtopia.sol\";\nimport \"../interfaces/ICenter.sol\";\n\ncontract AtopiaSpace is ERC721 {\n\tbool public initialized;\n\tusing Counters for Counters.Counter;\n\tCounters.Counter private _tokenIds;\n\n\tstruct Task {\n\t\tuint256 id;\n\t\tuint256 info;\n\t\tuint256 rewards;\n\t}\n\n\tIAtopia public atopia;\n\tICenter[] public centers;\n\tmapping(uint256 => uint256) public lives;\n\n\tTask[] public tasks;\n\n\tevent TaskUpdated(Task task);\n\tevent LifeUpdated(uint256 tokenId, uint256 life);\n\n\tfunction initialize(address _atopia) public {\n\t\trequire(!initialized);\n\t\tinitialized = true;\n\t\tname = \"Atopia Space\";\n\t\tsymbol = \"ATPSPACE\";\n\t\tatopia = IAtopia(_atopia);\n\t}\n\n\tmodifier onlyAtopia() {\n\t\trequire(msg.sender == atopia.owner());\n\t\t_;\n\t}\n\n\tfunction onlyTokenOwner(uint256 tokenId) public view {\n\t\trequire(atopia.ownerOf(tokenId) == msg.sender);\n\t}\n\n\tfunction totalTasks() external view returns (uint256) {\n\t\treturn tasks.length;\n\t}\n\n\tfunction totalCenters() external view returns (uint256) {\n\t\treturn centers.length;\n\t}\n\n\tfunction getLife(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 job,\n\t\t\tuint256 task,\n\t\t\tuint256 data\n\t\t)\n\t{\n\t\tuint256 life = lives[tokenId];\n\t\tdata = life & ((1 << 129) - 1);\n\t\tlife = life >> 128;\n\t\ttask = life & 0xFFFF;\n\t\tjob = life >> 64;\n\t}\n\n\tfunction addTask(\n\t\tuint128 duration,\n\t\tuint128 minAge,\n\t\tuint256 rewards\n\t) external onlyAtopia {\n\t\tTask memory newTask = Task(tasks.length + 1, (uint256(duration) << 128) | minAge, rewards);\n\t\ttasks.push(newTask);\n\t\temit TaskUpdated(newTask);\n\t}\n\n\tfunction updateTask(\n\t\tuint256 id,\n\t\tuint128 duration,\n\t\tuint128 minAge,\n\t\tuint256 rewards\n\t) external onlyAtopia {\n\t\tuint256 index = id - 1;\n\t\ttasks[index].info = (uint256(duration) << 128) | minAge;\n\t\ttasks[index].rewards = rewards;\n\t\temit TaskUpdated(tasks[index]);\n\t}\n\n\tfunction addCenter(address center) external onlyAtopia {\n\t\tICenter newCenter = ICenter(center);\n\t\tcenters.push(newCenter);\n\t\tuint256 id = centers.length;\n\t\t_mint(msg.sender, id);\n\t\tnewCenter.setId(id);\n\t}\n\n\tfunction addFeeAmount(uint256 centerId, uint256 amount) external {\n\t\trequire(msg.sender == address(atopia));\n\t\tcenters[centerId - 1].addFeeAmount(amount);\n\t}\n\n\tfunction enterInternal(uint256 tokenId, uint256 centerId) internal {\n\t\t(uint256 job, uint256 task, ) = getLife(tokenId);\n\t\tif (job != 0) {\n\t\t\t// already in a center for enjoying or working\n\t\t\tif (task != 0) {\n\t\t\t\t// if working quit work\n\t\t\t\tworkInternal(tokenId, centerId, 0);\n\t\t\t} else {\n\t\t\t\trequire(job != centerId);\n\t\t\t\texit(tokenId);\n\t\t\t}\n\t\t}\n\t\t//require(lives[tokenId] == 0);\n\t\t//atopia.update(tokenId);\n\t\tlives[tokenId] = centers[centerId - 1].enter(tokenId);\n\t\temit LifeUpdated(tokenId, lives[tokenId]);\n\t}\n\n\tfunction enter(uint256 tokenId, uint256 centerId) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tenterInternal(tokenId, centerId);\n\t}\n\n\tstruct EnterInfo {\n\t\tuint256 centerId;\n\t\tuint256[] tokenIds;\n\t}\n\n\tfunction batchEnter(EnterInfo[] memory enterInfos) external {\n\t\tfor (uint256 i = 0; i < enterInfos.length; i++) {\n\t\t\tEnterInfo memory enterInfo = enterInfos[i];\n\t\t\tfor (uint256 j = 0; j < enterInfo.tokenIds.length; j++) {\n\t\t\t\tuint256 tokenId = enterInfo.tokenIds[j];\n\t\t\t\tonlyTokenOwner(tokenId);\n\t\t\t\tenterInternal(tokenId, enterInfo.centerId);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction grow(uint256 centerId, uint256 tokenId) external {\n\t\trequire(msg.sender == address(atopia));\n\t\tcenters[centerId - 1].grow(tokenId);\n\t}\n\n\tfunction getGrowthAndFee(\n\t\tuint256 centerId,\n\t\tuint256 tokenId,\n\t\tuint256 growingReward\n\t) external view returns (uint256 grown, uint256 fee) {\n\t\tICenter center = centers[centerId - 1];\n\t\tfee = (growingReward * center.enjoyFee()) / 10000;\n\t\tgrown = center.grown(tokenId);\n\t}\n\n\tfunction exit(uint256 tokenId) public {\n\t\tonlyTokenOwner(tokenId);\n\t\t(uint256 job, uint256 task, ) = getLife(tokenId);\n\t\trequire(job > 0 && task == 0);\n\t\tuint256 centerIndex = job - 1;\n\t\tuint256 feeAmount = atopia.claimGrowth(\n\t\t\ttokenId,\n\t\t\tcenters[centerIndex].exit(tokenId),\n\t\t\tcenters[centerIndex].enjoyFee()\n\t\t);\n\t\tlives[tokenId] = 0;\n\t\tif (feeAmount > 0) centers[centerIndex].addFeeAmount(feeAmount);\n\t\temit LifeUpdated(tokenId, 0);\n\t}\n\n\tfunction batchExit(uint256[] memory tokenIds, uint256 centerId) external {\n\t\tuint256 centerIndex = centerId - 1;\n\t\tICenter center = centers[centerIndex];\n\t\tuint256 feeAmount;\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\t(uint256 job, uint256 task, ) = getLife(tokenId);\n\t\t\trequire(job == centerId && task == 0 && atopia.ownerOf(tokenId) == msg.sender);\n\t\t\tfeeAmount += atopia.claimGrowth(tokenId, center.exit(tokenId), center.enjoyFee());\n\t\t\tlives[tokenId] = 0;\n\t\t\temit LifeUpdated(tokenId, 0);\n\t\t}\n\t\tif (feeAmount > 0) center.addFeeAmount(feeAmount);\n\t}\n\n\tfunction claimGrowth(uint256[] memory tokenIds, uint256 centerId) public {\n\t\tuint256 centerIndex = centerId - 1;\n\t\tICenter center = centers[centerIndex];\n\t\tuint256 feeAmount;\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\t(uint256 job, uint256 task, ) = getLife(tokenId);\n\t\t\trequire(job == centerId && task == 0);\n\t\t\tfeeAmount += atopia.claimGrowth(tokenId, center.grow(tokenId), center.enjoyFee());\n\t\t}\n\t\tif (feeAmount > 0) center.addFeeAmount(feeAmount);\n\t}\n\n\tfunction workInternal(\n\t\tuint256 tokenId,\n\t\tuint256 centerId,\n\t\tuint16 task\n\t) internal {\n\t\tuint256 life = lives[tokenId];\n\t\tuint256 job = life >> 128;\n\t\tuint256 currentTask = uint16(job);\n\t\tuint256 reward;\n\t\tjob = job >> 64;\n\t\tif (task > 0) {\n\t\t\t//require(job == 0 || job == centerId);\n\t\t\tif (job != 0) {\n\t\t\t\t// if enjoying or already working\n\t\t\t\tif (currentTask == 0) {\n\t\t\t\t\t// if enjoying\n\t\t\t\t\texit(tokenId);\n\t\t\t\t\tlife = 0;\n\t\t\t\t} else if (job != centerId) {\n\t\t\t\t\t// if working\n\t\t\t\t\t(, reward) = centers[job - 1].work(tokenId, 0, life);\n\t\t\t\t\tlife = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t(life, reward) = centers[centerId - 1].work(tokenId, task, life);\n\t\t} else {\n\t\t\t// quit work\n\t\t\trequire(job == centerId && currentTask > 0);\n\t\t\t(, reward) = centers[centerId - 1].work(tokenId, task, life);\n\t\t\tlife = 0;\n\t\t}\n\t\tlives[tokenId] = life;\n\t\tif (reward > 0) atopia.addReward(tokenId, reward);\n\t\temit LifeUpdated(tokenId, life);\n\t}\n\n\tfunction work(\n\t\tuint256 tokenId,\n\t\tuint256 centerId,\n\t\tuint16 task\n\t) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tworkInternal(tokenId, centerId, task);\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view returns (string memory) {\n\t\treturn centers[tokenId - 1].metadata();\n\t}\n\n\tfunction claimBucks(uint256 centerId, uint256 amount) external {\n\t\trequire(msg.sender == address(centers[centerId - 1]));\n\t\tatopia.claimBucks(ownerOf[centerId], amount);\n\t}\n}\n"
    }
  }
}