{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"@openzeppelin/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"},"contracts/TwoBitClickRenderer.sol":{"content":"// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/two_bit.sol\";\nimport \"./libraries/base64.sol\";\n\npragma solidity 0.8.10;\npragma abicoder v2;\n\ncontract TwoBitClickRenderer is Ownable {\n  using Strings for uint16;\n  using Strings for uint8;\n  using Strings for uint256;\n\n  string[10] public _traits = [\n    \"Bit One RGB\",\n    \"Bit Two RGB\",\n    \"Bit One Level\",\n    \"Bit Two Level\",\n    \"Bit One X Coordinate\",\n    \"Bit Two X Coordinate\",\n    \"Degrees\",\n    \"Background Color\",\n    \"Total Level\",\n    \"Rebirth Count\"\n  ];\n\n  // Levels as keys, RGBs as lists\n  mapping(uint8 => mapping(uint8 => string)) public bitRGBs;\n\n  function uploadRGBs(\n    uint8 level,\n    uint8[] calldata rgbIds,\n    string[] calldata rgbs\n  ) external onlyOwner {\n    require(rgbIds.length == rgbs.length, \"Mismatched inputs\");\n    for (uint i = 0; i < rgbIds.length; i++) {\n      bitRGBs[level][rgbIds[i]] = rgbs[i];\n    }\n  }\n\n  function tokenURI(uint256 tokenId, TwoBit memory tbh) external view returns (string memory) {\n    string memory image = Base64.encode(bytes(generateSVGImage(tbh)));\n\n    return string(\n      abi.encodePacked(\n        \"data:application/json;base64,\",\n        Base64.encode(\n          bytes(\n            abi.encodePacked(\n              '{\"name\":\"',\n              'Two Bit',\n              ' #',\n              tokenId.toString(),\n              '\", ',\n              '\"attributes\": ',\n              compileAttributes(tbh),\n              ', \"image\": \"',\n              \"data:image/svg+xml;base64,\",\n              image,\n              '\"}'\n            )\n          )\n        )\n      )\n    );\n  }\n\n  function generateSVGImage(TwoBit memory params) internal view returns (string memory) {\n    return string(\n      abi.encodePacked(\n        generateSVGHeader(),\n        generateBackground(params.backgroundRandomLevel, params.background),\n        generateRGB(params.degrees, params.bitOneRGB, params.bitOneLevel, 160, params.bitOneXCoordinate),\n        generateRGB(params.degrees, params.bitTwoRGB, params.bitTwoLevel, 360, params.bitTwoXCoordinate),\n        \"</svg>\"\n      )\n    );\n  }\n\n  function generateSVGHeader() private pure returns (string memory) {\n    return\n    string(\n      abi.encodePacked(\n        '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" x=\"0px\" y=\"0px\"',\n        ' viewBox=\"0 0 720 720\" style=\"enable-background:new 0 0 720 720;\" xml:space=\"preserve\">'\n      )\n    );\n  }\n\n  function generateBackground(uint8 level, uint8 rgbInt) internal view returns (string memory) {\n    bytes memory svgString = abi.encodePacked(\n      '<rect x=\"0\" y=\"0\" fill=\"rgb(',\n      bitRGBs[level][rgbInt],\n      ')\" width=\"720\" height=\"720\"></rect>'\n    );\n\n    return string(svgString);\n  }\n\n  function generateRGB(uint16 degrees, uint8 rgbInt, uint8 level, uint16 yCoord, uint16 xCoord) internal view returns (string memory) {\n    bytes memory svgString = abi.encodePacked(\n      '<rect x=\"', xCoord.toString(), '\" y=\"', yCoord.toString(),'\" width=\"200\" height=\"200\" fill=\"rgb(',\n      bitRGBs[level][rgbInt],\n      ')\" transform=\"rotate(',\n      degrees.toString(),\n      ', 360, 360',\n      ')\">'\n      '</rect>'\n    );\n    return string(svgString);\n  }\n\n  function compileAttributes(TwoBit memory tbh) public view returns (string memory) {\n    string memory traits;\n    traits = string(abi.encodePacked(\n      attributeForTypeAndValue(_traits[0], bitRGBs[tbh.bitOneLevel][tbh.bitOneRGB]),',',\n      attributeForTypeAndValue(_traits[1], bitRGBs[tbh.bitTwoLevel][tbh.bitTwoRGB]),',',\n      attributeForTypeAndValue(_traits[2], (tbh.bitOneLevel + 1).toString()),',',\n      attributeForTypeAndValue(_traits[3], (tbh.bitTwoLevel+ 1).toString()),',',\n      attributeForTypeAndValue(_traits[4], tbh.bitOneXCoordinate.toString()),',',\n      attributeForTypeAndValue(_traits[5], tbh.bitTwoXCoordinate.toString()),',',\n      attributeForTypeAndValue(_traits[6], tbh.degrees.toString()),',',\n      attributeForTypeAndValue(_traits[7], bitRGBs[tbh.backgroundRandomLevel][tbh.background]),',',\n      attributeForTypeAndValue(_traits[8], (tbh.bitOneLevel + tbh.bitTwoLevel + 2).toString()),',',\n      attributeForNumberAndValue(_traits[2], tbh.bitOneLevel + 1),',',\n      attributeForNumberAndValue(_traits[3], tbh.bitTwoLevel + 1),',',\n      attributeForNumberAndValue(_traits[9], tbh.rebirth)\n    ));\n    return string(abi.encodePacked(\n      '[',\n      traits,\n      ']'\n    ));\n  }\n\n  function attributeForTypeAndValue(string memory traitType, string memory value) internal pure returns (string memory) {\n    return string(abi.encodePacked(\n      '{\"trait_type\":\"',\n      traitType,\n      '\",\"value\":\"',\n      value,\n      '\"}'\n    ));\n  }\n\n  function attributeForNumberAndValue(string memory traitType, uint8 value) internal pure returns (string memory) {\n    return string(abi.encodePacked(\n      '{\"display_type\":\"number\",\"trait_type\":\"',\n      traitType,\n      '\",\"value\": ',\n      value.toString(),\n      '}'\n    ));\n  }\n}"},"contracts/interfaces/two_bit.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\npragma abicoder v2;\n\nstruct TwoBit {\n  uint8 backgroundRandomLevel;\n  uint8 background;\n  uint8 bitOneRGB;\n  uint8 bitTwoRGB;\n  uint8 bitOneLevel;\n  uint8 bitTwoLevel;\n  uint16 bitOneXCoordinate;\n  uint16 bitTwoXCoordinate;\n  uint16 degrees;\n  uint8 rebirth;\n}"},"contracts/libraries/base64.sol":{"content":"// SPDX-License-Identifier: MIT\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\n\npragma solidity ^0.8.0;\nlibrary Base64 {\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /// @notice Encodes some bytes to the base64 representation\n    function encode(bytes memory data) internal pure returns (string memory) {\n        uint256 len = data.length;\n        if (len == 0) return \"\";\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((len + 2) / 3);\n\n        // Add some extra buffer at the end\n        bytes memory result = new bytes(encodedLen + 32);\n\n        bytes memory table = TABLE;\n\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n\n            for {\n                let i := 0\n            } lt(i, len) {\n\n            } {\n                i := add(i, 3)\n                let input := and(mload(add(data, i)), 0xffffff)\n\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n                out := shl(8, out)\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n                out := shl(224, out)\n\n                mstore(resultPtr, out)\n\n                resultPtr := add(resultPtr, 4)\n            }\n\n            switch mod(len, 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n\n            mstore(result, encodedLen)\n        }\n\n        return string(result);\n    }\n}"}}}