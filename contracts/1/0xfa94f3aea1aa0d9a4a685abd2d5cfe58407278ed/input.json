{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NftRelay.sol":{"content":"pragma solidity ^0.5.16;\r\n\r\n/**\r\n  * @title ArtDeco Finance\r\n  *\r\n  * @notice ArtDeco NFT Relay: ERC-721 NFTs stored in contract for promote  \r\n  * \r\n  */\r\n  \r\n/***\r\n* \r\n* MIT License\r\n* ===========\r\n* \r\n*  Copyright (c) 2020 ArtDeco\r\n* \r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\ncontract Governance {\r\n\r\n    address public _governance;\r\n\r\n    constructor() public {\r\n        _governance = tx.origin;\r\n    }\r\n\r\n    event GovernanceTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyGovernance {\r\n        require(msg.sender == _governance, \"not governance\");\r\n        _;\r\n    }\r\n\r\n    function setGovernance(address governance)  public  onlyGovernance\r\n    {\r\n        require(governance != address(0), \"new governance the zero address\");\r\n        emit GovernanceTransferred(_governance, governance);\r\n        _governance = governance;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ninterface NFTFactory{\r\n   function claimbyrelay() external;\r\n}\r\n\r\ninterface AnftToken {\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\ninterface AToken {\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) ;    \r\n  function transfer(address dst, uint rawAmount) external returns (bool);\r\n  function balanceOf(address account) external view returns (uint);\r\n  \r\n} \r\n\r\ninterface ApwrToken {\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function balanceOf(address account) external view returns (uint256);\r\n} \r\n\r\ninterface RandomSeed {\r\n  function random_get9999( address sender, uint256 random ) external view returns (uint);\r\n}\r\n\r\ncontract NftRelay is Governance{\r\n    \r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    address public _anft =  address(0x99a7e1188CE9a0b7514d084878DFb8A405D8529F);\r\n    address public _apwr = address(0xb60F072494c7f1b5a8ba46bc735C71A83D940D1A);  \r\n    address public _nftfactory = address(0x694D7054bc8993Ac15F9E42be364dccCBD576724);\r\n    address private _randseed = address(0x75A7c0f3c7E59D0Aa323cc8832EaF2729Fe2127C);\r\n    \r\n    // A token\r\n    address public _token =  address(0x77dF79539083DCd4a8898dbA296d899aFef20067); \r\n    address public _teamWallet = address(0x3b2b4f84cFE480289df651bE153c147fa417Fb8A);\r\n    address public _nextRelayPool = address(0);\r\n    address public _burnPool = 0x6666666666666666666666666666666666666666;\r\n    \r\n    uint256 private releaseDate;\r\n    uint256 public _claimrate = 0;  //1.0 * 1e18;\r\n    \r\n    uint256 public _claimdays = 0 days;\r\n    uint  private nonce = 0;\r\n    \r\n    uint256[] private _allNft;\r\n    \r\n    // Mapping from NFT-id to position in the allNft array\r\n    mapping(uint256 => uint256) private _allNftIndex;\r\n\r\n    // Mapping from airdrop receiver to boolean \r\n    mapping (address => bool) public hasClaimed;\r\n    \r\n    // Throws when msg.sender has already claimed the airdrop \r\n    modifier hasNotClaimed() {\r\n        require(hasClaimed[msg.sender] == false);\r\n        _;\r\n    }\r\n    \r\n    // Throws when the 30 day airdrop period has passed \r\n    modifier canClaim() {\r\n        require(releaseDate + _claimdays >= now);\r\n        _;\r\n    }\r\n    \r\n    event NFTReceived(address operator, address from, uint256 tokenId, bytes data);\r\n    event TransferNFT(address to, uint count);\r\n    \r\n    constructor() public {\r\n        // Set releaseDate\r\n        releaseDate = now;\r\n    }\r\n    \r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns (bytes4) \r\n    {\r\n        _addNft( tokenId );\r\n        emit NFTReceived(operator, from, tokenId, data);\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n    \r\n    function setNftFactory( address newfactory ) external onlyGovernance {\r\n        _nftfactory = newfactory;\r\n    }\r\n\r\n    function setnextRelayPool( address newrelaypool ) external onlyGovernance {\r\n        _nextRelayPool = newrelaypool;\r\n    }\r\n    \r\n    function setclaimDays( uint256 claimdays ) external onlyGovernance {\r\n        _claimdays = claimdays;\r\n    }\r\n \r\n    function setuseToken( address token ) external onlyGovernance {\r\n        _token = token;\r\n    }\r\n\r\n    function setclaimRate( uint256 claimrate ) external onlyGovernance {\r\n        _claimrate = claimrate;\r\n    }\r\n    \r\n    function getclaimRate() public view returns (uint256) {\r\n        return _claimrate;\r\n    }\r\n    \r\n    function IsClaimed( address account ) public view returns (bool) {\r\n        return hasClaimed[account];\r\n    }\r\n    \r\n    function mintNft( ) external \r\n    {\r\n            NFTFactory _nftfactoryx =  NFTFactory(_nftfactory);\r\n            _nftfactoryx.claimbyrelay( );\r\n    }\r\n\r\n    function claimNFTbytokens(  uint256 amount ) external hasNotClaimed()  canClaim()\r\n    {\r\n        \r\n        require( amount >= _claimrate, \"ARTTamount not enough\");\r\n        \r\n        if( amount > 0 )\r\n        {\r\n            AToken _tokenx =  AToken(_token);\r\n            _tokenx.transferFrom(msg.sender, address(this), amount );\r\n        }\r\n        \r\n        RandomSeed _rc = RandomSeed(_randseed);\r\n        uint randnum = _rc.random_get9999(msg.sender,nonce);  \r\n        nonce = nonce + 1;\r\n        \r\n        uint256 total = _allNft.length;\r\n        uint256 md = SafeMath.mod( randnum, total );\r\n        uint id = nftByIndex(md);\r\n        \r\n        _removeNft( id );\r\n        AnftToken _anftx =  AnftToken(_anft);\r\n        _anftx.safeTransferFrom( address(this), msg.sender, id );\r\n        \r\n        ApwrToken _apwrx = ApwrToken(_apwr);\r\n        _apwrx.transfer( msg.sender, 1* 1e16 );\r\n\r\n        // Set boolean for hasClaimed\r\n        hasClaimed[msg.sender] = true;\r\n    }\r\n \r\n\r\n    function claim() external hasNotClaimed()  canClaim()\r\n    {\r\n            require( _claimrate == 0, \"No Free, to pay Atoken is needed\");\r\n            \r\n            RandomSeed _rc = RandomSeed(_randseed);\r\n            uint randnum = _rc.random_get9999(msg.sender,nonce);  \r\n            nonce = nonce + 1;\r\n            \r\n            uint256 total = _allNft.length;\r\n            uint256 md = SafeMath.mod( randnum, total );\r\n            uint id = nftByIndex(md);\r\n            \r\n            _removeNft( id );\r\n            AnftToken _anftx =  AnftToken(_anft);\r\n            _anftx.safeTransferFrom( address(this), msg.sender, id );\r\n    \r\n            ApwrToken _apwrx = ApwrToken(_apwr);\r\n            _apwrx.transfer( msg.sender, 1* 1e16 );\r\n            \r\n            // Set boolean for hasClaimed\r\n            hasClaimed[msg.sender] = true;\r\n    }\r\n     \r\n    \r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param nftId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n     \r\n    function _removeNft(uint256 nftId) private {\r\n\r\n        uint256 lastNftIndex = _allNft.length.sub(1);\r\n        uint256 NftIndex = _allNftIndex[nftId];\r\n\r\n        uint256 lastNftId = _allNft[lastNftIndex];\r\n\r\n        _allNft[NftIndex] = lastNftId; \r\n        _allNftIndex[lastNftId] = NftIndex; \r\n\r\n        _allNft.length--;\r\n        _allNftIndex[nftId] = 0;\r\n    }\r\n        \r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addNft(uint256 tokenId) private {\r\n        _allNftIndex[tokenId] = _allNft.length;\r\n        _allNft.push(tokenId);\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets the total amount of NFT stored by the contract.\r\n     * @return uint256 representing the total amount of NFT\r\n     */\r\n    function totalNFTs() public view returns (uint256) {\r\n        return _allNft.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total amount of ArtPower stored by the contract.\r\n     * @return uint256 representing the total amount of APWR\r\n     */\r\n    function totalAPWR() public view returns (uint256) {\r\n        ApwrToken _apwrx = ApwrToken(_apwr);\r\n        return _apwrx.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token ID at a given index of all the NFT in this contract\r\n     * Reverts if the index is greater or equal to the total number of NFT.\r\n     * @param index uint256 representing the index to be accessed of the NFT list\r\n     * @return uint256 token ID at the given index of the NFT list\r\n     */\r\n    function nftByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalNFTs(), \"ERC721: global index out of bounds\");\r\n        return _allNft[index];\r\n    }\r\n \r\n    function MigrateNFT() external onlyGovernance \r\n    {\r\n         uint count =  _allNft.length;\r\n         uint id = 0;\r\n         if( count >= 1 )\r\n         {\r\n            AnftToken _anftx =  AnftToken(_anft);\r\n            id = _allNft[0];\r\n            _removeNft( id );\r\n            _anftx.safeTransferFrom( address(this), _nextRelayPool, id );\r\n\r\n            ApwrToken _apwrx = ApwrToken(_apwr);\r\n            _apwrx.transfer( _nextRelayPool, 1* 1e16 );\r\n         }\r\n         \r\n         emit TransferNFT( _nextRelayPool, count );\r\n    }\r\n    \r\n    // Transfer Atoken to _teamWallet\r\n    function seizeAtoken() external  \r\n    {\r\n        AToken _tokenx =  AToken(_token);\r\n        uint _currentBalance =  _tokenx.balanceOf(address(this));\r\n        _tokenx.transfer(_teamWallet, _currentBalance );\r\n    }\r\n    \r\n    \r\n}"}}}