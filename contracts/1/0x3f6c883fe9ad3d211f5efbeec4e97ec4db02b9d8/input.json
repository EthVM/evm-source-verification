{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    //function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    //function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"},"contracts/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"contracts/UniswapIntermediateAgentETH.sol":{"content":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\nimport \"./Ownable.sol\";\r\nimport \"./IUniswapV2Router02.sol\";\r\n//import \"./IBSCswapRouter02.sol\";\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IReimbursement {\r\n    function getLicenseeFee(address licenseeVault, address projectContract) external view returns(uint256); // return fee percentage with 2 decimals\r\n    function getVaultOwner(address vault) external view returns(address);\r\n    // returns address of fee receiver or address(0) if licensee can't receive the fee (fee should be returns to user)\r\n    function requestReimbursement(address user, uint256 feeAmount, address licenseeVault) external returns(address);\r\n}\r\n\r\ninterface IBEP20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract UniswapIntermediateAgent is Ownable{\r\n    using TransferHelper for address;\r\n    \r\n    IReimbursement public reimbursementContract;\r\n    address public companyVault;    // the vault address of our company registered in reimbursement contract\r\n    mapping(address => uint256) public routerInterface; // type on router interface: 0 = uniswap, 1 = BSCswap\r\n    address public feeReceiver; // address which receive the fee (by default is validator)\r\n\r\n    constructor(address _reimbursementContract) {      \r\n        reimbursementContract = IReimbursement(_reimbursementContract);\r\n    }\r\n\r\n    // get amount of collected fees that can be claimed\r\n    function getColletedFees() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // claim fees by feeReceiver\r\n    function claimFee() external returns (uint256 feeAmount)\r\n    {\r\n        require(msg.sender == feeReceiver);\r\n        feeAmount = address(this).balance;\r\n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\r\n    }\r\n\r\n    function setFeeReceiver(address _addr) external onlyOwner {\r\n        feeReceiver = _addr;\r\n    }\r\n\r\n    // This contract should not received any tokens, but due issue in ERC20 standard we can't disallow someone to do it.\r\n    // If someone accidentally transfer tokens to this contract, the owner will be able to rescue it and refund sender.\r\n    function rescueTokens(address someToken) external onlyOwner {\r\n        uint256 available = IBEP20(someToken).balanceOf(address(this));\r\n        TransferHelper.safeTransfer(someToken, msg.sender, available);\r\n    }\r\n\r\n    function setReimbursement(address _reimbursement)external onlyOwner{\r\n        require(_reimbursement != address(0), \"Invalid address\");\r\n        reimbursementContract = IReimbursement(_reimbursement);\r\n    }\r\n\r\n    // set address of company vault (ID) in reimbursement contract\r\n    function setCompanyVault(address _vault) external onlyOwner{\r\n        companyVault = _vault;\r\n    }\r\n\r\n    // set type of interface of selected router.\r\n    // _type: 0 = uniswap, 1 = BSCswap\r\n    function setRouterInterface(address _router, uint256 _type) external onlyOwner {\r\n        routerInterface[_router] = _type;\r\n    }\r\n\r\n    event Swap(\r\n        address indexed user,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountA,\r\n        uint256 amountB\r\n    );\r\n        \r\n    function getFee(\r\n        address fromToken,  // address(0) means native coin (ETH, BNB)\r\n        uint256 amountIn, \r\n        address licensee,\r\n        address uniV2Router   // Uniswap-compatible router address\r\n    ) \r\n    external\r\n    view\r\n    returns(uint256) \r\n    {\r\n        uint256 feeLicensee;\r\n        uint256 feeBswap;\r\n        address[] memory tempPath = new address[](2);\r\n        uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licensee, address(this));\r\n        uint256 feeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\r\n        if (routerInterface[uniV2Router] == 1) {\r\n            // add function for different interface here\r\n        } else {\r\n            tempPath[1] = IUniswapV2Router02(uniV2Router).WETH();\r\n        }\r\n        if(fromToken == address(0) || fromToken == tempPath[1]) {\r\n            feeLicensee = amountIn * licenseeFeeRate / 10000;\r\n            feeBswap = amountIn * feeRate / 10000;\r\n        }\r\n        else {\r\n                tempPath[0] = fromToken;\r\n                uint256[] memory totalFeeAmt = IUniswapV2Router02(uniV2Router).getAmountsOut(amountIn, tempPath); \r\n                feeBswap = totalFeeAmt[1] * feeRate / 10000;\r\n                \r\n                if(licenseeFeeRate>0){\r\n                    feeLicensee = totalFeeAmt[1] * licenseeFeeRate / 10000;\r\n                }\r\n        }\r\n        return feeBswap + feeLicensee;\r\n    }\r\n\r\n    function swap(\r\n        address payable licensee,\r\n        uint256 amountIn,                                                       // amount of token to swap\r\n        uint256 amountOut,                                                      // minimum amount of token to receive\r\n        address[] memory path,                                                  // address(0) means native coin (ETH, BNB)\r\n        uint256 deadline,\r\n        uint256 swapType,                                                        // allow to choose the correct swap function: \r\n                                                                                // 0 - swap Exact Tokens For Token; \r\n                                                                                // 1 - swap Tokens For Exact Token SupportingFeeOnTransferTokens;\r\n                                                                                // 2 - swap Tokens For Exact Token; \r\n        address uniV2Router   // Uniswap-compatible router address\r\n    ) \r\n        external\r\n        payable\r\n        returns (uint256[] memory amounts) \r\n    {\r\n        if (routerInterface[uniV2Router] == 1) {\r\n            // add function for different interface here\r\n        } else {\r\n            return swapUni(licensee, amountIn, amountOut, path, deadline, swapType, IUniswapV2Router02(uniV2Router));\r\n        }\r\n    }\r\n\r\n    function swapUni(\r\n        address payable licensee,\r\n        uint256 amountIn,                                                       // amount of token to swap\r\n        uint256 amountOut,                                                      // minimum amount of token to receive\r\n        address[] memory path,                                                  // address(0) means native coin (ETH, BNB)\r\n        uint256 deadline,\r\n        uint256 swapType,                                                        // allow to choose the correct swap function: \r\n                                                                                // 0 - swap Exact Tokens For Token; \r\n                                                                                // 1 - swap Tokens For Exact Token SupportingFeeOnTransferTokens;\r\n                                                                                // 2 - swap Tokens For Exact Token; \r\n        IUniswapV2Router02 uniV2Router   // Uniswap-compatible router address\r\n    ) \r\n        internal\r\n        returns (uint256[] memory amounts) \r\n    {\r\n        bool toETH;\r\n        bool fromETH;\r\n        uint256 totalGas = gasleft();\r\n        uint256 totalFee;\r\n        totalFee = msg.value;                                                   // assume that all coins that user send is a fee\r\n    \r\n        if (path[0] == address(0)) {                                             // swap from native coin (ETH, BNB)\r\n            totalFee = totalFee - amountIn;                                   // separate fee from swapping value\r\n            path[0] = uniV2Router.WETH();\r\n            fromETH = true;\r\n        } else {                                                                 // transfer token from user and approve to Router\r\n            path[0].safeTransferFrom(msg.sender, address(this), amountIn);\r\n            path[0].safeApprove(address(uniV2Router), amountIn);        \r\n        }\r\n    \r\n        if (path[path.length-1] == address(0)) {                                 // swap to native coin (ETH, BNB)\r\n            path[path.length-1] = uniV2Router.WETH();\r\n            toETH = true;\r\n        }\r\n        \r\n        require (!fromETH || !toETH, \"Swapping from ETH to ETH is forbidden\");\r\n\r\n        if (swapType == 0) {                    \r\n            if (fromETH) {\r\n                amounts = uniV2Router.swapExactETHForTokens{value: amountIn}(\r\n                    0,\r\n                    path,\r\n                    msg.sender,\r\n                    deadline\r\n                );\r\n            } else if (toETH) {\r\n                amounts = uniV2Router.swapExactTokensForETH(\r\n                    amountIn,\r\n                    amountOut,\r\n                    path,\r\n                    payable(msg.sender),\r\n                    deadline\r\n                );            \r\n            } else {\r\n                amounts = uniV2Router.swapExactTokensForTokens(\r\n                    amountIn,\r\n                    amountOut,\r\n                    path,\r\n                    msg.sender,\r\n                    deadline\r\n                );\r\n            }\r\n        } else if (swapType == 1) {\r\n            if (fromETH) {\r\n                uniV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountIn}(\r\n                    0,\r\n                    path,\r\n                    msg.sender,\r\n                    deadline\r\n                );\r\n            } else if (toETH) {\r\n                uniV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                    amountIn,\r\n                    amountOut,\r\n                    path,\r\n                    payable(msg.sender),\r\n                    deadline\r\n                );            \r\n            } else {\r\n                uniV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                    amountIn,\r\n                    amountOut,\r\n                    path,\r\n                    msg.sender,\r\n                    deadline\r\n                );\r\n            }\r\n        } else if (swapType == 2) {\r\n            if (fromETH) {\r\n                amounts = uniV2Router.swapETHForExactTokens{value: amountIn}(\r\n                    amountOut,\r\n                    path,\r\n                    msg.sender,\r\n                    deadline\r\n                );\r\n                \r\n                if(amountIn - amounts[0] > 0){\r\n                    payable(msg.sender).transfer(amountIn - amounts[0]);\r\n                }\r\n\r\n            } else if (toETH) {\r\n                amounts = uniV2Router.swapTokensForExactETH(\r\n                    amountOut,\r\n                    amountIn,\r\n                    path,\r\n                    payable(msg.sender),\r\n                    deadline\r\n                );\r\n                \r\n                if(amountIn - amounts[0] > 0){\r\n                    path[0].safeTransfer(msg.sender, (amountIn - amounts[0]));\r\n                }\r\n            } else {\r\n                amounts = uniV2Router.swapTokensForExactTokens(\r\n                    amountOut,\r\n                    amountIn,\r\n                    path,\r\n                    msg.sender,\r\n                    deadline\r\n                );\r\n                \r\n                if(amountIn - amounts[0] > 0){\r\n                    path[0].safeTransfer(msg.sender, (amountIn - amounts[0]));\r\n                }\r\n            }\r\n        }else { \r\n            revert(\"Wrong type\");\r\n        }\r\n    \r\n        processFee(totalGas, totalFee, licensee, msg.sender);\r\n\r\n        emit Swap(msg.sender, path[0], path[1], amountIn, amounts[1]);      // emit swap event\r\n    }\r\n\r\n    // Call function processFee() at the end of main function for correct gas usage calculation.\r\n    // txGas - is gasleft() on start of calling contract. Put `uint256 txGas = gasleft();` as a first command in function\r\n    // feeAmount - fee amount that user paid\r\n    // licenseeVault - address that licensee received on registration and should provide when users comes from their site\r\n    // user - address of user who has to get reimbursement (usually msg.sender)\r\n\r\n    function processFee(uint256 txGas, uint256 feeAmount, address licenseeVault, address user) internal {\r\n        if (address(reimbursementContract) == address(0)) {\r\n            payable(user).transfer(feeAmount); // return fee to sender if no reimbursement contract\r\n            return;\r\n        }\r\n\r\n        uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licenseeVault, address(this));\r\n        uint256 companyFeeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\r\n        uint256 licenseeFeeAmount = (feeAmount * licenseeFeeRate)/(licenseeFeeRate + companyFeeRate);\r\n        if (licenseeFeeAmount != 0) {\r\n            address licenseeFeeTo = reimbursementContract.requestReimbursement(user, licenseeFeeAmount, licenseeVault);\r\n            if (licenseeFeeTo == address(0)) {\r\n                payable(user).transfer(licenseeFeeAmount);    // refund to user\r\n            } else {\r\n                payable(licenseeFeeTo).transfer(licenseeFeeAmount);  // transfer to fee receiver\r\n            }\r\n        }\r\n        feeAmount -= licenseeFeeAmount; // company's part of fee\r\n\r\n        txGas -= gasleft(); // get gas amount that was spent on Licensee fee\r\n        txGas = txGas * tx.gasprice;\r\n        // request reimbursement for user\r\n        reimbursementContract.requestReimbursement(user, feeAmount+txGas, companyVault);\r\n    }\r\n    \r\n    receive() external payable {}\r\n}\r\n"}}}