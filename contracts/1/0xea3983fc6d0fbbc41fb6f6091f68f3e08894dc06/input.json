{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/UDO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.0;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address private _nextOwner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'Only the owner of the contract can do that');\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address nextOwner) public onlyOwner {\r\n        _nextOwner = nextOwner;\r\n    }\r\n    \r\n    function takeOwnership() public {\r\n        require(msg.sender == _nextOwner, 'Must be given ownership to do that');\r\n        emit OwnershipTransferred(owner, _nextOwner);\r\n        owner = _nextOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract UnidoDistribution is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    // 0 - SEED\r\n    // 1 - PRIVATE\r\n    // 2 - TEAM\r\n    // 3 - ADVISOR\r\n    // 4 - ECOSYSTEM\r\n    // 5 - LIQUIDITY\r\n    // 6 - RESERVE\r\n    enum POOL{SEED, PRIVATE, TEAM, ADVISOR, ECOSYSTEM, LIQUIDITY, RESERVE}\r\n    \r\n    mapping (POOL => uint) public pools;\r\n    \r\n    uint256 public totalSupply;\r\n    string public constant name = \"Unido\";\r\n    uint256 public constant decimals = 18;\r\n    string public constant symbol = \"UDO\";\r\n    address[] public participants;\r\n    \r\n    bool private isActive;\r\n    uint256 private scanLength = 150;\r\n    uint256 private continuePoint;\r\n    uint256[] private deletions;\r\n    \r\n    mapping (address => uint256) private balances;\r\n    mapping (address => mapping(address => uint256)) private allowances;\r\n    mapping (address => uint256) public lockoutPeriods;\r\n    mapping (address => uint256) public lockoutBalances;\r\n    mapping (address => uint256) public lockoutReleaseRates;\r\n    \r\n    event Active(bool isActive);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Burn(address indexed tokenOwner, uint tokens);\r\n    \r\n    constructor () {\r\n        pools[POOL.SEED] = 15000000 * 10**decimals;\r\n        pools[POOL.PRIVATE] = 16000000 * 10**decimals;\r\n        pools[POOL.TEAM] = 18400000 * 10**decimals;\r\n        pools[POOL.ADVISOR] = 10350000 * 10**decimals;\r\n        pools[POOL.ECOSYSTEM] = 14375000 * 10**decimals;\r\n        pools[POOL.LIQUIDITY] = 8625000 * 10**decimals;\r\n        pools[POOL.RESERVE] = 32250000 * 10**decimals;\r\n        \r\n        totalSupply = pools[POOL.SEED] + pools[POOL.PRIVATE] + pools[POOL.TEAM] + pools[POOL.ADVISOR] + pools[POOL.ECOSYSTEM] + pools[POOL.LIQUIDITY] + pools[POOL.RESERVE];\r\n\r\n        // Give POLS private sale directly\r\n        uint pols = 2000000 * 10**decimals;\r\n        pools[POOL.PRIVATE] = pools[POOL.PRIVATE].sub(pols);\r\n        balances[address(0xeFF02cB28A05EebF76cB6aF993984731df8479b1)] = pols;\r\n        \r\n        // Give LIQUIDITY pool their half directly\r\n        uint liquid = pools[POOL.LIQUIDITY].div(2);\r\n        pools[POOL.LIQUIDITY] = pools[POOL.LIQUIDITY].sub(liquid);\r\n        balances[address(0xd6221a4f8880e9Aa355079F039a6012555556974)] = liquid;\r\n    }\r\n    \r\n    function _isTradeable() internal view returns (bool) {\r\n        return isActive;\r\n    }\r\n    \r\n    function isTradeable() public view returns (bool) {\r\n        return _isTradeable();\r\n    }\r\n    \r\n    function setTradeable() external onlyOwner {\r\n        require (!isActive, \"Can only set tradeable when its not already tradeable\");\r\n        isActive = true;\r\n        Active(true);\r\n    }\r\n    \r\n    function setScanLength(uint256 len) external onlyOwner {\r\n        require (len > 20, \"Values 20 or less are impractical\");\r\n        require (len <= 200, \"Values greater than 200 may cause the updateRelease function to fail\");\r\n        scanLength = len;\r\n    }\r\n    \r\n    function balanceOf(address tokenOwner) public view returns (uint) {\r\n        return balances[tokenOwner];\r\n    }\r\n    \r\n    function allowance(address tokenOwner, address spender) public view returns (uint) {\r\n        return allowances[tokenOwner][spender];\r\n    }\r\n    \r\n    function spendable(address tokenOwner) public view returns (uint) {\r\n        return balances[tokenOwner].sub(lockoutBalances[tokenOwner]);\r\n    }\r\n    \r\n    function transfer(address to, uint tokens) public returns (bool) {\r\n        require (_isTradeable(), \"Contract is not tradeable yet\");\r\n        require (balances[msg.sender].sub(lockoutBalances[msg.sender]) >= tokens, \"Must have enough spendable tokens\");\r\n        require (tokens > 0, \"Must transfer non-zero amount\");\r\n        require (to != address(0), \"Cannot send to the 0 address\");\r\n        \r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    \r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n    \r\n    function approve(address spender, uint tokens) public returns (bool) {\r\n        _approve(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint tokens) internal {\r\n        require (owner != address(0), \"Cannot approve from the 0 address\");\r\n        require (spender != address(0), \"Cannot approve the 0 address\");\r\n        \r\n        allowances[owner][spender] = tokens;\r\n        Approval(owner, spender, tokens);\r\n    }\r\n    \r\n    function burn(uint tokens) public {\r\n        require (balances[msg.sender].sub(lockoutBalances[msg.sender]) >= tokens, \"Must have enough spendable tokens\");\r\n        require (tokens > 0, \"Must burn non-zero amount\");\r\n        \r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        totalSupply = totalSupply.sub(tokens);\r\n        Burn(msg.sender, tokens);\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint tokens) public returns (bool) {\r\n        require (_isTradeable(), \"Contract is not trading yet\");\r\n        require (balances[from].sub(lockoutBalances[from]) >= tokens, \"Must have enough spendable tokens\");\r\n        require (allowances[from][msg.sender] >= tokens, \"Must be approved to spend that much\");\r\n        require (tokens > 0, \"Must transfer non-zero amount\");\r\n        require (from != address(0), \"Cannot send from the 0 address\");\r\n        require (to != address(0), \"Cannot send to the 0 address\");\r\n        \r\n        balances[from] = balances[from].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        allowances[from][msg.sender] = allowances[from][msg.sender].sub(tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n    \r\n    function addParticipants(POOL pool, address[] calldata _participants, uint256[] calldata _stakes) external onlyOwner {\r\n        require (pool >= POOL.SEED && pool <= POOL.RESERVE, \"Must select a valid pool\");\r\n        require (_participants.length == _stakes.length, \"Must have equal array sizes\");\r\n        \r\n        uint lockoutPeriod;\r\n        uint lockoutReleaseRate;\r\n        \r\n        if (pool == POOL.SEED) {\r\n            lockoutPeriod = 1;\r\n            lockoutReleaseRate = 5;\r\n        } else if (pool == POOL.PRIVATE) {\r\n            lockoutReleaseRate = 4;\r\n        } else if (pool == POOL.TEAM) {\r\n            lockoutPeriod = 12;\r\n            lockoutReleaseRate = 12;\r\n        } else if (pool == POOL.ADVISOR) {\r\n            lockoutPeriod = 6;\r\n            lockoutReleaseRate = 6;\r\n        } else if (pool == POOL.ECOSYSTEM) {\r\n            lockoutPeriod = 3;\r\n            lockoutReleaseRate = 9;\r\n        } else if (pool == POOL.LIQUIDITY) {\r\n            lockoutReleaseRate = 1;\r\n            lockoutPeriod = 1;\r\n        } else if (pool == POOL.RESERVE) {\r\n            lockoutReleaseRate = 18;\r\n        }\r\n        \r\n        uint256 sum;\r\n        uint256 len = _participants.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            address p = _participants[i];\r\n            require(lockoutBalances[p] == 0, \"Participants can't be involved in multiple lock ups simultaneously\");\r\n        \r\n            participants.push(p);\r\n            lockoutBalances[p] = _stakes[i];\r\n            balances[p] = balances[p].add(_stakes[i]);\r\n            lockoutPeriods[p] = lockoutPeriod;\r\n            lockoutReleaseRates[p] = lockoutReleaseRate;\r\n            sum = sum.add(_stakes[i]);\r\n        }\r\n        \r\n        require(sum <= pools[pool], \"Insufficient amount left in pool for this\");\r\n        pools[pool] = pools[pool].sub(sum);\r\n    }\r\n    \r\n    function finalizeParticipants(POOL pool) external onlyOwner {\r\n        uint leftover = pools[pool];\r\n        pools[pool] = 0;\r\n        totalSupply = totalSupply.sub(leftover);\r\n    }\r\n    \r\n    /**\r\n     * For each account with an active lockout, if their lockout has expired \r\n     * then release their lockout at the lockout release rate\r\n     * If the lockout release rate is 0, assume its all released at the date\r\n     * Only do max 100 at a time, call repeatedly which it returns true\r\n     */\r\n    function updateRelease() external onlyOwner returns (bool) {\r\n        uint scan = scanLength;\r\n        uint len = participants.length;\r\n        uint continueAddScan = continuePoint.add(scan);\r\n        for (uint i = continuePoint; i < len && i < continueAddScan; i++) {\r\n            address p = participants[i];\r\n            if (lockoutPeriods[p] > 0) {\r\n                lockoutPeriods[p]--;\r\n            } else if (lockoutReleaseRates[p] > 0) {\r\n                uint rate = lockoutReleaseRates[p];\r\n                \r\n                uint release;\r\n                if (rate == 18) {\r\n                    // First release of reserve is 12.5%\r\n                    release = lockoutBalances[p].div(8);\r\n                } else {\r\n                    release = lockoutBalances[p].div(lockoutReleaseRates[p]);\r\n                }\r\n                \r\n                lockoutBalances[p] = lockoutBalances[p].sub(release);\r\n                lockoutReleaseRates[p]--;\r\n            } else {\r\n                deletions.push(i);\r\n            }\r\n        }\r\n        continuePoint = continuePoint.add(scan);\r\n        if (continuePoint >= len) {\r\n            continuePoint = 0;\r\n            while (deletions.length > 0) {\r\n                uint index = deletions[deletions.length-1];\r\n                deletions.pop();\r\n\r\n                participants[index] = participants[participants.length - 1];\r\n                participants.pop();\r\n            }\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n}"
    }
  }
}