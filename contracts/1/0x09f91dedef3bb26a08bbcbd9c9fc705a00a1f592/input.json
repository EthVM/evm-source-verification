{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SmartMatrix8Eth.sol": {
      "content": "pragma solidity >=0.4.23 <0.6.0;\r\n\r\ncontract SmartMatrix8Eth {\r\n    struct User {\r\n        uint256 id;\r\n        address referrer;\r\n        mapping(uint8 => bool) activeX5Levels;\r\n        mapping(uint8 => uint256) reinvestCounts;\r\n        mapping(uint8 => bool) blockX5Levels;\r\n        mapping(uint8 => uint256) partnersCounts;\r\n    }\r\n\r\n     struct X5 {\r\n        mapping(uint8 => address) referrals;\r\n        uint8   lastRefereeId;\r\n        address placer;\r\n        address freePlacer;\r\n    }\r\n\r\n    struct luckyGroup {\r\n        mapping(address => uint256) users;\r\n        mapping(uint256 => address) ids;\r\n        uint256 lastId;\r\n    }\r\n\r\n    mapping(address => X5) x5Matrix;\r\n\r\n    uint8 public constant LAST_LEVEL = 12;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint256 => address) public idToAddress;\r\n    mapping(uint8 => luckyGroup) public luckyGroups;\r\n\r\n    uint256 public lastUserId = 2;\r\n    address public owner;\r\n\r\n    mapping(uint8 => uint256) public levelPrice;\r\n\r\n    event Registration(\r\n        address indexed user,\r\n        address indexed referrer,\r\n        uint256 indexed userId,\r\n        address placer\r\n    );\r\n\r\n    event Reinvest(uint256 receiver, uint8 rtype, uint256 bonus, uint8 level);\r\n\r\n    event Upgrade(address indexed user, uint8 level);\r\n\r\n    constructor(address ownerAddress) public {\r\n        levelPrice[1] = 0.1 ether;\r\n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\r\n            levelPrice[i] = levelPrice[i - 1] * 2;\r\n        }\r\n\r\n        owner = ownerAddress;\r\n\r\n        User memory user = User({\r\n            id: 1,\r\n            referrer: address(0)\r\n        });\r\n\r\n        users[ownerAddress] = user;\r\n        idToAddress[1] = ownerAddress;\r\n\r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[ownerAddress].activeX5Levels[i] = true;\r\n        }\r\n\r\n        x5Matrix[ownerAddress].placer = ownerAddress;\r\n        x5Matrix[ownerAddress].freePlacer = ownerAddress;\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.data.length == 0) {\r\n            return registration(msg.sender, owner);\r\n        }\r\n\r\n        registration(msg.sender, bytesToAddress(msg.data));\r\n    }\r\n\r\n    function sendETHDividends(\r\n        address userAddress,\r\n        address referrerAddress,\r\n        uint8 level\r\n    ) private {\r\n        int256 amount = int256(levelPrice[level]);\r\n        uint256 bonus = uint256(amount / 10);\r\n\r\n        address(uint160(referrerAddress)).transfer(bonus);\r\n\r\n        amount -= int256(bonus);\r\n\r\n        address receiver = userAddress;\r\n        uint256 receivers = users[referrerAddress].id;\r\n        int256 index;\r\n\r\n        while (true) {\r\n            receiver = x5Matrix[receiver].placer;\r\n\r\n            if (receiver == owner) break;\r\n\r\n            if (index - int256(users[receiver].partnersCounts[level]) > 2) {\r\n                continue;\r\n            }\r\n\r\n            if (users[receiver].blockX5Levels[level]) {\r\n                continue;\r\n            }\r\n\r\n            if (level > 1 && !users[receiver].activeX5Levels[level]) {\r\n                continue;\r\n            }\r\n\r\n            amount -= int256(bonus);\r\n\r\n            address(uint160(receiver)).transfer(bonus);\r\n\r\n            receivers = receivers * 0xffffffff + users[receiver].id;\r\n\r\n            users[receiver].reinvestCounts[level] += 1;\r\n\r\n            if (level > 1 && level < LAST_LEVEL) {\r\n                if (\r\n                    !users[receiver].activeX5Levels[level + 1] &&\r\n                    users[receiver].reinvestCounts[level] >= 30\r\n                ) {\r\n                    users[receiver].blockX5Levels[level] = true;\r\n                }\r\n            }\r\n\r\n            index++;\r\n\r\n            if (index >= 7) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit Reinvest(receivers, 1, bonus, level);\r\n        uint256 lucklastId = luckyGroups[level].lastId;\r\n        if (lucklastId > 0) {\r\n            address randaddress = luckyGroups[level].ids[block.number %\r\n                lucklastId];\r\n\r\n            address(uint160(randaddress)).transfer(bonus);\r\n\r\n            emit Reinvest(users[randaddress].id, 2, bonus, level);\r\n\r\n            amount -= int256(bonus);\r\n        }\r\n\r\n        if (amount > 0) {\r\n            emit Reinvest(1, 3, uint256(amount), level);\r\n            address(uint160(owner)).transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    function registrationExt(address referrerAddress, address userAddress)\r\n        external\r\n        payable\r\n    {\r\n        registration(userAddress, referrerAddress);\r\n        sendETHDividends(userAddress, referrerAddress, 1);\r\n    }\r\n\r\n    function addToLuckyGroup(address referrerAddress, uint8 level) private {\r\n        uint256 lastId = luckyGroups[level].lastId;\r\n        luckyGroups[level].users[referrerAddress] = lastId;\r\n        luckyGroups[level].ids[lastId] = referrerAddress;\r\n        luckyGroups[level].lastId = lastId + 1;\r\n    }\r\n\r\n    function buyNewLevel(address userAddress, uint8 level) external payable {\r\n        require(\r\n            isUserExists(msg.sender),\r\n            \"user is not exists. Register first.\"\r\n        );\r\n\r\n        require(\r\n            isUserExists(userAddress),\r\n            \"user is not exists. Register first.\"\r\n        );\r\n\r\n        require(msg.value == levelPrice[level], \"invalid price\");\r\n        require(level > 1 && level <= LAST_LEVEL, \"invalid level\");\r\n\r\n        require(\r\n            !users[userAddress].activeX5Levels[level],\r\n            \"level already activated\"\r\n        );\r\n\r\n        require(\r\n            users[userAddress].activeX5Levels[level - 1],\r\n            \"level should be correct\"\r\n        );\r\n\r\n        if (users[userAddress].blockX5Levels[level - 1]) {\r\n            users[userAddress].blockX5Levels[level - 1] = false;\r\n        }\r\n\r\n        users[userAddress].activeX5Levels[level] = true;\r\n        address referrerAddress = users[userAddress].referrer;\r\n        users[referrerAddress].partnersCounts[level]++;\r\n\r\n        if (users[referrerAddress].partnersCounts[level] >= 30) {\r\n            addToLuckyGroup(referrerAddress, level);\r\n        }\r\n\r\n        emit Upgrade(userAddress, level);\r\n\r\n        sendETHDividends(userAddress, referrerAddress, level);\r\n    }\r\n\r\n    function registration(address userAddress, address referrerAddress)\r\n        private\r\n    {\r\n        require(msg.value == 0.1 ether, \"registration cost 0.1\");\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        require(size == 0, \"cannot be a contract\");\r\n\r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: referrerAddress\r\n        });\r\n\r\n        users[userAddress] = user;\r\n        idToAddress[lastUserId] = userAddress;\r\n        x5Matrix[userAddress].freePlacer = userAddress;\r\n\r\n        users[userAddress].activeX5Levels[1] = true;\r\n        users[referrerAddress].partnersCounts[1]++;\r\n\r\n        if (users[referrerAddress].partnersCounts[1] >= 30) {\r\n            addToLuckyGroup(referrerAddress, 1);\r\n        }\r\n\r\n        address placer = updateX5Referrer(\r\n            userAddress,\r\n            referrerAddress,\r\n            x5Matrix[referrerAddress].freePlacer\r\n        );\r\n\r\n        emit Registration(userAddress, referrerAddress, lastUserId, placer);\r\n\r\n        lastUserId++;\r\n    }\r\n\r\n    function getPosition(address placer, address userAddress)\r\n        private\r\n        view\r\n        returns (uint8)\r\n    {\r\n        for (uint8 i = 0; i < 4; i++) {\r\n            if (x5Matrix[placer].referrals[i] == userAddress) return i;\r\n        }\r\n        return 4;\r\n    }\r\n\r\n    function findfreePlacer(address referrer, address placer)\r\n        private\r\n        view\r\n        returns (address)\r\n    {\r\n        uint256 level = 0;\r\n\r\n        while (true) {\r\n            if (placer == referrer) {\r\n                placer = x5Matrix[referrer].referrals[0];\r\n                break;\r\n            }\r\n\r\n            address SuperPlacer = x5Matrix[placer].placer;\r\n            uint8 pos = getPosition(SuperPlacer, placer);\r\n\r\n            if (pos < 4) {\r\n                placer = x5Matrix[SuperPlacer].referrals[pos + 1];\r\n                break;\r\n            }\r\n\r\n            placer = SuperPlacer;\r\n            level++;\r\n        }\r\n\r\n        while (level > 0) {\r\n            placer = x5Matrix[placer].referrals[0];\r\n            level--;\r\n        }\r\n\r\n        return placer;\r\n    }\r\n\r\n    function updateX5Referrer(\r\n        address userAddress,\r\n        address referrer,\r\n        address freePlacer\r\n    ) private returns (address) {\r\n        while (true) {\r\n            uint8 lastRefereeId = x5Matrix[freePlacer].lastRefereeId;\r\n            if (lastRefereeId  < 5) {\r\n                x5Matrix[freePlacer].referrals[lastRefereeId] = userAddress;\r\n                x5Matrix[referrer].freePlacer = freePlacer;\r\n                x5Matrix[userAddress].placer = freePlacer;\r\n                lastRefereeId ++;\r\n                x5Matrix[freePlacer].lastRefereeId =  lastRefereeId;\r\n                return freePlacer;\r\n            }\r\n\r\n\r\n            freePlacer = findfreePlacer(referrer, freePlacer);\r\n        }\r\n    }\r\n\r\n    function usersActiveX5Levels(address userAddress, uint8 level)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return users[userAddress].activeX5Levels[level];\r\n    }\r\n\r\n    function usersX5Matrix(address userAddress, uint8 id)\r\n        public\r\n        view\r\n        returns (address, address)\r\n    {\r\n        return (x5Matrix[userAddress].placer, x5Matrix[userAddress].referrals[id]);\r\n    }\r\n\r\n    function usersLuckyGroupsLevels(address userAddress, uint8 level)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return luckyGroups[level].users[userAddress];\r\n    }\r\n\r\n    function usersInfo(address userAddress, uint8 level)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            address,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            users[userAddress].id,\r\n            users[userAddress].referrer,\r\n            x5Matrix[userAddress].placer,\r\n            users[userAddress].partnersCounts[level]\r\n        );\r\n    }\r\n\r\n    function isUserExists(address user) public view returns (bool) {\r\n        return (users[user].id != 0);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys)\r\n        private\r\n        pure\r\n        returns (address addr)\r\n    {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}"
    }
  }
}