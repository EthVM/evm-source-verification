{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/tests/demo2/DefiGetTogether.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity >=0.6.11;\r\nimport \"./interfaces/ICDaiErc20.sol\";\r\nimport \"./interfaces/IUniswapV2Router.sol\";\r\nimport \"./interfaces/ICurve.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeERC20.sol\";\r\n\r\ncontract DefiGetTogether {\r\n\r\n    using SafeMath for uint;\r\n    enum DefiStatus {\r\n        UNUSED,CROWDFUNDING,WAITDART,DARTSUCCESS               \r\n     }           \r\n                  \r\n    uint256 constant MaxUint256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n    uint [] private supplySection;  \r\n    uint public totalInvestor; \r\n\r\n    uint public crowdfundNumber; \r\n    uint public crowdfundPeriod; \r\n\r\n    uint public dartNumber;  \r\n    uint public dartPeriod;   \r\n    uint public intervalNumber = 11520; \r\n    uint public minCrowdFundingAmount = 1000;\r\n    uint public mortgageFactor = 69;\r\n    uint public maxMortgageFactor = 75;\r\n    uint public platformCoefficient = 15;\r\n\r\n    address private uniSwapContract;    \r\n    address private curvePoolContract;\r\n    address private usdtContract;     \r\n    address private daiContract;      \r\n    address private cDaiContract;     \r\n    address private compContract;   \r\n    address private compComptrollerContract;  \r\n    address public platformAddr;      \r\n    address public owner;         \r\n    address[] public investors;\r\n    mapping(address => bool) public admins;    \r\n    mapping(address => uint) public investments; \r\n    DefiStatus public status = DefiStatus.UNUSED; \r\n\r\n    bool private isUniswapWay = false;\r\n    int128 private curveUsdtIndex = 2;\r\n    int128 private curveDaiIndex = 0;\r\n\r\n    constructor(address _uniSwapContract,address _curvePoolContract,address _usdtContract,address _daiContract,address _cDaiContract,address _compContract,address _compComptrollerContract,address _platformAddr) public{\r\n        uniSwapContract = _uniSwapContract;\r\n        curvePoolContract = _curvePoolContract;\r\n        usdtContract = _usdtContract;\r\n        daiContract = _daiContract;\r\n        cDaiContract = _cDaiContract;\r\n        compContract = _compContract;\r\n        compComptrollerContract = _compComptrollerContract;\r\n        platformAddr = _platformAddr;\r\n        uint power = IERC20(usdtContract).decimals();\r\n        minCrowdFundingAmount = uint256(minCrowdFundingAmount).mul(10 ** power);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function _isContainsInvestors(address _investor) private view returns(bool) {\r\n        return investments[_investor] != 0;\r\n    }\r\n\r\n     function _isAdmin(address _address) private view returns(bool) {\r\n        return admins[_address];\r\n    }\r\n    \r\n    function _addInverstorInfo(address _investor, uint _amount) private {\r\n        if (_isContainsInvestors(_investor)) {\r\n            investments[_investor] = investments[_investor].add(_amount);\r\n        } else {\r\n            investors.push(_investor);\r\n            investments[_investor] = _amount;\r\n        }\r\n    }\r\n\r\n    function _deleteAllInvestorInfo() private {\r\n        for (uint i = 0; i < investors.length; i ++) {\r\n            delete investments[investors[i]];\r\n        }\r\n        delete investors;\r\n    }\r\n\r\n    function _getTotalInvestment() private view returns(uint) {\r\n        uint amount = 0;\r\n        for (uint i = 0; i < investors.length; i ++) {\r\n            amount = amount.add(investments[investors[i]]);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function _curveSwap(address _address,int128 _from, int128 _to, uint256 _amount) private {\r\n        SafeERC20.safeApprove(IERC20(_address),curvePoolContract,_amount);\r\n        ICurve curve = ICurve(curvePoolContract);\r\n        uint256 min_dy = curve.get_dy(_from, _to, _amount);\r\n        curve.exchange(_from, _to, _amount, min_dy);\r\n    }\r\n\r\n    function _uniswap(address _from, address _to, uint256 _amount) private {\r\n        IUniswapV2Router router = IUniswapV2Router(uniSwapContract);\r\n        SafeERC20.safeApprove(IERC20(_from),address(router),_amount);\r\n        address[] memory path = new address[](3);\r\n        path[0] = _from;\r\n        path[1] = router.WETH();\r\n        path[2] = _to;\r\n        uint[] memory amounts = router.getAmountsOut(_amount, path);\r\n        uint amountOutMin = amounts[amounts.length - 1];\r\n        router.swapExactTokensForTokens(_amount, amountOutMin, path, address(this), MaxUint256);\r\n    }\r\n\r\n    function _swap(address _from, address _to) private {\r\n        uint amountIn = IERC20(_from).balanceOf(address(this));\r\n        if(amountIn > 0){\r\n        \r\n            if (((_from == usdtContract && _to == daiContract) || (_from == daiContract && _to == usdtContract)) &&  isUniswapWay == false) {\r\n        \r\n                  if (_from == usdtContract) {\r\n                       _curveSwap(_from,curveUsdtIndex, curveDaiIndex, amountIn);\r\n                  } else {\r\n                      _curveSwap(_from,curveDaiIndex, curveUsdtIndex, amountIn);\r\n                     }\r\n            } else{\r\n                _uniswap(_from, _to, amountIn); \r\n              }\r\n        }\r\n    }\r\n   \r\n    function _batchTransferPrincipal() private {\r\n        uint amountUsdt = IERC20(usdtContract).balanceOf(address(this));\r\n        uint totalInvestment = _getTotalInvestment();\r\n        require(amountUsdt >= totalInvestment, \"usdt balance no enouth\");\r\n        for (uint i = 0; i < investors.length; i ++) {\r\n            address investor = investors[i];\r\n            uint investment = investments[investor];\r\n            SafeERC20.safeTransfer(IERC20(usdtContract), investor, investment);\r\n        }\r\n    }\r\n\r\n    function _batchTransferPrincipalAndIncome() private {\r\n        uint totalUsdtAmount = IERC20(usdtContract).balanceOf(address(this)); \r\n        require(totalUsdtAmount > 0, \"batch transfer balance failed\");\r\n        uint totalInvestment = _getTotalInvestment();\r\n\r\n        if (totalUsdtAmount > totalInvestment) {\r\n            uint income = totalUsdtAmount.sub(totalInvestment);\r\n            uint totalInvestorsIncome = income.mul(uint256(100).sub(platformCoefficient)).div(uint256(100)).add(totalInvestment);\r\n            for (uint i = 0; i < investors.length; i ++) {\r\n                address investor = investors[i];\r\n                uint investment = investments[investor];\r\n                uint investorIncome = totalInvestorsIncome.mul(investment).div(totalInvestment);\r\n                SafeERC20.safeTransfer(IERC20(usdtContract), investor, investorIncome);\r\n            }\r\n        } else if (totalUsdtAmount < totalInvestment) {\r\n            for (uint i = 0; i < investors.length; i ++) {\r\n                address investor = investors[i];\r\n                uint investment = investments[investor];\r\n                uint investorIncome = totalUsdtAmount.mul(investment).div(totalInvestment);\r\n                SafeERC20.safeTransfer(IERC20(usdtContract), investor, investorIncome);\r\n            }\r\n        } else {\r\n            for (uint i = 0; i < investors.length; i ++) {\r\n                address investor = investors[i];\r\n                uint investment = investments[investor];\r\n                SafeERC20.safeTransfer(IERC20(usdtContract), investor, investment);\r\n            }\r\n        }\r\n\r\n        uint leftUsdtAmount = IERC20(usdtContract).balanceOf(address(this));\r\n        if (leftUsdtAmount > 0) {\r\n            SafeERC20.safeTransfer(IERC20(usdtContract), platformAddr, leftUsdtAmount);\r\n        }\r\n    }\r\n\r\n    function _getTogetherSupply(uint _count) private {\r\n        uint _num = IERC20(daiContract).balanceOf(address(this));\r\n        require(_num > 0,\"invalid param\");\r\n        for (uint i = 0; i < _count;i++) {\r\n            SafeERC20.safeApprove(IERC20(daiContract),cDaiContract,_num);\r\n            require(ICDaiErc20(cDaiContract).mint(_num) == 0,\"supply fail\");\r\n            supplySection.push(_num);\r\n            if(i != _count - 1){\r\n                _num = _num.mul(mortgageFactor).div(100);\r\n                require(ICDaiErc20(cDaiContract).borrow(_num) == 0,\"borrow fail\");     \r\n            }\r\n       }\r\n    }\r\n\r\n    function _getTogetherRedeem() private {\r\n        uint _totalSupplyCurrrent;\r\n        uint _totalBorrowCurrrent;\r\n        uint _value;\r\n        uint _length = supplySection.length;\r\n        for(uint i = 0; i < _length ;i++){\r\n            _totalBorrowCurrrent = ICDaiErc20(cDaiContract).borrowBalanceCurrent(address(this));\r\n            if(_totalBorrowCurrrent == 0){\r\n                break;\r\n            }\r\n            _totalSupplyCurrrent = ICDaiErc20(cDaiContract).balanceOfUnderlying(address(this));\r\n            _value = _totalSupplyCurrrent.sub(_totalBorrowCurrrent.mul(100).div(maxMortgageFactor));\r\n    \r\n            require(ICDaiErc20(cDaiContract).redeemUnderlying(_value) == 0,\"redeemUnderlying fail\");  \r\n            \r\n            if(_value > _totalBorrowCurrrent){\r\n                _value = _totalBorrowCurrrent;\r\n            }\r\n            SafeERC20.safeApprove(IERC20(daiContract),cDaiContract,_value);\r\n            require(ICDaiErc20(cDaiContract).repayBorrow(_value) == 0,\"repayBorrow fail\"); \r\n        }\r\n\r\n        \r\n        _value = ICDaiErc20(cDaiContract).balanceOf(address(this));\r\n        if(_value > 0){\r\n             require(ICDaiErc20(cDaiContract).redeem(_value) == 0,\"redeem fail\"); \r\n        }\r\n      \r\n    }\r\n    \r\n    function repayAllBorrow() external onlyOwner(){\r\n       uint value;    \r\n       uint totalBorrowCurrrent = ICDaiErc20(cDaiContract).borrowBalanceCurrent(address(this));\r\n       uint balance = IERC20(daiContract).balanceOf(address(this));\r\n       require(balance >= totalBorrowCurrrent ,\"dai balance no enouth\");\r\n       value = ICDaiErc20(cDaiContract).borrowBalanceCurrent(address(this)); \r\n       if(value > 0){\r\n           SafeERC20.safeApprove(IERC20(daiContract),cDaiContract,value);\r\n           require(ICDaiErc20(cDaiContract).repayBorrow(value) == 0,\"repayBorrow fail\");\r\n       }\r\n       \r\n    }\r\n\r\n    function _cleanAllInfo() private {\r\n        _deleteAllInvestorInfo();\r\n        delete totalInvestor;\r\n        delete supplySection;\r\n        delete crowdfundNumber;  \r\n        delete crowdfundPeriod;\r\n        delete dartNumber;\r\n        delete dartPeriod;\r\n        status = DefiStatus.UNUSED;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function startCrowdFunding(uint _totalInvestment, uint _crowdfundPeriod) external onlyOwner() {\r\n        require(status == DefiStatus.UNUSED, \"not unused status\");\r\n        require(_totalInvestment > 0 && _crowdfundPeriod > 0, \"error crowdFunding time\");\r\n        status = DefiStatus.CROWDFUNDING;\r\n        totalInvestor = _totalInvestment;\r\n        crowdfundNumber = block.number;\r\n        crowdfundPeriod = _crowdfundPeriod.div(15);\r\n    }\r\n    \r\n    function crowdFunding(uint amount) external {\r\n        require(status == DefiStatus.CROWDFUNDING, \"not crowdfunding status\");\r\n        require(amount >= minCrowdFundingAmount,\"not enough amount\");\r\n        require(block.number < crowdfundNumber.add(crowdfundPeriod), \"crowdfunding time has passed\");\r\n        SafeERC20.safeTransferFrom(IERC20(usdtContract), msg.sender, address(this), amount);\r\n        _addInverstorInfo(msg.sender, amount);\r\n        uint currentAmount = _getTotalInvestment();\r\n        if (currentAmount >= totalInvestor) {\r\n            status = DefiStatus.WAITDART;\r\n        }\r\n    }\r\n    \r\n    function cancelCrowdfunding() external {\r\n        require(status == DefiStatus.CROWDFUNDING || status == DefiStatus.WAITDART);\r\n        uint allowInvestmentNumber = crowdfundNumber.add(crowdfundPeriod).add(intervalNumber);\r\n        require(msg.sender == owner || (_isContainsInvestors(msg.sender) && (block.number > allowInvestmentNumber)));\r\n        _batchTransferPrincipal();\r\n        _cleanAllInfo();\r\n    }\r\n\r\n    function startDart(uint count, uint duration) external onlyOwner() {\r\n        require(status == DefiStatus.WAITDART, \"not wait dart status\");\r\n        require(count > 0 && duration > 0, \"error startDart time\");\r\n        _swap(usdtContract, daiContract); \r\n        _getTogetherSupply(count);\r\n        status = DefiStatus.DARTSUCCESS;\r\n        dartNumber = block.number;\r\n        dartPeriod = duration.div(15);\r\n    }\r\n    \r\n    function startLiquidation() external {\r\n        require(status == DefiStatus.DARTSUCCESS);\r\n        uint allowInvestmentNumber = dartNumber.add(dartPeriod).add(intervalNumber);\r\n        require(msg.sender == owner || (_isContainsInvestors(msg.sender) && (block.number > allowInvestmentNumber)) || _isAdmin(msg.sender));\r\n        _getTogetherRedeem();\r\n        _swap(daiContract, usdtContract);\r\n        _swap(compContract, usdtContract);\r\n        _batchTransferPrincipalAndIncome();\r\n        _cleanAllInfo();\r\n    }\r\n\r\n\r\n    function claimComp() external onlyOwner() {\r\n        ICDaiErc20(compComptrollerContract).claimComp(address(this));\r\n        _swap(compContract, usdtContract);\r\n\r\n    }\r\n\r\n    function setOwner(address _address) external onlyOwner() {\r\n         owner = _address;\r\n    }\r\n\r\n    function setIsUniswapWay(bool _isUniswapWay) external onlyOwner() {\r\n        isUniswapWay = _isUniswapWay;\r\n    }\r\n\r\n    function setCurveInfo(address _poolAddr, int128 _usdtIndex, int128 _daiIndex) external onlyOwner() {\r\n        curvePoolContract = _poolAddr;\r\n        curveUsdtIndex = _usdtIndex;\r\n        curveDaiIndex = _daiIndex;\r\n    }\r\n\r\n    function setMinCrowdFundingAmount(uint minAmount) external onlyOwner() {\r\n        minCrowdFundingAmount = minAmount;\r\n    }\r\n\r\n    function setPlatformIncomeAddress(address _address) external onlyOwner() {\r\n        platformAddr = _address;\r\n    }\r\n\r\n    function setPlatformCoefficient(uint8 _platformCoefficient) external onlyOwner() {\r\n        platformCoefficient = _platformCoefficient;\r\n    }\r\n\r\n    function setMortgageFactor(uint _mortgageFactor) external onlyOwner() {\r\n         mortgageFactor = _mortgageFactor;\r\n    }\r\n    \r\n    function setMaxMortgageFactor(uint _mortgageFactor) external onlyOwner() {\r\n         maxMortgageFactor = _mortgageFactor;\r\n    }\r\n\r\n    function addAdmin(address _address) external onlyOwner() {\r\n        admins[_address] = true;\r\n    }\r\n\r\n    function removeAdmin(address _address) external onlyOwner() {\r\n        delete admins[_address];\r\n    }\r\n\r\n    function investorAmount(address investor) external view returns(uint) {\r\n        return investments[investor];\r\n    }\r\n\r\n    function currentTotalAmount() external view returns(uint) {\r\n        return _getTotalInvestment();\r\n    }\r\n \r\n    function currentInvestors()  external view returns(address[] memory,uint[] memory amountArray) {\r\n        amountArray = new uint[](investors.length);\r\n        for(uint i = 0; i < investors.length ;i++){\r\n           amountArray[i] = investments[investors[i]];\r\n        }\r\n        return (investors,amountArray);\r\n    }\r\n\r\n}\r\n"},"browser/tests/demo2/SafeERC20.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity >=0.6.11;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n   using SafeMath for uint256;\r\n   using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        if(token.allowance(address(this),spender) < value){\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n        }\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n         \r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n  \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"browser/tests/demo2/SafeMath.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity >=0.6.11;\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"},"browser/tests/demo2/interfaces/ICDaiErc20.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity >=0.6.11;\r\n\r\ninterface ICDaiErc20{\r\n    function mint(uint256) external returns (uint256);\r\n    function redeem(uint) external returns (uint);\r\n    function redeemUnderlying(uint) external returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function borrow(uint256) external returns (uint256);\r\n    function repayBorrow(uint256) external returns (uint256);\r\n    function balanceOfUnderlying(address) external returns (uint);\r\n    function borrowBalanceCurrent(address) external returns (uint256);\r\n\r\n    function claimComp(address holder) external;\r\n}\r\n"},"browser/tests/demo2/interfaces/ICurve.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity >=0.6.11;\r\n\r\ninterface ICurve {\r\n    function get_dy(int128 i, int128 j, uint256 dx) external returns (uint256);\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\r\n}"},"browser/tests/demo2/interfaces/IUniswapV2Router.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity >=0.6.11;\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n}"}}}