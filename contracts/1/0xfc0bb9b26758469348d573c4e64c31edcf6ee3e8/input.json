{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/github/stimuluspackage/PlexusContracts/contracts/wrapperBancor.sol":{"content":"\n/*\n\n                                       `.-:+osyhhhhhhyso+:-.`\n                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\n                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\n                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\n                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\n                         `omNNNNNNdo-`                        `-odNNNNNNmo`\n                        :dNNNNNNh/`                              `/hNNNNNNd:\n                      `oNNNNNNh:                     /-/.           :hNNNNNNo`\n                     `yNNNNNm+`                      mNNm-           `+mNNNNNy`\n                    `hNNNNNd-                        hNNNm.            -dNNNNNh`\n                    yNNNNNd.                         .ymNNh             .dNNNNNy\n                   /NNNNNm.                            -mNNys+.          .mNNNNN/\n                  `mNNNNN:                           `:hNNNNNNNs`         :NNNNNm`\n                  /NNNNNh                          `+dNNNNNNNNNNd.         hNNNNN/\n                  yNNNNN/               .:+syyhhhhhmNNNNNNNNNNNNNm`        /NNNNNy\n                  dNNNNN.            `+dNNNNNNNNNNNNNNNNNNNNNNNmd+         .NNNNNd\n                  mNNNNN`           -dNNNNNNNNNNNNNNNNNNNNNNm-             `NNNNNm\n                  dNNNNN.          -NNNNNNNNNNNNNNNNNNNNNNNN+              .NNNNNd\n                  yNNNNN/          dNNNNNNNNNNNNNNNNNNNNNNNN:              /NNNNNy\n                  /NNNNNh         .NNNNNNNNNNNNNNNNNNNNNNNNd`              hNNNNN/\n                  `mNNNNN:        -NNNNNNNNNNNNNNNNNNNNNNNh.              :NNNNNm`\n                   /NNNNNm.       `NNNNNNNNNNNNNNNNNNNNNh:               .mNNNNN/\n                    yNNNNNd.      .yNNNNNNNNNNNNNNNdmNNN/               .dNNNNNy\n                    `hNNNNNd-    `dmNNNNNNNNNNNNdo-`.hNNh              -dNNNNNh`\n                     `yNNNNNm+`   oNNmmNNNNNNNNNy.   `sNNdo.         `+mNNNNNy`\n                      `oNNNNNNh:   ....++///+++++.     -+++.        :hNNNNNNo`\n                        :dNNNNNNh/`                              `/hNNNNNNd:\n                         `omNNNNNNdo-`                        `-odNNNNNNmo`\n                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\n                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\n                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\n                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\n                                       `.-:+yourewelcome+:-.`\n /$$$$$$$  /$$                                               /$$      /$$\n| $$__  $$| $$                                              | $$$    /$$$\n| $$  \\ $$| $$  /$$$$$$  /$$   /$$ /$$   /$$  /$$$$$$$      | $$$$  /$$$$  /$$$$$$  /$$$$$$$   /$$$$$$  /$$   /$$\n| $$$$$$$/| $$ /$$__  $$|  $$ /$$/| $$  | $$ /$$_____/      | $$ $$/$$ $$ /$$__  $$| $$__  $$ /$$__  $$| $$  | $$\n| $$____/ | $$| $$$$$$$$ \\  $$$$/ | $$  | $$|  $$$$$$       | $$  $$$| $$| $$  \\ $$| $$  \\ $$| $$$$$$$$| $$  | $$\n| $$      | $$| $$_____/  >$$  $$ | $$  | $$ \\____  $$      | $$\\  $ | $$| $$  | $$| $$  | $$| $$_____/| $$  | $$\n| $$      | $$|  $$$$$$$ /$$/\\  $$|  $$$$$$/ /$$$$$$$/      | $$ \\/  | $$|  $$$$$$/| $$  | $$|  $$$$$$$|  $$$$$$$\n|__/      |__/ \\_______/|__/  \\__/ \\______/ |_______/       |__/     |__/ \\______/ |__/  |__/ \\_______/ \\____  $$\n                                                                                                        /$$  | $$\n                                                                                                       |  $$$$$$/\n                                                                                                       \\______/\n\n\n\n//Based Bancor Interaction developed by:\n\n// ███████╗░█████╗░██████╗░██████╗░███████╗██████╗░░░░███████╗██╗\n// ╚════██║██╔══██╗██╔══██╗██╔══██╗██╔════╝██╔══██╗░░░██╔════╝██║\n// ░░███╔═╝███████║██████╔╝██████╔╝█████╗░░██████╔╝░░░█████╗░░██║\n// ██╔══╝░░██╔══██║██╔═══╝░██╔═══╝░██╔══╝░░██╔══██╗░░░██╔══╝░░██║\n// ███████╗██║░░██║██║░░░░░██║░░░░░███████╗██║░░██║██╗██║░░░░░██║\n// ╚══════╝╚═╝░░╚═╝╚═╝░░░░░╚═╝░░░░░╚══════╝╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝\n// Copyright (C) 2020 zapper\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n\n///@author Zapper\n///@notice This contract adds liquidity to BancorV2 Pools using ETH or ERC20 Tokens\n\n// File: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\n\n\n\n interface WrappedETH {\n    function totalSupply() external view returns(uint supply);\n\n    function balanceOf(address _owner) external view returns(uint balance);\n\n    function transfer(address _to, uint _value) external returns(bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n\n    function approve(address _spender, uint _value) external returns(bool success);\n\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\n\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n\n}\n\ninterface UniswapV2{\n\n\n   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\n   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\n   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\n   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\n\n   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n}\ninterface UniswapFactory{\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\n\ninterface BANGetter{\n    function getConvertibleTokenAnchors(address tokenAddress) external view returns(address[] calldata banAddresses);\n    function getConvertersByAnchors(address[] calldata) external view returns(address[] calldata);\n}\n\n\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n\n\n            bytes32 accountHash\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account)\n        internal\n        pure\n        returns (address payable)\n    {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call{value:amount}(\"\");\n\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor()  {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor() {}\n\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address payable public _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor()  {\n        address payable msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address payable newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IBancorV2Converter {\n    function anchor() external view returns (address);\n}\n\ninterface IBancorLiquidityProtection {\n    function addLiquidityFor(\n        address _owner,\n        address _poolAnchor,\n        address _reserveToken,\n        uint256 _amount\n    ) external payable returns (uint256 poolTokenAmount);\n\n    function baseTokenAvailableSpace(address pool) view external returns(uint256);\n}\n\ninterface IBancorLiquidityProtectionStore {\n    function protectedLiquidity(uint256 _id)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n}\n\ninterface IBancorContractRegistry {\n    function addressOf(bytes32 _contractName) external view returns (address);\n}\n\ncontract BancorPlexusWrapper is ReentrancyGuard, Ownable {\n\n    address public ETH_TOKEN_ADDRESS  = address(0x0);\n  address public WETH_TOKEN_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  WrappedETH wethToken = WrappedETH(WETH_TOKEN_ADDRESS);\n  uint256 approvalAmount = 1000000000000000000000000000000;\n  uint256 longTimeFromNow = 1000000000000000000000000000;\n  address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n  address uniFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n  address bancorConverterRegistryAddress = 0xC0205e203F423Bcd8B2a4d6f8C8A154b0Aa60F19;\n  BANGetter bConv = BANGetter(bancorConverterRegistryAddress);\n  UniswapV2 uniswapExchange = UniswapV2(uniAddress);\n  UniswapFactory factory = UniswapFactory(uniFactoryAddress);\n  mapping (address => address[]) public lpTokenAddressToPairs;\n  mapping(string=>address) public stablecoins;\n  mapping(address=>mapping(address=>address[])) public presetPaths;\n\n  bool public changeRecpientIsOwner;\n   uint256 public fee = 0;\n  uint256 public maxfee = 0;\n\n\n    using SafeMath for uint256;\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    bool public stopped = false;\n    uint16 public goodwill;\n\n    address\n        private constant ETHAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address\n        private constant wethTokenAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable\n        private constant zgoodwillAddress = 0x3CE37278de6388532C3949ce4e886F365B14fB56;\n\n    bytes32 private constant liquidityProtectionName = \"LiquidityProtection\";\n    bytes32\n        private constant liquidityProtectionStoreName = \"LiquidityProtectionStore\";\n\n    IBancorContractRegistry\n        public constant bancorRegistry = IBancorContractRegistry(\n        0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4\n    );\n\n    event Zapin(\n        address toWhomToIssue,\n        address toPoolAnchor,\n        uint256 LPTRec,\n        uint256 id\n    );\n\n    constructor() public {\n\n        goodwill = 1;\n        _owner = msg.sender;\n    }\n\n    // circuit breaker modifiers\n    modifier stopInEmergency {\n        if (stopped) {\n            revert(\"Temporarily Paused\");\n        } else {\n            _;\n        }\n    }\n\n    function wrap(address sourceToken, address[] memory destinationTokens, uint256 amount) public payable returns(address, uint256){\n\n        address[] memory banConvAddresses = bConv.getConvertibleTokenAnchors(destinationTokens[0]);\n        address[] memory bancConAddrs = bConv.getConvertersByAnchors(banConvAddresses);\n        address theBanConverterAddress = bancConAddrs[0];\n        bytes memory swapData;\n        address theAllowanceTarget = address(0x0);\n        address theSwapTarget = address(0x0);\n        (uint256 lpsRec, uint256 idInfo) = ZapInSingleSided(sourceToken, theBanConverterAddress, destinationTokens[0], amount,theAllowanceTarget,theSwapTarget, swapData);\n        return(theBanConverterAddress, lpsRec);\n\n    }\n\n\n    function spaceAvailable(address tokenAddress) view public returns (address, uint256){\n        address[] memory banConvAddresses = bConv.getConvertibleTokenAnchors(tokenAddress);\n\n        address[] memory bancConAddrs = bConv.getConvertersByAnchors(banConvAddresses);\n        address theBanConverterAddress = bancConAddrs[0];\n       // return(theBanConverterAddress, 0);\n\n         address poolAnchor = IBancorV2Converter(theBanConverterAddress)\n            .anchor();\n        address bancorLiquidityProtectionAddress = bancorRegistry.addressOf(\n            liquidityProtectionName\n        );\n         IBancorLiquidityProtection bancorLiquidityProtection\n         = IBancorLiquidityProtection(bancorLiquidityProtectionAddress);\n\n        uint256 spaceAvailable = bancorLiquidityProtection.baseTokenAvailableSpace(poolAnchor);\n        return (poolAnchor, spaceAvailable);\n\n\n    }\n\n\n    function ZapInSingleSided(\n        address _fromTokenAddress,\n        address _toBanConverterAddress,\n        address _toReserveTokenAddress,\n        uint256 _amount,\n        address _allowanceTarget,\n        address _swapTarget,\n        bytes memory swapData\n    )\n        public\n        payable\n        nonReentrant\n        stopInEmergency\n        returns (uint256 lptReceived, uint256 id)\n    {\n        uint256 valueToSend;\n        address tokenToSend;\n        address poolAnchor = IBancorV2Converter(_toBanConverterAddress)\n            .anchor();\n\n        if (_fromTokenAddress == address(0)) {\n            require(msg.value > 0, \"ERR: No ETH sent\");\n            valueToSend = _transferGoodwill(_fromTokenAddress, msg.value);\n        } else {\n            require(_amount > 0, \"Err: No Tokens Sent\");\n            require(msg.value == 0, \"ERR: ETH sent with Token\");\n            tokenToSend = _fromTokenAddress;\n            IERC20(tokenToSend).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _amount\n            );\n            valueToSend = _transferGoodwill(_fromTokenAddress, _amount);\n        }\n\n        if (_fromTokenAddress == _toReserveTokenAddress) {\n            (lptReceived, id) = _enterBancor(\n                poolAnchor,\n                tokenToSend,\n                valueToSend\n            );\n        } else {\n            /*\n            uint256 reserveTokensBought = _fillQuote(\n                tokenToSend,\n                _toReserveTokenAddress,\n                valueToSend,\n                _allowanceTarget,\n                _swapTarget,\n                swapData\n            );\n\n            */\n\n            uint256 reserveTokensBought= conductUniswap(tokenToSend, _toReserveTokenAddress, valueToSend);\n\n            if(fee>0 && _toReserveTokenAddress != address(0x0)  && _toReserveTokenAddress != ETHAddress){\n              IERC20 resToken =  IERC20(_toReserveTokenAddress);\n            uint256 totalFee = (reserveTokensBought.mul(fee)).div(10000);\n            if(totalFee >0){\n               resToken.transfer(_owner, totalFee);\n            }\n            reserveTokensBought = resToken.balanceOf(address(this));\n\n            }\n\n\n            (lptReceived, id) = _enterBancor(\n                poolAnchor,\n                _toReserveTokenAddress,\n                reserveTokensBought\n            );\n        }\n        emit Zapin(msg.sender, poolAnchor, lptReceived, id);\n    }\n\n    function _enterBancor(\n        address _poolAnchor,\n        address _reserveToken,\n        uint256 _amount\n    ) internal returns (uint256 lptReceived, uint256 id) {\n        uint256 valueToSend;\n        address reserveToken = _reserveToken;\n        address bancorLiquidityProtectionAddress = bancorRegistry.addressOf(\n            liquidityProtectionName\n        );\n\n        if (_reserveToken != address(0)) {\n            IERC20 toReserveToken = IERC20(_reserveToken);\n            toReserveToken.safeApprove(bancorLiquidityProtectionAddress, 0);\n            toReserveToken.safeApprove(\n                bancorLiquidityProtectionAddress,\n                _amount\n            );\n        } else {\n            valueToSend = _amount;\n            reserveToken = ETHAddress;\n        }\n\n\n            IBancorLiquidityProtection bancorLiquidityProtection\n         = IBancorLiquidityProtection(bancorLiquidityProtectionAddress);\n\n        id = bancorLiquidityProtection.addLiquidityFor{value:valueToSend}(\n            msg.sender,\n            _poolAnchor,\n            reserveToken,\n            _amount\n        );\n\n\n            IBancorLiquidityProtectionStore liquidityProtectionStore\n         = IBancorLiquidityProtectionStore(\n            bancorRegistry.addressOf(liquidityProtectionStoreName)\n        );\n\n        (, , , lptReceived, , , , ) = liquidityProtectionStore\n            .protectedLiquidity(id);\n    }\n\n    function _fillQuote(\n        address _fromTokenAddress,\n        address _toReserveTokenAddress,\n        uint256 _amount,\n        address _allowanceTarget,\n        address _swapTarget,\n        bytes memory swapData\n    ) internal returns (uint256) {\n        uint256 valueToSend;\n        if (_fromTokenAddress == address(0)) {\n            valueToSend = _amount;\n        } else {\n            IERC20 fromToken = IERC20(_fromTokenAddress);\n            fromToken.safeApprove(address(_allowanceTarget), 0);\n            fromToken.safeApprove(address(_allowanceTarget), _amount);\n        }\n\n        uint256 initialBalance = _toReserveTokenAddress == address(0)\n            ? address(this).balance\n            : IERC20(_toReserveTokenAddress).balanceOf(address(this));\n\n        (bool success, ) = _swapTarget.call{value:valueToSend}(swapData);\n        require(success, \"Error Swapping Tokens\");\n\n        uint256 finalBalance = _toReserveTokenAddress == address(0)\n            ? (address(this).balance).sub(initialBalance)\n            : IERC20(_toReserveTokenAddress).balanceOf(address(this)).sub(\n                initialBalance\n            );\n\n        require(finalBalance > 0, \"Swapped to Invalid Intermediate\");\n\n        return finalBalance;\n    }\n\n    /**\n    @dev This function is used to calculate and transfer goodwill\n    @param _tokenContractAddress Token from which goodwill is deducted\n    @param valueToSend The total value being zapped in\n    @return The quantity of remaining tokens\n     */\n    function _transferGoodwill(\n        address _tokenContractAddress,\n        uint256 valueToSend\n    ) internal returns (uint256) {\n        if (goodwill == 0) return valueToSend;\n\n        uint256 goodwillPortion = SafeMath.div(\n            SafeMath.mul(valueToSend, goodwill),\n            10000\n        );\n        if (_tokenContractAddress == address(0)) {\n            zgoodwillAddress.transfer(goodwillPortion);\n        } else {\n            IERC20(_tokenContractAddress).safeTransfer(\n                zgoodwillAddress,\n                goodwillPortion\n            );\n        }\n        return valueToSend.sub(goodwillPortion);\n    }\n\n    function set_new_goodwill(uint16 _new_goodwill) public onlyOwner {\n        require(\n            _new_goodwill >= 0 && _new_goodwill < 10000,\n            \"GoodWill Value not allowed\"\n        );\n        goodwill = _new_goodwill;\n    }\n\n    function inCaseTokengetsStuck(address _tokenAddress) public onlyOwner {\n        IERC20 tokenAddress = IERC20(_tokenAddress);\n        uint256 qty = tokenAddress.balanceOf(address(this));\n        tokenAddress.safeTransfer(owner(), qty);\n    }\n\n    // - to Pause the contract\n    function toggleContractActive() public onlyOwner {\n        stopped = !stopped;\n    }\n\n    // - to withdraw any ETH balance sitting in the contract\n    function withdraw() public onlyOwner {\n        uint256 contractBalance = address(this).balance;\n        address payable _to = owner().toPayable();\n        _to.transfer(contractBalance);\n    }\n\n\n\n  function conductUniswap(address sellToken, address buyToken, uint amount) internal returns (uint256 amounts1){\n\n            if(sellToken ==ETH_TOKEN_ADDRESS && buyToken == WETH_TOKEN_ADDRESS){\n                wethToken.deposit{value:msg.value}();\n\n            }\n            else if(sellToken == address(0x0) || sellToken == ETHAddress){\n\n               // address [] memory addresses = new address[](2);\n               address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\n                //addresses[0] = WETH_TOKEN_ADDRESS;\n                //addresses[1] = buyToken;\n                uniswapExchange.swapExactETHForTokens{value:msg.value}(0, addresses, address(this), 1000000000000000 );\n\n            }\n\n            else if(sellToken == WETH_TOKEN_ADDRESS){\n                wethToken.withdraw(amount);\n\n                //address [] memory addresses = new address[](2);\n                address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\n                //addresses[0] = WETH_TOKEN_ADDRESS;\n                //addresses[1] = buyToken;\n                uniswapExchange.swapExactETHForTokens{value:amount}(0, addresses, address(this), 1000000000000000 );\n\n            }\n\n\n\n            else{\n\n          address [] memory addresses = getBestPath(sellToken, buyToken, amount);\n           uint256 [] memory amounts = conductUniswapT4T(addresses, amount );\n           uint256 resultingTokens = amounts[amounts.length-1];\n           return resultingTokens;\n            }\n    }\n\n\n    //gets the best path to route the transaction on Uniswap\n    function getBestPath(address sellToken, address buyToken, uint256 amount) public view returns (address[] memory){\n\n        address [] memory defaultPath =new address[](2);\n        defaultPath[0]=sellToken;\n        defaultPath[1] = buyToken;\n\n\n        if(presetPaths[sellToken][buyToken].length !=0){\n            return presetPaths[sellToken][buyToken];\n        }\n\n\n        if(sellToken == stablecoins[\"DAI\"] || sellToken == stablecoins[\"USDC\"] || sellToken == stablecoins[\"USDT\"]){\n            return defaultPath;\n        }\n        if(buyToken == stablecoins[\"DAI\"] || buyToken == stablecoins[\"USDC\"] || buyToken == stablecoins[\"USDT\"]){\n            return defaultPath;\n        }\n\n\n\n        address[] memory daiPath = new address[](3);\n        address[] memory usdcPath =new address[](3);\n        address[] memory usdtPath =new address[](3);\n\n        daiPath[0] = sellToken;\n        daiPath[1] = stablecoins[\"DAI\"];\n        daiPath[2] = buyToken;\n\n        usdcPath[0] = sellToken;\n        usdcPath[1] = stablecoins[\"USDC\"];\n        usdcPath[2] = buyToken;\n\n        usdtPath[0] = sellToken;\n        usdtPath[1] = stablecoins[\"USDT\"];\n        usdtPath[2] = buyToken;\n\n\n        uint256 directPathOutput =  getPriceFromUniswap(defaultPath, amount)[1];\n\n\n        uint256[] memory daiPathOutputRaw = getPriceFromUniswap(daiPath, amount);\n        uint256[]  memory usdtPathOutputRaw = getPriceFromUniswap(usdtPath, amount);\n        uint256[]  memory usdcPathOutputRaw = getPriceFromUniswap(usdcPath, amount);\n\n        //uint256 directPathOutput = directPathOutputRaw[directPathOutputRaw.length-1];\n        uint256 daiPathOutput = daiPathOutputRaw[daiPathOutputRaw.length-1];\n        uint256 usdtPathOutput = usdtPathOutputRaw[usdtPathOutputRaw.length-1];\n        uint256 usdcPathOutput = usdcPathOutputRaw[usdcPathOutputRaw.length-1];\n\n        uint256 bestPathOutput = directPathOutput;\n        address[] memory bestPath = new address[](2);\n        address[] memory bestPath3 = new address[](3);\n        //return defaultPath;\n        bestPath = defaultPath;\n\n        bool isTwoPath = true;\n\n        if(directPathOutput < daiPathOutput){\n            isTwoPath=false;\n            bestPathOutput = daiPathOutput;\n            bestPath3 = daiPath;\n        }\n        if(bestPathOutput < usdcPathOutput){\n            isTwoPath=false;\n            bestPathOutput = usdcPathOutput;\n            bestPath3 = usdcPath;\n        }\n         if(bestPathOutput < usdtPathOutput){\n             isTwoPath=false;\n            bestPathOutput = usdtPathOutput;\n            bestPath3 = usdtPath;\n        }\n\n        require(bestPathOutput >0, \"This trade will result in getting zero tokens back. Reverting\");\n\n        if(isTwoPath==true){\n              return bestPath;\n        }\n        else{\n            return bestPath3;\n        }\n\n\n\n    }\n\n    function getPriceFromUniswap(address  [] memory theAddresses, uint amount) public view returns (uint256[] memory amounts1){\n\n\n        try uniswapExchange.getAmountsOut(amount,theAddresses ) returns (uint256[] memory amounts){\n            return amounts;\n        }\n        catch  {\n            uint256 [] memory amounts2= new uint256[](2);\n            amounts2[0]=0;\n            amounts2[1]=0;\n            return amounts2;\n\n        }\n\n    }\n     function conductUniswapT4T(address  [] memory theAddresses, uint amount) internal returns (uint256[] memory amounts1){\n\n           uint256 deadline = 1000000000000000;\n           uint256 [] memory amounts =  uniswapExchange.swapExactTokensForTokens(amount, 0, theAddresses, address(this),deadline );\n           return amounts;\n\n    }\n\n     function updateOwnerAddress(address payable newOwner) onlyOwner public returns (bool){\n     _owner = newOwner;\n     return true;\n   }\n\n   function updateUniswapExchange(address newAddress ) public onlyOwner returns (bool){\n\n    uniswapExchange = UniswapV2( newAddress);\n    uniAddress = newAddress;\n    return true;\n\n  }\n\n\n  function updateBancorConverter(address newAddress ) public onlyOwner returns (bool){\n\n    bancorConverterRegistryAddress =newAddress;\n    bConv = BANGetter(newAddress);\n\n    return true;\n\n  }\n\n\n\n function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n      if (address(token) == ETH_TOKEN_ADDRESS) {\n          destination.transfer(amount);\n      }\n      else {\n          IERC20 tokenToken = IERC20(token);\n          require(tokenToken.transfer(destination, amount));\n      }\n      return true;\n  }\n\n\n  function setFee(uint256 newFee) public onlyOwner returns (bool){\n    require(newFee<=maxfee, \"Admin cannot set the fee higher than the current maxfee\");\n    fee = newFee;\n    return true;\n  }\n\n\n  function setMaxFee(uint256 newMax) public onlyOwner returns (bool){\n    require(maxfee==0, \"Admin can only set max fee once and it is perm\");\n    maxfee = newMax;\n    return true;\n  }\n\n  function updateUniswapFactory(address newAddress ) public onlyOwner returns (bool){\n\n   factory = UniswapFactory( newAddress);\n   uniFactoryAddress = newAddress;\n   return true;\n\n }\n\n function updateStableCoinAddress(string memory coinName, address newAddress) public onlyOwner returns(bool){\n        stablecoins[coinName] = newAddress;\n        return true;\n\n    }\n\n  function updatePresetPaths(address sellToken, address buyToken, address[] memory newPath ) public onlyOwner returns(bool){\n        presetPaths[sellToken][buyToken] = newPath;\n        return true;\n    }\n\n    //owner can turn on ability to collect a small fee from trade imbalances on LP conversions\n    function updateChangeRecipientBool(bool changeRecpientIsOwnerBool ) public onlyOwner returns(bool){\n        changeRecpientIsOwner = changeRecpientIsOwnerBool;\n        return true;\n    }\n\n}\n"}}}