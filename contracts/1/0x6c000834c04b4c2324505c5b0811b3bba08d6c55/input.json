{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Emcodex.sol":{"content":"pragma solidity =0.6.6;\ncontract EMCODEX {\n    string public constant name = \"EMCODEX\";\n    string public constant symbol = \"EMCO\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n    mapping (address => uint32) public numCheckpoints;\n\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 balance;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    constructor () public {\n        mint(address(msg.sender), 100000000 * 1e18);\n    }\n\n    function mint(address _account, uint256 _number) internal {\n        balances[_account] = _number;\n        totalSupply += _number;\n        emit Transfer(address(0), _account, _number);\n        _moveDelegates(address(0), _account, _number);\n    }\n\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint256 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint256(-1);\n        } else {\n            amount = safe256(rawAmount, \"EMCO::approve: amount exceeds 256 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    function transfer(address dst, uint rawAmount) external returns (bool) {\n        uint256 amount = safe256(rawAmount, \"EMCO::transfer: amount exceeds 256 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n        uint256 amount = safe256(rawAmount, \"EMCO::approve: amount exceeds 256 bits\");\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = sub256(spenderAllowance, amount, \"EMCO::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(address src, address dst, uint256 amount) internal {\n        require(src != address(0), \"EMCO::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"EMCO::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub256(balances[src], amount, \"EMCO::_transferTokens: transfer amount exceeds balance\");\n        balances[dst] = add256(balances[dst], amount, \"EMCO::_transferTokens: transfer amount overflows\");\n\n        emit Transfer(src, dst, amount);\n        _moveDelegates(src, dst, amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].balance : 0;\n                uint256 srcRepNew = sub256(srcRepOld, amount, \"EMCO::_moveDelegates: amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].balance : 0;\n                uint256 dstRepNew = add256(dstRepOld, amount, \"EMCO::_moveDelegates: amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address account, uint32 nCheckpoints, uint256 newBalance) internal {\n      uint32 blockNumber = safe32(block.number, \"EMCO::_writeCheckpoint: block number exceeds 32 bits\");\n\n      if (nCheckpoints > 0 && checkpoints[account][nCheckpoints - 1].fromBlock == blockNumber) {\n          checkpoints[account][nCheckpoints - 1].balance = newBalance;\n      } else {\n          checkpoints[account][nCheckpoints] = Checkpoint(blockNumber, newBalance);\n          numCheckpoints[account] = nCheckpoints + 1;\n      }\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe256(uint256 n, string memory errorMessage) internal pure returns (uint256) {\n        require(n <= uint(2**256-1), errorMessage);\n        return uint256(n);\n    }\n\n    function add256(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n}\n"}}}