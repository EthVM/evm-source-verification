{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ACCAToken.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-06-02\r\n*/\r\n\r\npragma solidity ^0.4.18;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        OwnershipTransferred(owner, _newOwner);\r\n        newOwner = _newOwner;\r\n    } \r\n\r\n    /**\r\n     * @dev 새로운 관리자가 승인해야만 소유권이 이전된다\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        \r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ACCAToken\r\n\r\n * @dev ACCA 토큰을 생성한다\r\n */\r\ncontract ACCAToken is StandardToken, Ownable {\r\n    // 토큰의 이름\r\n    string public constant name = \"ACCA\";\r\n    \r\n    // 토큰의 단위\r\n    string public constant symbol = \"ACCA\";\r\n    \r\n    // 소수점 자리수. ETH 18자리에 맞춘다\r\n    uint8 public constant decimals = 18;\r\n    \r\n    // 지갑별로 송금/수금 기능의 잠긴 여부를 저장\r\n    mapping (address => LockedInfo) public lockedWalletInfo;\r\n    \r\n    /**\r\n     * @dev 플랫폼에서 운영하는 마스터노드 스마트 컨트렉트 주소\r\n     */\r\n    mapping (address => bool) public manoContracts;\r\n    \r\n    \r\n    /**\r\n     * @dev 토큰 지갑의 잠김 속성을 정의\r\n     * \r\n     * @param timeLockUpEnd timeLockUpEnd 시간까지 송/수금에 대한 제한이 적용된다. 이후에는 제한이 풀린다\r\n     * @param sendLock 출금 잠김 여부(true : 잠김, false : 풀림)\r\n     * @param receiveLock 입금 잠김 여부 (true : 잠김, false : 풀림)\r\n     */\r\n    struct LockedInfo {\r\n        uint timeLockUpEnd;\r\n        bool sendLock;\r\n        bool receiveLock;\r\n    } \r\n    \r\n    \r\n    /**\r\n     * @dev 토큰이 송금됐을 때 발생하는 이벤트\r\n     * @param from 토큰을 보내는 지갑 주소\r\n     * @param to 토큰을 받는 지갑 주소\r\n     * @param value 전달되는 토큰의 양 (Satoshi)\r\n     */\r\n    event Transfer (address indexed from, address indexed to, uint256 value);\r\n    \r\n    /**\r\n     * @dev 토큰 지갑의 송금/입금 기능이 제한되었을 때 발생하는 이벤트\r\n     * @param target 제한 대상 지갑 주소\r\n     * @param timeLockUpEnd 제한이 종료되는 시간(UnixTimestamp)\r\n     * @param sendLock 지갑에서의 송금을 제한하는지 여부(true : 제한, false : 해제)\r\n     * @param receiveLock 지갑으로의 입금을 제한하는지 여부 (true : 제한, false : 해제)\r\n     */\r\n    event Locked (address indexed target, uint timeLockUpEnd, bool sendLock, bool receiveLock);\r\n    \r\n    /**\r\n     * @dev 지갑에 대한 송금/입금 제한을 해제했을 때 발생하는 이벤트\r\n     * @param target 해제 대상 지갑 주소\r\n     */\r\n    event Unlocked (address indexed target);\r\n    \r\n    /**\r\n     * @dev 송금 받는 지갑의 입금이 제한되어있어서 송금이 거절되었을 때 발생하는 이벤트\r\n     * @param from 토큰을 보내는 지갑 주소\r\n     * @param to (입금이 제한된) 토큰을 받는 지갑 주소\r\n     * @param value 전송하려고 한 토큰의 양(Satoshi)\r\n     */\r\n    event RejectedPaymentToLockedUpWallet (address indexed from, address indexed to, uint256 value);\r\n    \r\n    /**\r\n     * @dev 송금하는 지갑의 출금이 제한되어있어서 송금이 거절되었을 때 발생하는 이벤트\r\n     * @param from (출금이 제한된) 토큰을 보내는 지갑 주소\r\n     * @param to 토큰을 받는 지갑 주소\r\n     * @param value 전송하려고 한 토큰의 양(Satoshi)\r\n     */\r\n    event RejectedPaymentFromLockedUpWallet (address indexed from, address indexed to, uint256 value);\r\n    \r\n    /**\r\n     * @dev 토큰을 소각한다. \r\n     * @param burner 토큰을 소각하는 지갑 주소\r\n     * @param value 소각하는 토큰의 양(Satoshi)\r\n     */\r\n    event Burn (address indexed burner, uint256 value);\r\n    \r\n    /**\r\n     * @dev 아피스 플랫폼에 마스터노드 스마트 컨트렉트가 등록되거나 해제될 때 발생하는 이벤트\r\n     */\r\n    event ManoContractRegistered (address manoContract, bool registered);\r\n    \r\n    /**\r\n     * @dev 컨트랙트가 생성될 때 실행. 컨트렉트 소유자 지갑에 모든 토큰을 할당한다.\r\n     * 발행량이나 이름은 소스코드에서 확인할 수 있도록 변경하였음\r\n     */\r\n    function ACCAToken() public {\r\n        // 총 ACCA 발행량 (1천만)\r\n        uint256 supplyACCA = 1000000000;\r\n        \r\n        // wei 단위로 토큰 총량을 생성한다.\r\n        totalSupply = supplyACCA * 10 ** uint256(decimals);\r\n        \r\n        balances[msg.sender] = totalSupply;\r\n        \r\n        Transfer(0x0, msg.sender, totalSupply);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 지갑을 지정된 시간까지 제한시키거나 해제시킨다. 제한 시간이 경과하면 모든 제한이 해제된다.\r\n     * @param _targetWallet 제한을 적용할 지갑 주소\r\n     * @param _timeLockEnd 제한이 종료되는 시간(UnixTimestamp)\r\n     * @param _sendLock (true : 지갑에서 토큰을 출금하는 기능을 제한한다.) (false : 제한을 해제한다)\r\n     * @param _receiveLock (true : 지갑으로 토큰을 입금받는 기능을 제한한다.) (false : 제한을 해제한다)\r\n     */\r\n    function walletLock(address _targetWallet, uint _timeLockEnd, bool _sendLock, bool _receiveLock) onlyOwner public {\r\n        require(_targetWallet != 0x0);\r\n        \r\n        // If all locks are unlocked, set the _timeLockEnd to zero.\r\n        if(_sendLock == false && _receiveLock == false) {\r\n            _timeLockEnd = 0;\r\n        }\r\n        \r\n        lockedWalletInfo[_targetWallet].timeLockUpEnd = _timeLockEnd;\r\n        lockedWalletInfo[_targetWallet].sendLock = _sendLock;\r\n        lockedWalletInfo[_targetWallet].receiveLock = _receiveLock;\r\n        \r\n        if(_timeLockEnd > 0) {\r\n            Locked(_targetWallet, _timeLockEnd, _sendLock, _receiveLock);\r\n        } else {\r\n            Unlocked(_targetWallet);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev 지갑의 입급/출금을 지정된 시간까지 제한시킨다. 제한 시간이 경과하면 모든 제한이 해제된다.\r\n     * @param _targetWallet 제한을 적용할 지갑 주소\r\n     * @param _timeLockUpEnd 제한이 종료되는 시간(UnixTimestamp)\r\n     */\r\n    function walletLockBoth(address _targetWallet, uint _timeLockUpEnd) onlyOwner public {\r\n        walletLock(_targetWallet, _timeLockUpEnd, true, true);\r\n    }\r\n    \r\n    /**\r\n     * @dev 지갑의 입급/출금을 영원히(33658-9-27 01:46:39+00) 제한시킨다.\r\n     * @param _targetWallet 제한을 적용할 지갑 주소\r\n     */\r\n    function walletLockBothForever(address _targetWallet) onlyOwner public {\r\n        walletLock(_targetWallet, 999999999999, true, true);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 지갑에 설정된 입출금 제한을 해제한다\r\n     * @param _targetWallet 제한을 해제하고자 하는 지갑 주소\r\n     */\r\n    function walletUnlock(address _targetWallet) onlyOwner public {\r\n        walletLock(_targetWallet, 0, false, false);\r\n    }\r\n    \r\n    /**\r\n     * @dev 지갑의 송금 기능이 제한되어있는지 확인한다.\r\n     * @param _addr 송금 제한 여부를 확인하려는 지갑의 주소\r\n     * @return isSendLocked (true : 제한되어 있음, 토큰을 보낼 수 없음) (false : 제한 없음, 토큰을 보낼 수 있음)\r\n     * @return until 잠겨있는 시간, UnixTimestamp\r\n     */\r\n    function isWalletLocked_Send(address _addr) public constant returns (bool isSendLocked, uint until) {\r\n        require(_addr != 0x0);\r\n        \r\n        isSendLocked = (lockedWalletInfo[_addr].timeLockUpEnd > now && lockedWalletInfo[_addr].sendLock == true);\r\n        \r\n        if(isSendLocked) {\r\n            until = lockedWalletInfo[_addr].timeLockUpEnd;\r\n        } else {\r\n            until = 0;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev 지갑의 입금 기능이 제한되어있는지 확인한다.\r\n     * @param _addr 입금 제한 여부를 확인하려는 지갑의 주소\r\n     * @return (true : 제한되어 있음, 토큰을 받을 수 없음) (false : 제한 없음, 토큰을 받을 수 있음)\r\n     */\r\n    function isWalletLocked_Receive(address _addr) public constant returns (bool isReceiveLocked, uint until) {\r\n        require(_addr != 0x0);\r\n        \r\n        isReceiveLocked = (lockedWalletInfo[_addr].timeLockUpEnd > now && lockedWalletInfo[_addr].receiveLock == true);\r\n        \r\n        if(isReceiveLocked) {\r\n            until = lockedWalletInfo[_addr].timeLockUpEnd;\r\n        } else {\r\n            until = 0;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev 요청자의 지갑에 송금 기능이 제한되어있는지 확인한다.\r\n     * @return (true : 제한되어 있음, 토큰을 보낼 수 없음) (false : 제한 없음, 토큰을 보낼 수 있음)\r\n     */\r\n    function isMyWalletLocked_Send() public constant returns (bool isSendLocked, uint until) {\r\n        return isWalletLocked_Send(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev 요청자의 지갑에 입금 기능이 제한되어있는지 확인한다.\r\n     * @return (true : 제한되어 있음, 토큰을 보낼 수 없음) (false : 제한 없음, 토큰을 보낼 수 있음)\r\n     */\r\n    function isMyWalletLocked_Receive() public constant returns (bool isReceiveLocked, uint until) {\r\n        return isWalletLocked_Receive(msg.sender);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 아피스 플랫폼에서 운영하는 스마트 컨트렉트 주소를 등록하거나 해제한다.\r\n     * @param manoAddr 마스터노드 스마트 컨트렉컨트렉트\r\n     * @param registered true : 등록, false : 해제\r\n     */\r\n    function registerManoContract(address manoAddr, bool registered) onlyOwner public {\r\n        manoContracts[manoAddr] = registered;\r\n        \r\n        ManoContractRegistered(manoAddr, registered);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev _to 지갑으로 _accaWei 만큼의 토큰을 송금한다.\r\n     * @param _to 토큰을 받는 지갑 주소\r\n     * @param _accaWei 전송되는 토큰의 양\r\n     */\r\n    function transfer(address _to, uint256 _accaWei) public returns (bool) {\r\n        // 자신에게 송금하는 것을 방지한다\r\n        require(_to != address(this));\r\n        \r\n        // 마스터노드 컨트렉트일 경우, APIS 송수신에 제한을 두지 않는다\r\n        if(manoContracts[msg.sender] || manoContracts[_to]) {\r\n            return super.transfer(_to, _accaWei);\r\n        }\r\n        \r\n        // 송금 기능이 잠긴 지갑인지 확인한다.\r\n        if(lockedWalletInfo[msg.sender].timeLockUpEnd > now && lockedWalletInfo[msg.sender].sendLock == true) {\r\n            RejectedPaymentFromLockedUpWallet(msg.sender, _to, _accaWei);\r\n            return false;\r\n        } \r\n        // 입금 받는 기능이 잠긴 지갑인지 확인한다\r\n        else if(lockedWalletInfo[_to].timeLockUpEnd > now && lockedWalletInfo[_to].receiveLock == true) {\r\n            RejectedPaymentToLockedUpWallet(msg.sender, _to, _accaWei);\r\n            return false;\r\n        } \r\n        // 제한이 없는 경우, 송금을 진행한다.\r\n        else {\r\n            return super.transfer(_to, _accaWei);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev _to 지갑으로 _accaWei 만큼의 ACCA를 송금하고 _timeLockUpEnd 시간만큼 지갑을 잠근다\r\n     * @param _to 토큰을 받는 지갑 주소\r\n     * @param _accaWei 전송되는 토큰의 양(wei)\r\n     * @param _timeLockUpEnd 잠금이 해제되는 시간\r\n     */\r\n    function transferAndLockUntil(address _to, uint256 _accaWei, uint _timeLockUpEnd) onlyOwner public {\r\n        require(transfer(_to, _accaWei));\r\n        \r\n        walletLockBoth(_to, _timeLockUpEnd);\r\n    }\r\n    \r\n    /**\r\n     * @dev _to 지갑으로 _accaWei 만큼의 APIS를 송금하고영원히 지갑을 잠근다\r\n     * @param _to 토큰을 받는 지갑 주소\r\n     * @param _accaWei 전송되는 토큰의 양(wei)\r\n     */\r\n    function transferAndLockForever(address _to, uint256 _accaWei) onlyOwner public {\r\n        require(transfer(_to, _accaWei));\r\n        \r\n        walletLockBothForever(_to);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 함수를 호출하는 지갑의 토큰을 소각한다.\r\n     * \r\n     * zeppelin-solidity/contracts/token/BurnableToken.sol 참조\r\n     * @param _value 소각하려는 토큰의 양(Satoshi)\r\n     */\r\n    function burn(uint256 _value) public {\r\n        require(_value <= balances[msg.sender]);\r\n        require(_value <= totalSupply);\r\n        \r\n        address burner = msg.sender;\r\n        balances[burner] -= _value;\r\n        totalSupply -= _value;\r\n        \r\n        Burn(burner, _value);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev Eth은 받을 수 없도록 한다.\r\n     */\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WhiteList\r\n * @dev ICO 참여가 가능한 화이트 리스트를 관리한다\r\n */\r\ncontract WhiteList is Ownable {\r\n    \r\n    mapping (address => uint8) internal list;\r\n    \r\n    /**\r\n     * @dev 화이트리스트에 변동이 발생했을 때 이벤트\r\n     * @param backer 화이트리스트에 등재하려는 지갑 주소\r\n     * @param allowed (true : 화이트리스트에 추가) (false : 제거)\r\n     */\r\n    event WhiteBacker(address indexed backer, bool allowed);\r\n    \r\n    \r\n    /**\r\n     * @dev 화이트리스트에 등록하거나 해제한다.\r\n     * @param _target 화이트리스트에 등재하려는 지갑 주소\r\n     * @param _allowed (true : 화이트리스트에 추가) (false : 제거) \r\n     */\r\n    function setWhiteBacker(address _target, bool _allowed) onlyOwner public {\r\n        require(_target != 0x0);\r\n        \r\n        if(_allowed == true) {\r\n            list[_target] = 1;\r\n        } else {\r\n            list[_target] = 0;\r\n        }\r\n        \r\n        WhiteBacker(_target, _allowed);\r\n    }\r\n    \r\n    /**\r\n     * @dev 화이트 리스트에 등록(추가)한다\r\n     * @param _target 추가할 지갑 주소\r\n     */\r\n    function addWhiteBacker(address _target) onlyOwner public {\r\n        setWhiteBacker(_target, true);\r\n    }\r\n    \r\n    /**\r\n     * @dev 화이트리스트에 여러 지갑 주소를 동시에 등재하거나 제거한다.\r\n     * \r\n     * 가스 소모를 줄여보기 위함\r\n     * @param _backers 대상이 되는 지갑들의 리스트\r\n     * @param _allows 대상이 되는 지갑들의 추가 여부 리스트 (true : 추가) (false : 제거)\r\n     */\r\n    function setWhiteBackersByList(address[] _backers, bool[] _allows) onlyOwner public {\r\n        require(_backers.length > 0);\r\n        require(_backers.length == _allows.length);\r\n        \r\n        for(uint backerIndex = 0; backerIndex < _backers.length; backerIndex++) {\r\n            setWhiteBacker(_backers[backerIndex], _allows[backerIndex]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev 화이트리스트에 여러 지갑 주소를 등재한다.\r\n     * \r\n     * 모든 주소들은 화이트리스트에 추가된다.\r\n     * @param _backers 대상이 되는 지갑들의 리스트\r\n     */\r\n    function addWhiteBackersByList(address[] _backers) onlyOwner public {\r\n        for(uint backerIndex = 0; backerIndex < _backers.length; backerIndex++) {\r\n            setWhiteBacker(_backers[backerIndex], true);\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 해당 지갑 주소가 화이트 리스트에 등록되어있는지 확인한다\r\n     * @param _addr 등재 여부를 확인하려는 지갑의 주소\r\n     * @return (true : 등록되어있음) (false : 등록되어있지 않음)\r\n     */\r\n    function isInWhiteList(address _addr) public constant returns (bool) {\r\n        require(_addr != 0x0);\r\n        return list[_addr] > 0;\r\n    }\r\n    \r\n    /**\r\n     * @dev 요청하는 지갑이 화이트리스트에 등록되어있는지 확인한다.\r\n     * @return (true : 등록되어있음) (false : 등록되어있지 않음)\r\n     */\r\n    function isMeInWhiteList() public constant returns (bool isWhiteBacker) {\r\n        return list[msg.sender] > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title APIS Crowd Pre-Sale\r\n * @dev 토큰의 프리세일을 수행하기 위한 컨트랙트\r\n */\r\ncontract ACCACrowdSale is Ownable {\r\n    \r\n    // 소수점 자리수. Eth 18자리에 맞춘다\r\n    uint8 public constant decimals = 18;\r\n    \r\n    \r\n    // 크라우드 세일의 판매 목표량(APIS)\r\n    uint256 public fundingGoal;\r\n    \r\n    // 현재 진행하는 판매 목표량 \r\n    // QTUM과 공동으로 판매가 진행되기 때문에,  QTUM 쪽 컨트렉트와 합산한 판매량이 총 판매목표를 넘지 않도록 하기 위함\r\n    uint256 public fundingGoalCurrent;\r\n    \r\n    // 1 ETH으로 살 수 있는 APIS의 갯수\r\n    uint256 public priceOfApisPerFund;\r\n    \r\n\r\n    // 발급된 Apis 갯수 (예약 + 발행)\r\n    //uint256 public totalSoldApis;\r\n    \r\n    // 발행 대기중인 APIS 갯수\r\n    //uint256 public totalReservedApis;\r\n    \r\n    // 발행되서 출금된 APIS 갯수\r\n    //uint256 public totalWithdrawedApis;\r\n    \r\n    \r\n    // 입금된 투자금의 총액 (예약 + 발행)\r\n    //uint256 public totalReceivedFunds;\r\n    \r\n    // 구매 확정 전 투자금의 총액\r\n    //uint256 public totalReservedFunds;\r\n    \r\n    // 구매 확정된 투자금의 총액\r\n    //uint256 public totalPaidFunds;\r\n\r\n    \r\n    // 판매가 시작되는 시간\r\n    uint public startTime;\r\n    \r\n    // 판매가 종료되는 시간\r\n    uint public endTime;\r\n\r\n    // 판매가 조기에 종료될 경우를 대비하기 위함\r\n    bool closed = false;\r\n    \r\n\tSaleStatus public saleStatus;\r\n    \r\n    // APIS 토큰 컨트렉트\r\n    ACCAToken internal tokenReward;\r\n    \r\n    // 화이트리스트 컨트렉트\r\n    WhiteList internal whiteList;\r\n\r\n    \r\n    \r\n    mapping (address => Property) public fundersProperty;\r\n    \r\n    /**\r\n     * @dev APIS 토큰 구매자의 자산 현황을 정리하기 위한 구조체\r\n     */\r\n    struct Property {\r\n        uint256 reservedFunds;   // 입금했지만 아직 APIS로 변환되지 않은 Eth (환불 가능)\r\n        uint256 paidFunds;    \t// APIS로 변환된 Eth (환불 불가)\r\n        uint256 reservedApis;   // 받을 예정인 토큰\r\n        uint256 withdrawedApis; // 이미 받은 토큰\r\n        uint purchaseTime;      // 구입한 시간\r\n    }\r\n\t\r\n\t\r\n\t/**\r\n\t * @dev 현재 세일의 진행 현황을 확인할 수 있다.\r\n\t * totalSoldApis 발급된 Apis 갯수 (예약 + 발행)\r\n\t * totalReservedApis 발행 대기 중인 Apis\r\n\t * totalWithdrawedApis 발행되서 출금된 APIS 갯수\r\n\t * \r\n\t * totalReceivedFunds 입금된 투자금의 총액 (예약 + 발행)\r\n\t * totalReservedFunds 구매 확정 전 투자금의 총액\r\n\t * ttotalPaidFunds 구매 확정된 투자금의 총액\r\n\t */\r\n\tstruct SaleStatus {\r\n\t\tuint256 totalReservedFunds;\r\n\t\tuint256 totalPaidFunds;\r\n\t\tuint256 totalReceivedFunds;\r\n\t\t\r\n\t\tuint256 totalReservedApis;\r\n\t\tuint256 totalWithdrawedApis;\r\n\t\tuint256 totalSoldApis;\r\n\t}\r\n    \r\n    \r\n    \r\n    /**\r\n     * @dev APIS를 구입하기 위한 Eth을 입금했을 때 발생하는 이벤트\r\n     * @param beneficiary APIS를 구매하고자 하는 지갑의 주소\r\n     * @param amountOfFunds 입금한 Eth의 양 (wei)\r\n     * @param amountOfApis 투자금에 상응하는 APIS 토큰의 양 (wei)\r\n     */\r\n    event ReservedApis(address beneficiary, uint256 amountOfFunds, uint256 amountOfApis);\r\n    \r\n    /**\r\n     * @dev 크라우드 세일 컨트렉트에서 Eth이 인출되었을 때 발생하는 이벤트\r\n     * @param addr 받는 지갑의 주소\r\n     * @param amount 송금되는 양(wei)\r\n     */\r\n    event WithdrawalFunds(address addr, uint256 amount);\r\n    \r\n    /**\r\n     * @dev 구매자에게 토큰이 발급되었을 때 발생하는 이벤트\r\n     * @param funder 토큰을 받는 지갑의 주소\r\n     * @param amountOfFunds 입금한 투자금의 양 (wei)\r\n     * @param amountOfApis 발급 받는 토큰의 양 (wei)\r\n     */\r\n    event WithdrawalApis(address funder, uint256 amountOfFunds, uint256 amountOfApis);\r\n    \r\n    \r\n    /**\r\n     * @dev 투자금 입금 후, 아직 토큰을 발급받지 않은 상태에서, 환불 처리를 했을 때 발생하는 이벤트\r\n     * @param _backer 환불 처리를 진행하는 지갑의 주소\r\n     * @param _amountFunds 환불하는 투자금의 양\r\n     * @param _amountApis 취소되는 APIS 양\r\n     */\r\n    event Refund(address _backer, uint256 _amountFunds, uint256 _amountApis);\r\n    \r\n    \r\n    /**\r\n     * @dev 크라우드 세일 진행 중에만 동작하도록 제한하고, APIS의 가격도 설정되어야만 한다.\r\n     */\r\n    modifier onSale() {\r\n        require(now >= startTime);\r\n        require(now < endTime);\r\n        require(closed == false);\r\n        require(priceOfApisPerFund > 0);\r\n        require(fundingGoalCurrent > 0);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev 크라우드 세일 종료 후에만 동작하도록 제한\r\n     */\r\n    modifier onFinished() {\r\n        require(now >= endTime || closed == true);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev 화이트리스트에 등록되어있어야하고 아직 구매완료 되지 않은 투자금이 있어야만 한다.\r\n     */\r\n    modifier claimable() {\r\n        require(whiteList.isInWhiteList(msg.sender) == true);\r\n        require(fundersProperty[msg.sender].reservedFunds > 0);\r\n        _;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 크라우드 세일 컨트렉트를 생성한다.\r\n     * @param _fundingGoalApis 판매하는 토큰의 양 (APIS 단위)\r\n     * @param _startTime 크라우드 세일을 시작하는 시간\r\n     * @param _endTime 크라우드 세일을 종료하는 시간\r\n     * @param _addressOfVilTokenUsedAsReward APIS 토큰의 컨트렉트 주소\r\n     * @param _addressOfWhiteList WhiteList 컨트렉트 주소\r\n     */\r\n    function ApisCrowdSale (\r\n        uint256 _fundingGoalApis,\r\n        uint _startTime,\r\n        uint _endTime,\r\n        address _addressOfVilTokenUsedAsReward,\r\n        address _addressOfWhiteList\r\n    ) public {\r\n        require (_fundingGoalApis > 0);\r\n        require (_startTime > now);\r\n        require (_endTime > _startTime);\r\n        require (_addressOfVilTokenUsedAsReward != 0x0);\r\n        require (_addressOfWhiteList != 0x0);\r\n        \r\n        fundingGoal = _fundingGoalApis * 10 ** uint256(decimals);\r\n        \r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        \r\n        // 토큰 스마트컨트렉트를 불러온다\r\n        tokenReward = ACCAToken(_addressOfVilTokenUsedAsReward);\r\n        \r\n        // 화이트 리스트를 가져온다\r\n        whiteList = WhiteList(_addressOfWhiteList);\r\n    }\r\n    \r\n    /**\r\n     * @dev 판매 종료는 1회만 가능하도록 제약한다. 종료 후 다시 판매 중으로 변경할 수 없다\r\n     */\r\n    function closeSale(bool _closed) onlyOwner public {\r\n        require (closed == false);\r\n        \r\n        closed = _closed;\r\n    }\r\n    \r\n    /**\r\n     * @dev 크라우드 세일 시작 전에 1Eth에 해당하는 APIS 량을 설정한다.\r\n     */\r\n    function setPriceOfApis(uint256 price) onlyOwner public {\r\n        require(priceOfApisPerFund == 0);\r\n        \r\n        priceOfApisPerFund = price;\r\n    }\r\n    \r\n    /**\r\n     * @dev 현 시점에서 판매 가능한 목표량을 수정한다.\r\n     * @param _currentFundingGoalAPIS 현 시점의 판매 목표량은 총 판매된 양 이상이어야만 한다.\r\n     */\r\n    function setCurrentFundingGoal(uint256 _currentFundingGoalAPIS) onlyOwner public {\r\n        uint256 fundingGoalCurrentWei = _currentFundingGoalAPIS * 10 ** uint256(decimals);\r\n        require(fundingGoalCurrentWei >= saleStatus.totalSoldApis);\r\n        \r\n        fundingGoalCurrent = fundingGoalCurrentWei;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev APIS 잔고를 확인한다\r\n     * @param _addr 잔고를 확인하려는 지갑의 주소\r\n     * @return balance 지갑에 들은 APIS 잔고 (wei)\r\n     */\r\n    function balanceOf(address _addr) public view returns (uint256 balance) {\r\n        return tokenReward.balanceOf(_addr);\r\n    }\r\n    \r\n    /**\r\n     * @dev 화이트리스트 등록 여부를 확인한다\r\n     * @param _addr 등록 여부를 확인하려는 주소\r\n     * @return addrIsInWhiteList true : 등록되있음, false : 등록되어있지 않음\r\n     */\r\n    function whiteListOf(address _addr) public view returns (string message) {\r\n        if(whiteList.isInWhiteList(_addr) == true) {\r\n            return \"The address is in whitelist.\";\r\n        } else {\r\n            return \"The address is *NOT* in whitelist.\";\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 전달받은 지갑이 APIS 지급 요청이 가능한지 확인한다.\r\n     * @param _addr 확인하는 주소\r\n     * @return message 결과 메시지\r\n     */\r\n    function isClaimable(address _addr) public view returns (string message) {\r\n        if(fundersProperty[_addr].reservedFunds == 0) {\r\n            return \"The address has no claimable balance.\";\r\n        }\r\n        \r\n        if(whiteList.isInWhiteList(_addr) == false) {\r\n            return \"The address must be registered with KYC and Whitelist\";\r\n        }\r\n        \r\n        else {\r\n            return \"The address can claim APIS!\";\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 크라우드 세일 컨트렉트로 바로 투자금을 송금하는 경우, buyToken으로 연결한다\r\n     */\r\n    function () onSale public payable {\r\n        buyToken(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev 토큰을 구입하기 위해 Qtum을 입금받는다.\r\n     * @param _beneficiary 토큰을 받게 될 지갑의 주소\r\n     */\r\n    function buyToken(address _beneficiary) onSale public payable {\r\n        // 주소 확인\r\n        require(_beneficiary != 0x0);\r\n        \r\n        // 크라우드 세일 컨트렉트의 토큰 송금 기능이 정지되어있으면 판매하지 않는다\r\n        bool isLocked = false;\r\n        uint timeLock = 0;\r\n        (isLocked, timeLock) = tokenReward.isWalletLocked_Send(this);\r\n        \r\n        require(isLocked == false);\r\n        \r\n        \r\n        uint256 amountFunds = msg.value;\r\n        uint256 reservedApis = amountFunds * priceOfApisPerFund;\r\n        \r\n        \r\n        // 목표 금액을 넘어서지 못하도록 한다\r\n        require(saleStatus.totalSoldApis + reservedApis <= fundingGoalCurrent);\r\n        require(saleStatus.totalSoldApis + reservedApis <= fundingGoal);\r\n        \r\n        // 투자자의 자산을 업데이트한다\r\n        fundersProperty[_beneficiary].reservedFunds += amountFunds;\r\n        fundersProperty[_beneficiary].reservedApis += reservedApis;\r\n        fundersProperty[_beneficiary].purchaseTime = now;\r\n        \r\n        // 총액들을 업데이트한다\r\n        saleStatus.totalReceivedFunds += amountFunds;\r\n        saleStatus.totalReservedFunds += amountFunds;\r\n        \r\n        saleStatus.totalSoldApis += reservedApis;\r\n        saleStatus.totalReservedApis += reservedApis;\r\n        \r\n        \r\n        // 화이트리스트에 등록되어있으면 바로 출금한다\r\n        if(whiteList.isInWhiteList(_beneficiary) == true) {\r\n            withdrawal(_beneficiary);\r\n        }\r\n        else {\r\n            // 토큰 발행 예약 이벤트 발생\r\n            ReservedApis(_beneficiary, amountFunds, reservedApis);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * @dev 관리자에 의해서 토큰을 발급한다. 하지만 기본 요건은 갖춰야만 가능하다\r\n     * \r\n     * @param _target 토큰 발급을 청구하려는 지갑 주소\r\n     */\r\n    function claimApis(address _target) public {\r\n        // 화이트 리스트에 있어야만 하고\r\n        require(whiteList.isInWhiteList(_target) == true);\r\n        // 예약된 투자금이 있어야만 한다.\r\n        require(fundersProperty[_target].reservedFunds > 0);\r\n        \r\n        withdrawal(_target);\r\n    }\r\n    \r\n    /**\r\n     * @dev 예약한 토큰의 실제 지급을 요청하도록 한다.\r\n     * \r\n     * APIS를 구매하기 위해 Qtum을 입금할 경우, 관리자의 검토를 위한 7일의 유예기간이 존재한다.\r\n     * 유예기간이 지나면 토큰 지급을 요구할 수 있다.\r\n     */\r\n    function claimMyApis() claimable public {\r\n        withdrawal(msg.sender);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 구매자에게 토큰을 지급한다.\r\n     * @param funder 토큰을 지급할 지갑의 주소\r\n     */\r\n    function withdrawal(address funder) internal {\r\n        // 구매자 지갑으로 토큰을 전달한다\r\n        assert(tokenReward.transferFrom(owner, funder, fundersProperty[funder].reservedApis));\r\n        \r\n        fundersProperty[funder].withdrawedApis += fundersProperty[funder].reservedApis;\r\n        fundersProperty[funder].paidFunds += fundersProperty[funder].reservedFunds;\r\n        \r\n        // 총액에 반영\r\n        saleStatus.totalReservedFunds -= fundersProperty[funder].reservedFunds;\r\n        saleStatus.totalPaidFunds += fundersProperty[funder].reservedFunds;\r\n        \r\n        saleStatus.totalReservedApis -= fundersProperty[funder].reservedApis;\r\n        saleStatus.totalWithdrawedApis += fundersProperty[funder].reservedApis;\r\n        \r\n        // APIS가 출금 되었음을 알리는 이벤트\r\n        WithdrawalApis(funder, fundersProperty[funder].reservedFunds, fundersProperty[funder].reservedApis);\r\n        \r\n        // 인출하지 않은 APIS 잔고를 0으로 변경해서, Qtum 재입금 시 이미 출금한 토큰이 다시 출금되지 않게 한다.\r\n        fundersProperty[funder].reservedFunds = 0;\r\n        fundersProperty[funder].reservedApis = 0;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 아직 토큰을 발급받지 않은 지갑을 대상으로, 환불을 진행할 수 있다.\r\n     * @param _funder 환불을 진행하려는 지갑의 주소\r\n     */\r\n    function refundByOwner(address _funder) onlyOwner public {\r\n        require(fundersProperty[_funder].reservedFunds > 0);\r\n        \r\n        uint256 amountFunds = fundersProperty[_funder].reservedFunds;\r\n        uint256 amountApis = fundersProperty[_funder].reservedApis;\r\n        \r\n        // Eth을 환불한다\r\n        _funder.transfer(amountFunds);\r\n        \r\n        saleStatus.totalReceivedFunds -= amountFunds;\r\n        saleStatus.totalReservedFunds -= amountFunds;\r\n        \r\n        saleStatus.totalSoldApis -= amountApis;\r\n        saleStatus.totalReservedApis -= amountApis;\r\n        \r\n        fundersProperty[_funder].reservedFunds = 0;\r\n        fundersProperty[_funder].reservedApis = 0;\r\n        \r\n        Refund(_funder, amountFunds, amountApis);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev 펀딩이 종료된 이후면, 적립된 투자금을 반환한다.\r\n     * @param remainRefundable true : 환불할 수 있는 금액은 남기고 반환한다. false : 모두 반환한다\r\n     */\r\n    function withdrawalFunds(bool remainRefundable) onlyOwner public {\r\n        require(now > endTime || closed == true);\r\n        \r\n        uint256 amount = 0;\r\n        if(remainRefundable) {\r\n            amount = this.balance - saleStatus.totalReservedFunds;\r\n        } else {\r\n            amount = this.balance;\r\n        }\r\n        \r\n        if(amount > 0) {\r\n            msg.sender.transfer(amount);\r\n            \r\n            WithdrawalFunds(msg.sender, amount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n\t * @dev 크라우드 세일이 진행 중인지 여부를 반환한다.\r\n\t * @return isOpened true: 진행 중 false : 진행 중이 아님(참여 불가)\r\n\t */\r\n    function isOpened() public view returns (bool isOpend) {\r\n        if(now < startTime) return false;\r\n        if(now >= endTime) return false;\r\n        if(closed == true) return false;\r\n        \r\n        return true;\r\n    }\r\n}"}}}