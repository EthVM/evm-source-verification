{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Governace/govResolver.sol": {
      "content": "pragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\ninterface GoveranceInterface {\n\n       struct Proposal {\n        uint id;\n        address proposer;\n        uint eta;\n        uint startBlock;\n        uint endBlock;\n        uint forVotes;\n        uint againstVotes;\n        bool canceled;\n        bool executed;\n    }\n\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint96 votes;\n    }\n\n     enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    function proposals(uint) external view returns (Proposal memory);\n    function proposalCount() external view returns (uint);\n\n    function state(uint) external view returns (ProposalState);\n\n    function quorumVotes() external view returns (uint) ;\n    function getProposalThreshold() external view returns (uint);\n    function proposalMaxOperations() external pure returns (uint);\n    function getVotingDelay() external view returns (uint);\n    function getVotingPeriod() external view returns (uint);\n}\n\n\ncontract Resolver {\n    struct ProposalState {\n        uint forVotes;\n        uint againstVotes;\n        bool isFailed;\n        bool isEnded;\n        GoveranceInterface.ProposalState currentState;\n    }\n\n    function getProposalStates(address govAddr, uint256[] memory ids) public view returns (ProposalState[] memory) {\n        ProposalState[] memory proposalStates = new ProposalState[](ids.length);\n        GoveranceInterface govContract = GoveranceInterface(govAddr);\n        for (uint i = 0; i < ids.length; i++) {\n            uint id = ids[i];\n            GoveranceInterface.Proposal memory proposal = govContract.proposals(id);\n            bool isEnded = proposal.endBlock <= block.number;\n            bool isFailed = proposal.forVotes <= proposal.againstVotes || proposal.forVotes < govContract.quorumVotes();\n            proposalStates[i] = ProposalState({\n                forVotes: proposal.forVotes,\n                againstVotes: proposal.againstVotes,\n                isFailed: isEnded && isFailed,\n                isEnded: isEnded,\n                currentState: govContract.state(id)\n            });\n        }\n        return proposalStates;\n    }\n}\n\ncontract AtlasGovResolver is Resolver {\n\n    string public constant name = \"Atlas-Governance-Resolver-v1.0\";\n    \n}"
    }
  }
}