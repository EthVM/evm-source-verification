{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SimpleSale.sol": {
      "content": "// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/simple.sol\npragma solidity >0.4.13 >=0.4.23 >=0.6.0 >=0.6.7 <0.7.0;\n\n////// lib/ds-auth/src/auth.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n////// lib/ds-math/src/math.sol\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >0.4.13; */\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n////// lib/ds-token/src/token.sol\n/// token.sol -- ERC20 implementation with minting and burning\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\n/* import \"ds-math/math.sol\"; */\n/* import \"ds-auth/auth.sol\"; */\n\n\ncontract DSToken is DSMath, DSAuth {\n    bool                                              public  stopped;\n    uint256                                           public  totalSupply;\n    mapping (address => uint256)                      public  balanceOf;\n    mapping (address => mapping (address => uint256)) public  allowance;\n    bytes32                                           public  symbol;\n    uint256                                           public  decimals = 18; // standard token precision. override to customize\n    bytes32                                           public  name = \"\";     // Optional token name\n\n    constructor(bytes32 symbol_) public {\n        symbol = symbol_;\n    }\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n    event Mint(address indexed guy, uint wad);\n    event Burn(address indexed guy, uint wad);\n    event Stop();\n    event Start();\n\n    modifier stoppable {\n        require(!stopped, \"ds-stop-is-stopped\");\n        _;\n    }\n\n    function approve(address guy) external returns (bool) {\n        return approve(guy, uint(-1));\n    }\n\n    function approve(address guy, uint wad) public stoppable returns (bool) {\n        allowance[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        stoppable\n        returns (bool)\n    {\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        }\n\n        require(balanceOf[src] >= wad, \"ds-token-insufficient-balance\");\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function push(address dst, uint wad) external {\n        transferFrom(msg.sender, dst, wad);\n    }\n\n    function pull(address src, uint wad) external {\n        transferFrom(src, msg.sender, wad);\n    }\n\n    function move(address src, address dst, uint wad) external {\n        transferFrom(src, dst, wad);\n    }\n\n\n    function mint(uint wad) external {\n        mint(msg.sender, wad);\n    }\n\n    function burn(uint wad) external {\n        burn(msg.sender, wad);\n    }\n\n    function mint(address guy, uint wad) public auth stoppable {\n        balanceOf[guy] = add(balanceOf[guy], wad);\n        totalSupply = add(totalSupply, wad);\n        emit Mint(guy, wad);\n    }\n\n    function burn(address guy, uint wad) public auth stoppable {\n        if (guy != msg.sender && allowance[guy][msg.sender] != uint(-1)) {\n            require(allowance[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\n        }\n\n        require(balanceOf[guy] >= wad, \"ds-token-insufficient-balance\");\n        balanceOf[guy] = sub(balanceOf[guy], wad);\n        totalSupply = sub(totalSupply, wad);\n        emit Burn(guy, wad);\n    }\n\n    function stop() public auth {\n        stopped = true;\n        emit Stop();\n    }\n\n    function start() public auth {\n        stopped = false;\n        emit Start();\n    }\n\n    function setName(bytes32 name_) external auth {\n        name = name_;\n    }\n}\n\n////// src/transferhelper.sol\n/* pragma solidity >=0.6.0; */\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n////// src/simple.sol\n/* pragma solidity ^0.6.7; */\n\n/* import \"ds-token/token.sol\"; */\n/* import \"ds-auth/auth.sol\"; */\n/* import \"./transferhelper.sol\"; */\n\ncontract SimpleSale is DSAuth, DSMath\n{\n    mapping(address => uint) internal _tkn_sale_quantity;\n    address public _default;\n    \n    // uint[2]{price, total_quantity}\n    mapping(address => uint[2]) internal _tkn_sale_params;\n    mapping(address => address) internal _tkn_owners;\n    mapping(address => bool) public _tkn_open;\n    mapping(address => uint) public balances;\n\n    event SetSaleParams(address indexed token, address owner, uint price, uint quantity);\n    event CrowdSell(address indexed token, uint price, uint volume, address user);\n    event SetTokenOpen(address indexed token, bool open);\n    event Claim(address indexed receiver, uint amount);\n\n    modifier tokenExists(address token)\n    {\n        require(_tkn_owners[token] != address(0x00), \"the token not exists!\");\n        _;\n    }\n\n    modifier tokenOpen(address token)\n    {\n        require(_tkn_open[token], \"the token is not open for sale!\");\n        _;\n    }\n\n    constructor() DSAuth() payable public \n    {\n\n    }\n\n    receive() payable external\n    {\n        crowdsell(_default);\n    }\n\n    function claim(uint amount) public \n    {\n        require(balances[msg.sender] > 0 && balances[msg.sender] >= amount, \"The balance is insufficient.\");\n        \n        balances[msg.sender] = sub(balances[msg.sender], amount);\n        TransferHelper.safeTransferETH(msg.sender,amount);\n        \n        emit Claim(msg.sender, amount);\n    }\n\n    function crowdsell(address token) public payable tokenExists(token) tokenOpen(token)\n    {\n        sell(token, msg.value, msg.sender);\n        emit CrowdSell(token, _tkn_sale_params[token][0], msg.value, msg.sender);\n    }\n\n    function sell(address token, uint msgValue, address msgSender) private\n    {\n        require(_tkn_owners[token] != address(0x00) && _tkn_sale_params[token][0] > 0, \"Not yet started, stay tuned.\");\n        address tokenOwner = _tkn_owners[token];\n        uint price = _tkn_sale_params[token][0];\n        uint total_quantity = _tkn_sale_params[token][1];\n        uint amount = wmul(msgValue, price);\n\n        require(add(_tkn_sale_quantity[token],amount) <= total_quantity, \"sold out!\");\n        require(DSToken(token).allowance(tokenOwner, address(this)) >= amount, \"reach to uplimit of allowance.\");\n        TransferHelper.safeTransferFrom(token,tokenOwner, msgSender, amount);\n        _tkn_sale_quantity[token] = add(_tkn_sale_quantity[token], amount);\n        balances[tokenOwner] = add(balances[tokenOwner], msgValue);\n    }\n\n    function setSaleParams(address token, address owner, uint[2] memory price_uplimit, bool isDefault) public auth{\n        require(token != address(0x00), \"incorrect token address.\");\n        require(owner != address(0x00), \"incorrect token owner.\");\n        \n        if(_tkn_owners[token] == address(0x00))\n        {\n            _tkn_owners[token] = owner;\n        }\n        if(isDefault)\n        {\n            _default = token;\n        }\n        \n        require(price_uplimit.length == 2 && price_uplimit[0] > 0 && price_uplimit[1] > 0, \"They must be correct(price, sale quantity).\");\n        \n        require(DSToken(token).allowance(owner, address(this)) >= price_uplimit[1], \"makesure allowance enough!\");\n        _tkn_sale_params[token] = price_uplimit;\n        \n        emit SetSaleParams(token, owner, price_uplimit[0], price_uplimit[1]);\n    }\n\n    function setTokenOpen(address token, bool isOpen) public auth tokenExists(token)\n    {\n        _tkn_open[token] = isOpen;\n        emit SetTokenOpen(token, isOpen);\n    }\n\n    function getSaleParams(address token) public view returns (uint[2] memory)\n    {\n        return _tkn_sale_params[token];\n    }\n\n    function getTokenOwner(address token) public view returns (address)\n    {\n        return _tkn_owners[token];\n    }\n\n    function getSaleQuantity(address token) public view returns (uint)\n    {\n        return _tkn_sale_quantity[token];\n    }\n\n}\n"
    }
  }
}