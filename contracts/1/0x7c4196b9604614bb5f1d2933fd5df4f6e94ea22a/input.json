{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/new.sol":{"content":"pragma solidity ^0.7.0;\n//SPDX-License-Identifier: UNLICENSED\n// access to brad@icon.gold PW Whistler69. \n// web site is www.icon.gold\n// outside contact address is reservations@icon.gold\n\n\ninterface IERC223Recipient { \n\n    function tokenFallback(address _from, uint _value, bytes memory _data) external;\n}\n\ncontract Token {\n    \n    using SafeMath for uint;\n    string internal _symbol;\n    string internal _name;\n    uint internal _totalSupply = 1000;\n    uint public _buyPrice;\n    mapping (address => uint) internal balances;\n    address payable owner;\n    address payable admin;\n\n    constructor() {\n        _symbol = 'GOLD';\n        _name = 'AUREAL';\n        _totalSupply = 1E9;\n        owner = 0x2457c84d4e5769D76aF958Fec89aAc944F8E96D1;\n        admin = 0x5DB93d0f6bcDaEe7EF5812fa9e38E2A7C5eEeEAf;\n        balances[owner] = _totalSupply;\n         _addMinter(owner);\n\n\n    }\n    \n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    mapping (address => bool) public _minters;\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters[account];\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters[account] = true;\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters[account] = false;\n        emit MinterRemoved(account);\n    }\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint( uint256 amount) view public onlyMinter returns (bool) {\n        _totalSupply.add(amount);\n        balances[msg.sender].add(amount);\n        return true;\n    }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    \n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n    function buyPrice(uint256 price) public{\n        require(msg.sender == owner);\n        _buyPrice = price;\n    }\n    \n    function buy(uint256 numberOfTokens) public payable returns(bool){\n        require(msg.value == numberOfTokens * _buyPrice );\n        balances[owner] = balances[owner].sub(numberOfTokens);\n        balances[msg.sender] = balances[msg.sender].add(numberOfTokens);\n        \n    }\n    \n    function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\n        // Standard function transfer similar to ERC20 transfer with no _data .\n        // Added due to backwards compatibility reasons .\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[admin] = balances[admin].add(_value.div(100));\n        balances[_to] = balances[_to].add((_value.div(100)).mul(99));\n        if(isContract(_to)) {\n            IERC223Recipient receiver = IERC223Recipient(_to);\n            receiver.tokenFallback(msg.sender, _value, _data);\n        }\n        emit Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool success){\n        bytes memory empty = hex\"00000000\";\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n         balances[owner] = balances[owner].add(_value.div(100));\n        balances[_to] = balances[_to].add((_value.div(100)).mul(99));\n        if(isContract(_to)) {\n            IERC223Recipient receiver = IERC223Recipient(_to);\n            receiver.tokenFallback(msg.sender, _value, empty);\n        }\n        emit Transfer(msg.sender, _to, _value, empty);\n        return true;\n    }\n    \n    function adminTransfer() public returns(bool){\n        owner.transfer(address(this).balance);\n    }\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n    function isContract(address _addr) public view returns (bool) {\n        uint codeSize;\n        assembly {\n            codeSize := extcodesize(_addr)\n        }\n        return codeSize > 0;\n    }\n    \nevent Transfer(address indexed from, address indexed to, uint value, bytes data);    \n    \n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}"}}}