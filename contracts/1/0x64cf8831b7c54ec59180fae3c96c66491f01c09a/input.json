{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "NFT1155MarketProxy.sol": {
      "content": "/***\r\n *    ██████╗ ███████╗ ██████╗  ██████╗ \r\n *    ██╔══██╗██╔════╝██╔════╝ ██╔═══██╗\r\n *    ██║  ██║█████╗  ██║  ███╗██║   ██║\r\n *    ██║  ██║██╔══╝  ██║   ██║██║   ██║\r\n *    ██████╔╝███████╗╚██████╔╝╚██████╔╝\r\n *    ╚═════╝ ╚══════╝ ╚═════╝  ╚═════╝ \r\n *    \r\n * https://dego.finance\r\n                                  \r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2020 dego\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/// File: contracts/proxy/Proxy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract Proxy {\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n\r\n    function _implementation() internal view returns (address);\r\n\r\n    function _delegate(address implementation) internal {\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            let result := delegatecall(\r\n                gas,\r\n                implementation,\r\n                0,\r\n                calldatasize,\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n\r\n    function _willFallback() internal {}\r\n\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n\r\n// File: contracts/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\nlibrary AddressUtils {\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract UpgradeabilityProxy is Proxy {\r\n    event Upgraded(address implementation);\r\n\r\n    bytes32\r\n        private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n    constructor(address _implementation) public {\r\n        assert(\r\n            IMPLEMENTATION_SLOT ==\r\n                keccak256(\"org.zeppelinos.proxy.implementation\")\r\n        );\r\n\r\n        _setImplementation(_implementation);\r\n    }\r\n\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    function _setImplementation(address newImplementation) private {\r\n        require(\r\n            AddressUtils.isContract(newImplementation),\r\n            \"Cannot set a proxy implementation to a non-contract address\"\r\n        );\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/proxy/AdminUpgradeabilityProxy.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n    event AdminUpdated(address newAdmin);\r\n\r\n    bytes32\r\n        private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n    bytes32\r\n        private constant PENDING_ADMIN_SLOT = 0x54ac2bd5363dfe95a011c5b5a153968d77d153d212e900afce8624fdad74525c;\r\n\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    constructor(address _implementation)\r\n        public\r\n        UpgradeabilityProxy(_implementation)\r\n    {\r\n        assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n\r\n        _setAdmin(msg.sender);\r\n    }\r\n\r\n    function admin() external  ifAdmin returns (address) {\r\n        return _admin();\r\n    }\r\n\r\n    function pendingAdmin() external ifAdmin returns (address) {\r\n        return _pendingAdmin();\r\n    }\r\n\r\n    function implementation() external ifAdmin returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    function changeAdmin(address _newAdmin) external ifAdmin {\r\n        require(\r\n            _newAdmin != address(0),\r\n            \"Cannot change the admin of a proxy to the zero address\"\r\n        );\r\n        require(\r\n            _newAdmin != _admin(),\r\n            \"The current and new admin cannot be the same .\"\r\n        );\r\n        require(\r\n            _newAdmin != _pendingAdmin(),\r\n            \"Cannot set the newAdmin of a proxy to the same address .\"\r\n        );\r\n        _setPendingAdmin(_newAdmin);\r\n        emit AdminChanged(_admin(), _newAdmin);\r\n    }\r\n\r\n    function updateAdmin() external {\r\n        address _newAdmin = _pendingAdmin();\r\n        require(\r\n            _newAdmin != address(0),\r\n            \"Cannot change the admin of a proxy to the zero address\"\r\n        );\r\n        require(\r\n            msg.sender == _newAdmin,\r\n            \"msg.sender and newAdmin must be the same .\"\r\n        );\r\n        _setAdmin(_newAdmin);\r\n        _setPendingAdmin(address(0));\r\n        emit AdminUpdated(_newAdmin);\r\n    }\r\n\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        external\r\n        payable\r\n        ifAdmin\r\n    {\r\n        _upgradeTo(newImplementation);\r\n        (bool success, ) = address(this).call.value(msg.value)(data);\r\n        require(success, \"upgradeToAndCall-error\");\r\n    }\r\n\r\n    function _admin() internal view returns (address adm) {\r\n        bytes32 slot = ADMIN_SLOT;\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    function _pendingAdmin() internal view returns (address pendingAdm) {\r\n        bytes32 slot = PENDING_ADMIN_SLOT;\r\n        assembly {\r\n            pendingAdm := sload(slot)\r\n        }\r\n    }\r\n\r\n    function _setAdmin(address newAdmin) internal {\r\n        bytes32 slot = ADMIN_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n\r\n    function _setPendingAdmin(address pendingAdm) internal {\r\n        bytes32 slot = PENDING_ADMIN_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, pendingAdm)\r\n        }\r\n    }\r\n\r\n    function _willFallback() internal {\r\n        require(\r\n            msg.sender != _admin(),\r\n            \"Cannot call fallback function from the proxy admin\"\r\n        );\r\n        super._willFallback();\r\n    }\r\n}\r\n\r\n// File: contracts/market/NFT1155MarketProxy.sol\r\n\r\npragma solidity ^0.5.5;\r\n\r\n\r\ncontract NFT1155MarketProxy is AdminUpgradeabilityProxy {\r\n    constructor(address _implementation)\r\n        public\r\n        AdminUpgradeabilityProxy(_implementation)\r\n    {}\r\n\r\n    // Allow anyone to view the implementation address\r\n    function proxyImplementation() external view returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    function proxyAdmin() external view returns (address) {\r\n        return _admin();\r\n    }\r\n}"
    }
  }
}