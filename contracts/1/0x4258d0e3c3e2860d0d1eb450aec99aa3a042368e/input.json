{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"marketplace.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n  \r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\ninterface IMarket{\r\n\r\n function withdrawNFT(uint itemId)external;\r\nfunction addtoMarket(address nftContract,address owner, uint tokenId,uint price) external;\r\nfunction buyNFT(uint itemId, address newOwner)payable external;\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n   \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    \r\n    \r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n   \r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n   \r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n  \r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n  \r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n   \r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    \r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n   \r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\ninterface IERC721Metadata is IERC721 {\r\n    \r\n    function name() external view returns (string memory);\r\n\r\n    \r\n    function symbol() external view returns (string memory);\r\n\r\n    \r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\ninterface IERC721Receiver {\r\n   \r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ncontract ZikopikaMarketPlace is IERC721Receiver,IMarket{\r\n    struct Item{\r\n        uint _id;\r\n        address _nftContract;\r\n        address _owner; \r\n        uint _tokenId;\r\n        uint _currentPrice;\r\n        uint _offer;\r\n    }\r\naddress _owner;\r\n    uint itemCounter;\r\n    mapping(uint=>Item)public idToItem ;\r\n\r\n    //events\r\n    event NFT_Listed(address _nftContract, address _owner,uint _tokenId, uint _itemId,uint _price);\r\nevent NFT_Purchased(address _nftContract, address _exOwner,address _newOwner,uint indexed _tokenId, uint _itemId,uint _price);\r\nevent NFT_Withdraw(address _nftContract, address _exOwner,uint indexed _tokenId, uint _itemId);\r\n\r\n\r\nconstructor() {\r\n        \r\n        _owner= msg.sender;\r\n        \r\n    }\r\n/* called by NFT contract to verify that its transferred to contract*/\r\n\r\n    function onERC721Received(\r\n        address operator, address from,uint256 tokenId,bytes calldata data) override external virtual returns (bytes4){\r\n//- some logic\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n    function addtoMarket(address nftContract,\r\n    address owner, uint tokenId,uint price)override public{\r\nIERC721(nftContract).transferFrom(msg.sender,address(this),tokenId);\r\n\r\n        Item memory item =Item(itemCounter,nftContract,owner,tokenId,price,0);\r\n        idToItem[itemCounter]=item;\r\n        itemCounter++;\r\n            emit NFT_Listed(nftContract, owner,tokenId, itemCounter++, price);\r\n\r\n    }\r\n    function buyNFT(uint itemId, address newOwner)override payable public{\r\n        Item memory item= idToItem[itemId];\r\n   //     require (item._currentPrice==msg.value,\"Insufficient amount transferred\");\r\n\r\nIERC721(item._nftContract).transferFrom(address(this),newOwner,item._tokenId);// transfer tokenId\r\ndelete idToItem[itemId];\r\nemit NFT_Purchased(item._nftContract, item._owner,newOwner,item._tokenId, itemId, item._currentPrice);\r\n\r\n\r\n       \r\n    }\r\n   \r\n\r\n\r\n\r\n\r\n       \r\n  \r\n/*withdraw NFT */\r\nfunction withdrawNFT(uint itemId) override public{\r\n        Item memory item= idToItem[itemId];\r\n        require (item._owner==msg.sender,\"Only  owner can withdraw NFT\");\r\n\r\nIERC721(item._nftContract).transferFrom(address(this),item._owner,item._tokenId);// transfer tokenId\r\ndelete idToItem[itemId];\r\nemit NFT_Withdraw(item._nftContract, item._owner, item._tokenId, itemId);\r\n\r\n\r\n       \r\n    }\r\n function viewNFT(uint  itemId) view public returns(address _nftConract,uint _tokenId,string memory _tokenUri){\r\n        Item memory item =idToItem[itemId];\r\n        string memory uri=IERC721Metadata(item._nftContract).tokenURI(item._tokenId);\r\n        return(item._nftContract,item._tokenId,uri);\r\n    }\r\n    function withdrawFunds()public {\r\n        require(msg.sender==_owner,\"only contract owner can withdraw funds\");\r\n        uint balance= address(this).balance;\r\n        payable(_owner).transfer(balance);\r\n    }\r\n\r\n}"}}}