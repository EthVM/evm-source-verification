{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/MiningPool.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-06-29\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address, address) external;\n    \n    function setFeeOwner(address _feeOwner) external;\n}\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        \n        \n        \n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        \n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        \n\n        return c;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Context {\n    \n    \n    constructor () { }\n    \n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; \n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    \n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    \n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function nonces(address account) external view returns (uint256);\n\n    function approve(address spender, uint value) external returns (bool);\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, uint256 amount, uint8 v, bytes32 r, bytes32 s) external;\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IUniswapFactory {\n    function getPair(address token0,address token1) external returns(address);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n    function balanceOf(address owner) external view returns (uint);\n}\n\n\ncontract MiningPool is Ownable {\n    \n    constructor(IERC20 _token, IUniswapFactory _factory, uint256 chainId_, IWETH _weth ) {\n        // tokens[0] = tokenAddress;\n        // tokens[1] = wethAddress;\n        token = _token;\n        factory = _factory;\n        weth = _weth;\n        ANCHOR = duration(0,block.timestamp).mul(ONE_DAY);\n        \n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(\"MiningPool\"),\n            keccak256(bytes(version)),\n            chainId_,\n            address(this)\n        ));\n    }\n    \n    receive() external payable {\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\n    }\n\n    using SafeMath for uint256;\n  \n    struct User {\n        uint256 id;\n        uint256 investment;\n        uint256 freezeTime;\n    }\n    \n    string  public constant version  = \"1\";\n    \n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Lock(address holder,address locker,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x21cd9aa44f4218d88de398865e90b6302b1c68dbeecba1ed08e507cb29ef9d6f;\n\n    uint256 constant internal ONE_DAY = 1 days;\n    \n    uint256 public ANCHOR;\n    \n    IERC20 public token;\n    \n    IWETH public weth;\n    \n    //address[2] tokens;\n    IUniswapV2Pair public pair;\n    \n    IUniswapFactory public factory;\n    \n    uint256 public stakeAmount;\n    \n    mapping(address=>User) public users;\n    //Index of the user\n    mapping(uint256=>address) public indexs;\n    \n    mapping(address => uint256[2]) public deposits;\n    \n    mapping (address => uint) public _nonces;\n    \n    uint256 public userCounter;\n    \n    event Stake(address indexed userAddress,uint256 amount);\n    \n    event WithdrawCapital(address indexed userAddress,uint256 amount);\n    \n    event Deposit(address indexed userAddress,uint256[2]);\n    \n    event Allot(address indexed userAddress,uint256,uint256);\n    \n    event Lock(address indexed userAddress,uint256 amount);\n    \n    function setPair(address tokenA,address tokenB) public onlyOwner returns(address pairAddress){\n        pairAddress = factory.getPair(tokenA,tokenB);\n        //require(pairAddress!=address(0),\"Invalid trade pair\");\n        pair = IUniswapV2Pair(pairAddress);\n    }\n    \n    function deposit(uint256[2] memory amounts) public returns(bool){\n        (address[2] memory tokens,) = balanceOf(address(this));\n        for(uint8 i = 0;i<amounts.length;i++){\n            if(amounts[i]>0) TransferHelper.safeTransferFrom(tokens[i],msg.sender,address(this),amounts[i]);\n            deposits[msg.sender][i] += amounts[i];\n        }\n        emit Deposit(msg.sender,amounts);\n        \n        return true;\n    }\n    \n    function allot(address userAddress,uint256[2] memory amounts) public returns(bool){\n        (address[2] memory tokens,) = balanceOf(address(this));\n        \n        if(amounts[0]>0) _transfer(tokens[0],userAddress,amounts[0]);\n        if(amounts[1]>0) _transfer(tokens[1],userAddress,amounts[1]);\n      \n        for(uint8 i = 0;i<amounts.length;i++){\n            require(deposits[msg.sender][i]>=amounts[i],\"not sufficient funds\");\n            deposits[msg.sender][i]-=amounts[i];\n        }\n        \n        emit Allot(userAddress,amounts[0],amounts[1]);\n        return true;\n    }\n    \n    \n    function _transfer(address _token,address userAddress,uint256 amount) internal  {\n        if(_token==address(weth)) {\n            weth.withdraw(amount);\n            TransferHelper.safeTransferETH(userAddress, amount);\n        }else{\n            TransferHelper.safeTransfer(_token,userAddress,amount);\n        }\n        \n    }\n\n    \n    function stake(uint256 amount) public {\n        \n        require(address(pair)!=address(0),\"Invalid trade pair\");\n        require(amount>0,\"Amount of error\");\n        //token.permit(msg.sender,address(this),nonce,expiry,amount,v,r,s);\n        TransferHelper.safeTransferFrom(address(token),msg.sender,address(this),amount);\n        \n        User storage user = findUser(msg.sender);\n        \n        user.investment+= amount;\n        stakeAmount+=amount;\n        \n        emit Stake(msg.sender,stakeAmount);\n    }\n    \n    function lock(address holder, address locker, uint256 nonce, uint256 expiry,\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) public\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     locker,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"invalid-permit\");\n        require(expiry == 0 || block.timestamp <= expiry, \"permit-expired\");\n        require(nonce == _nonces[holder]++, \"invalid-nonce\");\n        \n        users[holder].freezeTime = block.timestamp;\n        \n        emit Lock(holder,users[holder].investment);\n    }\n    \n    \n    function withdrawCapital() public {\n      \n        User storage user = users[msg.sender];\n        if(user.freezeTime!=0){\n            require(duration(user.freezeTime)!=duration(),\"not allowed now\");\n        }\n        \n        uint256 amount = user.investment;\n        \n        require(amount>0,\"not stake\");\n        \n        TransferHelper.safeTransfer(address(token),msg.sender,amount);\n        user.investment = 0;\n        user.freezeTime = 0;\n        stakeAmount = stakeAmount.sub(amount);\n\n        emit WithdrawCapital(msg.sender,stakeAmount);\n    }\n    \n    \n    function findUser(address userAddress) internal returns(User storage user) {\n        User storage udata = users[msg.sender];\n        if(udata.id==0){\n            userCounter++;\n            udata.id = userCounter;\n            indexs[userCounter] = userAddress;\n        }\n        return udata;\n    }\n    \n    function lockStatus(address userAddress) public view returns(bool){\n        uint256 freezeTime = users[userAddress].freezeTime;\n        return freezeTime==0?false:duration(freezeTime) == duration();\n    }\n    \n    function balanceOf(address userAddress) public view returns (address[2] memory tokens,uint256[2] memory balances){\n        \n        tokens[0] = pair.token0();\n        tokens[1] = pair.token1();\n        \n        balances[0] = IERC20(tokens[0]).balanceOf(userAddress);\n        balances[1] = IERC20(tokens[1]).balanceOf(userAddress);\n        \n        return (tokens,balances);\n    }\n    \n    function totalSupply() public view returns (uint256){\n        return token.totalSupply();\n    }\n    \n    function duration() public view returns(uint256){\n        return duration(block.timestamp);\n    }\n\n    function duration(uint256 endTime) internal view returns(uint256){\n        return duration(ANCHOR,endTime);\n    }\n    \n    function duration(uint256 startTime,uint256 endTime) internal pure returns(uint256){\n        if(endTime<startTime){\n            return 0;\n        }else{\n            return endTime.sub(startTime).div(ONE_DAY);\n        }\n    }\n}\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    }
  }
}