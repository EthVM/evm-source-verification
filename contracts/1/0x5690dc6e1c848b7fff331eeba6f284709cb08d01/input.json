{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/ABDKMath64x64.sol": {
      "content": "/* ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n *\r\n * SPDX-License-Identifier: BSD 4-Clause \"Original\" or \"Old\" License\r\n * Copyright (c) 2019, ABDK Consulting\r\n * \r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n * \r\n *  - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n *  - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n *  - All advertising materials mentioning features or use of this software must display the following acknowledgement: This product includes software developed by ABDK Consulting.\r\n *  - Neither the name of ABDK Consulting nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY ABDK CONSULTING ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ABDK CONSULTING BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\npragma solidity ^0.5.0 || ^0.6.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /**\r\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}"
    },
    "browser/ACOAssetHelper.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nlibrary ACOAssetHelper {\r\n    uint256 internal constant MAX_UINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    /**\r\n     * @dev Internal function to get if the address is for Ethereum (0x0).\r\n     * @param _address Address to be checked.\r\n     * @return Whether the address is for Ethereum.\r\n     */ \r\n    function _isEther(address _address) internal pure returns(bool) {\r\n        return _address == address(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to approve ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param spender Authorized address.\r\n     * @param amount Amount to authorize.\r\n     */\r\n    function _callApproveERC20(address token, address spender, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x095ea7b3, spender, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callApproveERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to transfer ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n    function _callTransferERC20(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callTransferERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to call transferFrom on ERC20 tokens.\r\n     * @param token Address of the token.\r\n     * @param sender Address of the sender.\r\n     * @param recipient Address of the transfer destination.\r\n     * @param amount Amount to transfer.\r\n     */\r\n     function _callTransferFromERC20(address token, address sender, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory returndata) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\r\n        require(success && (returndata.length == 0 || abi.decode(returndata, (bool))), \"ACOAssetHelper::_callTransferFromERC20\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset symbol.\r\n     * @param asset Address of the asset.\r\n     * @return The asset symbol.\r\n     */\r\n    function _getAssetSymbol(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"ETH\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\r\n            require(success, \"ACOAssetHelper::_getAssetSymbol\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset decimals.\r\n     * @param asset Address of the asset.\r\n     * @return The asset decimals.\r\n     */\r\n    function _getAssetDecimals(address asset) internal view returns(uint8) {\r\n        if (_isEther(asset)) {\r\n            return uint8(18);\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x313ce567));\r\n            require(success, \"ACOAssetHelper::_getAssetDecimals\");\r\n            return abi.decode(returndata, (uint8));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to the asset name.\r\n     * @param asset Address of the asset.\r\n     * @return The asset name.\r\n     */\r\n    function _getAssetName(address asset) internal view returns(string memory) {\r\n        if (_isEther(asset)) {\r\n            return \"Ethereum\";\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x06fdde03));\r\n            require(success, \"ACOAssetHelper::_getAssetName\");\r\n            return abi.decode(returndata, (string));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset balance of an account.\r\n     * @param asset Address of the asset.\r\n     * @param account Address of the account.\r\n     * @return The account balance.\r\n     */\r\n    function _getAssetBalanceOf(address asset, address account) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return account.balance;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, account));\r\n            require(success, \"ACOAssetHelper::_getAssetBalanceOf\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to the asset allowance between two addresses.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @return The owner allowance for the spender.\r\n     */\r\n    function _getAssetAllowance(address asset, address owner, address spender) internal view returns(uint256) {\r\n        if (_isEther(asset)) {\r\n            return 0;\r\n        } else {\r\n            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0xdd62ed3e, owner, spender));\r\n            require(success, \"ACOAssetHelper::_getAssetAllowance\");\r\n            return abi.decode(returndata, (uint256));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer an asset. \r\n     * @param asset Address of the asset to be transferred.\r\n     * @param to Address of the destination.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function _transferAsset(address asset, address to, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            (bool success,) = to.call{value:amount}(new bytes(0));\r\n            require(success, 'ACOAssetHelper::_transferAsset');\r\n        } else {\r\n            _callTransferERC20(asset, to, amount);\r\n        }\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to receive an asset. \r\n     * @param asset Address of the asset to be received.\r\n     * @param amount The amount to be received.\r\n     */\r\n    function _receiveAsset(address asset, uint256 amount) internal {\r\n        if (_isEther(asset)) {\r\n            require(msg.value == amount, \"ACOAssetHelper:: Invalid ETH amount\");\r\n        } else {\r\n            require(msg.value == 0, \"ACOAssetHelper:: Ether is not expected\");\r\n            _callTransferFromERC20(asset, msg.sender, address(this), amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to check asset allowance and set to Infinity if necessary.\r\n     * @param asset Address of the asset.\r\n     * @param owner Address of the owner of the tokens.\r\n     * @param spender Address of the spender authorized.\r\n     * @param amount Amount to check allowance.\r\n     */\r\n    function _setAssetInfinityApprove(address asset, address owner, address spender, uint256 amount) internal {\r\n        if (_getAssetAllowance(asset, owner, spender) < amount) {\r\n            _callApproveERC20(asset, spender, MAX_UINT);\r\n        }\r\n    }\r\n}"
    },
    "browser/ACOPoolStrategy.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './Ownable.sol';\r\nimport './Address.sol';\r\nimport './SafeMath.sol';\r\nimport './ACOAssetHelper.sol';\r\nimport './BlackScholes.sol';\r\nimport './IACOPoolStrategy.sol';\r\n\r\n/**\r\n * @title ACOPoolStrategy\r\n * @dev The contract is to set the strategy for an ACO Pool.\r\n * This strategy is only to selling ACO tokens.\r\n */\r\ncontract ACOPoolStrategy is Ownable, IACOPoolStrategy {\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Emitted when the order size factors has been changed.\r\n     * orderSizePenaltyFactor * order size percentage ^ orderSizeDampingFactor\r\n     * @param oldOrderSizeMultiplierFactor Value of the previous order size multiplier factor.\r\n\t * @param oldOrderSizeDividerFactor Value of the previous order size divider factor.\r\n     * @param oldOrderSizeExponentialFactor Value of the previous order size exponential factor.\r\n     * @param newOrderSizeMultiplierFactor Value of the new order size penalty factor.\r\n\t * @param newOrderSizeDividerFactor Value of the new order size divider factor.\r\n     * @param newOrderSizeExponentialFactor Value of the new order size exponential factor.\r\n     */\r\n    event SetOrderSizeFactors(uint256 oldOrderSizeMultiplierFactor, uint256 oldOrderSizeDividerFactor, uint256 oldOrderSizeExponentialFactor, uint256 newOrderSizeMultiplierFactor, uint256 newOrderSizeDividerFactor, uint256 newOrderSizeExponentialFactor);\r\n    \r\n    /**\r\n     * @dev Emitted when the underlying price percentage adjust has been changed.\r\n     * @param oldUnderlyinPriceAdjustPercentage Value of the previous percentage adjust on the underlying price to calculate the option price.\r\n     * @param newUnderlyingPriceAdjustPercentage Value of the new percentage adjust on the underlying price to calculate the option price.\r\n     */\r\n    event SetUnderlyingPriceAdjustPercentage(uint256 oldUnderlyinPriceAdjustPercentage, uint256 newUnderlyingPriceAdjustPercentage);\r\n    \r\n    /**\r\n     * @dev Emitted when the minimum percentage for the option price calculation has been changed.\r\n     * @param oldMinOptionPricePercentage Value of the previous minimum percentage for the option price calculation.\r\n     * @param newMinOptionPricePercentage Value of the new minimum percentage for the option price calculation.\r\n     */\r\n\tevent SetMinOptionPricePercentage(uint256 oldMinOptionPricePercentage, uint256 newMinOptionPricePercentage);\r\n\r\n    /**\r\n     * @dev Emitted when the asset precision has been changed.\r\n     * @param asset Address of the asset.\r\n     * @param oldAssetPrecision Value of the previous asset precision.\r\n     * @param newAssetPrecision Value of the new asset precision.\r\n     */\r\n\tevent SetAssetPrecision(address indexed asset, uint256 oldAssetPrecision, uint256 newAssetPrecision);\r\n\r\n    /**\r\n     * @dev The percentage precision. (100000 = 100%)\r\n     */\r\n    uint256 internal constant PERCENTAGE_PRECISION = 100000;\r\n    \r\n    /**\r\n     * @dev The percentage adjust on the underlying price to calculate the option price.\r\n     */\r\n    uint256 public underlyingPriceAdjustPercentage;\r\n\t\r\n\t/**\r\n     * @dev The minimum percentage for the option price calculation.\r\n     */\r\n\tuint256 public minOptionPricePercentage;\r\n\t\r\n\t/**\r\n     * @dev The order size multiplier factor.\r\n     */\r\n    uint256 public orderSizeMultiplierFactor;\r\n\t\r\n\t/**\r\n     * @dev The order size divider factor.\r\n     */\r\n    uint256 public orderSizeDividerFactor;\r\n\t\r\n\t/**\r\n     * @dev The order size exponential factor.\r\n     */\r\n    uint256 public orderSizeExponentialFactor;\r\n\r\n\t/**\r\n     * @dev The asset precision. (6 decimals = 1000000)\r\n     */\r\n    mapping(address => uint256) public assetPrecision;\r\n    \r\n\t/**\r\n     * @dev The order size exponential divider factor used on the calculation.\r\n     */\r\n    uint256 internal orderSizeExponetialDivFactor;\r\n    \r\n    constructor(\r\n        uint256 _underlyingPriceAdjustPercentage,\r\n\t\tuint256 _minOptionPricePercentage,\r\n        uint256 _orderSizeMultiplierFactor,\r\n\t\tuint256 _orderSizeDividerFactor,\r\n        uint256 _orderSizeExponentialFactor\r\n    ) public {\r\n\t\tsuper.init();\r\n\t\t\r\n        _setUnderlyingPriceAdjustPercentage(_underlyingPriceAdjustPercentage);\r\n\t\t_setMinOptionPricePercentage(_minOptionPricePercentage);\r\n        _setOrderSizeFactors(_orderSizeMultiplierFactor, _orderSizeDividerFactor, _orderSizeExponentialFactor);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Function to set the percentage adjust on the underlying price to calculate the option price.\r\n\t * Only can be called by the admin.\r\n     * @param _underlyingPriceAdjustPercentage Value of the new percentage adjust on the underlying price to calculate the option price.\r\n     */\r\n    function setUnderlyingPriceAdjustPercentage(uint256 _underlyingPriceAdjustPercentage) onlyOwner public {\r\n        _setUnderlyingPriceAdjustPercentage(_underlyingPriceAdjustPercentage);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to set the minimum percentage for the option price calculation.\r\n\t * Only can be called by the admin.\r\n     * @param _minOptionPricePercentage Value of the new  minimum percentage for the option price calculation.\r\n     */\r\n\tfunction setMinOptionPricePercentage(uint256 _minOptionPricePercentage) onlyOwner public {\r\n        _setMinOptionPricePercentage(_minOptionPricePercentage);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to set the the order size factors.\r\n     * orderSizeMultiplierFactor / orderSizeDividerFactor * order size percentage ^ orderSizeExponentialFactor\r\n\t * Only can be called by the admin.\r\n     * @param _orderSizeMultiplierFactor Value of the new order size multiplier factor.\r\n\t * @param _orderSizeDividerFactor Value of the new order size divider factor.\r\n     * @param _orderSizeExponentialFactor Value of the new order size exponential factor.\r\n     */\r\n    function setOrderSizeFactors(uint256 _orderSizeMultiplierFactor, uint256 _orderSizeDividerFactor, uint256 _orderSizeExponentialFactor) onlyOwner public {\r\n        _setOrderSizeFactors(_orderSizeMultiplierFactor, _orderSizeDividerFactor, _orderSizeExponentialFactor);\r\n    }\r\n\t\r\n\t/**\r\n     * @dev Function to set the asset precision.\r\n\t * Only can be called by the admin.\r\n     * @param asset Address of the asset.\r\n     */\r\n    function setAssetPrecision(address asset) onlyOwner public {\r\n        _setAssetPrecision(asset);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to quote an option price.\r\n     * @param quoteData The quote data.\r\n\t * @return The option price per token in strike asset.\r\n     */\r\n    function quote(OptionQuote calldata quoteData) external override view returns(uint256, uint256) {\r\n        require(quoteData.expiryTime > block.timestamp, \"ACOPoolStrategy:: Expired\");\r\n\t\trequire(assetPrecision[quoteData.strikeAsset] > 0, \"ACOPoolStrategy:: Asset precision is not defined\");\r\n        uint256 volatility = _getVolatility(quoteData);\r\n        uint256 price = _getOptionPrice(volatility, quoteData);\r\n        require(price > 0, \"ACOPoolStrategy:: Invalid price\");\r\n        return (price, volatility);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to get a volatility adjusted by the order size.\r\n     * @param quoteData The quote data.\r\n\t * @return The volatility to be used on option price calculation.\r\n     */\r\n    function _getVolatility(OptionQuote memory quoteData) internal view returns(uint256) {\r\n        uint256 orderSizeAdjust = _getOrderSizeAdjust(quoteData);\r\n        return quoteData.baseVolatility.mul(orderSizeAdjust.add(PERCENTAGE_PRECISION)).div(PERCENTAGE_PRECISION);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to get the option price through the Black-Scholes method.\r\n\t * @param volatility The volatility percentage to be used on the calculation.\r\n     * @param quoteData The quote data.\r\n\t * @return The option price per token in strike asset.\r\n     */\r\n    function _getOptionPrice(uint256 volatility, OptionQuote memory quoteData) internal view returns(uint256) {\r\n        uint256 underlyingPriceForQuote = _getUnderlyingPriceForQuote(quoteData);\r\n        uint256 price = BlackScholes.getOptionPrice(\r\n            quoteData.isCallOption,\r\n            quoteData.strikePrice, \r\n            underlyingPriceForQuote,\r\n            assetPrecision[quoteData.strikeAsset],\r\n            quoteData.expiryTime - block.timestamp, \r\n            volatility,\r\n            0, \r\n            0,\r\n            PERCENTAGE_PRECISION\r\n        );\r\n        return _getValidPriceForQuote(price, quoteData);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to get the order size adjustment percentage on the volatility.\r\n     * orderSizeMultiplierFactor / orderSizeDividerFactor * order size percentage ^ orderSizeExponentialFactor\r\n     * @param quoteData The quote data.\r\n\t * @return The order size adjustment percentage on the volatility.\r\n     */\r\n    function _getOrderSizeAdjust(OptionQuote memory quoteData) internal view returns(uint256) {\r\n        uint256 orderSizePercentage = quoteData.collateralOrderAmount.mul(PERCENTAGE_PRECISION).div(quoteData.collateralAvailable);\r\n\t\trequire(orderSizePercentage <= PERCENTAGE_PRECISION, \"ACOPoolStrategy:: No liquidity\");\r\n        return (orderSizePercentage ** orderSizeExponentialFactor).mul(orderSizeMultiplierFactor).div(orderSizeDividerFactor).div(orderSizeExponetialDivFactor);\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to get a underlying price for a quote.\r\n     * @param quoteData The quote data.\r\n\t * @return The underlying price for a quote.\r\n     */\r\n    function _getUnderlyingPriceForQuote(OptionQuote memory quoteData) internal view returns(uint256) {\r\n\t\tif (quoteData.isCallOption) {\r\n\t\t\treturn quoteData.underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\r\n\t\t} else {\r\n\t\t\treturn quoteData.underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\r\n\t\t}\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to get a valid option price on a quote.\r\n\t * The minimum option price restriction is applied.\r\n     * @param price Calculated option price.\r\n     * @param quoteData The quote data.\r\n\t * @return The valid option price considering the minimum price allowed.\r\n     */\r\n    function _getValidPriceForQuote(uint256 price, OptionQuote memory quoteData) internal view returns(uint256) {\r\n\t\tuint256 basePrice = quoteData.isCallOption ? quoteData.underlyingPrice : quoteData.strikePrice;\r\n\t\tuint256 minPrice = basePrice.mul(minOptionPricePercentage).div(PERCENTAGE_PRECISION);\r\n\t\tif (minPrice > price) {\r\n\t\t\treturn minPrice;\r\n\t\t}\r\n\t\treturn price;\r\n    }\r\n\r\n\t/**\r\n     * @dev Internal function to set the asset precision. (6 decimals = 1000000)\r\n     * @param asset Address of the asset.\r\n     */\r\n    function _setAssetPrecision(address asset) internal {\r\n\t\tuint8 decimals = ACOAssetHelper._getAssetDecimals(asset);\r\n\t\tuint256 precision = (10 ** uint256(decimals));\r\n        emit SetAssetPrecision(asset, assetPrecision[asset], precision);\r\n        assetPrecision[asset] = precision;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the percentage adjust on the underlying price to calculate the option price.\r\n     * @param _underlyingPriceAdjustPercentage Value of the new percentage adjust on the underlying price to calculate the option price.\r\n     */\r\n    function _setUnderlyingPriceAdjustPercentage(uint256 _underlyingPriceAdjustPercentage) internal {\r\n        require(_underlyingPriceAdjustPercentage <= PERCENTAGE_PRECISION, \"ACOPoolStrategy:: Invalid underlying price adjust\");\r\n        emit SetUnderlyingPriceAdjustPercentage(underlyingPriceAdjustPercentage, _underlyingPriceAdjustPercentage);\r\n        underlyingPriceAdjustPercentage = _underlyingPriceAdjustPercentage;\r\n    }\r\n    \r\n\t/**\r\n     * @dev Internal function to set the minimum percentage for the option price calculation.\r\n     * @param _minOptionPricePercentage Value of the new  minimum percentage for the option price calculation.\r\n     */\r\n\tfunction _setMinOptionPricePercentage(uint256 _minOptionPricePercentage) internal {\r\n\t\trequire(_minOptionPricePercentage > 0 && _minOptionPricePercentage < PERCENTAGE_PRECISION, \"ACOPoolStrategy:: Invalid min option price percentage\");\r\n        emit SetMinOptionPricePercentage(minOptionPricePercentage, _minOptionPricePercentage);\r\n        minOptionPricePercentage = _minOptionPricePercentage;\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Internal function to set the the order size factors.\r\n     * @param _orderSizeMultiplierFactor Value of the new order size multiplier factor.\r\n\t * @param _orderSizeDividerFactor Value of the new order size divider factor.\r\n     * @param _orderSizeExponentialFactor Value of the new order size exponential factor.\r\n     */\r\n    function _setOrderSizeFactors(uint256 _orderSizeMultiplierFactor, uint256 _orderSizeDividerFactor, uint256 _orderSizeExponentialFactor) internal {\r\n\t\trequire(_orderSizeDividerFactor > 0, \"ACOPoolStrategy:: Invalid divider factor\");\r\n        require(_orderSizeExponentialFactor > 0 && _orderSizeExponentialFactor <= 10, \"ACOPoolStrategy:: Invalid exponential factor\");\r\n        emit SetOrderSizeFactors(orderSizeMultiplierFactor, orderSizeDividerFactor, orderSizeExponentialFactor, _orderSizeMultiplierFactor, _orderSizeDividerFactor, _orderSizeExponentialFactor);\r\n        orderSizeMultiplierFactor = _orderSizeMultiplierFactor;\r\n        orderSizeDividerFactor = _orderSizeDividerFactor;\r\n\t\torderSizeExponentialFactor = _orderSizeExponentialFactor;\r\n        orderSizeExponetialDivFactor = (PERCENTAGE_PRECISION ** (_orderSizeExponentialFactor - 1));\r\n    }\r\n}"
    },
    "browser/Address.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"
    },
    "browser/BlackScholes.sol": {
      "content": "pragma solidity ^0.5.0 || ^0.6.0;\r\n\r\nimport './ABDKMath64x64.sol';\r\n\r\nlibrary BlackScholes {\r\n\r\n\t/**\r\n     * @dev Function to get the option price using the Black-Sholes method.\r\n\t * @param isCallOption True if the option type is CALL, false for PUT.\r\n\t * @param strikePrice The strike price value with `pricePrecision`.\r\n\t * @param currentPrice The current underlying price value with `pricePrecision`.\r\n\t * @param pricePrecision The price precision, for example for an asset with 6 decimals it will be 1000000.\r\n\t * @param secondsToExpire Seconds to the option expiry.\r\n\t * @param annualVolatilityPercentage The annual volatility with `percentageDataPrecision`.\r\n\t * @param annualInterestRate The annual interest rate with `percentageDataPrecision`.\r\n\t * @param annualDividendYield The annual dividen yield with `percentageDataPrecision`.\r\n\t * @param percentageDataPrecision The percentage precision, for example it must be 100000 wheter 100000=100%, 25000=25%, 250750=250.75% etc.\r\n     * @return The calculated option price with `pricePrecision`.\r\n     */\r\n    function getOptionPrice(\r\n        bool isCallOption,\r\n        uint256 strikePrice, \r\n        uint256 currentPrice,\r\n        uint256 pricePrecision,\r\n        uint256 secondsToExpire, \r\n        uint256 annualVolatilityPercentage,\r\n        uint256 annualInterestRate, \r\n        uint256 annualDividendYield,\r\n        uint256 percentageDataPrecision\r\n    ) internal pure returns (uint256) {\r\n        return ABDKMath64x64.mulu(\r\n            _blackScholesCalculation(\r\n                isCallOption, \r\n                ABDKMath64x64.divu(strikePrice, pricePrecision), \r\n                ABDKMath64x64.divu(currentPrice, pricePrecision), \r\n                ABDKMath64x64.divu(annualVolatilityPercentage, percentageDataPrecision), \r\n                ABDKMath64x64.divu(annualInterestRate, percentageDataPrecision), \r\n                ABDKMath64x64.divu(annualDividendYield, percentageDataPrecision), \r\n                ABDKMath64x64.divu(secondsToExpire, 0x1e13380)\r\n            ),\r\n            pricePrecision\r\n        );\r\n    }\r\n\r\n\t/**\r\n     * @dev Private function to handle with the Black-Sholes calculation.\r\n\t * @param isCallOption True if the option type is CALL, false for PUT.\r\n\t * @param strikePrice The strike price normalized with `ABDKMath64x64` library.\r\n\t * @param currentPrice The current underlying price normalized with `ABDKMath64x64` library.\r\n\t * @param volatility The annual volatility normalized with `ABDKMath64x64` library.\r\n\t * @param interestRate The annual interest rate normalized with `ABDKMath64x64` library.\r\n\t * @param dividendYield The annual dividen yield normalized with `ABDKMath64x64` library.\r\n\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\r\n     * @return The calculated option price normalized with `ABDKMath64x64` library.\r\n     */\r\n    function _blackScholesCalculation(\r\n        bool isCallOption,\r\n        int128 strikePrice, \r\n        int128 currentPrice,\r\n        int128 volatility,\r\n        int128 interestRate, \r\n        int128 dividendYield,\r\n        int128 expiration\r\n    ) private pure returns (int128) {\r\n        int128 dCalculationAux = ABDKMath64x64.mul(volatility, ABDKMath64x64.sqrt(expiration));\r\n        int128 d1 = _d1Calculation(strikePrice, currentPrice, expiration, volatility, interestRate, dividendYield, dCalculationAux);\r\n        int128 d2 = ABDKMath64x64.sub(d1, dCalculationAux);\r\n        return _priceCalculation(\r\n            isCallOption, \r\n            strikePrice, \r\n            currentPrice, \r\n            interestRate, \r\n            dividendYield, \r\n            expiration, \r\n            d1, \r\n            d2\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Private function to calculate the option price with the Black-Sholes method.\r\n\t * @param isCallOption True if the option type is CALL, false for PUT.\r\n\t * @param strikePrice The strike price normalized with `ABDKMath64x64` library.\r\n\t * @param currentPrice The current underlying price normalized with `ABDKMath64x64` library.\r\n\t * @param interestRate The annual interest rate normalized with `ABDKMath64x64` library.\r\n\t * @param dividendYield The annual dividen yield normalized with `ABDKMath64x64` library.\r\n\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\r\n\t * @param d1 The D1 argument on Black-Sholes method normalized with `ABDKMath64x64` library.\r\n\t * @param d2 The D2 argument on Black-Sholes method normalized with `ABDKMath64x64` library.\r\n     * @return The calculated option price normalized with `ABDKMath64x64` library.\r\n     */\r\n    function _priceCalculation(\r\n        bool isCallOption,\r\n        int128 strikePrice, \r\n        int128 currentPrice,\r\n        int128 interestRate, \r\n        int128 dividendYield,\r\n        int128 expiration,\r\n        int128 d1,\r\n        int128 d2\r\n    ) private pure returns (int128) {\r\n        int128 dividendYieldFactor = _getRateFactor(dividendYield, expiration);\r\n        int128 interestRateFactor = _getRateFactor(interestRate, expiration);\r\n        if (isCallOption) {\r\n            return ABDKMath64x64.sub(\r\n                ABDKMath64x64.mul(\r\n                    dividendYieldFactor,\r\n                    ABDKMath64x64.mul(\r\n                        currentPrice,\r\n                        _normalCummulativeDistribution(d1)\r\n                    )\r\n                ),\r\n                ABDKMath64x64.mul(\r\n                    interestRateFactor,\r\n                    ABDKMath64x64.mul(\r\n                        strikePrice,\r\n                        _normalCummulativeDistribution(d2)\r\n                    )\r\n                )\r\n            );\r\n        } else {\r\n            return ABDKMath64x64.sub(\r\n                ABDKMath64x64.mul(\r\n                    interestRateFactor,\r\n                    ABDKMath64x64.mul(\r\n                        strikePrice,\r\n                        _normalCummulativeDistribution(ABDKMath64x64.neg(d2))\r\n                    )\r\n                ),\r\n                ABDKMath64x64.mul(\r\n                    dividendYieldFactor,\r\n                    ABDKMath64x64.mul(\r\n                        currentPrice,\r\n                        _normalCummulativeDistribution(ABDKMath64x64.neg(d1))\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\t\r\n    /**\r\n     * @dev Private function to calculate the normal cummulative distribution.\r\n\t * @param x The value normalized with `ABDKMath64x64` library to be calculated.\r\n     * @return The normal cummulative distribution normalized with `ABDKMath64x64` library.\r\n     */\r\n    function _normalCummulativeDistribution(int128 x) private pure returns (int128) {\r\n        int128 z = ABDKMath64x64.div(x, 0x16a09e667f3bcc908);\r\n        int128 t = ABDKMath64x64.div(0x10000000000000000, ABDKMath64x64.add(0x10000000000000000, ABDKMath64x64.mul(0x53dd02a4f5ee2e46, ABDKMath64x64.abs(z))));\r\n        int128 erf = _getErf(z, t);\r\n        int128 nerf = erf;\r\n        if (z < 0) {\r\n            nerf = ABDKMath64x64.neg(erf);\r\n        }\r\n        return ABDKMath64x64.mul(0x8000000000000000, ABDKMath64x64.add(0x10000000000000000, nerf));\r\n    }\r\n    \r\n    /**\r\n     * @dev Private function to calculate the ERF.\r\n\t * @param z The `z` argument normalized with `ABDKMath64x64` library.\r\n\t * @param t The `t` argument normalized with `ABDKMath64x64` library.\r\n     * @return The ERF normalized with `ABDKMath64x64` library.\r\n     */\r\n    function _getErf(int128 z, int128 t) private pure returns (int128) {\r\n        int128 f = ABDKMath64x64.mul(t, ABDKMath64x64.add(0x16be1c55bae156b65, ABDKMath64x64.mul(t, ABDKMath64x64.add(-0x17401c57014c38f14, ABDKMath64x64.mul(t, 0x10fb844255a12d72e)))));\r\n        int128 f2 = ABDKMath64x64.add(0x413c831bb169f874, ABDKMath64x64.mul(t, ABDKMath64x64.add(-0x48d4c730f051a5fe, f)));\r\n        return ABDKMath64x64.sub(0x10000000000000000, ABDKMath64x64.mul(t, ABDKMath64x64.mul(f2, ABDKMath64x64.exp(ABDKMath64x64.mul(ABDKMath64x64.neg(z), z)))));\r\n    }\r\n    \r\n    /**\r\n     * @dev Private function to calculate the rate factor: e ^ (-rate * expiration).\r\n\t * @param rate The rate normalized with `ABDKMath64x64` library.\r\n\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\r\n     * @return The rate factor normalized with `ABDKMath64x64` library.\r\n     */\r\n    function _getRateFactor(int128 rate, int128 expiration) private pure returns (int128) {\r\n        int128 rateFactor = 0x10000000000000000;\r\n        if (rate > 0) {\r\n            rateFactor = ABDKMath64x64.exp(ABDKMath64x64.mul(ABDKMath64x64.neg(rate), expiration));\r\n        }\r\n        return rateFactor;\r\n    }\r\n    \r\n    /**\r\n     * @dev Private function to calculate the D1 data for the Black-Sholes method.\r\n\t * @param strikePrice The strike price normalized with `ABDKMath64x64` library.\r\n\t * @param currentPrice The current underlying price normalized with `ABDKMath64x64` library.\r\n\t * @param expiration The expiration annual equivalent percentage normalized with `ABDKMath64x64` library.\r\n\t * @param volatility The annual volatility normalized with `ABDKMath64x64` library.\r\n\t * @param interestRate The annual interest rate normalized with `ABDKMath64x64` library.\r\n\t * @param dividendYield The annual dividen yield normalized with `ABDKMath64x64` library.\r\n\t * @param dCalculationAux The annual dividen yield normalized with `ABDKMath64x64` library.\r\n     * @return The D1 normalized with `ABDKMath64x64` library.\r\n     */\r\n    function _d1Calculation(\r\n        int128 strikePrice, \r\n        int128 currentPrice,\r\n        int128 expiration, \r\n        int128 volatility,\r\n        int128 interestRate, \r\n        int128 dividendYield,\r\n        int128 dCalculationAux\r\n    ) private pure returns (int128) {\r\n        return ABDKMath64x64.div(\r\n            ABDKMath64x64.add(\r\n                ABDKMath64x64.ln(ABDKMath64x64.div(currentPrice, strikePrice)), \r\n                ABDKMath64x64.mul(\r\n                    expiration, \r\n                    ABDKMath64x64.add(\r\n                        ABDKMath64x64.sub(interestRate, dividendYield), \r\n                        ABDKMath64x64.div(ABDKMath64x64.mul(volatility, volatility), 0x20000000000000000)\r\n                    )\r\n                )\r\n            ), \r\n            dCalculationAux\r\n        );\r\n    }\r\n}"
    },
    "browser/IACOPoolStrategy.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IACOPoolStrategy {\r\n    \r\n    struct OptionQuote {\r\n        uint256 underlyingPrice;\r\n        address underlying;\r\n        address strikeAsset;\r\n        bool isCallOption;\r\n        uint256 strikePrice; \r\n        uint256 expiryTime;\r\n        uint256 baseVolatility;\r\n        uint256 collateralOrderAmount;\r\n        uint256 collateralAvailable;\r\n    }\r\n\r\n    function quote(OptionQuote calldata quoteData) external view returns(uint256 optionPrice, uint256 volatility);\r\n}"
    },
    "browser/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function init() internal {\r\n        require(_owner == address(0), \"Ownable: Contract initialized\");\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"
    },
    "browser/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    }
  }
}