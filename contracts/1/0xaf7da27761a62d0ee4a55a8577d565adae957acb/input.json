{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ACOFactory.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./BokkyPooBahsDateTimeLibrary.sol\";\r\nimport \"./Strings.sol\";\r\n\r\n/**\r\n * @title ACOFactory\r\n * @dev The contract is the implementation for the ACOProxy.\r\n */\r\ncontract ACOFactory {\r\n    \r\n    /**\r\n     * @dev Emitted when the factory admin address has been changed.\r\n     * @param previousFactoryAdmin Address of the previous factory admin.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    event SetFactoryAdmin(address previousFactoryAdmin, address newFactoryAdmin);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO token implementation has been changed.\r\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\r\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\r\n     */\r\n    event SetAcoTokenImplementation(address previousAcoTokenImplementation, address newAcoTokenImplementation);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO fee has been changed.\r\n     * @param previousAcoFee Value of the previous ACO fee.\r\n     * @param newAcoFee Value of the new ACO fee.\r\n     */\r\n    event SetAcoFee(uint256 previousAcoFee, uint256 newAcoFee);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO fee destination address has been changed.\r\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\r\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\r\n     */\r\n    event SetAcoFeeDestination(address previousAcoFeeDestination, address newAcoFeeDestination);\r\n    \r\n    /**\r\n     * @dev Emitted when a new ACO token has been created.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param acoToken Address of the new ACO token created.\r\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\r\n     */\r\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\r\n    \r\n    /**\r\n     * @dev The ACO fee value. \r\n     * It is a percentage value (100000 is 100%).\r\n     */\r\n    uint256 public acoFee;\r\n    \r\n    /**\r\n     * @dev The factory admin address.\r\n     */\r\n    address public factoryAdmin;\r\n    \r\n    /**\r\n     * @dev The ACO token implementation address.\r\n     */\r\n    address public acoTokenImplementation;\r\n    \r\n    /**\r\n     * @dev The ACO fee destination address.\r\n     */\r\n    address public acoFeeDestination;\r\n    \r\n    /**\r\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\r\n     * Only factory admin address can execute.\r\n     */\r\n    modifier onlyFactoryAdmin() {\r\n        require(msg.sender == factoryAdmin, \"ACOFactory::onlyFactoryAdmin\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to initialize the contract.\r\n     * It should be called through the `data` argument when creating the proxy.\r\n     * It must be called only once. The `assert` is to guarantee that behavior.\r\n     * @param _factoryAdmin Address of the factory admin.\r\n     * @param _acoTokenImplementation Address of the ACO token implementation.\r\n     * @param _acoFee Value of the ACO fee.\r\n     * @param _acoFeeDestination Address of the ACO fee destination.\r\n     */\r\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\r\n        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), \"ACOFactory::init: Contract already initialized.\");\r\n        \r\n        _setFactoryAdmin(_factoryAdmin);\r\n        _setAcoTokenImplementation(_acoTokenImplementation);\r\n        _setAcoFee(_acoFee);\r\n        _setAcoFeeDestination(_acoFeeDestination);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to guarantee that the contract will not receive ether.\r\n     */\r\n    receive() external payable virtual {\r\n        revert();\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     */\r\n    function createAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime\r\n    ) onlyFactoryAdmin external virtual {\r\n        address acoToken = _deployAcoToken(_getAcoTokenInitData(underlying, strikeAsset, isCall, strikePrice, expiryTime));\r\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);   \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the factory admin address.\r\n     * Only can be called by the factory admin.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\r\n        _setFactoryAdmin(newFactoryAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO token implementation address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\r\n     */\r\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\r\n        _setAcoTokenImplementation(newAcoTokenImplementation);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO fee.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\r\n     */\r\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\r\n        _setAcoFee(newAcoFee);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO destination address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoFeeDestination Address of the new ACO destination.\r\n     */\r\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\r\n        _setAcoFeeDestination(newAcoFeeDestination);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the factory admin address.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\r\n        require(newFactoryAdmin != address(0), \"ACOFactory::_setFactoryAdmin: Invalid factory admin\");\r\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\r\n        factoryAdmin = newFactoryAdmin;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO token implementation address.\r\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\r\n     */\r\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\r\n        require(Address.isContract(newAcoTokenImplementation), \"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\");\r\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\r\n        acoTokenImplementation = newAcoTokenImplementation;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO fee.\r\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\r\n     */\r\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\r\n        emit SetAcoFee(acoFee, newAcoFee);\r\n        acoFee = newAcoFee;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO destination address.\r\n     * @param newAcoFeeDestination Address of the new ACO destination.\r\n     */\r\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\r\n        require(newAcoFeeDestination != address(0), \"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\");\r\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\r\n        acoFeeDestination = newAcoFeeDestination;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the ACO token initialize data.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @return ABI encoded with signature for initializing ACO token.\r\n     */\r\n    function _getAcoTokenInitData(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime\r\n    ) internal view virtual returns(bytes memory) {\r\n        return abi.encodeWithSignature(\"init(address,address,bool,uint256,uint256,uint256,address)\",\r\n            underlying,\r\n            strikeAsset,\r\n            isCall,\r\n            strikePrice,\r\n            expiryTime,\r\n            acoFee,\r\n            acoFeeDestination\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\r\n     * @param initData ABI encoded with signature for initializing the new ACO token.\r\n     * @return Address of the new minimal proxy deployed for the ACO token.\r\n     */\r\n    function _deployAcoToken(bytes memory initData) internal virtual returns(address) {\r\n        require(initData.length > 0, \"ACOFactory::_deployToken: Invalid init data\");\r\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\r\n        address proxy;\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), implentationBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            proxy := create(0, clone, 0x37)\r\n        }\r\n        (bool success, bytes memory returnData) = proxy.call(initData);\r\n        require(success, _acoTokenInititalizeError(returnData));\r\n        return proxy;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to handle the return data on initializing ACO token with an error.\r\n     * 4 bytes (function signature) + 32 bytes (offset) + 32 bytes (error string length) + X bytes (error string)\r\n     * @param data Returned data with an error.\r\n     * @return String with the error.\r\n     */\r\n    function _acoTokenInititalizeError(bytes memory data) internal pure virtual returns(string memory) {\r\n        if (data.length >= 100) {\r\n            bytes memory buffer = new bytes(data.length - 68);\r\n            uint256 index = 0;\r\n            for (uint256 i = 68; i < data.length; ++i) {\r\n                buffer[index++] = data[i];\r\n            }\r\n            return string(buffer);\r\n        } else {\r\n            return \"ACOFactory::_acoTokenInititalizeError\";\r\n        }  \r\n    }\r\n}"},"browser/Address.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"},"browser/BokkyPooBahsDateTimeLibrary.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n"},"browser/Strings.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n"}}}