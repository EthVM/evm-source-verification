{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"StrategiesHelper.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface IV2Strategy {\n    function name() external view returns (string memory);\n\n    function apiVersion() external view returns (string memory);\n\n    function strategist() external view returns (address);\n\n    function rewards() external view returns (address);\n\n    function vault() external view returns (address);\n\n    function keeper() external view returns (address);\n\n    function want() external view returns (address);\n\n    function emergencyExit() external view returns (bool);\n\n    function isActive() external view returns (bool);\n\n    function delegatedAssets() external view returns (uint256);\n\n    function estimatedTotalAssets() external view returns (uint256);\n    \n    function doHealthCheck() external view returns (bool);\n    \n    function healthCheck() external view returns (address);\n}\n\ninterface IAddressesGenerator {\n    function assetsAddresses() external view returns (address[] memory);\n}\n\ninterface IV2Vault {\n    function withdrawalQueue(uint256 arg0) external view returns (address);\n}\n\ninterface IHelper {\n    function mergeAddresses(address[][] memory addressesSets)\n        external\n        view\n        returns (address[] memory);\n}\n\ncontract StrategiesHelper {\n    address public addressesGeneratorAddress;\n    address public helperAddress;\n    address public ownerAddress;\n\n    struct StrategyMetadata {\n        string name;\n        string apiVersion;\n        address strategist;\n        address rewards;\n        address vault;\n        address keeper;\n        address want;\n        bool emergencyExit;\n        bool isActive;\n        uint256 delegatedAssets;\n        uint256 estimatedTotalAssets;\n        bool doHealthCheck;\n        address healthCheckAddress;\n    }\n\n    constructor(address _addressesGeneratorAddress, address _helperAddress) {\n        addressesGeneratorAddress = _addressesGeneratorAddress;\n        helperAddress = _helperAddress;\n        ownerAddress = msg.sender;\n    }\n\n    /**\n     * Fetch the number of strategies for a vault\n     */\n    function assetStrategiesLength(address assetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        IV2Vault vault = IV2Vault(assetAddress);\n        uint256 strategyIdx;\n        while (true) {\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n            if (strategyAddress == address(0)) {\n                break;\n            }\n            strategyIdx++;\n        }\n        return strategyIdx;\n    }\n\n    /**\n     * Fetch the total number of strategies for all vaults\n     */\n    function assetsStrategiesLength() public view returns (uint256) {\n        return assetsStrategiesAddresses().length;\n    }\n\n    /**\n     * Fetch strategy addresses given a vault address\n     */\n    function assetStrategiesAddresses(address assetAddress)\n        public\n        view\n        returns (address[] memory)\n    {\n        IV2Vault vault = IV2Vault(assetAddress);\n        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n        address[] memory _strategiesAddresses =\n            new address[](numberOfStrategies);\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n            _strategiesAddresses[strategyIdx] = strategyAddress;\n        }\n        return _strategiesAddresses;\n    }\n\n    /**\n     * Fetch all strategy addresses for all vaults\n     */\n     function assetsStrategiesAddresses() public view returns (address[] memory) {\n        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n        return assetsStrategiesAddresses(_assetsAddresses);\n     }\n\n    /**\n     * Fetch all strategy addresses given an array of vaults\n     */\n    function assetsStrategiesAddresses(address[] memory _assetsAddresses)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 numberOfAssets = _assetsAddresses.length;\n        address[][] memory _strategiesForAssets =\n            new address[][](numberOfAssets);\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n            address assetAddress = _assetsAddresses[assetIdx];\n            address[] memory _assetStrategiessAddresses =\n                assetStrategiesAddresses(assetAddress);\n            _strategiesForAssets[assetIdx] = _assetStrategiessAddresses;\n        }\n        address[] memory mergedAddresses =\n            IHelper(helperAddress).mergeAddresses(_strategiesForAssets);\n        return mergedAddresses;\n    }\n\n    /**\n     * Fetch total delegated balance for all strategies\n     */\n    function assetsStrategiesDelegatedBalance()\n        external\n        view\n        returns (uint256)\n    {\n        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n        uint256 numberOfAssets = _assetsAddresses.length;\n        uint256 assetsDelegatedBalance;\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n            address assetAddress = _assetsAddresses[assetIdx];\n            uint256 assetDelegatedBalance =\n                assetStrategiesDelegatedBalance(assetAddress);\n            assetsDelegatedBalance += assetDelegatedBalance;\n        }\n        return assetsDelegatedBalance;\n    }\n\n    /**\n     * Fetch delegated balance for all of a vault's strategies\n     */\n    function assetStrategiesDelegatedBalance(address assetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        address[] memory _assetStrategiesAddresses =\n            assetStrategiesAddresses(assetAddress);\n        uint256 numberOfStrategies = _assetStrategiesAddresses.length;\n        uint256 strategiesDelegatedBalance;\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = _assetStrategiesAddresses[strategyIdx];\n            IV2Strategy _strategy = IV2Strategy(strategyAddress);\n            uint256 strategyDelegatedBalance = _strategy.delegatedAssets();\n            strategiesDelegatedBalance += strategyDelegatedBalance;\n        }\n        return strategiesDelegatedBalance;\n    }\n\n    /**\n     * Fetch metadata for all strategies scoped to a vault\n     */\n    function assetStrategies(address assetAddress)\n        external\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        IV2Vault vault = IV2Vault(assetAddress);\n        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n        StrategyMetadata[] memory _strategies =\n            new StrategyMetadata[](numberOfStrategies);\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n            StrategyMetadata memory _strategy = strategy(strategyAddress);\n            _strategies[strategyIdx] = _strategy;\n        }\n        return _strategies;\n    }\n\n    /**\n     * Fetch metadata for all strategies\n     */\n    function assetsStrategies()\n        external\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        address[] memory _assetsStrategiesAddresses =\n            assetsStrategiesAddresses();\n        return strategies(_assetsStrategiesAddresses);\n    }\n    \n    /**\n     * Fetch metadata for a strategy given a strategy address\n     */\n    function strategy(address strategyAddress)\n        public\n        view\n        returns (StrategyMetadata memory)\n    {\n        IV2Strategy _strategy = IV2Strategy(strategyAddress);\n        bool _doHealthCheck;\n        address _healthCheckAddress;\n        try _strategy.doHealthCheck() {\n            _doHealthCheck = _strategy.doHealthCheck();\n        } catch {}\n        try _strategy.healthCheck() {\n             _healthCheckAddress = _strategy.healthCheck();\n        } catch {}\n        return\n            StrategyMetadata({\n                name: _strategy.name(),\n                apiVersion: _strategy.apiVersion(),\n                strategist: _strategy.strategist(),\n                rewards: _strategy.rewards(),\n                vault: _strategy.vault(),\n                keeper: _strategy.keeper(),\n                want: _strategy.want(),\n                emergencyExit: _strategy.emergencyExit(),\n                isActive: _strategy.isActive(),\n                delegatedAssets: _strategy.delegatedAssets(),\n                estimatedTotalAssets: _strategy.estimatedTotalAssets(),\n                doHealthCheck: _doHealthCheck,\n                healthCheckAddress: _healthCheckAddress\n            });\n    }\n\n    /**\n     * Fetch metadata for strategies given an array of strategy addresses\n     */\n    function strategies(address[] memory _strategiesAddresses)\n        public\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        uint256 numberOfStrategies = _strategiesAddresses.length;\n        StrategyMetadata[] memory _strategies =\n            new StrategyMetadata[](numberOfStrategies);\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = _strategiesAddresses[strategyIdx];\n            StrategyMetadata memory _strategy = strategy(strategyAddress);\n            _strategies[strategyIdx] = _strategy;\n        }\n        return _strategies;\n    }\n    \n    /**\n     * Allow storage slots to be manually updated\n     */\n    function updateSlot(bytes32 slot, bytes32 value) external {\n        require(msg.sender == ownerAddress, \"Caller is not the owner\");\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}"}}}