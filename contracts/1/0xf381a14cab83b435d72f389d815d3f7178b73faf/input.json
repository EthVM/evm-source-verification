{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Invoice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function transfer(address, uint256) external;\n    function balanceOf(address) external view returns(uint256);\n}\n\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\n/// @author davy42\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it's a contract without receive function\ncontract Invoice {\n\n    /// @notice Constructor\n    /// @dev The Invoice contract has only constructor.\n    /// @param token The address of the erc20 token contract\n    /// @param receiver The address to which tokens will be sent\n    /// @param amount amount of tokens\n    constructor(IERC20 token, address payable receiver, uint256 amount) {\n        token.transfer(receiver, amount);\n        selfdestruct(receiver);\n    }\n}\n\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\n/// @author davy42\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it's a contract without receive function\ncontract SimpleInvoice {\n\n    /// @notice Constructor\n    /// @dev The Invoice contract has only constructor.\n    /// @param token The address of the erc20 token contract\n    /// @param receiver The address to which tokens will be sent\n    constructor(IERC20 token, address payable receiver) {\n        token.transfer(receiver, token.balanceOf(address(this)));\n        selfdestruct(receiver);\n    }\n}"
    },
    "contracts/InvoiceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport {SimpleInvoice} from \"./Invoice.sol\";\n\n/// @title The InvoiceFactory allows withdrawing ERC20 tokens from a temporary Invoice\n/// @author davy42\n/// @notice The InvoiceFactory can compute the address for deposit and withdraw funds\n/// @dev The InvoiceFactory use the bytecode of the Invoice contract with dynamic token and receiver addresses\ncontract InvoiceFactory  {\n\n    bytes constant private invoiceCreationCode = type(SimpleInvoice).creationCode;\n\n    /// @notice Witdraws erc20 tokens from the deposit wallet and send to the receiver\n    /// @param salt The unique salt\n    /// @param token The address of the erc20 token which will be withdrawed\n    /// @param receiver The address which will get tokens\n    /// @return wallet the address of the wallet\n    function withdraw(uint256 salt, address token, address receiver) external returns (address wallet) {\n        bytes memory bytecode = getByteCode(token, receiver);\n        assembly {\n            wallet := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(wallet != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /// @notice  Returns the address of the wallet\n    /// @dev Compute address for depositing funds using salt, token and receivers\n    /// @param salt The unique salt\n    /// @param token The address of the erc20 token which will be deposited\n    /// @param receiver The address which will get tokens when withdraw\n    /// @return wallet the address of the wallet\n    function computeAddress(uint256 salt, address token, address receiver) public view returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(getByteCode(token, receiver))));\n        return address(uint160(uint256(_data)));\n    }\n\n    /// @notice Generate the bytecode of wallet contract with token and receiver\n    /// @dev Explain to a developer any extra details\n    /// @param token The address of the erc20 token which will be deposited\n    /// @param receiver The address which will get tokens when withdraw\n    /// @return bytecode the bytecode of the wallet contract\n    function getByteCode(address token, address receiver) private pure returns (bytes memory bytecode) {\n        bytecode = abi.encodePacked(invoiceCreationCode, abi.encode(token, receiver));\n    }\n}"
    }
  }
}