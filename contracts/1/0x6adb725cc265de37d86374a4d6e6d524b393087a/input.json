{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Bridge.sol":{"content":"// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity ^0.8.6;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    function burn(address account, uint256 amount) external;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\n\r\ncontract BridgeAdmin {\r\n\r\n    address public admin;\r\n\r\n    struct Token {\r\n        bool isRun; // 是否运行\r\n        bool isMain; // 是否主链\r\n        address local; // 本链地址\r\n    }\r\n\r\n    // tokens[toChainId][toToken] = localPairInfo\r\n    mapping(uint => mapping(address => Token)) public tokens;\r\n\r\n    // natives[toChainId][isMain] = localPairInfo\r\n    mapping(uint => mapping(bool => Token)) public natives;\r\n\r\n    event adminChanged(address _address);\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Bridge Admin: only use admin to call\");\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address payable newAdmin) public onlyAdmin {\r\n        admin = newAdmin;\r\n    }\r\n\r\n    // 代币是否支持跨链\r\n    function tokenCanBridge(uint toChainId, address toToken) view internal returns (bool){\r\n        return tokens[toChainId][toToken].isRun;\r\n    }\r\n\r\n\r\n    // 侧链,侧链代币,本链代币,是否运行,本链是否主链\r\n    function tokenInsert(uint toChainId, address toToken, address fromToken, bool isRun, bool isMain) external onlyAdmin {\r\n        tokens[toChainId][toToken] = Token({\r\n        isRun : isRun,\r\n        isMain : isMain,\r\n        local : fromToken\r\n        });\r\n    }\r\n\r\n    // 添加支持的主网币\r\n    function nativeInsert(uint toChainId, address fromAddress,bool isRun) external onlyAdmin {\r\n        bool isMain = false;\r\n        if(fromAddress == address(0)){\r\n            isMain = true;\r\n        }\r\n        natives[toChainId][isMain] = Token({\r\n        isMain : isMain,\r\n        isRun : isRun,\r\n        local : fromAddress\r\n        });\r\n    }\r\n\r\n    function switchTokenMain(uint toChainId, address toToken) external onlyAdmin returns (bool){\r\n        Token storage pair = tokens[toChainId][toToken];\r\n        require(pair.local != address(0),\"Bridge Admin: pair is not exist\");\r\n        bool isMain = pair.isMain? false : true;\r\n        tokens[toChainId][toToken] = Token({\r\n        isRun : pair.isRun,\r\n        isMain : isMain,\r\n        local : pair.local\r\n        });\r\n        return true;\r\n    }\r\n\r\n    // 设置代币状态\r\n    function setTokenIsRun(uint toChainId, address toToken, bool state) public {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Bridge Admin: no operation permission\"\r\n        );\r\n\r\n        tokens[toChainId][toToken].isRun = state;\r\n    }\r\n\r\n    // 设置主网币状态\r\n    function setNativeIsRun(uint toChainId, bool isMain, bool state) public {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Bridge Admin: no operation permission\"\r\n        );\r\n\r\n        natives[toChainId][isMain].isRun = state;\r\n    }\r\n\r\n\r\n    // 资产转账\r\n    function tokenTransfer(address fromToken, address recipient, uint256 value) public onlyAdmin {\r\n        IERC20 token = IERC20(fromToken);\r\n        token.transfer(recipient, value);\r\n    }\r\n\r\n    // 主网币转账\r\n    function nativeTransfer(address payable recipient, uint256 value) public onlyAdmin {\r\n        require(address(this).balance > value, \"Bridge Admin: not enough native token\");\r\n        recipient.transfer(value);\r\n    }\r\n}\r\n\r\ncontract Bridge is BridgeAdmin {\r\n\r\n    address public owner;\r\n\r\n    address public manager;\r\n\r\n    event Deposit(uint toChainId, address fromToken, address toToken, address recipient, uint256 value);\r\n\r\n    event DepositNative(uint toChainId, bool isMain, address recipient, uint256 value);\r\n\r\n    event WithdrawDone(uint toChainId, address fromToken, address toToken, address recipient, uint256 value, bytes depositHash);\r\n\r\n    event WithdrawNativeDone(uint fromChainId, address recipient, bool isMain, uint256 value, bytes depositHash);\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Bridge: only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager {\r\n        require(manager != address(0), \"Bridge: must set manager before call this function\");\r\n        require(msg.sender == manager, \"Bridge: only manager can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier canBridge(uint chainId, address toToken) {\r\n        require(tokenCanBridge(chainId, toToken), \"Bridge: token is can not use bridge\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        admin = _owner;\r\n        owner = _owner;\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwner {\r\n        require(_manager != address(0), \"Bridge: manager must be a contract address\");\r\n        manager = _manager;\r\n    }\r\n\r\n    function setOwner(address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n\r\n    function deposit(\r\n        uint chainId,\r\n        address toToken,\r\n        uint256 value\r\n    ) public canBridge(chainId, toToken) {\r\n        Token storage local = tokens[chainId][toToken];\r\n        IERC20 token = IERC20(local.local);\r\n        if (local.isMain) {\r\n            // 主链\r\n            token.transferFrom(msg.sender, address(this), value);\r\n        } else {\r\n            // 侧链 燃烧\r\n            token.burn(msg.sender, value);\r\n        }\r\n        emit Deposit(chainId, local.local, toToken, msg.sender, value);\r\n    }\r\n\r\n    function depositNative(uint toChainId, bool isMain, uint256 value) public payable {\r\n        Token storage native = natives[toChainId][isMain];\r\n        require(native.isRun, \"Bridge: chain is not support\");\r\n\r\n        if (native.isMain) {\r\n            // 主链跨出\r\n            require(msg.value == value, \"Bridge: value is wrong\");\r\n            require(msg.value > 0, \"Bridge: value is 0\");\r\n        } else {\r\n            // 侧链 燃烧\r\n            IERC20 token = IERC20(native.local);\r\n            token.burn(msg.sender, value);\r\n        }\r\n        emit DepositNative(toChainId, isMain, msg.sender, value);\r\n    }\r\n\r\n    function withdraw(uint toChainId, address toToken, address recipient, uint256 value, bytes memory depositHash) public onlyManager {\r\n        Token storage local = tokens[toChainId][toToken];\r\n        IERC20 token = IERC20(local.local);\r\n        if (local.isMain) {\r\n            // 主链 转账\r\n            token.transfer(recipient, value);\r\n        } else {\r\n            // 侧链 铸币\r\n            token.mint(recipient, value);\r\n        }\r\n        emit WithdrawDone(toChainId, local.local, toToken, recipient, value, depositHash);\r\n    }\r\n\r\n\r\n    function withdrawNative(uint toChainId, address payable recipient, bool isMain, uint256 value, bytes memory depositHash) public onlyManager {\r\n        Token storage native = natives[toChainId][isMain];\r\n        require(native.isRun, \"Bridge: chain is not support\");\r\n        if (native.isMain) {\r\n            // 主链跨入\r\n            require(address(this).balance > value, \"Bridge: not enough native token\");\r\n            recipient.transfer(value);\r\n        } else {\r\n            // 侧链跨入\r\n            IERC20 token = IERC20(native.local);\r\n            token.mint(recipient, value);\r\n        }\r\n        emit WithdrawNativeDone(toChainId, recipient, isMain, value, depositHash);\r\n    }\r\n\r\n    receive() external payable {}\r\n}"}}}