{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"fixedMinePoolProxy.sol":{"content":"// File: contracts\\Proxy\\newBaseProxy.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @title  newBaseProxy Contract\r\n\r\n */\r\ncontract newBaseProxy {\r\n    bytes32 private constant implementPositon = keccak256(\"org.Finnexus.implementation.storage\");\r\n    bytes32 private constant proxyOwnerPosition  = keccak256(\"org.Finnexus.Owner.storage\");\r\n    constructor(address implementation_) public {\r\n        // Creator of the contract is admin during initialization\r\n        _setProxyOwner(msg.sender);\r\n        _setImplementation(implementation_);\r\n        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature(\"initialize()\"));\r\n        require(success);\r\n    }\r\n    /**\r\n     * @dev Allows the current owner to transfer ownership\r\n     * @param _newOwner The address to transfer ownership to\r\n     */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner \r\n    {\r\n        require(_newOwner != address(0));\r\n        _setProxyOwner(_newOwner);\r\n    }\r\n    function _setProxyOwner(address _newOwner) internal \r\n    {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            sstore(position, _newOwner)\r\n        }\r\n    }\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n    /**\r\n     * @dev Tells the address of the current implementation\r\n     * @return address of the current implementation\r\n     */\r\n    function getImplementation() public view returns (address impl) {\r\n        bytes32 position = implementPositon;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n    function _setImplementation(address _newImplementation) internal \r\n    {\r\n        bytes32 position = implementPositon;\r\n        assembly {\r\n            sstore(position, _newImplementation)\r\n        }\r\n    }\r\n    function setImplementation(address _newImplementation)public onlyProxyOwner{\r\n        address currentImplementation = getImplementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        (bool success,) = _newImplementation.delegatecall(abi.encodeWithSignature(\"update()\"));\r\n        require(success);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to the implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = getImplementation().delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n\r\n    /**\r\n     * @notice Delegates execution to an implementation contract\r\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\r\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\r\n     * @param data The raw data to delegatecall\r\n     * @return The returned bytes from the delegatecall\r\n     */\r\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return abi.decode(returnData, (bytes));\r\n    }\r\n\r\n    function delegateToViewAndReturn() internal view returns (bytes memory) {\r\n        (bool success, ) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", msg.data));\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize) }\r\n            default { return(add(free_mem_ptr, 0x40), sub(returndatasize, 0x40)) }\r\n        }\r\n    }\r\n\r\n    function delegateAndReturn() internal returns (bytes memory) {\r\n        (bool success, ) = getImplementation().delegatecall(msg.data);\r\n\r\n        assembly {\r\n            let free_mem_ptr := mload(0x40)\r\n            returndatacopy(free_mem_ptr, 0, returndatasize)\r\n\r\n            switch success\r\n            case 0 { revert(free_mem_ptr, returndatasize) }\r\n            default { return(free_mem_ptr, returndatasize) }\r\n        }\r\n    }\r\n        /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require (msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts\\fixedMinePool\\fixedMinePoolProxy.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n/**\r\n * @title FNX period mine pool.\r\n * @dev A smart-contract which distribute some mine coins when user stake FPT-A and FPT-B coins.\r\n *\r\n */\r\ncontract fixedMinePoolProxy is newBaseProxy {\r\n    /**\r\n    * @dev constructor.\r\n    * FPTA FPT-A coin's address,staking coin\r\n    * FPTB FPT-B coin's address,staking coin\r\n    * startTime the start time when this mine pool begin.\r\n    */\r\n    constructor (address implementation_,address FPTA,address FPTB,uint256 startTime) newBaseProxy(implementation_) public{\r\n        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature(\r\n                \"setAddresses(address,address,uint256)\",\r\n                FPTA,\r\n                FPTB,\r\n                startTime));\r\n        require(success);\r\n    }\r\n        /**\r\n     * @dev default function for foundation input miner coins.\r\n     */\r\n    function()external payable{\r\n\r\n    }\r\n        /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address /*newOwner*/) public {\r\n        delegateAndReturn();\r\n    }\r\n    function setHalt(bool /*halt*/) public  {\r\n        delegateAndReturn();\r\n    }\r\n     function addWhiteList(address /*addAddress*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Implementation of revoke an invalid address from the whitelist.\r\n     *  removeAddress revoked address.\r\n     */\r\n    function removeWhiteList(address /*removeAddress*/)public returns (bool){\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Implementation of getting the eligible whitelist.\r\n     */\r\n    function getWhiteList()public view returns (address[] memory){\r\n        delegateToViewAndReturn();\r\n    }\r\n    /**\r\n     * @dev Implementation of testing whether the input address is eligible.\r\n     *  tmpAddress input address for testing.\r\n     */    \r\n    function isEligibleAddress(address /*tmpAddress*/) public view returns (bool){\r\n        delegateToViewAndReturn();\r\n    }\r\n    function setOperator(uint256 /*index*/,address /*addAddress*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    function getOperator(uint256 /*index*/)public view returns (address) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting function. Retrieve FPT-A coin's address\r\n     */\r\n    function getFPTAAddress()public view returns (address) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting function. Retrieve FPT-B coin's address\r\n     */\r\n    function getFPTBAddress()public view returns (address) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting function. Retrieve mine pool's start time.\r\n     */\r\n    function getStartTime()public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting current mine period ID.\r\n     */\r\n    function getCurrentPeriodID()public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting user's staking FPT-A balance.\r\n     * account user's account\r\n     */\r\n    function getUserFPTABalance(address /*account*/)public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting user's staking FPT-B balance.\r\n     * account user's account\r\n     */\r\n    function getUserFPTBBalance(address /*account*/)public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting user's maximium locked period ID.\r\n     * account user's account\r\n     */\r\n    function getUserMaxPeriodId(address /*account*/)public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting user's locked expired time. After this time user can unstake FPTB coins.\r\n     * account user's account\r\n     */\r\n    function getUserExpired(address /*account*/)public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    function getCurrentTotalAPY(address /*mineCoin*/)public view returns (uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev Calculate user's current APY.\r\n     * account user's account.\r\n     * mineCoin mine coin address\r\n     */\r\n    function getUserCurrentAPY(address /*account*/,address /*mineCoin*/)public view returns (uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    function getAverageLockedTime()public view returns (uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev foundation redeem out mine coins.\r\n     *  mineCoin mineCoin address\r\n     *  amount redeem amount.\r\n     */\r\n    function redeemOut(address /*mineCoin*/,uint256 /*amount*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev retrieve total distributed mine coins.\r\n     *  mineCoin mineCoin address\r\n     */\r\n    function getTotalMined(address /*mineCoin*/)public view returns(uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev retrieve minecoin distributed informations.\r\n     *  mineCoin mineCoin address\r\n     * @return distributed amount and distributed time interval.\r\n     */\r\n    function getMineInfo(address /*mineCoin*/)public view returns(uint256,uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev retrieve user's mine balance.\r\n     *  account user's account\r\n     *  mineCoin mineCoin address\r\n     */\r\n    function getMinerBalance(address /*account*/,address /*mineCoin*/)public view returns(uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev Set mineCoin mine info, only foundation owner can invoked.\r\n     *  mineCoin mineCoin address\r\n     *  _mineAmount mineCoin distributed amount\r\n     *  _mineInterval mineCoin distributied time interval\r\n     */\r\n    function setMineCoinInfo(address /*mineCoin*/,uint256 /*_mineAmount*/,uint256 /*_mineInterval*/)public {\r\n        delegateAndReturn();\r\n    }\r\n\r\n    /**\r\n     * @dev user redeem mine rewards.\r\n     *  mineCoin mine coin address\r\n     *  amount redeem amount.\r\n     */\r\n    function redeemMinerCoin(address /*mineCoin*/,uint256 /*amount*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev getting whole pool's mine production weight ratio.\r\n     *      Real mine production equals base mine production multiply weight ratio.\r\n     */\r\n    function getMineWeightRatio()public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev getting whole pool's mine shared distribution. All these distributions will share base mine production.\r\n     */\r\n    function getTotalDistribution() public view returns (uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev convert timestamp to period ID.\r\n     * _time timestamp. \r\n     */ \r\n    function getPeriodIndex(uint256 /*_time*/) public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev convert period ID to period's finish timestamp.\r\n     * periodID period ID. \r\n     */\r\n    function getPeriodFinishTime(uint256 /*periodID*/)public view returns (uint256) {\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev Stake FPT-A coin and get distribution for mining.\r\n     * amount FPT-A amount that transfer into mine pool.\r\n     */\r\n    function stakeFPTA(uint256 /*amount*/)public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Air drop to user some FPT-B coin and lock one period and get distribution for mining.\r\n     * user air drop's recieptor.\r\n     * ftp_b_amount FPT-B amount that transfer into mine pool.\r\n     */\r\n    function lockAirDrop(address /*user*/,uint256 /*ftp_b_amount*/) external{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Stake FPT-B coin and lock locedPreiod and get distribution for mining.\r\n     * amount FPT-B amount that transfer into mine pool.\r\n     * lockedPeriod locked preiod number.\r\n     */\r\n    function stakeFPTB(uint256 /*amount*/,uint256 /*lockedPeriod*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev withdraw FPT-A coin.\r\n     * amount FPT-A amount that withdraw from mine pool.\r\n     */\r\n    function unstakeFPTA(uint256 /*amount*/)public {\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev withdraw FPT-B coin.\r\n     * amount FPT-B amount that withdraw from mine pool.\r\n     */\r\n    function unstakeFPTB(uint256 /*amount*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev Add FPT-B locked period.\r\n     * lockedPeriod FPT-B locked preiod number.\r\n     */\r\n    function changeFPTBLockedPeriod(uint256 /*lockedPeriod*/)public{\r\n        delegateAndReturn();\r\n    }\r\n\r\n       /**\r\n     * @dev retrieve total distributed premium coins.\r\n     */\r\n    function getTotalPremium()public view returns(uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n    /**\r\n     * @dev user redeem his options premium rewards.\r\n     */\r\n    function redeemPremium()public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev user redeem his options premium rewards.\r\n     * amount redeem amount.\r\n     */\r\n    function redeemPremiumCoin(address /*premiumCoin*/,uint256 /*amount*/)public{\r\n        delegateAndReturn();\r\n    }\r\n    /**\r\n     * @dev get user's premium balance.\r\n     * account user's account\r\n     */ \r\n    function getUserLatestPremium(address /*account*/,address /*premiumCoin*/)public view returns(uint256){\r\n        delegateToViewAndReturn(); \r\n    }\r\n \r\n    /**\r\n     * @dev Distribute premium from foundation.\r\n     * periodID period ID\r\n     * amount premium amount.\r\n     */ \r\n    function distributePremium(address /*premiumCoin*/,uint256 /*periodID*/,uint256 /*amount*/)public {\r\n        delegateAndReturn();\r\n    }\r\n        /**\r\n     * @dev Emitted when `account` stake `amount` FPT-A coin.\r\n     */\r\n    event StakeFPTA(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `from` airdrop `recieptor` `amount` FPT-B coin.\r\n     */\r\n    event LockAirDrop(address indexed from,address indexed recieptor,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` stake `amount` FPT-B coin and locked `lockedPeriod` periods.\r\n     */\r\n    event StakeFPTB(address indexed account,uint256 amount,uint256 lockedPeriod);\r\n    /**\r\n     * @dev Emitted when `account` unstake `amount` FPT-A coin.\r\n     */\r\n    event UnstakeFPTA(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` unstake `amount` FPT-B coin.\r\n     */\r\n    event UnstakeFPTB(address indexed account,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` change `lockedPeriod` locked periods for FPT-B coin.\r\n     */\r\n    event ChangeLockedPeriod(address indexed account,uint256 lockedPeriod);\r\n    /**\r\n     * @dev Emitted when owner `account` distribute `amount` premium in `periodID` period.\r\n     */\r\n    event DistributePremium(address indexed account,address indexed premiumCoin,uint256 indexed periodID,uint256 amount);\r\n    /**\r\n     * @dev Emitted when `account` redeem `amount` premium.\r\n     */\r\n    event RedeemPremium(address indexed account,address indexed premiumCoin,uint256 amount);\r\n\r\n    /**\r\n     * @dev Emitted when `account` redeem `value` mineCoins.\r\n     */\r\n    event RedeemMineCoin(address indexed account, address indexed mineCoin, uint256 value);\r\n\r\n}"}}}