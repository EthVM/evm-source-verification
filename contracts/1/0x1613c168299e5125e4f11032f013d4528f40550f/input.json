{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/youswapinvite.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-03-17\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.4;\n\nlibrary ErrorCode {\n\n    string constant FORBIDDEN = 'YouSwap:FORBIDDEN';\n    string constant IDENTICAL_ADDRESSES = 'YouSwap:IDENTICAL_ADDRESSES';\n    string constant ZERO_ADDRESS = 'YouSwap:ZERO_ADDRESS';\n    string constant INVALID_ADDRESSES = 'YouSwap:INVALID_ADDRESSES';\n    string constant BALANCE_INSUFFICIENT = 'YouSwap:BALANCE_INSUFFICIENT';\n    string constant REWARDTOTAL_LESS_THAN_REWARDPROVIDE = 'YouSwap:REWARDTOTAL_LESS_THAN_REWARDPROVIDE';\n    string constant PARAMETER_TOO_LONG = 'YouSwap:PARAMETER_TOO_LONG';\n    string constant REGISTERED = 'YouSwap:REGISTERED';\n\n}\n\ninterface IYouswapInviteV1 {\n\n    struct UserInfo {\n        address upper;//上级\n        address[] lowers;//下级\n        uint256 startBlock;//邀请块高\n    }\n\n    event InviteV1(address indexed owner, address indexed upper, uint256 indexed height);//被邀请人的地址，邀请人的地址，邀请块高\n\n    function inviteCount() external view returns (uint256);//邀请人数\n\n    function inviteUpper1(address) external view returns (address);//上级邀请\n\n    function inviteUpper2(address) external view returns (address, address);//上级邀请\n\n    function inviteLower1(address) external view returns (address[] memory);//下级邀请\n\n    function inviteLower2(address) external view returns (address[] memory, address[] memory);//下级邀请\n\n    function inviteLower2Count(address) external view returns (uint256, uint256);//下级邀请\n    \n    function register() external returns (bool);//注册邀请关系\n\n    function acceptInvitation(address) external returns (bool);//注册邀请关系\n    \n    function inviteBatch(address[] memory) external returns (uint, uint);//注册邀请关系：输入数量，成功数量\n\n}\n\ncontract YouswapInviteV1 is IYouswapInviteV1 {\n\n    address public constant ZERO = address(0);\n    uint256 public startBlock;\n    address[] public inviteUserInfoV1;\n    mapping(address => UserInfo) public inviteUserInfoV2;\n\n    constructor () {\n        startBlock = block.number;\n    }\n    \n    function inviteCount() override external view returns (uint256) {\n        return inviteUserInfoV1.length;\n    }\n\n    function inviteUpper1(address _owner) override external view returns (address) {\n        return inviteUserInfoV2[_owner].upper;\n    }\n\n    function inviteUpper2(address _owner) override external view returns (address, address) {\n        address upper1 = inviteUserInfoV2[_owner].upper;\n        address upper2 = address(0);\n        if (address(0) != upper1) {\n            upper2 = inviteUserInfoV2[upper1].upper;\n        }\n\n        return (upper1, upper2);\n    }\n\n    function inviteLower1(address _owner) override external view returns (address[] memory) {\n        return inviteUserInfoV2[_owner].lowers;\n    }\n\n    function inviteLower2(address _owner) override external view returns (address[] memory, address[] memory) {\n        address[] memory lowers1 = inviteUserInfoV2[_owner].lowers;\n        uint256 count = 0;\n        uint256 lowers1Len = lowers1.length;\n        for (uint256 i = 0; i < lowers1Len; i++) {\n            count += inviteUserInfoV2[lowers1[i]].lowers.length;\n        }\n        address[] memory lowers;\n        address[] memory lowers2 = new address[](count);\n        count = 0;\n        for (uint256 i = 0; i < lowers1Len; i++) {\n            lowers = inviteUserInfoV2[lowers1[i]].lowers;\n            for (uint256 j = 0; j < lowers.length; j++) {\n                lowers2[count] = lowers[j];\n                count++;\n            }\n        }\n        \n        return (lowers1, lowers2);\n    }\n\n    function inviteLower2Count(address _owner) override external view returns (uint256, uint256) {\n        address[] memory lowers1 = inviteUserInfoV2[_owner].lowers;\n        uint256 lowers2Len = 0;\n        uint256 len = lowers1.length;\n        for (uint256 i = 0; i < len; i++) {\n            lowers2Len += inviteUserInfoV2[lowers1[i]].lowers.length;\n        }\n        \n        return (lowers1.length, lowers2Len);\n    }\n\n    function register() override external returns (bool) {\n        UserInfo storage user = inviteUserInfoV2[tx.origin];\n        require(0 == user.startBlock, ErrorCode.REGISTERED);\n        user.upper = ZERO;\n        user.startBlock = block.number;\n        inviteUserInfoV1.push(tx.origin);\n        \n        emit InviteV1(tx.origin, user.upper, user.startBlock);\n        \n        return true;\n    }\n\n    function acceptInvitation(address _inviter) override external returns (bool) {\n        require(msg.sender != _inviter, ErrorCode.FORBIDDEN);\n        UserInfo storage user = inviteUserInfoV2[msg.sender];\n        require(0 == user.startBlock, ErrorCode.REGISTERED);\n        UserInfo storage upper = inviteUserInfoV2[_inviter];\n        if (0 == upper.startBlock) {\n            upper.upper = ZERO;\n            upper.startBlock = block.number;\n            inviteUserInfoV1.push(_inviter);\n            \n            emit InviteV1(_inviter, upper.upper, upper.startBlock);\n        }\n        user.upper = _inviter;\n        upper.lowers.push(msg.sender);\n        user.startBlock = block.number;\n        inviteUserInfoV1.push(msg.sender);\n        \n        emit InviteV1(msg.sender, user.upper, user.startBlock);\n\n        return true;\n    }\n\n    function inviteBatch(address[] memory _invitees) override external returns (uint, uint) {\n        uint len = _invitees.length;\n        require(len <= 100, ErrorCode.PARAMETER_TOO_LONG);\n        UserInfo storage user = inviteUserInfoV2[msg.sender];\n        if (0 == user.startBlock) {\n            user.upper = ZERO;\n            user.startBlock = block.number;\n            inviteUserInfoV1.push(msg.sender);\n                        \n            emit InviteV1(msg.sender, user.upper, user.startBlock);\n        }\n        uint count = 0;\n        for (uint i = 0; i < len; i++) {\n            if ((address(0) != _invitees[i]) && (msg.sender != _invitees[i])) {\n                UserInfo storage lower = inviteUserInfoV2[_invitees[i]];\n                if (0 == lower.startBlock) {\n                    lower.upper = msg.sender;\n                    lower.startBlock = block.number;\n                    user.lowers.push(_invitees[i]);\n                    inviteUserInfoV1.push(_invitees[i]);\n                    count++;\n\n                    emit InviteV1(_invitees[i], msg.sender, lower.startBlock);\n                }\n            }\n        }\n\n        return (len, count);\n    }\n}"}}}