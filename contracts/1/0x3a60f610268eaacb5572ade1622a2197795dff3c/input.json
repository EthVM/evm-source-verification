{
  "language": "Solidity",
  "settings": {
    "evmVersion": "petersburg",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MultiPot.sol": {
      "content": "// SPDX-License-Identifier: NONE\r\n// Â© mia.bet\r\npragma solidity 0.7.3;\r\n\r\ncontract owned {\r\n    address payable public owner;\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only owner can call this function.\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @author The Mia.bet team\r\n * @title Bet processing contract for mia.bet\r\n */\r\ncontract MultiPot is owned {\r\n    enum Color {red, green, blue, yellow, white, orange, black}\r\n    enum State {seeding, accepting_bets, race_in_progress, paying_out, refunding}\r\n    Color public lastWinningColor;\r\n    State public current_state;\r\n    uint8 constant public numPots = 7;\r\n    uint16 public workoutTresholdMeters = 2000;\r\n    uint32 public workoutDeziMeters = 0;\r\n    uint32 public round = 0;\r\n    uint64 public roundStartTime = 0;\r\n    uint public minimumBetAmount = 1000000 gwei; // 0.001 ether\r\n\r\n    struct Pot {\r\n        uint amount;\r\n        address payable[] uniqueGamblers;\r\n        mapping (address => uint) stakes;\r\n    }\r\n\r\n    mapping (uint => Pot) pots;\r\n\r\n\r\n    /**\r\n     * state: seeding\r\n     */\r\n\r\n    function setMinimumBetAmount(uint amount) external onlyOwner {\r\n        require(current_state == State.seeding, \"Not possible in current state\");\r\n        minimumBetAmount = amount;\r\n    }\r\n\r\n    function setWorkoutThresholdMeters(uint16 meters) external onlyOwner {\r\n        require(current_state == State.seeding, \"Not possible in current state\");\r\n        workoutTresholdMeters = meters;\r\n    }\r\n\r\n    function kill() external onlyOwner {\r\n        require(current_state == State.seeding, \"Not possible in current state\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function startNewRound(uint seedAmount) internal {\r\n        roundStartTime = uint64(block.timestamp); // security/no-block-members: see remark at the bottom\r\n        round += 1;\r\n        workoutDeziMeters = 0;\r\n        emit RoundStarted(round, seedAmount);\r\n    }\r\n\r\n    function seedPots() external payable onlyOwner {\r\n        require(current_state == State.seeding, \"Not possible in current state\");\r\n        require(msg.value >= numPots * 1 wei, \"Pots must not have amount 0\");\r\n        uint offset = numPots * round;\r\n        delete pots[offset + uint8(Color.red)];\r\n        delete pots[offset + uint8(Color.green)];\r\n        delete pots[offset + uint8(Color.blue)];\r\n        delete pots[offset + uint8(Color.yellow)];\r\n        delete pots[offset + uint8(Color.white)];\r\n        delete pots[offset + uint8(Color.orange)];\r\n        delete pots[offset + uint8(Color.black)];\r\n        startNewRound(msg.value);\r\n        offset = offset + numPots;\r\n        uint seedAmount = msg.value / numPots;\r\n        for(uint8 j = 0; j < numPots; j++) {\r\n           pots[offset + j].amount = seedAmount;\r\n        }\r\n        transitionTo(State.accepting_bets);\r\n    }\r\n\r\n\r\n    /**\r\n     * state: accepting_bets\r\n     */\r\n\r\n    function placeBet(Color potColor, uint32 bet_round) external payable {\r\n        require(current_state == State.accepting_bets, \"Game has not started yet or a race is already in progress.\");\r\n        require(round == bet_round, \"Bets can only be placed for the current round.\");\r\n        require(msg.value >= minimumBetAmount, \"Your bet must be greater than or equal to the minimum bet amount.\");\r\n        address payable gambler = msg.sender;\r\n        Pot storage pot = pots[uint8(potColor) + numPots * round];\r\n        if (pot.stakes[gambler] == 0) {\r\n            pot.uniqueGamblers.push(gambler);\r\n        }\r\n        pot.stakes[gambler] += msg.value;\r\n        pot.amount += msg.value;\r\n        emit BetPlaced(potColor, msg.value);\r\n    }\r\n\r\n    function miaFinishedWorkout(uint32 dezi_meters) external onlyOwner {\r\n        require(current_state == State.accepting_bets, \"Not possible in current state\");\r\n        emit HamsterRan(dezi_meters);\r\n        workoutDeziMeters += dezi_meters;\r\n\r\n        if (workoutDeziMeters / 10 >= workoutTresholdMeters) {\r\n            transitionTo(State.race_in_progress);\r\n            emit RaceStarted(round);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * state: race_in_progress\r\n     */\r\n\r\n    function setWinningMarble(Color color, uint64 video_id, string calldata photo_id) external onlyOwner {\r\n        require(current_state == State.race_in_progress, \"Not possible in current state\");\r\n        lastWinningColor = color;\r\n        emit WinnerChosen(round, color, video_id, photo_id);\r\n        transitionTo(State.paying_out);\r\n    }\r\n\r\n\r\n    /**\r\n     * state: paying_out\r\n     */\r\n\r\n    function payoutWinners() external returns (uint pendingPayouts) {\r\n        require(current_state == State.paying_out, \"Not possible in current state.\");\r\n        Pot storage winningPot = pots[uint8(lastWinningColor) + numPots * round];\r\n        uint totalPayoutAmount = 0;\r\n        for(uint8 j = 0; j < numPots; j++) {\r\n            // sum up original payout amount (self.balance changes during payouts)\r\n            totalPayoutAmount += pots[j + numPots * round].amount;\r\n        }\r\n        totalPayoutAmount = totalPayoutAmount * 80 / 100; // 20% house fee\r\n        uint winningPotAmount = winningPot.amount;\r\n        for(uint i = winningPot.uniqueGamblers.length; i >= 1; i--) {\r\n            address payable gambler = winningPot.uniqueGamblers[i - 1];\r\n            winningPot.uniqueGamblers.pop();\r\n            uint stake = winningPot.stakes[gambler];\r\n            /* profit = totalPayoutAmount * (stake / winningPotAmount)\r\n               but do the multiplication before the division: */\r\n            uint profit = totalPayoutAmount * stake / winningPotAmount;\r\n            profit = profit >= stake ? profit : stake; // ensure no loss for player (reduces house profit)\r\n            winningPot.stakes[gambler] = 0; // checks-effects-interactions pattern\r\n            if (gambler.send(profit)) { // security/no-send: see remark at the bottom\r\n                emit PayoutSuccessful(gambler, profit, round);\r\n            } else {\r\n                emit PayoutFailed(gambler, profit, round);\r\n            }\r\n            if(!(gasleft() > 26000)) {\r\n                pendingPayouts = i - 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        assert(current_state == State.paying_out);\r\n        if(gasleft() > 400000) { // 400_000 gas for 7 pots\r\n            // payout house fee\r\n            owner.transfer(address(this).balance);\r\n            emit WinnersPaid(round, totalPayoutAmount, lastWinningColor, winningPotAmount);\r\n            // transition to next state\r\n            transitionTo(State.seeding);\r\n        }\r\n        return pendingPayouts;\r\n    }\r\n\r\n\r\n    /**\r\n     * state: refunding\r\n     */\r\n\r\n    function claimRefund() external {\r\n        require(block.timestamp > roundStartTime + 2 days, \"Only possible 2 day after round started.\"); // security/no-block-members: see remark at the bottom\r\n        require(current_state == State.accepting_bets || current_state == State.race_in_progress, \"Not possible in current state.\");\r\n        transitionTo(State.refunding);\r\n    }\r\n\r\n    function refundAll() external returns (uint pendingRefunds) {\r\n        require(current_state == State.refunding, \"Only possible after a successful claimRefund()\");\r\n        for(uint8 i = 0; i < numPots; i++) {\r\n           pendingRefunds = refundPot(pots[i + numPots * round]);\r\n           if (pendingRefunds != 0) break;\r\n        }\r\n        assert(current_state == State.refunding); // assure no state changes in re-entrancy attacks\r\n        if (pendingRefunds == 0) {\r\n            transitionTo(State.seeding);\r\n        }\r\n        return pendingRefunds;\r\n    }\r\n\r\n    function refundPot(Pot storage pot) internal returns (uint pendingRefunds) {\r\n        for(uint i = pot.uniqueGamblers.length; i >= 1; i--) {\r\n            address payable gambler = pot.uniqueGamblers[i - 1];\r\n            pot.uniqueGamblers.pop();\r\n            uint amount = pot.stakes[gambler];\r\n            pot.stakes[gambler] = 0;\r\n            if (gambler.send(amount)) { // security/no-send: see remark at the bottom\r\n                emit RefundSuccessful(gambler, amount);\r\n            } else {\r\n                emit RefundFailed(gambler, amount);\r\n            }\r\n            if(gasleft() < 26000) {\r\n                // stop execution here to let state be saved\r\n                // call function again to continue\r\n                break;\r\n            }\r\n        }\r\n        return pot.uniqueGamblers.length;\r\n    }\r\n\r\n    /**\r\n     * state transition method\r\n     */\r\n    function transitionTo(State newState) internal {\r\n      emit StateChanged(current_state, newState);\r\n      current_state = newState;\r\n    }\r\n\r\n    /**\r\n     * stateless functions\r\n     */\r\n\r\n    function getPotAmounts() external view returns (uint[numPots] memory amounts) {\r\n        for(uint8 j = 0; j < numPots; j++) {\r\n            amounts[j] = pots[j + numPots * round].amount;\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n\r\n    /* events */\r\n    event StateChanged(State from, State to);\r\n    event WinnerChosen(uint32 indexed round, Color color, uint64 video_id, string photo_id);\r\n    event WinnersPaid(uint32 indexed round, uint total_amount, Color color, uint winningPotAmount);\r\n    event PayoutSuccessful(address winner, uint amount, uint32 round);\r\n    event PayoutFailed(address winner, uint amount, uint32 round);\r\n    event RefundSuccessful(address gambler, uint amount);\r\n    event RefundFailed(address gambler, uint amount);\r\n    event RoundStarted(uint32 indexed round, uint total_seed_amount);\r\n    event RaceStarted(uint32 indexed round);\r\n    event BetPlaced(Color pot, uint amount);\r\n    event HamsterRan(uint32 dezi_meters);\r\n}\r\n\r\n/** Further Remarks\r\n * ----------------\r\n *\r\n * Warnings\r\n * - \"security/no-send: Consider using 'transfer' in place of 'send'.\" => We use send, transfer could throw/revert and thus be used in a DOS attack.\r\n * - \"security/no-block-members: Avoid using 'block.timestamp'.\" => Using block.timestamp is safe for time periods greather than 900s [1]. We use 1 day.\r\n *\r\n * Sources\r\n * [1] Is block.timestamp safe for longer time periods? https://ethereum.stackexchange.com/a/9752/44462\r\n */"
    }
  }
}