{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/egorasmicrofinance.sol": {
      "content": "// File: contracts\\SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts\\EgorasMicrofinanceInterface.sol\n\npragma solidity >=0.4.0 <0.7.0;\n// SPDX-License-Identifier: MIT\ninterface EgorasMicrofinanceInterface {\n    struct Loan{\n        uint amount;\n        string title;\n        uint length;\n        uint min_weekly_returns;\n        uint total_returns;\n        string image_url;\n        string companyName;\n        uint totalWeeks;\n        uint numWeekspaid;\n        uint totalPayment;\n        bool isApproved;\n        uint loanFee;\n        address creator;\n    }\nevent LoanCreated(uint newLoanID, uint _amount, string _title, uint _length, uint _min_weekly_returns, uint _total_returns,  \nstring _image_url, string _companyName, uint getTotalWeeks, uint _loanFee, uint countDown, address _creator);\n \n    struct Company{\n        bool isApproved;\n        uint positiveVote;\n        uint negativeVote;\n        uint votingPeriod;\n        bool stale;\n        string companyName;\n        uint registeredDate;\n    }\n\n    event Rewarded(\n        address voter, \n        uint share, \n        uint currentVotingPeriod, \n        uint time\n        );\n        \n      \n    event CompanyCreated(\n        address owner,\n        string companyName,\n        uint votingPeriod\n    );\n    event VotedForRequest(\n        address _voter,\n        uint _requestID,\n        uint _positiveVote,\n        uint _negativeVote,\n        bool _accept\n    );\n    event RequestCreated(\n      address _creator,\n      uint _requestType,\n      uint _changeTo,\n      string _reason,\n      uint _positiveVote,\n      uint _negativeVote,\n      uint _powerUsed,\n      bool _stale,\n      uint _votingPeriod,\n      uint _requestID\n      );\n    event CompanyApproved(\n    address companyAddress,\n    uint now,\n    bool state,\n    address _initiator\n    );\n    event VoteInCompany(\n    address _company,\n    address voter,\n    bool _accept,\n    uint _negativeVote,\n    uint _positiveVote);\n  \n    event ApproveLoan(uint _loanID, bool state, address initiator, uint time);\n    event ApproveRequest(uint _requestID, bool _state, address _initiator);    \n    event LoanRepayment(\n        uint loanID,\n        uint amount,\n        address remitter,\n        uint time\n    );\n    \n    event Refunded(uint amount, address voterAddress, uint _loanID, uint time);\n\n    event Voted(address voter,  uint loanID, uint _positiveVote, uint _negativeVote, bool _accept);\n    event Repay(uint _amount, uint _time, uint _week, uint _loanID);\n\n    function applyForLoan(\n        uint _amount,\n        string calldata _title,\n        uint _length,\n        string calldata _image_url\n        ) external;\n\n    function approveLoanCompany(address companyAddress) external;\n    function registerLoanCompany(string calldata companyName) external;\n    function getLoanByID(uint _loanID) external view returns(uint _amount, uint _min_weekly_returns, uint _totalWeeks, \n    uint _length, string memory _title, uint _total_returns, string memory _image_url, string memory _companyName,  uint _numWeekspaid, uint _totalPayment, bool _isApproved, address _creator);\n    function claimable() external view returns (bool);\n    function isDue(uint _loanID) external view returns (bool);\n    function getVotesByLoanID(uint _loanID) external view returns(uint _accepted, uint _declined);\n    function repayLoan(uint _loanID) external;\n    function approveLoan(uint _loanID) external;\n    function rewardHoldersByVotePower() external;\n    function distributeFee() external;\n    function vote(uint _loanID, uint _votePower, bool _accept) external;\n    function voteinCompany(address _company, uint _votePower, bool _accept) external;\n    function createRequest(uint _requestType, uint _changeTo, string calldata _reason, bool _withdrawEGR) external;\n    function governanceVote(uint _requestType, uint _requestID, uint _votePower, bool _accept) external;\n    function validateRequest(uint _requestID) external;\n    \n}\n\n// File: contracts\\EgorasLending.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0 <0.7.0;\n\n\n\n\ninterface IERC20 {\n    function totalSupply() external view  returns (uint256);\n    function balanceOf(address account) external view  returns (uint256);\n    function transfer(address recipient, uint256 amount) external  returns (bool);\n    function allowance(address owner, address spender) external  view returns (uint256);\n    function approve(address spender, uint256 amount) external  returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)  external  returns (bool);\n    function mint(address account, uint256 amount) external  returns (bool);\n    function burnFrom(address account, uint256 amount) external;\n}\n\ncontract EgorasMicrofinance is EgorasMicrofinanceInterface {\n    mapping(uint => bool) activeRequest;\n    mapping(uint => mapping(address => uint)) requestPower;\n    mapping(address => mapping(address => uint)) VoteInCompanyPower;\n    uint private totalLoans;\n    uint private loanInterestRate;\n    mapping(address => Company) company;\n    mapping (address => bool) companyExist;\n    struct Votters{\n      address payable voter;\n    }\n    \n     struct Requests{\n      address creator;\n      uint requestType;\n      uint changeTo;\n      string reason;\n      uint positiveVote;\n      uint negativeVote;\n      uint powerUsed;\n      bool  withdrawEGR;\n      bool stale;\n      uint votingPeriod;\n    }\n    \n    Requests[] requests;\n    mapping(uint => Requests[]) listOfrequests;\n    mapping(uint => Votters[]) listOfvoters;\n    mapping(uint => Votters[]) etherActiveVotters;\n    mapping(uint => Votters[]) activeVoters;\n    mapping(uint => Votters[]) activeRequestVoters;\n    mapping(address => Votters[]) activeLoanCompanyVoters;\n    mapping(uint => mapping(address => bool)) hasVoted;\n    mapping(uint => mapping(address => bool)) manageRequestVoters;\n    mapping(address => mapping(address => bool)) manageLoanCompanyVoters;\n    mapping(address => mapping(uint => bool)) isCurrentVotter;\n    mapping(address => mapping(uint => bool)) isCurrentEtherVotter;\n    mapping(uint => bool) stale;\n    mapping(uint => mapping(address => uint)) votePower;\n    mapping(address => uint) totalVotePower;\n    mapping(uint => uint) positiveVote;\n    mapping(uint => uint) voteCountDown;\n    mapping(uint => uint) negativeVote;\n    mapping (uint => bool) isLoanApproved;\n    mapping(uint => uint) currentTotalVotePower;\n    mapping(uint => uint) currentTotalVotePower2;\n    uint public nextClaimDate;\n    mapping(address => mapping(uint => uint)) userCurrentVotePower;\n    mapping(address => mapping(uint => uint)) userCurrentVotePower2;\n    Loan[] loans;\n    Votters[] voters;\n    using SafeMath for uint256;\n    address private NGNC;\n    address private egorasEGR;\n    uint private loanFee;\n    uint private systemFeeBalance;\n     \n    uint private currentVotingPeriod;\n    uint private requestCreationPower;\n    uint private currentEtherVotingPeriod;\n    uint public totalIncentive;\n    uint public weeklyIncentive;\n    uint public treasuryCut;\n    constructor(address _NGNC, address _egorasEgr, uint _initialLoanFee, uint _totalIncentive, uint _weeklyIncentive, uint _initialRequestPower\n    , uint _treasuryCut)  public {\n        egorasEGR = _egorasEgr;\n        NGNC = _NGNC;\n        loanFee = _initialLoanFee;\n        currentVotingPeriod = currentVotingPeriod.add(1);\n        currentEtherVotingPeriod = currentEtherVotingPeriod.add(1);\n        totalIncentive = _totalIncentive;\n        weeklyIncentive = _weeklyIncentive;\n        nextClaimDate = block.timestamp.add(8 days);\n        requestCreationPower = _initialRequestPower;\n        treasuryCut = _treasuryCut;\n    }\n\n/// Request\nfunction createRequest(uint _requestType, uint _changeTo, string memory _reason, bool _withdrawEGR) public override{\n    require(_requestType == 0 || _requestType == 1 || _requestType == 2,  \"Invalid request type!\");\n    require(!activeRequest[_requestType], \"Another request is still active\");\n    IERC20 iERC20 = IERC20(egorasEGR);\n    require(iERC20.allowance(msg.sender, address(this)) >= requestCreationPower, \"Insufficient EGR allowance for vote!\");\n    iERC20.transferFrom(msg.sender, address(this), requestCreationPower);\n    Requests memory _request = Requests({\n      creator: msg.sender,\n      requestType: _requestType,\n      changeTo: _changeTo,\n      reason: _reason,\n      positiveVote: 0,\n      negativeVote: 0,\n      powerUsed: requestCreationPower,\n      withdrawEGR: _withdrawEGR,\n      stale: false,\n      votingPeriod: block.timestamp.add(3 days)\n    });\n    \n    requests.push(_request);\n    uint256 newRequestID = requests.length - 1;\n     Requests memory request = requests[newRequestID];\n    emit RequestCreated(\n      request.creator,\n      request.requestType,\n      request.changeTo,\n      request.reason,\n      request.positiveVote,\n      request.negativeVote,\n      request.powerUsed,\n      request.stale,\n      request.votingPeriod,\n      newRequestID\n      );\n}\n\nfunction governanceVote(uint _requestType, uint _requestID, uint _votePower, bool _accept) public override{\n    Requests storage request = requests[_requestID];\n    require(request.votingPeriod >= block.timestamp, \"Voting period ended\");\n    require(_votePower > 0, \"Power must be greater than zero!\");\n    require(_requestType == 0 || _requestType == 1 || _requestType == 2,  \"Invalid request type!\");\n    IERC20 iERC20 = IERC20(egorasEGR);\n    require(iERC20.allowance(msg.sender, address(this)) >= _votePower, \"Insufficient EGR allowance for vote!\");\n    iERC20.transferFrom(msg.sender, address(this), _votePower);\n    requestPower[_requestType][msg.sender] = requestPower[_requestType][msg.sender].add(_votePower);\n     \n     \n       if(_accept){\n            request.positiveVote = request.positiveVote.add(_votePower);\n        }else{\n            request.negativeVote = request.negativeVote.add(_votePower);  \n        }\n      \n           \n            if(manageRequestVoters[_requestID][msg.sender] == false){\n                manageRequestVoters[_requestID][msg.sender] = true;\n                activeRequestVoters[_requestID].push(Votters(msg.sender));\n            }\n       \n           updateVotingStats(_votePower, msg.sender);\n    \n    emit VotedForRequest(msg.sender, _requestID, request.positiveVote, request.negativeVote, _accept);\n    \n}\n\nfunction validateRequest(uint _requestID) public override{\n    Requests storage request = requests[_requestID];\n    require(block.timestamp >= request.votingPeriod, \"Voting period still active\");\n    require(!request.stale, \"This has already been validated\");\n    IERC20 ngnc = IERC20(NGNC);\n    IERC20 egr = IERC20(egorasEGR);\n    if(request.requestType == 0){\n        if(request.positiveVote >= request.negativeVote){\n            loanFee = request.changeTo;\n            request.stale = true;\n            \n        }\n        \n    }else if(request.requestType == 1){\n        if(request.positiveVote >= request.negativeVote){\n            requestCreationPower = request.changeTo;\n            request.stale = true;\n            \n            \n        }\n        \n    }else if(request.requestType == 2){\n        if(request.positiveVote >= request.negativeVote){\n            if(request.withdrawEGR){\n               require(egr.transfer(request.creator, request.changeTo), \"Fail to transfer fund\");\n               }else{\n                require(ngnc.transfer(request.creator, request.changeTo), \"Fail to transfer fund\");\n               }\n            \n            request.stale = true;\n            \n        }\n    }\n    \n   \n    \n   \n    \n    for (uint256 i = 0; i < activeRequestVoters[_requestID].length; i++) {\n           address voterAddress = activeRequestVoters[_requestID][i].voter;\n           uint amount = requestPower[request.requestType][voterAddress];\n           require(egr.transfer(voterAddress, amount), \"Fail to refund voter\");\n           requestPower[request.requestType][voterAddress] = 0;\n           emit Refunded(amount, voterAddress, _requestID, now);\n    }\n    \n     require(egr.transfer(request.creator, request.powerUsed), \"Fail to transfer fund\");\n    emit ApproveRequest(_requestID, request.positiveVote >= request.negativeVote, msg.sender);\n}\n  // Loan\n\n    function applyForLoan(\n        uint _amount,\n        string memory _title,\n        uint _length,\n        string memory _image_url\n        ) public override {\n            require(_amount > 0, \"Loan amount should be greater than zero\");\n            require(_length > 0, \"Loan duration should be greater than zero\");\n            require(bytes(_title).length > 3, \"Loan title should more than three characters long\");\n            require(companyExist[msg.sender], \"Company does not exist\");\n            Company memory comp = company[msg.sender];\n            require(comp.isApproved, \"This company is not eligible to create loan!\");\n            string memory name_of_loan_company = company[msg.sender].companyName;\n            uint getTotalWeeks = _length.div(6);\n            uint amount = _amount.div(getTotalWeeks);\n            uint fee = uint(int256(amount) / int256(10000) * int256(loanFee));\n            uint  weekly_payment = fee.add(amount);\n         Loan memory _loan = Loan({\n         amount: _amount,\n         title: _title,\n         length: _length,\n         min_weekly_returns: weekly_payment,\n         total_returns: weekly_payment.mul(getTotalWeeks),\n         image_url: _image_url,\n         companyName: name_of_loan_company,\n         totalWeeks: getTotalWeeks,\n         numWeekspaid: 0,\n         totalPayment: 0,\n         isApproved: false,\n         loanFee: loanFee,\n         creator: msg.sender\n        });\n             loans.push(_loan);\n             uint256 newLoanID = loans.length - 1;\n             voteCountDown[newLoanID] = block.timestamp.add(3 days);\n             emit LoanCreated(newLoanID, _amount, _title, _length, weekly_payment, weekly_payment.mul(getTotalWeeks),_image_url,  name_of_loan_company, getTotalWeeks, loanFee, block.timestamp.add(3 days), msg.sender);\n        }\n\n    function getLoanByID(uint _loanID) external override view returns(uint _amount, uint _min_weekly_returns, uint _totalWeeks, \n    uint _length, string memory _title, uint _total_returns, string memory _image_url, string memory _companyName, uint _numWeekspaid, uint _totalPayment, bool _isApproved, address _creator){\n         Loan memory loan = loans[_loanID];\n         return (loan.amount, loan.min_weekly_returns,loan.totalWeeks, loan.length, \n         loan.title, loan.total_returns, loan.image_url, loan.companyName, loan.numWeekspaid, loan.totalPayment, loan.isApproved,\n          loan.creator);\n     }\n     \n     function getVotesByLoanID(uint _loanID) external override view returns(uint _accepted, uint _declined){\n            return (positiveVote[_loanID], negativeVote[_loanID]);\n        }\n\nfunction vote(uint _loanID, uint _votePower, bool _accept) external override{\n            require(_votePower > 0, \"Power must be greater than zero!\");\n            IERC20 iERC20 = IERC20(egorasEGR);\n            require(iERC20.allowance(msg.sender, address(this)) >= _votePower, \"Insufficient EGR allowance for vote!\");\n            iERC20.transferFrom(msg.sender, address(this), _votePower);\n            if(_accept){\n                positiveVote[_loanID] = positiveVote[_loanID].add(_votePower);\n            }else{\n              negativeVote[_loanID] = negativeVote[_loanID].add(_votePower);  \n            }\n            \n             \n             votePower[_loanID][msg.sender] = votePower[_loanID][msg.sender].add(_votePower);\n           \n           \n            if(hasVoted[_loanID][msg.sender] == false){\n                hasVoted[_loanID][msg.sender] = true;\n                listOfvoters[_loanID].push(Votters(msg.sender));\n            }\n          updateVotingStats(_votePower, msg.sender);\n     \n            \n            emit Voted(msg.sender, _loanID,  positiveVote[_loanID],negativeVote[_loanID], _accept);\n    } \n       \nfunction repayLoan(uint _loanID) external override{\n   Loan storage loan = loans[_loanID];\n   require(loan.isApproved, \"This loan is not approved yet.\");\n   require(loan.creator == msg.sender, \"Unauthorized.\");\n   IERC20 iERC20 = IERC20(NGNC);\n   require(loan.totalWeeks > loan.numWeekspaid, \"The loan fully paid!\");\n   uint fee = uint(int256(loan.min_weekly_returns) / int256(10000) * int256(loan.loanFee));\n   require(iERC20.allowance(msg.sender, address(this)) >= loan.min_weekly_returns, \"Insufficient EUSD allowance for repayment!\");\n   require(iERC20.transferFrom(msg.sender, address(this), fee), \"Fail to transfer\");\n   iERC20.burnFrom(msg.sender, loan.min_weekly_returns.sub(fee));\n   loan.totalPayment = loan.totalPayment.add(loan.min_weekly_returns);\n  \n   systemFeeBalance = systemFeeBalance.add(fee);\n   loan.numWeekspaid = loan.numWeekspaid.add(1);\n   emit Repay(loan.min_weekly_returns, now, loan.numWeekspaid, _loanID);\n}\n\nfunction approveLoan(uint _loanID) external override{\n     require(isDue(_loanID), \"Voting is not over yet!\");\n     require(!stale[_loanID], \"The loan is either approve/declined\");\n     bool state = false;\n     Loan storage loan = loans[_loanID];\n     IERC20 ngnc = IERC20(NGNC);\n     IERC20 egr = IERC20(egorasEGR);\n     if(positiveVote[_loanID] > negativeVote[_loanID]){\n     require(ngnc.mint(loan.creator, loan.amount), \"Fail to transfer fund\");\n     loan.isApproved = true;\n     state = true;\n     }\n    \n    for (uint256 i = 0; i < listOfvoters[_loanID].length; i++) {\n           address voterAddress = listOfvoters[_loanID][i].voter;\n           uint amount = votePower[_loanID][voterAddress];\n           require(egr.transfer(voterAddress, amount), \"Fail to refund voter\");\n           emit Refunded(amount, voterAddress, _loanID, now);\n    }\n    \n    stale[_loanID] = true;\n    ApproveLoan(_loanID, state, msg.sender, now);\n}\n\n\n// Company\n\n        function registerLoanCompany(string calldata _companyName) external override{\n            require(!companyExist[msg.sender], \"Company already exist!\");\n            Company storage comp = company[msg.sender];\n            uint countDown = block.timestamp.add(3 days);\n            comp.isApproved = false;\n            comp.companyName = _companyName;\n            comp.registeredDate = now;\n            comp.votingPeriod = countDown;\n            companyExist[msg.sender] = true;\n            emit CompanyCreated(msg.sender, _companyName, countDown);\n        }\n\n        function approveLoanCompany(address companyAddress) external override{\n            require(companyExist[companyAddress], \"Company does not exist!\");\n            bool state = false;\n            Company storage comp = company[companyAddress];\n            IERC20 egr = IERC20(egorasEGR);\n           require( block.timestamp >= comp.votingPeriod, \"Voting period still active\");\n            require(!comp.stale, \"This has already been validated\");\n            if(comp.positiveVote >= comp.negativeVote){\n                comp.isApproved = true;\n                state = true;\n            }\n            \n            for (uint256 i = 0; i < activeLoanCompanyVoters[companyAddress].length; i++) {\n                address voterAddress = activeLoanCompanyVoters[companyAddress][i].voter;\n                uint amount = VoteInCompanyPower[companyAddress][voterAddress];\n                require(egr.transfer(voterAddress, amount), \"Fail to refund voter\");\n            }\n            comp.stale = true;\n            emit CompanyApproved(companyAddress, now, state, msg.sender);\n              \n\n        }\n\n\n\n\n        \n   \n        \n        \n    function voteinCompany(address _company, uint _votePower, bool _accept) external override{\n           require(_votePower > 0, \"Power must be greater than zero!\");   \n            IERC20 iERC20 = IERC20(egorasEGR);\n            require(iERC20.allowance(msg.sender, address(this)) >= _votePower, \"Insufficient EGR allowance for vote!\");\n             iERC20.transferFrom(msg.sender, address(this), _votePower);\n             Company storage comp = company[_company];\n              if(_accept){\n                comp.positiveVote = comp.positiveVote.add(_votePower);\n            }else{\n              comp.negativeVote = comp.negativeVote.add(_votePower);  \n            }\n            \n               VoteInCompanyPower[_company][msg.sender] = VoteInCompanyPower[_company][msg.sender].add(_votePower);\n               if(manageLoanCompanyVoters[_company][msg.sender] == false){\n                manageLoanCompanyVoters[_company][msg.sender] = true;\n                activeLoanCompanyVoters[_company].push(Votters(msg.sender));\n            }\n            \n           updateVotingStats(_votePower, msg.sender);\n           \n           emit VoteInCompany(_company,msg.sender, _accept, comp.negativeVote, comp.positiveVote);\n            \n    }\n    \n     \n\n\n\n function updateVotingStats(uint _power, address payable _voter) private {\n      currentTotalVotePower[currentVotingPeriod] = currentTotalVotePower[currentVotingPeriod].add(_power);\n      userCurrentVotePower[_voter][currentVotingPeriod] = userCurrentVotePower[_voter][currentVotingPeriod].add(_power);\n      currentTotalVotePower2[currentEtherVotingPeriod] = currentTotalVotePower2[currentEtherVotingPeriod].add(_power);\n      userCurrentVotePower2[_voter][currentEtherVotingPeriod] = userCurrentVotePower2[_voter][currentEtherVotingPeriod].add(_power);\n             if(isCurrentEtherVotter[_voter][currentEtherVotingPeriod] == false){\n                etherActiveVotters[currentEtherVotingPeriod].push(Votters(_voter));\n            }\n       \n        if(isCurrentVotter[_voter][currentVotingPeriod] == false){\n                activeVoters[currentVotingPeriod].push(Votters(_voter));\n            }\n            \n         totalVotePower[_voter] = totalVotePower[_voter].add(_power);\n          \n }     \n\n\nfunction claimable() public override view returns (bool) {\n        if (block.timestamp >= nextClaimDate)\n            return true;\n        else\n            return false;\n    }\n\nfunction isDue(uint _loanID) public override view returns (bool) {\n        if (block.timestamp >= voteCountDown[_loanID])\n            return true;\n        else\n            return false;\n    }\n\nfunction rewardHoldersByVotePower() external override{\n      IERC20 iERC20 = IERC20(egorasEGR);\n       require(claimable(), \"Not yet time for reward\");\n       uint treasuryShare = uint(int256(weeklyIncentive) / int256(10000) * int256(treasuryCut));\n       uint votersShare = weeklyIncentive.sub(treasuryShare);\n       require(totalIncentive >= treasuryShare, \"No incentive left for distribution\");\n       \n      for (uint256 i = 0; i < activeVoters[currentVotingPeriod].length; i++) {\n            address _voter = activeVoters[currentVotingPeriod][i].voter;\n            uint totalUserVotePower = userCurrentVotePower[_voter][currentVotingPeriod].mul(1000);\n            uint currentTotalPower = currentTotalVotePower[currentVotingPeriod];\n            uint percentage = totalUserVotePower.div(currentTotalPower);\n            uint share = percentage.mul(votersShare).div(1000);\n            require(totalIncentive >= share, \"No incentive left for distribution\");\n            require(iERC20.mint(_voter, share), \"Unable to mint token\");\n            totalIncentive = totalIncentive.sub(share);\n            emit Rewarded(_voter, share, currentVotingPeriod, now);\n            \n        }\n        require(iERC20.mint(address(this), treasuryShare), \"Unable to mint token\");\n        \n         currentVotingPeriod = currentVotingPeriod.add(1);\n         nextClaimDate = block.timestamp.add(8 days);\n}\n\nfunction distributeFee() external override{ \n    uint minEther =  1 ether;\n    uint balance = address(this).balance;\n    require(balance >= minEther, \"Not enough balance\");\n\n        for (uint256 i = 0; i < etherActiveVotters[currentEtherVotingPeriod].length; i++) {\n            address payable _voter = etherActiveVotters[currentVotingPeriod][i].voter;\n            uint totalUserVotePower = userCurrentVotePower2[_voter][currentEtherVotingPeriod].mul(1000);\n            uint currentTotalPower = currentTotalVotePower[currentEtherVotingPeriod];\n            uint percentage = totalUserVotePower.div(currentTotalPower);\n            uint share = percentage.mul(balance).div(1000);\n            require(balance >= share, \"Non-sufficient funds\");\n           _voter.transfer(share);\n            \n            emit Rewarded(_voter, share, currentVotingPeriod, now);\n            \n        }\n        \n         currentEtherVotingPeriod = currentEtherVotingPeriod.add(1);\n         \n}\nfunction depositEther() public payable {\n}\n\nfunction systemInfo() public view  returns(uint _requestpower, uint _loanFee, uint _totalIncentive, uint _weeklyIncentive ,  uint _treasuryCut, uint _nextClaimDate){\n    return(requestCreationPower, loanFee, totalIncentive, weeklyIncentive, treasuryCut, nextClaimDate);\n}\n\n}"
    }
  }
}