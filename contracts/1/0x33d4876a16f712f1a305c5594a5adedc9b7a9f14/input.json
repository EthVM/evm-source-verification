{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DydxFL/compound.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface CTokenInterface {\n    function mint(uint mintAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n\n    function borrowBalanceCurrent(address account) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function exchangeRateCurrent() external returns (uint);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n}\n\ninterface CETHInterface {\n    function mint() external payable;\n    function repayBorrow() external payable;\n}\n\ninterface TokenInterface {\n    function allowance(address, address) external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function approve(address, uint) external;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface ComptrollerInterface {\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n    function exitMarket(address cTokenAddress) external returns (uint);\n}\n\ninterface InstaMapping {\n    function cTokenMapping(address) external view returns (address);\n}\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n    /**\n     * @dev Return ethereum address\n     */\n    function getAddressETH() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n    }\n\n    function getAddressWETH() internal pure returns (address) {\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\n        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // kovan\n    }\n\n    function isETH(address token) internal pure returns(bool) {\n        return token == getAddressETH() || token == getAddressWETH();\n    }\n}\n\n\ncontract CompoundHelpers is Helpers {\n    /**\n     * @dev Return Compound Comptroller Address\n     */\n    function getComptrollerAddress() internal pure returns (address) {\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; // main\n        // return 0x1f5D7F3CaAC149fE41b8bd62A3673FE6eC0AB73b; // kovan\n    }\n\n    /**\n     * @dev Return InstaDApp Mapping Addresses\n     */\n    function getMappingAddr() internal pure returns (address) {\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\n    }\n\n\n    /**\n     * @dev enter compound market\n     */\n    function enterMarket(address cToken) internal {\n        address[] memory cTokens = new address[](1);\n        cTokens[0] = cToken;\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\n        troller.enterMarkets(cTokens);\n    }\n}\n\n\ncontract BasicResolver is CompoundHelpers {\n    event LogDeposit(address indexed token, uint256 tokenAmt);\n    event LogWithdraw(address indexed token);\n    event LogBorrow(address indexed token, uint256 tokenAmt);\n    event LogPayback(address indexed token);\n\n    /**\n     * @dev Deposit ETH/ERC20_Token.\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to deposit.\n    */\n    function deposit(address token, uint amt) external payable{\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n        uint _amt = amt;\n        enterMarket(cToken);\n        if (isETH(token)) {\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\n            CETHInterface(cToken).mint.value(_amt)();\n        } else {\n            TokenInterface tokenContract = TokenInterface(token);\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\n            tokenContract.approve(cToken, _amt);\n            require(CTokenInterface(cToken).mint(_amt) == 0, \"minting-failed\");\n        }\n\n        emit LogDeposit(token, _amt);\n    }\n\n    /**\n     * @dev Withdraw ETH/ERC20_Token.\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to withdraw.\n    */\n    function withdraw(address token, uint amt) external {\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\n        if (amt == uint(-1)) {\n            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, \"full-withdraw-failed\");\n        } else {\n            require(cTokenContract.redeemUnderlying(amt) == 0, \"withdraw-failed\");\n        }\n\n        emit LogWithdraw(token);\n    }\n\n    /**\n     * @dev Borrow ETH/ERC20_Token.\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to borrow.\n    */\n    function borrow(address token, uint amt) external {\n        uint _amt = amt;\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n        enterMarket(cToken);\n        require(CTokenInterface(cToken).borrow(_amt) == 0, \"borrow-failed\");\n\n        emit LogBorrow(token, _amt);\n    }\n\n    /**\n     * @dev Payback borrowed ETH/ERC20_Token.\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to payback.\n    */\n    function payback(address token, uint amt) external {\n        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n        CTokenInterface cTokenContract = CTokenInterface(cToken);\n        uint _amt = amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : amt;\n\n        if (isETH(token)) {\n            require(address(this).balance >= _amt, \"not-enough-eth\");\n            CETHInterface(cToken).repayBorrow.value(_amt)();\n        } else {\n            TokenInterface tokenContract = TokenInterface(token);\n            require(tokenContract.balanceOf(address(this)) >= _amt, \"not-enough-token\");\n            tokenContract.approve(cToken, _amt);\n            require(cTokenContract.repayBorrow(_amt) == 0, \"repay-failed.\");\n        }\n\n        emit LogPayback(token);\n    }\n}\n\ncontract ConnectCompound is BasicResolver {\n    string public name = \"flashloan-Compound-v1.0\";\n}"}}}