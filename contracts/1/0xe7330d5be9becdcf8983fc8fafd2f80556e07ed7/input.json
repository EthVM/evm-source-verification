{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "/*\n██╗     ███████╗██╗  ██╗    \n██║     ██╔════╝╚██╗██╔╝    \n██║     █████╗   ╚███╔╝     \n██║     ██╔══╝   ██╔██╗     \n███████╗███████╗██╔╝ ██╗    \n╚══════╝╚══════╝╚═╝  ╚═╝                                                                             \n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗     \n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    \n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝    \n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    \n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    \n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\nDEAR MSG.SENDER(S):\n/ LXL is a project in beta\n// Please audit & use at your own risk\n/// Entry into LXL shall not create an attorney/client relationship\n//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel\n///// STEAL THIS C0D3SL4W \n~presented by LexDAO LLC \\+|+/ \n*/\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.4;\n\ninterface IERC20 { // brief interface for erc20 token tx\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n}\n\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\n    using Address for address;\n    \n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    \n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returnData) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returnData.length > 0) { // return data is optional\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary SafeMath { // arithmetic wrapper for unit under/overflow check\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n\n        return c;\n    }\n}\n\ncontract Context { // describe current contract execution context (metaTX support) - see openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract ReentrancyGuard { // call wrapper for reentrancy check - see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @title LexLocker.\n * @author LexDAO LLC.\n * @notice Milestone token locker registry with embedded resolution. \n */\ncontract LexLocker is Context, ReentrancyGuard { \n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /*$<⚖️️> LXL <⚔️>$*/\n    address public manager; // account managing LXL settings - see 'Manager Functions' - updateable by manager\n    address public swiftResolverToken; // token required to participate as swift resolver - updateable by manager\n    address public wETH; // ether token wrapper contract reference - updateable by manager\n    uint256 private lockerCount; // lockers counted into LXL registry\n    uint256 public MAX_DURATION; // time limit in seconds on token lockup - default 63113904 (2-year) - updateable by manager\n    uint256 public resolutionRate; // rate to determine resolution fee for disputed locker (e.g., 20 = 5% of remainder) - updateable by manager\n    uint256 public swiftResolverTokenBalance; // balance required in `swiftResolverToken` to participate as swift resolver - updateable by manager\n    string public lockerTerms; // general terms wrapping LXL - updateable by manager\n    string[] public marketTerms; // market terms stamped by manager\n    string[] public resolutions; // locker resolutions stamped by LXL resolver\n    \n    mapping(address => uint256[]) private clientRegistrations; // tracks registered lockers per client account\n    mapping(address => uint256[]) private providerRegistrations; // tracks registered lockers per provider account\n    mapping(address => bool) public swiftResolverConfirmed; // tracks registered swift resolver status\n    mapping(uint256 => ADR) public adrs; // tracks ADR details for registered LXL\n    mapping(uint256 => Locker) public lockers; // tracks registered LXL details\n    \n    event DepositLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\n    event RegisterLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\n    event ConfirmLocker(uint256 registration); \n    event RequestLockerResolution(address indexed client, address indexed counterparty, address indexed resolver, address token, uint256 deposit, uint256 registration, string details, bool swiftResolver); \n    event Release(uint256 milestone, uint256 registration); \n    event Withdraw(uint256 registration);\n    event AssignClientOracle(address indexed clientOracle, uint256 registration);\n    event ClientProposeResolver(address indexed proposedResolver, uint256 registration, string details);\n    event ProviderProposeResolver(address indexed proposedResolver, uint256 registration, string details);\n    event Lock(address indexed caller, uint256 registration, string details);\n    event Resolve(address indexed resolver, uint256 clientAward, uint256 providerAward, uint256 registration, uint256 resolutionFee, string resolution); \n    event AddMarketTerms(uint256 index, string terms);\n    event AmendMarketTerms(uint256 index, string terms);\n    event UpdateLockerSettings(address indexed manager, address indexed swiftResolverToken, address wETH, uint256 MAX_DURATION, uint256 resolutionRate, uint256 swiftResolverTokenBalance, string lockerTerms);\n    event TributeToManager(uint256 amount, string details);\n    event UpdateSwiftResolverStatus(address indexed swiftResolver, string details, bool confirmed);\n\n    struct ADR {  \n        address proposedResolver;\n        address resolver;\n        uint8 clientProposedResolver;\n        uint8 providerProposedResolver;\n\t    uint256 resolutionRate;\n\t    string resolution;\n\t    bool swiftResolver;\n    }\n    \n    struct Locker {  \n        address client; \n        address clientOracle;\n        address provider;\n        address token;\n        uint8 confirmed;\n        uint8 locked;\n        uint256[] amount;\n        uint256 currentMilestone;\n        uint256 milestones;\n        uint256 released;\n        uint256 sum;\n        uint256 termination;\n        string details; \n    }\n    \n    constructor(\n        address _manager, \n        address _swiftResolverToken, \n        address _wETH,\n        uint256 _MAX_DURATION,\n        uint256 _resolutionRate, \n        uint256 _swiftResolverTokenBalance, \n        string memory _lockerTerms\n    ) {\n        manager = _manager;\n        swiftResolverToken = _swiftResolverToken;\n        wETH = _wETH;\n        MAX_DURATION = _MAX_DURATION;\n        resolutionRate = _resolutionRate;\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\n        lockerTerms = _lockerTerms;\n    }\n\n    /***************\n    LOCKER FUNCTIONS\n    ***************/\n    // ************\n    // REGISTRATION\n    // ************\n    /**\n     * @notice LXL can be registered as deposit from `client` for benefit of `provider`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param provider Account to receive registered `amount`s.\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\n     * @param token Token address for `amount` deposit.\n     * @param amount Lump `sum` or array of milestone `amount`s to be sent to `provider` on call of `release()`.\n     * @param termination Exact `termination` date in seconds since epoch.\n     * @param details Context re: LXL.\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\n     */\n    function depositLocker( // CLIENT-TRACK\n        address clientOracle, \n        address provider,\n        address resolver,\n        address token,\n        uint256[] memory amount, \n        uint256 termination, \n        string memory details,\n        bool swiftResolver \n    ) external nonReentrant payable returns (uint256) {\n        require(_msgSender() != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\n        \n        uint256 sum;\n        for (uint256 i = 0; i < amount.length; i++) {\n            sum = sum.add(amount[i]);\n        }\n\n        if (msg.value > 0) {\n            require(token == wETH && msg.value == sum, \"!ethBalance\");\n            (bool success, ) = wETH.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(wETH).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\n        }\n        \n        lockerCount++;\n        uint256 registration = lockerCount;\n       \n        clientRegistrations[_msgSender()].push(registration);\n        providerRegistrations[provider].push(registration);\n        \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n\n        lockers[registration] = Locker( \n            _msgSender(), \n            clientOracle,\n            provider,\n            token,\n            1,\n            0,\n            amount,\n            1,\n            amount.length,\n            0,\n            sum,\n            termination,\n            details);\n\n        emit DepositLocker(_msgSender(), clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    /**\n     * @notice LXL can be registered as `provider` request for `client` deposit (by calling `confirmLocker()`).\n     * @param client Account to provide `sum` deposit and call `release()` of registered `amount`s.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param provider Account to receive registered `amount`s.\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\n     * @param token Token address for `amount` deposit.\n     * @param amount Lump `sum` or array of milestone `amount`s to be sent to `provider` on call of `release()`.\n     * @param termination Exact `termination` date in seconds since epoch.\n     * @param details Context re: LXL.\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\n     */\n    function registerLocker( // PROVIDER-TRACK\n        address client,\n        address clientOracle, \n        address provider,\n        address resolver,\n        address token,\n        uint256[] memory amount, \n        uint256 termination, \n        string memory details,\n        bool swiftResolver \n    ) external nonReentrant returns (uint256) {\n        require(client != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\n        \n        uint256 sum;\n        for (uint256 i = 0; i < amount.length; i++) {\n            sum = sum.add(amount[i]);\n        }\n \n        lockerCount++;\n        uint256 registration = lockerCount;\n        \n        clientRegistrations[client].push(registration);\n        providerRegistrations[provider].push(registration);\n       \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n\n        lockers[registration] = Locker( \n            client, \n            clientOracle,\n            provider,\n            token,\n            0,\n            0,\n            amount,\n            1,\n            amount.length,\n            0,\n            sum,\n            termination,\n            details);\n\n        emit RegisterLocker(client, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    /**\n     * @notice LXL `client` can confirm after `registerLocker()` is called to deposit `sum` for `provider`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n     * @param registration Registered LXL number.\n     */\n    function confirmLocker(uint256 registration) external nonReentrant payable { // PROVIDER-TRACK\n        Locker storage locker = lockers[registration];\n        \n        require(_msgSender() == locker.client, \"!client\");\n        require(locker.confirmed == 0, \"confirmed\");\n        \n        address token = locker.token;\n        uint256 sum = locker.sum;\n        \n        if (msg.value > 0) {\n            require(token == wETH && msg.value == sum, \"!ethBalance\");\n            (bool success, ) = wETH.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(wETH).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\n        }\n        \n        locker.confirmed = 1;\n        \n        emit ConfirmLocker(registration); \n    }\n    \n    /**\n     * @notice LXL depositor (`client`) can request direct resolution between selected `counterparty` over `deposit`. E.g., staked wager to benefit charity as `counterparty`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call. \n     * @param counterparty Other account (`provider`) that can receive award from `resolver`.\n     * @param resolver Account that can call `resolve()` to award `deposit` between LXL parties.\n     * @param token Token address for `deposit`.\n     * @param deposit Lump sum amount for `deposit`.\n     * @param details Context re: resolution request.\n     * @param swiftResolver If `true`, `deposit` can be resolved by holders of `swiftResolverToken`.\n     */\n    function requestLockerResolution(address counterparty, address resolver, address token, uint256 deposit, string memory details, bool swiftResolver) external nonReentrant payable returns (uint256) {\n        require(_msgSender() != resolver && counterparty != resolver, \"client/counterparty = resolver\");\n        \n        if (msg.value > 0) {\n            require(token == wETH && msg.value == deposit, \"!ethBalance\");\n            (bool success, ) = wETH.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(wETH).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), deposit);\n        }\n        \n        uint256[] memory amount = new uint256[](1);\n        amount[0] = deposit;\n        lockerCount++;\n        uint256 registration = lockerCount;\n        \n        clientRegistrations[_msgSender()].push(registration);\n        providerRegistrations[counterparty].push(registration);\n        \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n     \n        lockers[registration] = Locker( \n            _msgSender(), \n            address(0),\n            counterparty,\n            token,\n            1,\n            1,\n            amount,\n            0,\n            0,\n            0,\n            deposit,\n            0,\n            details);\n\n        emit RequestLockerResolution(_msgSender(), counterparty, resolver, token, deposit, registration, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    // ***********\n    // CLIENT MGMT\n    // ***********\n    /**\n     * @notice LXL `client` can assign account as `clientOracle` to help call `release()` and `withdraw()`.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param registration Registered LXL number.\n     */\n    function assignClientOracle(address clientOracle, uint256 registration) external nonReentrant {\n        Locker storage locker = lockers[registration];\n        \n        require(_msgSender() == locker.client, \"!client\");\n        require(locker.locked == 0, \"locked\");\n\t    require(locker.released < locker.sum, \"released\");\n        \n        locker.clientOracle = clientOracle;\n        \n        emit AssignClientOracle(clientOracle, registration);\n    }\n    \n    /**\n     * @notice LXL `client` or `clientOracle` can release milestone `amount` to `provider`. \n     * @param registration Registered LXL number.\n     */\n    function release(uint256 registration) external nonReentrant {\n    \tLocker storage locker = lockers[registration];\n\t    \n\t    require(_msgSender() == locker.client || _msgSender() == locker.clientOracle, \"!client/oracle\");\n\t    require(locker.confirmed == 1, \"!confirmed\");\n\t    require(locker.locked == 0, \"locked\");\n\t    require(locker.released < locker.sum, \"released\");\n        \n        uint256 milestone = locker.currentMilestone-1;\n        uint256 payment = locker.amount[milestone];\n        \n        IERC20(locker.token).safeTransfer(locker.provider, payment);\n        locker.released = locker.released.add(payment);\n        if (locker.released < locker.sum) {locker.currentMilestone++;}\n        \n\t    emit Release(milestone+1, registration); \n    }\n    \n    /**\n     * @notice LXL `client` or `clientOracle` can withdraw `sum` remainder after `termination`. \n     * @dev `release()` can still be called by `client` or `clientOracle` after `termination` to preserve extension option. \n     * @param registration Registered LXL number.\n     */\n    function withdraw(uint256 registration) external nonReentrant {\n    \tLocker storage locker = lockers[registration];\n        \n        require(_msgSender() == locker.client || _msgSender() == locker.clientOracle, \"!client/oracle\");\n        require(locker.confirmed == 1, \"!confirmed\");\n        require(locker.locked == 0, \"locked\");\n        require(locker.released < locker.sum, \"released\");\n        require(locker.termination < block.timestamp, \"!terminated\");\n        \n        uint256 remainder = locker.sum.sub(locker.released); \n        IERC20(locker.token).safeTransfer(locker.client, remainder);\n        locker.released = locker.sum; \n        \n\t    emit Withdraw(registration); \n    }\n    \n    // **********\n    // RESOLUTION\n    // **********\n    /**\n     * @notice LXL `client` or `provider` can lock to freeze release and withdrawal of `sum` remainder until `resolver` calls `resolve()`. \n     * @dev `lock()` can be called repeatedly to allow LXL parties to continue to provide context until resolution. \n     * @param registration Registered LXL number.\n     * @param details Context re: lock / dispute.\n     */\n    function lock(uint256 registration, string calldata details) external nonReentrant {\n        Locker storage locker = lockers[registration]; \n        \n        require(_msgSender() == locker.client || _msgSender() == locker.provider, \"!party\"); \n        require(locker.confirmed == 1, \"!confirmed\");\n        require(locker.released < locker.sum, \"released\");\n\n\t    locker.locked = 1; \n\t    \n\t    emit Lock(_msgSender(), registration, details);\n    }\n    \n    /**\n     * @notice After LXL is locked, selected `resolver` awards `sum` remainder between `client` and `provider` minus fee.\n     * @param clientAward Remainder awarded to `client`.\n     * @param providerAward Remainder awarded to `provider`.\n     * @param registration Registered LXL number.\n     * @param resolution Context re: resolution.\n     */\n    function resolve(uint256 clientAward, uint256 providerAward, uint256 registration, string calldata resolution) external nonReentrant {\n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration];\n        \n        uint256 remainder = locker.sum.sub(locker.released); \n\t    uint256 resolutionFee = remainder.div(adr.resolutionRate); // calculate dispute resolution fee as set on registration\n\t    \n\t    require(_msgSender() != locker.client && _msgSender() != locker.clientOracle && _msgSender() != locker.provider, \"client/clientOracle/provider = resolver\");\n\t    require(locker.locked == 1, \"!locked\"); \n\t    require(locker.released < locker.sum, \"released\");\n\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), \"awards != remainder - fee\");\n\t    \n\t    if (adr.swiftResolver) {\n\t        require(IERC20(swiftResolverToken).balanceOf(_msgSender()) >= swiftResolverTokenBalance && swiftResolverConfirmed[_msgSender()], \"!swiftResolverTokenBalance/confirmed\");\n        } else {\n            require(_msgSender() == adr.resolver, \"!resolver\");\n        }\n\n        IERC20(locker.token).safeTransfer(locker.client, clientAward);\n        IERC20(locker.token).safeTransfer(locker.provider, providerAward);\n        IERC20(locker.token).safeTransfer(adr.resolver, resolutionFee);\n\t    \n\t    adr.resolution = resolution;\n\t    locker.released = locker.sum; \n\t    resolutions.push(resolution);\n\t    \n\t    emit Resolve(_msgSender(), clientAward, providerAward, registration, resolutionFee, resolution);\n    }\n    \n    /**\n     * @notice 1-time, fallback to allow LXL party to suggest new `resolver` to counterparty.\n     * @dev LXL `client` calls to update `resolver` selection - if matches `provider` suggestion or confirmed, `resolver` updates. \n     * @param proposedResolver Proposed account to resolve LXL.\n     * @param registration Registered LXL number.\n     * @param details Context re: proposed `resolver`.\n     */\n    function clientProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration]; \n        \n        require(_msgSender() == locker.client, \"!client\"); \n        require(adr.clientProposedResolver == 0, \"pending\");\n\t    require(locker.released < locker.sum, \"released\");\n        \n        if (adr.proposedResolver == proposedResolver) {\n            adr.resolver = proposedResolver;\n        } else {\n            adr.clientProposedResolver = 0;\n            adr.providerProposedResolver = 0;\n        }\n\n\t    adr.proposedResolver = proposedResolver; \n\t    adr.clientProposedResolver = 1;\n\t    \n\t    emit ClientProposeResolver(proposedResolver, registration, details);\n    }\n    \n    /**\n     * @notice 1-time, fallback to allow LXL party to suggest new `resolver` to counterparty.\n     * @dev LXL `provider` calls to update `resolver` selection - if matches `client` suggestion or confirmed, `resolver` updates. \n     * @param proposedResolver Proposed account to resolve LXL.\n     * @param registration Registered LXL number.\n     * @param details Context re: proposed `resolver`.\n     */\n    function providerProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration]; \n        \n        require(_msgSender() == locker.provider, \"!provider\"); \n        require(adr.providerProposedResolver == 0, \"pending\");\n\t    require(locker.released < locker.sum, \"released\");\n\n\t    if (adr.proposedResolver == proposedResolver) {\n            adr.resolver = proposedResolver;\n        } else {\n            adr.clientProposedResolver = 0;\n            adr.providerProposedResolver = 0;\n        }\n\t    \n\t    adr.proposedResolver = proposedResolver;\n\t    adr.providerProposedResolver = 1;\n\t    \n\t    emit ProviderProposeResolver(proposedResolver, registration, details);\n    }\n    \n    /**\n     * @notice Swift resolvers call to update LXL service status.\n     * @dev Swift resolvers must first confirm to participate and can continue with details / cancel LXL service.  \n     * @param details Context re: status update.\n     * @param confirmed If `true`, swift resolver can participate in LXL resolution.\n     */\n    function updateSwiftResolverStatus(string calldata details, bool confirmed) external nonReentrant {\n        require(IERC20(swiftResolverToken).balanceOf(_msgSender()) >= swiftResolverTokenBalance, \"!swiftResolverTokenBalance\");\n        swiftResolverConfirmed[_msgSender()] = confirmed;\n        emit UpdateSwiftResolverStatus(_msgSender(), details, confirmed);\n    }\n    \n    // *******\n    // GETTERS\n    // *******\n    function getClientRegistrations(address account) external view returns (uint256[] memory) { // get `client` registered lockers \n        return clientRegistrations[account];\n    }\n    \n    function getProviderAmounts(uint256 registration) external view returns (address, uint256[] memory) { // get `token` and milestone `amount`s for `provider`\n        return (lockers[registration].token, lockers[registration].amount);\n    }\n    \n    function getProviderRegistrations(address account) external view returns (uint256[] memory) { // get `provider` registered lockers\n        return providerRegistrations[account];\n    }\n    \n    function getLockerCount() external view returns (uint256) { // get total registered lockers\n        return lockerCount;\n    }\n\n    function getMarketTermsCount() external view returns (uint256) { // get total market terms stamped by `manager`\n        return marketTerms.length;\n    }\n\n    function getResolutionsCount() external view returns (uint256) { // get total resolutions passed by LXL `resolver`s\n        return resolutions.length;\n    }\n   \n    /****************\n    MANAGER FUNCTIONS\n    ****************/\n    /**\n     * @dev Throws if caller is not LXL `manager`.\n     */\n    modifier onlyManager {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n    \n    /**\n     * @notice Updates LXL with new market `terms`. \n     * @param terms New `terms` to add to LXL market. \n     */\n    function addMarketTerms(string calldata terms) external nonReentrant onlyManager {\n        marketTerms.push(terms);\n        emit AddMarketTerms(marketTerms.length-1, terms);\n    }\n    \n    /**\n     * @notice Updates LXL with amended market `terms`. \n     * @param index Targeted location in `marketTerms` array.\n     * @param terms Amended `terms` to add to LXL market. \n     */\n    function amendMarketTerms(uint256 index, string calldata terms) external nonReentrant onlyManager {\n        marketTerms[index] = terms;\n        emit AmendMarketTerms(index, terms);\n    }\n    \n    /**\n     * @notice General ether payment function for `manager` of LXL contract. \n     * @param details Describes context for ether transfer.\n     */\n    function tributeToManager(string calldata details) external nonReentrant payable { \n        (bool success, ) = manager.call{value: msg.value}(\"\");\n        require(success, \"!ethCall\");\n        emit TributeToManager(msg.value, details);\n    }\n    \n    /**\n     * @notice Updates LXL management settings.\n     * @param _manager Account that governs LXL contract settings.\n     * @param _swiftResolverToken Token to mark participants in swift resolution.\n     * @param _wETH Standard contract reference to wrap ether. \n     * @param _MAX_DURATION Time limit in seconds on token lockup - default 63113904 (2-year).\n     * @param _resolutionRate Rate to determine resolution fee for locker (e.g., 20 = 5% of remainder).\n     * @param _swiftResolverTokenBalance Token balance required to perform swift resolution. \n     * @param _lockerTerms General terms wrapping LXL.  \n     */\n    function updateLockerSettings(\n        address _manager, \n        address _swiftResolverToken, \n        address _wETH, \n        uint256 _MAX_DURATION, \n        uint256 _resolutionRate, \n        uint256 _swiftResolverTokenBalance, \n        string calldata _lockerTerms\n    ) external nonReentrant onlyManager { \n        manager = _manager;\n        swiftResolverToken = _swiftResolverToken;\n        wETH = _wETH;\n        MAX_DURATION = _MAX_DURATION;\n        resolutionRate = _resolutionRate;\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\n        lockerTerms = _lockerTerms;\n\t    \n\t    emit UpdateLockerSettings(_manager, _swiftResolverToken, _wETH, _MAX_DURATION, _resolutionRate, _swiftResolverTokenBalance, _lockerTerms);\n    }\n}"
    }
  }
}