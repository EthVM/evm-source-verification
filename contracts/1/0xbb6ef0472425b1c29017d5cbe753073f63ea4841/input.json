{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/BalanceManager.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-03-26\n*/\n\n// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\n\npragma solidity ^0.6.6;\n\ninterface IKeeperRecipient {\n    function keep() external;\n}\n\ninterface IArmorMaster {\n    function registerModule(bytes32 _key, address _module) external;\n    function getModule(bytes32 _key) external view returns(address);\n    function keep() external;\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n * \n * @dev Completely default OpenZeppelin.\n */\ncontract Ownable {\n    address private _owner;\n    address private _pendingOwner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function initializeOwnable() internal {\n        require(_owner == address(0), \"already initialized\");\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"msg.sender is not owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _pendingOwner = newOwner;\n    }\n\n    function receiveOwnership() public {\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\n        _transferOwnership(_pendingOwner);\n        _pendingOwner = address(0);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private __gap;\n}\n\nlibrary Bytes32 {\n    function toString(bytes32 x) internal pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n}\n\n/**\n * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\n**/\ncontract ArmorModule {\n    IArmorMaster internal _master;\n\n    using Bytes32 for bytes32;\n\n    modifier onlyOwner() {\n        require(msg.sender == Ownable(address(_master)).owner(), \"only owner can call this function\");\n        _;\n    }\n\n    modifier doKeep() {\n        _master.keep();\n        _;\n    }\n\n    modifier onlyModule(bytes32 _module) {\n        string memory message = string(abi.encodePacked(\"only module \", _module.toString(),\" can call this function\"));\n        require(msg.sender == getModule(_module), message);\n        _;\n    }\n\n    /**\n     * @dev Used when multiple can call.\n    **/\n    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\n        string memory message = string(abi.encodePacked(\"only module \", _moduleOne.toString(),\" or \", _moduleTwo.toString(),\" can call this function\"));\n        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\n        _;\n    }\n\n    function initializeModule(address _armorMaster) internal {\n        require(address(_master) == address(0), \"already initialized\");\n        require(_armorMaster != address(0), \"master cannot be zero address\");\n        _master = IArmorMaster(_armorMaster);\n    }\n\n    function changeMaster(address _newMaster) external onlyOwner {\n        _master = IArmorMaster(_newMaster);\n    }\n\n    function getModule(bytes32 _key) internal view returns(address) {\n        return _master.getModule(_key);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n * \n * @dev Default OpenZeppelin\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n\n/**\n * @title Balance Expire Traker\n * @dev Keeps track of expiration of user balances.\n**/\ncontract BalanceExpireTracker {\n    \n    using SafeMath for uint64;\n    using SafeMath for uint256;\n    \n    // Don't want to keep typing address(0). Typecasting just for clarity.\n    uint160 private constant EMPTY = uint160(address(0));\n    \n    // 3 days for each step.\n    uint64 public constant BUCKET_STEP = 3 days;\n\n    // indicates where to start from \n    // points where TokenInfo with (expiredAt / BUCKET_STEP) == index\n    mapping(uint64 => Bucket) public checkPoints;\n\n    struct Bucket {\n        uint160 head;\n        uint160 tail;\n    }\n\n    // points first active nft\n    uint160 public head;\n    // points last active nft\n    uint160 public tail;\n\n    // maps expireId to deposit info\n    mapping(uint160 => ExpireMetadata) public infos; \n    \n    // pack data to reduce gas\n    struct ExpireMetadata {\n        uint160 next; // zero if there is no further information\n        uint160 prev;\n        uint64 expiresAt;\n    }\n\n    function expired() internal view returns(bool) {\n        if(infos[head].expiresAt == 0) {\n            return false;\n        }\n\n        if(infos[head].expiresAt <= uint64(now)){\n            return true;\n        }\n\n        return false;\n    }\n\n    // using typecasted expireId to save gas\n    function push(uint160 expireId, uint64 expiresAt) \n      internal \n    {\n        require(expireId != EMPTY, \"info id address(0) cannot be supported\");\n\n        // If this is a replacement for a current balance, remove it's current link first.\n        if (infos[expireId].expiresAt > 0) pop(expireId);\n\n        uint64 bucket = uint64( (expiresAt.div(BUCKET_STEP)).mul(BUCKET_STEP) );\n        if (head == EMPTY) {\n            // all the nfts are expired. so just add\n            head = expireId;\n            tail = expireId;\n            checkPoints[bucket] = Bucket(expireId, expireId);\n            infos[expireId] = ExpireMetadata(EMPTY,EMPTY,expiresAt);\n            \n            return;\n        }\n            \n        // there is active nft. we need to find where to push\n        // first check if this expires faster than head\n        if (infos[head].expiresAt >= expiresAt) {\n            // pushing nft is going to expire first\n            // update head\n            infos[head].prev = expireId;\n            infos[expireId] = ExpireMetadata(head, EMPTY,expiresAt);\n            head = expireId;\n            \n            // update head of bucket\n            Bucket storage b = checkPoints[bucket];\n            b.head = expireId;\n                \n            if(b.tail == EMPTY) {\n                // if tail is zero, this bucket was empty should fill tail with expireId\n                b.tail = expireId;\n            }\n                \n            // this case can end now\n            return;\n        }\n          \n        // then check if depositing nft will last more than latest\n        if (infos[tail].expiresAt <= expiresAt) {\n            infos[tail].next = expireId;\n            // push nft at tail\n            infos[expireId] = ExpireMetadata(EMPTY,tail,expiresAt);\n            tail = expireId;\n            \n            // update tail of bucket\n            Bucket storage b = checkPoints[bucket];\n            b.tail = expireId;\n            \n            if(b.head == EMPTY) {\n              // if head is zero, this bucket was empty should fill head with expireId\n              b.head = expireId;\n            }\n            \n            // this case is done now\n            return;\n        }\n          \n        // so our nft is somewhere in between\n        if (checkPoints[bucket].head != EMPTY) {\n            //bucket is not empty\n            //we just need to find our neighbor in the bucket\n            uint160 cursor = checkPoints[bucket].head;\n        \n            // iterate until we find our nft's next\n            while(infos[cursor].expiresAt < expiresAt){\n                cursor = infos[cursor].next;\n            }\n        \n            infos[expireId] = ExpireMetadata(cursor, infos[cursor].prev, expiresAt);\n            infos[infos[cursor].prev].next = expireId;\n            infos[cursor].prev = expireId;\n        \n            //now update bucket's head/tail data\n            Bucket storage b = checkPoints[bucket];\n            \n            if (infos[b.head].prev == expireId){\n                b.head = expireId;\n            }\n            \n            if (infos[b.tail].next == expireId){\n                b.tail = expireId;\n            }\n        } else {\n            //bucket is empty\n            //should find which bucket has depositing nft's closest neighbor\n            // step 1 find prev bucket\n            uint64 prevCursor = uint64( bucket.sub(BUCKET_STEP) );\n            \n            while(checkPoints[prevCursor].tail == EMPTY){\n              prevCursor = uint64( prevCursor.sub(BUCKET_STEP) );\n            }\n    \n            uint160 prev = checkPoints[prevCursor].tail;\n            uint160 next = infos[prev].next;\n    \n            // step 2 link prev buckets tail - nft - next buckets head\n            infos[expireId] = ExpireMetadata(next,prev,expiresAt);\n            infos[prev].next = expireId;\n            infos[next].prev = expireId;\n    \n            checkPoints[bucket].head = expireId;\n            checkPoints[bucket].tail = expireId;\n        }\n    }\n\n    function pop(uint160 expireId) internal {\n        uint64 expiresAt = infos[expireId].expiresAt;\n        uint64 bucket = uint64( (expiresAt.div(BUCKET_STEP)).mul(BUCKET_STEP) );\n        // check if bucket is empty\n        // if bucket is empty, end\n        if(checkPoints[bucket].head == EMPTY){\n            return;\n        }\n        // if bucket is not empty, iterate through\n        // if expiresAt of current cursor is larger than expiresAt of parameter, reverts\n        for(uint160 cursor = checkPoints[bucket].head; infos[cursor].expiresAt <= expiresAt; cursor = infos[cursor].next) {\n            ExpireMetadata memory info = infos[cursor];\n            // if expiresAt is same of paramter, check if expireId is same\n            if(info.expiresAt == expiresAt && cursor == expireId) {\n                // if yes, delete it\n                // if cursor was head, move head to cursor.next\n                if(head == cursor) {\n                    head = info.next;\n                }\n                // if cursor was tail, move tail to cursor.prev\n                if(tail == cursor) {\n                    tail = info.prev;\n                }\n                // if cursor was head of bucket\n                if(checkPoints[bucket].head == cursor){\n                    // and cursor.next is still in same bucket, move head to cursor.next\n                    if(infos[info.next].expiresAt.div(BUCKET_STEP) == bucket.div(BUCKET_STEP)){\n                        checkPoints[bucket].head = info.next;\n                    } else {\n                        // delete whole checkpoint if bucket is now empty\n                        delete checkPoints[bucket];\n                    }\n                } else if(checkPoints[bucket].tail == cursor){\n                    // since bucket.tail == bucket.haed == cursor case is handled at the above,\n                    // we only have to handle bucket.tail == cursor != bucket.head\n                    checkPoints[bucket].tail = info.prev;\n                }\n                // now we handled all tail/head situation, we have to connect prev and next\n                infos[info.prev].next = info.next;\n                infos[info.next].prev = info.prev;\n                // delete info and end\n                delete infos[cursor];\n                return;\n            }\n            // if not, continue -> since there can be same expires at with multiple expireId\n        }\n        //changed to return for consistency\n        return;\n        //revert(\"Info does not exist\");\n    }\n\n    uint256[50] private __gap;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IBalanceManager {\n  event Deposit(address indexed user, uint256 amount);\n  event Withdraw(address indexed user, uint256 amount);\n  event Loss(address indexed user, uint256 amount);\n  event PriceChange(address indexed user, uint256 price);\n  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\n  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\n  function expireBalance(address _user) external;\n  function deposit(address _referrer) external payable;\n  function withdraw(uint256 _amount) external;\n  function initialize(address _armormaster, address _devWallet) external;\n  function balanceOf(address _user) external view returns (uint256);\n  function perSecondPrice(address _user) external view returns(uint256);\n  function changePrice(address user, uint64 _newPricePerSec) external;\n}\n\ninterface IPlanManager {\n  // Mapping = protocol => cover amount\n  struct Plan {\n      uint64 startTime;\n      uint64 endTime;\n      uint128 length;\n  }\n  \n  struct ProtocolPlan {\n      uint64 protocolId;\n      uint192 amount;\n  }\n    \n  // Event to notify frontend of plan update.\n  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\n  function userCoverageLimit(address _user, address _protocol) external view returns(uint256);\n  function markup() external view returns(uint256);\n  function nftCoverPrice(address _protocol) external view returns(uint256);\n  function initialize(address _armorManager) external;\n  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\n  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\n  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\n  function coverageLeft(address _protocol) external view returns(uint256);\n  function getCurrentPlan(address _user) external view returns(uint256 idx, uint128 start, uint128 end);\n  function updateExpireTime(address _user, uint256 _expiry) external;\n  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\n  function totalUsedCover(address _scAddress) external view returns (uint256);\n}\n\ninterface IRewardDistributionRecipient {\n    function notifyRewardAmount(uint256 reward) payable external;\n}\n\ninterface IRewardManager is IRewardDistributionRecipient {\n  function initialize(address _rewardToken, address _stakeManager) external;\n  function stake(address _user, uint256 _coverPrice, uint256 _nftId) external;\n  function withdraw(address _user, uint256 _coverPrice, uint256 _nftId) external;\n  function getReward(address payable _user) external;\n}\n\ninterface IUtilizationFarm is IRewardDistributionRecipient {\n  function initialize(address _rewardToken, address _stakeManager) external;\n  function stake(address _user, uint256 _coverPrice) external;\n  function withdraw(address _user, uint256 _coverPrice) external;\n  function getReward(address payable _user) external;\n}\n\n/**\n * @dev BorrowManager is where borrowers do all their interaction and it holds funds\n *      until they're sent to the StakeManager.\n **/\ncontract BalanceManager is ArmorModule, IBalanceManager, BalanceExpireTracker {\n\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n\n    // Wallet of the developers for if a developer fee is being paid.\n    address public devWallet;\n\n    // With lastTime and secondPrice we can determine balance by second.\n    struct Balance {\n        uint64 lastTime;\n        uint64 perSecondPrice;\n        uint128 lastBalance;\n    }\n    \n    // keep track of monthly payments and start/end of those\n    mapping (address => Balance) public balances;\n\n    // user => referrer\n    mapping (address => address) public referrers;\n\n    // Percent of funds that go to development--start with 0 and can change.\n    uint128 public devPercent;\n\n    // Percent of funds referrers receive. 20 = 2%.\n    uint128 public refPercent;\n\n    // Percent of funds given to governance stakers.\n    uint128 public govPercent;\n\n    // Denominator used to when distributing tokens 1000 == 100%\n    uint128 public constant DENOMINATOR = 1000;\n\n    // True if utilization farming is still ongoing\n    bool public ufOn;\n\n    // Mapping of shields so we don't reward them for U.F.\n    mapping (address => bool) public arShields;\n     \n    // Block withdrawals within 1 hour of depositing.\n    modifier onceAnHour {\n        require(block.timestamp >= balances[msg.sender].lastTime.add(1 hours), \"You must wait an hour after your last update to withdraw.\");\n        _;\n    }\n\n    /**\n     * @dev Call updateBalance before any action is taken by a user.\n     * @param _user The user whose balance we need to update.\n     **/\n    modifier update(address _user)\n    {\n        uint256 _oldBal = _updateBalance(_user);\n        _;\n        _updateBalanceActions(_user, _oldBal);\n    }\n\n    /**\n     * @dev Keep function can be called by anyone to balances that have been expired. This pays out addresses and removes used cover.\n     *      This is external because the doKeep modifier calls back to ArmorMaster, which then calls back to here (and elsewhere).\n    **/\n    function keep() external {\n        for (uint256 i = 0; i < 2; i++) {\n        \n            if (infos[head].expiresAt != 0 && infos[head].expiresAt <= now) {\n                address oldHead = address(head);\n                uint256 oldBal = _updateBalance(oldHead);\n                _updateBalanceActions(oldHead, oldBal);\n            } else return;\n            \n        }\n    }\n\n    function expireBalance(address _user) external override update(_user) {\n        require(balanceOf(_user) == 0, \"Cannot expire when balance > 0\");\n    }\n\n    /**\n     * @param _armorMaster Address of the ArmorMaster contract.\n     **/\n    function initialize(address _armorMaster, address _devWallet)\n      external\n      override\n    {\n        initializeModule(_armorMaster);\n        devWallet = _devWallet;\n        devPercent = 0;     // 0 %\n        refPercent = 25;    // 2.5%\n        govPercent = 0;     // 0%\n        ufOn = true;\n    }\n\n    /**\n     * @dev Borrower deposits an amount of ETH to pay for coverage.\n     * @param _referrer User who referred the depositor.\n    **/\n    function deposit(address _referrer) \n      external\n      payable\n      override\n      // doKeep\n      update(msg.sender)\n    {\n        if ( referrers[msg.sender] == address(0) ) {\n            referrers[msg.sender] = _referrer != address(0) ? _referrer : devWallet;\n            emit ReferralAdded(_referrer, msg.sender, block.timestamp);\n        }\n        \n        require(msg.value > 0, \"No Ether was deposited.\");\n\n        balances[msg.sender].lastBalance = uint128(balances[msg.sender].lastBalance.add(msg.value));\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Borrower withdraws ETH from their balance.\n     * @param _amount The amount of ETH to withdraw.\n    **/\n    function withdraw(uint256 _amount)\n      external\n      override\n      onceAnHour\n      // doKeep\n      update(msg.sender)\n    {\n        require(_amount > 0, \"Must withdraw more than 0.\");\n        Balance memory balance = balances[msg.sender];\n\n        // Since cost increases per second, it's difficult to estimate the correct amount. Withdraw it all in that case.\n        if (balance.lastBalance > _amount) {\n            balance.lastBalance = uint128( balance.lastBalance.sub(_amount) );\n        } else {\n            _amount = balance.lastBalance;\n            balance.lastBalance = 0;\n        }\n        \n        balances[msg.sender] = balance;\n        msg.sender.transfer(_amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Find the current balance of a user to the second.\n     * @param _user The user whose balance to find.\n     **/\n    function balanceOf(address _user)\n      public\n      view\n      override\n    returns (uint256)\n    {\n        Balance memory balance = balances[_user];\n\n        // We adjust balance on chain based on how many blocks have passed.\n        uint256 lastBalance = balance.lastBalance;\n\n        uint256 timeElapsed = block.timestamp.sub(balance.lastTime);\n        uint256 cost = timeElapsed.mul(balance.perSecondPrice);\n\n        // If the elapsed time has brought balance to 0, make it 0.\n        uint256 newBalance;\n        if (lastBalance > cost) newBalance = lastBalance.sub(cost);\n        else newBalance = 0;\n\n        return newBalance;\n    }\n\n    /**\n     * @dev Send funds to governanceStaker and rewardManager (don't want to have to send them with every transaction).\n    **/\n    function releaseFunds()\n      public\n    {\n       uint256 govBalance = balances[getModule(\"GOVSTAKE\")].lastBalance;\n       // If staking contracts are sent too low of a reward, it can mess up distribution.\n       if (govBalance >= 1 ether / 10) {\n           IRewardManager(getModule(\"GOVSTAKE\")).notifyRewardAmount{value: govBalance}(govBalance);\n           balances[getModule(\"GOVSTAKE\")].lastBalance = 0;\n       }\n       \n       uint256 rewardBalance = balances[getModule(\"REWARD\")].lastBalance;\n       // If staking contracts are sent too low of a reward, it can mess up distribution.\n       if (rewardBalance >= 1 ether / 10) {\n           IRewardManager(getModule(\"REWARD\")).notifyRewardAmount{value: rewardBalance}(rewardBalance);\n           balances[getModule(\"REWARD\")].lastBalance = 0;\n       }\n    }\n\n    function perSecondPrice(address _user)\n      external\n      override\n      view\n    returns(uint256)\n    {\n        Balance memory balance = balances[_user];\n        return balance.perSecondPrice;\n    }\n    \n    /**\n     * @dev PlanManager has the ability to change the price that a user is paying for their insurance.\n     * @param _user The user whose price we are changing.\n     * @param _newPrice the new price per second that the user will be paying.\n     **/\n    function changePrice(address _user, uint64 _newPrice)\n      external\n      override\n      onlyModule(\"PLAN\")\n    {\n        _updateBalance(_user);\n        _priceChange(_user, _newPrice);\n        if (_newPrice > 0) _adjustExpiry(_user, balances[_user].lastBalance.div(_newPrice).add(block.timestamp));\n        else _adjustExpiry(_user, block.timestamp);\n    }\n    \n    /**\n     * @dev Update a borrower's balance to it's adjusted amount.\n     * @param _user The address to be updated.\n     **/\n    function _updateBalance(address _user)\n      internal\n      returns (uint256 oldBalance)\n    {\n        Balance memory balance = balances[_user];\n\n        oldBalance = balance.lastBalance;\n        uint256 newBalance = balanceOf(_user);\n\n        // newBalance should never be greater than last balance.\n        uint256 loss = oldBalance.sub(newBalance);\n    \n        _payPercents(_user, uint128(loss));\n\n        // Update storage balance.\n        balance.lastBalance = uint128(newBalance);\n        balance.lastTime = uint64(block.timestamp);\n        emit Loss(_user, loss);\n        \n        balances[_user] = balance;\n    }\n\n    /**\n     * @dev Actions relating to balance updates.\n     * @param _user The user who we're updating.\n     * @param _oldBal The original balance in the tx.\n    **/\n    function _updateBalanceActions(address _user, uint256 _oldBal)\n      internal\n    {\n        Balance memory balance = balances[_user];\n        if (_oldBal != balance.lastBalance && balance.perSecondPrice > 0) {\n            _notifyBalanceChange(_user, balance.lastBalance, balance.perSecondPrice);\n            _adjustExpiry(_user, balance.lastBalance.div(balance.perSecondPrice).add(block.timestamp));\n        }\n        if (balance.lastBalance == 0 && _oldBal != 0) {\n            _priceChange(_user, 0);\n        }\n    }\n    \n    /**\n     * @dev handle the user's balance change. this will interact with UFB\n     * @param _user user's address\n     * @param _newPrice user's new per sec price\n     **/\n\n    function _priceChange(address _user, uint64 _newPrice) \n      internal \n    {\n        Balance memory balance = balances[_user];\n        uint64 originalPrice = balance.perSecondPrice;\n        \n        if(originalPrice == _newPrice) {\n            // no need to process\n            return;\n        }\n\n        if (ufOn && !arShields[_user]) {\n            if(originalPrice > _newPrice) {\n                // price is decreasing\n                IUtilizationFarm(getModule(\"UFB\")).withdraw(_user, originalPrice.sub(_newPrice));\n            } else {\n                // price is increasing\n                IUtilizationFarm(getModule(\"UFB\")).stake(_user, _newPrice.sub(originalPrice));\n            } \n        }\n        \n        balances[_user].perSecondPrice = _newPrice;\n        emit PriceChange(_user, _newPrice);\n    }\n    \n    /**\n     * @dev Adjust when a balance expires.\n     * @param _user Address of the user whose expiry we're adjusting.\n     * @param _newExpiry New Unix timestamp of expiry.\n    **/\n    function _adjustExpiry(address _user, uint256 _newExpiry)\n      internal\n    {\n        if (_newExpiry == block.timestamp) {\n            BalanceExpireTracker.pop(uint160(_user));\n        } else {\n            BalanceExpireTracker.push(uint160(_user), uint64(_newExpiry));\n        }\n    }\n    \n    /**\n     * @dev Balance has changed so PlanManager's expire time must be either increased or reduced.\n    **/\n    function _notifyBalanceChange(address _user, uint256 _newBalance, uint256 _newPerSec) \n      internal\n    {\n        uint256 expiry = _newBalance.div(_newPerSec).add(block.timestamp);\n        IPlanManager(getModule(\"PLAN\")).updateExpireTime(_user, expiry); \n    }\n    \n    /**\n     * @dev Give rewards to different places.\n     * @param _user User that's being charged.\n     * @param _charged Amount of funds charged to the user.\n    **/\n    function _payPercents(address _user, uint128 _charged)\n      internal\n    {\n        // percents: 20 = 2%.\n        uint128 refAmount = referrers[_user] != address(0) ? _charged * refPercent / DENOMINATOR : 0;\n        uint128 devAmount = _charged * devPercent / DENOMINATOR;\n        uint128 govAmount = _charged * govPercent / DENOMINATOR;\n        uint128 nftAmount = uint128( _charged.sub(refAmount).sub(devAmount).sub(govAmount) );\n        \n        if (refAmount > 0) {\n            balances[ referrers[_user] ].lastBalance = uint128( balances[ referrers[_user] ].lastBalance.add(refAmount) );\n            emit AffiliatePaid(referrers[_user], _user, refAmount, block.timestamp);\n        }\n        if (devAmount > 0) balances[devWallet].lastBalance = uint128( balances[devWallet].lastBalance.add(devAmount) );\n        if (govAmount > 0) balances[getModule(\"GOVSTAKE\")].lastBalance = uint128( balances[getModule(\"GOVSTAKE\")].lastBalance.add(govAmount) );\n        if (nftAmount > 0) balances[getModule(\"REWARD\")].lastBalance = uint128( balances[getModule(\"REWARD\")].lastBalance.add(nftAmount) );\n    }\n    \n    /**\n     * @dev Controller can change how much referrers are paid.\n     * @param _newPercent New percent referrals receive from revenue. 100 == 10%.\n    **/\n    function changeRefPercent(uint128 _newPercent)\n      external\n      onlyOwner\n    {\n        require(_newPercent <= DENOMINATOR, \"new percent cannot be bigger than DENOMINATOR\");\n        refPercent = _newPercent;\n    }\n    \n    /**\n     * @dev Controller can change how much governance is paid.\n     * @param _newPercent New percent that governance will receive from revenue. 100 == 10%.\n    **/\n    function changeGovPercent(uint128 _newPercent)\n      external\n      onlyOwner\n    {\n        require(_newPercent <= DENOMINATOR, \"new percent cannot be bigger than DENOMINATOR\");\n        govPercent = _newPercent;\n    }\n    \n    /**\n     * @dev Controller can change how much developers are paid.\n     * @param _newPercent New percent that devs will receive from revenue. 100 == 10%.\n    **/\n    function changeDevPercent(uint128 _newPercent)\n      external\n      onlyOwner\n    {\n        require(_newPercent <= DENOMINATOR, \"new percent cannot be bigger than DENOMINATOR\");\n        devPercent = _newPercent;\n    }\n    \n    /**\n     * @dev Toggle whether utilization farming should be on or off.\n    **/\n    function toggleUF()\n      external\n      onlyOwner\n    {\n        ufOn = !ufOn;\n    }\n    \n    /**\n     * @dev Toggle whether address is a shield.\n    **/\n    function toggleShield(address _shield)\n      external\n      onlyOwner\n    {\n        arShields[_shield] = !arShields[_shield];\n    }\n\n    // to reset the buckets\n    function resetExpiry(uint160[] calldata _idxs) external onlyOwner {\n        for(uint256 i = 0; i<_idxs.length; i++) {\n            require(infos[_idxs[i]].expiresAt != 0, \"not in linkedlist\");\n            BalanceExpireTracker.pop(_idxs[i]);\n            BalanceExpireTracker.push(_idxs[i], infos[_idxs[i]].expiresAt);\n        }\n    }\n\n    // set desired head and tail\n    function _resetBucket(uint64 _bucket, uint160 _head, uint160 _tail) internal {\n        require(_bucket % BUCKET_STEP == 0, \"INVALID BUCKET\");\n\n        require(\n            infos[infos[_tail].next].expiresAt >= _bucket + BUCKET_STEP &&\n            infos[_tail].expiresAt < _bucket + BUCKET_STEP &&\n            infos[_tail].expiresAt >= _bucket,\n            \"tail is not tail\");\n        require(\n            infos[infos[_head].prev].expiresAt < _bucket &&\n            infos[_head].expiresAt < _bucket + BUCKET_STEP &&\n            infos[_head].expiresAt >= _bucket,\n            \"head is not head\");\n        checkPoints[_bucket].tail = _tail;\n        checkPoints[_bucket].head = _head;\n    }\n\n    function resetBuckets(uint64[] calldata _buckets, uint160[] calldata _heads, uint160[] calldata _tails) external onlyOwner{\n        for(uint256 i = 0 ; i < _buckets.length; i++){\n            _resetBucket(_buckets[i], _heads[i], _tails[i]);\n        }\n    }\n\n    function manualUpdate(address[] calldata _users)\n      external\n    {\n        require(msg.sender == armorKeeper, \"Only keeper may call this.\");\n        for (uint256 i = 0; i < _users.length; i++) {\n            uint256 oldBal = _updateBalance(_users[i]);\n            _updateBalanceActions(_users[i], oldBal);\n        }\n    }\n\n    // Keeper is allowed to update people's balance. It's restricted so that DoS cannot occur through updates.\n    function changeKeeper(address _newKeeper)\n      external\n      onlyOwner\n    {\n        armorKeeper = _newKeeper;\n    }\n\n    address public armorKeeper;\n\n}"
    }
  }
}