{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BHT.sol":{"content":"pragma solidity ^0.5.16;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n// Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n  \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n  \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n}\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\ncontract ERC20 {\r\n    \r\n    function balanceOf(address _address) public view returns (uint256 balance);\r\n    \r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    \r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    \r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    \r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract UniSwap {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\n// Token contract\r\ncontract BHT is ERC20, UniSwap {\r\n    \r\n    string public name = \"Bounty Hunter Token\";\r\n    string public symbol = \"BHT\";\r\n    uint8 public decimals = 18;\r\n    // 总发行量1万个\r\n    uint256 public totalSupply = 10000 * 10**18;\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    // 合约管理者\r\n    address public owner;\r\n    \r\n    /*****************uniswapp配对合约地址************/\r\n    // uniswapp配对合约地址\r\n    address public pairAddress;\r\n    \r\n    /*********************投资这一块*******************/\r\n    // BHC合约的地址\r\n    address public BHCAddress;\r\n    // BHC授权交易\r\n    bytes4 private constant SELECTOR = bytes4(\r\n        keccak256(bytes(\"transfer(address,uint256)\"))\r\n    );\r\n    // 上次提币的时间\r\n    uint256 public lastTime = 0;\r\n    // 30天只能转出一次; 24个小时乘以30天;\r\n    uint256 public monthTime;\r\n    // 提取投资的时间; 24个小时乘以投资的类型的天数;\r\n    uint256 public dayTime;\r\n    // 用户每隔7天可以提现奖励一次;\r\n    uint256 public wTime;\r\n    // 一个只能转出的数量, 一千个\r\n    uint256 tokenNumber = 1000 * 10**18;\r\n    // 地址的投资信息\r\n    struct invest {\r\n        // 投资的类型 30,90,180,3600\r\n        uint256 genre;\r\n        // 开始的时间\r\n        uint256 time;\r\n        // 可提现的时间\r\n        uint256 withdrawTime;\r\n        // 投资的金额BHT\r\n        uint256 money;\r\n        // 赚取的BHC数量; (投资的加赚取的, 但是没有扣除书续费)\r\n        uint256 earnBHC;\r\n        // 可以提现的BHC数量; (扣除手续费之后的数量)\r\n        uint256 withdrawBHC;\r\n        // 是否已经提现\r\n        bool withdraw;\r\n    }\r\n    // 用户的所有投资\r\n    mapping(address => invest[]) public invests;\r\n    // 用户的上级和推广收益, 以及下级数量\r\n    struct inf {\r\n        // 是否注册; ture已注册, false未注册\r\n        bool register;\r\n        // 上级, 也就是推荐人\r\n        address super1;\r\n        // 上上级\r\n        address super2;\r\n        // 下级数量\r\n        uint256 juniors;\r\n        // 推广的奖励; 也是BHC\r\n        uint256 award;\r\n        // 下级投资了多少钱\r\n        uint256 group;\r\n        // 下次可以提现奖励的时间; (每隔7天可以提现一次推荐奖励)\r\n        uint256 time;\r\n    }\r\n    mapping(address => inf) public info;\r\n    // 提现推广奖励的记录\r\n    struct record {\r\n        // 提现的时间\r\n        uint256 time;\r\n        // 提现的金额\r\n        uint256 money;\r\n    }\r\n    mapping(address => record[]) public records;\r\n    \r\n    /*********************投资这一块*******************/\r\n    \r\n    // 构造函数;\r\n    // 主网使用BHC地址, 时间是86400秒(也就是一天);\r\n    // 测试网使用代币地址(0x...); 时间自定义(60) \r\n    constructor(address _BHCAddress, uint256 _day) public {\r\n        balances[address(this)] = totalSupply;\r\n        owner = msg.sender;\r\n        // BHC代币合约地址\r\n        BHCAddress = _BHCAddress;\r\n        // 管理员一个月只能转出一次BHT;\r\n        monthTime = _day * 30;\r\n        // 提取投资的时间; 24个小时乘以投资的类型的天数;\r\n        dayTime = _day;\r\n        // 用户提现的间隔时间;\r\n        wTime = _day * 7;\r\n    }\r\n    \r\n    // 管理员修饰符\r\n    modifier onlyOwner { \r\n        require(msg.sender == owner, \"You are not owner\");\r\n        _;\r\n    }\r\n    \r\n    function balanceOf(address _address) public view returns (uint256 balance) {\r\n        return balances[_address];\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        require(balances[msg.sender] >= _value && _value > 0, \"Insufficient balance or zero amount\");\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\r\n        balances[_to] = SafeMath.add(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(_spender != address(0));\r\n        require((allowed[msg.sender][_spender] == 0) || (_amount == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_from != address(0) && _to != address(0));\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Insufficient balance or zero amount\");\r\n        balances[_from] = SafeMath.sub(balances[_from], _value);\r\n        balances[_to] = SafeMath.add(balances[_to], _value);\r\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    // 更换管理员\r\n    function setOwner(address _owner) public onlyOwner returns (bool success) {\r\n        require(_owner != address(0));\r\n        owner= _owner;\r\n        return true;\r\n    }\r\n    \r\n    /************************************投资这一块***********************************/\r\n    // 已注册修饰符\r\n    modifier onlyRegistered {\r\n        require(info[msg.sender].register, \"You have not registered\");\r\n        _;\r\n    }\r\n    // 已投资的修饰符\r\n    modifier onlyInvest {\r\n        require(invests[msg.sender].length > 0, \"You have not Invest\");\r\n        _;\r\n    }\r\n    \r\n    // 注册事件\r\n    event RegisterInvest(address indexed _super1, address indexed _address);\r\n    // 锁仓投资事件\r\n    event LockedInvest(address indexed _address, uint256 _value, uint256 _genre);\r\n    // 提现锁仓投资事件\r\n    event WithdrawInvest(address indexed _address, uint256 _value);\r\n    // 提现推广奖励事件\r\n    event WithdrawAward(address indexed _address, uint256 _value);\r\n    \r\n    \r\n    // 管理员取出BHT; 每30天只能提币一次, 一次必须是1000个;\r\n    function fetchBHT(address _address) public onlyOwner returns (bool success) {\r\n        // 不能是0地址\r\n        require(_address != address(0));\r\n        require(balances[address(this)] >= tokenNumber, \"Contract insufficient balance\");\r\n        if(lastTime == 0) {\r\n            // 如果上次提币时间是0, 说明这是第一次提币;\r\n            lastTime = block.timestamp;\r\n        }else {\r\n            // 如果不是0, 说明不是第一次提币; 需要判断时间有没有过30天;\r\n            require(lastTime + monthTime < block.timestamp, \"Time is not\");\r\n            lastTime += monthTime;\r\n        }\r\n        balances[_address] = SafeMath.add(balances[_address], tokenNumber);\r\n        balances[address(this)] = SafeMath.sub(balances[address(this)], tokenNumber);\r\n        emit Transfer(address(this), _address, tokenNumber);\r\n        success = true;\r\n    }\r\n    \r\n    // 管理员取出BHC\r\n    function fetchBHC(address _to, uint256 _value) public onlyOwner returns (bool success2) {\r\n        // 不能是0地址\r\n        require(_to != address(0));\r\n        (bool success, ) = BHCAddress.call(\r\n            abi.encodeWithSelector(SELECTOR, _to, _value)\r\n        );\r\n        if(!success) {\r\n            revert(\"transfer fail\");\r\n        }\r\n        success2 = true;\r\n    }\r\n    \r\n    // 管理员设置配对合约地址\r\n    function setPairAddress(address _address) public onlyOwner returns (bool success) {\r\n         // 不能是0地址\r\n        require(_address != address(0));\r\n        pairAddress = _address;\r\n        success = true;\r\n    }\r\n    \r\n    // 注册; 投资之前需要先进行一个注册操作, 梳理下上级身份;\r\n    function registerInvest(address _super1) public returns (bool success) {\r\n        // 注册人必须没有注册过;\r\n        require(!(info[msg.sender].register), \"You have been registered\");\r\n        // 如果推荐人是0地址; 就相当于是没有推荐人, 前端默认的0地址\r\n        if(_super1 == address(0)) {\r\n            // 已注册; 结束\r\n            info[msg.sender].register = true;\r\n            return true;\r\n        }\r\n        // 上级(也就是推荐人)必须是已经注册的地址;\r\n        require(info[_super1].register, \"The referee is not registered\");\r\n        // 修改注册人信息; 已注册, 赋值上级\r\n        info[msg.sender].register = true;\r\n        info[msg.sender].super1 = _super1;\r\n        // 梳理上下级身份, 最多有二级;\r\n        // 先处理上级; 下级数量加1;\r\n        info[_super1].juniors += 1;\r\n        // 判断有没有上上级;\r\n        address super2 = info[_super1].super1;\r\n        if(super2 != address(0)) {\r\n            // 说明有上上级; 注册人添加上上级, 上上级的下级人数加1\r\n            info[msg.sender].super2 = super2;\r\n            info[super2].juniors += 1;\r\n        }\r\n        // 触发注册事件\r\n        emit RegisterInvest(_super1, msg.sender);\r\n        success = true;\r\n    }\r\n    \r\n    // 锁仓投资;\r\n    function lockedInvest(uint256 _value, uint256 _genre) public onlyRegistered returns (bool success) {\r\n        // 锁仓类型只有四种; 30天平均月化8%, 90天平均月化9%, 180天平均月化10%, 360天平均月化12%;\r\n        require(_genre == 30 || _genre == 90 || _genre == 180 || _genre == 360, \"locked position type inexistence\");\r\n        // 判断BHT余额是否足够; 并且投资金额必须大于0;\r\n        require(balances[msg.sender] >= _value && _value > 0, \"Insufficient balance or zero amount\");\r\n        // 把用户投资的币放到合约里\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\r\n        balances[address(this)] = SafeMath.add(balances[address(this)], _value);\r\n        emit Transfer(msg.sender, address(this), _value);\r\n        \r\n        // 计算投资的值对应的BHC数量;\r\n        uint256 _value2 = getPro(_value);\r\n        \r\n        // 可提现时间\r\n        uint256 wt = block.timestamp + dayTime * _genre;\r\n        // 赚取金额BHC数量; (投资+收益, 但没有扣除手续费)\r\n        uint256 eb;\r\n        // 应该给到推广奖励的数量;\r\n        uint256 award1;\r\n        uint256 award2;\r\n        if(_genre == 30) {\r\n            // 计算投资赚取BHC的收益\r\n            eb = _value2 + _value2 * 8/100;\r\n            // 计算上级的推荐奖励\r\n            award1 = _value2 * 8/100 * 20/100;\r\n            award2 = _value2 * 8/100 * 10/100;\r\n        }\r\n        if(_genre == 90) {\r\n            eb = _value2 + _value2 * 9/100 * 3;\r\n            award1 = _value2 * 9/100 * 20/100 * 3;\r\n            award2 = _value2 * 9/100 * 10/100 * 3;\r\n        }\r\n        if(_genre == 180) {\r\n            eb = _value2 + _value2 * 10/100 * 6;\r\n            award1 = _value2 * 10/100 * 20/100 * 6;\r\n            award2 = _value2 * 10/100 * 10/100 * 6;\r\n        }\r\n        if(_genre == 360) {\r\n            eb = _value2 + _value2 * 12/100 * 12;\r\n            award1 = _value2 * 12/100 * 20/100 * 12;\r\n            award2 = _value2 * 12/100 * 10/100 * 12;\r\n        }\r\n        // 可提现的金额BHC数量;\r\n        uint256 wb = eb - (eb * 3/100);\r\n        // 保存用户的投资信息; 类型,时间,可提现时间,投资金额BHT,赚取金额BHC,可以提现的金额BHC,未提现\r\n        invest memory i = invest(_genre, block.timestamp, wt, _value, eb, wb, false);\r\n        invests[msg.sender].push(i);\r\n        \r\n        // 给上级增加奖励;\r\n        address super1 = info[msg.sender].super1;\r\n        address super2 = info[msg.sender].super2;\r\n        if(super1 != address(0)) {\r\n           info[super1].award += award1;\r\n           info[super1].group += _value;\r\n        }\r\n        if(super2 != address(0)) {\r\n          info[super2].award += award2;\r\n          info[super2].group += _value;\r\n        }\r\n        \r\n        // 触发锁仓事件\r\n        emit LockedInvest(msg.sender, _value, _genre);\r\n        success = true;\r\n    }\r\n    \r\n    // 提现锁仓投资; 通过索引进行提现, 提现的币是BHC, 收取的手续费也是BHC, 销毁的BHT\r\n    function withdrawInvest(uint256 _index) public onlyInvest returns (bool success2) {\r\n        // 索引必须小于投资数组的长度\r\n        require(invests[msg.sender].length > _index, \"invest is not\");\r\n        // 先获取索引对应的投资订单;\r\n        invest memory i = invests[msg.sender][_index];\r\n        // 提现时间, 是否提现, 销毁的BHT数量, 用户提现BHC的数量;\r\n        uint256 wt = i.withdrawTime;\r\n        bool w = i.withdraw;\r\n        uint256 m = i.money;\r\n        uint256 wb = i.withdrawBHC;\r\n        // 判断这笔订单是否到达可提现时间\r\n        require(block.timestamp > wt, \"Time is not\");\r\n        // 判断这笔订单是否已经提现\r\n        require(!w, \"already withdraw\");\r\n        \r\n        // 销毁投资的BHT;\r\n        balances[address(this)] = SafeMath.sub(balances[address(this)], m);\r\n        balances[address(0)] = SafeMath.add(balances[address(0)], m);\r\n        emit Transfer(address(this), address(0), m);\r\n        // 用户提现BHC\r\n        (bool success, ) = BHCAddress.call(\r\n            abi.encodeWithSelector(SELECTOR, msg.sender, wb)\r\n        );\r\n        if(!success) {\r\n            revert(\"transfer fail\");\r\n        }\r\n        \r\n        // 修改状态; 已经提现\r\n        invests[msg.sender][_index].withdraw = true;\r\n        // 触发提现锁仓事件\r\n        emit WithdrawInvest(msg.sender, wb);\r\n        success2 = true;\r\n         // 确认; 防止攻击者控制gas\r\n        assert(invests[msg.sender][_index].withdraw);\r\n    }\r\n    \r\n    // 提现推广奖励; 通过金额进行提取\r\n    function withdrawAward(uint256 _money) public onlyInvest returns (bool success2) {\r\n        // 可提现奖励的金额, 可提现的时间\r\n        uint256 m = info[msg.sender].award;\r\n        uint256 t = info[msg.sender].time;\r\n        // 金额判断;\r\n        require(m >= _money, \"The amount is not enough\");\r\n        // 时间判断\r\n        require(t < block.timestamp, \"Time is not\");\r\n        \r\n        // 实际转账的值; 扣除3%的手续费\r\n        uint256 v = _money - (_money * 3/100);\r\n        // 转账\r\n       (bool success, ) = BHCAddress.call(\r\n            abi.encodeWithSelector(SELECTOR, msg.sender, v)\r\n        );\r\n        if(!success) {\r\n            revert(\"transfer fail\");\r\n        }\r\n        // 修改数据\r\n        info[msg.sender].award -= _money;\r\n        // 触发提现推广奖励事件\r\n        emit WithdrawAward(msg.sender, _money);\r\n        // 重新修改可提现时间\r\n        info[msg.sender].time = block.timestamp + wTime;\r\n        // 保存提现记录\r\n        record memory r = record(block.timestamp, _money);\r\n        records[msg.sender].push(r);\r\n        success2 = true;\r\n    }\r\n    \r\n    // 查询用户所有的投资\r\n    function getInvests(address _address) public view returns (invest[] memory r) {\r\n        // 获取所有投资的数量\r\n        uint256 l = invests[_address].length;\r\n        // 创建定长数组对象\r\n        r = new invest[](l);\r\n        for(uint256 i = 0; i < l; i++) {\r\n            r[i] = invests[_address][i];\r\n        }\r\n    }\r\n    \r\n    // 查询用户所有的提现记录\r\n    function getRecords(address _address) public view returns (record[] memory r) {\r\n        // 获取所有投资的数量\r\n        uint256 l = records[_address].length;\r\n        r = new record[](l);\r\n        for(uint256 i = 0; i < l; i++) {\r\n            r[i] = records[_address][i];\r\n        }\r\n    }\r\n    \r\n    // 查询用户的信息\r\n    function getInfo(address _address) public view returns (inf memory r) {\r\n        r = info[_address];\r\n    }\r\n    \r\n    /* ----------------uniswap配对合约的交互----------------- */\r\n    // 重写这个函数\r\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        UniSwap uniswap = UniSwap(pairAddress);\r\n        // 返回的值, 地址小的在前面, 大的在后面\r\n        (_reserve0, _reserve1, _blockTimestampLast) = uniswap.getReserves();\r\n    }\r\n    \r\n    // 根据当时的比例, 给出BHT计算出BHC;\r\n    function getPro(uint256 _value) public view returns (uint256 v) {\r\n        // 显示转换\r\n        (uint256 _reserve0, uint256 _reserve1, ) = getReserves();\r\n        require(address(this) != BHCAddress, \"two address identical\");\r\n        if(address(this) < BHCAddress) {\r\n            // 说明_reserve0对应的BHT, _reserve1对应BHC;\r\n            v = _value * _reserve1 / _reserve0;\r\n        }else {\r\n            v = _value * _reserve0 / _reserve1;\r\n        }\r\n    }\r\n    \r\n  \r\n    \r\n}"}}}