{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/DefiTokenTracker.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\npragma abicoder v2;\r\npragma solidity ^0.8.7;\r\n\r\ncontract DefiTokenTracker {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    struct TokenInfo {\r\n        address token;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct LPTokenInfo {\r\n        address lpToken;\r\n        uint256 balance;\r\n        TokenInfo tokenInfo;\r\n    }\r\n\r\n    struct StakedInfo {\r\n        address chefAddress;\r\n        uint256 index;\r\n        address token;\r\n        uint256 balance;\r\n        LPTokenInfo lpTokenInfo;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        address chefAddress;\r\n        string poolInfoSignature;\r\n        string userInfoSignature;\r\n        uint256 index;\r\n    }\r\n\r\n    address public manager;\r\n    \r\n    modifier onlyManager() {\r\n        require (msg.sender == manager);\r\n        _;\r\n    }\r\n    \r\n    constructor() {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    function getUserTokenInfo(\r\n        address user,\r\n        address token\r\n    )\r\n        public\r\n        view\r\n        returns (TokenInfo memory tokenInfo)\r\n    {\r\n        tokenInfo.token = token;\r\n        tokenInfo.balance = ERC20(token).balanceOf(user);\r\n    }\r\n    \r\n    function getUserLPTokenInfo(\r\n        address user,\r\n        address token,\r\n        address lpToken\r\n    )\r\n        public\r\n        view\r\n        returns (LPTokenInfo memory lpTokenInfo)\r\n    {\r\n        Pair lpTokenPair = Pair(lpToken);\r\n        lpTokenInfo.lpToken = lpToken;\r\n        lpTokenInfo.balance = lpTokenPair.balanceOf(user);\r\n        lpTokenInfo.tokenInfo.token = token;\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = lpTokenPair.getReserves();\r\n        if (lpTokenPair.token0() == token) {\r\n            lpTokenInfo.tokenInfo.balance = \r\n                lpTokenInfo.balance * reserve0 / lpTokenPair.totalSupply();\r\n        } else if (lpTokenPair.token1() == token) {\r\n            lpTokenInfo.tokenInfo.balance =\r\n                lpTokenInfo.balance * reserve1 / lpTokenPair.totalSupply();\r\n        }\r\n    }\r\n\r\n    function getUserLPTokenInfos(\r\n        address user,\r\n        address token,\r\n        address[] memory lpTokens\r\n    )\r\n        public\r\n        view\r\n        returns (LPTokenInfo[] memory lpTokenInfos)\r\n    {\r\n        lpTokenInfos = new LPTokenInfo[](lpTokens.length);\r\n        uint256 lpTokenLength = lpTokens.length;\r\n        for (uint256 i = 0; i < lpTokenLength; i++) {\r\n            lpTokenInfos[i] = getUserLPTokenInfo(\r\n                user,\r\n                token,\r\n                lpTokens[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function getUserStakedInfo(\r\n        address user,\r\n        address token,\r\n        address chefAddress,\r\n        string memory poolInfoSignature,\r\n        string memory userInfoSignature,\r\n        uint256 index\r\n    )\r\n        public\r\n        view\r\n        returns (StakedInfo memory stakedInfo)\r\n    {\r\n        bytes memory poolInfoCallData;\r\n        poolInfoCallData =abi.encodeWithSignature(\r\n            concat(toSlice(poolInfoSignature), toSlice(\"(uint256)\")),\r\n            index\r\n        );\r\n\r\n        (\r\n            bool success,\r\n            bytes memory returnData\r\n        ) = address(chefAddress).staticcall(poolInfoCallData);\r\n\r\n        address poolToken;\r\n        if (success) {\r\n            (poolToken) = abi.decode(returnData, (address));\r\n        }\r\n\r\n        bytes memory callData;\r\n        callData = abi.encodeWithSignature(\r\n            concat(toSlice(userInfoSignature), toSlice(\"(uint256,address)\")),\r\n            index,\r\n            user\r\n        );\r\n\r\n        (\r\n            success,\r\n            returnData\r\n        ) = address(chefAddress).staticcall(callData);\r\n\r\n        stakedInfo.chefAddress = chefAddress;\r\n        stakedInfo.index = index;\r\n        stakedInfo.token = poolToken;\r\n        if (success) {\r\n            (stakedInfo.balance) = abi.decode(returnData, (uint256));\r\n        }\r\n\r\n        Pair poolTokenPair = Pair(poolToken);\r\n        try poolTokenPair.getReserves() returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32\r\n        ) {\r\n            stakedInfo.lpTokenInfo.lpToken = poolToken;\r\n            stakedInfo.lpTokenInfo.balance = stakedInfo.balance;\r\n            stakedInfo.lpTokenInfo.tokenInfo.token = token;\r\n            if (poolTokenPair.token0() == token) {\r\n                stakedInfo.lpTokenInfo.tokenInfo.balance = \r\n                    stakedInfo.balance * reserve0 / poolTokenPair.totalSupply();\r\n            } else if (poolTokenPair.token1() == token) {\r\n                stakedInfo.lpTokenInfo.tokenInfo.balance =\r\n                    stakedInfo.balance * reserve1 / poolTokenPair.totalSupply();\r\n            }\r\n        } catch Error(string memory /*reason*/) {\r\n        } catch (bytes memory /*lowLevelData*/) {\r\n        }\r\n    }\r\n    \r\n    function getUserStakedInfos(\r\n        address user,\r\n        address token,\r\n        PoolInfo[] memory poolInfos\r\n    )\r\n        public\r\n        view\r\n        returns (StakedInfo[]memory stakedInfos)\r\n    {\r\n        stakedInfos = new StakedInfo[](poolInfos.length);\r\n        uint256 poolLength = poolInfos.length;\r\n        for (uint256 i = 0; i < poolLength; i++) {\r\n            stakedInfos[i] = getUserStakedInfo(\r\n                user,\r\n                token,\r\n                poolInfos[i].chefAddress,\r\n                poolInfos[i].poolInfoSignature,\r\n                poolInfos[i].userInfoSignature,\r\n                poolInfos[i].index\r\n            );\r\n        }\r\n    }\r\n\r\n    function getUserInfos(\r\n        address user,\r\n        address token,\r\n        address[] memory lpTokens,\r\n        PoolInfo[] memory poolInfos\r\n    )\r\n        public\r\n        view\r\n        returns\r\n    (\r\n        TokenInfo memory tokenInfo,\r\n        LPTokenInfo[] memory lpTokenInfos,\r\n        StakedInfo[] memory stakedInfos\r\n    )\r\n    {\r\n        tokenInfo = getUserTokenInfo(user, token);\r\n\r\n        lpTokenInfos = new LPTokenInfo[](lpTokens.length);\r\n        lpTokenInfos = getUserLPTokenInfos(user, token, lpTokens);\r\n\r\n        stakedInfos = new StakedInfo[](poolInfos.length);\r\n        stakedInfos = getUserStakedInfos(user, token, poolInfos);\r\n    }\r\n\r\n    function changeManager(address newManager) external onlyManager {\r\n        require(newManager != address(0));\r\n        manager = newManager;\r\n    }\r\n\r\n    function concat(\r\n        slice memory self,\r\n        slice memory other\r\n    )\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n    \r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address _owner) external view returns (uint);\r\n}\r\n\r\ninterface Pair {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n"}}}