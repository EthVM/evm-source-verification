{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/AggregatorV3Interface.sol":{"content":"pragma solidity >=0.4.24;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/AlkemiWETH.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract AlkemiWETH {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    function() public payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(address user, uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        user.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/CarefulMath.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ErrorReporter.sol\";\n\n/**\n * @title Careful Math\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath is ErrorReporter {\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\n        if (a == 0) {\n            return (Error.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (Error.INTEGER_OVERFLOW, 0);\n        } else {\n            return (Error.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint a, uint b) internal pure returns (Error, uint) {\n        if (b == 0) {\n            return (Error.DIVISION_BY_ZERO, 0);\n        }\n\n        return (Error.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\n        if (b <= a) {\n            return (Error.NO_ERROR, a - b);\n        } else {\n            return (Error.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subInt(uint a, uint b) internal pure returns (Error, int) {\n            return (Error.NO_ERROR, int(a - b));\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function add(uint a, uint b) internal pure returns (Error, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (Error.NO_ERROR, c);\n        } else {\n            return (Error.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addInt(uint a, int b) internal pure returns (Error, int) {\n        int c = int(a) + b;\n            return (Error.NO_ERROR, c);\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n        (Error err0, uint sum) = add(a, b);\n\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return sub(sum, c);\n    }\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/ChainLink.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./AggregatorV3Interface.sol\";\nimport './TestTokens.sol';\n\ncontract ChainLink {\n    \n    mapping(address => AggregatorV3Interface) internal priceContractMapping;\n    mapping (address => bool) public assetsWithPriceFeedBasedOnUSD;\n    address public admin;\n    bool public paused = false;\n    address public wethAddress;\n    AggregatorV3Interface public USDETHPriceFeed;\n\n    /**\n     * Sets the initial assets and admin\n     * Add assets and set Weth Address using their own functions\n     */\n    constructor() public {\n        admin = msg.sender;\n    }\n    \n    /**\n     * Modifier to restrict functions only by admins\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"Only the Admin can perform this operation\");\n        _;\n    }\n    \n    /**\n     * Event declarations for all the operations of this contract\n     */\n    event assetAdded(address assetAddress, address priceFeedContract);\n    event assetRemoved(address assetAddress);\n    event adminChanged(address oldAdmin, address newAdmin);\n    event wethAddressSet(address wethAddress);\n    event USDETHPriceFeedSet(address USDETHPriceFeed);\n    event contractPausedOrUnpaused(bool currentStatus);\n\n    /**\n     * Allows admin to add a new asset for price tracking\n     */\n    function addAsset(address assetAddress, address priceFeedContract, bool _assetWithPriceFeedBasedOnUSD) public onlyAdmin {\n        if (_assetWithPriceFeedBasedOnUSD) {\n            require(USDETHPriceFeed != address(0),\"USDETHPriceFeed not set\");\n        }\n        priceContractMapping[assetAddress] = AggregatorV3Interface(priceFeedContract);\n        assetsWithPriceFeedBasedOnUSD[assetAddress] = _assetWithPriceFeedBasedOnUSD;\n        emit assetAdded(assetAddress, priceFeedContract);\n    }\n    \n    /**\n     * Allows admin to remove an existing asset from price tracking\n     */\n    function removeAsset(address assetAddress) public onlyAdmin {\n        priceContractMapping[assetAddress] = AggregatorV3Interface(address(0));\n        emit assetRemoved(assetAddress);\n    }\n    \n    /**\n     * Allows admin to change the admin of the contract\n     */\n    function changeAdmin(address newAdmin) public onlyAdmin {\n        emit adminChanged(admin, newAdmin);\n        admin = newAdmin;\n    }\n\n    /**\n     * Allows admin to set the weth address\n     */\n    function setWethAddress(address _wethAddress) public onlyAdmin {\n        wethAddress = _wethAddress;\n        emit wethAddressSet(_wethAddress);\n    }\n\n    /**\n     * Allows admin to set the weth address\n     */\n    function setUSDETHPriceFeedAddress(AggregatorV3Interface _USDETHPriceFeed) public onlyAdmin {\n        USDETHPriceFeed = _USDETHPriceFeed;\n        emit USDETHPriceFeedSet(_USDETHPriceFeed);\n    }\n\n    /**\n     * Allows admin to pause and unpause the contract\n     */\n    function togglePause() public onlyAdmin {\n        if (paused) {\n            paused = false;\n            emit contractPausedOrUnpaused(false);\n        }\n        else {\n            paused = true;\n            emit contractPausedOrUnpaused(true);\n        }\n    }\n\n    /**\n     * Returns the latest price\n     */\n    function getAssetPrice(address asset) public view returns (uint) {\n        // Return 1 * 10^18 for WETH, otherwise return actual price\n        if(!paused && asset == wethAddress) {\n            return 1000000000000000000;\n        }\n        // Capture the decimals in the ERC20 token\n        uint8 assetDecimals = TestTokens(asset).decimals();\n        if(!paused && priceContractMapping[asset] != address(0)) {\n            (\n                uint80 roundID, \n                int price,\n                uint startedAt,\n                uint timeStamp,\n                uint80 answeredInRound\n            ) = priceContractMapping[asset].latestRoundData();\n            // If the round is not complete yet, timestamp is 0\n            require(timeStamp > 0, \"Round not complete\");\n            // Calculate USD/ETH price for contracts using USD based price feed\n            if(assetsWithPriceFeedBasedOnUSD[asset]) {\n                int priceUSD;\n                (\n                    roundID, \n                    priceUSD,\n                    startedAt,\n                    timeStamp,\n                    answeredInRound\n                ) = USDETHPriceFeed.latestRoundData();\n                // If the round is not complete yet, timestamp is 0\n                require(timeStamp > 0, \"Round not complete\");\n                uint returnedPrice = uint(price) * uint(priceUSD) / (10 ** 8);\n                return returnedPrice;\n            } else {\n                if(price >0) {\n                // Magnify the result based on decimals\n                return (uint(price) * (10 ** (18 - uint(assetDecimals))));\n            }\n            else {\n                return 0;\n            }\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function fallback() public payable {\n        require(msg.sender.send(msg.value),\"Fallback function initiated but refund failed\");\n    }\n}"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/EIP20Interface.sol":{"content":"// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.4.24;\n\n\ncontract EIP20Interface {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    // total amount of tokens\n    uint256 public totalSupply;\n    /**\n     * @param _owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    /**\n     * @notice send `_value` token to `_to` from `msg.sender`\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /**\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /**\n     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @param _value The amount of tokens to be approved for transfer\n     * @return Whether the approval was successful or not\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /**\n     * @param _owner The address of the account owning tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @return Amount of remaining tokens allowed to spent\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/EIP20NonStandardInterface.sol":{"content":"// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.4.24;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n * See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ncontract EIP20NonStandardInterface {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    // total amount of tokens\n    uint256 public totalSupply;\n\n    /**\n     * @param _owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    /**\n     * !!!!!!!!!!!!!!\n     * !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n     * !!!!!!!!!!!!!!\n     *\n     * @notice send `_value` token to `_to` from `msg.sender`\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transfer(address _to, uint256 _value) public;\n\n    /**\n     *\n     * !!!!!!!!!!!!!!\n     * !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n     * !!!!!!!!!!!!!!\n     *\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public;\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /**\n     * @param _owner The address of the account owning tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @return Amount of remaining tokens allowed to spent\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/ErrorReporter.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract ErrorReporter {\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     */\n    event Failure(uint error, uint info, uint detail);\n\n    enum Error {\n        NO_ERROR,\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n        UNAUTHORIZED,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW,\n        DIVISION_BY_ZERO,\n        BAD_INPUT,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_TRANSFER_FAILED,\n        MARKET_NOT_SUPPORTED,\n        SUPPLY_RATE_CALCULATION_FAILED,\n        BORROW_RATE_CALCULATION_FAILED,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_OUT_FAILED,\n        INSUFFICIENT_LIQUIDITY,\n        INSUFFICIENT_BALANCE,\n        INVALID_COLLATERAL_RATIO,\n        MISSING_ASSET_PRICE,\n        EQUITY_INSUFFICIENT_BALANCE,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        ASSET_NOT_PRICED,\n        INVALID_LIQUIDATION_DISCOUNT,\n        INVALID_COMBINED_RISK_PARAMETERS,\n        ZERO_ORACLE_ADDRESS,\n        CONTRACT_PAUSED,\n        KYC_ADMIN_CHECK_FAILED,\n        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\n        LIQUIDATOR_CHECK_FAILED,\n        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\n        WETH_ADDRESS_NOT_SET_ERROR,\n        ETHER_AMOUNT_MISMATCH_ERROR\n    }\n\n    /**\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n        BORROW_CONTRACT_PAUSED,\n        BORROW_MARKET_NOT_SUPPORTED,\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n        BORROW_TRANSFER_OUT_FAILED,\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n        LIQUIDATE_CONTRACT_PAUSED,\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\n        LIQUIDATE_TRANSFER_IN_FAILED,\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_CONTRACT_PAUSED,\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_ASSET_PRICE_CHECK_ORACLE,\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_ORACLE_OWNER_CHECK,\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n        SET_PAUSED_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n        SET_RISK_PARAMETERS_VALIDATION,\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        SUPPLY_CONTRACT_PAUSED,\n        SUPPLY_MARKET_NOT_SUPPORTED,\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        SUPPLY_TRANSFER_IN_FAILED,\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n        SUPPORT_MARKET_FETCH_PRICE_FAILED,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SUPPORT_MARKET_PRICE_CHECK,\n        SUSPEND_MARKET_OWNER_CHECK,\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n        WITHDRAW_CONTRACT_PAUSED,\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        WITHDRAW_TRANSFER_OUT_FAILED,\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE,\n        KYC_ADMIN_CHECK_FAILED,\n        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\n        LIQUIDATOR_CHECK_FAILED,\n        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\n        WETH_ADDRESS_NOT_SET_ERROR,\n        SEND_ETHER_ADMIN_CHECK_FAILED,\n        ETHER_AMOUNT_MISMATCH_ERROR\n    }\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n        return uint(Error.OPAQUE_ERROR);\n    }\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/Exponential.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ErrorReporter.sol\";\nimport \"./CarefulMath.sol\";\n\ncontract Exponential is ErrorReporter, CarefulMath {\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\n    uint constant expScale = 10**18;\n\n    // See TODO on expScale\n    uint constant halfExpScale = expScale/2;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct ExpNegative {\n        int mantissa;\n    }\n\n    uint constant mantissaOne = 10**18;\n    uint constant mantissaOneTenth = 10**17;\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (Error err1, uint rational) = div(scaledNumerator, denom);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExpNegative(Exp memory a, ExpNegative memory b) pure internal returns (Error, Exp memory) {\n        (Error error, int result) = addInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: uint(result)}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExpNegative(Exp memory a, Exp memory b) pure internal returns (Error, ExpNegative memory) {\n        (Error error, int result) = subInt(a.mantissa, b.mantissa);\n\n        return (error, ExpNegative({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\n        /*\n            We are doing this as:\n            getExp(mul(expScale, scalar), divisor.mantissa)\n\n            How it works:\n            Exp = a / b;\n            Scalar = s;\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (Error err0, uint numerator) = mul(expScale, scalar);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == Error.NO_ERROR);\n\n        return (Error.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / 10**18;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if first Exp is greater than second Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n}\n\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/InterestRateModel.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title InterestRateModel Interface\n * @notice Any interest rate model should derive from this contract.\n * @dev These functions are specifically not marked `pure` as implementations of this\n *      contract may read from storage variables.\n */\ncontract InterestRateModel {\n    /**\n     * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\n     * @dev The return value should be scaled by 1e18, thus a return value of\n     *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n     * @param asset The asset to get the interest rate of\n     * @param cash The total cash of the asset in the market\n     * @param borrows The total borrows of the asset in the market\n     * @return Success or failure and the supply interest rate per block scaled by 10e18\n     */\n    function getSupplyRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\n\n    /**\n     * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\n     * @dev The return value should be scaled by 1e18, thus a return value of\n     *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n     * @param asset The asset to get the interest rate of\n     * @param cash The total cash of the asset in the market\n     * @param borrows The total borrows of the asset in the market\n     * @return Success or failure and the borrow interest rate per block scaled by 10e18\n     */\n    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/MoneyMarketV11.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./ChainLink.sol\";\nimport \"./AlkemiWETH.sol\";\n\ncontract MoneyMarketV11 is Exponential, SafeToken {\n\n    uint internal initialInterestIndex;\n    uint internal defaultOriginationFee; \n    uint internal defaultCollateralRatio;\n    uint internal defaultLiquidationDiscount;\n\n    uint internal minimumCollateralRatioMantissa;\n    uint internal maximumLiquidationDiscountMantissa;\n    bool public initializationDone; // To make sure initializer is called only once\n\n    /**\n     * @notice `MoneyMarket` is the core MoneyMarket contract\n     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n     * @notice Hence this contract has an 'initializer' in place of a 'constructor'\n     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n     */\n    function initializer() public {\n        if(initializationDone == false) {\n            initializationDone = true;\n            admin = msg.sender;\n            initialInterestIndex = 10 ** 18;\n            defaultOriginationFee = (10 ** 15); // default is 0.1%\n            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n            originationFee = Exp({mantissa: defaultOriginationFee});\n            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n            // oracle must be configured via _setOracle\n        }\n    }\n\n    /**\n     * @notice Do not pay directly into MoneyMarket, please use `supply`.\n     */\n    function() payable public {\n        revert();\n    }\n\n    /**\n     * @dev pending Administrator for this contract.\n     */\n    address public pendingAdmin;\n\n    /**\n     * @dev Administrator for this contract. Initially set in constructor, but can\n     *      be changed by the admin itself.\n     */\n    address public admin;\n\n    /**\n     * @dev Managers for this contract with limited permissions. Can\n     *      be changed by the admin.\n     */\n    mapping (address => bool) public managers;\n\n    /**\n     * @dev Account allowed to set oracle prices for this contract. Initially set\n     *      in constructor, but can be changed by the admin.\n     */\n    address public oracle;\n\n    /**\n     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n     */\n    ChainLink priceOracle;\n\n    /**\n     * @dev Container for customer balance information written to storage.\n     *\n     *      struct Balance {\n     *        principal = customer total balance with accrued interest after applying the customer's most recent balance-changing action\n     *        interestIndex = the total interestIndex as calculated after applying the customer's most recent balance-changing action\n     *      }\n     */\n    struct Balance {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -> assetAddress -> balance for supplies\n     */\n    mapping(address => mapping(address => Balance)) public supplyBalances;\n\n\n    /**\n     * @dev 2-level map: customerAddress -> assetAddress -> balance for borrows\n     */\n    mapping(address => mapping(address => Balance)) public borrowBalances;\n\n\n    /**\n     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n     *\n     *      struct Market {\n     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n     *         blockNumber = when the other values in this struct were calculated\n     *         totalSupply = total amount of this asset supplied (in asset wei)\n     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n     *     }\n     */\n    struct Market {\n        bool isSupported;\n        uint blockNumber;\n        InterestRateModel interestRateModel;\n\n        uint totalSupply;\n        uint supplyRateMantissa;\n        uint supplyIndex;\n\n        uint totalBorrows;\n        uint borrowRateMantissa;\n        uint borrowIndex;\n    }\n\n    /**\n     * @dev wethAddress to hold the WETH token contract address\n     * set using setWethAddress function\n     */\n    address public wethAddress;\n\n    /**\n     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n     */\n    AlkemiWETH public WETHContract;\n\n    /**\n     * @dev map: assetAddress -> Market\n     */\n    mapping(address => Market) public markets;\n\n    /**\n     * @dev list: collateralMarkets\n     */\n    address[] public collateralMarkets;\n\n    /**\n     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n     *      is initially set in the constructor, but can be changed by the admin.\n     */\n    Exp public collateralRatio;\n\n    /**\n     * @dev originationFee for new borrows.\n     *\n     */\n    Exp public originationFee;\n\n    /**\n     * @dev liquidationDiscount for collateral when liquidating borrows\n     *\n     */\n    Exp public liquidationDiscount;\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    /**\n     * @dev Mapping to identify the list of KYC Admins\n     */\n    mapping(address=>bool) private KYCAdmins;\n    /**\n     * @dev Mapping to identify the list of customers with verified KYC\n     */\n    mapping(address=>bool) private customersWithKYC;\n\n    /**\n     * @dev Mapping to identify the list of customers with Liquidator roles\n     */\n    mapping(address=>bool) private liquidators;\n\n    /**\n     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n    struct SupplyLocalVars {\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n    }\n\n    /**\n     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n\n    struct WithdrawLocalVars {\n        uint withdrawAmount;\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfWithdrawal;\n        uint withdrawCapacity;\n    }\n\n    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n    struct AccountValueLocalVars {\n        address assetAddress;\n        uint collateralMarketsLength;\n\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        Exp supplyTotalValue;\n        Exp sumSupplies;\n\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        Exp borrowTotalValue;\n        Exp sumBorrows;\n    }\n\n    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n    struct PayBorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint repayAmount;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n    }\n\n    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n    struct BorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint borrowAmountWithFee;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfBorrowAmountWithFee;\n    }\n\n    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n    struct LiquidateLocalVars {\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n        address targetAccount;\n        address assetBorrow;\n        address liquidator;\n        address assetCollateral;\n\n        // borrow index and supply index are global to the asset, not specific to the user\n        uint newBorrowIndex_UnderwaterAsset;\n        uint newSupplyIndex_UnderwaterAsset;\n        uint newBorrowIndex_CollateralAsset;\n        uint newSupplyIndex_CollateralAsset;\n\n        // the target borrow's full balance with accumulated interest\n        uint currentBorrowBalance_TargetUnderwaterAsset;\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\n\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\n\n        uint startingBorrowBalance_TargetUnderwaterAsset;\n        uint startingSupplyBalance_TargetCollateralAsset;\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\n\n        uint currentSupplyBalance_TargetCollateralAsset;\n        uint updatedSupplyBalance_TargetCollateralAsset;\n\n        // If liquidator already has a balance of collateralAsset, we will accumulate\n        // interest on it before transferring seized collateral from the borrower.\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\n        // This will be the liquidator's accumulated balance of collateral asset before the liquidation (if any)\n        // plus the amount seized from the borrower.\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n\n        uint newTotalSupply_ProtocolCollateralAsset;\n        uint currentCash_ProtocolUnderwaterAsset;\n        uint updatedCash_ProtocolUnderwaterAsset;\n\n        // cash does not change for collateral asset\n\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n\n        // Why no variables for the interest rates for the collateral asset?\n        // We don't need to calculate new rates for the collateral asset since neither cash nor borrows change\n\n        uint discountedRepayToEvenAmount;\n\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n        uint discountedBorrowDenominatedCollateral;\n\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        uint closeBorrowAmount_TargetUnderwaterAsset;\n        uint seizeSupplyAmount_TargetCollateralAsset;\n\n        Exp collateralPrice;\n        Exp underwaterAssetPrice;\n\n        uint reimburseAmount;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -> assetAddress -> originationFeeBalance for borrows\n     */\n    mapping(address => mapping(address => uint)) public originationFeeBalance;\n\n    /**\n     * @dev Event emitted on successful addition of Weth Address\n     */\n    event WETHAddressSet(address wethAddress);\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event LiquidatorAdded(address Liquidator);\n    event LiquidatorRemoved(address Liquidator);\n\n    /**\n     * @dev emitted when a supply is received\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a origination fee supply is received as admin\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n    /**\n     * @dev emitted when a supply is withdrawn\n     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a new borrow is taken\n     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n     */\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is repaid\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is liquidated\n     *      targetAccount = user whose borrow was liquidated\n     *      assetBorrow = asset borrowed\n     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountRepaid = amount of borrow repaid\n     *      liquidator = account requesting the liquidation\n     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountSeized = amount of collateral seized by liquidator\n     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n     */\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    /**\n     * @dev emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev newOracle - address of new oracle\n     */\n    event NewOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev emitted when new market is supported by admin\n     */\n    event SupportedMarket(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when risk parameters are changed by admin\n     */\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n\n    /**\n     * @dev emitted when origination fee is changed by admin\n     */\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n\n    /**\n     * @dev emitted when market has new interest rate model set\n     */\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when admin withdraws equity\n     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n     */\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n\n    /**\n     * @dev emitted when a supported market is suspended by admin\n     */\n    event SuspendedMarket(address asset);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev KYC Integration\n     */\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event KYCAdminAdded(address KYCAdmin);\n    event KYCAdminRemoved(address KYCAdmin);\n    event KYCCustomerAdded(address KYCCustomer);\n    event KYCCustomerRemoved(address KYCCustomer);\n\n    /**\n     * @dev Modifier to check if the caller of the function is a manager or owner\n     */\n    modifier onlyAdminOrManager {\n        // Check caller = KYCadmin\n        require(msg.sender == admin || managers[msg.sender],\"Only owner or manager can perform operation\");\n        _;\n    }\n\n    /**\n     * @dev Function to emit fail event to frontend\n     */\n    function emitError(Error error, FailureInfo failure) private returns(uint) {\n        return fail(error, failure);\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is a KYC Admin\n     */\n    modifier isKYCAdmin {\n        // Check caller = KYCadmin\n        if (!KYCAdmins[msg.sender]) {\n            emitError(Error.KYC_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_CHECK_FAILED);\n        } else {\n            require(KYCAdmins[msg.sender],\"Operation can only be performed by a KYC Admin\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is KYC verified\n     */\n    modifier isKYCVerifiedCustomer {\n        // Check caller = KYCVerifiedCustomer\n        if (!customersWithKYC[msg.sender]) {\n            revertEtherToUser(msg.sender,msg.value);\n            emitError(Error.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED, FailureInfo.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED);\n        } else {\n            require(customersWithKYC[msg.sender],\"Customer is not KYC Verified\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add KYC Admins\n     */\n    function addKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = true;\n        emit KYCAdminAdded(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove KYC Admins\n     */\n    function removeKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = false;\n        emit KYCAdminRemoved(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to add KYC Customers\n     */\n    function addCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = true;\n        emit KYCCustomerAdded(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to remove KYC Customers\n     */\n    function removeCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = false;\n        emit KYCCustomerRemoved(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch KYC verification status of a customer\n     */\n    function verifyKYC(address customer) public view returns(bool) {\n        return customersWithKYC[customer];\n    }\n\n    /**\n     * @dev Function to fetch KYC Admin status of an admin\n     */\n    function checkKYCAdmin(address _KYCAdmin) public view returns(bool) {\n        return KYCAdmins[_KYCAdmin];\n    }\n\n    /**\n     * @dev Liquidator Integration\n     */\n\n    /**\n     * @dev Modifier to check if the caller of the function is a Liquidator\n     */\n    modifier isLiquidator {\n        // Check caller = Liquidator\n        if (!liquidators[msg.sender]) {\n            emitError(Error.LIQUIDATOR_CHECK_FAILED, FailureInfo.LIQUIDATOR_CHECK_FAILED);\n        } else {\n            require(liquidators[msg.sender],\"Customer is not a Liquidator\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add Liquidators\n     */\n    function addLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = true;\n        emit LiquidatorAdded(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove Liquidators\n     */\n    function removeLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = false;\n        emit LiquidatorRemoved(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch Liquidator status of a customer\n     */\n    function verifyLiquidator(address liquidator) public view returns(bool) {\n        return liquidators[liquidator];\n    }\n\n    /**\n     * @dev Simple function to calculate min between two numbers.\n     */\n    function min(uint a, uint b) pure internal returns (uint) {\n        if (a < b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *      This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n     *      Note: this will not add the asset if it already exists.\n     */\n    function addCollateralMarket(address asset) internal {\n        for (uint i = 0; i < collateralMarkets.length; i++) {\n            if (collateralMarkets[i] == asset) {\n                return;\n            }\n        }\n\n        collateralMarkets.push(asset);\n    }\n\n    /**\n     * @notice return the number of elements in `collateralMarkets`\n     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n     * @return the length of `collateralMarkets`\n     */\n    function getCollateralMarketsLength() public view returns (uint) {\n        return collateralMarkets.length;\n    }\n\n    /**\n     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n     */\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n\n        // Get the block delta\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        // Scale the interest rate times number of blocks\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n        if (err2 != Error.NO_ERROR) {\n            return (err2, 0);\n        }\n\n        // Then scale that accumulated interest by the old interest index to get the new interest index\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n        if (err3 != Error.NO_ERROR) {\n            return (err3, 0);\n        }\n\n        // Finally, truncate the interest index. This works only if interest index starts large enough\n        // that is can be accurately represented with a whole number.\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n    }\n\n    /**\n     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n     *      This is defined as: `The user's last balance checkpoint is multiplied by the currentSupplyIndex\n     *      value and divided by the user's checkpoint index value`\n     *\n     *      TODO: Is there a way to handle this that is less likely to overflow?\n     */\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n        if (startingBalance == 0) {\n            // We are accumulating interest on any previous balance; if there's no previous balance, then there is\n            // nothing to accumulate.\n            return (Error.NO_ERROR, 0);\n        }\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return div(balanceTimesIndex, interestIndexStart);\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset.\n     */\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n     */\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory scaledPrice;\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        // Now, multiply the assetValue by the collateral ratio\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        // Get the price for the given asset amount\n        return mulScalar(scaledPrice, assetAmount);\n    }\n\n    /**\n     * @dev Calculates the origination fee added to a given borrowAmount\n     *      This is simply `(1 + originationFee) * borrowAmount`\n     *\n     *      TODO: Track at what magnitude this fee rounds down to zero?\n     */\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n        // When origination fee is zero, the amount with fee is simply equal to the amount\n        if (isZeroExp(originationFee)) {\n            return (Error.NO_ERROR, borrowAmount);\n        }\n\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n    }\n\n    /**\n     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n     * @param asset asset whose price should be fetched\n     */\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n        if (oracle == address(0)) {\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n        }\n\n        uint priceMantissa = priceOracle.getAssetPrice(asset);\n\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n    }\n\n    /**\n     * @notice Reads scaled price of specified asset from the price oracle\n     * @dev Reads scaled price of specified asset from the price oracle.\n     *      The plural name is to match a previous storage mapping that this function replaced.\n     * @param asset Asset whose price should be retrieved\n     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return 0;\n        }\n        return result.mantissa;\n    }\n\n    /**\n     * @dev Gets the amount of the specified asset given the specified Eth value\n     *      ethValue / oraclePrice = assetAmountWei\n     *      If there's no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n     */\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory assetAmount;\n\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, assetAmount) = divExp(ethValue, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(assetAmount));\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller = pendingAdmin\n        // msg.sender can't be zero\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAdmin = admin;\n        // Store admin = pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = 0;\n\n        emit NewAdmin(oldAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new oracle, who can set asset prices\n     * @dev Admin function to change oracle\n     * @param newOracle New oracle address\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOracle(address newOracle) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n        }\n\n        // Verify contract at newOracle address supports assetPrices call.\n        // This will revert if it doesn't.\n        // ChainLink priceOracleTemp = ChainLink(newOracle);\n        // priceOracleTemp.getAssetPrice(address(0));\n\n        address oldOracle = oracle;\n\n        // Store oracle = newOracle\n        oracle = newOracle;\n        // Initialize the Chainlink contract in priceOracle\n        priceOracle = ChainLink(newOracle);\n\n        emit NewOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice returns the liquidity for given account.\n     *         a positive result indicates ability to borrow, whereas\n     *         a negative result indicates a shortfall which may be liquidated\n     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n     *      note: this includes interest trued up on all balances\n     * @param account the account to examine\n     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n     */\n    function getAccountLiquidity(address account) public view returns (int) {\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n        require(err == Error.NO_ERROR);\n\n        if (isZeroExp(accountLiquidity)) {\n            return -1 * int(truncate(accountShortfall));\n        } else {\n            return int(truncate(accountLiquidity));\n        }\n    }\n\n    /**\n     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose supply balance belonging to `account` should be checked\n     * @return uint supply balance on success, throws on failed assertion otherwise\n     */\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[account][asset];\n\n        // Calculate the newSupplyIndex, needed to calculate user's supplyCurrent\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n        require(err == Error.NO_ERROR);\n\n        return userSupplyCurrent;\n    }\n\n    /**\n     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n     * @return uint borrow balance on success, throws on failed assertion otherwise\n     */\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[account][asset];\n\n        // Calculate the newBorrowIndex, needed to calculate user's borrowCurrent\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n        require(err == Error.NO_ERROR);\n\n        return userBorrowCurrent;\n    }\n\n\n    /**\n     * @notice Supports a given market (asset) for use\n     * @dev Admin function to add support for a market\n     * @param asset Asset to support; MUST already have a non-zero price set\n     * @param interestRateModel InterestRateModel to use for the asset\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        // Append asset to collateralAssets if not set\n        addCollateralMarket(asset);\n\n        // Set market isSupported to true\n        markets[asset].isSupported = true;\n\n        // Default supply and borrow index to 1e18\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n\n        emit SupportedMarket(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Suspends a given *supported* market (asset) from use.\n     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n     * @dev Admin function to suspend a market\n     * @param asset Asset to suspend\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _suspendMarket(address asset) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n        }\n\n        // If the market is not configured at all, we don't want to add any configuration for it.\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n        // has already been marked as unsupported. We can just return without doing anything.\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n        if (!markets[asset].isSupported) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // If we get here, we know market is configured and is supported, so set isSupported to false\n        markets[asset].isSupported = false;\n\n        emit SuspendedMarket(asset);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n     * @dev Owner function to set the risk parameters\n     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be >= 1.1\n     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be <= 0.1 and must be less than (descaled collateral ratio minus 1)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n        }\n\n        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n\n        Error err;\n        Exp memory newLiquidationDiscountPlusOne;\n\n        // Make sure new collateral ratio value is not below minimum value\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n        // C < L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Save current values so we can emit them in log.\n        Exp memory oldCollateralRatio = collateralRatio;\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\n\n        // Store new values\n        collateralRatio = newCollateralRatio;\n        liquidationDiscount = newLiquidationDiscount;\n\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the origination fee (which is a multiplier on new borrows)\n     * @dev Owner function to set the origination fee\n     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be >= 1.1\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n        }\n\n        // Save current value so we can emit it in log.\n        Exp memory oldOriginationFee = originationFee;\n\n        originationFee = Exp({mantissa: originationFeeMantissa});\n\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the interest rate model for a given market\n     * @dev Admin function to set interest rate model\n     * @param asset Asset to support\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        emit SetMarketInterestRateModel(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` <= equity. Equity= cash - (supply + borrows)\n     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount <= cash - (supply + borrows)\n     * @param asset asset whose equity should be withdrawn\n     * @param amount amount of equity to withdraw; must not exceed equity available\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n        }\n\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n        uint cash = getCash(asset);\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n        if (err0 != Error.NO_ERROR) {\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n        }\n\n        if (amount > equity) {\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset out of the protocol to the admin\n            Error err2 = doTransferOut(asset, admin, amount);\n            if (err2 != Error.NO_ERROR) {\n                // This is safe since it's our first interaction and it didn't do anything if it failed\n                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n        emit EquityWithdrawn(asset, equity, amount, admin);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Set WETH token contract address\n     * @param wethContractAddress Enter the WETH token address\n     */\n    function setWethAddress(address wethContractAddress) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n        }\n        wethAddress = wethContractAddress;\n        WETHContract = AlkemiWETH(wethAddress);\n        emit WETHAddressSet(wethContractAddress);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n     * @return errors if any\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n        user; // To silence the warning of unused local variable\n        if(wethAddress != address(0)){\n            WETHContract.deposit.value(etherAmount)();\n            return uint(Error.NO_ERROR);\n        }\n        else {\n            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n        }\n    }\n\n    /**\n     * @dev Revert Ether paid by user back to user's account in case transaction fails due to some other reason\n     * @param etherAmount Amount of ether to be sent back to user\n     * @param user User account address\n     */\n    function revertEtherToUser(address user, uint etherAmount) internal {\n        if(etherAmount > 0){\n            user.transfer(etherAmount);\n        }\n    }\n\n    /**\n     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n     * @dev add amount of supported asset to msg.sender's account\n     * @param asset The market asset to supply\n     * @param amount The amount to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function supply(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage balance = supplyBalances[msg.sender][asset];\n\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n        }\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // Fail gracefully if asset is not approved or has insufficient balance\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the newSupplyIndex, user's supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it's our first interaction and it didn't do anything if it failed\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n        balance.principal = localResults.userSupplyUpdated;\n        balance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice withdraw `amount` of `ether` from sender's account to sender's address\n     * @dev withdraw `amount` of `ether` from msg.sender's account to msg.sender\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n            WETHContract.withdraw(user,etherAmount);\n            return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice send Ether from contract to a user\n     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n     */\n    function sendEtherToUser(address user, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n        }\n        user.transfer(amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraw `amount` of `asset` from sender's account to sender's address\n     * @dev withdraw `amount` of `asset` from msg.sender's account to msg.sender\n     * @param asset The market asset to withdraw\n     * @param requestedAmount The amount to withdraw (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function withdraw(address asset, uint requestedAmount) public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // We calculate the user's accountLiquidity and accountShortfall.\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // We calculate the newSupplyIndex, user's supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount => the lesser of withdrawCapacity and supplyCurrent\n        if (requestedAmount == uint(-1)) {\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n            }\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n        } else {\n            localResults.withdrawAmount = requestedAmount;\n        }\n\n        // From here on we should NOT use requestedAmount.\n\n        // Fail gracefully if protocol has insufficient cash\n        // If protocol has insufficient cash, the sub operation will underflow.\n        localResults.currentCash = getCash(asset);\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        // We check that the amount is less than or equal to supplyCurrent\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // We want to know the user's withdrawCapacity, denominated in the asset\n        // Customer's withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply.\n        // Note that, even though the customer is withdrawing, if they've accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it's our first interaction and it didn't do anything if it failed\n                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // failure\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n        supplyBalance.principal = localResults.userSupplyUpdated;\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n        \n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Gets the user's account liquidity and account shortfall balances. This includes\n     *      any accumulated interest thus far but does NOT actually update anything in\n     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n     */\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n        Error err;\n        uint sumSupplyValuesMantissa;\n        uint sumBorrowValuesMantissa;\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        Exp memory result;\n\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // if sumSupplies < sumBorrows, then the user is under collateralized and has account shortfall.\n        // else the user meets the collateral ratio and has account liquidity.\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n            // accountShortfall = borrows - supplies\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n        } else {\n            // accountLiquidity = supplies - borrows\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n        }\n    }\n\n    /**\n     * @notice Gets the ETH values of the user's accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n     * TODO: To help save gas we could think about using the current Market.interestIndex\n     *       accumulate interest rather than calculating it\n     */\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n\n        /** By definition, all collateralMarkets are those that contribute to the user's\n         * liquidity and shortfall so we need only loop through those markets.\n         * To handle avoiding intermediate negative results, we will sum all the user's\n         * supply balances and borrow balances (with collateral ratio) separately and then\n         * subtract the sums at the end.\n         */\n\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n        localResults.sumSupplies = Exp({mantissa: 0});\n        localResults.sumBorrows = Exp({mantissa: 0});\n        Error err; // Re-used for all intermediate errors\n        localResults.collateralMarketsLength = collateralMarkets.length;\n\n        for (uint i = 0; i < localResults.collateralMarketsLength; i++) {\n            localResults.assetAddress = collateralMarkets[i];\n            Market storage currentMarket = markets[localResults.assetAddress];\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n\n            if (supplyBalance.principal > 0) {\n                // We calculate the newSupplyIndex and users supplyCurrent (includes interest)\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // We have the user's supply balance with interest so let's multiply by the asset price to get the total value\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of supplies\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n\n            if (borrowBalance.principal > 0) {\n                // We perform a similar actions to get the user's borrow balance\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of borrows\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n        }\n\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n    }\n\n    /**\n     * @notice Gets the ETH values of the user's accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n     *          sum ETH value of supplies scaled by 10e18,\n     *          sum ETH value of borrows scaled by 10e18)\n     */\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n\n            return (uint(err), 0, 0);\n        }\n\n        return (0, supplyValue, borrowValue);\n    }\n\n    /**\n     * @notice Users repay borrowed assets from their own address to the protocol.\n     * @param asset The market asset to repay\n     * @param amount The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(address asset, uint amount) public payable returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n        }\n        PayBorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n        Error err;\n        uint rateCalculationResultCode;\n\n        // We calculate the newBorrowIndex, user's borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        uint reimburseAmount;\n        // If the user specifies -1 amount to repay (max), repayAmount =>\n        // the lesser of the senders ERC-20 balance and borrowCurrent\n        if (asset != wethAddress) {\n            if (amount == uint(-1)) {\n                localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n            } else {\n                localResults.repayAmount = amount;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (amount > localResults.userBorrowCurrent) {\n                localResults.repayAmount = localResults.userBorrowCurrent;\n                (err, reimburseAmount) = sub(amount,localResults.userBorrowCurrent); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.repayAmount = amount;\n            }\n        }\n\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n        // Note: this checks that repayAmount is less than borrowCurrent\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail gracefully if asset is not approved or has insufficient balance\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the protocol's totalBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow\n        // Note that, even though the customer is paying some of their borrow, if they've accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it's our first interaction and it didn't do anything if it failed\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,localResults.repayAmount);\n                //Repay excess funds\n                if(reimburseAmount > 0){\n                    revertEtherToUser(msg.sender,reimburseAmount);\n                }\n                if(supplyError != 0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                } \n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n        \n        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice users repay all or some of an underwater borrow and receive collateral\n     * @param targetAccount The account whose borrow should be liquidated\n     * @param assetBorrow The market asset to repay\n     * @param assetCollateral The borrower's market asset to receive in exchange\n     * @param requestedAmountClose The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) public isLiquidator returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n        }\n        LiquidateLocalVars memory localResults;\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n        // We'll use localResults.liquidator inside this function for clarity vs using msg.sender.\n        localResults.targetAccount = targetAccount;\n        localResults.assetBorrow = assetBorrow;\n        localResults.liquidator = msg.sender;\n        localResults.assetCollateral = assetCollateral;\n\n        Market storage borrowMarket = markets[assetBorrow];\n        Market storage collateralMarket = markets[assetCollateral];\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n\n        // Liquidator might already hold some of the collateral asset\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n        Error err; // re-used for all intermediate errors\n\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n        if(err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n        }\n\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n        assert(err == Error.NO_ERROR);\n\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Liquidator may or may not already have some collateral asset.\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We update the protocol's totalSupply for assetCollateral in 2 steps, first by adding target user's accumulated\n        // interest and then by adding the liquidator's accumulated interest.\n\n        // Step 1 of 2: We add the target user's supplyCurrent and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the target user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Step 2 of 2: We add the liquidator's supplyCurrent of collateral asset and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the calling user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n        // This is equal to the lesser of\n        // 1. borrowCurrent; (already calculated)\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n        // discountedRepayToEvenAmount=\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n        // 3. discountedBorrowDenominatedCollateral\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n        (err, localResults.discountedBorrowDenominatedCollateral) =\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n        }\n\n        if (borrowMarket.isSupported) {\n            // Market is supported, so we calculate item 2 from above.\n            (err, localResults.discountedRepayToEvenAmount) =\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n            }\n\n            // We need to do a two-step min to select from all 3 values\n            // min1&3 = min(item 1, item 3)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n\n            // min1&3&2 = min(min1&3, 2)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n        } else {\n            // Market is not supported, so we don't need to calculate item 2.\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n        }\n\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (assetBorrow != wethAddress) {\n            if (requestedAmountClose == uint(-1)) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (requestedAmountClose > localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n                (err, localResults.reimburseAmount) = sub(requestedAmountClose,localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        }\n\n        // From here on, no more use of `requestedAmountClose`\n\n        // Verify closeBorrowAmount_TargetUnderwaterAsset <= maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset > localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n        }\n\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n        }\n\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n        // Fail gracefully if asset is not approved or has insufficient balance\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We are going to repay the target user's borrow using the calling user's funds\n        // We update the protocol's totalBorrow for assetBorrow, by subtracting the target user's prior checkpointed balance,\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset <= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can't underflow\n        assert(err == Error.NO_ERROR);\n\n        // We calculate the protocol's totalBorrow for assetBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n        // (Please note that we don't need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don't recalculate it.\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        // Now we look at collateral. We calculated target user's accumulated supply balance and the supply index above.\n        // Now we need to calculate the borrow index.\n        // We don't need to calculate new rates for the collateral asset because we have not changed utilization:\n        //  - accumulating interest on the target user's collateral does not change cash or borrows\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        // We checkpoint the target user's assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // The sub won't underflow because because seizeSupplyAmount_TargetCollateralAsset <= target user's collateral balance\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n        assert (err == Error.NO_ERROR);\n\n        // We checkpoint the liquidating user's assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // We can't overflow here because if this would overflow, then we would have already overflowed above and failed\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n        assert (err == Error.NO_ERROR);\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it's our first interaction and it didn't do anything if it failed\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n            }\n        } else {\n            uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            //Repay excess funds\n                if(localResults.reimburseAmount > 0){\n                    revertEtherToUser(localResults.liquidator,localResults.reimburseAmount);\n                }\n            if(supplyError !=0 ){\n                return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n            }\n        }\n\n        // Save borrow market updates\n        borrowMarket.blockNumber = getBlockNumber();\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n        // borrowMarket.totalSupply does not need to be updated\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        // Save collateral market updates\n        // We didn't calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n        collateralMarket.blockNumber = getBlockNumber();\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n\n        // Save user updates\n\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n        \n        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n\n        emitLiquidationEvent(localResults);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n     */\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n        emit BorrowLiquidated(localResults.targetAccount,\n            localResults.assetBorrow,\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n            localResults.liquidator,\n            localResults.assetCollateral,\n            localResults.startingSupplyBalance_TargetCollateralAsset,\n            localResults.currentSupplyBalance_TargetCollateralAsset,\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\n    }\n\n    /**\n     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n     *      If the market isn't supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n     */\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n        Error err;\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n        Exp memory accountShortfall_TargetUser;\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n        Exp memory discountedPrice_UnderwaterAsset;\n        Exp memory rawResult;\n\n        // we calculate the target user's shortfall, denominated in Ether, that the user is below the collateral ratio\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n        // discountedCollateralRatioMinusOne < collateralRatio\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can't overflow either\n        assert(err == Error.NO_ERROR);\n\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n        // It's theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n    /**\n     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n     */\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n        Error err;\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n        Exp memory rawResult;\n\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n     */\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n\n        // re-used for all intermediate errors\n        Error err;\n\n        // (1+liquidationDiscount)\n        Exp memory liquidationMultiplier;\n\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n        // or, expanded:\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n        Exp memory finalNumerator;\n\n        // finalNumerator / priceCollateral\n        Exp memory rawResult;\n\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        // liquidation discount will be enforced < 1, so 1 + liquidationDiscount can't overflow.\n        assert(err == Error.NO_ERROR);\n\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param asset The market asset to borrow\n     * @param amount The amount to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(address asset, uint amount) public isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n        }\n        BorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n\n        Error err;\n        uint rateCalculationResultCode;\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n        }\n\n        // We calculate the newBorrowIndex, user's borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Calculate origination fee.\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n        }\n        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol's totalBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow with fee\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // Check customer liquidity\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // Would the customer have a shortfall after this borrow (including origination fee)?\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] > accountLiquidity`\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // Fail gracefully if protocol has insufficient cash\n        localResults.currentCash = getCash(asset);\n        // We need to calculate what the updated cash will be after we transfer out to the user\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            // Note: we ignore error here and call this token insufficient cash\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS & INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it's our first interaction and it didn't do anything if it failed\n                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n\n        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n        uint originationFeeRepaid = 0;\n        if (originationFeeBalance[user][asset] != 0){\n            if (amount < originationFeeBalance[user][asset]) {\n                originationFeeRepaid = amount;\n            } else {\n                originationFeeRepaid = originationFeeBalance[user][asset];\n            }\n            Balance storage balance = supplyBalances[admin][asset];\n\n            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n            Error err; // Re-used for every function call that includes an Error in its return value(s).\n\n            originationFeeBalance[user][asset] -= originationFeeRepaid;\n\n            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n\n            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n\n            // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply\n            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n\n            // Save market updates\n            markets[asset].totalSupply =  localResults.newTotalSupply;\n\n            // Save user updates\n            localResults.startingBalance = balance.principal;\n            balance.principal = localResults.userSupplyUpdated;\n            balance.interestIndex = newSupplyIndex;\n\n            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n        }\n    }\n}"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/SafeToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ErrorReporter.sol\";\n\ncontract SafeToken is ErrorReporter {\n\n    /**\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and\n     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.\n     */\n    function checkTransferIn(address asset, address from, uint amount) internal view returns (Error) {\n        EIP20Interface token = EIP20Interface(asset);\n\n        if (token.allowance(from, address(this)) < amount) {\n            return Error.TOKEN_INSUFFICIENT_ALLOWANCE;\n        }\n\n        if (token.balanceOf(from) < amount) {\n            return Error.TOKEN_INSUFFICIENT_BALANCE;\n        }\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and returns an explanatory\n     *      error code rather than reverting.  If caller has not called `checkTransferIn`, this may revert due to\n     *      insufficient balance or insufficient allowance. If caller has called `checkTransferIn` prior to this call,\n     *      and it returned Error.NO_ERROR, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address asset, address from, uint amount) internal returns (Error) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\n\n        bool result;\n\n        token.transferFrom(from, address(this), amount);\n\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    result := not(0)          // set result to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    result := mload(0)        // Set `result = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        if (!result) {\n            return Error.TOKEN_TRANSFER_FAILED;\n        }\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @dev Checks balance of this contract in asset\n     */\n    function getCash(address asset) internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(asset);\n\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Checks balance of `from` in `asset`\n     */\n    function getBalanceOf(address asset, address from) internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(asset);\n\n        return token.balanceOf(from);\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address asset, address to, uint amount) internal returns (Error) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\n\n        bool result;\n\n        token.transfer(to, amount);\n\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    result := not(0)          // set result to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    result := mload(0)        // Set `result = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        if (!result) {\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n        }\n\n        return Error.NO_ERROR;\n    }\n\n    function doApprove(address asset, address to, uint amount) internal returns (Error) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\n        bool result;\n        token.approve(to, amount);\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    result := not(0)          // set result to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    result := mload(0)        // Set `result = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        if (!result) {\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n        }\n        return Error.NO_ERROR;\n    }\n}\n"},"/Users/ryanbreen/Workspace/Alkemi/alkemi-earn/alkemi-earn-protocol/contracts/TestTokens.sol":{"content":"pragma solidity 0.4.24;\n\ncontract TestTokens {\n//Variables\nstring public name;\nstring public symbol; // Usually is 3 or 4 letters long\nuint8 public decimals; // maximum is 18 decimals\nuint256 public supply;\n\nmapping(address => uint) public balances;\nmapping(address => mapping(address => uint)) public allowed;\n//Events\nevent Transfer(address sender, address receiver, uint256 tokens);\nevent Approval(address sender, address delegate, uint256 tokens);\n//constructor\nconstructor (string memory _name, string memory _symbol, uint8 _decimals, uint256 _supply) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n    supply = _supply * 10**18;\n    balances[msg.sender] = _supply * 10**18;\n}\n//Functions\n//return the total number of tokens that you have\nfunction totalSupply() external view returns (uint256){\n    return supply;\n}\n\n//How many tokens does this person have\nfunction balanceOf(address tokenOwner) external view returns (uint){\n    return balances[tokenOwner];\n}\n\n//helps in transferring from your account to another person\nfunction transfer(address receiver, uint numTokens) external returns (bool){\n    require(msg.sender != receiver,\"Sender and receiver can't be the same\");\n    require(balances[msg.sender] >= numTokens,\"Not enough balance\");\n    balances[msg.sender] -= numTokens;\n    balances[receiver] += numTokens;\n    emit Transfer(msg.sender,receiver,numTokens);\n    return true;\n}\n\n// Used to delegate authority to send tokens without my approval\nfunction approve(address delegate, uint numTokens) external returns (bool){\n    require(msg.sender != delegate,\"Sender and delegate can't be the same\");\n    allowed[msg.sender][delegate] = numTokens;\n    emit Approval(msg.sender,delegate,numTokens);\n    return true;\n}\n\n// How much has the owner delegated/approved to the delegate\nfunction allowance(address owner, address delegate) external view returns (uint){\n    return allowed[owner][delegate];\n}\n\n// Used by exchanges to send money from owner to buyer\nfunction transferFrom(address owner, address buyer, uint numTokens) external returns (bool){\n    require(owner != buyer,\"Owner and Buyer can't be the same\");\n    require(balances[owner] >= numTokens,\"Not enough balance\");\n    require(allowed[owner][msg.sender] >= numTokens,\"Not enough allowance\");\n    balances[owner] -= numTokens;\n    balances[buyer] += numTokens;\n    allowed[owner][msg.sender] -= numTokens;\n    emit Transfer(owner,buyer,numTokens);\n    return true;\n}\n\n// Should not be used in production\n// Only to allocate testnet tokens to user for testing purposes\nfunction allocateTo(address _owner, uint256 value) public {\n        balances[_owner] += value;\n        supply += value;\n        emit Transfer(address(this), _owner, value);\n    }\n}\n"}}}