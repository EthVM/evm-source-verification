{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.17;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"browser/Babylonian.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n        // else z = 0\r\n    }\r\n}\r\n"},"browser/FixedPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.4.0;\r\n\r\nimport './Babylonian.sol';\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint private constant Q112 = uint(1) << RESOLUTION;\r\n    uint private constant Q224 = Q112 << RESOLUTION;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\r\n        uint z;\r\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\r\n    }\r\n}\r\n"},"browser/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.17;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"browser/IUniswapV2Pair.sol":{"content":"pragma solidity >=0.5.0;\r\n\r\ninterface UniswapPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n"},"browser/PYLONGovernanceStorage.sol":{"content":"pragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract PYLONGovernanceStorage {\r\n    /// @notice A record of each accounts delegate\r\n    mapping (address => address) internal _delegates;\r\n\r\n    /// @notice A checkpoint for marking number of votes from a given block\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    /// @notice A record of votes checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    /// @notice The number of checkpoints for each account\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    /// @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    /// @notice A record of states for signing / validating signatures\r\n    mapping (address => uint) public nonces;\r\n}\r\n"},"browser/PYLONRebaser.sol":{"content":"pragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./SafeERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport './IUniswapV2Pair.sol';\r\nimport \"./UniswapV2OracleLibrary.sol\";\r\nimport \"./PYLONTokenInterface.sol\";\r\n\r\n\r\ncontract PYLONRebaser {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyGov() {\r\n        require(msg.sender == gov);\r\n        _;\r\n    }\r\n\r\n    struct Transaction {\r\n        bool enabled;\r\n        address destination;\r\n        bytes data;\r\n    }\r\n\r\n    struct UniVars {\r\n      uint256 pylonsToUni;\r\n      uint256 amountFromReserves;\r\n      uint256 mintToReserves;\r\n    }\r\n\r\n    /// @notice an event emitted when a transaction fails\r\n    event TransactionFailed(address indexed destination, uint index, bytes data);\r\n\r\n    /// @notice an event emitted when maxSlippageFactor is changed\r\n    event NewMaxSlippageFactor(uint256 oldSlippageFactor, uint256 newSlippageFactor);\r\n\r\n    /// @notice an event emitted when deviationThreshold is changed\r\n    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\r\n\r\n    /**\r\n     * @notice Sets the treasury mint percentage of rebase\r\n     */\r\n    event NewRebaseMintPercent(uint256 oldRebaseMintPerc, uint256 newRebaseMintPerc);\r\n\r\n\r\n    /**\r\n     * @notice Sets the reserve contract\r\n     */\r\n    event NewReserveContract(address oldReserveContract, address newReserveContract);\r\n\r\n    /**\r\n     * @notice Sets the reserve contract\r\n     */\r\n    event TreasuryIncreased(uint256 reservesAdded, uint256 pylonsSold, uint256 pylonsFromReserves, uint256 pylonsToReserves);\r\n\r\n\r\n    /**\r\n     * @notice Event emitted when pendingGov is changed\r\n     */\r\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\r\n\r\n    /**\r\n     * @notice Event emitted when gov is changed\r\n     */\r\n    event NewGov(address oldGov, address newGov);\r\n\r\n    // Stable ordering is not guaranteed.\r\n    Transaction[] public transactions;\r\n\r\n\r\n    /// @notice Governance address\r\n    address public gov;\r\n\r\n    /// @notice Pending Governance address\r\n    address public pendingGov;\r\n\r\n    /// @notice Spreads out getting to the target price\r\n    uint256 public rebaseLag;\r\n\r\n    /// @notice Peg target\r\n    uint256 public targetRate;\r\n\r\n    /// @notice Percent of rebase that goes to minting for treasury building\r\n    uint256 public rebaseMintPerc;\r\n\r\n    // If the current exchange rate is within this fractional distance from the target, no supply\r\n    // update is performed. Fixed point number--same format as the rate.\r\n    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\r\n    uint256 public deviationThreshold;\r\n\r\n    /// @notice More than this much time must pass between rebase operations.\r\n    uint256 public minRebaseTimeIntervalSec;\r\n\r\n    /// @notice Block timestamp of last rebase operation\r\n    uint256 public lastRebaseTimestampSec;\r\n\r\n    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\r\n    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\r\n    uint256 public rebaseWindowOffsetSec;\r\n\r\n    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\r\n    uint256 public rebaseWindowLengthSec;\r\n\r\n    /// @notice The number of rebase cycles since inception\r\n    uint256 public epoch;\r\n\r\n    // rebasing is not active initially. It can be activated at T+12 hours from\r\n    // deployment time\r\n    ///@notice boolean showing rebase activation status\r\n    bool public rebasingActive;\r\n\r\n    /// @notice delays rebasing activation to facilitate liquidity\r\n    uint256 public constant rebaseDelay = 12 hours;\r\n\r\n    /// @notice Time of TWAP initialization\r\n    uint256 public timeOfTWAPInit;\r\n\r\n    /// @notice PYLON token address\r\n    address public pylonAddress;\r\n\r\n    /// @notice reserve token\r\n    address public reserveToken;\r\n\r\n    /// @notice Reserves vault contract\r\n    address public reservesContract;\r\n\r\n    /// @notice pair for reserveToken <> PYLON\r\n    address public uniswap_pair;\r\n\r\n    /// @notice last TWAP update time\r\n    uint32 public blockTimestampLast;\r\n\r\n    /// @notice last TWAP cumulative price;\r\n    uint256 public priceCumulativeLast;\r\n\r\n    // Max slippage factor when buying reserve token. Magic number based on\r\n    // the fact that uniswap is a constant product. Therefore,\r\n    // targeting a % max slippage can be achieved by using a single precomputed\r\n    // number. i.e. 2.5% slippage is always equal to some f(maxSlippageFactor, reserves)\r\n    /// @notice the maximum slippage factor when buying reserve token\r\n    uint256 public maxSlippageFactor;\r\n\r\n    /// @notice Whether or not this token is first in uniswap PYLON<>Reserve pair\r\n    bool public isToken0;\r\n\r\n    constructor(\r\n        address pylonAddress_,\r\n        address reserveToken_,\r\n        address uniswap_factory,\r\n        address reservesContract_\r\n    )\r\n        public\r\n    {\r\n          minRebaseTimeIntervalSec = 12 hours;\r\n          rebaseWindowOffsetSec = 28800; // 8am/8pm UTC rebases\r\n          reservesContract = reservesContract_;\r\n          (address token0, address token1) = sortTokens(pylonAddress_, reserveToken_);\r\n\r\n          // used for interacting with uniswap\r\n          if (token0 == pylonAddress_) {\r\n              isToken0 = true;\r\n          } else {\r\n              isToken0 = false;\r\n          }\r\n          // uniswap PYLON<>Reserve pair\r\n          uniswap_pair = pairFor(uniswap_factory, token0, token1);\r\n\r\n          // Reserves contract is mutable\r\n          reservesContract = reservesContract_;\r\n\r\n          // Reserve token is not mutable. Must deploy a new rebaser to update it\r\n          reserveToken = reserveToken_;\r\n\r\n          pylonAddress = pylonAddress_;\r\n\r\n          // target 10% slippage\r\n          // 5.4%\r\n          maxSlippageFactor = 5409258 * 10**10;\r\n\r\n          // 1 YCRV\r\n          targetRate = 10**18;\r\n\r\n          // twice daily rebase, with targeting reaching peg in 5 days\r\n          rebaseLag = 10;\r\n\r\n          // 10%\r\n          rebaseMintPerc = 10**17;\r\n\r\n          // 5%\r\n          deviationThreshold = 5 * 10**16;\r\n\r\n          // 60 minutes\r\n          rebaseWindowLengthSec = 60 * 60;\r\n\r\n          // Changed in deployment scripts to facilitate protocol initiation\r\n          gov = msg.sender;\r\n\r\n    }\r\n\r\n    /**\r\n    @notice Updates slippage factor\r\n    @param maxSlippageFactor_ the new slippage factor\r\n    *\r\n    */\r\n    function setMaxSlippageFactor(uint256 maxSlippageFactor_)\r\n        public\r\n        onlyGov\r\n    {\r\n        uint256 oldSlippageFactor = maxSlippageFactor;\r\n        maxSlippageFactor = maxSlippageFactor_;\r\n        emit NewMaxSlippageFactor(oldSlippageFactor, maxSlippageFactor_);\r\n    }\r\n\r\n    /**\r\n    @notice Updates rebase mint percentage\r\n    @param rebaseMintPerc_ the new rebase mint percentage\r\n    *\r\n    */\r\n    function setRebaseMintPerc(uint256 rebaseMintPerc_)\r\n        public\r\n        onlyGov\r\n    {\r\n        uint256 oldPerc = rebaseMintPerc;\r\n        rebaseMintPerc = rebaseMintPerc_;\r\n        emit NewRebaseMintPercent(oldPerc, rebaseMintPerc_);\r\n    }\r\n\r\n\r\n    /**\r\n    @notice Updates reserve contract\r\n    @param reservesContract_ the new reserve contract\r\n    *\r\n    */\r\n    function setReserveContract(address reservesContract_)\r\n        public\r\n        onlyGov\r\n    {\r\n        address oldReservesContract = reservesContract;\r\n        reservesContract = reservesContract_;\r\n        emit NewReserveContract(oldReservesContract, reservesContract_);\r\n    }\r\n\r\n\r\n    /** @notice sets the pendingGov\r\n     * @param pendingGov_ The address of the rebaser contract to use for authentication.\r\n     */\r\n    function _setPendingGov(address pendingGov_)\r\n        external\r\n        onlyGov\r\n    {\r\n        address oldPendingGov = pendingGov;\r\n        pendingGov = pendingGov_;\r\n        emit NewPendingGov(oldPendingGov, pendingGov_);\r\n    }\r\n\r\n    /** @notice lets msg.sender accept governance\r\n     *\r\n     */\r\n    function _acceptGov()\r\n        external\r\n    {\r\n        require(msg.sender == pendingGov, \"!pending\");\r\n        address oldGov = gov;\r\n        gov = pendingGov;\r\n        pendingGov = address(0);\r\n        emit NewGov(oldGov, gov);\r\n    }\r\n\r\n    /** @notice Initializes TWAP start point, starts countdown to first rebase\r\n    *\r\n    */\r\n    function init_twap()\r\n        public\r\n    {\r\n        require(timeOfTWAPInit == 0, \"already activated\");\r\n        (uint priceCumulative, uint32 blockTimestamp) =\r\n           UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\r\n        require(blockTimestamp > 0, \"no trades\");\r\n        blockTimestampLast = blockTimestamp;\r\n        priceCumulativeLast = priceCumulative;\r\n        timeOfTWAPInit = blockTimestamp;\r\n    }\r\n\r\n    /** @notice Activates rebasing\r\n    *   @dev One way function, cannot be undone, callable by anyone\r\n    */\r\n    function activate_rebasing()\r\n        public\r\n    {\r\n        // disable rebase\r\n        // require(timeOfTWAPInit > 0, \"twap wasnt intitiated, call init_twap()\");\r\n        // // cannot enable prior to end of rebaseDelay\r\n        // require(now >= timeOfTWAPInit + rebaseDelay, \"!end_delay\");\r\n\r\n        // rebasingActive = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\r\n     *\r\n     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\r\n     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\r\n     *      and targetRate is 1e18\r\n     */\r\n    function rebase()\r\n        public\r\n    {\r\n        // disable rebase\r\n        // // EOA only\r\n        // require(msg.sender == tx.origin);\r\n        // // ensure rebasing at correct time\r\n        // _inRebaseWindow();\r\n\r\n        // // This comparison also ensures there is no reentrancy.\r\n        // require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\r\n\r\n        // // Snap the rebase time to the start of this window.\r\n        // lastRebaseTimestampSec = now.sub(\r\n        //     now.mod(minRebaseTimeIntervalSec)).add(rebaseWindowOffsetSec);\r\n\r\n        // epoch = epoch.add(1);\r\n\r\n        // // get twap from uniswap v2;\r\n        // uint256 exchangeRate = getTWAP();\r\n\r\n        // // calculates % change to supply\r\n        // (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\r\n\r\n        // uint256 indexDelta = offPegPerc;\r\n\r\n        // // Apply the Dampening factor.\r\n        // indexDelta = indexDelta.div(rebaseLag);\r\n\r\n        // PYLONTokenInterface pylon = PYLONTokenInterface(pylonAddress);\r\n\r\n        // if (positive) {\r\n        //     require(pylon.pylonsScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < pylon.maxScalingFactor(), \"new scaling factor will be too big\");\r\n        // }\r\n\r\n\r\n        // uint256 currSupply = pylon.totalSupply();\r\n\r\n        // uint256 mintAmount;\r\n        // // reduce indexDelta to account for minting\r\n        // if (positive) {\r\n        //     uint256 mintPerc = indexDelta.mul(rebaseMintPerc).div(10**18);\r\n        //     indexDelta = indexDelta.sub(mintPerc);\r\n        //     mintAmount = currSupply.mul(mintPerc).div(10**18);\r\n        // }\r\n\r\n        // // rebase\r\n        // uint256 supplyAfterRebase = pylon.rebase(epoch, indexDelta, positive);\r\n        // assert(pylon.pylonsScalingFactor() <= pylon.maxScalingFactor());\r\n\r\n        // // perform actions after rebase\r\n        // afterRebase(mintAmount, offPegPerc);\r\n    }\r\n\r\n\r\n    function uniswapV2Call(\r\n        address sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes memory data\r\n    )\r\n        public\r\n    {\r\n        // enforce that it is coming from uniswap\r\n        require(msg.sender == uniswap_pair, \"bad msg.sender\");\r\n        // enforce that this contract called uniswap\r\n        require(sender == address(this), \"bad origin\");\r\n        (UniVars memory uniVars) = abi.decode(data, (UniVars));\r\n\r\n        PYLONTokenInterface pylon = PYLONTokenInterface(pylonAddress);\r\n\r\n        if (uniVars.amountFromReserves > 0) {\r\n            // transfer from reserves and mint to uniswap\r\n            pylon.transferFrom(reservesContract, uniswap_pair, uniVars.amountFromReserves);\r\n            if (uniVars.amountFromReserves < uniVars.pylonsToUni) {\r\n                // if the amount from reserves > pylonsToUni, we have fully paid for the yCRV tokens\r\n                // thus this number would be 0 so no need to mint\r\n                pylon.mint(uniswap_pair, uniVars.pylonsToUni.sub(uniVars.amountFromReserves));\r\n            }\r\n        } else {\r\n            // mint to uniswap\r\n            pylon.mint(uniswap_pair, uniVars.pylonsToUni);\r\n        }\r\n\r\n        // mint unsold to mintAmount\r\n        if (uniVars.mintToReserves > 0) {\r\n            pylon.mint(reservesContract, uniVars.mintToReserves);\r\n        }\r\n\r\n        // transfer reserve token to reserves\r\n        if (isToken0) {\r\n            SafeERC20.safeTransfer(IERC20(reserveToken), reservesContract, amount1);\r\n            emit TreasuryIncreased(amount1, uniVars.pylonsToUni, uniVars.amountFromReserves, uniVars.mintToReserves);\r\n        } else {\r\n            SafeERC20.safeTransfer(IERC20(reserveToken), reservesContract, amount0);\r\n            emit TreasuryIncreased(amount0, uniVars.pylonsToUni, uniVars.amountFromReserves, uniVars.mintToReserves);\r\n        }\r\n    }\r\n\r\n    function buyReserveAndTransfer(\r\n        uint256 mintAmount,\r\n        uint256 offPegPerc\r\n    )\r\n        internal\r\n    {\r\n        UniswapPair pair = UniswapPair(uniswap_pair);\r\n\r\n        PYLONTokenInterface pylon = PYLONTokenInterface(pylonAddress);\r\n\r\n        // get reserves\r\n        (uint256 token0Reserves, uint256 token1Reserves, ) = pair.getReserves();\r\n\r\n        // check if protocol has excess pylon in the reserve\r\n        uint256 excess = pylon.balanceOf(reservesContract);\r\n\r\n\r\n        uint256 tokens_to_max_slippage = uniswapMaxSlippage(token0Reserves, token1Reserves, offPegPerc);\r\n\r\n        UniVars memory uniVars = UniVars({\r\n          pylonsToUni: tokens_to_max_slippage, // how many pylons uniswap needs\r\n          amountFromReserves: excess, // how much of pylonsToUni comes from reserves\r\n          mintToReserves: 0 // how much pylons protocol mints to reserves\r\n        });\r\n\r\n        // tries to sell all mint + excess\r\n        // falls back to selling some of mint and all of excess\r\n        // if all else fails, sells portion of excess\r\n        // upon pair.swap, `uniswapV2Call` is called by the uniswap pair contract\r\n        if (isToken0) {\r\n            if (tokens_to_max_slippage > mintAmount.add(excess)) {\r\n                // we already have performed a safemath check on mintAmount+excess\r\n                // so we dont need to continue using it in this code path\r\n\r\n                // can handle selling all of reserves and mint\r\n                uint256 buyTokens = getAmountOut(mintAmount + excess, token0Reserves, token1Reserves);\r\n                uniVars.pylonsToUni = mintAmount + excess;\r\n                uniVars.amountFromReserves = excess;\r\n                // call swap using entire mint amount and excess; mint 0 to reserves\r\n                pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\r\n            } else {\r\n                if (tokens_to_max_slippage > excess) {\r\n                    // uniswap can handle entire reserves\r\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token0Reserves, token1Reserves);\r\n\r\n                    // swap up to slippage limit, taking entire pylon reserves, and minting part of total\r\n                    uniVars.mintToReserves = mintAmount.sub((tokens_to_max_slippage - excess));\r\n                    pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\r\n                } else {\r\n                    // uniswap cant handle all of excess\r\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token0Reserves, token1Reserves);\r\n                    uniVars.amountFromReserves = tokens_to_max_slippage;\r\n                    uniVars.mintToReserves = mintAmount;\r\n                    // swap up to slippage limit, taking excess - remainingExcess from reserves, and minting full amount\r\n                    // to reserves\r\n                    pair.swap(0, buyTokens, address(this), abi.encode(uniVars));\r\n                }\r\n            }\r\n        } else {\r\n            if (tokens_to_max_slippage > mintAmount.add(excess)) {\r\n                // can handle all of reserves and mint\r\n                uint256 buyTokens = getAmountOut(mintAmount + excess, token1Reserves, token0Reserves);\r\n                uniVars.pylonsToUni = mintAmount + excess;\r\n                uniVars.amountFromReserves = excess;\r\n                // call swap using entire mint amount and excess; mint 0 to reserves\r\n                pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\r\n            } else {\r\n                if (tokens_to_max_slippage > excess) {\r\n                    // uniswap can handle entire reserves\r\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token1Reserves, token0Reserves);\r\n\r\n                    // swap up to slippage limit, taking entire pylon reserves, and minting part of total\r\n                    uniVars.mintToReserves = mintAmount.sub( (tokens_to_max_slippage - excess));\r\n                    // swap up to slippage limit, taking entire pylon reserves, and minting part of total\r\n                    pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\r\n                } else {\r\n                    // uniswap cant handle all of excess\r\n                    uint256 buyTokens = getAmountOut(tokens_to_max_slippage, token1Reserves, token0Reserves);\r\n                    uniVars.amountFromReserves = tokens_to_max_slippage;\r\n                    uniVars.mintToReserves = mintAmount;\r\n                    // swap up to slippage limit, taking excess - remainingExcess from reserves, and minting full amount\r\n                    // to reserves\r\n                    pair.swap(buyTokens, 0, address(this), abi.encode(uniVars));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function uniswapMaxSlippage(\r\n        uint256 token0,\r\n        uint256 token1,\r\n        uint256 offPegPerc\r\n    )\r\n      internal\r\n      view\r\n      returns (uint256)\r\n    {\r\n        if (isToken0) {\r\n          if (offPegPerc >= 10**17) {\r\n              // cap slippage\r\n              return token0.mul(maxSlippageFactor).div(10**18);\r\n          } else {\r\n              // in the 5-10% off peg range, slippage is essentially 2*x (where x is percentage of pool to buy).\r\n              // all we care about is not pushing below the peg, so underestimate\r\n              // the amount we can sell by dividing by 3. resulting price impact\r\n              // should be ~= offPegPerc * 2 / 3, which will keep us above the peg\r\n              //\r\n              // this is a conservative heuristic\r\n              return token0.mul(offPegPerc / 3).div(10**18);\r\n          }\r\n        } else {\r\n            if (offPegPerc >= 10**17) {\r\n                return token1.mul(maxSlippageFactor).div(10**18);\r\n            } else {\r\n                return token1.mul(offPegPerc / 3).div(10**18);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n     *\r\n     * @param amountIn input amount of the asset\r\n     * @param reserveIn reserves of the asset being sold\r\n     * @param reserveOut reserves if the asset being purchased\r\n     */\r\n\r\n   function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint amountOut)\r\n    {\r\n       require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n       require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n       uint amountInWithFee = amountIn.mul(997);\r\n       uint numerator = amountInWithFee.mul(reserveOut);\r\n       uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n       amountOut = numerator / denominator;\r\n   }\r\n\r\n\r\n    function afterRebase(\r\n        uint256 mintAmount,\r\n        uint256 offPegPerc\r\n    )\r\n        internal\r\n    {\r\n        // update uniswap\r\n        UniswapPair(uniswap_pair).sync();\r\n\r\n        if (mintAmount > 0) {\r\n            buyReserveAndTransfer(\r\n                mintAmount,\r\n                offPegPerc\r\n            );\r\n        }\r\n\r\n        // call any extra functions\r\n        for (uint i = 0; i < transactions.length; i++) {\r\n            Transaction storage t = transactions[i];\r\n            if (t.enabled) {\r\n                bool result =\r\n                    externalCall(t.destination, t.data);\r\n                if (!result) {\r\n                    emit TransactionFailed(t.destination, i, t.data);\r\n                    revert(\"Transaction Failed\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Calculates TWAP from uniswap\r\n     *\r\n     * @dev When liquidity is low, this can be manipulated by an end of block -> next block\r\n     *      attack. We delay the activation of rebases 12 hours after liquidity incentives\r\n     *      to reduce this attack vector. Additional there is very little supply\r\n     *      to be able to manipulate this during that time period of highest vuln.\r\n     */\r\n    function getTWAP()\r\n        internal\r\n        returns (uint256)\r\n    {\r\n      (uint priceCumulative, uint32 blockTimestamp) =\r\n         UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\r\n       uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n\r\n       // no period check as is done in isRebaseWindow\r\n\r\n       // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\r\n\r\n        priceCumulativeLast = priceCumulative;\r\n        blockTimestampLast = blockTimestamp;\r\n\r\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 10**18));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates current TWAP from uniswap\r\n     *\r\n     */\r\n    function getCurrentTWAP()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n      (uint priceCumulative, uint32 blockTimestamp) =\r\n         UniswapV2OracleLibrary.currentCumulativePrices(uniswap_pair, isToken0);\r\n       uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n\r\n       // no period check as is done in isRebaseWindow\r\n\r\n       // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\r\n\r\n        return FixedPoint.decode144(FixedPoint.mul(priceAverage, 10**18));\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\r\n     *         oracle is within this fractional distance from the targetRate, then no supply\r\n     *         modifications are made.\r\n     * @param deviationThreshold_ The new exchange rate threshold fraction.\r\n     */\r\n    function setDeviationThreshold(uint256 deviationThreshold_)\r\n        external\r\n        onlyGov\r\n    {\r\n        require(deviationThreshold > 0);\r\n        uint256 oldDeviationThreshold = deviationThreshold;\r\n        deviationThreshold = deviationThreshold_;\r\n        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the rebase lag parameter.\r\n               It is used to dampen the applied supply adjustment by 1 / rebaseLag\r\n               If the rebase lag R, equals 1, the smallest value for R, then the full supply\r\n               correction is applied on each rebase cycle.\r\n               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\r\n     * @param rebaseLag_ The new rebase lag parameter.\r\n     */\r\n    function setRebaseLag(uint256 rebaseLag_)\r\n        external\r\n        onlyGov\r\n    {\r\n        require(rebaseLag_ > 0);\r\n        rebaseLag = rebaseLag_;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the targetRate parameter.\r\n     * @param targetRate_ The new target rate parameter.\r\n     */\r\n    function setTargetRate(uint256 targetRate_)\r\n        external\r\n        onlyGov\r\n    {\r\n        require(targetRate_ > 0);\r\n        targetRate = targetRate_;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the parameters which control the timing and frequency of\r\n     *         rebase operations.\r\n     *         a) the minimum time period that must elapse between rebase cycles.\r\n     *         b) the rebase window offset parameter.\r\n     *         c) the rebase window length parameter.\r\n     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\r\n     *        operations, in seconds.\r\n     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\r\n              the rebase interval, where the rebase window begins.\r\n     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\r\n     */\r\n    function setRebaseTimingParameters(\r\n        uint256 minRebaseTimeIntervalSec_,\r\n        uint256 rebaseWindowOffsetSec_,\r\n        uint256 rebaseWindowLengthSec_)\r\n        external\r\n        onlyGov\r\n    {\r\n        require(minRebaseTimeIntervalSec_ > 0);\r\n        require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\r\n\r\n        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\r\n        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\r\n        rebaseWindowLengthSec = rebaseWindowLengthSec_;\r\n    }\r\n\r\n    /**\r\n     * @return If the latest block timestamp is within the rebase time window it, returns true.\r\n     *         Otherwise, returns false.\r\n     */\r\n    function inRebaseWindow() public view returns (bool) {\r\n\r\n        // rebasing is delayed until there is a liquid market\r\n        _inRebaseWindow();\r\n        return true;\r\n    }\r\n\r\n    function _inRebaseWindow() internal view {\r\n\r\n        // rebasing is delayed until there is a liquid market\r\n        require(rebasingActive, \"rebasing not active\");\r\n\r\n        require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, \"too early\");\r\n        require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \"too late\");\r\n    }\r\n\r\n    /**\r\n     * @return Computes in % how far off market is from peg\r\n     */\r\n    function computeOffPegPerc(uint256 rate)\r\n        private\r\n        view\r\n        returns (uint256, bool)\r\n    {\r\n        if (withinDeviationThreshold(rate)) {\r\n            return (0, false);\r\n        }\r\n\r\n        // indexDelta =  (rate - targetRate) / targetRate\r\n        if (rate > targetRate) {\r\n            return (rate.sub(targetRate).mul(10**18).div(targetRate), true);\r\n        } else {\r\n            return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param rate The current exchange rate, an 18 decimal fixed point number.\r\n     * @return If the rate is within the deviation threshold from the target rate, returns true.\r\n     *         Otherwise, returns false.\r\n     */\r\n    function withinDeviationThreshold(uint256 rate)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\r\n            .div(10 ** 18);\r\n\r\n        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)\r\n            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\r\n    }\r\n\r\n    /* - Constructor Helpers - */\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address token0,\r\n        address token1\r\n    )\r\n        internal\r\n        pure\r\n        returns (address pair)\r\n    {\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(\r\n        address tokenA,\r\n        address tokenB\r\n    )\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    /* -- Rebase helpers -- */\r\n\r\n    /**\r\n     * @notice Adds a transaction that gets called for a downstream receiver of rebases\r\n     * @param destination Address of contract destination\r\n     * @param data Transaction data payload\r\n     */\r\n    function addTransaction(address destination, bytes calldata data)\r\n        external\r\n        onlyGov\r\n    {\r\n        transactions.push(Transaction({\r\n            enabled: true,\r\n            destination: destination,\r\n            data: data\r\n        }));\r\n    }\r\n\r\n\r\n    /**\r\n     * @param index Index of transaction to remove.\r\n     *              Transaction ordering may have changed since adding.\r\n     */\r\n    function removeTransaction(uint index)\r\n        external\r\n        onlyGov\r\n    {\r\n        require(index < transactions.length, \"index out of bounds\");\r\n\r\n        if (index < transactions.length - 1) {\r\n            transactions[index] = transactions[transactions.length - 1];\r\n        }\r\n\r\n        transactions.length--;\r\n    }\r\n\r\n    /**\r\n     * @param index Index of transaction. Transaction ordering may have changed since adding.\r\n     * @param enabled True for enabled, false for disabled.\r\n     */\r\n    function setTransactionEnabled(uint index, bool enabled)\r\n        external\r\n        onlyGov\r\n    {\r\n        require(index < transactions.length, \"index must be in range of stored tx list\");\r\n        transactions[index].enabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * @dev wrapper to call the encoded transactions on downstream consumers.\r\n     * @param destination Address of destination contract.\r\n     * @param data The encoded data payload.\r\n     * @return True on success\r\n     */\r\n    function externalCall(address destination, bytes memory data)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        bool result;\r\n        assembly {  // solhint-disable-line no-inline-assembly\r\n            // \"Allocate\" memory for output\r\n            // (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let outputAddress := mload(0x40)\r\n\r\n            // First 32 bytes are the padded length of data, so exclude that\r\n            let dataAddress := add(data, 32)\r\n\r\n            result := call(\r\n                // 34710 is the value that solidity is currently emitting\r\n                // It includes callGas (700) + callVeryLow (3, to pay for SUB)\r\n                // + callValueTransferGas (9000) + callNewAccountGas\r\n                // (25000, in case the destination address does not exist and needs creating)\r\n                sub(gas, 34710),\r\n\r\n\r\n                destination,\r\n                0, // transfer value in wei\r\n                dataAddress,\r\n                mload(data),  // Size of the input, in bytes. Stored in position 0 of the array.\r\n                outputAddress,\r\n                0  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"},"browser/PYLONTokenInterface.sol":{"content":"pragma solidity 0.5.17;\r\n\r\nimport \"./PYLONTokenStorage.sol\";\r\nimport \"./PYLONGovernanceStorage.sol\";\r\n\r\ncontract PYLONTokenInterface is PYLONTokenStorage, PYLONGovernanceStorage {\r\n\r\n    /// @notice An event thats emitted when an account changes its delegate\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    /// @notice An event thats emitted when a delegate account's vote balance changes\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    /**\r\n     * @notice Event emitted when tokens are rebased\r\n     */\r\n    event Rebase(uint256 epoch, uint256 prevPYLONsScalingFactor, uint256 newPYLONsScalingFactor);\r\n\r\n    /*** Gov Events ***/\r\n\r\n    /**\r\n     * @notice Event emitted when pendingGov is changed\r\n     */\r\n    event NewPendingGov(address oldPendingGov, address newPendingGov);\r\n\r\n    /**\r\n     * @notice Event emitted when gov is changed\r\n     */\r\n    event NewGov(address oldGov, address newGov);\r\n\r\n    /**\r\n     * @notice Sets the rebaser contract\r\n     */\r\n    event NewRebaser(address oldRebaser, address newRebaser);\r\n\r\n    /**\r\n     * @notice Sets the incentivizer contract\r\n     */\r\n    event NewIncentivizer(address oldIncentivizer, address newIncentivizer);\r\n\r\n    /* - ERC20 Events - */\r\n\r\n    /**\r\n     * @notice EIP20 Transfer event\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    /**\r\n     * @notice EIP20 Approval event\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    /* - Extra Events - */\r\n    /**\r\n     * @notice Tokens minted event\r\n     */\r\n    event Mint(address to, uint256 amount);\r\n\r\n    // Public functions\r\n    function transfer(address to, uint256 value) external returns(bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\r\n    function balanceOf(address who) external view returns(uint256);\r\n    function balanceOfUnderlying(address who) external view returns(uint256);\r\n    function allowance(address owner_, address spender) external view returns(uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    function maxScalingFactor() external view returns (uint256);\r\n\r\n    /* - Governance Functions - */\r\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\r\n    function delegate(address delegatee) external;\r\n    function delegates(address delegator) external view returns (address);\r\n    function getCurrentVotes(address account) external view returns (uint256);\r\n\r\n    /* - Permissioned/Governance functions - */\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\r\n    function _setRebaser(address rebaser_) external;\r\n    function _setIncentivizer(address incentivizer_) external;\r\n    function _setPendingGov(address pendingGov_) external;\r\n    function _acceptGov() external;\r\n}\r\n"},"browser/PYLONTokenStorage.sol":{"content":"pragma solidity 0.5.17;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\n// Storage for a PYLON token\r\ncontract PYLONTokenStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Guard variable for re-entrancy checks. Not currently used\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @notice EIP-20 token name for this token\r\n     */\r\n    string public name;\r\n\r\n    /**\r\n     * @notice EIP-20 token symbol for this token\r\n     */\r\n    string public symbol;\r\n\r\n    /**\r\n     * @notice EIP-20 token decimals for this token\r\n     */\r\n    uint8 public decimals;\r\n\r\n    /**\r\n     * @notice Governor for this contract\r\n     */\r\n    address public gov;\r\n\r\n    /**\r\n     * @notice Pending governance for this contract\r\n     */\r\n    address public pendingGov;\r\n\r\n    /**\r\n     * @notice Approved rebaser for this contract\r\n     */\r\n    address public rebaser;\r\n\r\n    /**\r\n     * @notice Reserve address of PYLON protocol\r\n     */\r\n    address public incentivizer;\r\n\r\n    /**\r\n     * @notice Total supply of PYLONs\r\n     */\r\n    uint256 public totalSupply;\r\n\r\n    /**\r\n     * @notice Internal decimals used to handle scaling factor\r\n     */\r\n    uint256 public constant internalDecimals = 10**24;\r\n\r\n    /**\r\n     * @notice Used for percentage maths\r\n     */\r\n    uint256 public constant BASE = 10**18;\r\n\r\n    /**\r\n     * @notice Scaling factor that adjusts everyone's balances\r\n     */\r\n    uint256 public pylonsScalingFactor;\r\n\r\n    mapping (address => uint256) internal _pylonBalances;\r\n\r\n    mapping (address => mapping (address => uint256)) internal _allowedFragments;\r\n\r\n    uint256 public initSupply;\r\n\r\n}\r\n"},"browser/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.17;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"},"browser/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.5.17;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"},"browser/UniswapV2OracleLibrary.sol":{"content":"pragma solidity >=0.5.0;\r\n\r\nimport './IUniswapV2Pair.sol';\r\nimport './FixedPoint.sol';\r\n\r\n// library with helper methods for oracles that are concerned with computing average prices\r\nlibrary UniswapV2OracleLibrary {\r\n    using FixedPoint for *;\r\n\r\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2 ** 32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(\r\n        address pair,\r\n        bool isToken0\r\n    ) internal view returns (uint priceCumulative, uint32 blockTimestamp) {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = UniswapPair(pair).getReserves();\r\n        if (isToken0) {\r\n          priceCumulative = UniswapPair(pair).price0CumulativeLast();\r\n\r\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n          if (blockTimestampLast != blockTimestamp) {\r\n              // subtraction overflow is desired\r\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n              // addition overflow is desired\r\n              // counterfactual\r\n              priceCumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n          }\r\n        } else {\r\n          priceCumulative = UniswapPair(pair).price1CumulativeLast();\r\n          // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n          if (blockTimestampLast != blockTimestamp) {\r\n              // subtraction overflow is desired\r\n              uint32 timeElapsed = blockTimestamp - blockTimestampLast;\r\n              // addition overflow is desired\r\n              // counterfactual\r\n              priceCumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n          }\r\n        }\r\n\r\n    }\r\n}\r\n"}}}