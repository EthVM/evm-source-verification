{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BOTSToken.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) { return 0; }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n  address public admin;\r\n  mapping(address => bool) public owners;\r\n\r\n  constructor() public {\r\n    admin = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(owners[msg.sender] || admin == msg.sender);\r\n    _;\r\n  }\r\n\r\n  function addOwner(address newOwner) onlyOwner public returns(bool success) {\r\n    if (!owners[newOwner]) {\r\n      owners[newOwner] = true;\r\n      success = true; \r\n    }\r\n  }\r\n  \r\n  function removeOwner(address oldOwner) onlyOwner public returns(bool success) {\r\n    if (owners[oldOwner]) {\r\n      owners[oldOwner] = false;\r\n      success = true;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused || msg.sender == admin || owners[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused external {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused external {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n\r\n}\r\n\r\nabstract contract ERC20 {\r\n  function totalSupply() virtual public view returns (uint256);\r\n  function balanceOf(address who) virtual public view returns (uint256);\r\n  function transfer(address to, uint256 value) virtual public returns (bool);\r\n  function allowance(address owner, address spender) virtual public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) virtual public returns (bool);\r\n  function approve(address spender, uint256 value) virtual public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract TokenBase is ERC20, Pausable {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  modifier isValidDestination(address _to) {\r\n    require(_to != address(0x0));\r\n    require(_to != address(this));\r\n    _;\r\n  }\r\n\r\n  function totalSupply() override public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  function balanceOf(address _owner) override public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) override public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) override public whenNotPaused isValidDestination(_to) returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) override public whenNotPaused isValidDestination(_to) returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) override public whenNotPaused returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function increaseApproval(address _spender, uint256 _addedValue) public whenNotPaused returns (bool) {\r\n    allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address _spender, uint256 _subtractedValue) public whenNotPaused returns (bool) {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract MintableToken is TokenBase {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  function finishMinting() onlyOwner canMint external returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract BurnableToken is MintableToken {\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  function burn(uint256 _value) external {\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(msg.sender, _value);\r\n    emit Transfer(msg.sender, address(0), _value);\r\n  }\r\n\r\n}\r\n\r\ncontract BOTSToken is BurnableToken {\r\n  string public constant name = \"BOTS Token\";\r\n  string public constant symbol = \"BOTS\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  function takeOut(ERC20 _token, uint256 _amount) external onlyOwner {\r\n    _token.transfer(msg.sender, _amount);\r\n  }\r\n  \r\n  function takeOutETH(uint256 _amount) external {\r\n    (bool success, ) = msg.sender.call.value(_amount)(\"\");\r\n    require(success, \"Transfer failed.\");\r\n  }\r\n \r\n}"}}}