{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Treasury.sol":{"content":"// Sources flattened with hardhat v2.6.8 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v3.4.1-solc-0.7-2\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v3.4.1-solc-0.7-2\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.1-solc-0.7-2\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.1-solc-0.7-2\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v3.4.1-solc-0.7-2\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/SafeERC20.sol@v3.4.1-solc-0.7-2\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IALD.sol\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IALD is IERC20 {\r\n  function mint(address _to, uint256 _amount) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPriceOracle.sol\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IPriceOracle {\r\n  /// @dev Return the usd price of asset. mutilpled by 1e18\r\n  /// @param _asset The address of asset\r\n  function price(address _asset) external view returns (uint256);\r\n\r\n  /// @dev Return the usd value of asset. mutilpled by 1e18\r\n  /// @param _asset The address of asset\r\n  /// @param _amount The amount of asset\r\n  function value(address _asset, uint256 _amount) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITreasury.sol\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface ITreasury {\r\n  enum ReserveType {\r\n    // used by reserve manager, will not used to bond ALD.\r\n    NULL,\r\n    // used by main asset bond\r\n    UNDERLYING,\r\n    // used by vault reward bond\r\n    VAULT_REWARD,\r\n    // used by liquidity token bond\r\n    LIQUIDITY_TOKEN\r\n  }\r\n\r\n  /// @dev return the usd value given token and amount.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function valueOf(address _token, uint256 _amount) external view returns (uint256);\r\n\r\n  /// @dev return the amount of bond ALD given token and usd value.\r\n  /// @param _token The address of token.\r\n  /// @param _value The usd of token.\r\n  function bondOf(address _token, uint256 _value) external view returns (uint256);\r\n\r\n  /// @dev deposit token to bond ALD.\r\n  /// @param _type The type of deposited token.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function deposit(\r\n    ReserveType _type,\r\n    address _token,\r\n    uint256 _amount\r\n  ) external returns (uint256);\r\n\r\n  /// @dev withdraw token from POL.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function withdraw(address _token, uint256 _amount) external;\r\n\r\n  /// @dev manage token to earn passive yield.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function manage(address _token, uint256 _amount) external;\r\n\r\n  /// @dev mint ALD reward.\r\n  /// @param _recipient The address of to receive ALD token.\r\n  /// @param _amount The amount of token.\r\n  function mintRewards(address _recipient, uint256 _amount) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/LogExpMath.sol\r\n\r\npragma solidity ^0.7.6;\r\n\r\n// Copy from @balancer-labs/v2-solidity-utils/contracts/math/LogExpMath.sol with some modification.\r\n\r\n/**\r\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\r\n *\r\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\r\n * exponentiation and logarithm (where the base is Euler's number).\r\n *\r\n * @author Fernando Martinelli - @fernandomartinelli\r\n * @author Sergio Yuhjtman - @sergioyuhjtman\r\n * @author Daniel Fernandez - @dmf7z\r\n */\r\nlibrary LogExpMath {\r\n  // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\r\n  // two numbers, and multiply by ONE when dividing them.\r\n\r\n  // All arguments and return values are 18 decimal fixed point numbers.\r\n  int256 constant ONE_18 = 1e18;\r\n\r\n  // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\r\n  // case of ln36, 36 decimals.\r\n  int256 constant ONE_20 = 1e20;\r\n  int256 constant ONE_36 = 1e36;\r\n\r\n  // The domain of natural exponentiation is bound by the word size and number of decimals used.\r\n  //\r\n  // Because internally the result will be stored using 20 decimals, the largest possible result is\r\n  // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\r\n  // The smallest possible result is 10^(-18), which makes largest negative argument\r\n  // ln(10^(-18)) = -41.446531673892822312.\r\n  // We use 130.0 and -41.0 to have some safety margin.\r\n  int256 constant MAX_NATURAL_EXPONENT = 130e18;\r\n  int256 constant MIN_NATURAL_EXPONENT = -41e18;\r\n\r\n  // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\r\n  // 256 bit integer.\r\n  int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\r\n  int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\r\n\r\n  uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\r\n\r\n  // 18 decimal constants\r\n  int256 constant x0 = 128000000000000000000; // 2ˆ7\r\n  int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\r\n  int256 constant x1 = 64000000000000000000; // 2ˆ6\r\n  int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\r\n\r\n  // 20 decimal constants\r\n  int256 constant x2 = 3200000000000000000000; // 2ˆ5\r\n  int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\r\n  int256 constant x3 = 1600000000000000000000; // 2ˆ4\r\n  int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\r\n  int256 constant x4 = 800000000000000000000; // 2ˆ3\r\n  int256 constant a4 = 298095798704172827474000; // eˆ(x4)\r\n  int256 constant x5 = 400000000000000000000; // 2ˆ2\r\n  int256 constant a5 = 5459815003314423907810; // eˆ(x5)\r\n  int256 constant x6 = 200000000000000000000; // 2ˆ1\r\n  int256 constant a6 = 738905609893065022723; // eˆ(x6)\r\n  int256 constant x7 = 100000000000000000000; // 2ˆ0\r\n  int256 constant a7 = 271828182845904523536; // eˆ(x7)\r\n  int256 constant x8 = 50000000000000000000; // 2ˆ-1\r\n  int256 constant a8 = 164872127070012814685; // eˆ(x8)\r\n  int256 constant x9 = 25000000000000000000; // 2ˆ-2\r\n  int256 constant a9 = 128402541668774148407; // eˆ(x9)\r\n  int256 constant x10 = 12500000000000000000; // 2ˆ-3\r\n  int256 constant a10 = 113314845306682631683; // eˆ(x10)\r\n  int256 constant x11 = 6250000000000000000; // 2ˆ-4\r\n  int256 constant a11 = 106449445891785942956; // eˆ(x11)\r\n\r\n  /**\r\n   * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\r\n   *\r\n   * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\r\n   */\r\n  function pow(uint256 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) {\r\n      // We solve the 0^0 indetermination by making it equal one.\r\n      return uint256(ONE_18);\r\n    }\r\n\r\n    if (x == 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\r\n    // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\r\n    // x^y = exp(y * ln(x)).\r\n\r\n    // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\r\n    require(x < 2**255, \"LogExpMath: x out of bounds\");\r\n    int256 x_int256 = int256(x);\r\n\r\n    // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\r\n    // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\r\n\r\n    // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\r\n    require(y < MILD_EXPONENT_BOUND, \"LogExpMath: y out of bounds\");\r\n    int256 y_int256 = int256(y);\r\n\r\n    int256 logx_times_y;\r\n    if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\r\n      int256 ln_36_x = _ln_36(x_int256);\r\n\r\n      // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\r\n      // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\r\n      // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\r\n      // (downscaled) last 18 decimals.\r\n      logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\r\n    } else {\r\n      logx_times_y = _ln(x_int256) * y_int256;\r\n    }\r\n    logx_times_y /= ONE_18;\r\n\r\n    // Finally, we compute exp(y * ln(x)) to arrive at x^y\r\n    require(\r\n      MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\r\n      \"LogExpMath: product out of bounds\"\r\n    );\r\n\r\n    return uint256(exp(logx_times_y));\r\n  }\r\n\r\n  /**\r\n   * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\r\n   *\r\n   * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\r\n   */\r\n  function exp(int256 x) internal pure returns (int256) {\r\n    require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"LogExpMath: invalid exponent\");\r\n\r\n    if (x < 0) {\r\n      // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\r\n      // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\r\n      // Fixed point division requires multiplying by ONE_18.\r\n      return ((ONE_18 * ONE_18) / exp(-x));\r\n    }\r\n\r\n    // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\r\n    // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\r\n    // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\r\n    // decomposition.\r\n    // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\r\n    // decomposition, which will be lower than the smallest x_n.\r\n    // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\r\n    // We mutate x by subtracting x_n, making it the remainder of the decomposition.\r\n\r\n    // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\r\n    // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\r\n    // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\r\n    // decomposition.\r\n\r\n    // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\r\n    // it and compute the accumulated product.\r\n\r\n    int256 firstAN;\r\n    if (x >= x0) {\r\n      x -= x0;\r\n      firstAN = a0;\r\n    } else if (x >= x1) {\r\n      x -= x1;\r\n      firstAN = a1;\r\n    } else {\r\n      firstAN = 1; // One with no decimal places\r\n    }\r\n\r\n    // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\r\n    // smaller terms.\r\n    x *= 100;\r\n\r\n    // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\r\n    // one. Recall that fixed point multiplication requires dividing by ONE_20.\r\n    int256 product = ONE_20;\r\n\r\n    if (x >= x2) {\r\n      x -= x2;\r\n      product = (product * a2) / ONE_20;\r\n    }\r\n    if (x >= x3) {\r\n      x -= x3;\r\n      product = (product * a3) / ONE_20;\r\n    }\r\n    if (x >= x4) {\r\n      x -= x4;\r\n      product = (product * a4) / ONE_20;\r\n    }\r\n    if (x >= x5) {\r\n      x -= x5;\r\n      product = (product * a5) / ONE_20;\r\n    }\r\n    if (x >= x6) {\r\n      x -= x6;\r\n      product = (product * a6) / ONE_20;\r\n    }\r\n    if (x >= x7) {\r\n      x -= x7;\r\n      product = (product * a7) / ONE_20;\r\n    }\r\n    if (x >= x8) {\r\n      x -= x8;\r\n      product = (product * a8) / ONE_20;\r\n    }\r\n    if (x >= x9) {\r\n      x -= x9;\r\n      product = (product * a9) / ONE_20;\r\n    }\r\n\r\n    // x10 and x11 are unnecessary here since we have high enough precision already.\r\n\r\n    // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\r\n    // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\r\n\r\n    int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\r\n    int256 term; // Each term in the sum, where the nth term is (x^n / n!).\r\n\r\n    // The first term is simply x.\r\n    term = x;\r\n    seriesSum += term;\r\n\r\n    // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\r\n    // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\r\n\r\n    term = ((term * x) / ONE_20) / 2;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 3;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 4;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 5;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 6;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 7;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 8;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 9;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 10;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 11;\r\n    seriesSum += term;\r\n\r\n    term = ((term * x) / ONE_20) / 12;\r\n    seriesSum += term;\r\n\r\n    // 12 Taylor terms are sufficient for 18 decimal precision.\r\n\r\n    // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\r\n    // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\r\n    // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\r\n    // and then drop two digits to return an 18 decimal value.\r\n\r\n    return (((product * seriesSum) / ONE_20) * firstAN) / 100;\r\n  }\r\n\r\n  /**\r\n   * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\r\n   */\r\n  function log(int256 arg, int256 base) internal pure returns (int256) {\r\n    // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\r\n\r\n    // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\r\n    // upscaling.\r\n\r\n    int256 logBase;\r\n    if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\r\n      logBase = _ln_36(base);\r\n    } else {\r\n      logBase = _ln(base) * ONE_18;\r\n    }\r\n\r\n    int256 logArg;\r\n    if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\r\n      logArg = _ln_36(arg);\r\n    } else {\r\n      logArg = _ln(arg) * ONE_18;\r\n    }\r\n\r\n    // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\r\n    return (logArg * ONE_18) / logBase;\r\n  }\r\n\r\n  /**\r\n   * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\r\n   */\r\n  function ln(int256 a) internal pure returns (int256) {\r\n    // The real natural logarithm is not defined for negative numbers or zero.\r\n    require(a > 0, \"LogExpMath: out of bounds\");\r\n    if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\r\n      return _ln_36(a) / ONE_18;\r\n    } else {\r\n      return _ln(a);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\r\n   */\r\n  function _ln(int256 a) private pure returns (int256) {\r\n    if (a < ONE_18) {\r\n      // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\r\n      // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\r\n      // Fixed point division requires multiplying by ONE_18.\r\n      return (-_ln((ONE_18 * ONE_18) / a));\r\n    }\r\n\r\n    // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\r\n    // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\r\n    // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\r\n    // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\r\n    // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\r\n    // decomposition, which will be lower than the smallest a_n.\r\n    // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\r\n    // We mutate a by subtracting a_n, making it the remainder of the decomposition.\r\n\r\n    // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\r\n    // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\r\n    // ONE_18 to convert them to fixed point.\r\n    // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\r\n    // by it and compute the accumulated sum.\r\n\r\n    int256 sum = 0;\r\n    if (a >= a0 * ONE_18) {\r\n      a /= a0; // Integer, not fixed point division\r\n      sum += x0;\r\n    }\r\n\r\n    if (a >= a1 * ONE_18) {\r\n      a /= a1; // Integer, not fixed point division\r\n      sum += x1;\r\n    }\r\n\r\n    // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\r\n    sum *= 100;\r\n    a *= 100;\r\n\r\n    // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\r\n\r\n    if (a >= a2) {\r\n      a = (a * ONE_20) / a2;\r\n      sum += x2;\r\n    }\r\n\r\n    if (a >= a3) {\r\n      a = (a * ONE_20) / a3;\r\n      sum += x3;\r\n    }\r\n\r\n    if (a >= a4) {\r\n      a = (a * ONE_20) / a4;\r\n      sum += x4;\r\n    }\r\n\r\n    if (a >= a5) {\r\n      a = (a * ONE_20) / a5;\r\n      sum += x5;\r\n    }\r\n\r\n    if (a >= a6) {\r\n      a = (a * ONE_20) / a6;\r\n      sum += x6;\r\n    }\r\n\r\n    if (a >= a7) {\r\n      a = (a * ONE_20) / a7;\r\n      sum += x7;\r\n    }\r\n\r\n    if (a >= a8) {\r\n      a = (a * ONE_20) / a8;\r\n      sum += x8;\r\n    }\r\n\r\n    if (a >= a9) {\r\n      a = (a * ONE_20) / a9;\r\n      sum += x9;\r\n    }\r\n\r\n    if (a >= a10) {\r\n      a = (a * ONE_20) / a10;\r\n      sum += x10;\r\n    }\r\n\r\n    if (a >= a11) {\r\n      a = (a * ONE_20) / a11;\r\n      sum += x11;\r\n    }\r\n\r\n    // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\r\n    // that converges rapidly for values of `a` close to one - the same one used in ln_36.\r\n    // Let z = (a - 1) / (a + 1).\r\n    // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\r\n\r\n    // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\r\n    // division by ONE_20.\r\n    int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\r\n    int256 z_squared = (z * z) / ONE_20;\r\n\r\n    // num is the numerator of the series: the z^(2 * n + 1) term\r\n    int256 num = z;\r\n\r\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\r\n    int256 seriesSum = num;\r\n\r\n    // In each step, the numerator is multiplied by z^2\r\n    num = (num * z_squared) / ONE_20;\r\n    seriesSum += num / 3;\r\n\r\n    num = (num * z_squared) / ONE_20;\r\n    seriesSum += num / 5;\r\n\r\n    num = (num * z_squared) / ONE_20;\r\n    seriesSum += num / 7;\r\n\r\n    num = (num * z_squared) / ONE_20;\r\n    seriesSum += num / 9;\r\n\r\n    num = (num * z_squared) / ONE_20;\r\n    seriesSum += num / 11;\r\n\r\n    // 6 Taylor terms are sufficient for 36 decimal precision.\r\n\r\n    // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\r\n    seriesSum *= 2;\r\n\r\n    // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\r\n    // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\r\n    // value.\r\n\r\n    return (sum + seriesSum) / 100;\r\n  }\r\n\r\n  /**\r\n   * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\r\n   * for x close to one.\r\n   *\r\n   * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\r\n   */\r\n  function _ln_36(int256 x) private pure returns (int256) {\r\n    // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\r\n    // worthwhile.\r\n\r\n    // First, we transform x to a 36 digit fixed point value.\r\n    x *= ONE_18;\r\n\r\n    // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\r\n    // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\r\n\r\n    // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\r\n    // division by ONE_36.\r\n    int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\r\n    int256 z_squared = (z * z) / ONE_36;\r\n\r\n    // num is the numerator of the series: the z^(2 * n + 1) term\r\n    int256 num = z;\r\n\r\n    // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\r\n    int256 seriesSum = num;\r\n\r\n    // In each step, the numerator is multiplied by z^2\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 3;\r\n\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 5;\r\n\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 7;\r\n\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 9;\r\n\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 11;\r\n\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 13;\r\n\r\n    num = (num * z_squared) / ONE_36;\r\n    seriesSum += num / 15;\r\n\r\n    // 8 Taylor terms are sufficient for 36 decimal precision.\r\n\r\n    // All that remains is multiplying by 2 (non fixed point).\r\n    return seriesSum * 2;\r\n  }\r\n}\r\n\r\n\r\n// File contracts/Treasury.sol\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Treasury is Ownable, ITreasury {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  event Deposit(address indexed token, uint256 amount, uint256 value);\r\n  event Withdrawal(address indexed token, uint256 amount);\r\n  event ReservesManaged(address indexed token, address indexed manager, uint256 amount);\r\n  event ReservesUpdated(ReserveType indexed _type, uint256 totalReserves);\r\n  event RewardsMinted(address indexed caller, address indexed recipient, uint256 amount);\r\n\r\n  event UpdateReserveToken(address indexed token, bool isAdd);\r\n  event UpdateLiquidityToken(address indexed token, bool isAdd);\r\n  event UpdateReserveDepositor(address indexed depositor, bool isAdd);\r\n  event UpdateReserveManager(address indexed manager, bool isAdd);\r\n  event UpdateRewardManager(address indexed manager, bool isAdd);\r\n  event UpdatePolSpender(address indexed spender, bool isAdd);\r\n\r\n  event UpdateDiscount(address indexed token, uint256 discount);\r\n  event UpdatePriceOracle(address indexed token, address oracle);\r\n  event UpdatePolPercentage(address indexed token, uint256 percentage);\r\n  event UpdateContributorPercentage(uint256 percentage);\r\n  event UpdateLiabilityRatio(uint256 liabilityRatio);\r\n\r\n  uint256 private constant PRECISION = 1e18;\r\n\r\n  // The address of governor.\r\n  address public governor;\r\n\r\n  // The address of ALD token\r\n  address public immutable ald;\r\n  // The address of ALD DAO\r\n  address public immutable aldDAO;\r\n\r\n  // A list of reserve tokens. Push only, beware false-positives.\r\n  address[] public reserveTokens;\r\n  // Record whether an address is reserve token or not.\r\n  mapping(address => bool) public isReserveToken;\r\n\r\n  // A list of liquidity tokens. Push only, beware false-positives.\r\n  address[] public liquidityTokens;\r\n  // Record whether an address is liquidity token or not.\r\n  mapping(address => bool) public isLiquidityToken;\r\n\r\n  // A list of reserve depositors. Push only, beware false-positives.\r\n  address[] public reserveDepositors;\r\n  // Record whether an address is reserve depositor or not.\r\n  mapping(address => bool) public isReserveDepositor;\r\n\r\n  // Mapping from token address to price oracle address.\r\n  mapping(address => address) public priceOracle;\r\n\r\n  // A list of reserve managers. Push only, beware false-positives.\r\n  address[] public reserveManagers;\r\n  // Record whether an address is reserve manager or not.\r\n  mapping(address => bool) public isReserveManager;\r\n\r\n  // A list of reward managers. Push only, beware false-positives.\r\n  address[] public rewardManagers;\r\n  // Record whether an address is reward manager or not.\r\n  mapping(address => bool) public isRewardManager;\r\n\r\n  // Mapping from token address to discount factor. Multiplied by 1e18\r\n  mapping(address => uint256) public discount;\r\n\r\n  // A list of pol spenders. Push only, beware false-positives.\r\n  address[] public polSpenders;\r\n  // Record whether an address is pol spender or not.\r\n  mapping(address => bool) public isPolSpender;\r\n\r\n  // Mapping from token address to reserve amount belong to POL.\r\n  mapping(address => uint256) public polReserves;\r\n  // Mapping from token address to percentage of profit to POL. Multiplied by 1e18\r\n  mapping(address => uint256) public percentagePOL;\r\n\r\n  // The percentage of ALD to contributors. Multiplied by 1e18\r\n  uint256 public percentageContributor;\r\n\r\n  // The liability ratio used to calcalate ald price. Multiplied by 1e18\r\n  uint256 public liabilityRatio;\r\n\r\n  // The USD value of all reserves from main asset. Multiplied by 1e18\r\n  uint256 public totalReserveUnderlying;\r\n  // The USD value of all reserves from vault reward. Multiplied by 1e18\r\n  uint256 public totalReserveVaultReward;\r\n  // The USD value of all reserves from liquidity token. Multiplied by 1e18\r\n  uint256 public totalReserveLiquidityToken;\r\n\r\n  modifier onlyGovernor() {\r\n    require(msg.sender == governor || msg.sender == owner(), \"Treasury: only governor\");\r\n    _;\r\n  }\r\n\r\n  /// @param _ald The address of ALD token\r\n  /// @param _aldDAO The address of ALD DAO\r\n  constructor(address _ald, address _aldDAO) {\r\n    require(_ald != address(0), \"Treasury: zero ald address\");\r\n    require(_aldDAO != address(0), \"Treasury: zero aldDAO address\");\r\n\r\n    ald = _ald;\r\n    aldDAO = _aldDAO;\r\n\r\n    percentageContributor = 5e16; // 5%\r\n    liabilityRatio = 1e17; // 0.1\r\n  }\r\n\r\n  /********************************** View Functions **********************************/\r\n\r\n  /// @dev return the ALD bond price. mutipliled by 1e18\r\n  function aldBondPrice() public view returns (uint256) {\r\n    uint256 _totalReserve = totalReserveUnderlying.add(totalReserveVaultReward).add(totalReserveLiquidityToken);\r\n    uint256 _aldSupply = IERC20(ald).totalSupply();\r\n    return _totalReserve.mul(1e36).div(_aldSupply).div(liabilityRatio);\r\n  }\r\n\r\n  /// @dev return the amount of bond ALD given token and usd value, without discount.\r\n  /// @param _value The usd of token.\r\n  function bondOfWithoutDiscount(uint256 _value) public view returns (uint256) {\r\n    uint256 _aldSupply = IERC20(ald).totalSupply();\r\n    uint256 _totalReserve = totalReserveUnderlying.add(totalReserveVaultReward).add(totalReserveLiquidityToken);\r\n\r\n    uint256 x = _totalReserve.add(_value).mul(PRECISION).div(_totalReserve);\r\n    uint256 bond = LogExpMath.pow(x, liabilityRatio).sub(PRECISION).mul(_aldSupply).div(PRECISION);\r\n    return bond;\r\n  }\r\n\r\n  /// @dev return the usd value given token and amount.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function valueOf(address _token, uint256 _amount) public view override returns (uint256) {\r\n    return IPriceOracle(priceOracle[_token]).value(_token, _amount);\r\n  }\r\n\r\n  /// @dev return the amount of bond ALD given token and usd value.\r\n  /// @param _token The address of token.\r\n  /// @param _value The usd of token.\r\n  function bondOf(address _token, uint256 _value) public view override returns (uint256) {\r\n    return bondOfWithoutDiscount(_value).mul(discount[_token]).div(PRECISION);\r\n  }\r\n\r\n  /********************************** Mutated Functions **********************************/\r\n\r\n  /// @dev deposit token to bond ALD.\r\n  /// @param _type The type of deposited token.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function deposit(\r\n    ReserveType _type,\r\n    address _token,\r\n    uint256 _amount\r\n  ) external override returns (uint256) {\r\n    require(isReserveToken[_token] || isLiquidityToken[_token], \"Treasury: not accepted\");\r\n    require(isReserveDepositor[msg.sender], \"Treasury: not approved depositor\");\r\n\r\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n    uint256 _value = valueOf(_token, _amount);\r\n    uint256 _bond;\r\n\r\n    if (_type != ReserveType.NULL) {\r\n      // a portion of token should used as POL\r\n      uint256 _percentagePOL = percentagePOL[_token];\r\n      if (_percentagePOL > 0) {\r\n        polReserves[_token] = polReserves[_token].add(_amount.mul(_percentagePOL).div(PRECISION));\r\n      }\r\n\r\n      // mint bond ald to sender\r\n      _bond = bondOf(_token, _value);\r\n      IALD(ald).mint(msg.sender, _bond);\r\n\r\n      // mint extra ALD to ald DAO\r\n      uint256 _percentageContributor = percentageContributor;\r\n      if (percentageContributor > 0) {\r\n        IALD(ald).mint(aldDAO, _bond.mul(_percentageContributor).div(PRECISION - _percentageContributor));\r\n      }\r\n\r\n      // update reserves\r\n      if (_type == ReserveType.LIQUIDITY_TOKEN) {\r\n        totalReserveLiquidityToken = totalReserveLiquidityToken.add(_value);\r\n        emit ReservesUpdated(_type, totalReserveLiquidityToken);\r\n      } else if (_type == ReserveType.UNDERLYING) {\r\n        totalReserveUnderlying = totalReserveUnderlying.add(_value);\r\n        emit ReservesUpdated(_type, totalReserveUnderlying);\r\n      } else if (_type == ReserveType.VAULT_REWARD) {\r\n        totalReserveVaultReward = totalReserveVaultReward.add(_value);\r\n        emit ReservesUpdated(_type, totalReserveVaultReward);\r\n      } else {\r\n        revert(\"Treasury: invalid reserve type\");\r\n      }\r\n    }\r\n\r\n    emit Deposit(_token, _amount, _value);\r\n\r\n    return _bond;\r\n  }\r\n\r\n  /// @dev withdraw token from POL.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function withdraw(address _token, uint256 _amount) external override {\r\n    require(isReserveToken[_token], \"Treasury: not accepted\");\r\n    require(isPolSpender[msg.sender], \"Treasury: not approved spender\");\r\n    require(_amount <= polReserves[_token], \"Treasury: exceed pol reserve\");\r\n\r\n    polReserves[_token] = polReserves[_token] - _amount;\r\n    IERC20(_token).safeTransfer(msg.sender, _amount);\r\n\r\n    emit Withdrawal(_token, _amount);\r\n  }\r\n\r\n  /// @dev manage token to earn passive yield.\r\n  /// @param _token The address of token.\r\n  /// @param _amount The amount of token.\r\n  function manage(address _token, uint256 _amount) external override {\r\n    require(isReserveToken[_token] || isLiquidityToken[_token], \"Treasury: not accepted\");\r\n    require(isReserveManager[msg.sender], \"Treasury: not approved manager\");\r\n\r\n    IERC20(_token).safeTransfer(msg.sender, _amount);\r\n    emit ReservesManaged(_token, msg.sender, _amount);\r\n  }\r\n\r\n  /// @dev mint ALD reward.\r\n  /// @param _recipient The address of to receive ALD token.\r\n  /// @param _amount The amount of token.\r\n  function mintRewards(address _recipient, uint256 _amount) external override {\r\n    require(isRewardManager[msg.sender], \"Treasury: not approved manager\");\r\n\r\n    IALD(ald).mint(_recipient, _amount);\r\n\r\n    emit RewardsMinted(msg.sender, _recipient, _amount);\r\n  }\r\n\r\n  /********************************** Restricted Functions **********************************/\r\n\r\n  function updateGovernor(address _governor) external onlyOwner {\r\n    governor = _governor;\r\n  }\r\n\r\n  /// @dev update reserve token\r\n  /// @param _token The address of token.\r\n  /// @param _isAdd Whether it is add or remove token.\r\n  function updateReserveToken(address _token, bool _isAdd) external onlyOwner {\r\n    _addOrRemoveAddress(reserveTokens, isReserveToken, _token, _isAdd);\r\n\r\n    emit UpdateReserveToken(_token, _isAdd);\r\n  }\r\n\r\n  /// @dev update liquidity token\r\n  /// @param _token The address of token.\r\n  /// @param _isAdd Whether it is add or remove token.\r\n  function updateLiquidityToken(address _token, bool _isAdd) external onlyOwner {\r\n    _addOrRemoveAddress(liquidityTokens, isLiquidityToken, _token, _isAdd);\r\n\r\n    emit UpdateLiquidityToken(_token, _isAdd);\r\n  }\r\n\r\n  /// @dev update reserve depositor\r\n  /// @param _depositor The address of depositor.\r\n  /// @param _isAdd Whether it is add or remove token.\r\n  function updateReserveDepositor(address _depositor, bool _isAdd) external onlyOwner {\r\n    _addOrRemoveAddress(reserveDepositors, isReserveDepositor, _depositor, _isAdd);\r\n\r\n    emit UpdateReserveDepositor(_depositor, _isAdd);\r\n  }\r\n\r\n  /// @dev update price oracle for token.\r\n  /// @param _token The address of token.\r\n  /// @param _oracle The address of price oracle.\r\n  function updatePriceOracle(address _token, address _oracle) external onlyOwner {\r\n    require(_oracle != address(0), \"Treasury: zero address\");\r\n    priceOracle[_token] = _oracle;\r\n\r\n    emit UpdatePriceOracle(_token, _oracle);\r\n  }\r\n\r\n  /// @dev update reserve manager.\r\n  /// @param _manager The address of manager.\r\n  /// @param _isAdd Whether it is add or remove token.\r\n  function updateReserveManager(address _manager, bool _isAdd) external onlyOwner {\r\n    _addOrRemoveAddress(reserveManagers, isReserveManager, _manager, _isAdd);\r\n\r\n    emit UpdateReserveManager(_manager, _isAdd);\r\n  }\r\n\r\n  /// @dev update reward manager.\r\n  /// @param _manager The address of manager.\r\n  /// @param _isAdd Whether it is add or remove token.\r\n  function updateRewardManager(address _manager, bool _isAdd) external onlyOwner {\r\n    _addOrRemoveAddress(rewardManagers, isRewardManager, _manager, _isAdd);\r\n\r\n    emit UpdateRewardManager(_manager, _isAdd);\r\n  }\r\n\r\n  /// @dev update discount factor for token.\r\n  /// @param _token The address of token.\r\n  /// @param _discount The discount factor. multipled by 1e18\r\n  function updateDiscount(address _token, uint256 _discount) external onlyGovernor {\r\n    discount[_token] = _discount;\r\n\r\n    emit UpdateDiscount(_token, _discount);\r\n  }\r\n\r\n  /// @dev update POL spender.\r\n  /// @param _spender The address of spender.\r\n  /// @param _isAdd Whether it is add or remove token.\r\n  function updatePolSpenders(address _spender, bool _isAdd) external onlyOwner {\r\n    _addOrRemoveAddress(polSpenders, isPolSpender, _spender, _isAdd);\r\n\r\n    emit UpdatePolSpender(_spender, _isAdd);\r\n  }\r\n\r\n  /// @dev update POL percentage for token.\r\n  /// @param _token The address of token.\r\n  /// @param _percentage The POL percentage. multipled by 1e18\r\n  function updatePercentagePOL(address _token, uint256 _percentage) external onlyOwner {\r\n    require(_percentage <= PRECISION, \"Treasury: percentage too large\");\r\n\r\n    percentagePOL[_token] = _percentage;\r\n\r\n    emit UpdatePolPercentage(_token, _percentage);\r\n  }\r\n\r\n  /// @dev update contributor percentage.\r\n  /// @param _percentage The contributor percentage. multipled by 1e18\r\n  function updatePercentageContributor(uint256 _percentage) external onlyOwner {\r\n    require(_percentage <= PRECISION, \"Treasury: percentage too large\");\r\n\r\n    percentageContributor = _percentage;\r\n\r\n    emit UpdateContributorPercentage(_percentage);\r\n  }\r\n\r\n  /// @dev update protocol liability ratio\r\n  /// @param _liabilityRatio The liability ratio. multipled by 1e18\r\n  function updateLiabilityRatio(uint256 _liabilityRatio) external onlyOwner {\r\n    liabilityRatio = _liabilityRatio;\r\n\r\n    emit UpdateLiabilityRatio(_liabilityRatio);\r\n  }\r\n\r\n  /// @dev update protocol reserves\r\n  /// @param _totalReserveUnderlying The underlying reserve.\r\n  /// @param _totalReserveVaultReward The vault reward reserve.\r\n  /// @param _totalReserveLiquidityToken The liquidity token reserve.\r\n  function updateReserves(\r\n    uint256 _totalReserveUnderlying,\r\n    uint256 _totalReserveVaultReward,\r\n    uint256 _totalReserveLiquidityToken\r\n  ) external onlyGovernor {\r\n    totalReserveUnderlying = _totalReserveUnderlying;\r\n    totalReserveVaultReward = _totalReserveVaultReward;\r\n    totalReserveLiquidityToken = _totalReserveLiquidityToken;\r\n\r\n    emit ReservesUpdated(ReserveType.UNDERLYING, _totalReserveUnderlying);\r\n    emit ReservesUpdated(ReserveType.VAULT_REWARD, _totalReserveVaultReward);\r\n    emit ReservesUpdated(ReserveType.LIQUIDITY_TOKEN, _totalReserveLiquidityToken);\r\n  }\r\n\r\n  /********************************** Internal Functions **********************************/\r\n\r\n  function _containAddress(address[] storage _list, address _item) internal view returns (bool) {\r\n    for (uint256 i = 0; i < _list.length; i++) {\r\n      if (_list[i] == _item) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function _addOrRemoveAddress(\r\n    address[] storage _list,\r\n    mapping(address => bool) storage _status,\r\n    address _item,\r\n    bool _isAdd\r\n  ) internal {\r\n    require(_item != address(0), \"Treasury: zero address\");\r\n\r\n    if (_isAdd) {\r\n      require(!_status[_item], \"Treasury: already set\");\r\n      if (!_containAddress(_list, _item)) {\r\n        _list.push(_item);\r\n      }\r\n      _status[_item] = true;\r\n    } else {\r\n      require(_status[_item], \"Treasury: already unset\");\r\n      _status[_item] = false;\r\n    }\r\n  }\r\n}"}}}