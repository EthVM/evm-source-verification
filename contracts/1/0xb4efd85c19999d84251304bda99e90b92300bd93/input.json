{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RocketPoolToken.sol":{"content":"pragma solidity ^0.4.11;\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\ncontract SalesAgentInterface {\r\n     /**** Properties ***********/\r\n    // Main contract token address\r\n    address tokenContractAddress;\r\n    // Contributions per address\r\n    mapping (address => uint256) public contributions;    \r\n    // Total ETH contributed     \r\n    uint256 public contributedTotal;                       \r\n    /// @dev Only allow access from the main token contract\r\n    modifier onlyTokenContract() {_;}\r\n    /*** Events ****************/\r\n    event Contribute(address _agent, address _sender, uint256 _value);\r\n    event FinaliseSale(address _agent, address _sender, uint256 _value);\r\n    event Refund(address _agent, address _sender, uint256 _value);\r\n    event ClaimTokens(address _agent, address _sender, uint256 _value);  \r\n    /*** Methods ****************/\r\n    /// @dev The address used for the depositAddress must checkin with the contract to verify it can interact with this contract, must happen or it won't accept funds\r\n    function getDepositAddressVerify() public;\r\n    /// @dev Get the contribution total of ETH from a contributor\r\n    /// @param _owner The owners address\r\n    function getContributionOf(address _owner) constant returns (uint256 balance);\r\n}\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\n/// @title The main Rocket Pool Token (RPL) contract\r\n/// @author David Rugendyke - http://www.rocketpool.net\r\n\r\n/*****************************************************************\r\n*   This is the main Rocket Pool Token (RPL) contract. It features\r\n*   Smart Agent compatibility. The Sale Agent is a new type of \r\n*   contract that can authorise the minting of tokens on behalf of\r\n*   the traditional ERC20 token contract. This allows you to \r\n*   distribute your ICO tokens through multiple Sale Agents, \r\n*   at various times, of various token quantities and of varying\r\n*   fund targets. Once you’ve written a new Sale Agent contract,\r\n*   you can register him with the main ERC20 token contract, \r\n*   he’s then permitted to sell it’s tokens on your behalf using\r\n*   guidelines such as the amount of tokens he’s allowed to sell, \r\n*   the maximum ether he’s allowed to raise, the start block and\r\n*   end blocks he’s allowed to sell between and more.\r\n/****************************************************************/\r\n\r\ncontract RocketPoolToken is StandardToken, Owned {\r\n\r\n     /**** Properties ***********/\r\n\r\n    string public name = \"Rocket Pool\";\r\n    string public symbol = \"RPL\";\r\n    string public version = \"1.0\";\r\n    // Set our token units\r\n    uint8 public constant decimals = 18;\r\n    uint256 public exponent = 10**uint256(decimals);\r\n    uint256 public totalSupply = 0;                             // The total of tokens currently minted by sales agent contracts    \r\n    uint256 public totalSupplyCap = 18 * (10**6) * exponent;    // 18 Million tokens\r\n\r\n\r\n    /**** Libs *****************/\r\n    \r\n    using SafeMath for uint;                           \r\n    \r\n    \r\n    /*** Sale Addresses *********/\r\n       \r\n    mapping (address => SalesAgent) private salesAgents;   // Our contract addresses of our sales contracts \r\n    address[] private salesAgentsAddresses;                // Keep an array of all our sales agent addresses for iteration\r\n\r\n    /*** Structs ***************/\r\n             \r\n    struct SalesAgent {                     // These are contract addresses that are authorised to mint tokens\r\n        address saleContractAddress;        // Address of the contract\r\n        bytes32 saleContractType;           // Type of the contract ie. presale, crowdsale \r\n        uint256 targetEthMax;               // The max amount of ether the agent is allowed raise\r\n        uint256 targetEthMin;               // The min amount of ether to raise to consider this contracts sales a success\r\n        uint256 tokensLimit;                // The maximum amount of tokens this sale contract is allowed to distribute\r\n        uint256 tokensMinted;               // The current amount of tokens minted by this agent\r\n        uint256 minDeposit;                 // The minimum deposit amount allowed\r\n        uint256 maxDeposit;                 // The maximum deposit amount allowed\r\n        uint256 startBlock;                 // The start block when allowed to mint tokens\r\n        uint256 endBlock;                   // The end block when to finish minting tokens\r\n        address depositAddress;             // The address that receives the ether for that sale contract\r\n        bool depositAddressCheckedIn;       // The address that receives the ether for that sale contract must check in with its sale contract to verify its a valid address that can interact\r\n        bool finalised;                     // Has this sales contract been completed and the ether sent to the deposit address?\r\n        bool exists;                        // Check to see if the mapping exists\r\n    }\r\n\r\n    /*** Events ****************/\r\n\r\n    event MintToken(address _agent, address _address, uint256 _value);\r\n    event SaleFinalised(address _agent, address _address, uint256 _value);\r\n  \r\n    /*** Tests *****************/\r\n\r\n    event FlagUint(uint256 flag);\r\n    event FlagAddress(address flag);\r\n\r\n    \r\n    /*** Modifiers *************/\r\n\r\n    /// @dev Only allow access from the latest version of a sales contract\r\n    modifier isSalesContract(address _sender) {\r\n        // Is this an authorised sale contract?\r\n        assert(salesAgents[_sender].exists == true);\r\n        _;\r\n    }\r\n\r\n    \r\n    /**** Methods ***********/\r\n\r\n    /// @dev RPL Token Init\r\n    function RocketPoolToken() {}\r\n\r\n\r\n    // @dev General validation for a sales agent contract receiving a contribution, additional validation can be done in the sale contract if required\r\n    // @param _value The value of the contribution in wei\r\n    // @return A boolean that indicates if the operation was successful.\r\n    function validateContribution(uint256 _value) isSalesContract(msg.sender) returns (bool) {\r\n        // Get an instance of the sale agent contract\r\n        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\r\n        // Did they send anything from a proper address?\r\n        assert(_value > 0);  \r\n        // Check the depositAddress has been verified by the account holder\r\n        assert(salesAgents[msg.sender].depositAddressCheckedIn == true);\r\n        // Check if we're ok to receive contributions, have we started?\r\n        assert(block.number > salesAgents[msg.sender].startBlock);       \r\n        // Already ended? Or if the end block is 0, it's an open ended sale until finalised by the depositAddress\r\n        assert(block.number < salesAgents[msg.sender].endBlock || salesAgents[msg.sender].endBlock == 0); \r\n        // Is it above the min deposit amount?\r\n        assert(_value >= salesAgents[msg.sender].minDeposit); \r\n        // Is it below the max deposit allowed?\r\n        assert(_value <= salesAgents[msg.sender].maxDeposit); \r\n        // No contributions if the sale contract has finalised\r\n        assert(salesAgents[msg.sender].finalised == false);      \r\n        // Does this deposit put it over the max target ether for the sale contract?\r\n        assert(saleAgent.contributedTotal().add(_value) <= salesAgents[msg.sender].targetEthMax);       \r\n        // All good\r\n        return true;\r\n    }\r\n\r\n\r\n    // @dev General validation for a sales agent contract that requires the user claim the tokens after the sale has finished\r\n    // @param _sender The address sent the request\r\n    // @return A boolean that indicates if the operation was successful.\r\n    function validateClaimTokens(address _sender) isSalesContract(msg.sender) returns (bool) {\r\n        // Get an instance of the sale agent contract\r\n        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\r\n        // Must have previously contributed\r\n        assert(saleAgent.getContributionOf(_sender) > 0); \r\n        // Sale contract completed\r\n        assert(block.number > salesAgents[msg.sender].endBlock);  \r\n        // All good\r\n        return true;\r\n    }\r\n    \r\n\r\n    // @dev Mint the Rocket Pool Tokens (RPL)\r\n    // @param _to The address that will receive the minted tokens.\r\n    // @param _amount The amount of tokens to mint.\r\n    // @return A boolean that indicates if the operation was successful.\r\n    function mint(address _to, uint _amount) isSalesContract(msg.sender) returns (bool) {\r\n        // Check if we're ok to mint new tokens, have we started?\r\n        // We dont check for the end block as some sale agents mint tokens during the sale, and some after its finished (proportional sales)\r\n        assert(block.number > salesAgents[msg.sender].startBlock);   \r\n        // Check the depositAddress has been verified by the designated account holder that will receive the funds from that agent\r\n        assert(salesAgents[msg.sender].depositAddressCheckedIn == true);\r\n        // No minting if the sale contract has finalised\r\n        assert(salesAgents[msg.sender].finalised == false);\r\n        // Check we don't exceed the assigned tokens of the sale agent\r\n        assert(salesAgents[msg.sender].tokensLimit >= salesAgents[msg.sender].tokensMinted.add(_amount));\r\n        // Verify ok balances and values\r\n        assert(_amount > 0);\r\n         // Check we don't exceed the supply limit\r\n        assert(totalSupply.add(_amount) <= totalSupplyCap);\r\n         // Ok all good, automatically checks for overflow with safeMath\r\n        balances[_to] = balances[_to].add(_amount);\r\n        // Add to the total minted for that agent, automatically checks for overflow with safeMath\r\n        salesAgents[msg.sender].tokensMinted = salesAgents[msg.sender].tokensMinted.add(_amount);\r\n        // Add to the overall total minted, automatically checks for overflow with safeMath\r\n        totalSupply = totalSupply.add(_amount);\r\n        // Fire the event\r\n        MintToken(msg.sender, _to, _amount);\r\n        // Fire the transfer event\r\n        Transfer(0x0, _to, _amount); \r\n        // Completed\r\n        return true; \r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that can still be minted\r\n    function getRemainingTokens() public constant returns(uint256) {\r\n        return totalSupplyCap.sub(totalSupply);\r\n    }\r\n    \r\n    /// @dev Set the address of a new crowdsale/presale contract agent if needed, usefull for upgrading\r\n    /// @param _saleAddress The address of the new token sale contract\r\n    /// @param _saleContractType Type of the contract ie. presale, crowdsale, quarterly\r\n    /// @param _targetEthMin The min amount of ether to raise to consider this contracts sales a success\r\n    /// @param _targetEthMax The max amount of ether the agent is allowed raise\r\n    /// @param _tokensLimit The maximum amount of tokens this sale contract is allowed to distribute\r\n    /// @param _minDeposit The minimum deposit amount allowed\r\n    /// @param _maxDeposit The maximum deposit amount allowed\r\n    /// @param _startBlock The start block when allowed to mint tokens\r\n    /// @param _endBlock The end block when to finish minting tokens\r\n    /// @param _depositAddress The address that receives the ether for that sale contract\r\n    function setSaleAgentContract(\r\n        address _saleAddress, \r\n         string _saleContractType, \r\n        uint256 _targetEthMin, \r\n        uint256 _targetEthMax, \r\n        uint256 _tokensLimit, \r\n        uint256 _minDeposit,\r\n        uint256 _maxDeposit,\r\n        uint256 _startBlock, \r\n        uint256 _endBlock, \r\n        address _depositAddress\r\n    ) \r\n    // Only the owner can register a new sale agent\r\n    public onlyOwner  \r\n    {\r\n        // Valid addresses?\r\n        assert(_saleAddress != 0x0 && _depositAddress != 0x0);  \r\n        // Must have some available tokens\r\n        assert(_tokensLimit > 0 && _tokensLimit <= totalSupplyCap);\r\n        // Make sure the min deposit is less than or equal to the max\r\n        assert(_minDeposit <= _maxDeposit);\r\n        // Add the new sales contract\r\n        salesAgents[_saleAddress] = SalesAgent({\r\n            saleContractAddress: _saleAddress,\r\n            saleContractType: sha3(_saleContractType),\r\n            targetEthMin: _targetEthMin,\r\n            targetEthMax: _targetEthMax,\r\n            tokensLimit: _tokensLimit,\r\n            tokensMinted: 0,\r\n            minDeposit: _minDeposit,\r\n            maxDeposit: _maxDeposit,\r\n            startBlock: _startBlock,\r\n            endBlock: _endBlock,\r\n            depositAddress: _depositAddress,\r\n            depositAddressCheckedIn: false,\r\n            finalised: false,\r\n            exists: true                      \r\n        });\r\n        // Store our agent address so we can iterate over it if needed\r\n        salesAgentsAddresses.push(_saleAddress);\r\n    }\r\n\r\n\r\n    /// @dev Sets the contract sale agent process as completed, that sales agent is now retired\r\n    function setSaleContractFinalised(address _sender) isSalesContract(msg.sender) public returns(bool) {\r\n        // Get an instance of the sale agent contract\r\n        SalesAgentInterface saleAgent = SalesAgentInterface(msg.sender);\r\n        // Finalise the crowdsale funds\r\n        assert(!salesAgents[msg.sender].finalised);                       \r\n        // The address that will receive this contracts deposit, should match the original senders\r\n        assert(salesAgents[msg.sender].depositAddress == _sender);            \r\n        // If the end block is 0, it means an open ended crowdsale, once it's finalised, the end block is set to the current one\r\n        if (salesAgents[msg.sender].endBlock == 0) {\r\n            salesAgents[msg.sender].endBlock = block.number;\r\n        }\r\n        // Not yet finished?\r\n        assert(block.number >= salesAgents[msg.sender].endBlock);         \r\n        // Not enough raised?\r\n        assert(saleAgent.contributedTotal() >= salesAgents[msg.sender].targetEthMin);\r\n        // We're done now\r\n        salesAgents[msg.sender].finalised = true;\r\n        // Fire the event\r\n        SaleFinalised(msg.sender, _sender, salesAgents[msg.sender].tokensMinted);\r\n        // All good\r\n        return true;\r\n    }\r\n\r\n\r\n    /// @dev Verifies if the current address matches the depositAddress\r\n    /// @param _verifyAddress The address to verify it matches the depositAddress given for the sales agent\r\n    function setSaleContractDepositAddressVerified(address _verifyAddress) isSalesContract(msg.sender) public {\r\n        // Check its verified\r\n        assert(salesAgents[msg.sender].depositAddress == _verifyAddress && _verifyAddress != 0x0);\r\n        // Ok set it now\r\n        salesAgents[msg.sender].depositAddressCheckedIn = true;\r\n    }\r\n\r\n    /// @dev Returns true if this sales contract has finalised\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractIsFinalised(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(bool) {\r\n        return salesAgents[_salesAgentAddress].finalised;\r\n    }\r\n\r\n    /// @dev Returns the min target amount of ether the contract wants to raise\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractTargetEtherMin(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].targetEthMin;\r\n    }\r\n\r\n    /// @dev Returns the max target amount of ether the contract can raise\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractTargetEtherMax(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].targetEthMax;\r\n    }\r\n\r\n    /// @dev Returns the min deposit amount of ether\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractDepositEtherMin(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].minDeposit;\r\n    }\r\n\r\n    /// @dev Returns the max deposit amount of ether\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractDepositEtherMax(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].maxDeposit;\r\n    }\r\n\r\n    /// @dev Returns the address where the sale contracts ether will be deposited\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractDepositAddress(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(address) {\r\n        return salesAgents[_salesAgentAddress].depositAddress;\r\n    }\r\n\r\n    /// @dev Returns the true if the sale agents deposit address has been verified\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractDepositAddressVerified(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(bool) {\r\n        return salesAgents[_salesAgentAddress].depositAddressCheckedIn;\r\n    }\r\n\r\n    /// @dev Returns the start block for the sale agent\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractStartBlock(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].startBlock;\r\n    }\r\n\r\n    /// @dev Returns the start block for the sale agent\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractEndBlock(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].endBlock;\r\n    }\r\n\r\n    /// @dev Returns the max tokens for the sale agent\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractTokensLimit(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].tokensLimit;\r\n    }\r\n\r\n    /// @dev Returns the token total currently minted by the sale agent\r\n    /// @param _salesAgentAddress The address of the token sale agent contract\r\n    function getSaleContractTokensMinted(address _salesAgentAddress) constant isSalesContract(_salesAgentAddress) public returns(uint256) {\r\n        return salesAgents[_salesAgentAddress].tokensMinted;\r\n    }\r\n\r\n    \r\n}"}}}