{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "openseanft.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable {\r\n  address private owner;\r\n  \r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor () internal {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), owner);\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Ownable#onlyOwner: SENDER_IS_NOT_OWNER\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    require(_newOwner != address(0), \"Ownable#transferOwnership: INVALID_ADDRESS\");\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n  function getOwner() public view returns (address) {\r\n    return owner;\r\n  }\r\n\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\ninterface IERC1155TokenReceiver {\r\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\r\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 {\r\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\r\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n  event URI(string _amount, uint256 indexed _id);\r\n\r\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\r\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\r\n}\r\n\r\nlibrary Address {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param account address of the account to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { codehash := extcodehash(account) }\r\n    return (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n\r\nabstract contract ERC1155 is IERC165 {\r\n  using Address for address;\r\n\r\n\r\n  /***********************************|\r\n  |        Variables and Events       |\r\n  |__________________________________*/\r\n\r\n  // onReceive function signatures\r\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n\r\n  // Objects balances\r\n  mapping (address => mapping(uint256 => uint256)) internal balances;\r\n\r\n  // Operator Functions\r\n  mapping (address => mapping(address => bool)) internal operators;\r\n\r\n  mapping (address => uint256[]) private ownershipOfs;\r\n\r\n  // Events\r\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\r\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n  event URI(string _uri, uint256 indexed _id);\r\n\r\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    public\r\n  {\r\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\r\n    require(_to != address(0),\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\r\n    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\r\n\r\n    _safeTransferFrom(_from, _to, _id, _amount);\r\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\r\n  }\r\n\r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    public\r\n  {\r\n    // Requirements\r\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\");\r\n    require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\r\n\r\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\r\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\r\n  }\r\n\r\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\r\n    internal\r\n  {\r\n    // Update balances\r\n    balances[_from][_id] = balances[_from][_id] - _amount; // Subtract amount\r\n    balances[_to][_id] = balances[_to][_id] + _amount;     // Add amount\r\n\r\n    // update ownership\r\n    ownershipOfs[_to].push(_id);\r\n\r\n    // Emit event\r\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\r\n   */\r\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    internal\r\n  {\r\n    // Check if recipient is contract\r\n    if (_to.isContract()) {\r\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\r\n      require(retval == ERC1155_RECEIVED_VALUE, \"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\");\r\n    }\r\n  }\r\n\r\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\r\n    internal\r\n  {\r\n    require(_ids.length == _amounts.length, \"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\");\r\n\r\n    // Number of transfer to execute\r\n    uint256 nTransfer = _ids.length;\r\n\r\n    // Executing all transfers\r\n    for (uint256 i = 0; i < nTransfer; i++) {\r\n      // Update storage balance of previous bin\r\n      balances[_from][_ids[i]] = balances[_from][_ids[i]] - _amounts[i];\r\n      balances[_to][_ids[i]] = balances[_to][_ids[i]] + _amounts[i];\r\n\r\n      // update ownership\r\n        ownershipOfs[_to].push(_ids[i]);\r\n    }\r\n\r\n    // Emit event\r\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\r\n  }\r\n\r\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    internal\r\n  {\r\n    // Pass data if recipient is contract\r\n    if (_to.isContract()) {\r\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\r\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\");\r\n    }\r\n  }\r\n\r\n  function setApprovalForAll(address _operator, bool _approved)\r\n    external\r\n  {\r\n    // Update operator status\r\n    operators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view virtual returns (bool isOperator)\r\n  {\r\n    return operators[_owner][_operator];\r\n  }\r\n\r\n  function balanceOf(address _owner, uint256 _id)\r\n    public view returns (uint256)\r\n  {\r\n    return balances[_owner][_id];\r\n  }\r\n\r\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\r\n    public view returns (uint256[] memory)\r\n  {\r\n    require(_owners.length == _ids.length, \"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\");\r\n\r\n    // Variables\r\n    uint256[] memory batchBalances = new uint256[](_owners.length);\r\n\r\n    // Iterate over each owner and token ID\r\n    for (uint256 i = 0; i < _owners.length; i++) {\r\n      batchBalances[i] = balances[_owners[i]][_ids[i]];\r\n    }\r\n\r\n    return batchBalances;\r\n  }\r\n\r\n  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\r\n\r\n  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\r\n\r\n  function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {\r\n    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function ownershipOf(address _address) external view returns (uint256[] memory) {\r\n    uint256[] memory IDs = new uint256[](ownershipOfs[_address].length);\r\n    uint counter;\r\n    for(uint i=0; i<ownershipOfs[_address].length; i++) {\r\n        if ( balanceOf( _address, ownershipOfs[_address][i] ) > 0 ) {\r\n            IDs[counter] = ownershipOfs[_address][i];\r\n            counter++;\r\n        }\r\n    }\r\n    return IDs;\r\n  }\r\n\r\n}\r\n\r\nabstract contract ERC1155MintBurn is ERC1155 {\r\n\r\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    internal\r\n  {\r\n    // Add _amount\r\n    balances[_to][_id] = balances[_to][_id] + _amount;\r\n\r\n    // Emit event\r\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\r\n\r\n    // Calling onReceive method if recipient is contract\r\n    _callonERC1155Received(address(0x0), _to, _id, _amount, _data);\r\n  }\r\n\r\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    internal\r\n  {\r\n    require(_ids.length == _amounts.length, \"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\");\r\n\r\n    // Number of mints to execute\r\n    uint256 nMint = _ids.length;\r\n\r\n     // Executing all minting\r\n    for (uint256 i = 0; i < nMint; i++) {\r\n      // Update storage balance\r\n      balances[_to][_ids[i]] = balances[_to][_ids[i]] + _amounts[i];\r\n    }\r\n\r\n    // Emit batch mint event\r\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\r\n\r\n    // Calling onReceive method if recipient is contract\r\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\r\n  }\r\n\r\n  function _burn(address _from, uint256 _id, uint256 _amount)\r\n    internal\r\n  {\r\n    //Substract _amount\r\n    balances[_from][_id] = balances[_from][_id] - _amount;\r\n\r\n    // Emit event\r\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\r\n  }\r\n\r\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\r\n    internal\r\n  {\r\n    require(_ids.length == _amounts.length, \"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\");\r\n\r\n    // Number of mints to execute\r\n    uint256 nBurn = _ids.length;\r\n\r\n     // Executing all minting\r\n    for (uint256 i = 0; i < nBurn; i++) {\r\n      // Update storage balance\r\n      balances[_from][_ids[i]] = balances[_from][_ids[i]] - _amounts[i];\r\n    }\r\n\r\n    // Emit batch mint event\r\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\r\n  }\r\n\r\n}\r\n\r\ncontract OwnableDelegateProxy { }\r\n\r\ncontract ProxyRegistry {\r\n  mapping(address => OwnableDelegateProxy) public proxies;\r\n}\r\n\r\n/**\r\n * @title ERC1155Tradable\r\n * ERC1155Tradable - ERC1155 contract that whitelists an operator address, has create and mint functionality, and supports useful standards from OpenZeppelin,\r\n  like _exists(), name(), symbol(), and totalSupply()\r\n */\r\ncontract ERC1155Tradable is ERC1155, ERC1155MintBurn, Ownable {\r\n\r\n  address proxyRegistryAddress;\r\n  uint256 private _currentTokenID = 0;\r\n  mapping (uint256 => address) public creators;\r\n  mapping (uint256 => uint256) public tokenSupply;\r\n  mapping (uint256 => string) public URIs;\r\n  mapping (address => bool) public minters;\r\n\r\n  // Contract name\r\n  string public name;\r\n  // Contract symbol\r\n  string public symbol;\r\n\r\n  /**\r\n   * @dev Require msg.sender to be the creator of the token id\r\n   */\r\n  modifier creatorOnly(uint256 _id) {\r\n    require(creators[_id] == msg.sender, \"ERC1155Tradable#creatorOnly: ONLY_CREATOR_ALLOWED\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Require msg.sender to own more than 0 of the token id\r\n   */\r\n  modifier ownersOnly(uint256 _id) {\r\n    require(balances[msg.sender][_id] > 0, \"ERC1155Tradable#ownersOnly: ONLY_OWNERS_ALLOWED\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    address _proxyRegistryAddress\r\n  ) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    proxyRegistryAddress = _proxyRegistryAddress;\r\n    minters[msg.sender] = true;\r\n  }\r\n\r\n  function uri(\r\n    uint256 _id\r\n  ) public view returns (string memory) {\r\n    require(_exists(_id), \"ERC721Tradable#uri: NONEXISTENT_TOKEN\");\r\n    return URIs[_id];\r\n  }\r\n\r\n\r\n  function totalSupply(\r\n    uint256 _id\r\n  ) public view returns (uint256) {\r\n    return tokenSupply[_id];\r\n  }\r\n\r\n  function create(\r\n    address _to,\r\n    address _creator,\r\n    uint256 _id,\r\n    uint256 _initialSupply,\r\n    string calldata _uri,\r\n    bytes calldata _data\r\n  ) external returns (uint256) {\r\n    require(minters[msg.sender], \"Minter role is required.\");\r\n\r\n    creators[_id] = _creator;\r\n    URIs[_id] = _uri;\r\n\r\n    _mint(_to, _id, _initialSupply, _data);\r\n    tokenSupply[_id] = _initialSupply;\r\n    return _id;\r\n  }\r\n\r\n  function batchCreate(\r\n    address[] calldata _tos,\r\n    address[] calldata _creators,\r\n    uint256[] calldata _ids,\r\n    uint256[] calldata _initialSupplys,\r\n    string[] calldata _uris,\r\n    bytes calldata _data\r\n  ) external {\r\n    require(minters[msg.sender], \"Minter role is required.\");\r\n    require(_tos.length == _ids.length, \"Invalid array length.\");\r\n    for(uint i=0; i<_tos.length; i++) {\r\n        creators[_ids[i]] = _creators[i];\r\n        URIs[_ids[i]] = _uris[i];\r\n\r\n        _mint(_tos[i], _ids[i], _initialSupplys[i], _data);\r\n        tokenSupply[_ids[i]] = _initialSupplys[i];\r\n    }\r\n\r\n  }\r\n\r\n\r\n  function mint(\r\n    address _to,\r\n    uint256 _id,\r\n    uint256 _quantity,\r\n    bytes memory _data\r\n  ) public {\r\n    require(minters[msg.sender], \"Minter role is required.\");\r\n    _mint(_to, _id, _quantity, _data);\r\n    tokenSupply[_id] = tokenSupply[_id] + _quantity;\r\n  }\r\n\r\n  function batchMint(\r\n    address _to,\r\n    uint256[] memory _ids,\r\n    uint256[] memory _quantities,\r\n    bytes memory _data\r\n  ) public {\r\n    require(minters[msg.sender], \"Minter role is required.\");\r\n    for (uint256 i = 0; i < _ids.length; i++) {\r\n      uint256 _id = _ids[i];\r\n      uint256 quantity = _quantities[i];\r\n      tokenSupply[_id] = tokenSupply[_id] + quantity;\r\n    }\r\n    _batchMint(_to, _ids, _quantities, _data);\r\n  }\r\n\r\n  function setCreator(\r\n    address _to,\r\n    uint256[] memory _ids\r\n  ) public {\r\n    require(_to != address(0), \"ERC1155Tradable#setCreator: INVALID_ADDRESS.\");\r\n    for (uint256 i = 0; i < _ids.length; i++) {\r\n      uint256 id = _ids[i];\r\n      _setCreator(_to, id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  ) public view override returns (bool isOperator) {\r\n    // Whitelist OpenSea proxy contract for easy trading.\r\n    ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\r\n    if (address(proxyRegistry.proxies(_owner)) == _operator) {\r\n      return true;\r\n    }\r\n\r\n    return ERC1155.isApprovedForAll(_owner, _operator);\r\n  }\r\n\r\n  function _setCreator(address _to, uint256 _id) internal creatorOnly(_id)\r\n  {\r\n      creators[_id] = _to;\r\n  }\r\n\r\n  function _exists(\r\n    uint256 _id\r\n  ) internal view returns (bool) {\r\n    return creators[_id] != address(0);\r\n  }\r\n\r\n\r\n\r\n  function setMinterRole(address _address, bool _permission) external onlyOwner {\r\n    minters[_address] = _permission;\r\n  }\r\n\r\n  function setBatchURI(uint256[] calldata _ids, string calldata _uri) external {\r\n    require(minters[msg.sender], \"Minter role is required.\");\r\n    for(uint i=0; i<_ids.length; i++) {\r\n        URIs[_ids[i]] = _uri;\r\n    }\r\n  }\r\n\r\n  function setURI(uint256 _id, string calldata _uri) external {\r\n    require(minters[msg.sender], \"Minter role is required.\");\r\n    URIs[_id] = _uri;\r\n  }\r\n\r\n}\r\n\r\ncontract TAHUNFT is ERC1155Tradable {\r\n\r\n  constructor(address _proxyRegistryAddress)\r\n  ERC1155Tradable(\r\n    \"TAHU Brand\",\r\n    \"NFTAHU\",\r\n    _proxyRegistryAddress\r\n  ) public {\r\n\r\n  }\r\n\r\n  function contractURI() public view returns (string memory) {\r\n    return \"https://metadata.tahu.digital/c/ethereum/mainnet/tahu-brand\";\r\n  }\r\n  \r\n}"
    }
  }
}