{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Claimable.sol":{"content":"// SPDX-License-Identifier: WTFPL\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\ninterface IAdapter {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    function outputTokens(address inputToken) external view returns (address[] memory outputs);\r\n\r\n    function encodeMigration(address _genericRouter, address _strategy, address _lp, uint256 _amount)\r\n        external view returns (Call[] memory calls);\r\n\r\n    function encodeWithdraw(address _lp, uint256 _amount) external view returns (Call[] memory calls);\r\n\r\n    function buy(address _lp, address _exchange, uint256 _minAmountOut, uint256 _deadline) external payable;\r\n\r\n    function getAmountOut(address _lp, address _exchange, uint256 _amountIn) external returns (uint256);\r\n\r\n    function isWhitelisted(address _token) external view returns (bool);\r\n}\r\n\r\n\r\n\r\ninterface ILiquidityMigration {\r\n    function adapters(address _adapter) external view returns (bool);\r\n    function hasStaked(address _account, address _lp) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IRoot1155 is IERC1155 {\r\n    function getMaxTokenID() external view returns(uint256);\r\n    function burn(address account, uint256 id, uint256 value) external;\r\n}\r\n\r\n\r\n\r\ncontract Claimable is Ownable, ERC1155Holder {\r\n    enum State {\r\n        Pending,\r\n        Active,\r\n        Closed\r\n    }\r\n    State private _state;\r\n\r\n    uint256 public max;\r\n    address public migration;\r\n    address public collection;\r\n\r\n    mapping (address => uint256) public index;\r\n    mapping (address => mapping (uint256 => bool)) public claimed;\r\n\r\n    event Claimed(address indexed account, uint256 protocol);\r\n    event StateChange(uint8 changed);\r\n    event Migration(address migration);\r\n    event Collection(address collection);\r\n\r\n    /**\r\n    * @dev Require particular state\r\n    */\r\n    modifier onlyState(State state_) {\r\n        require(state() == state_, \"Claimable#onlyState: ONLY_STATE_ALLOWED\");\r\n        _;\r\n    }\r\n\r\n    /* assumption is enum ID will be the same as collection ID,\r\n     * and no further collections will be added whilst active\r\n    */\r\n    constructor(address _migration, address _collection, uint256 _max, address[] memory _index){\r\n        require(_max == _index.length, \"Claimable#claim: incorrect max\");\r\n        collection = _collection;\r\n        migration = _migration;\r\n        max = _max;\r\n        for (uint256 i = 0; i < _index.length; i++) {\r\n            if (i > 0) {\r\n                require(_index[i] != _index[0] && index[_index[i]] == 0,  \"Claimable#constructor: duplicate adapter\");\r\n            }\r\n            index[_index[i]] = i;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice claim NFT for staking LP\r\n     * @param _lp address of lp\r\n     * @param _adapter address of adapter\r\n     */\r\n    function claim(address _lp, address _adapter)\r\n        public\r\n        onlyState(State.Active)\r\n    {\r\n        require(_lp != address(0), \"Claimable#claim: empty address\");\r\n        require(_adapter != address(0), \"Claimable#claim: empty address\");\r\n\r\n        require(ILiquidityMigration(migration).adapters(_adapter), \"Claimable#claim: not adapter\");\r\n        require(IAdapter(_adapter).isWhitelisted(_lp), \"Claimable#claim: not associated\");\r\n        require(ILiquidityMigration(migration).hasStaked(msg.sender, _lp), \"Claimable#claim: not staked\");\r\n\r\n        uint256 _index = index[_adapter];\r\n        require(!claimed[msg.sender][_index], \"Claimable#claim: already claimed\");\r\n\r\n        require(IERC1155(collection).balanceOf(address(this), _index) > 0, \"Claimable#claim: no NFTs left\");\r\n\r\n        claimed[msg.sender][_index] = true;\r\n        IERC1155(collection).safeTransferFrom(address(this), msg.sender, _index, 1, \"\");\r\n        emit Claimed(msg.sender, _index);\r\n    }\r\n\r\n    /**\r\n     * @notice you wanna be a masta good old boi?\r\n     */\r\n    function master()\r\n        public\r\n        onlyState(State.Active)\r\n    {\r\n        require(!claimed[msg.sender][max], \"Claimable#master: claimed\");\r\n        for (uint256 i = 0; i < max; i++) {\r\n            require(claimed[msg.sender][i], \"Claimable#master: not all\");\r\n            require(IERC1155(collection).balanceOf(msg.sender, i) > 0, \"Claimable#master: not holding\");\r\n        }\r\n        claimed[msg.sender][max] = true;\r\n        IERC1155(collection).safeTransferFrom(address(this), msg.sender, max, 1, \"\");\r\n        emit Claimed(msg.sender, max);\r\n    }\r\n\r\n    /**\r\n     * @notice claim all through range\r\n     * @param _lp[] array of lp addresses\r\n     * @param _adapter[] array of adapter addresses\r\n     */\r\n\r\n    function claimAll(address[] memory _lp, address[] memory _adapter)\r\n        public\r\n    {\r\n        require(_lp.length <= max, \"Claimable#claimAll: incorrect length\");\r\n        require(_lp.length == _adapter.length, \"Claimable#claimAll: incorrect len\");\r\n        for (uint256 i = 0; i < _lp.length; i++) {\r\n            claim(_lp[i], _adapter[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice we wipe it, and burn all - should have got in already\r\n     */\r\n    function wipe(uint256 _start, uint256 _end)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_start < _end, \"Claimable#Wipe: range out\");\r\n        require(_end <= max, \"Claimable#Wipe: out of bounds\");\r\n        for (uint256 start = _start; start <= _end; start++) {\r\n            IRoot1155(collection).\r\n            burn(\r\n                address(this),\r\n                start,\r\n                IERC1155(collection).balanceOf(address(this), start)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice emergency from deployer change state\r\n     * @param state_ to change to\r\n     */\r\n    function stateChange(State state_)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _stateChange(state_);\r\n    }\r\n\r\n    /**\r\n     * @notice emergency from deployer change migration\r\n     * @param _migration to change to\r\n     */\r\n    function updateMigration(address _migration)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_migration != migration, \"Claimable#UpdateMigration: exists\");\r\n        migration = _migration;\r\n        emit Migration(migration);\r\n    }\r\n\r\n    /**\r\n     * @notice emergency from deployer change migration\r\n     * @param _collection to change to\r\n     */\r\n    function updateCollection(address _collection)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(_collection != collection, \"Claimable#UpdateCollection: exists\");\r\n        collection = _collection;\r\n        emit Collection(collection);\r\n    }\r\n\r\n    /**\r\n     * @return current state.\r\n     */\r\n    function state() public view virtual returns (State) {\r\n        return _state;\r\n    }\r\n\r\n    function _stateChange(State state_)\r\n        private\r\n    {\r\n        require(_state != state_, \"Claimable#changeState: current\");\r\n        _state = state_;\r\n        emit StateChange(uint8(_state));\r\n    }\r\n}"}}}