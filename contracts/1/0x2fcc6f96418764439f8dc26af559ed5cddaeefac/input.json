{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.6.12;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary RightsManager {\r\n    struct Rights {\r\n        bool canPauseSwapping;\r\n        bool canChangeSwapFee;\r\n        bool canChangeWeights;\r\n        bool canAddRemoveTokens;\r\n        bool canWhitelistLPs;\r\n        bool canChangeCap;\r\n    }\r\n}\r\n\r\nabstract contract ERC20 {\r\n    function approve(address spender, uint amount) external virtual returns (bool);\r\n    function transfer(address dst, uint amt) external virtual returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external virtual returns (bool);\r\n    function balanceOf(address whom) external view virtual returns (uint);\r\n    function allowance(address, address) external view virtual returns (uint);\r\n}\r\n\r\nabstract contract BalancerOwnable {\r\n    function setController(address controller) external virtual;\r\n}\r\n\r\nabstract contract AbstractPool is ERC20, BalancerOwnable {\r\n    function setSwapFee(uint swapFee) external virtual;\r\n    function setPublicSwap(bool public_) external virtual;\r\n    \r\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external virtual;\r\n    function joinswapExternAmountIn(\r\n        address tokenIn, uint tokenAmountIn, uint minPoolAmountOut\r\n    ) external virtual returns (uint poolAmountOut);\r\n}\r\n\r\nabstract contract BPool is AbstractPool {\r\n    function finalize() external virtual;\r\n    function bind(address token, uint balance, uint denorm) external virtual;\r\n    function rebind(address token, uint balance, uint denorm) external virtual;\r\n    function unbind(address token) external virtual;\r\n    function isBound(address t) external view virtual returns (bool);\r\n    function getCurrentTokens() external view virtual returns (address[] memory);\r\n    function getFinalTokens() external view virtual returns(address[] memory);\r\n    function getBalance(address token) external view virtual returns (uint);\r\n}\r\n\r\nabstract contract BFactory {\r\n    function newBPool() external virtual returns (BPool);\r\n}\r\n\r\nabstract contract ConfigurableRightsPool is AbstractPool {\r\n    struct PoolParams {\r\n        string poolTokenSymbol;\r\n        string poolTokenName;\r\n        address[] constituentTokens;\r\n        uint[] tokenBalances;\r\n        uint[] tokenWeights;\r\n        uint swapFee;\r\n    }\r\n\r\n    struct CrpParams {\r\n        uint initialSupply;\r\n        uint minimumWeightChangeBlockPeriod;\r\n        uint addTokenTimeLockInBlocks;\r\n    }\r\n\r\n    function createPool(\r\n        uint initialSupply, uint minimumWeightChangeBlockPeriod, uint addTokenTimeLockInBlocks\r\n    ) external virtual;\r\n    function createPool(uint initialSupply) external virtual;\r\n    function setCap(uint newCap) external virtual;\r\n    function updateWeight(address token, uint newWeight) external virtual;\r\n    function updateWeightsGradually(\r\n        uint[] calldata newWeights, uint startBlock, uint endBlock\r\n    ) external virtual;\r\n    function commitAddToken(address token, uint balance, uint denormalizedWeight) external virtual;\r\n    function applyAddToken() external virtual;\r\n    function removeToken(address token) external virtual;\r\n    function whitelistLiquidityProvider(address provider) external virtual;\r\n    function removeWhitelistedLiquidityProvider(address provider) external virtual;\r\n    function bPool() external view virtual returns (BPool);\r\n}\r\n\r\nabstract contract CRPFactory {\r\n    function newCrp(\r\n        address factoryAddress,\r\n        ConfigurableRightsPool.PoolParams calldata params,\r\n        RightsManager.Rights calldata rights\r\n    ) external virtual returns (ConfigurableRightsPool);\r\n}\r\n\r\n/********************************** WARNING **********************************/\r\n//                                                                           //\r\n// This contract is only meant to be used in conjunction with ds-proxy.      //\r\n// Calling this contract directly will lead to loss of funds.                //\r\n//                                                                           //\r\n/********************************** WARNING **********************************/\r\n\r\ncontract BActions {\r\n\r\n    // --- Pool Creation ---\r\n\r\n    function create(\r\n        BFactory factory,\r\n        address[] calldata tokens,\r\n        uint[] calldata balances,\r\n        uint[] calldata weights,\r\n        uint swapFee,\r\n        bool finalize\r\n    ) external returns (BPool pool) {\r\n        require(tokens.length == balances.length, \"ERR_LENGTH_MISMATCH\");\r\n        require(tokens.length == weights.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        pool = factory.newBPool();\r\n        pool.setSwapFee(swapFee);\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20 token = ERC20(tokens[i]);\r\n            require(token.transferFrom(msg.sender, address(this), balances[i]), \"ERR_TRANSFER_FAILED\");\r\n            _safeApprove(token, address(pool), balances[i]);\r\n            pool.bind(tokens[i], balances[i], weights[i]);\r\n        }\r\n\r\n        if (finalize) {\r\n            pool.finalize();\r\n            require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n        } else {\r\n            pool.setPublicSwap(true);\r\n        }\r\n    }\r\n    \r\n    function createSmartPool(\r\n        CRPFactory factory,\r\n        BFactory bFactory,\r\n        ConfigurableRightsPool.PoolParams calldata poolParams,\r\n        ConfigurableRightsPool.CrpParams calldata crpParams,\r\n        RightsManager.Rights calldata rights\r\n    ) external returns (ConfigurableRightsPool crp) {\r\n        require(\r\n            poolParams.constituentTokens.length == poolParams.tokenBalances.length,\r\n            \"ERR_LENGTH_MISMATCH\"\r\n        );\r\n        require(\r\n            poolParams.constituentTokens.length == poolParams.tokenWeights.length,\r\n            \"ERR_LENGTH_MISMATCH\"\r\n        );\r\n\r\n        crp = factory.newCrp(\r\n            address(bFactory),\r\n            poolParams,\r\n            rights\r\n        );\r\n        \r\n        for (uint i = 0; i < poolParams.constituentTokens.length; i++) {\r\n            ERC20 token = ERC20(poolParams.constituentTokens[i]);\r\n            require(\r\n                token.transferFrom(msg.sender, address(this), poolParams.tokenBalances[i]),\r\n                \"ERR_TRANSFER_FAILED\"\r\n            );\r\n            _safeApprove(token, address(crp), poolParams.tokenBalances[i]);\r\n        }\r\n        \r\n        crp.createPool(\r\n            crpParams.initialSupply,\r\n            crpParams.minimumWeightChangeBlockPeriod,\r\n            crpParams.addTokenTimeLockInBlocks\r\n        );\r\n        require(crp.transfer(msg.sender, crpParams.initialSupply), \"ERR_TRANSFER_FAILED\");\r\n        // DSProxy instance keeps pool ownership to enable management\r\n    }\r\n    \r\n    // --- Joins ---\r\n    \r\n    function joinPool(\r\n        BPool pool,\r\n        uint poolAmountOut,\r\n        uint[] calldata maxAmountsIn\r\n    ) external {\r\n        address[] memory tokens = pool.getFinalTokens();\r\n        _join(pool, tokens, poolAmountOut, maxAmountsIn);\r\n    }\r\n    \r\n    function joinSmartPool(\r\n        ConfigurableRightsPool pool,\r\n        uint poolAmountOut,\r\n        uint[] calldata maxAmountsIn\r\n    ) external {\r\n        address[] memory tokens = pool.bPool().getCurrentTokens();\r\n        _join(pool, tokens, poolAmountOut, maxAmountsIn);\r\n    }\r\n\r\n    function joinswapExternAmountIn(\r\n        AbstractPool pool,\r\n        ERC20 token,\r\n        uint tokenAmountIn,\r\n        uint minPoolAmountOut\r\n    ) external {\r\n        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        _safeApprove(token, address(pool), tokenAmountIn);\r\n        uint poolAmountOut = pool.joinswapExternAmountIn(address(token), tokenAmountIn, minPoolAmountOut);\r\n        require(pool.transfer(msg.sender, poolAmountOut), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n    \r\n    // --- Pool management (common) ---\r\n    \r\n    function setPublicSwap(AbstractPool pool, bool publicSwap) external {\r\n        pool.setPublicSwap(publicSwap);\r\n    }\r\n\r\n    function setSwapFee(AbstractPool pool, uint newFee) external {\r\n        pool.setSwapFee(newFee);\r\n    }\r\n\r\n    function setController(AbstractPool pool, address newController) external {\r\n        pool.setController(newController);\r\n    }\r\n    \r\n    // --- Private pool management ---\r\n\r\n    function setTokens(\r\n        BPool pool,\r\n        address[] calldata tokens,\r\n        uint[] calldata balances,\r\n        uint[] calldata denorms\r\n    ) external {\r\n        require(tokens.length == balances.length, \"ERR_LENGTH_MISMATCH\");\r\n        require(tokens.length == denorms.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20 token = ERC20(tokens[i]);\r\n            if (pool.isBound(tokens[i])) {\r\n                if (balances[i] > pool.getBalance(tokens[i])) {\r\n                    require(\r\n                        token.transferFrom(msg.sender, address(this), balances[i] - pool.getBalance(tokens[i])),\r\n                        \"ERR_TRANSFER_FAILED\"\r\n                    );\r\n                    _safeApprove(token, address(pool), balances[i] - pool.getBalance(tokens[i]));\r\n                }\r\n                if (balances[i] > 10**6) {\r\n                    pool.rebind(tokens[i], balances[i], denorms[i]);\r\n                } else {\r\n                    pool.unbind(tokens[i]);\r\n                }\r\n\r\n            } else {\r\n                require(token.transferFrom(msg.sender, address(this), balances[i]), \"ERR_TRANSFER_FAILED\");\r\n                _safeApprove(token, address(pool), balances[i]);\r\n                pool.bind(tokens[i], balances[i], denorms[i]);\r\n            }\r\n\r\n            if (token.balanceOf(address(this)) > 0) {\r\n                require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function finalize(BPool pool) external {\r\n        pool.finalize();\r\n        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n    \r\n    // --- Smart pool management ---\r\n    \r\n    function increaseWeight(\r\n        ConfigurableRightsPool crp,\r\n        ERC20 token,\r\n        uint newWeight,\r\n        uint tokenAmountIn\r\n    ) external {\r\n        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        _safeApprove(token, address(crp), tokenAmountIn);\r\n        crp.updateWeight(address(token), newWeight);\r\n        require(crp.transfer(msg.sender, crp.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n    \r\n    function decreaseWeight(\r\n        ConfigurableRightsPool crp,\r\n        ERC20 token,\r\n        uint newWeight,\r\n        uint poolAmountIn\r\n    ) external {\r\n        require(crp.transferFrom(msg.sender, address(this), poolAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        crp.updateWeight(address(token), newWeight);\r\n        require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n    \r\n    function updateWeightsGradually(\r\n        ConfigurableRightsPool crp,\r\n        uint[] calldata newWeights,\r\n        uint startBlock,\r\n        uint endBlock\r\n    ) external {\r\n        crp.updateWeightsGradually(newWeights, startBlock, endBlock);\r\n    }\r\n\r\n    function setCap(\r\n        ConfigurableRightsPool crp,\r\n        uint newCap\r\n    ) external {\r\n        crp.setCap(newCap);\r\n    }\r\n\r\n    function commitAddToken(\r\n        ConfigurableRightsPool crp,\r\n        ERC20 token,\r\n        uint balance,\r\n        uint denormalizedWeight\r\n    ) external {\r\n        crp.commitAddToken(address(token), balance, denormalizedWeight);\r\n    }\r\n\r\n    function applyAddToken(\r\n        ConfigurableRightsPool crp,\r\n        ERC20 token,\r\n        uint tokenAmountIn\r\n    ) external {\r\n        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        _safeApprove(token, address(crp), tokenAmountIn);\r\n        crp.applyAddToken();\r\n        require(crp.transfer(msg.sender, crp.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function removeToken(\r\n        ConfigurableRightsPool crp,\r\n        ERC20 token,\r\n        uint poolAmountIn\r\n    ) external {\r\n        require(crp.transferFrom(msg.sender, address(this), poolAmountIn), \"ERR_TRANSFER_FAILED\");\r\n        crp.removeToken(address(token));\r\n        require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function whitelistLiquidityProvider(\r\n        ConfigurableRightsPool crp,\r\n        address provider\r\n    ) external {\r\n        crp.whitelistLiquidityProvider(provider);\r\n    }\r\n\r\n    function removeWhitelistedLiquidityProvider(\r\n        ConfigurableRightsPool crp,\r\n        address provider\r\n    ) external {\r\n        crp.removeWhitelistedLiquidityProvider(provider);\r\n    }\r\n    \r\n    // --- Internals ---\r\n    \r\n    function _safeApprove(ERC20 token, address spender, uint amount) internal {\r\n        if (token.allowance(address(this), spender) > 0) {\r\n            token.approve(spender, 0);\r\n        }\r\n        token.approve(spender, amount);\r\n    }\r\n    \r\n    function _join(\r\n        AbstractPool pool,\r\n        address[] memory tokens,\r\n        uint poolAmountOut,\r\n        uint[] memory maxAmountsIn\r\n    ) internal {\r\n        require(maxAmountsIn.length == tokens.length, \"ERR_LENGTH_MISMATCH\");\r\n\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20 token = ERC20(tokens[i]);\r\n            require(token.transferFrom(msg.sender, address(this), maxAmountsIn[i]), \"ERR_TRANSFER_FAILED\");\r\n            _safeApprove(token, address(pool), maxAmountsIn[i]);\r\n        }\r\n        pool.joinPool(poolAmountOut, maxAmountsIn);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20 token = ERC20(tokens[i]);\r\n            if (token.balanceOf(address(this)) > 0) {\r\n                require(token.transfer(msg.sender, token.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n            }\r\n        }\r\n        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n}"
    }
  }
}