{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 0
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Vyper_contract.sol": {
      "content": "# @version ^0.3.0\r\n# A \"zap\" to add liquidity and deposit into gauge in one transaction\r\n# (c) Curve.Fi, 2022\r\n\r\nMAX_COINS: constant(uint256) = 5\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n\r\n# External Contracts\r\ninterface ERC20:\r\n    def transfer(_receiver: address, _amount: uint256): nonpayable\r\n    def transferFrom(_sender: address, _receiver: address, _amount: uint256): nonpayable\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def decimals() -> uint256: view\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def allowance(_owner : address, _spender : address) -> uint256: view\r\n\r\ninterface Pool2:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256): payable\r\n\r\ninterface Pool3:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256): payable\r\n\r\ninterface Pool4:\r\n    def add_liquidity(amounts: uint256[4], min_mint_amount: uint256): payable\r\n\r\ninterface Pool5:\r\n    def add_liquidity(amounts: uint256[5], min_mint_amount: uint256): payable\r\n\r\ninterface PoolUseUnderlying2:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying3:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying4:\r\n    def add_liquidity(amounts: uint256[4], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolUseUnderlying5:\r\n    def add_liquidity(amounts: uint256[5], min_mint_amount: uint256, use_underlying: bool): payable\r\n\r\ninterface PoolFactory2:\r\n    def add_liquidity(pool: address, amounts: uint256[2], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory3:\r\n    def add_liquidity(pool: address, amounts: uint256[3], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory4:\r\n    def add_liquidity(pool: address, amounts: uint256[4], min_mint_amount: uint256): payable\r\n\r\ninterface PoolFactory5:\r\n    def add_liquidity(pool: address, amounts: uint256[5], min_mint_amount: uint256): payable\r\n\r\ninterface Gauge:\r\n    def deposit(lp_token_amount: uint256, addr: address): payable\r\n\r\n\r\nallowance: HashMap[address, bool[MAX_COINS]]\r\ngauge_allowance: HashMap[address, bool]\r\n\r\n\r\n@internal\r\ndef _add_liquidity(\r\n        deposit_address: address,\r\n        n_coins: uint256,\r\n        amounts: uint256[MAX_COINS],\r\n        min_mint_amount: uint256,\r\n        eth_value: uint256,\r\n        use_underlying: bool,\r\n        pool: address\r\n):\r\n    if pool != ZERO_ADDRESS:\r\n        if n_coins == 2:\r\n            PoolFactory2(deposit_address).add_liquidity(pool, [amounts[0], amounts[1]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 3:\r\n            PoolFactory3(deposit_address).add_liquidity(pool, [amounts[0], amounts[1], amounts[2]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 4:\r\n            PoolFactory4(deposit_address).add_liquidity(pool, [amounts[0], amounts[1], amounts[2], amounts[3]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 5:\r\n            PoolFactory5(deposit_address).add_liquidity(pool, [amounts[0], amounts[1], amounts[2], amounts[3], amounts[4]], min_mint_amount, value=eth_value)\r\n    elif use_underlying:\r\n        if n_coins == 2:\r\n            PoolUseUnderlying2(deposit_address).add_liquidity([amounts[0], amounts[1]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 3:\r\n            PoolUseUnderlying3(deposit_address).add_liquidity([amounts[0], amounts[1], amounts[2]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 4:\r\n            PoolUseUnderlying4(deposit_address).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3]], min_mint_amount, True, value=eth_value)\r\n        elif n_coins == 5:\r\n            PoolUseUnderlying5(deposit_address).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3], amounts[4]], min_mint_amount, True, value=eth_value)\r\n    else:\r\n        if n_coins == 2:\r\n            Pool2(deposit_address).add_liquidity([amounts[0], amounts[1]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 3:\r\n            Pool3(deposit_address).add_liquidity([amounts[0], amounts[1], amounts[2]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 4:\r\n            Pool4(deposit_address).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3]], min_mint_amount, value=eth_value)\r\n        elif n_coins == 5:\r\n            Pool5(deposit_address).add_liquidity([amounts[0], amounts[1], amounts[2], amounts[3], amounts[4]], min_mint_amount, value=eth_value)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit_and_stake(\r\n        deposit: address,\r\n        lp_token: address,\r\n        gauge: address,\r\n        n_coins: uint256,\r\n        coins: address[MAX_COINS],\r\n        amounts: uint256[MAX_COINS],\r\n        min_mint_amount: uint256,\r\n        use_underlying: bool, # for aave, saave, ib (use_underlying) and crveth, cvxeth (use_eth)\r\n        pool: address = ZERO_ADDRESS, # for factory\r\n):\r\n    assert n_coins >= 2, 'n_coins must be >=2'\r\n    assert n_coins <= MAX_COINS, 'n_coins must be <=MAX_COINS'\r\n\r\n    # Ensure allowance for swap or zap\r\n    for i in range(MAX_COINS):\r\n        if i >= n_coins:\r\n            break\r\n\r\n        if coins[i] == ETH_ADDRESS or amounts[i] == 0 or self.allowance[deposit][i]:\r\n            continue\r\n\r\n        self.allowance[deposit][i] = True\r\n        ERC20(coins[i]).approve(deposit, MAX_UINT256)\r\n\r\n    # Ensure allowance for gauge\r\n    if not self.gauge_allowance[gauge]:\r\n        self.gauge_allowance[gauge] = True\r\n        ERC20(lp_token).approve(gauge, MAX_UINT256)\r\n\r\n    # Transfer coins from owner\r\n    has_eth: bool = False\r\n    for i in range(MAX_COINS):\r\n        if i >= n_coins:\r\n            break\r\n\r\n        if coins[i] == ETH_ADDRESS:\r\n            assert msg.value == amounts[i]\r\n            has_eth = True\r\n            continue\r\n\r\n        if amounts[i] > 0:\r\n            # \"safeTransferFrom\" which works for ERC20s which return bool or not\r\n            _response: Bytes[32] = raw_call(\r\n                coins[i],\r\n                concat(\r\n                    method_id(\"transferFrom(address,address,uint256)\"),\r\n                    convert(msg.sender, bytes32),\r\n                    convert(self, bytes32),\r\n                    convert(amounts[i], bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )  # dev: failed transfer\r\n            if len(_response) > 0:\r\n                assert convert(_response, bool)  # dev: failed transfer\r\n\r\n    if not has_eth:\r\n        assert msg.value == 0\r\n\r\n    # Reverts if n_coins is wrong\r\n    self._add_liquidity(deposit, n_coins, amounts, min_mint_amount, msg.value, use_underlying, pool)\r\n\r\n    lp_token_amount: uint256 = ERC20(lp_token).balanceOf(self)\r\n    assert lp_token_amount > 0 # dev: swap-token mismatch\r\n\r\n    Gauge(gauge).deposit(lp_token_amount, msg.sender)\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass"
    }
  }
}