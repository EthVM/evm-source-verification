{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\nimport \"./IBeacon.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy {\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) public payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _setBeacon(beacon, data);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address beacon) {\n        bytes32 slot = _BEACON_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            beacon := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_beacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        require(\n            Address.isContract(beacon),\n            \"BeaconProxy: beacon is not a contract\"\n        );\n        require(\n            Address.isContract(IBeacon(beacon).implementation()),\n            \"BeaconProxy: beacon implementation is not a contract\"\n        );\n        bytes32 slot = _BEACON_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, beacon)\n        }\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive () external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../access/Ownable.sol\";\nimport \"./TransparentUpgradeableProxy.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./UpgradeableProxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(admin_);\n    }\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _admin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _admin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\n        _upgradeTo(newImplementation);\n        Address.functionDelegateCall(newImplementation, data);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address adm) {\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adm := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        bytes32 slot = _ADMIN_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newAdmin)\n        }\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../access/Ownable.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) public {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Proxy.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n *\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n * {TransparentUpgradeableProxy}.\n */\ncontract UpgradeableProxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) public payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if(_data.length > 0) {\n            Address.functionDelegateCall(_logic, _data);\n        }\n    }\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Upgrades the proxy to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal virtual {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        bytes32 slot = _IMPLEMENTATION_SLOT;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, newImplementation)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/arch/Hashing.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Value.sol\";\n\nlibrary Hashing {\n    using Hashing for Value.Data;\n    using Value for Value.CodePoint;\n\n    function keccak1(bytes32 b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(b));\n    }\n\n    function keccak2(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(a, b));\n    }\n\n    function bytes32FromArray(\n        bytes memory arr,\n        uint256 offset,\n        uint256 arrLength\n    ) internal pure returns (uint256) {\n        uint256 res = 0;\n        for (uint256 i = 0; i < 32; i++) {\n            res = res << 8;\n            bytes1 b = arrLength > offset + i ? arr[offset + i] : bytes1(0);\n            res = res | uint256(uint8(b));\n        }\n        return res;\n    }\n\n    /*\n     * !! Note that dataLength must be a power of two !!\n     *\n     * If you have an arbitrary data length, you can round it up with roundUpToPow2.\n     * The boolean return value tells if the data segment data[startOffset..startOffset+dataLength] only included zeroes.\n     * If pack is true, the returned value is the merkle hash where trailing zeroes are ignored, that is,\n     *   if h is the smallest height for which all data[startOffset+2**h..] are zero, merkle hash of data[startOffset..startOffset+2**h] is returned.\n     * If all elements in the data segment are zero (and pack is true), keccak1(bytes32(0)) is returned.\n     */\n    function merkleRoot(\n        bytes memory data,\n        uint256 rawDataLength,\n        uint256 startOffset,\n        uint256 dataLength,\n        bool pack\n    ) internal pure returns (bytes32, bool) {\n        if (dataLength <= 32) {\n            if (startOffset >= rawDataLength) {\n                return (keccak1(bytes32(0)), true);\n            }\n            bytes32 res = keccak1(bytes32(bytes32FromArray(data, startOffset, rawDataLength)));\n            return (res, res == keccak1(bytes32(0)));\n        }\n        (bytes32 h2, bool zero2) =\n            merkleRoot(data, rawDataLength, startOffset + dataLength / 2, dataLength / 2, false);\n        if (zero2 && pack) {\n            return merkleRoot(data, rawDataLength, startOffset, dataLength / 2, pack);\n        }\n        (bytes32 h1, bool zero1) =\n            merkleRoot(data, rawDataLength, startOffset, dataLength / 2, false);\n        return (keccak2(h1, h2), zero1 && zero2);\n    }\n\n    function roundUpToPow2(uint256 len) internal pure returns (uint256) {\n        if (len <= 1) return 1;\n        else return 2 * roundUpToPow2((len + 1) / 2);\n    }\n\n    function bytesToBufferHash(\n        bytes memory buf,\n        uint256 startOffset,\n        uint256 length\n    ) internal pure returns (bytes32) {\n        (bytes32 mhash, ) =\n            merkleRoot(buf, startOffset + length, startOffset, roundUpToPow2(length), true);\n        return keccak2(bytes32(uint256(123)), mhash);\n    }\n\n    function hashInt(uint256 val) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(val));\n    }\n\n    function hashCodePoint(Value.CodePoint memory cp) internal pure returns (bytes32) {\n        assert(cp.immediate.length < 2);\n        if (cp.immediate.length == 0) {\n            return\n                keccak256(abi.encodePacked(Value.codePointTypeCode(), cp.opcode, cp.nextCodePoint));\n        }\n        return\n            keccak256(\n                abi.encodePacked(\n                    Value.codePointTypeCode(),\n                    cp.opcode,\n                    cp.immediate[0].hash(),\n                    cp.nextCodePoint\n                )\n            );\n    }\n\n    function hashTuplePreImage(bytes32 innerHash, uint256 valueSize)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(uint8(Value.tupleTypeCode()), innerHash, valueSize));\n    }\n\n    function hash(Value.Data memory val) internal pure returns (bytes32) {\n        if (val.typeCode == Value.intTypeCode()) {\n            return hashInt(val.intVal);\n        } else if (val.typeCode == Value.codePointTypeCode()) {\n            return hashCodePoint(val.cpVal);\n        } else if (val.typeCode == Value.tuplePreImageTypeCode()) {\n            return hashTuplePreImage(bytes32(val.intVal), val.size);\n        } else if (val.typeCode == Value.tupleTypeCode()) {\n            Value.Data memory preImage = getTuplePreImage(val.tupleVal);\n            return preImage.hash();\n        } else if (val.typeCode == Value.hashOnlyTypeCode()) {\n            return bytes32(val.intVal);\n        } else if (val.typeCode == Value.bufferTypeCode()) {\n            return keccak256(abi.encodePacked(uint256(123), val.bufferHash));\n        } else {\n            require(false, \"Invalid type code\");\n        }\n    }\n\n    function getTuplePreImage(Value.Data[] memory vals) internal pure returns (Value.Data memory) {\n        require(vals.length <= 8, \"Invalid tuple length\");\n        bytes32[] memory hashes = new bytes32[](vals.length);\n        uint256 hashCount = hashes.length;\n        uint256 size = 1;\n        for (uint256 i = 0; i < hashCount; i++) {\n            hashes[i] = vals[i].hash();\n            size += vals[i].size;\n        }\n        bytes32 firstHash = keccak256(abi.encodePacked(uint8(hashes.length), hashes));\n        return Value.newTuplePreImage(firstHash, size);\n    }\n}\n"
    },
    "contracts/arch/IOneStepProof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\n\ninterface IOneStepProof {\n    // Bridges is sequencer bridge then delayed bridge\n    function executeStep(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    )\n        external\n        view\n        returns (\n            uint64 gas,\n            uint256 afterMessagesRead,\n            bytes32[4] memory fields\n        );\n\n    function executeStepDebug(\n        address[2] calldata bridges,\n        uint256 initialMessagesRead,\n        bytes32[2] calldata accs,\n        bytes calldata proof,\n        bytes calldata bproof\n    ) external view returns (string memory startMachine, string memory afterMachine);\n}\n"
    },
    "contracts/arch/Marshaling.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Value.sol\";\nimport \"./Hashing.sol\";\n\nimport \"../libraries/BytesLib.sol\";\n\nlibrary Marshaling {\n    using BytesLib for bytes;\n    using Value for Value.Data;\n\n    // This depends on how it's implemented in arb-os\n    function deserializeMessage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            bool,\n            uint256,\n            address,\n            uint8,\n            bytes memory\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 8, \"too short\");\n        uint256 size = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            size *= 256;\n            size += uint8(data[startOffset + 7 - i]);\n        }\n        (, uint256 sender) = deserializeInt(data, startOffset + 8);\n        (, uint256 kind) = deserializeInt(data, startOffset + 8 + 32);\n        bytes memory res = new bytes(size - 64);\n        for (uint256 i = 0; i < size - 64; i++) {\n            res[i] = data[startOffset + 8 + 64 + i];\n        }\n        return (true, startOffset + 8 + size, address(uint160(sender)), uint8(kind), res);\n    }\n\n    function deserializeRawMessage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            bool,\n            uint256,\n            bytes memory\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 8, \"too short\");\n        uint256 size = 0;\n        for (uint256 i = 0; i < 8; i++) {\n            size *= 256;\n            size += uint8(data[startOffset + 7 - i]);\n        }\n        bytes memory res = new bytes(size);\n        for (uint256 i = 0; i < size; i++) {\n            res[i] = data[startOffset + 8 + i];\n        }\n        return (true, startOffset + 8 + size, res);\n    }\n\n    function deserializeHashPreImage(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (uint256 offset, Value.Data memory value)\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 64, \"too short\");\n        bytes32 hashData;\n        uint256 size;\n        (offset, hashData) = extractBytes32(data, startOffset);\n        (offset, size) = deserializeInt(data, offset);\n        return (offset, Value.newTuplePreImage(hashData, size));\n    }\n\n    function deserializeInt(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            uint256 // val\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, data.toUint(startOffset));\n    }\n\n    function deserializeBytes32(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            bytes32 // val\n        )\n    {\n        require(data.length >= startOffset && data.length - startOffset >= 32, \"too short\");\n        return (startOffset + 32, data.toBytes32(startOffset));\n    }\n\n    function deserializeCodePoint(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data memory // val\n        )\n    {\n        uint256 offset = startOffset;\n        uint8 immediateType;\n        uint8 opCode;\n        Value.Data memory immediate;\n        bytes32 nextHash;\n\n        (offset, immediateType) = extractUint8(data, offset);\n        (offset, opCode) = extractUint8(data, offset);\n        if (immediateType == 1) {\n            (offset, immediate) = deserialize(data, offset);\n        }\n        (offset, nextHash) = extractBytes32(data, offset);\n        if (immediateType == 1) {\n            return (offset, Value.newCodePoint(opCode, nextHash, immediate));\n        }\n        return (offset, Value.newCodePoint(opCode, nextHash));\n    }\n\n    function deserializeTuple(\n        uint8 memberCount,\n        bytes memory data,\n        uint256 startOffset\n    )\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data[] memory // val\n        )\n    {\n        uint256 offset = startOffset;\n        Value.Data[] memory members = new Value.Data[](memberCount);\n        for (uint8 i = 0; i < memberCount; i++) {\n            (offset, members[i]) = deserialize(data, offset);\n        }\n        return (offset, members);\n    }\n\n    function deserialize(bytes memory data, uint256 startOffset)\n        internal\n        pure\n        returns (\n            uint256, // offset\n            Value.Data memory // val\n        )\n    {\n        require(startOffset < data.length, \"invalid offset\");\n        (uint256 offset, uint8 valType) = extractUint8(data, startOffset);\n        if (valType == Value.intTypeCode()) {\n            uint256 intVal;\n            (offset, intVal) = deserializeInt(data, offset);\n            return (offset, Value.newInt(intVal));\n        } else if (valType == Value.codePointTypeCode()) {\n            return deserializeCodePoint(data, offset);\n        } else if (valType == Value.bufferTypeCode()) {\n            bytes32 hashVal;\n            (offset, hashVal) = deserializeBytes32(data, offset);\n            return (offset, Value.newBuffer(hashVal));\n        } else if (valType == Value.tuplePreImageTypeCode()) {\n            return deserializeHashPreImage(data, offset);\n        } else if (valType >= Value.tupleTypeCode() && valType < Value.valueTypeCode()) {\n            uint8 tupLength = uint8(valType - Value.tupleTypeCode());\n            Value.Data[] memory tupleVal;\n            (offset, tupleVal) = deserializeTuple(tupLength, data, offset);\n            return (offset, Value.newTuple(tupleVal));\n        }\n        require(false, \"invalid typecode\");\n    }\n\n    function extractUint8(bytes memory data, uint256 startOffset)\n        private\n        pure\n        returns (\n            uint256, // offset\n            uint8 // val\n        )\n    {\n        return (startOffset + 1, uint8(data[startOffset]));\n    }\n\n    function extractBytes32(bytes memory data, uint256 startOffset)\n        private\n        pure\n        returns (\n            uint256, // offset\n            bytes32 // val\n        )\n    {\n        return (startOffset + 32, data.toBytes32(startOffset));\n    }\n}\n"
    },
    "contracts/arch/Value.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary Value {\n    uint8 internal constant INT_TYPECODE = 0;\n    uint8 internal constant CODE_POINT_TYPECODE = 1;\n    uint8 internal constant HASH_PRE_IMAGE_TYPECODE = 2;\n    uint8 internal constant TUPLE_TYPECODE = 3;\n    uint8 internal constant BUFFER_TYPECODE = TUPLE_TYPECODE + 9;\n    // All values received from clients will have type codes less than the VALUE_TYPE_COUNT\n    uint8 internal constant VALUE_TYPE_COUNT = TUPLE_TYPECODE + 10;\n\n    // The following types do not show up in the marshalled format and is\n    // only used for internal tracking purposes\n    uint8 internal constant HASH_ONLY = 100;\n\n    struct CodePoint {\n        uint8 opcode;\n        bytes32 nextCodePoint;\n        Data[] immediate;\n    }\n\n    struct Data {\n        uint256 intVal;\n        CodePoint cpVal;\n        Data[] tupleVal;\n        bytes32 bufferHash;\n        uint8 typeCode;\n        uint256 size;\n    }\n\n    function tupleTypeCode() internal pure returns (uint8) {\n        return TUPLE_TYPECODE;\n    }\n\n    function tuplePreImageTypeCode() internal pure returns (uint8) {\n        return HASH_PRE_IMAGE_TYPECODE;\n    }\n\n    function intTypeCode() internal pure returns (uint8) {\n        return INT_TYPECODE;\n    }\n\n    function bufferTypeCode() internal pure returns (uint8) {\n        return BUFFER_TYPECODE;\n    }\n\n    function codePointTypeCode() internal pure returns (uint8) {\n        return CODE_POINT_TYPECODE;\n    }\n\n    function valueTypeCode() internal pure returns (uint8) {\n        return VALUE_TYPE_COUNT;\n    }\n\n    function hashOnlyTypeCode() internal pure returns (uint8) {\n        return HASH_ONLY;\n    }\n\n    function isValidTupleSize(uint256 size) internal pure returns (bool) {\n        return size <= 8;\n    }\n\n    function typeCodeVal(Data memory val) internal pure returns (Data memory) {\n        if (val.typeCode == 2) {\n            // Map HashPreImage to Tuple\n            return newInt(TUPLE_TYPECODE);\n        }\n        return newInt(val.typeCode);\n    }\n\n    function valLength(Data memory val) internal pure returns (uint8) {\n        if (val.typeCode == TUPLE_TYPECODE) {\n            return uint8(val.tupleVal.length);\n        } else {\n            return 1;\n        }\n    }\n\n    function isInt(Data memory val) internal pure returns (bool) {\n        return val.typeCode == INT_TYPECODE;\n    }\n\n    function isInt64(Data memory val) internal pure returns (bool) {\n        return val.typeCode == INT_TYPECODE && val.intVal < (1 << 64);\n    }\n\n    function isCodePoint(Data memory val) internal pure returns (bool) {\n        return val.typeCode == CODE_POINT_TYPECODE;\n    }\n\n    function isTuple(Data memory val) internal pure returns (bool) {\n        return val.typeCode == TUPLE_TYPECODE;\n    }\n\n    function isBuffer(Data memory val) internal pure returns (bool) {\n        return val.typeCode == BUFFER_TYPECODE;\n    }\n\n    function newEmptyTuple() internal pure returns (Data memory) {\n        return newTuple(new Data[](0));\n    }\n\n    function newBoolean(bool val) internal pure returns (Data memory) {\n        if (val) {\n            return newInt(1);\n        } else {\n            return newInt(0);\n        }\n    }\n\n    function newInt(uint256 _val) internal pure returns (Data memory) {\n        return\n            Data(_val, CodePoint(0, 0, new Data[](0)), new Data[](0), 0, INT_TYPECODE, uint256(1));\n    }\n\n    function newHashedValue(bytes32 valueHash, uint256 valueSize)\n        internal\n        pure\n        returns (Data memory)\n    {\n        return\n            Data(\n                uint256(valueHash),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                0,\n                HASH_ONLY,\n                valueSize\n            );\n    }\n\n    function newTuple(Data[] memory _val) internal pure returns (Data memory) {\n        require(isValidTupleSize(_val.length), \"Tuple must have valid size\");\n        uint256 size = 1;\n\n        for (uint256 i = 0; i < _val.length; i++) {\n            size += _val[i].size;\n        }\n\n        return Data(0, CodePoint(0, 0, new Data[](0)), _val, 0, TUPLE_TYPECODE, size);\n    }\n\n    function newTuplePreImage(bytes32 preImageHash, uint256 size)\n        internal\n        pure\n        returns (Data memory)\n    {\n        return\n            Data(\n                uint256(preImageHash),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                0,\n                HASH_PRE_IMAGE_TYPECODE,\n                size\n            );\n    }\n\n    function newCodePoint(uint8 opCode, bytes32 nextHash) internal pure returns (Data memory) {\n        return newCodePoint(CodePoint(opCode, nextHash, new Data[](0)));\n    }\n\n    function newCodePoint(\n        uint8 opCode,\n        bytes32 nextHash,\n        Data memory immediate\n    ) internal pure returns (Data memory) {\n        Data[] memory imm = new Data[](1);\n        imm[0] = immediate;\n        return newCodePoint(CodePoint(opCode, nextHash, imm));\n    }\n\n    function newCodePoint(CodePoint memory _val) private pure returns (Data memory) {\n        return Data(0, _val, new Data[](0), 0, CODE_POINT_TYPECODE, uint256(1));\n    }\n\n    function newBuffer(bytes32 bufHash) internal pure returns (Data memory) {\n        return\n            Data(\n                uint256(0),\n                CodePoint(0, 0, new Data[](0)),\n                new Data[](0),\n                bufHash,\n                BUFFER_TYPECODE,\n                uint256(1)\n            );\n    }\n}\n"
    },
    "contracts/bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Inbox.sol\";\nimport \"./Outbox.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./interfaces/IBridge.sol\";\n\ncontract Bridge is OwnableUpgradeable, IBridge {\n    using Address for address;\n    struct InOutInfo {\n        uint256 index;\n        bool allowed;\n    }\n\n    mapping(address => InOutInfo) private allowedInboxesMap;\n    mapping(address => InOutInfo) private allowedOutboxesMap;\n\n    address[] public allowedInboxList;\n    address[] public allowedOutboxList;\n\n    address public override activeOutbox;\n    bytes32[] public override inboxAccs;\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    function allowedInboxes(address inbox) external view override returns (bool) {\n        return allowedInboxesMap[inbox].allowed;\n    }\n\n    function allowedOutboxes(address outbox) external view override returns (bool) {\n        return allowedOutboxesMap[outbox].allowed;\n    }\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable override returns (uint256) {\n        require(allowedInboxesMap[msg.sender].allowed, \"NOT_FROM_INBOX\");\n        uint256 count = inboxAccs.length;\n        bytes32 messageHash =\n            Messages.messageHash(\n                kind,\n                sender,\n                block.number,\n                block.timestamp, // solhint-disable-line not-rely-on-time\n                count,\n                tx.gasprice,\n                messageDataHash\n            );\n        bytes32 prevAcc = 0;\n        if (count > 0) {\n            prevAcc = inboxAccs[count - 1];\n        }\n        inboxAccs.push(Messages.addMessageToInbox(prevAcc, messageHash));\n        emit MessageDelivered(count, prevAcc, msg.sender, kind, sender, messageDataHash);\n        return count;\n    }\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool success, bytes memory returnData) {\n        require(allowedOutboxesMap[msg.sender].allowed, \"NOT_FROM_OUTBOX\");\n        if (data.length > 0) require(destAddr.isContract(), \"NO_CODE_AT_DEST\");\n        address currentOutbox = activeOutbox;\n        activeOutbox = msg.sender;\n        (success, returnData) = destAddr.call{ value: amount }(data);\n        activeOutbox = currentOutbox;\n    }\n\n    function setInbox(address inbox, bool enabled) external override onlyOwner {\n        InOutInfo storage info = allowedInboxesMap[inbox];\n        bool alreadyEnabled = info.allowed;\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\n            return;\n        }\n        if (enabled) {\n            allowedInboxesMap[inbox] = InOutInfo(allowedInboxList.length, true);\n            allowedInboxList.push(inbox);\n        } else {\n            allowedInboxList[info.index] = allowedInboxList[allowedInboxList.length - 1];\n            allowedInboxesMap[allowedInboxList[info.index]].index = info.index;\n            allowedInboxList.pop();\n            delete allowedInboxesMap[inbox];\n        }\n    }\n\n    function setOutbox(address outbox, bool enabled) external override onlyOwner {\n        InOutInfo storage info = allowedOutboxesMap[outbox];\n        bool alreadyEnabled = info.allowed;\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\n            return;\n        }\n        if (enabled) {\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\n            allowedOutboxList.push(outbox);\n        } else {\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\n            allowedOutboxList.pop();\n            delete allowedOutboxesMap[outbox];\n        }\n    }\n\n    function messageCount() external view override returns (uint256) {\n        return inboxAccs.length;\n    }\n}\n"
    },
    "contracts/bridge/Inbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./interfaces/IInbox.sol\";\nimport \"./interfaces/IBridge.sol\";\n\nimport \"./Messages.sol\";\nimport \"../libraries/Cloneable.sol\";\nimport \"../libraries/Whitelist.sol\";\n\ncontract Inbox is IInbox, WhitelistConsumer, Cloneable {\n    uint8 internal constant ETH_TRANSFER = 0;\n    uint8 internal constant L2_MSG = 3;\n    uint8 internal constant L1MessageType_L2FundedByL1 = 7;\n    uint8 internal constant L1MessageType_submitRetryableTx = 9;\n\n    uint8 internal constant L2MessageType_unsignedEOATx = 0;\n    uint8 internal constant L2MessageType_unsignedContractTx = 1;\n\n    IBridge public override bridge;\n\n    function initialize(IBridge _bridge, address _whitelist) external {\n        require(address(bridge) == address(0), \"ALREADY_INIT\");\n        bridge = _bridge;\n        WhitelistConsumer.whitelist = _whitelist;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData)\n        external\n        onlyWhitelisted\n        returns (uint256)\n    {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"origin only\");\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDeliveredFromOrigin(msgNum);\n        return msgNum;\n    }\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData)\n        external\n        override\n        onlyWhitelisted\n        returns (uint256)\n    {\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\n        emit InboxMessageDelivered(msgNum, messageData);\n        return msgNum;\n    }\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    maxGas,\n                    gasPriceBid,\n                    nonce,\n                    uint256(uint160(bytes20(destAddr))),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_L2FundedByL1,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    maxGas,\n                    gasPriceBid,\n                    uint256(uint160(bytes20(destAddr))),\n                    msg.value,\n                    data\n                )\n            );\n    }\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedEOATx,\n                    maxGas,\n                    gasPriceBid,\n                    nonce,\n                    uint256(uint160(bytes20(destAddr))),\n                    amount,\n                    data\n                )\n            );\n    }\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L2_MSG,\n                msg.sender,\n                abi.encodePacked(\n                    L2MessageType_unsignedContractTx,\n                    maxGas,\n                    gasPriceBid,\n                    uint256(uint160(bytes20(destAddr))),\n                    amount,\n                    data\n                )\n            );\n    }\n\n    function depositEth(uint256 maxSubmissionCost)\n        external\n        payable\n        virtual\n        override\n        onlyWhitelisted\n        returns (uint256)\n    {\n        return\n            this.createRetryableTicket{ value: msg.value }(\n                msg.sender,\n                0,\n                maxSubmissionCost,\n                msg.sender,\n                msg.sender,\n                0,\n                0,\n                \"\"\n            );\n    }\n\n    /**\n    @notice Put an message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n    * @dev all msg.value will deposited to callValueRefundAddress on L2\n    * @param destAddr destination L2 contract address\n    * @param l2CallValue call value for retryable L2 message \n    * @param  maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    * @param excessFeeRefundAddress maxgas x gasprice - execution cost gets credited here on L2 balance\n    * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n    * @param maxGas Max gas deducted from user's L2 balance to cover L2 execution\n    * @param gasPriceBid price bid for L2 execution\n    * @param data ABI encoded data of L2 message \n    * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\n     */\n    function createRetryableTicket(\n        address destAddr,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable virtual override onlyWhitelisted returns (uint256) {\n        return\n            _deliverMessage(\n                L1MessageType_submitRetryableTx,\n                msg.sender,\n                abi.encodePacked(\n                    uint256(uint160(bytes20(destAddr))),\n                    l2CallValue,\n                    msg.value,\n                    maxSubmissionCost,\n                    uint256(uint160(bytes20(excessFeeRefundAddress))),\n                    uint256(uint160(bytes20(callValueRefundAddress))),\n                    maxGas,\n                    gasPriceBid,\n                    data.length,\n                    data\n                )\n            );\n    }\n\n    function _deliverMessage(\n        uint8 _kind,\n        address _sender,\n        bytes memory _messageData\n    ) internal returns (uint256) {\n        uint256 msgNum = deliverToBridge(_kind, _sender, keccak256(_messageData));\n        emit InboxMessageDelivered(msgNum, _messageData);\n        return msgNum;\n    }\n\n    function deliverToBridge(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) internal returns (uint256) {\n        return bridge.deliverMessageToInbox{ value: msg.value }(kind, sender, messageDataHash);\n    }\n}\n"
    },
    "contracts/bridge/Messages.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary Messages {\n    function messageHash(\n        uint8 kind,\n        address sender,\n        uint256 blockNumber,\n        uint256 timestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        bytes32 messageDataHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    kind,\n                    sender,\n                    blockNumber,\n                    timestamp,\n                    inboxSeqNum,\n                    gasPriceL1,\n                    messageDataHash\n                )\n            );\n    }\n\n    function addMessageToInbox(bytes32 inbox, bytes32 message) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(inbox, message));\n    }\n}\n"
    },
    "contracts/bridge/Outbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./OutboxEntry.sol\";\n\nimport \"./interfaces/IOutbox.sol\";\nimport \"./interfaces/IBridge.sol\";\n\nimport \"./Messages.sol\";\nimport \"../libraries/MerkleLib.sol\";\nimport \"../libraries/BytesLib.sol\";\nimport \"../libraries/Cloneable.sol\";\n\nimport \"@openzeppelin/contracts/proxy/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\";\n\ncontract Outbox is IOutbox, Cloneable {\n    using BytesLib for bytes;\n\n    bytes1 internal constant MSG_ROOT = 0;\n\n    uint8 internal constant SendType_sendTxToL1 = 3;\n\n    address public rollup;\n    IBridge public bridge;\n\n    UpgradeableBeacon public beacon;\n    OutboxEntry[] public outboxes;\n\n    // Note, these variables are set and then wiped during a single transaction.\n    // Therefore their values don't need to be maintained, and their slots will\n    // be empty outside of transactions\n    address internal _sender;\n    uint128 internal _l2Block;\n    uint128 internal _l1Block;\n    uint128 internal _timestamp;\n\n    function initialize(address _rollup, IBridge _bridge) external {\n        require(rollup == address(0), \"ALREADY_INIT\");\n        rollup = _rollup;\n        bridge = _bridge;\n\n        address outboxEntryTemplate = address(new OutboxEntry());\n        beacon = new UpgradeableBeacon(outboxEntryTemplate);\n        beacon.transferOwnership(_rollup);\n    }\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    /// When the return value is zero, that means this is a system message\n    function l2ToL1Sender() external view override returns (address) {\n        return _sender;\n    }\n\n    function l2ToL1Block() external view override returns (uint256) {\n        return uint256(_l2Block);\n    }\n\n    function l2ToL1EthBlock() external view override returns (uint256) {\n        return uint256(_l1Block);\n    }\n\n    function l2ToL1Timestamp() external view override returns (uint256) {\n        return uint256(_timestamp);\n    }\n\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\n        external\n        override\n    {\n        require(msg.sender == rollup, \"ONLY_ROLLUP\");\n        // If we've reached here, we've already confirmed that sum(sendLengths) == sendsData.length\n        uint256 messageCount = sendLengths.length;\n        uint256 offset = 0;\n        for (uint256 i = 0; i < messageCount; i++) {\n            handleOutgoingMessage(bytes(sendsData[offset:offset + sendLengths[i]]));\n            offset += sendLengths[i];\n        }\n    }\n\n    function handleOutgoingMessage(bytes memory data) private {\n        // Otherwise we have an unsupported message type and we skip the message\n        if (data[0] == MSG_ROOT) {\n            require(data.length == 97, \"BAD_LENGTH\");\n            uint256 batchNum = data.toUint(1);\n            uint256 numInBatch = data.toUint(33);\n            bytes32 outputRoot = data.toBytes32(65);\n\n            address clone = address(new BeaconProxy(address(beacon), \"\"));\n            OutboxEntry(clone).initialize(outputRoot, numInBatch);\n            uint256 outboxIndex = outboxes.length;\n            outboxes.push(OutboxEntry(clone));\n            emit OutboxEntryCreated(batchNum, outboxIndex, outputRoot, numInBatch);\n        }\n    }\n\n    /**\n     * @notice Executes a messages in an Outbox entry. Reverts if dispute period hasn't expired and\n     * @param outboxIndex Index of OutboxEntry in outboxes array\n     * @param proof Merkle proof of message inclusion in outbox entry\n     * @param index Index of message in outbox entry\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param destAddr destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param amount value in L1 message in wei\n     * @param calldataForL1 abi-encoded L1 message data\n     */\n    function executeTransaction(\n        uint256 outboxIndex,\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address destAddr,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 amount,\n        bytes calldata calldataForL1\n    ) external virtual {\n        bytes32 userTx =\n            calculateItemHash(\n                l2Sender,\n                destAddr,\n                l2Block,\n                l1Block,\n                l2Timestamp,\n                amount,\n                calldataForL1\n            );\n\n        spendOutput(outboxIndex, proof, index, userTx);\n        emit OutBoxTransactionExecuted(destAddr, l2Sender, outboxIndex, index);\n\n        address currentSender = _sender;\n        uint128 currentL2Block = _l2Block;\n        uint128 currentL1Block = _l1Block;\n        uint128 currentTimestamp = _timestamp;\n\n        _sender = l2Sender;\n        _l2Block = uint128(l2Block);\n        _l1Block = uint128(l1Block);\n        _timestamp = uint128(l2Timestamp);\n\n        executeBridgeCall(destAddr, amount, calldataForL1);\n\n        _sender = currentSender;\n        _l2Block = currentL2Block;\n        _l1Block = currentL1Block;\n        _timestamp = currentTimestamp;\n    }\n\n    function spendOutput(\n        uint256 outboxIndex,\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) internal {\n        require(proof.length <= 256, \"PROOF_TOO_LONG\");\n        require(path < 2**proof.length, \"PATH_NOT_MINIMAL\");\n\n        // Hash the leaf an extra time to prove it's a leaf\n        bytes32 calcRoot = calculateMerkleRoot(proof, path, item);\n        OutboxEntry outbox = outboxes[outboxIndex];\n        require(address(outbox) != address(0), \"NO_OUTBOX\");\n\n        // With a minimal path, the pair of path and proof length should always identify\n        // a unique leaf. The path itself is not enough since the path length to different\n        // leaves could potentially be different\n        bytes32 uniqueKey = keccak256(abi.encodePacked(path, proof.length));\n        uint256 numRemaining = outbox.spendOutput(calcRoot, uniqueKey);\n\n        if (numRemaining == 0) {\n            outbox.destroy();\n            outboxes[outboxIndex] = OutboxEntry(address(0));\n        }\n    }\n\n    function executeBridgeCall(\n        address destAddr,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        (bool success, bytes memory returndata) = bridge.executeCall(destAddr, amount, data);\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"BRIDGE_CALL_FAILED\");\n            }\n        }\n    }\n\n    function calculateItemHash(\n        address l2Sender,\n        address destAddr,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 amount,\n        bytes calldata calldataForL1\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    SendType_sendTxToL1,\n                    uint256(uint160(bytes20(l2Sender))),\n                    uint256(uint160(bytes20(destAddr))),\n                    l2Block,\n                    l1Block,\n                    l2Timestamp,\n                    amount,\n                    calldataForL1\n                )\n            );\n    }\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) public pure returns (bytes32) {\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\n    }\n\n    function outboxesLength() public view returns (uint256) {\n        return outboxes.length;\n    }\n}\n"
    },
    "contracts/bridge/OutboxEntry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../libraries/Cloneable.sol\";\n\ncontract OutboxEntry is Cloneable {\n    address outbox;\n    bytes32 public root;\n    uint256 public numRemaining;\n    mapping(bytes32 => bool) public spentOutput;\n\n    function initialize(bytes32 _root, uint256 _numInBatch) external {\n        require(outbox == address(0), \"ALREADY_INIT\");\n        require(root == 0, \"ALREADY_INIT\");\n        require(_root != 0, \"BAD_ROOT\");\n        outbox = msg.sender;\n        root = _root;\n        numRemaining = _numInBatch;\n    }\n\n    function spendOutput(bytes32 _root, bytes32 _id) external returns (uint256) {\n        require(msg.sender == outbox, \"NOT_FROM_OUTBOX\");\n        require(!spentOutput[_id], \"ALREADY_SPENT\");\n        require(_root == root, \"BAD_ROOT\");\n\n        spentOutput[_id] = true;\n        numRemaining--;\n\n        return numRemaining;\n    }\n\n    function destroy() external {\n        require(msg.sender == outbox, \"NOT_FROM_OUTBOX\");\n        safeSelfDestruct(msg.sender);\n    }\n}\n"
    },
    "contracts/bridge/SequencerInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./interfaces/ISequencerInbox.sol\";\nimport \"./interfaces/IBridge.sol\";\nimport \"../arch/Marshaling.sol\";\nimport \"../libraries/Cloneable.sol\";\nimport \"../rollup/Rollup.sol\";\n\nimport \"./Messages.sol\";\n\ncontract SequencerInbox is ISequencerInbox, Cloneable {\n    uint8 internal constant L2_MSG = 3;\n    uint8 internal constant END_OF_BLOCK = 6;\n\n    bytes32[] public override inboxAccs;\n    uint256 public override messageCount;\n\n    uint256 totalDelayedMessagesRead;\n\n    IBridge public delayedInbox;\n    address public sequencer;\n    address public rollup;\n\n    function initialize(\n        IBridge _delayedInbox,\n        address _sequencer,\n        address _rollup\n    ) external {\n        require(address(delayedInbox) == address(0), \"ALREADY_INIT\");\n        delayedInbox = _delayedInbox;\n        sequencer = _sequencer;\n        rollup = _rollup;\n    }\n\n    function setSequencer(address newSequencer) external override {\n        require(msg.sender == rollup, \"ONLY_ROLLUP\");\n        sequencer = newSequencer;\n        emit SequencerAddressUpdated(newSequencer);\n    }\n\n    function maxDelayBlocks() public view override returns (uint256) {\n        return RollupBase(rollup).sequencerInboxMaxDelayBlocks();\n    }\n\n    function maxDelaySeconds() public view override returns (uint256) {\n        return RollupBase(rollup).sequencerInboxMaxDelaySeconds();\n    }\n\n    function getLastDelayedAcc() internal view returns (bytes32) {\n        bytes32 acc = 0;\n        if (totalDelayedMessagesRead > 0) {\n            acc = delayedInbox.inboxAccs(totalDelayedMessagesRead - 1);\n        }\n        return acc;\n    }\n\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint256[2] calldata l1BlockAndTimestamp,\n        uint256 inboxSeqNum,\n        uint256 gasPriceL1,\n        address sender,\n        bytes32 messageDataHash,\n        bytes32 delayedAcc\n    ) external {\n        require(_totalDelayedMessagesRead > totalDelayedMessagesRead, \"DELAYED_BACKWARDS\");\n        {\n            bytes32 messageHash =\n                Messages.messageHash(\n                    kind,\n                    sender,\n                    l1BlockAndTimestamp[0],\n                    l1BlockAndTimestamp[1],\n                    inboxSeqNum,\n                    gasPriceL1,\n                    messageDataHash\n                );\n            require(l1BlockAndTimestamp[0] + maxDelayBlocks() < block.number, \"MAX_DELAY_BLOCKS\");\n            require(l1BlockAndTimestamp[1] + maxDelaySeconds() < block.timestamp, \"MAX_DELAY_TIME\");\n\n            bytes32 prevDelayedAcc = 0;\n            if (_totalDelayedMessagesRead > 1) {\n                prevDelayedAcc = delayedInbox.inboxAccs(_totalDelayedMessagesRead - 2);\n            }\n            require(\n                delayedInbox.inboxAccs(_totalDelayedMessagesRead - 1) ==\n                    Messages.addMessageToInbox(prevDelayedAcc, messageHash),\n                \"DELAYED_ACCUMULATOR\"\n            );\n        }\n\n        uint256 startNum = messageCount;\n        bytes32 beforeAcc = 0;\n        if (inboxAccs.length > 0) {\n            beforeAcc = inboxAccs[inboxAccs.length - 1];\n        }\n\n        (bytes32 acc, uint256 count) =\n            includeDelayedMessages(\n                beforeAcc,\n                startNum,\n                _totalDelayedMessagesRead,\n                block.number,\n                block.timestamp,\n                delayedAcc\n            );\n        inboxAccs.push(acc);\n        messageCount = count;\n        emit DelayedInboxForced(\n            startNum,\n            beforeAcc,\n            count,\n            _totalDelayedMessagesRead,\n            [acc, delayedAcc],\n            inboxAccs.length - 1\n        );\n    }\n\n    function addSequencerL2BatchFromOrigin(\n        bytes calldata transactions,\n        uint256[] calldata lengths,\n        uint256[] calldata sectionsMetadata,\n        bytes32 afterAcc\n    ) external {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender == tx.origin, \"origin only\");\n        uint256 startNum = messageCount;\n        bytes32 beforeAcc =\n            addSequencerL2BatchImpl(transactions, lengths, sectionsMetadata, afterAcc);\n        emit SequencerBatchDeliveredFromOrigin(\n            startNum,\n            beforeAcc,\n            messageCount,\n            afterAcc,\n            inboxAccs.length - 1\n        );\n    }\n\n    function addSequencerL2Batch(\n        bytes calldata transactions,\n        uint256[] calldata lengths,\n        uint256[] calldata sectionsMetadata,\n        bytes32 afterAcc\n    ) external {\n        uint256 startNum = messageCount;\n        bytes32 beforeAcc =\n            addSequencerL2BatchImpl(transactions, lengths, sectionsMetadata, afterAcc);\n        emit SequencerBatchDelivered(\n            startNum,\n            beforeAcc,\n            messageCount,\n            afterAcc,\n            transactions,\n            lengths,\n            sectionsMetadata,\n            inboxAccs.length - 1,\n            msg.sender\n        );\n    }\n\n    function addSequencerL2BatchImpl(\n        bytes memory transactions,\n        uint256[] calldata lengths,\n        uint256[] calldata sectionsMetadata,\n        bytes32 afterAcc\n    ) private returns (bytes32 beforeAcc) {\n        require(msg.sender == sequencer, \"ONLY_SEQUENCER\");\n\n        if (inboxAccs.length > 0) {\n            beforeAcc = inboxAccs[inboxAccs.length - 1];\n        }\n\n        uint256 runningCount = messageCount;\n        bytes32 runningAcc = beforeAcc;\n        uint256 processedItems = 0;\n        uint256 dataOffset;\n        assembly {\n            dataOffset := add(transactions, 32)\n        }\n        for (uint256 i = 0; i + 5 <= sectionsMetadata.length; i += 5) {\n            // Each metadata section consists of:\n            // [numItems, l1BlockNumber, l1Timestamp, newTotalDelayedMessagesRead, newDelayedAcc]\n            {\n                uint256 l1BlockNumber = sectionsMetadata[i + 1];\n                require(l1BlockNumber + maxDelayBlocks() >= block.number, \"BLOCK_TOO_OLD\");\n                require(l1BlockNumber <= block.number, \"BLOCK_TOO_NEW\");\n            }\n            {\n                uint256 l1Timestamp = sectionsMetadata[i + 2];\n                require(l1Timestamp + maxDelaySeconds() >= block.timestamp, \"TIME_TOO_OLD\");\n                require(l1Timestamp <= block.timestamp, \"TIME_TOO_NEW\");\n            }\n\n            {\n                bytes32 prefixHash =\n                    keccak256(\n                        abi.encodePacked(\n                            msg.sender,\n                            sectionsMetadata[i + 1],\n                            sectionsMetadata[i + 2]\n                        )\n                    );\n                uint256 numItems = sectionsMetadata[i];\n                (runningAcc, runningCount, dataOffset) = calcL2Batch(\n                    dataOffset,\n                    lengths,\n                    processedItems,\n                    numItems, // num items\n                    prefixHash,\n                    runningCount,\n                    runningAcc\n                );\n                processedItems += numItems; // num items\n            }\n\n            uint256 newTotalDelayedMessagesRead = sectionsMetadata[i + 3];\n            require(newTotalDelayedMessagesRead >= totalDelayedMessagesRead, \"DELAYED_BACKWARDS\");\n            require(newTotalDelayedMessagesRead >= 1, \"MUST_DELAYED_INIT\");\n            require(\n                totalDelayedMessagesRead >= 1 || sectionsMetadata[i] == 0,\n                \"MUST_DELAYED_INIT_START\"\n            );\n            if (newTotalDelayedMessagesRead > totalDelayedMessagesRead) {\n                (runningAcc, runningCount) = includeDelayedMessages(\n                    runningAcc,\n                    runningCount,\n                    newTotalDelayedMessagesRead,\n                    sectionsMetadata[i + 1], // block number\n                    sectionsMetadata[i + 2], // timestamp\n                    bytes32(sectionsMetadata[i + 4]) // delayed accumulator\n                );\n            }\n        }\n\n        uint256 startOffset;\n        assembly {\n            startOffset := add(transactions, 32)\n        }\n        require(dataOffset >= startOffset, \"OFFSET_OVERFLOW\");\n        require(dataOffset <= startOffset + transactions.length, \"TRANSACTIONS_OVERRUN\");\n\n        require(runningCount > messageCount, \"EMPTY_BATCH\");\n        inboxAccs.push(runningAcc);\n        messageCount = runningCount;\n\n        require(runningAcc == afterAcc, \"AFTER_ACC\");\n    }\n\n    function calcL2Batch(\n        uint256 beforeOffset,\n        uint256[] calldata lengths,\n        uint256 lengthsOffset,\n        uint256 itemCount,\n        bytes32 prefixHash,\n        uint256 beforeCount,\n        bytes32 beforeAcc\n    )\n        private\n        pure\n        returns (\n            bytes32 acc,\n            uint256 count,\n            uint256 offset\n        )\n    {\n        offset = beforeOffset;\n        count = beforeCount;\n        acc = beforeAcc;\n        itemCount += lengthsOffset;\n        for (uint256 i = lengthsOffset; i < itemCount; i++) {\n            uint256 length = lengths[i];\n            bytes32 messageDataHash;\n            assembly {\n                messageDataHash := keccak256(offset, length)\n            }\n            acc = keccak256(abi.encodePacked(acc, count, prefixHash, messageDataHash));\n            offset += length;\n            count++;\n        }\n        return (acc, count, offset);\n    }\n\n    // Precondition: _totalDelayedMessagesRead > totalDelayedMessagesRead\n    function includeDelayedMessages(\n        bytes32 acc,\n        uint256 count,\n        uint256 _totalDelayedMessagesRead,\n        uint256 l1BlockNumber,\n        uint256 timestamp,\n        bytes32 delayedAcc\n    ) private returns (bytes32, uint256) {\n        require(_totalDelayedMessagesRead <= delayedInbox.messageCount(), \"DELAYED_TOO_FAR\");\n        require(delayedAcc == delayedInbox.inboxAccs(_totalDelayedMessagesRead - 1), \"DELAYED_ACC\");\n        acc = keccak256(\n            abi.encodePacked(\n                \"Delayed messages:\",\n                acc,\n                count,\n                totalDelayedMessagesRead,\n                _totalDelayedMessagesRead,\n                delayedAcc\n            )\n        );\n        count += _totalDelayedMessagesRead - totalDelayedMessagesRead;\n        bytes memory emptyBytes;\n        acc = keccak256(\n            abi.encodePacked(\n                acc,\n                count,\n                keccak256(abi.encodePacked(address(0), l1BlockNumber, timestamp)),\n                keccak256(emptyBytes)\n            )\n        );\n        count++;\n        totalDelayedMessagesRead = _totalDelayedMessagesRead;\n        return (acc, count);\n    }\n\n    function proveSeqBatchMsgCount(\n        bytes calldata proof,\n        uint256 offset,\n        bytes32 acc\n    ) internal pure returns (uint256, uint256) {\n        uint256 endCount;\n\n        bytes32 buildingAcc;\n        uint256 seqNum;\n        bytes32 messageHeaderHash;\n        bytes32 messageDataHash;\n        (offset, buildingAcc) = Marshaling.deserializeBytes32(proof, offset);\n        (offset, seqNum) = Marshaling.deserializeInt(proof, offset);\n        (offset, messageHeaderHash) = Marshaling.deserializeBytes32(proof, offset);\n        (offset, messageDataHash) = Marshaling.deserializeBytes32(proof, offset);\n        buildingAcc = keccak256(\n            abi.encodePacked(buildingAcc, seqNum, messageHeaderHash, messageDataHash)\n        );\n        endCount = seqNum + 1;\n        require(buildingAcc == acc, \"BATCH_ACC\");\n\n        return (offset, endCount);\n    }\n\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\n        external\n        view\n        override\n        returns (uint256, bytes32)\n    {\n        if (inboxCount == 0) {\n            return (0, 0);\n        }\n\n        (uint256 offset, uint256 seqBatchNum) = Marshaling.deserializeInt(proof, 0);\n        uint256 lastBatchCount = 0;\n        if (seqBatchNum > 0) {\n            (offset, lastBatchCount) = proveSeqBatchMsgCount(\n                proof,\n                offset,\n                inboxAccs[seqBatchNum - 1]\n            );\n            lastBatchCount++;\n        }\n\n        bytes32 seqBatchAcc = inboxAccs[seqBatchNum];\n        uint256 thisBatchCount;\n        (offset, thisBatchCount) = proveSeqBatchMsgCount(proof, offset, seqBatchAcc);\n\n        require(inboxCount > lastBatchCount, \"BATCH_START\");\n        require(inboxCount <= thisBatchCount, \"BATCH_END\");\n\n        return (thisBatchCount, seqBatchAcc);\n    }\n}\n"
    },
    "contracts/bridge/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    );\n\n    function deliverMessageToInbox(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    // These are only callable by the admin\n    function setInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // View functions\n\n    function activeOutbox() external view returns (address);\n\n    function allowedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function messageCount() external view returns (uint256);\n}\n"
    },
    "contracts/bridge/interfaces/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        uint256 nonce,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        address destAddr,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function createRetryableTicket(\n        address destAddr,\n        uint256 arbTxCallValue,\n        uint256 maxSubmissionCost,\n        address submissionRefundAddress,\n        address valueRefundAddress,\n        uint256 maxGas,\n        uint256 gasPriceBid,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n    function bridge() external view returns (IBridge);\n}\n"
    },
    "contracts/bridge/interfaces/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IMessageProvider {\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "contracts/bridge/interfaces/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IOutbox {\n    event OutboxEntryCreated(\n        uint256 indexed batchNum,\n        uint256 outboxIndex,\n        bytes32 outputRoot,\n        uint256 numInBatch\n    );\n    event OutBoxTransactionExecuted(\n        address indexed destAddr,\n        address indexed l2Sender,\n        uint256 indexed outboxIndex,\n        uint256 transactionIndex\n    );\n\n    function l2ToL1Sender() external view returns (address);\n\n    function l2ToL1Block() external view returns (uint256);\n\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\n        external;\n}\n"
    },
    "contracts/bridge/interfaces/ISequencerInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ISequencerInbox {\n    event SequencerBatchDelivered(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        bytes32 afterAcc,\n        bytes transactions,\n        uint256[] lengths,\n        uint256[] sectionsMetadata,\n        uint256 seqBatchIndex,\n        address sequencer\n    );\n\n    event SequencerBatchDeliveredFromOrigin(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        bytes32 afterAcc,\n        uint256 seqBatchIndex\n    );\n\n    event DelayedInboxForced(\n        uint256 indexed firstMessageNum,\n        bytes32 indexed beforeAcc,\n        uint256 newMessageCount,\n        uint256 totalDelayedMessagesRead,\n        bytes32[2] afterAccAndDelayed,\n        uint256 seqBatchIndex\n    );\n\n    event SequencerAddressUpdated(address newAddress);\n\n    function setSequencer(address newSequencer) external;\n\n    function messageCount() external view returns (uint256);\n\n    function maxDelayBlocks() external view returns (uint256);\n\n    function maxDelaySeconds() external view returns (uint256);\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function proveBatchContainsSequenceNumber(bytes calldata proof, uint256 inboxCount)\n        external\n        view\n        returns (uint256, bytes32);\n}\n"
    },
    "contracts/challenge/ChallengeLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../libraries/MerkleLib.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary ChallengeLib {\n    using SafeMath for uint256;\n\n    function firstSegmentSize(uint256 totalCount, uint256 bisectionCount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return totalCount / bisectionCount + (totalCount % bisectionCount);\n    }\n\n    function otherSegmentSize(uint256 totalCount, uint256 bisectionCount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return totalCount / bisectionCount;\n    }\n\n    function bisectionChunkHash(\n        uint256 _segmentStart,\n        uint256 _segmentLength,\n        bytes32 _startHash,\n        bytes32 _endHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_segmentStart, _segmentLength, _startHash, _endHash));\n    }\n\n    function inboxDeltaHash(bytes32 _inboxAcc, bytes32 _deltaAcc) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_inboxAcc, _deltaAcc));\n    }\n\n    function assertionHash(uint256 _arbGasUsed, bytes32 _restHash) internal pure returns (bytes32) {\n        // Note: make sure this doesn't return Challenge.UNREACHABLE_ASSERTION (currently 0)\n        return keccak256(abi.encodePacked(_arbGasUsed, _restHash));\n    }\n\n    function assertionRestHash(\n        uint256 _totalMessagesRead,\n        bytes32 _machineState,\n        bytes32 _sendAcc,\n        uint256 _sendCount,\n        bytes32 _logAcc,\n        uint256 _logCount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    _totalMessagesRead,\n                    _machineState,\n                    _sendAcc,\n                    _sendCount,\n                    _logAcc,\n                    _logCount\n                )\n            );\n    }\n\n    function updatedBisectionRoot(\n        bytes32[] memory _chainHashes,\n        uint256 _challengedSegmentStart,\n        uint256 _challengedSegmentLength\n    ) internal pure returns (bytes32) {\n        uint256 bisectionCount = _chainHashes.length - 1;\n        bytes32[] memory hashes = new bytes32[](bisectionCount);\n        uint256 chunkSize = ChallengeLib.firstSegmentSize(_challengedSegmentLength, bisectionCount);\n        uint256 segmentStart = _challengedSegmentStart;\n        hashes[0] = ChallengeLib.bisectionChunkHash(\n            segmentStart,\n            chunkSize,\n            _chainHashes[0],\n            _chainHashes[1]\n        );\n        segmentStart = segmentStart.add(chunkSize);\n        chunkSize = ChallengeLib.otherSegmentSize(_challengedSegmentLength, bisectionCount);\n        for (uint256 i = 1; i < bisectionCount; i++) {\n            hashes[i] = ChallengeLib.bisectionChunkHash(\n                segmentStart,\n                chunkSize,\n                _chainHashes[i],\n                _chainHashes[i + 1]\n            );\n            segmentStart = segmentStart.add(chunkSize);\n        }\n        return MerkleLib.generateRoot(hashes);\n    }\n\n    function verifySegmentProof(\n        bytes32 challengeState,\n        bytes32 item,\n        bytes32[] calldata _merkleNodes,\n        uint256 _merkleRoute\n    ) internal pure returns (bool) {\n        return challengeState == MerkleLib.calculateRoot(_merkleNodes, _merkleRoute, item);\n    }\n}\n"
    },
    "contracts/challenge/IChallenge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\nimport \"../arch/IOneStepProof.sol\";\n\ninterface IChallenge {\n    function initializeChallenge(\n        IOneStepProof[] calldata _executors,\n        address _resultReceiver,\n        bytes32 _executionHash,\n        uint256 _maxMessageCount,\n        address _asserter,\n        address _challenger,\n        uint256 _asserterTimeLeft,\n        uint256 _challengerTimeLeft,\n        ISequencerInbox _sequencerBridge,\n        IBridge _delayedBridge\n    ) external;\n\n    function currentResponderTimeLeft() external view returns (uint256);\n\n    function lastMoveBlock() external view returns (uint256);\n\n    function timeout() external;\n\n    function asserter() external view returns (address);\n\n    function challenger() external view returns (address);\n\n    function clearChallenge() external;\n}\n"
    },
    "contracts/challenge/IChallengeFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/ISequencerInbox.sol\";\n\ninterface IChallengeFactory {\n    function createChallenge(\n        address _resultReceiver,\n        bytes32 _executionHash,\n        uint256 _maxMessageCount,\n        address _asserter,\n        address _challenger,\n        uint256 _asserterTimeLeft,\n        uint256 _challengerTimeLeft,\n        ISequencerInbox _sequencerBridge,\n        IBridge _delayedBridge\n    ) external returns (address);\n}\n"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.6.11;\n\n/* solhint-disable no-inline-assembly */\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n/* solhint-enable no-inline-assembly */\n"
    },
    "contracts/libraries/Cloneable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./ICloneable.sol\";\n\ncontract Cloneable is ICloneable {\n    string private constant NOT_CLONE = \"NOT_CLONE\";\n\n    bool private isMasterCopy;\n\n    constructor() public {\n        isMasterCopy = true;\n    }\n\n    function isMaster() external view override returns (bool) {\n        return isMasterCopy;\n    }\n\n    function safeSelfDestruct(address payable dest) internal {\n        require(!isMasterCopy, NOT_CLONE);\n        selfdestruct(dest);\n    }\n}\n"
    },
    "contracts/libraries/ICloneable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface ICloneable {\n    function isMaster() external view returns (bool);\n}\n"
    },
    "contracts/libraries/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nlibrary MerkleLib {\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\n        bytes32[] memory prevLayer = _hashes;\n        while (prevLayer.length > 1) {\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\n            for (uint256 i = 0; i < nextLayer.length; i++) {\n                if (2 * i + 1 < prevLayer.length) {\n                    nextLayer[i] = keccak256(\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\n                    );\n                } else {\n                    nextLayer[i] = prevLayer[2 * i];\n                }\n            }\n            prevLayer = nextLayer;\n        }\n        return prevLayer[0];\n    }\n\n    function calculateRoot(\n        bytes32[] memory nodes,\n        uint256 route,\n        bytes32 item\n    ) internal pure returns (bytes32) {\n        uint256 proofItems = nodes.length;\n        require(proofItems <= 256);\n        bytes32 h = item;\n        for (uint256 i = 0; i < proofItems; i++) {\n            if (route % 2 == 0) {\n                h = keccak256(abi.encodePacked(nodes[i], h));\n            } else {\n                h = keccak256(abi.encodePacked(h, nodes[i]));\n            }\n            route /= 2;\n        }\n        return h;\n    }\n}\n"
    },
    "contracts/libraries/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nabstract contract WhitelistConsumer {\n    address public whitelist;\n\n    event WhitelistSourceUpdated(address newSource);\n\n    modifier onlyWhitelisted {\n        if (whitelist != address(0)) {\n            require(Whitelist(whitelist).isAllowed(msg.sender), \"NOT_WHITELISTED\");\n        }\n        _;\n    }\n\n    function updateWhitelistSource(address newSource) external {\n        require(msg.sender == whitelist, \"NOT_FROM_LIST\");\n        whitelist = newSource;\n        emit WhitelistSourceUpdated(newSource);\n    }\n}\n\ncontract Whitelist {\n    address public owner;\n    mapping(address => bool) public isAllowed;\n\n    event OwnerUpdated(address newOwner);\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            isAllowed[user[i]] = val[i];\n        }\n    }\n\n    // set new whitelist to address(0) to disable whitelist\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\n        for (uint256 i = 0; i < targets.length; i++) {\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\n        }\n        emit WhitelistUpgraded(newWhitelist, targets);\n    }\n}\n"
    },
    "contracts/rollup/BridgeCreator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/Bridge.sol\";\nimport \"../bridge/SequencerInbox.sol\";\nimport \"../bridge/Inbox.sol\";\nimport \"../bridge/Outbox.sol\";\nimport \"./RollupEventBridge.sol\";\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"../libraries/Whitelist.sol\";\n\ncontract BridgeCreator is Ownable {\n    Bridge public delayedBridgeTemplate;\n    SequencerInbox public sequencerInboxTemplate;\n    Inbox public inboxTemplate;\n    RollupEventBridge public rollupEventBridgeTemplate;\n    Outbox public outboxTemplate;\n\n    event TemplatesUpdated();\n\n    constructor() public Ownable() {\n        delayedBridgeTemplate = new Bridge();\n        sequencerInboxTemplate = new SequencerInbox();\n        inboxTemplate = new Inbox();\n        rollupEventBridgeTemplate = new RollupEventBridge();\n        outboxTemplate = new Outbox();\n    }\n\n    function updateTemplates(\n        address _delayedBridgeTemplate,\n        address _sequencerInboxTemplate,\n        address _inboxTemplate,\n        address _rollupEventBridgeTemplate,\n        address _outboxTemplate\n    ) external onlyOwner {\n        delayedBridgeTemplate = Bridge(_delayedBridgeTemplate);\n        sequencerInboxTemplate = SequencerInbox(_sequencerInboxTemplate);\n        inboxTemplate = Inbox(_inboxTemplate);\n        rollupEventBridgeTemplate = RollupEventBridge(_rollupEventBridgeTemplate);\n        outboxTemplate = Outbox(_outboxTemplate);\n\n        emit TemplatesUpdated();\n    }\n\n    struct CreateBridgeFrame {\n        ProxyAdmin admin;\n        Bridge delayedBridge;\n        SequencerInbox sequencerInbox;\n        Inbox inbox;\n        RollupEventBridge rollupEventBridge;\n        Outbox outbox;\n        Whitelist whitelist;\n    }\n\n    function createBridge(\n        address adminProxy,\n        address rollup,\n        address sequencer\n    )\n        external\n        returns (\n            Bridge,\n            SequencerInbox,\n            Inbox,\n            RollupEventBridge,\n            Outbox\n        )\n    {\n        CreateBridgeFrame memory frame;\n        {\n            frame.delayedBridge = Bridge(\n                address(\n                    new TransparentUpgradeableProxy(address(delayedBridgeTemplate), adminProxy, \"\")\n                )\n            );\n            frame.sequencerInbox = SequencerInbox(\n                address(\n                    new TransparentUpgradeableProxy(address(sequencerInboxTemplate), adminProxy, \"\")\n                )\n            );\n            frame.inbox = Inbox(\n                address(new TransparentUpgradeableProxy(address(inboxTemplate), adminProxy, \"\"))\n            );\n            frame.rollupEventBridge = RollupEventBridge(\n                address(\n                    new TransparentUpgradeableProxy(\n                        address(rollupEventBridgeTemplate),\n                        adminProxy,\n                        \"\"\n                    )\n                )\n            );\n            frame.outbox = Outbox(\n                address(new TransparentUpgradeableProxy(address(outboxTemplate), adminProxy, \"\"))\n            );\n            frame.whitelist = new Whitelist();\n        }\n\n        frame.delayedBridge.initialize();\n        frame.sequencerInbox.initialize(IBridge(frame.delayedBridge), sequencer, rollup);\n        frame.inbox.initialize(IBridge(frame.delayedBridge), address(frame.whitelist));\n        frame.rollupEventBridge.initialize(address(frame.delayedBridge), rollup);\n        frame.outbox.initialize(rollup, IBridge(frame.delayedBridge));\n\n        frame.delayedBridge.setInbox(address(frame.inbox), true);\n        frame.delayedBridge.transferOwnership(rollup);\n\n        frame.whitelist.setOwner(rollup);\n\n        return (\n            frame.delayedBridge,\n            frame.sequencerInbox,\n            frame.inbox,\n            frame.rollupEventBridge,\n            frame.outbox\n        );\n    }\n}\n"
    },
    "contracts/rollup/INode.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface INode {\n    function initialize(\n        address _rollup,\n        bytes32 _stateHash,\n        bytes32 _challengeHash,\n        bytes32 _confirmData,\n        uint256 _prev,\n        uint256 _deadlineBlock\n    ) external;\n\n    function destroy() external;\n\n    function addStaker(address staker) external returns (uint256);\n\n    function removeStaker(address staker) external;\n\n    function childCreated(uint256) external;\n\n    function resetChildren() external;\n\n    function newChildConfirmDeadline(uint256 deadline) external;\n\n    function stateHash() external view returns (bytes32);\n\n    function challengeHash() external view returns (bytes32);\n\n    function confirmData() external view returns (bytes32);\n\n    function prev() external view returns (uint256);\n\n    function deadlineBlock() external view returns (uint256);\n\n    function noChildConfirmedBeforeBlock() external view returns (uint256);\n\n    function stakerCount() external view returns (uint256);\n\n    function stakers(address staker) external view returns (bool);\n\n    function firstChildBlock() external view returns (uint256);\n\n    function latestChildNumber() external view returns (uint256);\n\n    function requirePastDeadline() external view;\n\n    function requirePastChildConfirmDeadline() external view;\n}\n"
    },
    "contracts/rollup/INodeFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface INodeFactory {\n    function createNode(\n        bytes32 _stateHash,\n        bytes32 _challengeHash,\n        bytes32 _confirmData,\n        uint256 _prev,\n        uint256 _deadlineBlock\n    ) external returns (address);\n}\n"
    },
    "contracts/rollup/IRollupCore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./INode.sol\";\n\ninterface IRollupCore {\n    function _stakerMap(address stakerAddress)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            bool\n        );\n\n    function getNode(uint256 nodeNum) external view returns (INode);\n\n    /**\n     * @notice Get the address of the staker at the given index\n     * @param stakerNum Index of the staker\n     * @return Address of the staker\n     */\n    function getStakerAddress(uint256 stakerNum) external view returns (address);\n\n    /**\n     * @notice Check whether the given staker is staked\n     * @param staker Staker address to check\n     * @return True or False for whether the staker was staked\n     */\n    function isStaked(address staker) external view returns (bool);\n\n    /**\n     * @notice Get the latest staked node of the given staker\n     * @param staker Staker address to lookup\n     * @return Latest node staked of the staker\n     */\n    function latestStakedNode(address staker) external view returns (uint256);\n\n    /**\n     * @notice Get the current challenge of the given staker\n     * @param staker Staker address to lookup\n     * @return Current challenge of the staker\n     */\n    function currentChallenge(address staker) external view returns (address);\n\n    /**\n     * @notice Get the amount staked of the given staker\n     * @param staker Staker address to lookup\n     * @return Amount staked of the staker\n     */\n    function amountStaked(address staker) external view returns (uint256);\n\n    /**\n     * @notice Get the original staker address of the zombie at the given index\n     * @param zombieNum Index of the zombie to lookup\n     * @return Original staker address of the zombie\n     */\n    function zombieAddress(uint256 zombieNum) external view returns (address);\n\n    /**\n     * @notice Get Latest node that the given zombie at the given index is staked on\n     * @param zombieNum Index of the zombie to lookup\n     * @return Latest node that the given zombie is staked on\n     */\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint256);\n\n    /// @return Current number of un-removed zombies\n    function zombieCount() external view returns (uint256);\n\n    function isZombie(address staker) external view returns (bool);\n\n    /**\n     * @notice Get the amount of funds withdrawable by the given address\n     * @param owner Address to check the funds of\n     * @return Amount of funds withdrawable by owner\n     */\n    function withdrawableFunds(address owner) external view returns (uint256);\n\n    /**\n     * @return Index of the first unresolved node\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\n     */\n    function firstUnresolvedNode() external view returns (uint256);\n\n    /// @return Index of the latest confirmed node\n    function latestConfirmed() external view returns (uint256);\n\n    /// @return Index of the latest rollup node created\n    function latestNodeCreated() external view returns (uint256);\n\n    /// @return Ethereum block that the most recent stake was created\n    function lastStakeBlock() external view returns (uint256);\n\n    /// @return Number of active stakers currently staked\n    function stakerCount() external view returns (uint256);\n\n    /// @return Node hash as of this node number\n    function getNodeHash(uint256 index) external view returns (bytes32);\n}\n"
    },
    "contracts/rollup/Rollup.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./RollupCore.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"./RollupEventBridge.sol\";\n\nimport \"./INode.sol\";\nimport \"./INodeFactory.sol\";\nimport \"../challenge/IChallenge.sol\";\nimport \"../challenge/IChallengeFactory.sol\";\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/IOutbox.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../bridge/Messages.sol\";\nimport \"./RollupLib.sol\";\nimport \"../libraries/Cloneable.sol\";\nimport \"./facets/IRollupFacets.sol\";\n\nabstract contract RollupBase is Cloneable, RollupCore, Pausable {\n    // Rollup Config\n    uint256 public confirmPeriodBlocks;\n    uint256 public extraChallengeTimeBlocks;\n    uint256 public arbGasSpeedLimitPerBlock;\n    uint256 public baseStake;\n\n    // Bridge is an IInbox and IOutbox\n    IBridge public delayedBridge;\n    ISequencerInbox public sequencerBridge;\n    IOutbox public outbox;\n    RollupEventBridge public rollupEventBridge;\n    IChallengeFactory public challengeFactory;\n    INodeFactory public nodeFactory;\n    address public owner;\n    address public stakeToken;\n    uint256 public minimumAssertionPeriod;\n\n    uint256 public sequencerInboxMaxDelayBlocks;\n    uint256 public sequencerInboxMaxDelaySeconds;\n    uint256 public challengeExecutionBisectionDegree;\n\n    address[] internal facets;\n\n    mapping(address => bool) isValidator;\n\n    event RollupCreated(bytes32 machineHash);\n\n    event NodeCreated(\n        uint256 indexed nodeNum,\n        bytes32 indexed parentNodeHash,\n        bytes32 nodeHash,\n        bytes32 executionHash,\n        uint256 inboxMaxCount,\n        uint256 afterInboxBatchEndCount,\n        bytes32 afterInboxBatchAcc,\n        bytes32[3][2] assertionBytes32Fields,\n        uint256[4][2] assertionIntFields\n    );\n\n    event NodeConfirmed(\n        uint256 indexed nodeNum,\n        bytes32 afterSendAcc,\n        uint256 afterSendCount,\n        bytes32 afterLogAcc,\n        uint256 afterLogCount\n    );\n\n    event NodeRejected(uint256 indexed nodeNum);\n\n    event RollupChallengeStarted(\n        address indexed challengeContract,\n        address asserter,\n        address challenger,\n        uint256 challengedNode\n    );\n\n    event StakerReassigned(address indexed staker, uint256 newNode);\n    event NodesDestroyed(uint256 indexed startNode, uint256 indexed endNode);\n    event OwnerFunctionCalled(uint256 indexed id);\n}\n\ncontract Rollup is RollupBase {\n    // _rollupParams = [ confirmPeriodBlocks, extraChallengeTimeBlocks, arbGasSpeedLimitPerBlock, baseStake ]\n    // connectedContracts = [delayedBridge, sequencerInbox, outbox, rollupEventBridge, challengeFactory, nodeFactory]\n    function initialize(\n        bytes32 _machineHash,\n        uint256[4] calldata _rollupParams,\n        address _stakeToken,\n        address _owner,\n        bytes calldata _extraConfig,\n        address[6] calldata connectedContracts,\n        address[2] calldata _facets,\n        uint256[2] calldata sequencerInboxParams\n    ) public {\n        require(confirmPeriodBlocks == 0, \"ALREADY_INIT\");\n        require(_rollupParams[0] != 0, \"BAD_CONF_PERIOD\");\n\n        delayedBridge = IBridge(connectedContracts[0]);\n        sequencerBridge = ISequencerInbox(connectedContracts[1]);\n        outbox = IOutbox(connectedContracts[2]);\n        delayedBridge.setOutbox(connectedContracts[2], true);\n        rollupEventBridge = RollupEventBridge(connectedContracts[3]);\n        delayedBridge.setInbox(connectedContracts[3], true);\n\n        rollupEventBridge.rollupInitialized(\n            _rollupParams[0],\n            _rollupParams[2],\n            _rollupParams[3],\n            _stakeToken,\n            _owner,\n            _extraConfig\n        );\n\n        challengeFactory = IChallengeFactory(connectedContracts[4]);\n        nodeFactory = INodeFactory(connectedContracts[5]);\n\n        INode node = createInitialNode(_machineHash);\n        initializeCore(node);\n\n        confirmPeriodBlocks = _rollupParams[0];\n        extraChallengeTimeBlocks = _rollupParams[1];\n        arbGasSpeedLimitPerBlock = _rollupParams[2];\n        baseStake = _rollupParams[3];\n        owner = _owner;\n        // A little over 15 minutes\n        minimumAssertionPeriod = 75;\n        challengeExecutionBisectionDegree = 400;\n\n        sequencerInboxMaxDelayBlocks = sequencerInboxParams[0];\n        sequencerInboxMaxDelaySeconds = sequencerInboxParams[1];\n\n        // facets[0] == admin, facets[1] == user\n        facets = _facets;\n\n        (bool success, ) =\n            _facets[1].delegatecall(\n                abi.encodeWithSelector(IRollupUser.initialize.selector, _stakeToken)\n            );\n        require(success, \"FAIL_INIT_FACET\");\n\n        emit RollupCreated(_machineHash);\n    }\n\n    function createInitialNode(bytes32 _machineHash) private returns (INode) {\n        bytes32 state =\n            RollupLib.stateHash(\n                RollupLib.ExecutionState(\n                    0, // total gas used\n                    _machineHash,\n                    0, // inbox count\n                    0, // send count\n                    0, // log count\n                    0, // send acc\n                    0, // log acc\n                    block.number, // block proposed\n                    1 // Initialization message already in inbox\n                )\n            );\n        return\n            INode(\n                nodeFactory.createNode(\n                    state,\n                    0, // challenge hash (not challengeable)\n                    0, // confirm data\n                    0, // prev node\n                    block.number // deadline block (not challengeable)\n                )\n            );\n    }\n\n    /**\n     * Fallback and delegate functions from OZ\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/TransparentUpgradeableProxy.sol\n     * And dispatch pattern from EIP-2535: Diamonds\n     */\n\n    function getFacets() public view returns (address, address) {\n        return (getAdminFacet(), getUserFacet());\n    }\n\n    function getAdminFacet() public view returns (address) {\n        return facets[0];\n    }\n\n    function getUserFacet() public view returns (address) {\n        return facets[1];\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable {\n        _fallback();\n    }\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        require(msg.data.length >= 4, \"NO_FUNC_SIG\");\n        address rollupOwner = owner;\n        // if there is an owner and it is the sender, delegate to admin facet\n        address target =\n            rollupOwner != address(0) && rollupOwner == msg.sender\n                ? getAdminFacet()\n                : getUserFacet();\n        _delegate(target);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n}\n"
    },
    "contracts/rollup/RollupCore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./INode.sol\";\nimport \"./IRollupCore.sol\";\nimport \"./RollupLib.sol\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract RollupCore is IRollupCore {\n    using SafeMath for uint256;\n\n    struct Zombie {\n        address stakerAddress;\n        uint256 latestStakedNode;\n    }\n\n    struct Staker {\n        uint256 index;\n        uint256 latestStakedNode;\n        uint256 amountStaked;\n        // currentChallenge is 0 if staker is not in a challenge\n        address currentChallenge;\n        bool isStaked;\n    }\n\n    uint256 private _latestConfirmed;\n    uint256 private _firstUnresolvedNode;\n    uint256 private _latestNodeCreated;\n    uint256 private _lastStakeBlock;\n    mapping(uint256 => INode) private _nodes;\n    mapping(uint256 => bytes32) private _nodeHashes;\n\n    address payable[] private _stakerList;\n    mapping(address => Staker) public override _stakerMap;\n\n    Zombie[] private _zombies;\n\n    mapping(address => uint256) private _withdrawableFunds;\n\n    /**\n     * @notice Get the address of the Node contract for the given node\n     * @param nodeNum Index of the node\n     * @return Address of the Node contract\n     */\n    function getNode(uint256 nodeNum) public view override returns (INode) {\n        return _nodes[nodeNum];\n    }\n\n    /**\n     * @notice Get the address of the staker at the given index\n     * @param stakerNum Index of the staker\n     * @return Address of the staker\n     */\n    function getStakerAddress(uint256 stakerNum) public view override returns (address) {\n        return _stakerList[stakerNum];\n    }\n\n    /**\n     * @notice Check whether the given staker is staked\n     * @param staker Staker address to check\n     * @return True or False for whether the staker was staked\n     */\n    function isStaked(address staker) public view override returns (bool) {\n        return _stakerMap[staker].isStaked;\n    }\n\n    /**\n     * @notice Get the latest staked node of the given staker\n     * @param staker Staker address to lookup\n     * @return Latest node staked of the staker\n     */\n    function latestStakedNode(address staker) public view override returns (uint256) {\n        return _stakerMap[staker].latestStakedNode;\n    }\n\n    /**\n     * @notice Get the current challenge of the given staker\n     * @param staker Staker address to lookup\n     * @return Current challenge of the staker\n     */\n    function currentChallenge(address staker) public view override returns (address) {\n        return _stakerMap[staker].currentChallenge;\n    }\n\n    /**\n     * @notice Get the amount staked of the given staker\n     * @param staker Staker address to lookup\n     * @return Amount staked of the staker\n     */\n    function amountStaked(address staker) public view override returns (uint256) {\n        return _stakerMap[staker].amountStaked;\n    }\n\n    /**\n     * @notice Get the original staker address of the zombie at the given index\n     * @param zombieNum Index of the zombie to lookup\n     * @return Original staker address of the zombie\n     */\n    function zombieAddress(uint256 zombieNum) public view override returns (address) {\n        return _zombies[zombieNum].stakerAddress;\n    }\n\n    /**\n     * @notice Get Latest node that the given zombie at the given index is staked on\n     * @param zombieNum Index of the zombie to lookup\n     * @return Latest node that the given zombie is staked on\n     */\n    function zombieLatestStakedNode(uint256 zombieNum) public view override returns (uint256) {\n        return _zombies[zombieNum].latestStakedNode;\n    }\n\n    /// @return Current number of un-removed zombies\n    function zombieCount() public view override returns (uint256) {\n        return _zombies.length;\n    }\n\n    function isZombie(address staker) public view override returns (bool) {\n        for (uint256 i = 0; i < _zombies.length; i++) {\n            if (staker == _zombies[i].stakerAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Get the amount of funds withdrawable by the given address\n     * @param owner Address to check the funds of\n     * @return Amount of funds withdrawable by owner\n     */\n    function withdrawableFunds(address owner) public view override returns (uint256) {\n        return _withdrawableFunds[owner];\n    }\n\n    /**\n     * @return Index of the first unresolved node\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\n     */\n    function firstUnresolvedNode() public view override returns (uint256) {\n        return _firstUnresolvedNode;\n    }\n\n    /// @return Index of the latest confirmed node\n    function latestConfirmed() public view override returns (uint256) {\n        return _latestConfirmed;\n    }\n\n    /// @return Index of the latest rollup node created\n    function latestNodeCreated() public view override returns (uint256) {\n        return _latestNodeCreated;\n    }\n\n    /// @return Ethereum block that the most recent stake was created\n    function lastStakeBlock() public view override returns (uint256) {\n        return _lastStakeBlock;\n    }\n\n    /// @return Number of active stakers currently staked\n    function stakerCount() public view override returns (uint256) {\n        return _stakerList.length;\n    }\n\n    /**\n     * @notice Initialize the core with an initial node\n     * @param initialNode Initial node to start the chain with\n     */\n    function initializeCore(INode initialNode) internal {\n        _nodes[0] = initialNode;\n        _firstUnresolvedNode = 1;\n    }\n\n    /**\n     * @notice React to a new node being created by storing it an incrementing the latest node counter\n     * @param node Node that was newly created\n     * @param nodeHash The hash of said node\n     */\n    function nodeCreated(INode node, bytes32 nodeHash) internal {\n        _latestNodeCreated++;\n        _nodes[_latestNodeCreated] = node;\n        _nodeHashes[_latestNodeCreated] = nodeHash;\n    }\n\n    /// @return Node hash as of this node number\n    function getNodeHash(uint256 index) public view override returns (bytes32) {\n        return _nodeHashes[index];\n    }\n\n    function resetNodeHash(uint256 index) internal {\n        _nodeHashes[index] = 0;\n    }\n\n    /**\n     * @notice Update the latest node created\n     * @param newLatestNodeCreated New value for the latest node created\n     */\n    function updateLatestNodeCreated(uint256 newLatestNodeCreated) internal {\n        _latestNodeCreated = newLatestNodeCreated;\n    }\n\n    /// @notice Reject the next unresolved node\n    function rejectNextNode() internal {\n        destroyNode(_firstUnresolvedNode);\n        _firstUnresolvedNode++;\n    }\n\n    /// @notice Confirm the next unresolved node\n    function confirmNextNode() internal {\n        destroyNode(_latestConfirmed);\n        _latestConfirmed = _firstUnresolvedNode;\n        _firstUnresolvedNode++;\n    }\n\n    /// @notice Confirm the next unresolved node\n    function confirmLatestNode() internal {\n        destroyNode(_latestConfirmed);\n        uint256 latestNode = _latestNodeCreated;\n        _latestConfirmed = latestNode;\n        _firstUnresolvedNode = latestNode + 1;\n    }\n\n    /**\n     * @notice Create a new stake\n     * @param stakerAddress Address of the new staker\n     * @param depositAmount Stake amount of the new staker\n     */\n    function createNewStake(address payable stakerAddress, uint256 depositAmount) internal {\n        uint256 stakerIndex = _stakerList.length;\n        _stakerList.push(stakerAddress);\n        _stakerMap[stakerAddress] = Staker(\n            stakerIndex,\n            _latestConfirmed,\n            depositAmount,\n            address(0),\n            true\n        );\n        _lastStakeBlock = block.number;\n    }\n\n    /**\n     * @notice Check to see whether the two stakers are in the same challenge\n     * @param stakerAddress1 Address of the first staker\n     * @param stakerAddress2 Address of the second staker\n     * @return Address of the challenge that the two stakers are in\n     */\n    function inChallenge(address stakerAddress1, address stakerAddress2)\n        internal\n        view\n        returns (address)\n    {\n        Staker storage staker1 = _stakerMap[stakerAddress1];\n        Staker storage staker2 = _stakerMap[stakerAddress2];\n        address challenge = staker1.currentChallenge;\n        require(challenge == staker2.currentChallenge, \"IN_CHAL\");\n        require(challenge != address(0), \"NO_CHAL\");\n        return challenge;\n    }\n\n    /**\n     * @notice Make the given staker as not being in a challenge\n     * @param stakerAddress Address of the staker to remove from a challenge\n     */\n    function clearChallenge(address stakerAddress) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        staker.currentChallenge = address(0);\n    }\n\n    /**\n     * @notice Mark both the given stakers as engaged in the challenge\n     * @param staker1 Address of the first staker\n     * @param staker2 Address of the second staker\n     * @param challenge Address of the challenge both stakers are now in\n     */\n    function challengeStarted(\n        address staker1,\n        address staker2,\n        address challenge\n    ) internal {\n        _stakerMap[staker1].currentChallenge = challenge;\n        _stakerMap[staker2].currentChallenge = challenge;\n    }\n\n    /**\n     * @notice Add to the stake of the given staker by the given amount\n     * @param stakerAddress Address of the staker to increase the stake of\n     * @param amountAdded Amount of stake to add to the staker\n     */\n    function increaseStakeBy(address stakerAddress, uint256 amountAdded) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        staker.amountStaked = staker.amountStaked.add(amountAdded);\n    }\n\n    /**\n     * @notice Reduce the stake of the given staker to the given target\n     * @param stakerAddress Address of the staker to reduce the stake of\n     * @param target Amount of stake to leave with the staker\n     * @return Amount of value released from the stake\n     */\n    function reduceStakeTo(address stakerAddress, uint256 target) internal returns (uint256) {\n        Staker storage staker = _stakerMap[stakerAddress];\n        uint256 current = staker.amountStaked;\n        require(target <= current, \"TOO_LITTLE_STAKE\");\n        uint256 amountWithdrawn = current.sub(target);\n        staker.amountStaked = target;\n        _withdrawableFunds[stakerAddress] = _withdrawableFunds[stakerAddress].add(amountWithdrawn);\n        return amountWithdrawn;\n    }\n\n    /**\n     * @notice Remove the given staker and turn them into a zombie\n     * @param stakerAddress Address of the staker to remove\n     */\n    function turnIntoZombie(address stakerAddress) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        _zombies.push(Zombie(stakerAddress, staker.latestStakedNode));\n        deleteStaker(stakerAddress);\n    }\n\n    /**\n     * @notice Update the latest staked node of the zombie at the given index\n     * @param zombieNum Index of the zombie to move\n     * @param latest New latest node the zombie is staked on\n     */\n    function zombieUpdateLatestStakedNode(uint256 zombieNum, uint256 latest) internal {\n        _zombies[zombieNum].latestStakedNode = latest;\n    }\n\n    /**\n     * @notice Remove the zombie at the given index\n     * @param zombieNum Index of the zombie to remove\n     */\n    function removeZombie(uint256 zombieNum) internal {\n        _zombies[zombieNum] = _zombies[_zombies.length - 1];\n        _zombies.pop();\n    }\n\n    /**\n     * @notice Remove the given staker and return their stake\n     * @param stakerAddress Address of the staker withdrawing their stake\n     */\n    function withdrawStaker(address stakerAddress) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        _withdrawableFunds[stakerAddress] = _withdrawableFunds[stakerAddress].add(\n            staker.amountStaked\n        );\n        deleteStaker(stakerAddress);\n    }\n\n    /**\n     * @notice Advance the given staker to the given node\n     * @param stakerAddress Address of the staker adding their stake\n     * @param nodeNum Index of the node to stake on\n     */\n    function stakeOnNode(\n        address stakerAddress,\n        uint256 nodeNum,\n        uint256 confirmPeriodBlocks\n    ) internal {\n        Staker storage staker = _stakerMap[stakerAddress];\n        INode node = _nodes[nodeNum];\n        uint256 newStakerCount = node.addStaker(stakerAddress);\n        staker.latestStakedNode = nodeNum;\n        if (newStakerCount == 1) {\n            INode parent = _nodes[node.prev()];\n            parent.newChildConfirmDeadline(block.number.add(confirmPeriodBlocks));\n        }\n    }\n\n    /**\n     * @notice Clear the withdrawable funds for the given address\n     * @param owner Address of the account to remove funds from\n     * @return Amount of funds removed from account\n     */\n    function withdrawFunds(address owner) internal returns (uint256) {\n        uint256 amount = _withdrawableFunds[owner];\n        _withdrawableFunds[owner] = 0;\n        return amount;\n    }\n\n    /**\n     * @notice Increase the withdrawable funds for the given address\n     * @param owner Address of the account to add withdrawable funds to\n     */\n    function increaseWithdrawableFunds(address owner, uint256 amount) internal {\n        _withdrawableFunds[owner] = _withdrawableFunds[owner].add(amount);\n    }\n\n    /**\n     * @notice Remove the given staker\n     * @param stakerAddress Address of the staker to remove\n     */\n    function deleteStaker(address stakerAddress) private {\n        Staker storage staker = _stakerMap[stakerAddress];\n        uint256 stakerIndex = staker.index;\n        _stakerList[stakerIndex] = _stakerList[_stakerList.length - 1];\n        _stakerMap[_stakerList[stakerIndex]].index = stakerIndex;\n        _stakerList.pop();\n        delete _stakerMap[stakerAddress];\n    }\n\n    /**\n     * @notice Destroy the given node and clear out its address\n     * @param nodeNum Index of the node to remove\n     */\n    function destroyNode(uint256 nodeNum) internal {\n        _nodes[nodeNum].destroy();\n        _nodes[nodeNum] = INode(0);\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/rollup/RollupCreator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../bridge/Bridge.sol\";\nimport \"../bridge/SequencerInbox.sol\";\nimport \"../bridge/Inbox.sol\";\nimport \"../bridge/Outbox.sol\";\nimport \"./RollupEventBridge.sol\";\nimport \"./BridgeCreator.sol\";\n\nimport \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Rollup.sol\";\nimport \"./facets/RollupUser.sol\";\nimport \"./facets/RollupAdmin.sol\";\nimport \"../bridge/interfaces/IBridge.sol\";\n\nimport \"./RollupLib.sol\";\nimport \"../libraries/ICloneable.sol\";\n\ncontract RollupCreator is Ownable {\n    event RollupCreated(address indexed rollupAddress, address inboxAddress, address adminProxy);\n    event TemplatesUpdated();\n\n    BridgeCreator public bridgeCreator;\n    ICloneable public rollupTemplate;\n    address public challengeFactory;\n    address public nodeFactory;\n    address public rollupAdminFacet;\n    address public rollupUserFacet;\n\n    constructor() public Ownable() {}\n\n    function setTemplates(\n        BridgeCreator _bridgeCreator,\n        ICloneable _rollupTemplate,\n        address _challengeFactory,\n        address _nodeFactory,\n        address _rollupAdminFacet,\n        address _rollupUserFacet\n    ) external onlyOwner {\n        bridgeCreator = _bridgeCreator;\n        rollupTemplate = _rollupTemplate;\n        challengeFactory = _challengeFactory;\n        nodeFactory = _nodeFactory;\n        rollupAdminFacet = _rollupAdminFacet;\n        rollupUserFacet = _rollupUserFacet;\n        emit TemplatesUpdated();\n    }\n\n    function createRollup(\n        bytes32 _machineHash,\n        uint256 _confirmPeriodBlocks,\n        uint256 _extraChallengeTimeBlocks,\n        uint256 _arbGasSpeedLimitPerBlock,\n        uint256 _baseStake,\n        address _stakeToken,\n        address _owner,\n        address _sequencer,\n        uint256 _sequencerDelayBlocks,\n        uint256 _sequencerDelaySeconds,\n        bytes calldata _extraConfig\n    ) external returns (address) {\n        return\n            createRollup(\n                RollupLib.Config(\n                    _machineHash,\n                    _confirmPeriodBlocks,\n                    _extraChallengeTimeBlocks,\n                    _arbGasSpeedLimitPerBlock,\n                    _baseStake,\n                    _stakeToken,\n                    _owner,\n                    _sequencer,\n                    _sequencerDelayBlocks,\n                    _sequencerDelaySeconds,\n                    _extraConfig\n                )\n            );\n    }\n\n    struct CreateRollupFrame {\n        ProxyAdmin admin;\n        Bridge delayedBridge;\n        SequencerInbox sequencerInbox;\n        Inbox inbox;\n        RollupEventBridge rollupEventBridge;\n        Outbox outbox;\n        address rollup;\n    }\n\n    // After this setup:\n    // Rollup should be the owner of bridge\n    // RollupOwner should be the owner of Rollup's ProxyAdmin\n    // RollupOwner should be the owner of Rollup\n    // Bridge should have a single inbox and outbox\n    function createRollup(RollupLib.Config memory config) private returns (address) {\n        CreateRollupFrame memory frame;\n        frame.admin = new ProxyAdmin();\n        frame.rollup = address(\n            new TransparentUpgradeableProxy(address(rollupTemplate), address(frame.admin), \"\")\n        );\n\n        (\n            frame.delayedBridge,\n            frame.sequencerInbox,\n            frame.inbox,\n            frame.rollupEventBridge,\n            frame.outbox\n        ) = bridgeCreator.createBridge(address(frame.admin), frame.rollup, config.sequencer);\n\n        frame.admin.transferOwnership(config.owner);\n        Rollup(payable(frame.rollup)).initialize(\n            config.machineHash,\n            [\n                config.confirmPeriodBlocks,\n                config.extraChallengeTimeBlocks,\n                config.arbGasSpeedLimitPerBlock,\n                config.baseStake\n            ],\n            config.stakeToken,\n            config.owner,\n            config.extraConfig,\n            [\n                address(frame.delayedBridge),\n                address(frame.sequencerInbox),\n                address(frame.outbox),\n                address(frame.rollupEventBridge),\n                challengeFactory,\n                nodeFactory\n            ],\n            [rollupAdminFacet, rollupUserFacet],\n            [config.sequencerDelayBlocks, config.sequencerDelaySeconds]\n        );\n\n        emit RollupCreated(frame.rollup, address(frame.inbox), address(frame.admin));\n        return frame.rollup;\n    }\n}\n"
    },
    "contracts/rollup/RollupEventBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./Rollup.sol\";\nimport \"./facets/IRollupFacets.sol\";\n\nimport \"../bridge/interfaces/IBridge.sol\";\nimport \"../bridge/interfaces/IMessageProvider.sol\";\nimport \"./INode.sol\";\nimport \"../libraries/Cloneable.sol\";\n\ncontract RollupEventBridge is IMessageProvider, Cloneable {\n    uint8 internal constant INITIALIZATION_MSG_TYPE = 4;\n    uint8 internal constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\n\n    uint8 internal constant CREATE_NODE_EVENT = 0;\n    uint8 internal constant CONFIRM_NODE_EVENT = 1;\n    uint8 internal constant REJECT_NODE_EVENT = 2;\n    uint8 internal constant STAKE_CREATED_EVENT = 3;\n    uint8 internal constant CLAIM_NODE_EVENT = 4;\n\n    IBridge bridge;\n    address rollup;\n\n    modifier onlyRollup {\n        require(msg.sender == rollup, \"ONLY_ROLLUP\");\n        _;\n    }\n\n    function initialize(address _bridge, address _rollup) external {\n        require(rollup == address(0), \"ALREADY_INIT\");\n        bridge = IBridge(_bridge);\n        rollup = _rollup;\n    }\n\n    function rollupInitialized(\n        uint256 confirmPeriodBlocks,\n        uint256 arbGasSpeedLimitPerBlock,\n        uint256 baseStake,\n        address stakeToken,\n        address owner,\n        bytes calldata extraConfig\n    ) external onlyRollup {\n        bytes memory initMsg =\n            abi.encodePacked(\n                confirmPeriodBlocks,\n                arbGasSpeedLimitPerBlock / 100, // convert avm gas to arbgas\n                uint256(0),\n                baseStake,\n                uint256(uint160(bytes20(stakeToken))),\n                uint256(uint160(bytes20(owner))),\n                extraConfig\n            );\n        uint256 num =\n            bridge.deliverMessageToInbox(INITIALIZATION_MSG_TYPE, msg.sender, keccak256(initMsg));\n        emit InboxMessageDelivered(num, initMsg);\n    }\n\n    function nodeCreated(\n        uint256 nodeNum,\n        uint256 prev,\n        uint256 deadline,\n        address asserter\n    ) external onlyRollup {\n        deliverToBridge(\n            abi.encodePacked(\n                CREATE_NODE_EVENT,\n                nodeNum,\n                prev,\n                block.number,\n                deadline,\n                uint256(uint160(bytes20(asserter)))\n            )\n        );\n    }\n\n    function nodeConfirmed(uint256 nodeNum) external onlyRollup {\n        deliverToBridge(abi.encodePacked(CONFIRM_NODE_EVENT, nodeNum));\n    }\n\n    function nodeRejected(uint256 nodeNum) external onlyRollup {\n        deliverToBridge(abi.encodePacked(REJECT_NODE_EVENT, nodeNum));\n    }\n\n    function stakeCreated(address staker, uint256 nodeNum) external onlyRollup {\n        deliverToBridge(\n            abi.encodePacked(\n                STAKE_CREATED_EVENT,\n                uint256(uint160(bytes20(staker))),\n                nodeNum,\n                block.number\n            )\n        );\n    }\n\n    function claimNode(uint256 nodeNum, address staker) external onlyRollup {\n        Rollup r = Rollup(payable(rollup));\n        INode node = r.getNode(nodeNum);\n        require(node.stakers(staker), \"NOT_STAKED\");\n        IRollupUser(address(r)).requireUnresolved(nodeNum);\n\n        deliverToBridge(\n            abi.encodePacked(CLAIM_NODE_EVENT, nodeNum, uint256(uint160(bytes20(staker))))\n        );\n    }\n\n    function deliverToBridge(bytes memory message) private {\n        emit InboxMessageDelivered(\n            bridge.deliverMessageToInbox(\n                ROLLUP_PROTOCOL_EVENT_TYPE,\n                msg.sender,\n                keccak256(message)\n            ),\n            message\n        );\n    }\n}\n"
    },
    "contracts/rollup/RollupLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../challenge/ChallengeLib.sol\";\nimport \"./INode.sol\";\n\nlibrary RollupLib {\n    struct Config {\n        bytes32 machineHash;\n        uint256 confirmPeriodBlocks;\n        uint256 extraChallengeTimeBlocks;\n        uint256 arbGasSpeedLimitPerBlock;\n        uint256 baseStake;\n        address stakeToken;\n        address owner;\n        address sequencer;\n        uint256 sequencerDelayBlocks;\n        uint256 sequencerDelaySeconds;\n        bytes extraConfig;\n    }\n\n    struct ExecutionState {\n        uint256 gasUsed;\n        bytes32 machineHash;\n        uint256 inboxCount;\n        uint256 sendCount;\n        uint256 logCount;\n        bytes32 sendAcc;\n        bytes32 logAcc;\n        uint256 proposedBlock;\n        uint256 inboxMaxCount;\n    }\n\n    function stateHash(ExecutionState memory execState) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    execState.gasUsed,\n                    execState.machineHash,\n                    execState.inboxCount,\n                    execState.sendCount,\n                    execState.logCount,\n                    execState.sendAcc,\n                    execState.logAcc,\n                    execState.proposedBlock,\n                    execState.inboxMaxCount\n                )\n            );\n    }\n\n    struct Assertion {\n        ExecutionState beforeState;\n        ExecutionState afterState;\n    }\n\n    function decodeExecutionState(\n        bytes32[3] memory bytes32Fields,\n        uint256[4] memory intFields,\n        uint256 proposedBlock,\n        uint256 inboxMaxCount\n    ) internal pure returns (ExecutionState memory) {\n        return\n            ExecutionState(\n                intFields[0],\n                bytes32Fields[0],\n                intFields[1],\n                intFields[2],\n                intFields[3],\n                bytes32Fields[1],\n                bytes32Fields[2],\n                proposedBlock,\n                inboxMaxCount\n            );\n    }\n\n    function decodeAssertion(\n        bytes32[3][2] memory bytes32Fields,\n        uint256[4][2] memory intFields,\n        uint256 beforeProposedBlock,\n        uint256 beforeInboxMaxCount,\n        uint256 inboxMaxCount\n    ) internal view returns (Assertion memory) {\n        return\n            Assertion(\n                decodeExecutionState(\n                    bytes32Fields[0],\n                    intFields[0],\n                    beforeProposedBlock,\n                    beforeInboxMaxCount\n                ),\n                decodeExecutionState(bytes32Fields[1], intFields[1], block.number, inboxMaxCount)\n            );\n    }\n\n    function executionStateChallengeHash(ExecutionState memory state)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            ChallengeLib.assertionHash(\n                state.gasUsed,\n                ChallengeLib.assertionRestHash(\n                    state.inboxCount,\n                    state.machineHash,\n                    state.sendAcc,\n                    state.sendCount,\n                    state.logAcc,\n                    state.logCount\n                )\n            );\n    }\n\n    function executionHash(Assertion memory assertion) internal pure returns (bytes32) {\n        return\n            ChallengeLib.bisectionChunkHash(\n                assertion.beforeState.gasUsed,\n                assertion.afterState.gasUsed - assertion.beforeState.gasUsed,\n                RollupLib.executionStateChallengeHash(assertion.beforeState),\n                RollupLib.executionStateChallengeHash(assertion.afterState)\n            );\n    }\n\n    function challengeRoot(\n        Assertion memory assertion,\n        bytes32 assertionExecHash,\n        uint256 blockProposed\n    ) internal pure returns (bytes32) {\n        return challengeRootHash(assertionExecHash, blockProposed, assertion.afterState.inboxCount);\n    }\n\n    function challengeRootHash(\n        bytes32 execution,\n        uint256 proposedTime,\n        uint256 maxMessageCount\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(execution, proposedTime, maxMessageCount));\n    }\n\n    function confirmHash(Assertion memory assertion) internal pure returns (bytes32) {\n        return\n            confirmHash(\n                assertion.beforeState.sendAcc,\n                assertion.afterState.sendAcc,\n                assertion.afterState.logAcc,\n                assertion.afterState.sendCount,\n                assertion.afterState.logCount\n            );\n    }\n\n    function confirmHash(\n        bytes32 beforeSendAcc,\n        bytes32 afterSendAcc,\n        bytes32 afterLogAcc,\n        uint256 afterSendCount,\n        uint256 afterLogCount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    beforeSendAcc,\n                    afterSendAcc,\n                    afterSendCount,\n                    afterLogAcc,\n                    afterLogCount\n                )\n            );\n    }\n\n    function feedAccumulator(\n        bytes memory messageData,\n        uint256[] memory messageLengths,\n        bytes32 beforeAcc\n    ) internal pure returns (bytes32) {\n        uint256 offset = 0;\n        uint256 messageCount = messageLengths.length;\n        uint256 dataLength = messageData.length;\n        bytes32 messageAcc = beforeAcc;\n        for (uint256 i = 0; i < messageCount; i++) {\n            uint256 messageLength = messageLengths[i];\n            require(offset + messageLength <= dataLength, \"DATA_OVERRUN\");\n            bytes32 messageHash;\n            assembly {\n                messageHash := keccak256(add(messageData, add(offset, 32)), messageLength)\n            }\n            messageAcc = keccak256(abi.encodePacked(messageAcc, messageHash));\n            offset += messageLength;\n        }\n        require(offset == dataLength, \"DATA_LENGTH\");\n        return messageAcc;\n    }\n\n    function nodeHash(\n        bool hasSibling,\n        bytes32 lastHash,\n        bytes32 assertionExecHash,\n        bytes32 inboxAcc\n    ) internal pure returns (bytes32) {\n        uint8 hasSiblingInt = hasSibling ? 1 : 0;\n        return keccak256(abi.encodePacked(hasSiblingInt, lastHash, assertionExecHash, inboxAcc));\n    }\n\n    function nodeAccumulator(bytes32 prevAcc, bytes32 newNodeHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(prevAcc, newNodeHash));\n    }\n}\n"
    },
    "contracts/rollup/facets/IRollupFacets.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"../INode.sol\";\nimport \"../../bridge/interfaces/IOutbox.sol\";\n\ninterface IRollupUser {\n    function initialize(address _stakeToken) external;\n\n    function completeChallenge(address winningStaker, address losingStaker) external;\n\n    function returnOldDeposit(address stakerAddress) external;\n\n    function requireUnresolved(uint256 nodeNum) external view;\n\n    function requireUnresolvedExists() external view;\n\n    function countStakedZombies(INode node) external view returns (uint256);\n}\n\ninterface IRollupAdmin {\n    /**\n     * @notice Add a contract authorized to put messages into this rollup's inbox\n     * @param _outbox Outbox contract to add\n     */\n    function setOutbox(IOutbox _outbox) external;\n\n    /**\n     * @notice Disable an old outbox from interacting with the bridge\n     * @param _outbox Outbox contract to remove\n     */\n    function removeOldOutbox(address _outbox) external;\n\n    /**\n     * @notice Enable or disable an inbox contract\n     * @param _inbox Inbox contract to add or remove\n     * @param _enabled New status of inbox\n     */\n    function setInbox(address _inbox, bool _enabled) external;\n\n    /**\n     * @notice Pause interaction with the rollup contract\n     */\n    function pause() external;\n\n    /**\n     * @notice Resume interaction with the rollup contract\n     */\n    function resume() external;\n\n    /**\n     * @notice Set the addresses of rollup logic facets called\n     * @param newAdminFacet address of logic that owner of rollup calls\n     * @param newUserFacet ddress of logic that user of rollup calls\n     */\n    function setFacets(address newAdminFacet, address newUserFacet) external;\n\n    /**\n     * @notice Set the addresses of the validator whitelist\n     * @dev It is expected that both arrays are same length, and validator at\n     * position i corresponds to the value at position i\n     * @param _validator addresses to set in the whitelist\n     * @param _val value to set in the whitelist for corresponding address\n     */\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\n\n    /**\n     * @notice Set a new owner address for the rollup\n     * @param newOwner address of new rollup owner\n     */\n    function setOwner(address newOwner) external;\n\n    /**\n     * @notice Set minimum assertion period for the rollup\n     * @param newPeriod new minimum period for assertions\n     */\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\n\n    /**\n     * @notice Set number of blocks until a node is considered confirmed\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\n     */\n    function setConfirmPeriodBlocks(uint256 newConfirmPeriod) external;\n\n    /**\n     * @notice Set number of extra blocks after a challenge\n     * @param newExtraTimeBlocks new number of blocks\n     */\n    function setExtraChallengeTimeBlocks(uint256 newExtraTimeBlocks) external;\n\n    /**\n     * @notice Set speed limit per block\n     * @param newArbGasSpeedLimitPerBlock maximum arbgas to be used per block\n     */\n    function setArbGasSpeedLimitPerBlock(uint256 newArbGasSpeedLimitPerBlock) external;\n\n    /**\n     * @notice Set base stake required for an assertion\n     * @param newBaseStake maximum arbgas to be used per block\n     */\n    function setBaseStake(uint256 newBaseStake) external;\n\n    /**\n     * @notice Set the token used for stake, where address(0) == eth\n     * @dev Before changing the base stake token, you might need to change the\n     * implementation of the Rollup User facet!\n     * @param newStakeToken address of token used for staking\n     */\n    function setStakeToken(address newStakeToken) external;\n\n    /**\n     * @notice Set max delay in blocks for sequencer inbox\n     * @param newSequencerInboxMaxDelayBlocks max number of blocks\n     */\n    function setSequencerInboxMaxDelayBlocks(uint256 newSequencerInboxMaxDelayBlocks) external;\n\n    /**\n     * @notice Set max delay in seconds for sequencer inbox\n     * @param newSequencerInboxMaxDelaySeconds max number of seconds\n     */\n    function setSequencerInboxMaxDelaySeconds(uint256 newSequencerInboxMaxDelaySeconds) external;\n\n    /**\n     * @notice Set execution bisection degree\n     * @param newChallengeExecutionBisectionDegree execution bisection degree\n     */\n    function setChallengeExecutionBisectionDegree(uint256 newChallengeExecutionBisectionDegree)\n        external;\n\n    /**\n     * @notice Updates a whitelist address for its consumers\n     * @dev setting the newWhitelist to address(0) disables it for consumers\n     * @param whitelist old whitelist to be deprecated\n     * @param newWhitelist new whitelist to be used\n     * @param targets whitelist consumers to be triggered\n     */\n    function updateWhitelistConsumers(\n        address whitelist,\n        address newWhitelist,\n        address[] memory targets\n    ) external;\n\n    /**\n     * @notice Updates a whitelist's entries\n     * @dev user at position i will be assigned value i\n     * @param whitelist whitelist to be updated\n     * @param user users to be updated in the whitelist\n     * @param val if user is or not allowed in the whitelist\n     */\n    function setWhitelistEntries(\n        address whitelist,\n        address[] memory user,\n        bool[] memory val\n    ) external;\n\n    /**\n     * @notice Updates a sequencer address at the sequencer inbox\n     * @param newSequencer new sequencer address to be used\n     */\n    function setSequencer(address newSequencer) external;\n\n    /**\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\n     * @param beacon address of beacon to be upgraded\n     * @param newImplementation new address of implementation\n     */\n    function upgradeBeacon(address beacon, address newImplementation) external;\n}\n"
    },
    "contracts/rollup/facets/RollupAdmin.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.11;\n\nimport \"../Rollup.sol\";\nimport \"./IRollupFacets.sol\";\nimport \"../../bridge/interfaces/IOutbox.sol\";\nimport \"../../bridge/interfaces/ISequencerInbox.sol\";\nimport \"../../libraries/Whitelist.sol\";\n\nimport \"@openzeppelin/contracts/proxy/UpgradeableBeacon.sol\";\n\ncontract RollupAdminFacet is RollupBase, IRollupAdmin {\n    /**\n     * Functions are only to reach this facet if the caller is the owner\n     * so there is no need for a redundant onlyOwner check\n     */\n\n    /**\n     * @notice Add a contract authorized to put messages into this rollup's inbox\n     * @param _outbox Outbox contract to add\n     */\n    function setOutbox(IOutbox _outbox) external override {\n        outbox = _outbox;\n        delayedBridge.setOutbox(address(_outbox), true);\n        emit OwnerFunctionCalled(0);\n    }\n\n    /**\n     * @notice Disable an old outbox from interacting with the bridge\n     * @param _outbox Outbox contract to remove\n     */\n    function removeOldOutbox(address _outbox) external override {\n        require(_outbox != address(outbox), \"CUR_OUTBOX\");\n        delayedBridge.setOutbox(_outbox, false);\n        emit OwnerFunctionCalled(1);\n    }\n\n    /**\n     * @notice Enable or disable an inbox contract\n     * @param _inbox Inbox contract to add or remove\n     * @param _enabled New status of inbox\n     */\n    function setInbox(address _inbox, bool _enabled) external override {\n        delayedBridge.setInbox(address(_inbox), _enabled);\n        emit OwnerFunctionCalled(2);\n    }\n\n    /**\n     * @notice Pause interaction with the rollup contract\n     */\n    function pause() external override {\n        _pause();\n        emit OwnerFunctionCalled(3);\n    }\n\n    /**\n     * @notice Resume interaction with the rollup contract\n     */\n    function resume() external override {\n        _unpause();\n        emit OwnerFunctionCalled(4);\n    }\n\n    /**\n     * @notice Set the addresses of rollup logic facets called\n     * @param newAdminFacet address of logic that owner of rollup calls\n     * @param newUserFacet ddress of logic that user of rollup calls\n     */\n    function setFacets(address newAdminFacet, address newUserFacet) external override {\n        facets[0] = newAdminFacet;\n        facets[1] = newUserFacet;\n        emit OwnerFunctionCalled(5);\n    }\n\n    /**\n     * @notice Set the addresses of the validator whitelist\n     * @dev It is expected that both arrays are same length, and validator at\n     * position i corresponds to the value at position i\n     * @param _validator addresses to set in the whitelist\n     * @param _val value to set in the whitelist for corresponding address\n     */\n    function setValidator(address[] memory _validator, bool[] memory _val) external override {\n        require(_validator.length == _val.length, \"WRONG_LENGTH\");\n\n        for (uint256 i = 0; i < _validator.length; i++) {\n            isValidator[_validator[i]] = _val[i];\n        }\n        emit OwnerFunctionCalled(6);\n    }\n\n    /**\n     * @notice Set a new owner address for the rollup\n     * @param newOwner address of new rollup owner\n     */\n    function setOwner(address newOwner) external override {\n        owner = newOwner;\n        emit OwnerFunctionCalled(7);\n    }\n\n    /**\n     * @notice Set minimum assertion period for the rollup\n     * @param newPeriod new minimum period for assertions\n     */\n    function setMinimumAssertionPeriod(uint256 newPeriod) external override {\n        minimumAssertionPeriod = newPeriod;\n        emit OwnerFunctionCalled(8);\n    }\n\n    /**\n     * @notice Set number of blocks until a node is considered confirmed\n     * @param newConfirmPeriod new number of blocks\n     */\n    function setConfirmPeriodBlocks(uint256 newConfirmPeriod) external override {\n        confirmPeriodBlocks = newConfirmPeriod;\n        emit OwnerFunctionCalled(9);\n    }\n\n    /**\n     * @notice Set number of extra blocks after a challenge\n     * @param newExtraTimeBlocks new number of blocks\n     */\n    function setExtraChallengeTimeBlocks(uint256 newExtraTimeBlocks) external override {\n        extraChallengeTimeBlocks = newExtraTimeBlocks;\n        emit OwnerFunctionCalled(10);\n    }\n\n    /**\n     * @notice Set speed limit per block\n     * @param newArbGasSpeedLimitPerBlock maximum arbgas to be used per block\n     */\n    function setArbGasSpeedLimitPerBlock(uint256 newArbGasSpeedLimitPerBlock) external override {\n        arbGasSpeedLimitPerBlock = newArbGasSpeedLimitPerBlock;\n        emit OwnerFunctionCalled(11);\n    }\n\n    /**\n     * @notice Set base stake required for an assertion\n     * @param newBaseStake maximum arbgas to be used per block\n     */\n    function setBaseStake(uint256 newBaseStake) external override {\n        baseStake = newBaseStake;\n        emit OwnerFunctionCalled(12);\n    }\n\n    /**\n     * @notice Set the token used for stake, where address(0) == eth\n     * @dev Before changing the base stake token, you might need to change the\n     * implementation of the Rollup User facet!\n     * @param newStakeToken address of token used for staking\n     */\n    function setStakeToken(address newStakeToken) external override {\n        stakeToken = newStakeToken;\n        emit OwnerFunctionCalled(13);\n    }\n\n    /**\n     * @notice Set max delay in blocks for sequencer inbox\n     * @param newSequencerInboxMaxDelayBlocks max number of blocks\n     */\n    function setSequencerInboxMaxDelayBlocks(uint256 newSequencerInboxMaxDelayBlocks)\n        external\n        override\n    {\n        sequencerInboxMaxDelayBlocks = newSequencerInboxMaxDelayBlocks;\n        emit OwnerFunctionCalled(14);\n    }\n\n    /**\n     * @notice Set max delay in seconds for sequencer inbox\n     * @param newSequencerInboxMaxDelaySeconds max number of seconds\n     */\n    function setSequencerInboxMaxDelaySeconds(uint256 newSequencerInboxMaxDelaySeconds)\n        external\n        override\n    {\n        sequencerInboxMaxDelaySeconds = newSequencerInboxMaxDelaySeconds;\n        emit OwnerFunctionCalled(15);\n    }\n\n    /**\n     * @notice Set execution bisection degree\n     * @param newChallengeExecutionBisectionDegree execution bisection degree\n     */\n    function setChallengeExecutionBisectionDegree(uint256 newChallengeExecutionBisectionDegree)\n        external\n        override\n    {\n        challengeExecutionBisectionDegree = newChallengeExecutionBisectionDegree;\n        emit OwnerFunctionCalled(16);\n    }\n\n    /**\n     * @notice Updates a whitelist address for its consumers\n     * @dev setting the newWhitelist to address(0) disables it for consumers\n     * @param whitelist old whitelist to be deprecated\n     * @param newWhitelist new whitelist to be used\n     * @param targets whitelist consumers to be triggered\n     */\n    function updateWhitelistConsumers(\n        address whitelist,\n        address newWhitelist,\n        address[] memory targets\n    ) external override {\n        Whitelist(whitelist).triggerConsumers(newWhitelist, targets);\n        emit OwnerFunctionCalled(17);\n    }\n\n    /**\n     * @notice Updates a whitelist's entries\n     * @dev user at position i will be assigned value i\n     * @param whitelist whitelist to be updated\n     * @param user users to be updated in the whitelist\n     * @param val if user is or not allowed in the whitelist\n     */\n    function setWhitelistEntries(\n        address whitelist,\n        address[] memory user,\n        bool[] memory val\n    ) external override {\n        require(user.length == val.length, \"INVALID_INPUT\");\n        Whitelist(whitelist).setWhitelist(user, val);\n        emit OwnerFunctionCalled(18);\n    }\n\n    /**\n     * @notice Updates a sequencer address at the sequencer inbox\n     * @param newSequencer new sequencer address to be used\n     */\n    function setSequencer(address newSequencer) external override {\n        ISequencerInbox(sequencerBridge).setSequencer(newSequencer);\n        emit OwnerFunctionCalled(19);\n    }\n\n    /**\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\n     * @param beacon address of beacon to be upgraded\n     * @param newImplementation new address of implementation\n     */\n    function upgradeBeacon(address beacon, address newImplementation) external override {\n        UpgradeableBeacon(beacon).upgradeTo(newImplementation);\n        emit OwnerFunctionCalled(20);\n    }\n\n    /*\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external override whenPaused {\n        require(stackerA.length == stackerB.length, \"WRONG_LENGTH\");\n        for (uint256 i = 0; i < stackerA.length; i++) {\n            address chall = inChallenge(stackerA[i], stackerB[i]);\n\n            require(address(0) != chall, \"NOT_IN_CHALL\");\n            clearChallenge(stackerA[i]);\n            clearChallenge(stackerB[i]);\n\n            IChallenge(chall).clearChallenge();\n        }\n    }\n\n    function forceRefundStaker(address[] memory stacker) external override whenPaused {\n        for (uint256 i = 0; i < stacker.length; i++) {\n            withdrawStaker(stacker[i]);\n        }\n    }\n\n    function forceCreateNode(\n        bytes32 expectedNodeHash,\n        bytes32[3][2] calldata assertionBytes32Fields,\n        uint256[4][2] calldata assertionIntFields,\n        uint256 beforeProposedBlock,\n        uint256 beforeInboxMaxCount,\n        uint256 prevNode,\n        uint256 deadlineBlock,\n        uint256 sequencerBatchEnd,\n        bytes32 sequencerBatchAcc\n    ) external override whenPaused {\n        require(prevNode == latestConfirmed(), \"ONLY_LATEST_CONFIRMED\");\n\n        RollupLib.Assertion memory assertion =\n                RollupLib.decodeAssertion(\n                    assertionBytes32Fields,\n                    assertionIntFields,\n                    beforeProposedBlock,\n                    beforeInboxMaxCount,\n                    sequencerBridge.messageCount()\n                );\n\n        bytes32 nodeHash =\n            _newNode(\n                assertion,\n                deadlineBlock,\n                sequencerBatchEnd,\n                sequencerBatchAcc,\n                prevNode,\n                getNodeHash(prevNode),\n                false\n            );\n        // TODO: should we add a stake?\n        \n        require(expectedNodeHash == nodeHash, \"NOT_EXPECTED_HASH\");\n    }\n\n    function forceConfirmNode(\n        bytes calldata sendsData,\n        uint256[] calldata sendLengths\n    ) external override whenPaused {\n        outbox.processOutgoingMessages(sendsData, sendLengths);\n\n        confirmLatestNode();\n\n        rollupEventBridge.nodeConfirmed(latestConfirmed());\n\n        // emit NodeConfirmed(\n        //     firstUnresolved,\n        //     afterSendAcc,\n        //     afterSendCount,\n        //     afterLogAcc,\n        //     afterLogCount\n        // );\n    }\n    */\n}\n"
    },
    "contracts/rollup/facets/RollupUser.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.6.11;\n\nimport \"../Rollup.sol\";\nimport \"./IRollupFacets.sol\";\n\nabstract contract AbsRollupUserFacet is RollupBase, IRollupUser {\n    function initialize(address _stakeToken) public virtual override;\n\n    // TODO: Configure this value based on the cost of sends\n    uint8 internal constant MAX_SEND_COUNT = 100;\n\n    modifier onlyValidator {\n        require(isValidator[msg.sender], \"NOT_VALIDATOR\");\n        _;\n    }\n\n    /**\n     * @notice Reject the next unresolved node\n     * @param stakerAddress Example staker staked on sibling\n     */\n    function rejectNextNode(address stakerAddress) external onlyValidator whenNotPaused {\n        requireUnresolvedExists();\n        uint256 latest = latestConfirmed();\n        uint256 firstUnresolved = firstUnresolvedNode();\n        INode node = getNode(firstUnresolved);\n        if (node.prev() == latest) {\n            // Confirm that the example staker is staked on a sibling node\n            require(isStaked(stakerAddress), \"NOT_STAKED\");\n            requireUnresolved(latestStakedNode(stakerAddress));\n            require(!node.stakers(stakerAddress), \"STAKED_ON_TARGET\");\n\n            // Verify the block's deadline has passed\n            node.requirePastDeadline();\n\n            getNode(latest).requirePastChildConfirmDeadline();\n\n            removeOldZombies(0);\n\n            // Verify that no staker is staked on this node\n            require(node.stakerCount() == countStakedZombies(node), \"HAS_STAKERS\");\n        }\n        rejectNextNode();\n        rollupEventBridge.nodeRejected(firstUnresolved);\n\n        emit NodeRejected(firstUnresolved);\n    }\n\n    /**\n     * @notice Confirm the next unresolved node\n     * @param beforeSendAcc Accumulator of the AVM sends from the beginning of time up to the end of the previous confirmed node\n     * @param sendsData Concatenated data of the sends included in the confirmed node\n     * @param sendLengths Lengths of the included sends\n     * @param afterSendCount Total number of AVM sends emitted from the beginning of time after this node is confirmed\n     * @param afterLogAcc Accumulator of the AVM logs from the beginning of time up to the end of this node\n     * @param afterLogCount Total number of AVM logs emitted from the beginning of time after this node is confirmed\n     */\n    function confirmNextNode(\n        bytes32 beforeSendAcc,\n        bytes calldata sendsData,\n        uint256[] calldata sendLengths,\n        uint256 afterSendCount,\n        bytes32 afterLogAcc,\n        uint256 afterLogCount\n    ) external onlyValidator whenNotPaused {\n        requireUnresolvedExists();\n\n        // There is at least one non-zombie staker\n        require(stakerCount() > 0, \"NO_STAKERS\");\n\n        uint256 firstUnresolved = firstUnresolvedNode();\n        INode node = getNode(firstUnresolved);\n\n        // Verify the block's deadline has passed\n        node.requirePastDeadline();\n\n        // Check that prev is latest confirmed\n        require(node.prev() == latestConfirmed(), \"INVALID_PREV\");\n\n        getNode(latestConfirmed()).requirePastChildConfirmDeadline();\n\n        removeOldZombies(0);\n\n        // All non-zombie stakers are staked on this node\n        require(\n            node.stakerCount() == stakerCount().add(countStakedZombies(node)),\n            \"NOT_ALL_STAKED\"\n        );\n\n        bytes32 afterSendAcc = RollupLib.feedAccumulator(sendsData, sendLengths, beforeSendAcc);\n        require(\n            node.confirmData() ==\n                RollupLib.confirmHash(\n                    beforeSendAcc,\n                    afterSendAcc,\n                    afterLogAcc,\n                    afterSendCount,\n                    afterLogCount\n                ),\n            \"CONFIRM_DATA\"\n        );\n\n        outbox.processOutgoingMessages(sendsData, sendLengths);\n\n        confirmNextNode();\n\n        rollupEventBridge.nodeConfirmed(firstUnresolved);\n\n        emit NodeConfirmed(\n            firstUnresolved,\n            afterSendAcc,\n            afterSendCount,\n            afterLogAcc,\n            afterLogCount\n        );\n    }\n\n    /**\n     * @notice Create a new stake\n     * @param depositAmount The amount of either eth or tokens staked\n     */\n    function _newStake(uint256 depositAmount) internal onlyValidator whenNotPaused {\n        // Verify that sender is not already a staker\n        require(!isStaked(msg.sender), \"ALREADY_STAKED\");\n        require(!isZombie(msg.sender), \"STAKER_IS_ZOMBIE\");\n        require(depositAmount >= currentRequiredStake(), \"NOT_ENOUGH_STAKE\");\n\n        createNewStake(msg.sender, depositAmount);\n\n        rollupEventBridge.stakeCreated(msg.sender, latestConfirmed());\n    }\n\n    /**\n     * @notice Move stake onto an existing node\n     * @param nodeNum Inbox of the node to move stake to. This must by a child of the node the staker is currently staked on\n     * @param nodeHash Node hash of nodeNum (protects against reorgs)\n     */\n    function stakeOnExistingNode(uint256 nodeNum, bytes32 nodeHash)\n        external\n        onlyValidator\n        whenNotPaused\n    {\n        require(isStaked(msg.sender), \"NOT_STAKED\");\n\n        require(getNodeHash(nodeNum) == nodeHash, \"NODE_REORG\");\n        require(nodeNum >= firstUnresolvedNode() && nodeNum <= latestNodeCreated());\n        INode node = getNode(nodeNum);\n        require(latestStakedNode(msg.sender) == node.prev(), \"NOT_STAKED_PREV\");\n        stakeOnNode(msg.sender, nodeNum, confirmPeriodBlocks);\n    }\n\n    struct StakeOnNewNodeFrame {\n        uint256 sequencerBatchEnd;\n        bytes32 sequencerBatchAcc;\n        uint256 currentInboxSize;\n        INode node;\n        bytes32 executionHash;\n        INode prevNode;\n    }\n\n    /**\n     * @notice Move stake onto a new node\n     * @param expectedNodeHash The hash of the node being created (protects against reorgs)\n     * @param assertionBytes32Fields Assertion data for creating\n     * @param assertionIntFields Assertion data for creating\n     */\n    function stakeOnNewNode(\n        bytes32 expectedNodeHash,\n        bytes32[3][2] calldata assertionBytes32Fields,\n        uint256[4][2] calldata assertionIntFields,\n        uint256 beforeProposedBlock,\n        uint256 beforeInboxMaxCount,\n        bytes calldata sequencerBatchProof\n    ) external onlyValidator whenNotPaused {\n        require(isStaked(msg.sender), \"NOT_STAKED\");\n\n        uint256 prevNodeNum = latestStakedNode(msg.sender);\n        StakeOnNewNodeFrame memory frame;\n        {\n            INode prevNode = getNode(prevNodeNum);\n            uint256 currentInboxSize = sequencerBridge.messageCount();\n\n            RollupLib.Assertion memory assertion =\n                RollupLib.decodeAssertion(\n                    assertionBytes32Fields,\n                    assertionIntFields,\n                    beforeProposedBlock,\n                    beforeInboxMaxCount,\n                    currentInboxSize\n                );\n\n            uint256 sequencerBatchEnd;\n            bytes32 sequencerBatchAcc;\n            uint256 deadlineBlock;\n            {\n                // frame.executionHash = RollupLib.executionHash(assertion);\n                // Make sure the previous state is correct against the node being built on\n                require(\n                    RollupLib.stateHash(assertion.beforeState) == prevNode.stateHash(),\n                    \"PREV_STATE_HASH\"\n                );\n\n                (sequencerBatchEnd, sequencerBatchAcc) = sequencerBridge\n                    .proveBatchContainsSequenceNumber(\n                    sequencerBatchProof,\n                    assertion.afterState.inboxCount\n                );\n\n                uint256 timeSinceLastNode = block.number.sub(assertion.beforeState.proposedBlock);\n                // Verify that assertion meets the minimum Delta time requirement\n                require(timeSinceLastNode >= minimumAssertionPeriod, \"TIME_DELTA\");\n\n                uint256 gasUsed = assertion.afterState.gasUsed.sub(assertion.beforeState.gasUsed);\n                // Minimum size requirements: each assertion must satisfy either\n                require(\n                    // Consumes at least all inbox messages put into L1 inbox before your prev nodes L1 blocknum\n                    assertion.afterState.inboxCount >= assertion.beforeState.inboxMaxCount ||\n                        // Consumes ArbGas >=100% of speed limit for time since your prev node (based on difference in L1 blocknum)\n                        gasUsed >= timeSinceLastNode.mul(arbGasSpeedLimitPerBlock) ||\n                        assertion.afterState.sendCount.sub(assertion.beforeState.sendCount) ==\n                        MAX_SEND_COUNT,\n                    \"TOO_SMALL\"\n                );\n\n                // Don't allow an assertion to use above a maximum amount of gas\n                require(\n                    gasUsed <= timeSinceLastNode.mul(arbGasSpeedLimitPerBlock).mul(4),\n                    \"TOO_LARGE\"\n                );\n\n                {\n                    // Set deadline rounding up to the nearest block\n                    uint256 checkTime =\n                        gasUsed.add(arbGasSpeedLimitPerBlock.sub(1)).div(arbGasSpeedLimitPerBlock);\n                    deadlineBlock = max(\n                        block.number.add(confirmPeriodBlocks),\n                        prevNode.deadlineBlock()\n                    )\n                        .add(checkTime);\n                    uint256 olderSibling = prevNode.latestChildNumber();\n                    if (olderSibling != 0) {\n                        deadlineBlock = max(deadlineBlock, getNode(olderSibling).deadlineBlock());\n                    }\n                }\n                // Ensure that the assertion doesn't read past the end of the current inbox\n                require(assertion.afterState.inboxCount <= currentInboxSize, \"INBOX_PAST_END\");\n            }\n\n            bytes32 nodeHash;\n            {\n                bytes32 lastHash;\n                bool hasSibling = prevNode.latestChildNumber() > 0;\n                if (hasSibling) {\n                    lastHash = getNodeHash(prevNode.latestChildNumber());\n                } else {\n                    lastHash = getNodeHash(prevNodeNum);\n                }\n\n                (nodeHash, frame) = createNewNode(\n                    assertion,\n                    deadlineBlock,\n                    sequencerBatchEnd,\n                    sequencerBatchAcc,\n                    prevNodeNum,\n                    lastHash,\n                    hasSibling\n                );\n            }\n            require(nodeHash == expectedNodeHash, \"UNEXPECTED_NODE_HASH\");\n            stakeOnNode(msg.sender, latestNodeCreated(), confirmPeriodBlocks);\n        }\n\n        emit NodeCreated(\n            latestNodeCreated(),\n            getNodeHash(prevNodeNum),\n            expectedNodeHash,\n            frame.executionHash,\n            frame.currentInboxSize,\n            frame.sequencerBatchEnd,\n            frame.sequencerBatchAcc,\n            assertionBytes32Fields,\n            assertionIntFields\n        );\n    }\n\n    function createNewNode(\n        RollupLib.Assertion memory assertion,\n        uint256 deadlineBlock,\n        uint256 sequencerBatchEnd,\n        bytes32 sequencerBatchAcc,\n        uint256 prevNode,\n        bytes32 prevHash,\n        bool hasSibling\n    ) internal returns (bytes32, StakeOnNewNodeFrame memory) {\n        StakeOnNewNodeFrame memory frame;\n        frame.currentInboxSize = sequencerBridge.messageCount();\n        frame.prevNode = getNode(prevNode);\n        {\n            uint256 nodeNum = latestNodeCreated() + 1;\n            frame.executionHash = RollupLib.executionHash(assertion);\n\n            frame.sequencerBatchEnd = sequencerBatchEnd;\n            frame.sequencerBatchAcc = sequencerBatchAcc;\n\n            rollupEventBridge.nodeCreated(nodeNum, prevNode, deadlineBlock, msg.sender);\n\n            frame.node = INode(\n                nodeFactory.createNode(\n                    RollupLib.stateHash(assertion.afterState),\n                    RollupLib.challengeRoot(assertion, frame.executionHash, block.number),\n                    RollupLib.confirmHash(assertion),\n                    prevNode,\n                    deadlineBlock\n                )\n            );\n        }\n\n        bytes32 nodeHash =\n            RollupLib.nodeHash(hasSibling, prevHash, frame.executionHash, frame.sequencerBatchAcc);\n\n        nodeCreated(frame.node, nodeHash);\n        frame.prevNode.childCreated(latestNodeCreated());\n\n        return (nodeHash, frame);\n    }\n\n    /**\n     * @notice Refund a staker that is currently staked on or before the latest confirmed node\n     * @dev Since a staker is initially placed in the latest confirmed node, if they don't move it\n     * a griefer can remove their stake. It is recomended to batch together the txs to place a stake\n     * and move it to the desired node.\n     * @param stakerAddress Address of the staker whose stake is refunded\n     */\n    function returnOldDeposit(address stakerAddress) external override onlyValidator whenNotPaused {\n        require(latestStakedNode(stakerAddress) <= latestConfirmed(), \"TOO_RECENT\");\n        requireUnchallengedStaker(stakerAddress);\n        withdrawStaker(stakerAddress);\n    }\n\n    /**\n     * @notice Increase the amount staked for the given staker\n     * @param stakerAddress Address of the staker whose stake is increased\n     * @param depositAmount The amount of either eth or tokens deposited\n     */\n    function _addToDeposit(address stakerAddress, uint256 depositAmount)\n        internal\n        onlyValidator\n        whenNotPaused\n    {\n        requireUnchallengedStaker(stakerAddress);\n        increaseStakeBy(stakerAddress, depositAmount);\n    }\n\n    /**\n     * @notice Reduce the amount staked for the sender\n     * @param target Target amount of stake for the staker. If this is below the current minimum, it will be set to minimum instead\n     */\n    function reduceDeposit(uint256 target) external onlyValidator whenNotPaused {\n        requireUnchallengedStaker(msg.sender);\n        uint256 currentRequired = currentRequiredStake();\n        if (target < currentRequired) {\n            target = currentRequired;\n        }\n        reduceStakeTo(msg.sender, target);\n    }\n\n    /**\n     * @notice Start a challenge between the given stakers over the node created by the first staker assuming that the two are staked on conflicting nodes\n     * @param stakers Stakers engaged in the challenge. The first staker should be staked on the first node\n     * @param nodeNums Nodes of the stakers engaged in the challenge. The first node should be the earliest and is the one challenged\n     * @param executionHashes Challenge related data for the two nodes\n     * @param proposedTimes Times that the two nodes were proposed\n     * @param maxMessageCounts Total number of messages consumed by the two nodes\n     */\n    function createChallenge(\n        address payable[2] calldata stakers,\n        uint256[2] calldata nodeNums,\n        bytes32[2] calldata executionHashes,\n        uint256[2] calldata proposedTimes,\n        uint256[2] calldata maxMessageCounts\n    ) external onlyValidator whenNotPaused {\n        require(nodeNums[0] < nodeNums[1], \"WRONG_ORDER\");\n        require(nodeNums[1] <= latestNodeCreated(), \"NOT_PROPOSED\");\n        require(latestConfirmed() < nodeNums[0], \"ALREADY_CONFIRMED\");\n\n        INode node1 = getNode(nodeNums[0]);\n        INode node2 = getNode(nodeNums[1]);\n\n        require(node1.prev() == node2.prev(), \"DIFF_PREV\");\n\n        requireUnchallengedStaker(stakers[0]);\n        requireUnchallengedStaker(stakers[1]);\n\n        require(node1.stakers(stakers[0]), \"STAKER1_NOT_STAKED\");\n        require(node2.stakers(stakers[1]), \"STAKER2_NOT_STAKED\");\n\n        require(\n            node1.challengeHash() ==\n                RollupLib.challengeRootHash(\n                    executionHashes[0],\n                    proposedTimes[0],\n                    maxMessageCounts[0]\n                ),\n            \"CHAL_HASH1\"\n        );\n\n        require(\n            node2.challengeHash() ==\n                RollupLib.challengeRootHash(\n                    executionHashes[1],\n                    proposedTimes[1],\n                    maxMessageCounts[1]\n                ),\n            \"CHAL_HASH2\"\n        );\n\n        uint256 commonEndTime =\n            node1.deadlineBlock().sub(proposedTimes[0]).add(extraChallengeTimeBlocks).add(\n                getNode(node1.prev()).firstChildBlock()\n            );\n        if (commonEndTime < proposedTimes[1]) {\n            // The second node was created too late to be challenged.\n            completeChallengeImpl(stakers[0], stakers[1]);\n            return;\n        }\n        // Start a challenge between staker1 and staker2. Staker1 will defend the correctness of node1, and staker2 will challenge it.\n        address challengeAddress =\n            challengeFactory.createChallenge(\n                address(this),\n                executionHashes[0],\n                maxMessageCounts[0],\n                stakers[0],\n                stakers[1],\n                commonEndTime.sub(proposedTimes[0]),\n                commonEndTime.sub(proposedTimes[1]),\n                sequencerBridge,\n                delayedBridge\n            );\n\n        challengeStarted(stakers[0], stakers[1], challengeAddress);\n\n        emit RollupChallengeStarted(challengeAddress, stakers[0], stakers[1], nodeNums[0]);\n    }\n\n    /**\n     * @notice Inform the rollup that the challenge between the given stakers is completed\n     * @dev completeChallenge isn't pausable since in flight challenges should be allowed to complete or else they could be forced to timeout\n     * @param winningStaker Address of the winning staker\n     * @param losingStaker Address of the losing staker\n     */\n    function completeChallenge(address winningStaker, address losingStaker)\n        external\n        override\n        whenNotPaused\n    {\n        // Only the challenge contract can declare winners and losers\n        require(msg.sender == inChallenge(winningStaker, losingStaker), \"WRONG_SENDER\");\n\n        completeChallengeImpl(winningStaker, losingStaker);\n    }\n\n    function completeChallengeImpl(address winningStaker, address losingStaker) private {\n        uint256 remainingLoserStake = amountStaked(losingStaker);\n        uint256 winnerStake = amountStaked(winningStaker);\n        if (remainingLoserStake > winnerStake) {\n            remainingLoserStake = remainingLoserStake.sub(reduceStakeTo(losingStaker, winnerStake));\n        }\n\n        uint256 amountWon = remainingLoserStake / 2;\n        increaseStakeBy(winningStaker, amountWon);\n        remainingLoserStake = remainingLoserStake.sub(amountWon);\n        clearChallenge(winningStaker);\n\n        increaseWithdrawableFunds(owner, remainingLoserStake);\n        turnIntoZombie(losingStaker);\n    }\n\n    /**\n     * @notice Remove the given zombie from nodes it is staked on, moving backwords from the latest node it is staked on\n     * @param zombieNum Index of the zombie to remove\n     * @param maxNodes Maximum number of nodes to remove the zombie from (to limit the cost of this transaction)\n     */\n    function removeZombie(uint256 zombieNum, uint256 maxNodes)\n        external\n        onlyValidator\n        whenNotPaused\n    {\n        require(zombieNum <= zombieCount(), \"NO_SUCH_ZOMBIE\");\n        address zombieStakerAddress = zombieAddress(zombieNum);\n        uint256 latestStakedNode = zombieLatestStakedNode(zombieNum);\n        uint256 nodesRemoved = 0;\n        uint256 firstUnresolved = firstUnresolvedNode();\n        while (latestStakedNode >= firstUnresolved && nodesRemoved < maxNodes) {\n            INode node = getNode(latestStakedNode);\n            node.removeStaker(zombieStakerAddress);\n            latestStakedNode = node.prev();\n            nodesRemoved++;\n        }\n        if (latestStakedNode < firstUnresolved) {\n            removeZombie(zombieNum);\n        } else {\n            zombieUpdateLatestStakedNode(zombieNum, latestStakedNode);\n        }\n    }\n\n    /**\n     * @notice Remove any zombies whose latest stake is earlier than the first unresolved node\n     * @param startIndex Index in the zombie list to start removing zombies from (to limit the cost of this transaction)\n     */\n    function removeOldZombies(uint256 startIndex) public {\n        uint256 currentZombieCount = zombieCount();\n        uint256 firstUnresolved = firstUnresolvedNode();\n        for (uint256 i = startIndex; i < currentZombieCount; i++) {\n            while (zombieLatestStakedNode(i) < firstUnresolved) {\n                removeZombie(i);\n                currentZombieCount--;\n                if (i >= currentZombieCount) {\n                    return;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Calculate the current amount of funds required to place a new stake in the rollup\n     * @dev If the stake requirement get's too high, this function may start reverting due to overflow, but\n     * that only blocks operations that should be blocked anyway\n     * @return The current minimum stake requirement\n     */\n    function currentRequiredStake(\n        uint256 _blockNumber,\n        uint256 _firstUnresolvedNodeNum,\n        uint256 _latestNodeCreated\n    ) internal view returns (uint256) {\n        // If there are no unresolved nodes, then you can use the base stake\n        if (_firstUnresolvedNodeNum - 1 == _latestNodeCreated) {\n            return baseStake;\n        }\n        uint256 firstUnresolvedDeadline = getNode(_firstUnresolvedNodeNum).deadlineBlock();\n        if (_blockNumber < firstUnresolvedDeadline) {\n            return baseStake;\n        }\n        uint24[10] memory numerators =\n            [1, 122971, 128977, 80017, 207329, 114243, 314252, 129988, 224562, 162163];\n        uint24[10] memory denominators =\n            [1, 114736, 112281, 64994, 157126, 80782, 207329, 80017, 128977, 86901];\n        uint256 firstUnresolvedAge = _blockNumber.sub(firstUnresolvedDeadline);\n        uint256 periodsPassed = firstUnresolvedAge.mul(10).div(confirmPeriodBlocks);\n        // Overflow check\n        if (periodsPassed.div(10) >= 255) {\n            return type(uint256).max;\n        }\n        uint256 baseMultiplier = 2**periodsPassed.div(10);\n        uint256 withNumerator = baseMultiplier * numerators[periodsPassed % 10];\n        // Overflow check\n        if (withNumerator / baseMultiplier != numerators[periodsPassed % 10]) {\n            return type(uint256).max;\n        }\n        uint256 multiplier = withNumerator.div(denominators[periodsPassed % 10]);\n        if (multiplier == 0) {\n            multiplier = 1;\n        }\n        uint256 fullStake = baseStake * multiplier;\n        // Overflow check\n        if (fullStake / baseStake != multiplier) {\n            return type(uint256).max;\n        }\n        return fullStake;\n    }\n\n    /**\n     * @notice Calculate the current amount of funds required to place a new stake in the rollup\n     * @dev If the stake requirement get's too high, this function may start reverting due to overflow, but\n     * that only blocks operations that should be blocked anyway\n     * @return The current minimum stake requirement\n     */\n    function requiredStake(\n        uint256 blockNumber,\n        uint256 firstUnresolvedNodeNum,\n        uint256 latestNodeCreated\n    ) public view returns (uint256) {\n        return currentRequiredStake(blockNumber, firstUnresolvedNodeNum, latestNodeCreated);\n    }\n\n    function currentRequiredStake() public view returns (uint256) {\n        uint256 firstUnresolvedNodeNum = firstUnresolvedNode();\n\n        return currentRequiredStake(block.number, firstUnresolvedNodeNum, latestNodeCreated());\n    }\n\n    /**\n     * @notice Calculate the number of zombies staked on the given node\n     *\n     * @dev This function could be uncallable if there are too many zombies. However,\n     * removeZombie and removeOldZombies can be used to remove any zombies that exist\n     * so that this will then be callable\n     *\n     * @param node The node on which to count staked zombies\n     * @return The number of zombies staked on the node\n     */\n    function countStakedZombies(INode node) public view override returns (uint256) {\n        uint256 currentZombieCount = zombieCount();\n        uint256 stakedZombieCount = 0;\n        for (uint256 i = 0; i < currentZombieCount; i++) {\n            if (node.stakers(zombieAddress(i))) {\n                stakedZombieCount++;\n            }\n        }\n        return stakedZombieCount;\n    }\n\n    /**\n     * @notice Verify that there are some number of nodes still unresolved\n     */\n    function requireUnresolvedExists() public view override {\n        uint256 firstUnresolved = firstUnresolvedNode();\n        require(\n            firstUnresolved > latestConfirmed() && firstUnresolved <= latestNodeCreated(),\n            \"NO_UNRESOLVED\"\n        );\n    }\n\n    function requireUnresolved(uint256 nodeNum) public view override {\n        require(nodeNum >= firstUnresolvedNode(), \"ALREADY_DECIDED\");\n        require(nodeNum <= latestNodeCreated(), \"DOESNT_EXIST\");\n    }\n\n    /**\n     * @notice Verify that the given address is staked and not actively in a challenge\n     * @param stakerAddress Address to check\n     */\n    function requireUnchallengedStaker(address stakerAddress) private view {\n        require(isStaked(stakerAddress), \"NOT_STAKED\");\n        require(currentChallenge(stakerAddress) == address(0), \"IN_CHAL\");\n    }\n\n    function withdrawStakerFunds(address payable destination) external virtual returns (uint256);\n}\n\ncontract RollupUserFacet is AbsRollupUserFacet {\n    function initialize(address _stakeToken) public override {\n        require(_stakeToken == address(0), \"NO_TOKEN_ALLOWED\");\n        // stakeToken = _stakeToken;\n    }\n\n    /**\n     * @notice Create a new stake\n     * @dev It is recomended to call stakeOnExistingNode after creating a new stake\n     * so that a griefer doesn't remove your stake by immediately calling returnOldDeposit\n     */\n    function newStake() external payable onlyValidator whenNotPaused {\n        _newStake(msg.value);\n    }\n\n    /**\n     * @notice Increase the amount staked eth for the given staker\n     * @param stakerAddress Address of the staker whose stake is increased\n     */\n    function addToDeposit(address stakerAddress) external payable onlyValidator whenNotPaused {\n        _addToDeposit(stakerAddress, msg.value);\n    }\n\n    /**\n     * @notice Withdraw uncomitted funds owned by sender from the rollup chain\n     * @param destination Address to transfer the withdrawn funds to\n     */\n    function withdrawStakerFunds(address payable destination)\n        external\n        override\n        onlyValidator\n        whenNotPaused\n        returns (uint256)\n    {\n        uint256 amount = withdrawFunds(msg.sender);\n        // Note: This is an unsafe external call and could be used for reentrency\n        // This is safe because it occurs after all checks and effects\n        destination.transfer(amount);\n        return amount;\n    }\n}\n\ncontract ERC20RollupUserFacet is AbsRollupUserFacet {\n    function initialize(address _stakeToken) public override {\n        require(_stakeToken != address(0), \"NEED_STAKE_TOKEN\");\n        require(stakeToken == address(0), \"ALREADY_INIT\");\n        stakeToken = _stakeToken;\n    }\n\n    /**\n     * @notice Create a new stake\n     * @dev It is recomended to call stakeOnExistingNode after creating a new stake\n     * so that a griefer doesn't remove your stake by immediately calling returnOldDeposit\n     * @param tokenAmount the amount of tokens staked\n     */\n    function newStake(uint256 tokenAmount) external onlyValidator whenNotPaused {\n        _newStake(tokenAmount);\n        require(\n            IERC20(stakeToken).transferFrom(msg.sender, address(this), tokenAmount),\n            \"TRANSFER_FAIL\"\n        );\n    }\n\n    /**\n     * @notice Increase the amount staked tokens for the given staker\n     * @param stakerAddress Address of the staker whose stake is increased\n     * @param tokenAmount the amount of tokens staked\n     */\n    function addToDeposit(address stakerAddress, uint256 tokenAmount)\n        external\n        onlyValidator\n        whenNotPaused\n    {\n        _addToDeposit(stakerAddress, tokenAmount);\n        require(\n            IERC20(stakeToken).transferFrom(msg.sender, address(this), tokenAmount),\n            \"TRANSFER_FAIL\"\n        );\n    }\n\n    /**\n     * @notice Withdraw uncomitted funds owned by sender from the rollup chain\n     * @param destination Address to transfer the withdrawn funds to\n     */\n    function withdrawStakerFunds(address payable destination)\n        external\n        override\n        onlyValidator\n        whenNotPaused\n        returns (uint256)\n    {\n        uint256 amount = withdrawFunds(msg.sender);\n        // Note: This is an unsafe external call and could be used for reentrency\n        // This is safe because it occurs after all checks and effects\n        require(IERC20(stakeToken).transfer(destination, amount), \"TRANSFER_FAILED\");\n        return amount;\n    }\n}\n"
    }
  }
}