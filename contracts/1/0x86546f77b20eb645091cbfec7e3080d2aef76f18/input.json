{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BancorChanger.sol": {
      "content": "// File: 1/solidity/contracts/interfaces/IOwned.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public constant returns (address owner) { owner; }\n\n    function transferOwnership(address _newOwner) public;\n    function acceptOwnership() public;\n}\n\n// File: 1/solidity/contracts/Owned.sol\n\npragma solidity ^0.4.11;\n\n\n/*\n    Provides support and utilities for contract ownership\n*/\ncontract Owned is IOwned {\n    address public owner;\n    address public newOwner;\n\n    event OwnerUpdate(address _prevOwner, address _newOwner);\n\n    /**\n        @dev constructor\n    */\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        assert(msg.sender == owner);\n        _;\n    }\n\n    /**\n        @dev allows transferring the contract ownership\n        the new owner still needs to accept the transfer\n        can only be called by the contract owner\n\n        @param _newOwner    new contract owner\n    */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    /**\n        @dev used by a new owner to accept an ownership transfer\n    */\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = 0x0;\n    }\n}\n\n// File: 1/solidity/contracts/Utils.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Utilities & Common Modifiers\n*/\ncontract Utils {\n    /**\n        constructor\n    */\n    function Utils() {\n    }\n\n    // verifies that an amount is greater than zero\n    modifier greaterThanZero(uint256 _amount) {\n        require(_amount > 0);\n        _;\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        require(_address != 0x0);\n        _;\n    }\n\n    // verifies that the address is different than this contract address\n    modifier notThis(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    // Overflow protected math functions\n\n    /**\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\n\n        @param _x   value 1\n        @param _y   value 2\n\n        @return sum\n    */\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n        uint256 z = _x + _y;\n        assert(z >= _x);\n        return z;\n    }\n\n    /**\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n\n        @param _x   minuend\n        @param _y   subtrahend\n\n        @return difference\n    */\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n        assert(_x >= _y);\n        return _x - _y;\n    }\n\n    /**\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n\n        @param _x   factor 1\n        @param _y   factor 2\n\n        @return product\n    */\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n        uint256 z = _x * _y;\n        assert(_x == 0 || z / _x == _y);\n        return z;\n    }\n}\n\n// File: 1/solidity/contracts/interfaces/IERC20Token.sol\n\npragma solidity ^0.4.11;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public constant returns (string name) { name; }\n    function symbol() public constant returns (string symbol) { symbol; }\n    function decimals() public constant returns (uint8 decimals) { decimals; }\n    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: 1/solidity/contracts/interfaces/ITokenHolder.sol\n\npragma solidity ^0.4.11;\n\n\n\n/*\n    Token Holder interface\n*/\ncontract ITokenHolder is IOwned {\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n}\n\n// File: 1/solidity/contracts/TokenHolder.sol\n\npragma solidity ^0.4.11;\n\n\n\n\n\n/*\n    We consider every contract to be a 'token holder' since it's currently not possible\n    for a contract to deny receiving tokens.\n\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\n*/\ncontract TokenHolder is ITokenHolder, Owned, Utils {\n    /**\n        @dev constructor\n    */\n    function TokenHolder() {\n    }\n\n    /**\n        @dev withdraws tokens held by the contract and sends them to an account\n        can only be called by the owner\n\n        @param _token   ERC20 token contract address\n        @param _to      account to receive the new amount\n        @param _amount  amount to withdraw\n    */\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n        public\n        ownerOnly\n        validAddress(_token)\n        validAddress(_to)\n        notThis(_to)\n    {\n        assert(_token.transfer(_to, _amount));\n    }\n}\n\n// File: 1/solidity/contracts/interfaces/ISmartToken.sol\n\npragma solidity ^0.4.11;\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is ITokenHolder, IERC20Token {\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n}\n\n// File: 1/solidity/contracts/SmartTokenController.sol\n\npragma solidity ^0.4.11;\n\n\n\n/*\n    The smart token controller is an upgradable part of the smart token that allows\n    more functionality as well as fixes for bugs/exploits.\n    Once it accepts ownership of the token, it becomes the token's sole controller\n    that can execute any of its functions.\n\n    To upgrade the controller, ownership must be transferred to a new controller, along with\n    any relevant data.\n\n    The smart token must be set on construction and cannot be changed afterwards.\n    Wrappers are provided (as opposed to a single 'execute' function) for each of the token's functions, for easier access.\n\n    Note that the controller can transfer token ownership to a new controller that\n    doesn't allow executing any function on the token, for a trustless solution.\n    Doing that will also remove the owner's ability to upgrade the controller.\n*/\ncontract SmartTokenController is TokenHolder {\n    ISmartToken public token;   // smart token\n\n    /**\n        @dev constructor\n    */\n    function SmartTokenController(ISmartToken _token)\n        validAddress(_token)\n    {\n        token = _token;\n    }\n\n    // ensures that the controller is the token's owner\n    modifier active() {\n        assert(token.owner() == address(this));\n        _;\n    }\n\n    // ensures that the controller is not the token's owner\n    modifier inactive() {\n        assert(token.owner() != address(this));\n        _;\n    }\n\n    /**\n        @dev allows transferring the token ownership\n        the new owner still need to accept the transfer\n        can only be called by the contract owner\n\n        @param _newOwner    new token owner\n    */\n    function transferTokenOwnership(address _newOwner) public ownerOnly {\n        token.transferOwnership(_newOwner);\n    }\n\n    /**\n        @dev used by a new owner to accept a token ownership transfer\n        can only be called by the contract owner\n    */\n    function acceptTokenOwnership() public ownerOnly {\n        token.acceptOwnership();\n    }\n\n    /**\n        @dev disables/enables token transfers\n        can only be called by the contract owner\n\n        @param _disable    true to disable transfers, false to enable them\n    */\n    function disableTokenTransfers(bool _disable) public ownerOnly {\n        token.disableTransfers(_disable);\n    }\n\n    /**\n        @dev withdraws tokens held by the token and sends them to an account\n        can only be called by the owner\n\n        @param _token   ERC20 token contract address\n        @param _to      account to receive the new amount\n        @param _amount  amount to withdraw\n    */\n    function withdrawFromToken(IERC20Token _token, address _to, uint256 _amount) public ownerOnly {\n        token.withdrawTokens(_token, _to, _amount);\n    }\n}\n\n// File: 1/solidity/contracts/Managed.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Provides support and utilities for contract management\n*/\ncontract Managed {\n    address public manager;\n    address public newManager;\n\n    event ManagerUpdate(address _prevManager, address _newManager);\n\n    /**\n        @dev constructor\n    */\n    function Managed() {\n        manager = msg.sender;\n    }\n\n    // allows execution by the manager only\n    modifier managerOnly {\n        assert(msg.sender == manager);\n        _;\n    }\n\n    /**\n        @dev allows transferring the contract management\n        the new manager still needs to accept the transfer\n        can only be called by the contract manager\n\n        @param _newManager    new contract manager\n    */\n    function transferManagement(address _newManager) public managerOnly {\n        require(_newManager != manager);\n        newManager = _newManager;\n    }\n\n    /**\n        @dev used by a new manager to accept a management transfer\n    */\n    function acceptManagement() public {\n        require(msg.sender == newManager);\n        ManagerUpdate(manager, newManager);\n        manager = newManager;\n        newManager = 0x0;\n    }\n}\n\n// File: 1/solidity/contracts/interfaces/ITokenChanger.sol\n\npragma solidity ^0.4.11;\n\n\n/*\n    EIP228 Token Changer interface\n*/\ncontract ITokenChanger {\n    function changeableTokenCount() public constant returns (uint16 count);\n    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount);\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);\n}\n\n// File: 1/solidity/contracts/interfaces/IBancorFormula.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Bancor Formula interface\n*/\ncontract IBancorFormula {\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\n}\n\n// File: 1/solidity/contracts/interfaces/IEtherToken.sol\n\npragma solidity ^0.4.11;\n\n\n\n/*\n    Ether Token interface\n*/\ncontract IEtherToken is ITokenHolder, IERC20Token {\n    function deposit() public payable;\n    function withdraw(uint256 _amount) public;\n}\n\n// File: 1/solidity/contracts/BancorChanger.sol\n\npragma solidity ^0.4.11;\n\n\n\n\n\n\n\n\n/*\n    Open issues:\n    - Add miner front-running attack protection. The issue is somewhat mitigated by the use of _minReturn when changing\n    - Possibly add getters for reserve fields so that the client won't need to rely on the order in the struct\n*/\n\n/*\n    Bancor Changer v0.2\n\n    The Bancor version of the token changer, allows changing between a smart token and other ERC20 tokens and between different ERC20 tokens and themselves.\n\n    ERC20 reserve token balance can be virtual, meaning that the calculations are based on the virtual balance instead of relying on\n    the actual reserve balance. This is a security mechanism that prevents the need to keep a very large (and valuable) balance in a single contract.\n\n    The changer is upgradable (just like any SmartTokenController).\n\n    A note on change paths -\n    Change path is a data structure that's used when changing a token to another token in the bancor network\n    when the change cannot necessarily be done by single changer and might require multiple 'hops'.\n    The path defines which changers should be used and what kind of change should be done in each step.\n\n    The path format doesn't include complex structure and instead, it is represented by a single array\n    in which each 'hop' is represented by a 2-tuple - smart token & to token.\n    In addition, the first element is always the source token.\n    The smart token is only used as a pointer to a changer (since changer addresses are more likely to change).\n\n    Format:\n    [source token, smart token, to token, smart token, to token...]\n\n\n    WARNING: It is NOT RECOMMENDED to use the changer with Smart Tokens that have less than 8 decimal digits\n             or with very small numbers because of precision loss\n*/\ncontract BancorChanger is ITokenChanger, SmartTokenController, Managed {\n    uint32 private constant MAX_CRR = 1000000;\n    uint32 private constant MAX_CHANGE_FEE = 1000000;\n\n    struct Reserve {\n        uint256 virtualBalance;         // virtual balance\n        uint32 ratio;                   // constant reserve ratio (CRR), represented in ppm, 1-1000000\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\n        bool isPurchaseEnabled;         // is purchase of the smart token enabled with the reserve, can be set by the owner\n        bool isSet;                     // used to tell if the mapping element is defined\n    }\n\n    string public version = '0.2';\n    string public changerType = 'bancor';\n\n    IBancorFormula public formula;                  // bancor calculation formula contract\n    IERC20Token[] public reserveTokens;             // ERC20 standard token addresses\n    IERC20Token[] public quickBuyPath;              // change path that's used in order to buy the token with ETH\n    mapping (address => Reserve) public reserves;   // reserve token addresses -> reserve data\n    uint32 private totalReserveRatio = 0;           // used to efficiently prevent increasing the total reserve ratio above 100%\n    uint32 public maxChangeFee = 0;                 // maximum change fee for the lifetime of the contract, represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\n    uint32 public changeFee = 0;                    // current change fee, represented in ppm, 0...maxChangeFee\n    bool public changingEnabled = true;             // true if token changing is enabled, false if not\n    bool private withdrawingEther = false;          // used to prevent re-entry while the contract is withdrawing from an ether token\n\n    // triggered when a change between two tokens occurs (TokenChanger event)\n    event Change(address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return,\n                 uint256 _currentPriceN, uint256 _currentPriceD);\n\n    /**\n        @dev constructor\n\n        @param  _token          smart token governed by the changer\n        @param  _formula        address of a bancor formula contract\n        @param  _maxChangeFee   maximum change fee, represented in ppm\n        @param  _reserveToken   optional, initial reserve, allows defining the first reserve at deployment time\n        @param  _reserveRatio   optional, ratio for the initial reserve\n    */\n    function BancorChanger(ISmartToken _token, IBancorFormula _formula, uint32 _maxChangeFee, IERC20Token _reserveToken, uint32 _reserveRatio)\n        SmartTokenController(_token)\n        validAddress(_formula)\n        validMaxChangeFee(_maxChangeFee)\n    {\n        formula = _formula;\n        maxChangeFee = _maxChangeFee;\n\n        if (address(_reserveToken) != 0x0)\n            addReserve(_reserveToken, _reserveRatio, false);\n    }\n\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\n    modifier validReserve(IERC20Token _address) {\n        require(reserves[_address].isSet);\n        _;\n    }\n\n    // validates a token address - verifies that the address belongs to one of the changeable tokens\n    modifier validToken(IERC20Token _address) {\n        require(_address == token || reserves[_address].isSet);\n        _;\n    }\n\n    // validates maximum change fee\n    modifier validMaxChangeFee(uint32 _changeFee) {\n        require(_changeFee >= 0 && _changeFee <= MAX_CHANGE_FEE);\n        _;\n    }\n\n    // validates change fee\n    modifier validChangeFee(uint32 _changeFee) {\n        require(_changeFee >= 0 && _changeFee <= maxChangeFee);\n        _;\n    }\n\n    // validates reserve ratio range\n    modifier validReserveRatio(uint32 _ratio) {\n        require(_ratio > 0 && _ratio <= MAX_CRR);\n        _;\n    }\n\n    // validates a change path - verifies that the number of elements is odd and that maximum number of 'hops' is 10\n    modifier validChangePath(IERC20Token[] _path) {\n        require(_path.length > 2 && _path.length <= (1 + 2 * 10) && _path.length % 2 == 1);\n        _;\n    }\n\n    // allows execution only when changing isn't disabled\n    modifier changingAllowed {\n        assert(changingEnabled);\n        _;\n    }\n\n    /**\n        @dev returns the number of reserve tokens defined\n\n        @return number of reserve tokens\n    */\n    function reserveTokenCount() public constant returns (uint16 count) {\n        return uint16(reserveTokens.length);\n    }\n\n    /**\n        @dev returns the number of changeable tokens supported by the contract\n        note that the number of changeable tokens is the number of reserve token, plus 1 (that represents the smart token)\n\n        @return number of changeable tokens\n    */\n    function changeableTokenCount() public constant returns (uint16 count) {\n        return reserveTokenCount() + 1;\n    }\n\n    /**\n        @dev given a changeable token index, returns the changeable token contract address\n\n        @param _tokenIndex  changeable token index\n\n        @return number of changeable tokens\n    */\n    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress) {\n        if (_tokenIndex == 0)\n            return token;\n        return reserveTokens[_tokenIndex - 1];\n    }\n\n    /*\n        @dev allows the owner to update the formula contract address\n\n        @param _formula    address of a bancor formula contract\n    */\n    function setFormula(IBancorFormula _formula)\n        public\n        ownerOnly\n        validAddress(_formula)\n        notThis(_formula)\n    {\n        formula = _formula;\n    }\n\n    /*\n        @dev allows the manager to update the quick buy path\n\n        @param _path    new quick buy path, see change path format above\n    */\n    function setQuickBuyPath(IERC20Token[] _path)\n        public\n        ownerOnly\n        validChangePath(_path)\n    {\n        quickBuyPath = _path;\n    }\n\n    /*\n        @dev allows the manager to clear the quick buy path\n    */\n    function clearQuickBuyPath() public ownerOnly {\n        quickBuyPath.length = 0;\n    }\n\n    /**\n        @dev returns the length of the quick buy path array\n\n        @return quick buy path length\n    */\n    function getQuickBuyPathLength() public constant returns (uint256 length) {\n        return quickBuyPath.length;\n    }\n\n    /**\n        @dev returns the address of the ether token used by the quick buy functionality\n        note that it should always be the first element in the quick buy path, if one is set\n\n        @return ether token address\n    */\n    function getQuickBuyEtherToken() public constant returns (IEtherToken etherToken) {\n        if (quickBuyPath.length == 0)\n            return IEtherToken(0x0);\n        return IEtherToken(quickBuyPath[0]);\n    }\n\n    /**\n        @dev disables the entire change functionality\n        this is a safety mechanism in case of a emergency\n        can only be called by the manager\n\n        @param _disable true to disable changing, false to re-enable it\n    */\n    function disableChanging(bool _disable) public managerOnly {\n        changingEnabled = !_disable;\n    }\n\n    /**\n        @dev updates the current change fee\n        can only be called by the manager\n\n        @param _changeFee new change fee, represented in ppm\n    */\n    function setChangeFee(uint32 _changeFee)\n        public\n        managerOnly\n        validChangeFee(_changeFee)\n    {\n        changeFee = _changeFee;\n    }\n\n    /*\n        @dev returns the change fee amount for a given return amount\n\n        @return change fee amount\n    */\n    function getChangeFeeAmount(uint256 _amount) public constant returns (uint256 feeAmount) {\n        return safeMul(_amount, changeFee) / MAX_CHANGE_FEE;\n    }\n\n    /**\n        @dev defines a new reserve for the token\n        can only be called by the owner while the changer is inactive\n\n        @param _token                  address of the reserve token\n        @param _ratio                  constant reserve ratio, represented in ppm, 1-1000000\n        @param _enableVirtualBalance   true to enable virtual balance for the reserve, false to disable it\n    */\n    function addReserve(IERC20Token _token, uint32 _ratio, bool _enableVirtualBalance)\n        public\n        ownerOnly\n        inactive\n        validAddress(_token)\n        notThis(_token)\n        validReserveRatio(_ratio)\n    {\n        require(_token != token && !reserves[_token].isSet && totalReserveRatio + _ratio <= MAX_CRR); // validate input\n\n        reserves[_token].virtualBalance = 0;\n        reserves[_token].ratio = _ratio;\n        reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\n        reserves[_token].isPurchaseEnabled = true;\n        reserves[_token].isSet = true;\n        reserveTokens.push(_token);\n        totalReserveRatio += _ratio;\n    }\n\n    /**\n        @dev updates one of the token reserves\n        can only be called by the owner\n\n        @param _reserveToken           address of the reserve token\n        @param _ratio                  constant reserve ratio, represented in ppm, 1-1000000\n        @param _enableVirtualBalance   true to enable virtual balance for the reserve, false to disable it\n        @param _virtualBalance         new reserve's virtual balance\n    */\n    function updateReserve(IERC20Token _reserveToken, uint32 _ratio, bool _enableVirtualBalance, uint256 _virtualBalance)\n        public\n        ownerOnly\n        validReserve(_reserveToken)\n        validReserveRatio(_ratio)\n    {\n        Reserve storage reserve = reserves[_reserveToken];\n        require(totalReserveRatio - reserve.ratio + _ratio <= MAX_CRR); // validate input\n\n        totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;\n        reserve.ratio = _ratio;\n        reserve.isVirtualBalanceEnabled = _enableVirtualBalance;\n        reserve.virtualBalance = _virtualBalance;\n    }\n\n    /**\n        @dev disables purchasing with the given reserve token in case the reserve token got compromised\n        can only be called by the owner\n        note that selling is still enabled regardless of this flag and it cannot be disabled by the owner\n\n        @param _reserveToken    reserve token contract address\n        @param _disable         true to disable the token, false to re-enable it\n    */\n    function disableReservePurchases(IERC20Token _reserveToken, bool _disable)\n        public\n        ownerOnly\n        validReserve(_reserveToken)\n    {\n        reserves[_reserveToken].isPurchaseEnabled = !_disable;\n    }\n\n    /**\n        @dev returns the reserve's virtual balance if one is defined, otherwise returns the actual balance\n\n        @param _reserveToken    reserve token contract address\n\n        @return reserve balance\n    */\n    function getReserveBalance(IERC20Token _reserveToken)\n        public\n        constant\n        validReserve(_reserveToken)\n        returns (uint256 balance)\n    {\n        Reserve storage reserve = reserves[_reserveToken];\n        return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this);\n    }\n\n    /**\n        @dev returns the expected return for changing a specific amount of _fromToken to _toToken\n\n        @param _fromToken  ERC20 token to change from\n        @param _toToken    ERC20 token to change to\n        @param _amount     amount to change, in fromToken\n\n        @return expected change return amount\n    */\n    function getReturn(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount) public constant returns (uint256 amount) {\n        require(_fromToken != _toToken); // validate input\n\n        // change between the token and one of its reserves\n        if (_toToken == token)\n            return getPurchaseReturn(_fromToken, _amount);\n        else if (_fromToken == token)\n            return getSaleReturn(_toToken, _amount);\n\n        // change between 2 reserves\n        uint256 purchaseReturnAmount = getPurchaseReturn(_fromToken, _amount);\n        return getSaleReturn(_toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount));\n    }\n\n    /**\n        @dev returns the expected return for buying the token for a reserve token\n\n        @param _reserveToken   reserve token contract address\n        @param _depositAmount  amount to deposit (in the reserve token)\n\n        @return expected purchase return amount\n    */\n    function getPurchaseReturn(IERC20Token _reserveToken, uint256 _depositAmount)\n        public\n        constant\n        active\n        validReserve(_reserveToken)\n        returns (uint256 amount)\n    {\n        Reserve storage reserve = reserves[_reserveToken];\n        require(reserve.isPurchaseEnabled); // validate input\n\n        uint256 tokenSupply = token.totalSupply();\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\n        amount = formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount);\n\n        // deduct the fee from the return amount\n        uint256 feeAmount = getChangeFeeAmount(amount);\n        return safeSub(amount, feeAmount);\n    }\n\n    /**\n        @dev returns the expected return for selling the token for one of its reserve tokens\n\n        @param _reserveToken   reserve token contract address\n        @param _sellAmount     amount to sell (in the smart token)\n\n        @return expected sale return amount\n    */\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount) public constant returns (uint256 amount) {\n        return getSaleReturn(_reserveToken, _sellAmount, token.totalSupply());\n    }\n\n    /**\n        @dev changes a specific amount of _fromToken to _toToken\n\n        @param _fromToken  ERC20 token to change from\n        @param _toToken    ERC20 token to change to\n        @param _amount     amount to change, in fromToken\n        @param _minReturn  if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return change return amount\n    */\n    function change(IERC20Token _fromToken, IERC20Token _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount) {\n        require(_fromToken != _toToken); // validate input\n\n        // change between the token and one of its reserves\n        if (_toToken == token)\n            return buy(_fromToken, _amount, _minReturn);\n        else if (_fromToken == token)\n            return sell(_toToken, _amount, _minReturn);\n\n        // change between 2 reserves\n        uint256 purchaseAmount = buy(_fromToken, _amount, 1);\n        return sell(_toToken, purchaseAmount, _minReturn);\n    }\n\n    /**\n        @dev buys the token by depositing one of its reserve tokens\n\n        @param _reserveToken   reserve token contract address\n        @param _depositAmount  amount to deposit (in the reserve token)\n        @param _minReturn      if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return buy return amount\n    */\n    function buy(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn)\n        public\n        changingAllowed\n        greaterThanZero(_minReturn)\n        returns (uint256 amount)\n    {\n        amount = getPurchaseReturn(_reserveToken, _depositAmount);\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\n\n        // update virtual balance if relevant\n        Reserve storage reserve = reserves[_reserveToken];\n        if (reserve.isVirtualBalanceEnabled)\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount);\n\n        assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount)); // transfer _depositAmount funds from the caller in the reserve token\n        token.issue(msg.sender, amount); // issue new funds to the caller in the smart token\n\n        // calculate the new price using the simple price formula\n        // price = reserve balance / (supply * CRR)\n        // CRR is represented in ppm, so multiplying by 1000000\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\n        Change(_reserveToken, token, msg.sender, _depositAmount, amount, reserveAmount, tokenAmount);\n        return amount;\n    }\n\n    /**\n        @dev sells the token by withdrawing from one of its reserve tokens\n\n        @param _reserveToken   reserve token contract address\n        @param _sellAmount     amount to sell (in the smart token)\n        @param _minReturn      if the change results in an amount smaller the minimum return - it is cancelled, must be nonzero\n\n        @return sell return amount\n    */\n    function sell(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _minReturn)\n        public\n        changingAllowed\n        greaterThanZero(_minReturn)\n        returns (uint256 amount)\n    {\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\n\n        amount = getSaleReturn(_reserveToken, _sellAmount);\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\n\n        uint256 tokenSupply = token.totalSupply();\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\n        // ensure that the trade will only deplete the reserve if the total supply is depleted as well\n        assert(amount < reserveBalance || (amount == reserveBalance && _sellAmount == tokenSupply));\n\n        // update virtual balance if relevant\n        Reserve storage reserve = reserves[_reserveToken];\n        if (reserve.isVirtualBalanceEnabled)\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, amount);\n\n        token.destroy(msg.sender, _sellAmount); // destroy _sellAmount from the caller's balance in the smart token\n        assert(_reserveToken.transfer(msg.sender, amount)); // transfer funds to the caller in the reserve token\n                                                            // note that it might fail if the actual reserve balance is smaller than the virtual balance\n        // calculate the new price using the simple price formula\n        // price = reserve balance / (supply * CRR)\n        // CRR is represented in ppm, so multiplying by 1000000\n        uint256 reserveAmount = safeMul(getReserveBalance(_reserveToken), MAX_CRR);\n        uint256 tokenAmount = safeMul(token.totalSupply(), reserve.ratio);\n        Change(token, _reserveToken, msg.sender, _sellAmount, amount, tokenAmount, reserveAmount);\n        return amount;\n    }\n\n    /**\n        @dev changes the token to any other token in the bancor network by following a predefined change path\n        note that when changing from an ERC20 token (as opposed to a smart token), allowance must be set beforehand\n\n        @param _path        change path, see change path format above\n        @param _amount      amount to change from (in the initial source token)\n        @param _minReturn   if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return tokens issued in return\n    */\n    function quickChange(IERC20Token[] _path, uint256 _amount, uint256 _minReturn)\n        public\n        validChangePath(_path)\n        returns (uint256 amount)\n    {\n        // we need to transfer the tokens from the caller to the local contract before we\n        // follow the change path, to allow it to execute the change on behalf of the caller\n        IERC20Token fromToken = _path[0];\n        claimTokens(fromToken, msg.sender, _amount);\n\n        ISmartToken smartToken;\n        IERC20Token toToken;\n        BancorChanger changer;\n        uint256 pathLength = _path.length;\n\n        // iterate over the change path\n        for (uint8 i = 1; i < pathLength; i += 2) {\n            smartToken = ISmartToken(_path[i]);\n            toToken = _path[i + 1];\n            changer = BancorChanger(smartToken.owner());\n\n            // if the smart token isn't the source (from token), the changer doesn't have control over it and thus we need to approve the request\n            if (smartToken != fromToken)\n                ensureAllowance(fromToken, changer, _amount);\n\n            // make the change - if it's the last one, also provide the minimum return value\n            _amount = changer.change(fromToken, toToken, _amount, i == pathLength - 2 ? _minReturn : 1);\n            fromToken = toToken;\n        }\n\n        // finished the change, transfer the funds back to the caller\n        // if the last change resulted in ether tokens, withdraw them and send them as ETH to the caller\n        if (changer.getQuickBuyEtherToken() == toToken) {\n            IEtherToken etherToken = IEtherToken(toToken);\n\n            // prevent the withdrawal from executing the quick buy function\n            withdrawingEther = true;\n            etherToken.withdraw(_amount);\n            withdrawingEther = false;\n            msg.sender.transfer(_amount);\n        }\n        else {\n            // not ETH, transfer the tokens to the caller\n            assert(toToken.transfer(msg.sender, _amount));\n        }\n\n        return _amount;\n    }\n\n    /**\n        @dev buys the smart token with ETH if the return amount meets the minimum requested\n        note that this function can eventually be moved into a separate contract\n\n        @param _minReturn  if the change results in an amount smaller than the minimum return - it is cancelled, must be nonzero\n\n        @return tokens issued in return\n    */\n    function quickBuy(uint256 _minReturn) public payable returns (uint256 amount) {\n        // ensure that the quick buy path was set\n        assert(quickBuyPath.length > 0);\n        // we assume that the initial source in the quick buy path is always an ether token\n        IEtherToken etherToken = IEtherToken(quickBuyPath[0]);\n        // deposit ETH in the ether token\n        etherToken.deposit.value(msg.value)();\n        // get the initial changer in the path\n        ISmartToken smartToken = ISmartToken(quickBuyPath[1]);\n        BancorChanger changer = BancorChanger(smartToken.owner());\n        // approve allowance for the changer in the ether token\n        ensureAllowance(etherToken, changer, msg.value);\n        // execute the change\n        uint256 returnAmount = changer.quickChange(quickBuyPath, msg.value, _minReturn);\n        // transfer the tokens to the caller\n        assert(token.transfer(msg.sender, returnAmount));\n        return returnAmount;\n    }\n\n    /**\n        @dev utility, returns the expected return for selling the token for one of its reserve tokens, given a total supply override\n\n        @param _reserveToken   reserve token contract address\n        @param _sellAmount     amount to sell (in the smart token)\n        @param _totalSupply    total token supply, overrides the actual token total supply when calculating the return\n\n        @return sale return amount\n    */\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _totalSupply)\n        private\n        constant\n        active\n        validReserve(_reserveToken)\n        greaterThanZero(_totalSupply)\n        returns (uint256 amount)\n    {\n        Reserve storage reserve = reserves[_reserveToken];\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\n        amount = formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount);\n\n        // deduct the fee from the return amount\n        uint256 feeAmount = getChangeFeeAmount(amount);\n        return safeSub(amount, feeAmount);\n    }\n\n    /**\n        @dev utility, checks whether allowance for the given spender exists and approves one if it doesn't\n\n        @param _token   token to check the allowance in\n        @param _spender approved address\n        @param _value   allowance amount\n    */\n    function ensureAllowance(IERC20Token _token, address _spender, uint256 _value) private {\n        // check if allowance for the given amount already exists\n        if (_token.allowance(this, _spender) >= _value)\n            return;\n\n        // if the allowance is nonzero, must reset it to 0 first\n        if (_token.allowance(this, _spender) != 0)\n            assert(_token.approve(_spender, 0));\n\n        // approve the new allowance\n        assert(_token.approve(_spender, _value));\n    }\n\n    /**\n        @dev utility, transfers tokens from an account to the local contract\n\n        @param _token   token to claim\n        @param _from    account to claim the tokens from\n        @param _amount  amount to claim\n    */\n    function claimTokens(IERC20Token _token, address _from, uint256 _amount) private {\n        // if the token is the smart token, no allowance is required - destroy the tokens from the caller and issue them to the local contract\n        if (_token == token) {\n            token.destroy(_from, _amount); // destroy _amount tokens from the caller's balance in the smart token\n            token.issue(this, _amount); // issue _amount new tokens to the local contract\n            return;\n        }\n\n        // otherwise, we assume we already have allowance\n        assert(_token.transferFrom(_from, this, _amount));\n    }\n\n    /**\n        @dev fallback, buys the smart token with ETH\n        note that the purchase will use the price at the time of the purchase\n    */\n    function() payable {\n        // disable quick buy if the changer is simply withdrawing ether from an ether token\n        if (withdrawingEther)\n            return;\n\n        quickBuy(1);\n    }\n}\n"
    }
  }
}