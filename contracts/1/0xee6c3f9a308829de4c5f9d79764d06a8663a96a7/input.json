{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Teazers.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.6.11;\n\nimport './TeazersBase.sol';\n\ncontract Teazers is TeazersBase {\n    constructor(address _addr) public {\n        owner = msg.sender;\n\n        reentry_status = ENTRY_ENABLED;\n\n        levelCost[1] = 0.003 ether;\n        for (uint8 i = 2; i <= TOP_LEVEL; i++) {\n            levelCost[i] = levelCost[i - 1] * 2;\n        }\n\n        createAccount(_addr, _addr, true);\n\n        for (uint8 j = 1; j <= TOP_LEVEL; j++) {\n            handlePositionX3(_addr, _addr, _addr, j, true);\n            handlePositionX4(_addr, _addr, _addr, j, true);\n        }\n    }\n}\n"
    },
    "browser/TeazersBase.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.6.11;\n\nimport \"./TeazersStorage.sol\";\nimport \"./TeazersEvents.sol\";\n\ncontract TeazersBase is TeazersStorage, TeazersEvents {\n    function registration(address _referrer) external payable blockReEntry() {\n        preRegistration(msg.sender, _referrer);\n    }\n\n    function preRegistration(address _addr, address _referrer) internal {\n        require((levelCost[1]) == msg.value, \"Require .003 eth to register!\");\n\n        createAccount(_addr, _referrer, false);\n\n        users[_referrer].directSales++;\n\n        handlePositionX3(_addr, _referrer, _referrer, 1, false);\n        handlePositionX4(_addr, _referrer, _referrer, 1, false);\n\n        handlePayout(_addr, 0, 1);\n        handlePayout(_addr, 1, 1);\n    }\n\n    function createAccount(\n        address _addr,\n        address _referrer,\n        bool _initial\n    ) internal {\n        require(!users[_addr].exists, \"Already a member!\");\n\n        if (!_initial) {\n            require(users[_referrer].exists, \"referrer dont exist!\");\n        }\n\n        lastId++;\n\n        users[_addr] = Account({\n            id: lastId,\n            referrer: _referrer,\n            exists: true,\n            directSales: 0,\n            activeLevel: new uint8[](2)\n        });\n         \n        idToAddress[lastId] = _addr;\n\n        emit Registration(_addr, lastId, _referrer);\n    }\n\n    function purchaseLevel(uint8 _matrix, uint8 _level)\n        external\n        payable\n        isMember(msg.sender)\n        blockReEntry()\n    {\n        require((_matrix == 1 || _matrix == 2), \"Invalid matrix identifier.\");\n        require((_level > 0 && _level <= TOP_LEVEL), \"Invalid matrix level.\");\n\n        uint8 activeLevel = users[msg.sender].activeLevel[(_matrix - 1)];\n\n        require((activeLevel < _level), \"Already active at level!\");\n        require((activeLevel == (_level - 1)), \"Level upgrade req. in order!\");\n        require((msg.value == levelCost[_level]), \"Wrong amount transferred.\");\n\n        address referrer = users[msg.sender].referrer;\n\n        emit Upgrade(msg.sender, referrer, _matrix, _level);\n\n        if (_matrix == 1) {\n            handlePositionX3(\n                msg.sender,\n                referrer,\n                findActiveReferrer(msg.sender, referrer, 0, _level, true),\n                _level,\n                false\n            );\n        } else {\n            handlePositionX4(\n                msg.sender,\n                referrer,\n                findActiveReferrer(msg.sender, referrer, 1, _level, true),\n                _level,\n                false\n            );\n        }\n\n        handlePayout(msg.sender, (_matrix - 1), _level);\n    }\n\n    function handlePositionX3(\n        address _addr,\n        address _mainReferrer,\n        address _referrer,\n        uint8 _level,\n        bool _initial\n    ) internal {\n        Account storage member = users[_addr];\n\n        member.activeLevel[0] = _level;\n        member.x3Positions[_level] = X3({\n            referrer: _referrer,\n            placement: 0,\n            directSales: 0,\n            cycles: 0,\n            passup: 0,\n            reEntryCheck: 0\n        });\n\n        if (_initial) {\n            return;\n        } else if (_mainReferrer == _referrer) {\n            users[_mainReferrer].x3Positions[_level].directSales++;\n        } else {\n            member.x3Positions[_level].reEntryCheck = 1;\n        }\n\n        referrerPlaceX3(_addr, _referrer, _level, false);\n    }\n\n    function referrerPlaceX3(\n        address _addr,\n        address _referrer,\n        uint8 _level,\n        bool passup\n    ) internal {\n        X3 storage position = users[_referrer].x3Positions[_level];\n\n        emit PlacementX3(\n            _addr,\n            _referrer,\n            _level,\n            (position.placement + 1),\n            passup\n        );\n\n        if (position.placement >= 2) {\n            emit Cycle(_referrer, _addr, 1, _level);\n\n            position.placement = 0;\n            position.cycles++;\n\n            if (_referrer != idToAddress[1]) {\n                position.passup++;\n\n                referrerPlaceX3(_referrer, position.referrer, _level, true);\n            }\n        } else {\n            position.placement++;\n        }\n    }\n\n    function handlePositionX4(\n        address _addr,\n        address _mainReferrer,\n        address _referrer,\n        uint8 _level,\n        bool _initial\n    ) internal {\n        Account storage member = users[_addr];\n\n        member.activeLevel[1] = _level;\n        member.x4Positions[_level] = X4({\n            referrer: _referrer,\n            directSales: 0,\n            cycles: 0,\n            passup: 0,\n            cycle: 0,\n            reEntryCheck: 0,\n            placementSide: 0,\n            placedUnder: _referrer,\n            placementFirstLevel: new address[](0),\n            placementLastLevel: 0\n        });\n\n        if (_initial) {\n            return;\n        } else if (_mainReferrer == _referrer) {\n            users[_mainReferrer].x4Positions[_level].directSales++;\n        } else {\n            member.x4Positions[_level].reEntryCheck = 1;\n        }\n\n        referrerPlaceX4(_addr, _referrer, _level, false);\n    }\n\n    function referrerPlaceX4(\n        address _addr,\n        address _referrer,\n        uint8 _level,\n        bool passup\n    ) internal {\n        X4 storage member = users[_addr].x4Positions[_level];\n        X4 storage position = users[_referrer].x4Positions[_level];\n\n        if (position.placementFirstLevel.length < 2) {\n            if (position.placementFirstLevel.length == 0) {\n                member.placementSide = 1;\n            } else {\n                member.placementSide = 2;\n            }\n\n            member.placedUnder = _referrer;\n            position.placementFirstLevel.push(_addr);\n\n            if (_referrer != idToAddress[1]) {\n                position.passup++;\n            }\n\n            positionPlaceLastLevelX4(\n                _addr,\n                _referrer,\n                position.placedUnder,\n                position.placementSide,\n                _level\n            );\n        } else {\n            if (position.placementLastLevel == 0) {\n                member.placementSide = 1;\n                member.placedUnder = position.placementFirstLevel[0];\n                position.placementLastLevel += 1;\n            } else if ((position.placementLastLevel & 2) == 0) {\n                member.placementSide = 2;\n                member.placedUnder = position.placementFirstLevel[0];\n                position.placementLastLevel += 2;\n            } else if ((position.placementLastLevel & 4) == 0) {\n                member.placementSide = 1;\n                member.placedUnder = position.placementFirstLevel[1];\n                position.placementLastLevel += 4;\n            } else {\n                member.placementSide = 2;\n                member.placedUnder = position.placementFirstLevel[1];\n                position.placementLastLevel += 8;\n            }\n\n            if (member.placedUnder != idToAddress[1]) {\n                users[member.placedUnder].x4Positions[_level]\n                    .placementFirstLevel\n                    .push(_addr);\n            }\n        }\n\n        if ((position.placementLastLevel & 15) == 15) {\n            emit Cycle(_referrer, _addr, 2, _level);\n\n            position.placementFirstLevel = new address[](0);\n            position.placementLastLevel = 0;\n            position.cycles++;\n\n            if (_referrer != idToAddress[1]) {\n                position.cycle++;\n\n                referrerPlaceX4(_referrer, position.referrer, _level, true);\n            }\n        }\n\n        emit PlacementX4(\n            _addr,\n            _referrer,\n            _level,\n            member.placementSide,\n            member.placedUnder,\n            passup\n        );\n    }\n\n    function positionPlaceLastLevelX4(\n        address _addr,\n        address _referrer,\n        address _position,\n        uint8 _placementSide,\n        uint8 _level\n    ) internal {\n        X4 storage position = users[_position].x4Positions[_level];\n\n        if (position.placementSide == 0 && _referrer == idToAddress[1]) {\n            return;\n        }\n\n        if (_placementSide == 1) {\n            if ((position.placementLastLevel & 1) == 0) {\n                position.placementLastLevel += 1;\n            } else {\n                position.placementLastLevel += 2;\n            }\n        } else {\n            if ((position.placementLastLevel & 4) == 0) {\n                position.placementLastLevel += 4;\n            } else {\n                position.placementLastLevel += 8;\n            }\n        }\n\n        if ((position.placementLastLevel & 15) == 15) {\n            emit Cycle(_position, _addr, 2, _level);\n\n            position.placementFirstLevel = new address[](0);\n            position.placementLastLevel = 0;\n            position.cycles++;\n\n            if (_position != idToAddress[1]) {\n                position.cycle++;\n\n                referrerPlaceX4(_position, position.referrer, _level, true);\n            }\n        }\n    }\n\n    function findActiveReferrer(\n        address _addr,\n        address _referrer,\n        uint8 _matrix,\n        uint8 _level,\n        bool _emit\n    ) internal returns (address) {\n        address referrerAddress = _referrer;\n\n        while (true) {\n            if (users[referrerAddress].activeLevel[_matrix] >= _level) {\n                return referrerAddress;\n            }\n            referrerAddress = users[referrerAddress].referrer;\n            if (_emit) {\n                emit FundsPassup(referrerAddress, _addr, (_matrix + 1), _level);\n            }\n        }\n    }\n\n    function handleReEntryX3(address _addr, uint8 _level) internal {\n        X3 storage member = users[_addr].x3Positions[_level];\n        bool reentry = false;\n\n        member.reEntryCheck++;\n\n        if (member.reEntryCheck >= REENTRY_REQ) {\n            address referrer = users[_addr].referrer;\n\n            if (users[referrer].activeLevel[0] >= _level) {\n                member.reEntryCheck = 0;\n                reentry = true;\n            } else {\n                referrer = findActiveReferrer(\n                    _addr,\n                    referrer,\n                    0,\n                    _level,\n                    false\n                );\n\n                if (\n                    member.referrer != referrer &&\n                    users[referrer].activeLevel[0] >= _level\n                ) {\n                    reentry = true;\n                }\n            }\n\n            if (reentry) {\n                member.referrer = referrer;\n\n                emit PlacementReEntry(referrer, _addr, 1, _level);\n            }\n        }\n    }\n\n    function handleReEntryX4(address _addr, uint8 _level) internal {\n        X4 storage member = users[_addr].x4Positions[_level];\n        bool reentry = false;\n\n        member.reEntryCheck++;\n\n        if (member.reEntryCheck >= REENTRY_REQ) {\n            address referrer = users[_addr].referrer;\n\n            if (users[referrer].activeLevel[1] >= _level) {\n                member.reEntryCheck = 0;\n                member.referrer = referrer;\n                reentry = true;\n            } else {\n                address active_referrer =\n                    findActiveReferrer(_addr, referrer, 1, _level, false);\n\n                if (\n                    member.referrer != active_referrer &&\n                    users[active_referrer].activeLevel[1] >= _level\n                ) {\n                    member.referrer = active_referrer;\n                    reentry = true;\n                }\n            }\n\n            if (reentry) {\n                emit PlacementReEntry(member.referrer, _addr, 2, _level);\n            }\n        }\n    }\n\n    function findPayoutReceiver(\n        address _addr,\n        uint8 _matrix,\n        uint8 _level\n    ) internal returns (address) {\n        address from;\n        address receiver;\n\n        if (_matrix == 0) {\n            receiver = users[_addr].x3Positions[_level].referrer;\n\n            while (true) {\n                X3 storage member = users[receiver].x3Positions[_level];\n\n                if (member.passup == 0) {\n                    return receiver;\n                }\n\n                member.passup--;\n                from = receiver;\n                receiver = member.referrer;\n\n                if (_level > 1 && member.reEntryCheck > 0) {\n                    handleReEntryX3(from, _level);\n                }\n            }\n        } else {\n            receiver = users[_addr].x4Positions[_level].referrer;\n\n            while (true) {\n                X4 storage member = users[receiver].x4Positions[_level];\n\n                if (member.passup == 0 && member.cycle == 0) {\n                    return receiver;\n                }\n\n                if (member.passup > 0) {\n                    member.passup--;\n                    receiver = member.placedUnder;\n                } else {\n                    member.cycle--;\n                    from = receiver;\n                    receiver = member.referrer;\n\n                    if (_level > 1 && member.reEntryCheck > 0) {\n                        handleReEntryX4(from, _level);\n                    }\n                }\n            }\n        }\n    }\n\n    function handlePayout(\n        address _addr,\n        uint8 _matrix,\n        uint8 _level\n    ) internal {\n        address receiver = findPayoutReceiver(_addr, _matrix, _level);\n\n        emit FundsPayout(receiver, _addr, (_matrix + 1), _level);\n\n        uint256 cost = levelCost[_level];\n        \n        bool success = address(uint160(receiver)).send(cost);\n        if (!success) {\n            uint256 balance = address(this).balance;\n            return address(uint160(idToAddress[1])).transfer(balance);\n        }\n        require(success, \"Transfer Failed\");\n    }\n\n    function getAffiliateWallet(uint32 memberId)\n        external\n        view\n        returns (address)\n    {\n        return idToAddress[memberId];\n    }\n\n    function usersX3Matrix(address _addr, uint8 _level)\n        external\n        view\n        returns (\n            uint32,\n            uint16,\n            uint8,\n            uint8,\n            uint8,\n            address\n        )\n    {\n        return (\n            users[_addr].x3Positions[_level].directSales,\n            users[_addr].x3Positions[_level].cycles,\n            users[_addr].x3Positions[_level].passup,\n            users[_addr].x3Positions[_level].reEntryCheck,\n            users[_addr].x3Positions[_level].placement,\n            users[_addr].x3Positions[_level].referrer\n        );\n    }\n\n    function usersX4Matrix(address _addr, uint8 _level)\n        external\n        view\n        returns (\n            uint32,\n            uint16,\n            uint8,\n            uint8,\n            address\n        )\n    {\n        return (\n            users[_addr].x4Positions[_level].directSales,\n            users[_addr].x4Positions[_level].cycles,\n            users[_addr].x4Positions[_level].passup,\n            users[_addr].x4Positions[_level].reEntryCheck,\n            users[_addr].x4Positions[_level].referrer\n        );\n    }\n\n    function usersX4MatrixPlacements(address _addr, uint8 _level)\n        external\n        view\n        returns (\n            uint8,\n            uint8,\n            address,\n            address[] memory\n        )\n    {\n        return (\n            users[_addr].x4Positions[_level].placementLastLevel,\n            users[_addr].x4Positions[_level].placementSide,\n            users[_addr].x4Positions[_level].placedUnder,\n            users[_addr].x4Positions[_level].placementFirstLevel\n        );\n    }\n}\n"
    },
    "browser/TeazersEvents.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.6.11;\n\ncontract TeazersEvents {\n    event Registration(address member, uint256 memberId, address referrer);\n    event Upgrade(address member, address referrer, uint8 matrix, uint8 level);\n    \n    event PlacementX3(\n        address member,\n        address referrer,\n        uint8 level,\n        uint8 placement,\n        bool passup\n    );\n    \n    event PlacementX4(\n        address member,\n        address referrer,\n        uint8 level,\n        uint8 placementSide,\n        address placedUnder,\n        bool passup\n    );\n    \n    event Cycle(\n        address indexed member,\n        address fromPosition,\n        uint8 matrix,\n        uint8 level\n    );\n    event PlacementReEntry(\n        address indexed member,\n        address reEntryFrom,\n        uint8 matrix,\n        uint8 level\n    );\n    event FundsPayout(\n        address indexed member,\n        address payoutFrom,\n        uint8 matrix,\n        uint8 level\n    );\n    event FundsPassup(\n        address indexed member,\n        address passupFrom,\n        uint8 matrix,\n        uint8 level\n    );\n}"
    },
    "browser/TeazersStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.6.11;\n\ncontract TeazersStorage {\n    uint8 public constant TOP_LEVEL = 16;\n    uint32 public lastId;\n    uint256 internal constant ENTRY_ENABLED = 1;\n    uint256 internal constant ENTRY_DISABLED = 2;\n    uint256 public constant REENTRY_REQ = 2;\n    uint256 internal reentry_status;\n    address internal owner;\n    \n    struct Account {\n        uint32 id;\n        uint32 directSales;\n        uint8[] activeLevel;\n        bool exists;\n        address referrer;\n        mapping(uint8 => X3) x3Positions;\n        mapping(uint8 => X4) x4Positions;\n    }\n\n    struct X3 {\n        uint8 passup;\n        uint8 reEntryCheck;\n        uint8 placement;\n        uint16 cycles;\n        uint32 directSales;\n        address referrer;\n    }\n\n    struct X4 {\n        uint8 passup;\n        uint8 cycle;\n        uint8 reEntryCheck;\n        uint8 placementLastLevel;\n        uint8 placementSide;\n        uint16 cycles;\n        uint32 directSales;\n        address referrer;\n        address placedUnder;\n        address[] placementFirstLevel;\n    }\n\n\n    mapping(uint8 => uint256) public levelCost;\n    mapping(address => Account) public users;\n    mapping(uint32 => address) public idToAddress;\n\n    modifier isOwner(address _user) {\n        require(owner == _user, 'Restricted Access!');\n        _;\n    }\n\n    modifier isMember(address _addr) {\n        require(users[_addr].exists, 'Register Account First!');\n        _;\n    }\n\n    modifier blockReEntry() {\n        require(reentry_status != ENTRY_DISABLED, 'Security Block');\n        reentry_status = ENTRY_DISABLED;\n\n        _;\n        reentry_status = ENTRY_ENABLED;\n    }\n}"
    }
  }
}