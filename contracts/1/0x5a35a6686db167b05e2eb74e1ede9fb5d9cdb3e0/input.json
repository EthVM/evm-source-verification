{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Cig.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Author: 0xTycoon\r\n// Repo: github.com/0xTycoon/punksceo\r\n\r\npragma solidity ^0.8.11;\r\n\r\n//import \"./safemath.sol\"; // don't need since v0.8\r\n//import \"./ceo.sol\";\r\n/*\r\n\r\nPUNKS CEO (and \"Cigarette\" token)\r\nWEB: https://punksceo.eth.limo / https://punksceo.eth.link\r\nIPFS: See content hash record for punksceo.eth\r\nToken Address: cigtoken.eth\r\n\r\nThere is NO trade tax or any other fee in the standard ERC20 methods of this token.\r\n\r\nThe \"CEO of CryptoPunks\" game element is optional and implemented for your entertainment.\r\n\r\n### THE RULES OF THE GAME\r\n\r\n1. Anybody can buy the CEO title at any time using Cigarettes. (The CEO of all cryptopunks)\r\n2. When buying the CEO title, you must nominate a punk, set the price and pre-pay the tax.\r\n3. The CEO title can be bought from the existing CEO at any time.\r\n4. To remain a CEO, a daily tax needs to be paid.\r\n5. The tax is 0.1% of the price to buy the CEO title, to be charged per epoch.\r\n6. The CEO can be removed if they fail to pay the tax. A reward of CIGs is paid to the whistleblower.\r\n7. After Removing a CEO: A dutch auction is held, where the price will decrease 10% every half-an-epoch.\r\n8. The price can be changed by the CEO at any time. (Once per block)\r\n9. An epoch is 7200 blocks.\r\n10. All the Cigarettes from the sale are burned.\r\n11. All tax is burned\r\n12. After buying the CEO title, the old CEO will get their unspent tax deposit refunded\r\n\r\n### CEO perk\r\n\r\n13. The CEO can increase or decrease the CIG farming block reward by 20% every 2nd epoch!\r\nHowever, note that the issuance can never be more than 1000 CIG per block, also never under 0.0001 CIG.\r\n14. THE CEO gets to hold a NFT in their wallet. There will only be ever 1 this NFT.\r\nThe purpose of this NFT is so that everyone can see that they are the CEO.\r\nIMPORTANT: This NFT will be revoked once the CEO title changes.\r\nAlso, the NFT cannot be transferred by the owner, the only way to transfer is for someone else to buy the CEO title! (Think of this NFT as similar to a \"title belt\" in boxing.)\r\n\r\nEND\r\n\r\n* states\r\n* 0 = initial\r\n* 1 = CEO reigning\r\n* 2 = Dutch auction\r\n\r\nNotes:\r\nIt was decided that whoever buys the CEO title does not have to hold a punk and can nominate any punk they wish.\r\nThis is because some may hold their punks in cold storage, plus checking ownership costs additional gas.\r\nBesides, CEOs are usually appointed by the board.\r\n\r\nCredits:\r\n- LP Staking based on code from SushiSwap's MasterChef.sol\r\n- ERC20 & SafeMath based on lib from OpenZeppelin\r\n\r\n*/\r\n\r\ncontract Cig {\r\n    //using SafeMath for uint256; // no need since Solidity 0.8\r\n    // ERC20 stuff\r\n    string public constant name = \"Cigarette Token\";\r\n    string public constant symbol = \"CIG\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public totalSupply = 0;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    // UserInfo keeps track of user LP deposits and withdrawals\r\n    struct UserInfo {\r\n        uint256 deposit;    // How many LP tokens the user has deposited.\r\n        uint256 rewardDebt; // keeps track of how much reward was paid out\r\n    }\r\n    mapping(address => UserInfo) public userInfo; // keeps track of UserInfo for each staking address\r\n    address public admin;                         // admin is used for deployment, burned after\r\n    ILiquidityPoolERC20 public lpToken;           // lpToken is the address of LP token contract that's being staked.\r\n    uint256 public lastRewardBlock;               // Last block number that cigarettes distribution occurs.\r\n    uint256 public accCigPerShare;                // Accumulated cigarettes per share, times 1e12. See below.\r\n    uint256 public cigPerBlock;                   // CIGs per-block rewarded and split with LPs\r\n    bytes32 public graffiti;                      // a 32 character graffiti set when buying a CEO\r\n    ICryptoPunk public punks;                     // a reference to the CryptoPunks contract\r\n    event Deposit(address indexed user, uint256 amount);           // when depositing LP tokens to stake, or harvest\r\n    event Withdraw(address indexed user, uint256 amount);          // when withdrawing LP tokens form staking\r\n    event EmergencyWithdraw(address indexed user, uint256 amount); // when withdrawing LP tokens, no rewards claimed\r\n    event RewardUp(uint256 reward, uint256 upAmount);              // when cigPerBlock is increased\r\n    event RewardDown(uint256 reward, uint256 downAmount);          // when cigPerBlock is decreased\r\n    event Claim(address indexed owner, uint indexed punkIndex, uint256 value); // when a punk is claimed\r\n    mapping(uint => bool) public claims;                           // keep track of claimed punks\r\n    modifier onlyAdmin {\r\n        require(\r\n            msg.sender == admin,\r\n            \"Only admin can call this\"\r\n        );\r\n        _;\r\n    }\r\n    uint256 constant MIN_PRICE = 1e12;            // 0.000001 CIG\r\n    uint256 constant CLAIM_AMOUNT = 100000 ether; // claim amount for each punk\r\n    uint256 constant MIN_REWARD = 1e14;           // minimum block reward of 0.0001 CIG (1e14 wei)\r\n    uint256 constant MAX_REWARD = 1000 ether;     // maximum block reward of 1000 CIG\r\n    address public The_CEO;                       // address of CEO\r\n    uint public CEO_punk_index;                   // which punk id the CEO is using\r\n    uint256 public CEO_price = 50000 ether;       // price to buy the CEO title\r\n    uint256 public CEO_state;                     // state has 3 states, described above.\r\n    uint256 public CEO_tax_balance;               // deposit to be used to pay the CEO tax\r\n    uint256 public taxBurnBlock;                  // The last block when the tax was burned\r\n    uint256 public rewardsChangedBlock;           // which block was the last reward increase / decrease\r\n    uint256 private immutable CEO_epoch_blocks;   // secs per day divided by 12 (86400 / 12), assuming 12 sec blocks\r\n    uint256 private immutable CEO_auction_blocks; // 3600 blocks\r\n    event NewCEO(address indexed user, uint indexed punk_id, uint256 new_price, bytes32 graffiti); // when a CEO is bought\r\n    event TaxDeposit(address indexed user,  uint256 amount);                               // when tax is deposited\r\n    event RevenueBurned(address indexed user,  uint256 amount);                            // when tax is burned\r\n    event TaxBurned(address indexed user,  uint256 amount);                                // when tax is burned\r\n    event CEODefaulted(address indexed called_by,  uint256 reward);                        // when CEO defaulted on tax\r\n    event CEOPriceChange(uint256 price);                                                   // when CEO changed price\r\n    modifier onlyCEO {\r\n        require(\r\n            msg.sender == The_CEO,\r\n            \"only CEO can call this\"\r\n        );\r\n        _;\r\n    }\r\n    IRouterV2 private immutable V2ROUTER;    // address of router used to get the price quote\r\n    ICEOERC721 private immutable The_NFT;    // reference to the CEO NFT token\r\n    address private immutable MASTERCHEF_V2; // address pointing to SushiSwap's MasterChefv2 contract\r\n    /**\r\n    * @dev constructor\r\n    * @param _startBlock starting block when rewards start\r\n    * @param _cigPerBlock Number of CIG tokens rewarded per block\r\n    * @param _punks address of the cryptopunks contract\r\n    * @param _CEO_epoch_blocks how many blocks between each epochs\r\n    * @param _CEO_auction_blocks how many blocks between each auction discount\r\n    * @param _CEO_price starting price to become CEO (in CIG)\r\n    * @param _MASTERCHEF_V2 address of the MasterChefv2 contract\r\n    */\r\n    constructor(\r\n        uint256 _startBlock,\r\n        uint256 _cigPerBlock,\r\n        address _punks,\r\n        uint _CEO_epoch_blocks,\r\n        uint _CEO_auction_blocks,\r\n        uint256 _CEO_price,\r\n        address _MASTERCHEF_V2,\r\n        bytes32 _graffiti,\r\n        address _NFT,\r\n        address _V2ROUTER\r\n    ) {\r\n        lastRewardBlock    = _startBlock;\r\n        cigPerBlock        = _cigPerBlock;\r\n        admin              = msg.sender;                 // the admin key will be burned after deployment\r\n        punks              = ICryptoPunk(_punks);\r\n        CEO_epoch_blocks   = _CEO_epoch_blocks;\r\n        CEO_auction_blocks = _CEO_auction_blocks;\r\n        CEO_price          = _CEO_price;\r\n        MASTERCHEF_V2      = _MASTERCHEF_V2;\r\n        graffiti           = _graffiti;\r\n        The_NFT            = ICEOERC721(_NFT);\r\n        V2ROUTER           = IRouterV2(_V2ROUTER);\r\n        // mint the tokens for the airdrop and place them in the CryptoPunks contract.\r\n        mint(_punks, CLAIM_AMOUNT * 10000);\r\n    }\r\n\r\n    /**\r\n    * @dev renounceOwnership burns the admin key, so this contract is unruggable\r\n    */\r\n    function renounceOwnership() external onlyAdmin {\r\n        admin = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev setStartingBlock sets the starting block for LP staking rewards\r\n    * Admin only, used only for initial configuration.\r\n    * @param _startBlock the block to start rewards for\r\n    */\r\n    function setStartingBlock(uint256 _startBlock) external onlyAdmin {\r\n        lastRewardBlock = _startBlock;\r\n    }\r\n\r\n    /**\r\n    * @dev setPool address to an LP pool. Only Admin. (used only in testing/deployment)\r\n    */\r\n    function setPool(ILiquidityPoolERC20 _addr) external onlyAdmin {\r\n        require(address(lpToken) == address(0), \"pool already set\");\r\n        lpToken = _addr;\r\n    }\r\n\r\n    /**\r\n    * @dev setReward sets the reward. Admin only (used only in testing/deployment)\r\n    */\r\n    function setReward(uint256 _value) public onlyAdmin {\r\n        cigPerBlock = _value;\r\n    }\r\n\r\n    /**\r\n    * @dev buyCEO allows anybody to be the CEO\r\n    * @param _max_spend the total CIG that can be spent\r\n    * @param _new_price the new price for the punk (in CIG)\r\n    * @param _tax_amount how much to pay in advance (in CIG)\r\n    * @param _punk_index the id of the punk 0-9999\r\n    * @param _graffiti a little message / ad from the buyer\r\n    */\r\n    function buyCEO(\r\n        uint256 _max_spend,\r\n        uint256 _new_price,\r\n        uint256 _tax_amount,\r\n        uint256 _punk_index,\r\n        bytes32 _graffiti\r\n    ) external  {\r\n        if (CEO_state == 1 && (taxBurnBlock != block.number)) {\r\n            _burnTax();                                                    // _burnTax can change CEO_state to 2\r\n        }\r\n        if (CEO_state == 2) {\r\n            // Auction state. The price goes down 10% every `CEO_auction_blocks` blocks\r\n            CEO_price = _calcDiscount();\r\n        }\r\n        require (CEO_price + _tax_amount <= _max_spend, \"overpaid\");        // prevent CEO over-payment\r\n        require (_new_price >= MIN_PRICE, \"price 2 smol\");                 // price cannot be under 0.000001 CIG\r\n        require (_punk_index <= 9999, \"invalid punk\");                     // validate the punk index\r\n        require (_tax_amount >= _new_price / 1000, \"insufficient tax\" );   // at least %0.1 fee paid for 1 epoch\r\n        transfer(address(this), CEO_price);                                // pay for the CEO title\r\n        burn(address(this), CEO_price);                                    // burn the revenue\r\n        emit RevenueBurned(msg.sender, CEO_price);\r\n        _returnDeposit(The_CEO, CEO_tax_balance);                          // return deposited tax back to old CEO\r\n        transfer(address(this), _tax_amount);                              // deposit tax (reverts if not enough)\r\n        CEO_tax_balance = _tax_amount;                                     // store the tax deposit amount\r\n        _transferNFT(The_CEO, msg.sender);                                 // yank the NFT to the new CEO\r\n        CEO_price = _new_price;                                            // set the new price\r\n        CEO_punk_index = _punk_index;                                      // store the punk id\r\n        The_CEO = msg.sender;                                              // store the CEO's address\r\n        taxBurnBlock = block.number;                                       // store the block number\r\n                                                                           // (tax may not have been burned if the\r\n                                                                           // previous state was 0)\r\n        CEO_state = 1;\r\n        graffiti = _graffiti;\r\n        emit TaxDeposit(msg.sender, _tax_amount);\r\n        emit NewCEO(msg.sender, _punk_index, _new_price, _graffiti);\r\n    }\r\n\r\n    /**\r\n    * @dev _returnDeposit returns the tax deposit back to the CEO\r\n    * @param _to address The address which you want to transfer to\r\n    * remember to update CEO_tax_balance after calling this\r\n    */\r\n    function _returnDeposit(\r\n        address _to,\r\n        uint256 _amount\r\n    )\r\n    internal\r\n    {\r\n        if (_amount == 0) {\r\n            return;\r\n        }\r\n        balanceOf[address(this)] = balanceOf[address(this)] - _amount;\r\n        balanceOf[_to] = balanceOf[_to] + _amount;\r\n        emit Transfer(address(this), _to, _amount);\r\n        //CEO_tax_balance = 0; // can be omitted since value gets overwritten by caller\r\n    }\r\n\r\n    /**\r\n    * @dev transfer the NFT to a new wallet\r\n    */\r\n    function _transferNFT(address _oldCEO, address _newCEO) internal {\r\n        if (_oldCEO != _newCEO) {\r\n            The_NFT.transferFrom(_oldCEO, _newCEO, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev depositTax pre-pays tax for the existing CEO.\r\n    * It may also burn any tax debt the CEO may have.\r\n    * @param _amount amount of tax to pre-pay\r\n    */\r\n    function depositTax(uint256 _amount) external onlyCEO {\r\n        require (CEO_state == 1, \"no CEO\");\r\n        if (_amount > 0) {\r\n            transfer(address(this), _amount);                   // place the tax on deposit\r\n            CEO_tax_balance = CEO_tax_balance + _amount;        // record the balance\r\n            emit TaxDeposit(msg.sender, _amount);\r\n        }\r\n        if (taxBurnBlock != block.number) {\r\n            _burnTax();                                         // settle any tax debt\r\n            taxBurnBlock = block.number;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev burnTax is called to burn tax.\r\n    * It removes the CEO if tax is unpaid.\r\n    * 1. deduct tax, update last update\r\n    * 2. if not enough tax, remove & begin auction\r\n    * 3. reward the caller by minting a reward from the amount indebted\r\n    * A Dutch auction begins where the price decreases 10% every hour.\r\n    */\r\n\r\n    function burnTax() external  {\r\n        if (taxBurnBlock == block.number) return;\r\n        if (CEO_state == 1) {\r\n            _burnTax();\r\n            taxBurnBlock = block.number;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev _burnTax burns any tax debt. Boots the CEO if defaulted, paying a reward to the caller\r\n    */\r\n    function _burnTax() internal {\r\n        // calculate tax per block (tpb)\r\n        uint256 tpb = CEO_price / 1000 / CEO_epoch_blocks;       // 0.1% per epoch\r\n        uint256 debt = (block.number - taxBurnBlock) * tpb;\r\n        if (CEO_tax_balance !=0 && CEO_tax_balance >= debt) {    // Does CEO have enough deposit to pay debt?\r\n            CEO_tax_balance = CEO_tax_balance - debt;            // deduct tax\r\n            burn(address(this), debt);                           // burn the tax\r\n            emit TaxBurned(msg.sender, debt);\r\n        } else {\r\n            // CEO defaulted\r\n            uint256 default_amount = debt - CEO_tax_balance;     // calculate how much defaulted\r\n            burn(address(this), CEO_tax_balance);                // burn the tax\r\n            emit TaxBurned(msg.sender, CEO_tax_balance);\r\n            CEO_state = 2;                                       // initiate a Dutch auction.\r\n            CEO_tax_balance = 0;\r\n            _transferNFT(The_CEO, address(this));                // This contract holds the NFT temporarily\r\n            The_CEO = address(this);                             // This contract is the \"interim CEO\"\r\n            mint(msg.sender, default_amount);                    // reward the caller for reporting tax default\r\n            emit CEODefaulted(msg.sender, default_amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev setPrice changes the price for the CEO title.\r\n     * @param _price the price to be paid. The new price most be larger tan MIN_PRICE and not default on debt\r\n     */\r\n    function setPrice(uint256 _price) external onlyCEO  {\r\n        require(CEO_state == 1, \"No CEO in charge\");\r\n        require (_price >= MIN_PRICE, \"price 2 smol\");\r\n        require (CEO_tax_balance >= _price / 1000, \"price would default\"); // need at least 0.1% for tax\r\n        if (block.number != taxBurnBlock) {\r\n            _burnTax();\r\n            taxBurnBlock = block.number;\r\n        }\r\n        // The state is 1 if the CEO hasn't defaulted on tax\r\n        if (CEO_state == 1) {\r\n            CEO_price = _price; // set the new price\r\n            emit CEOPriceChange(_price);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev rewardUp allows the CEO to increase the block rewards by %1\r\n    * Can only be called by the CEO every 7 epochs\r\n    * @return _amount increased by\r\n    */\r\n    function rewardUp() external onlyCEO returns (uint256)  {\r\n        require(CEO_state == 1, \"No CEO in charge\");\r\n        require(block.number > rewardsChangedBlock + (CEO_epoch_blocks*2), \"wait more blocks\");\r\n        require (cigPerBlock <= MAX_REWARD, \"reward already max\");\r\n        rewardsChangedBlock = block.number;\r\n        uint256 _amount = cigPerBlock / 5;                // %20\r\n        uint256 _new_reward = cigPerBlock + _amount;\r\n        if (_new_reward > MAX_REWARD) {\r\n            _amount = MAX_REWARD - cigPerBlock;\r\n            _new_reward = MAX_REWARD; // cap\r\n        }\r\n        cigPerBlock = _new_reward;\r\n        emit RewardUp(_new_reward, _amount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n    * @dev rewardDown decreases the block rewards by 1%\r\n    * Can only be called by the CEO every 7 epochs\r\n    */\r\n    function rewardDown() external onlyCEO returns (uint256) {\r\n        require(CEO_state == 1, \"No CEO in charge\");\r\n        require(block.number > rewardsChangedBlock + (CEO_epoch_blocks*2), \"wait more blocks\");\r\n        require(cigPerBlock >= MIN_REWARD, \"reward already low\");\r\n        rewardsChangedBlock = block.number;\r\n        uint256 _amount = cigPerBlock / 5;            // %20\r\n        uint256 _new_reward = cigPerBlock - _amount;\r\n        if (_new_reward < MIN_REWARD) {\r\n            _amount = cigPerBlock - MIN_REWARD;\r\n            _new_reward = MIN_REWARD;\r\n        }\r\n        cigPerBlock = _new_reward;\r\n        emit RewardDown(_new_reward, _amount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n    * @dev _calcDiscount calculates the discount for the CEO title based on how many blocks passed\r\n    */\r\n    function _calcDiscount() internal view returns (uint256) {\r\n        unchecked {\r\n            uint256 d = (CEO_price / 10)           // 10% discount\r\n            // multiply by the number of discounts accrued\r\n            * (block.number - taxBurnBlock) / CEO_auction_blocks;\r\n            if (d > CEO_price) {\r\n                // overflow assumed, reset to MIN_PRICE\r\n                return MIN_PRICE;\r\n            }\r\n            uint256 price = CEO_price - d;\r\n            if (price < MIN_PRICE) {\r\n                price = MIN_PRICE;\r\n            }\r\n        return price;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev getStats helps to fetch some stats for the GUI in a single web3 call\r\n    * @param _user the address to return the report for\r\n    * @return uint256[22] the stats\r\n    * @return address of the current CEO\r\n    * @return bytes32 Current graffiti\r\n    */\r\n    function getStats(address _user) external view returns(uint256[] memory, address, bytes32, uint112[] memory) {\r\n        uint[] memory ret = new uint[](22);\r\n        uint112[] memory reserves = new uint112[](2);\r\n        uint256 tpb = (CEO_price / 1000) / (CEO_epoch_blocks); // 0.1% per epoch\r\n        uint256 debt = (block.number - taxBurnBlock) * tpb;\r\n        uint256 price = CEO_price;\r\n        UserInfo memory info = userInfo[_user];\r\n        if (CEO_state == 2) {\r\n            price = _calcDiscount();\r\n        }\r\n        ret[0] = CEO_state;\r\n        ret[1] = CEO_tax_balance;\r\n        ret[2] = taxBurnBlock;                     // the block number last tax burn\r\n        ret[3] = rewardsChangedBlock;              // the block of the last staking rewards change\r\n        ret[4] = price;                            // price of the CEO title\r\n        ret[5] = CEO_punk_index;                   // punk ID of CEO\r\n        ret[6] = cigPerBlock;                      // staking reward per block\r\n        ret[7] = totalSupply;                      // total supply of CIG\r\n        if (address(lpToken) != address(0)) {\r\n            ret[8] = lpToken.balanceOf(address(this)); // Total LP staking\r\n            ret[16] = lpToken.balanceOf(_user);        // not staked by user\r\n            ret[17] = pendingCig(_user);               // pending harvest\r\n            (reserves[0], reserves[1], ) = lpToken.getReserves();        // uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast\r\n            ret[18] = V2ROUTER.getAmountOut(1 ether, uint(reserves[0]), uint(reserves[1])); // CIG price in ETH\r\n            if (isContract(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2))) { // are we on mainnet?\r\n                ILiquidityPoolERC20 ethusd = ILiquidityPoolERC20(address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f));  // sushi DAI-WETH pool\r\n                uint112 r0;\r\n                uint112 r1;\r\n                (r0, r1, ) = ethusd.getReserves();\r\n                // get the price of ETH in USD\r\n                ret[19] =  V2ROUTER.getAmountOut(1 ether, uint(r0), uint(r1));      // ETH price in USD\r\n            }\r\n        }\r\n\r\n        ret[9] = block.number;                     // current block number\r\n        ret[10] = tpb;                             // \"tax per block\" (tpb)\r\n        ret[11] = debt;                            // tax debt accrued\r\n        ret[12] = lastRewardBlock;                 // the block of the last staking rewards payout update\r\n        ret[13] = info.deposit;                    // amount of LP tokens staked by user\r\n        ret[14] = info.rewardDebt;                 // amount of rewards paid out\r\n        ret[15] = balanceOf[_user];                // amount of CIG held by user\r\n        ret[20] = balanceOf[address(0)];           // amount of CIG burned\r\n        ret[21] = balanceOf[address(punks)];       // amount of CIG to be claimed\r\n\r\n        return (ret, The_CEO, graffiti, reserves);\r\n    }\r\n\r\n    /*\r\n    * ************************ Token distribution and farming stuff ****************\r\n    */\r\n\r\n    /**\r\n    * Claim claims the initial CIG airdrop using a punk\r\n    * @param _punkIndex the index of the punk, number between 0-9999\r\n    */\r\n    function claim(uint256 _punkIndex) external returns(bool) {\r\n        require (_punkIndex <= 9999, \"invalid punk\");\r\n        require(claims[_punkIndex] == false, \"punk already claimed\");\r\n        require(msg.sender == punks.punkIndexToAddress(_punkIndex), \"punk 404\");\r\n        claims[_punkIndex] = true;\r\n        balanceOf[address(punks)] = balanceOf[address(punks)] - CLAIM_AMOUNT; // deduct from the punks contract\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] + CLAIM_AMOUNT;         // deposit to the caller\r\n        emit Transfer(address(punks), msg.sender, CLAIM_AMOUNT);\r\n        emit Claim(msg.sender, _punkIndex, CLAIM_AMOUNT);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev update updates the accCigPerShare value and mints new CIG rewards to be distributed to LP stakers\r\n    * Credits go to MasterChef.sol\r\n    * Modified the original by removing poolInfo as there is only a single pool\r\n    * Removed totalAllocPoint and pool.allocPoint\r\n    * pool.lastRewardBlock moved to lastRewardBlock\r\n    * There is no need for getMultiplier (rewards are adjusted by the CEO)\r\n    *\r\n    */\r\n    function update() public {\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = lpToken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        // mint some new cigarette rewards to be distributed\r\n        uint256 cigReward = (block.number - lastRewardBlock) * cigPerBlock;\r\n        mint(address(this), cigReward);\r\n        accCigPerShare = accCigPerShare + (\r\n            cigReward * 1e12 / lpSupply\r\n        );\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev pendingCig displays the amount of cig to be claimed\r\n    * @param _user the address to report\r\n    */\r\n    function pendingCig(address _user) view public returns (uint256) {\r\n        uint256 _acps = accCigPerShare;\r\n        // accumulated cig per share\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 lpSupply = lpToken.balanceOf(address(this));\r\n        if (block.number > lastRewardBlock && lpSupply != 0) {\r\n            uint256 cigReward = (block.number - lastRewardBlock) * cigPerBlock;\r\n            _acps = _acps + (\r\n                cigReward * 1e12 / lpSupply\r\n            );\r\n        }\r\n        return (user.deposit * _acps / 1e12) - user.rewardDebt;\r\n    }\r\n\r\n    /**\r\n    * @dev deposit deposits LP tokens to be staked. It also harvests rewards.\r\n    * @param _amount the amount of LP tokens to deposit. Assumes this contract has been approved for the _amount.\r\n    */\r\n    function deposit(uint256 _amount) public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        update();\r\n        if (user.deposit > 0) {\r\n            uint256 pending =\r\n            (user.deposit * (accCigPerShare) / 1e12) - user.rewardDebt;\r\n            safeSendPayout(msg.sender, pending);\r\n        }\r\n        if (_amount > 0) {\r\n            lpToken.transferFrom(\r\n                address(msg.sender),\r\n                address(this),\r\n                _amount\r\n            );\r\n            user.deposit = user.deposit + _amount;\r\n            emit Deposit(msg.sender, _amount);\r\n        }\r\n        user.rewardDebt = user.deposit * accCigPerShare / 1e12;\r\n    }\r\n\r\n    /**\r\n    * @dev withdraw takes out the LP tokens and pending rewards\r\n    * @param _amount the amount to withdraw\r\n    */\r\n    function withdraw(uint256 _amount) external {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.deposit >= _amount, \"withdraw: not good\");\r\n        update();\r\n        uint256 pending = (user.deposit * accCigPerShare / 1e12) - user.rewardDebt;\r\n        safeSendPayout(msg.sender, pending);\r\n        user.deposit = user.deposit - _amount;\r\n        user.rewardDebt = user.deposit * accCigPerShare / 1e12;\r\n        lpToken.transfer(address(msg.sender), _amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n    /**\r\n    * @dev emergencyWithdraw does a withdraw without caring about rewards. EMERGENCY ONLY.\r\n    */\r\n    function emergencyWithdraw() external {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 amount = user.deposit;\r\n        user.deposit = 0;\r\n        user.rewardDebt = 0;\r\n        lpToken.transfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, amount);\r\n\r\n    }\r\n    /**\r\n    * @dev safeSendPayout, just in case if rounding error causes pool to not have enough CIGs.\r\n    * @param _to recipient address\r\n    * @param _amount the value to send\r\n    */\r\n    function safeSendPayout(address _to, uint256 _amount) internal {\r\n        uint256 cigBal = balanceOf[address(this)];\r\n        if (_amount > cigBal) {\r\n            _amount = cigBal;\r\n        }\r\n        balanceOf[address(this)] = balanceOf[address(this)] - _amount;\r\n        balanceOf[_to] = balanceOf[_to] + _amount;\r\n        emit Transfer(address(this), _to, _amount);\r\n    }\r\n\r\n    /*\r\n    * ************************ ERC20 Token stuff ********************************\r\n    */\r\n\r\n    /**\r\n    * @dev burn some tokens\r\n    * @param _from The address to burn from\r\n    * @param _amount The amount to burn\r\n    */\r\n   function burn(address _from, uint256 _amount) internal {\r\n       balanceOf[_from] = balanceOf[_from] - _amount;\r\n       totalSupply = totalSupply - _amount;\r\n       emit Transfer(_from, address(0), _amount);\r\n   }\r\n\r\n   /**\r\n   * @dev mint new tokens\r\n   * @param _to The address to mint to.\r\n   * @param _amount The amount to be minted.\r\n   */\r\n    function mint(address _to, uint256 _amount) internal {\r\n        require(_to != address(0), \"ERC20: mint to the zero address\");\r\n        totalSupply = totalSupply + _amount;\r\n        balanceOf[_to] = balanceOf[_to] + _amount;\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        // require(_value <= balanceOf[msg.sender], \"value exceeds balance\"); // SafeMath already checks this\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        //require(_value <= balanceOf[_from], \"value exceeds balance\"); // SafeMath already checks this\r\n        require(_value <= allowance[_from][msg.sender], \"not approved\");\r\n        balanceOf[_from] = balanceOf[_from] - _value;\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Approve tokens of mount _value to be spent by _spender\r\n    * @param _spender address The spender\r\n    * @param _value the stipend to spend\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /********************************************************************\r\n    * @dev onSushiReward IRewarder methods to be called by the SushSwap MasterChefV2 contract\r\n    */\r\n\r\n    function onSushiReward (\r\n        uint256 /* pid */,\r\n        address _user,\r\n        address _to,\r\n        uint256 /* sushiAmount*/,\r\n        uint256 _newLpAmount)  external onlyMCV2 {\r\n        UserInfo storage user = userInfo[_user];\r\n        update();\r\n        if (user.deposit > 0) {\r\n            uint256 pending = (user.deposit * accCigPerShare / 1e12) - user.rewardDebt;\r\n            safeSendPayout(_to, pending);\r\n        }\r\n        user.deposit = _newLpAmount;\r\n        user.rewardDebt = user.deposit * accCigPerShare / 1e12;\r\n    }\r\n\r\n    /**\r\n    * pendingTokens returns the number of pending CIG rewards, implementing IRewarder\r\n    * @param user it is the only parameter we look at\r\n    */\r\n    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external view returns (IERC20[] memory, uint256[] memory) {\r\n        IERC20[] memory _rewardTokens = new IERC20[](1);\r\n        _rewardTokens[0] = IERC20(address(this));\r\n        uint256[] memory _rewardAmounts = new uint256[](1);\r\n        _rewardAmounts[0] = pendingCig(user);\r\n        return (_rewardTokens, _rewardAmounts);\r\n    }\r\n    // onlyMCV2 ensures only the MasterChefV2 contract can call this\r\n    modifier onlyMCV2 {\r\n        require(\r\n            msg.sender == MASTERCHEF_V2,\r\n            \"Only MCV2\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * credits https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n* @dev sushi router 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\n*/\r\ninterface IRouterV2 {\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external pure returns(uint256 amountOut);\r\n\r\n}\r\n\r\n\r\n\r\ninterface ICryptoPunk {\r\n    //function balanceOf(address account) external view returns (uint256);\r\n    function punkIndexToAddress(uint256 punkIndex) external returns (address);\r\n    //function punksOfferedForSale(uint256 punkIndex) external returns (bool, uint256, address, uint256, address);\r\n    //function buyPunk(uint punkIndex) external payable;\r\n    //function transferPunk(address to, uint punkIndex) external;\r\n}\r\n\r\ninterface ICEOERC721 {\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n}\r\n\r\n// IRewarder allows the contract to be called by SushSwap MasterChefV2\r\n// example impl https://etherscan.io/address/0x7519c93fc5073e15d89131fd38118d73a72370f8/advanced#code\r\ninterface IRewarder {\r\n    function onSushiReward(uint256 pid, address user, address recipient, uint256 sushiAmount, uint256 newLpAmount) external;\r\n    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external view returns (IERC20[] memory, uint256[] memory);\r\n}\r\n\r\n/*\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 is IRewarder {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * 0xTycoon was here\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n* @dev from UniswapV2Pair.sol\r\n*/\r\ninterface ILiquidityPoolERC20 is IERC20 {\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n}"}}}