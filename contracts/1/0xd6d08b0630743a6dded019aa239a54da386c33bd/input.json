{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/MillonMoney.sol": {
      "content": "/**\n// yyyy-mm-dd\n*\n* Website: https://nguyenphunho.github.io\n* Telegram Channel: https://t.me/BullRunV3\n \n*/\npragma solidity 0.5.7 - 0.6.3;\n\n\ncontract Ownable {\n\n  address public owner;\n  address public manager;\n  address public ownerWallet;\n\n  constructor() public {\n    owner = msg.sender;\n    manager = msg.sender;\n    ownerWallet = 0xa61bBbe65fE0A8dD51cDe8bdD65306700d959984;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"only for owner\");\n    _;\n  }\n\n  modifier onlyOwnerOrManager() {\n     require((msg.sender == owner)||(msg.sender == manager), \"only for owner or manager\");\n      _;\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    owner = newOwner;\n  }\n\n  function setManager(address _manager) public onlyOwnerOrManager {\n      manager = _manager;\n  }\n}\n\ncontract MILLIONMONEYV3 is Ownable {\n\n    event regLevelEvent(address indexed _user, address indexed _referrer, uint _time);\n    event buyLevelEvent(address indexed _user, uint _level, uint _time);\n    event prolongateLevelEvent(address indexed _user, uint _level, uint _time);\n    event getMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time);\n    event lostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time);\n    //------------------------------\n\n    mapping (uint => uint) public LEVEL_PRICE;\n    uint REFERRER_1_LEVEL_LIMIT = 2;\n    uint PERIOD_LENGTH = 36500 days;\n\n\n    struct UserStruct {\n        bool isExist;\n        uint id;\n        uint referrerID;\n        address[] referral;\n        mapping (uint => uint) levelExpired;\n    }\n\n    mapping (address => UserStruct) public users;\n    mapping (uint => address) public userList;\n    uint public currUserID = 0;\n\n\n\n\n    constructor() public {\n\n        LEVEL_PRICE[1] = 3 ether;\n        LEVEL_PRICE[2] = 5 ether;\n        LEVEL_PRICE[3] = 10 ether;\n        LEVEL_PRICE[4] = 40 ether;\n        LEVEL_PRICE[5] = 100 ether;\n        LEVEL_PRICE[6] = 250 ether;\n        LEVEL_PRICE[7] = 500 ether;\n        LEVEL_PRICE[8] = 1000 ether;\n        LEVEL_PRICE[9] = 2000 ether;\n        LEVEL_PRICE[10] = 4000 ether;\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist : true,\n            id : currUserID,\n            referrerID : 0,\n            referral : new address[](0)\n        });\n        users[ownerWallet] = userStruct;\n        userList[currUserID] = ownerWallet;\n\n        users[ownerWallet].levelExpired[1] = 7777777777777;\n        users[ownerWallet].levelExpired[2] = 7777777777777;\n        users[ownerWallet].levelExpired[3] = 7777777777777;\n        users[ownerWallet].levelExpired[4] = 7777777777777;\n        users[ownerWallet].levelExpired[5] = 7777777777777;\n        users[ownerWallet].levelExpired[6] = 7777777777777;\n        users[ownerWallet].levelExpired[7] = 7777777777777;\n        users[ownerWallet].levelExpired[8] = 7777777777777;\n    }\n\n    function () external payable {\n\n        uint level;\n\n        if(msg.value == LEVEL_PRICE[1]){\n            level = 1;\n        }else if(msg.value == LEVEL_PRICE[2]){\n            level = 2;\n        }else if(msg.value == LEVEL_PRICE[3]){\n            level = 3;\n        }else if(msg.value == LEVEL_PRICE[4]){\n            level = 4;\n        }else if(msg.value == LEVEL_PRICE[5]){\n            level = 5;\n        }else if(msg.value == LEVEL_PRICE[6]){\n            level = 6;\n        }else if(msg.value == LEVEL_PRICE[7]){\n            level = 7;\n        }else if(msg.value == LEVEL_PRICE[8]){\n            level = 8;\n        }else {\n            revert('Incorrect Value send');\n        }\n\n        if(users[msg.sender].isExist){\n            buyLevel(level);\n        } else if(level == 1) {\n            uint refId = 0;\n            address referrer = bytesToAddress(msg.data);\n\n            if (users[referrer].isExist){\n                refId = users[referrer].id;\n            } else {\n                revert('Incorrect referrer');\n            }\n\n            regUser(refId);\n        } else {\n            revert(\"Please regUser first level for 3 ETH\");\n        }\n    }\n\n    function regUser(uint _referrerID) public payable {\n        require(!users[msg.sender].isExist, 'User exist');\n\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\n\n        require(msg.value==LEVEL_PRICE[1], 'Incorrect Value');\n\n\n        if(users[userList[_referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT)\n        {\n            _referrerID = users[findFreeReferrer(userList[_referrerID])].id;\n        }\n\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist : true,\n            id : currUserID,\n            referrerID : _referrerID,\n            referral : new address[](0)\n        });\n\n        users[msg.sender] = userStruct;\n        userList[currUserID] = msg.sender;\n\n        users[msg.sender].levelExpired[1] = now + PERIOD_LENGTH;\n        users[msg.sender].levelExpired[2] = 0;\n        users[msg.sender].levelExpired[3] = 0;\n        users[msg.sender].levelExpired[4] = 0;\n        users[msg.sender].levelExpired[5] = 0;\n        users[msg.sender].levelExpired[6] = 0;\n        users[msg.sender].levelExpired[7] = 0;\n        users[msg.sender].levelExpired[8] = 0;\n\n        users[userList[_referrerID]].referral.push(msg.sender);\n\n        payForLevel(1, msg.sender);\n\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\n    }\n\n    function buyLevel(uint _level) public payable {\n        require(users[msg.sender].isExist, 'User not exist');\n\n        require( _level>0 && _level<=8, 'Incorrect level');\n\n        if(_level == 1){\n            require(msg.value==LEVEL_PRICE[1], 'Incorrect Value');\n            users[msg.sender].levelExpired[1] += PERIOD_LENGTH;\n        } else {\n            require(msg.value==LEVEL_PRICE[_level], 'Incorrect Value');\n\n            for(uint l =_level-1; l>0; l-- ){\n                require(users[msg.sender].levelExpired[l] >= now, 'Buy the previous level');\n            }\n\n            if(users[msg.sender].levelExpired[_level] == 0){\n                users[msg.sender].levelExpired[_level] = now + PERIOD_LENGTH;\n            } else {\n                users[msg.sender].levelExpired[_level] += PERIOD_LENGTH;\n            }\n        }\n        payForLevel(_level, msg.sender);\n        emit buyLevelEvent(msg.sender, _level, now);\n    }\n\n    function payForLevel(uint _level, address _user) internal {\n\n        address referer;\n        address referer1;\n        address referer2;\n        address referer3;\n        if(_level == 1 || _level == 5){\n            referer = userList[users[_user].referrerID];\n        } else if(_level == 2 || _level == 6){\n            referer1 = userList[users[_user].referrerID];\n            referer = userList[users[referer1].referrerID];\n        } else if(_level == 3 || _level == 7){\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer = userList[users[referer2].referrerID];\n        } else if(_level == 4 || _level == 8){\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer3 = userList[users[referer2].referrerID];\n            referer = userList[users[referer3].referrerID];\n        }\n\n        if(!users[referer].isExist){\n            referer = userList[1];\n        }\n\n        if(users[referer].levelExpired[_level] >= now ){\n            bool result;\n            result = address(uint160(referer)).send(LEVEL_PRICE[_level]);\n            emit getMoneyForLevelEvent(referer, msg.sender, _level, now);\n        } else {\n            emit lostMoneyForLevelEvent(referer, msg.sender, _level, now);\n            payForLevel(_level,referer);\n        }\n    }\n\n    function findFreeReferrer(address _user) public view returns(address) {\n        if(users[_user].referral.length < REFERRER_1_LEVEL_LIMIT){\n            return _user;\n        }\n\n        address[] memory referrals = new address[](363);\n        referrals[0] = users[_user].referral[0]; \n        referrals[1] = users[_user].referral[1];\n        referrals[2] = users[_user].referral[2];\n\n        address freeReferrer;\n        bool noFreeReferrer = true;\n\n        for(uint i =0; i<363;i++){\n            if(users[referrals[i]].referral.length == REFERRER_1_LEVEL_LIMIT){\n                if(i<120){\n                    referrals[(i+1)*3] = users[referrals[i]].referral[0];\n                    referrals[(i+1)*3+1] = users[referrals[i]].referral[1];\n                    referrals[(i+1)*3+2] = users[referrals[i]].referral[2];\n                }\n            }else{\n                noFreeReferrer = false;\n                freeReferrer = referrals[i];\n                break;\n            }\n        }\n        require(!noFreeReferrer, 'No Free Referrer');\n        return freeReferrer;\n\n    }\n\n    function viewUserReferral(address _user) public view returns(address[] memory) {\n        return users[_user].referral;\n    }\n\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\n        return users[_user].levelExpired[_level];\n    }\n    function bytesToAddress(bytes memory bys) private pure returns (address  addr ) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n}"
    }
  }
}