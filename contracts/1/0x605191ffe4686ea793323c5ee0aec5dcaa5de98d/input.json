{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "COX.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * SPDX-License-Identifier: <SPDX-License>\r\n * @dev Implementation of the {COX} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {COXPresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-COX-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of COX applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {COX-approve}.\r\n */\r\ncontract COX is Initializable {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    uint256 private _transferTaxRate; \r\n    uint256 private _transferRewardRate; \r\n    uint256 private _transferBurnRate; \r\n    uint256 private _transferTaxStakers; \r\n    uint256 private _transferTaxLongHolder; \r\n    uint256 private _transferTaxReferral;\r\n    uint256 private _transferRatioTotal;\r\n\r\n    uint256 private _unstakeTaxRate;\r\n    uint256 private _unstakeRewardRate;\r\n    uint256 private _unstakeBurnRate;\r\n    uint256 private _unstakeTaxStaker;\r\n    uint256 private _unstakeTaxLongHolders;\r\n    uint256 private _unstakeRatioTotal;\r\n\r\n    bool private _enableTax;\r\n    bool private _enableStake;\r\n    bool private _enableStake_Bonus;\r\n\r\n    uint256 private _Burnt_Limit;\r\n    uint256 private _Min_Stake;\r\n    uint256 private _StartStakeBonusDate;\r\n    uint256 private _Entry_Days;\r\n    uint256 private _Stake_Bonus_Interval;\r\n\r\n    uint256 private _Scale;\r\n    address private _bonusPool;\r\n    uint256 private constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n\r\n    address private presale;\r\n    \r\n\r\n    struct Party {\r\n\t\tbool elite;\r\n        bool notNew;\r\n\t\tuint256 balance;\r\n\t\tuint256 staked;\r\n\t\tuint256 referralCount;\r\n        uint256 payoutstake;\r\n        address referral;\r\n        mapping(uint256 => uint256) monthlyStakePool;\r\n        mapping(uint256 => bool) monthlyUnStake;\r\n\t\tmapping(address => uint256) allowance;\r\n\t}\r\n\r\n\tstruct Board {\r\n\t\tuint256 totalSupply;\r\n\t\tuint256 totalStaked;\r\n\t\tuint256 totalStakers;\r\n        uint256 retPerStakeToken;\r\n\t\taddress owner;\r\n        mapping(address => Party) parties;\r\n        mapping(uint256 => uint256) totalMonthlyStakePool;\r\n        mapping(uint256 => uint256) totalMonthlyStakePoolReward;\r\n\t}\r\n\r\n    Board private _board;\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 tokens);\r\n\tevent Eliters(address indexed Party, bool status);\r\n\tevent Stake(address indexed owner, uint256 tokens);\r\n\tevent UnStake(address indexed owner, uint256 tokens);\r\n    event StakeGain(address indexed owner, uint256 tokens);\r\n    event InvestStakeGain(address indexed owner, uint256 tokens);\r\n\tevent Burn(uint256 tokens);\r\n    event ReferralBonus(address indexed account,address indexed referral,uint256 token);\r\n    event NewReferral(address indexed account,address indexed referral);\r\n    event StakePool(address indexed account,uint256 token, uint256 cycle);\r\n\r\n    modifier whenStakeEnabled {\r\n        require(_enableStake, \"Can only be called when Staking is Enabled.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == _board.owner, \"Can only be called by the owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPresaleContract {\r\n        require(msg.sender == address(presale), \"only presale can call this.\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    function initialize(string calldata name,string calldata symbol,uint256 StartStakeBonusDate,uint256 Entry_Days,address bonusPool, uint256 Stake_Bonus_Interval,address _presale) external initializer {\r\n\r\n       _totalSupply = 35e25;\r\n       _name = name;\r\n       _symbol = symbol;\r\n       _decimals = 18;\r\n       _bonusPool = bonusPool;\r\n\r\n       _transferTaxRate = 9; //9%\r\n       _transferBurnRate = 4; // 4%\r\n       _transferRewardRate = 4; // 4%\r\n       _transferTaxStakers = 3; //3/4% \r\n       _transferTaxLongHolder = 2; //2/4%\r\n       _transferTaxReferral = 1; //1%\r\n       _transferRatioTotal = _transferTaxLongHolder.add(_transferTaxStakers);\r\n\r\n       _unstakeTaxRate = 6; //%\r\n       _unstakeRewardRate = 3; // %\r\n       _unstakeBurnRate = 3; // %\r\n       _unstakeTaxStaker = 3; // 3 ratio\r\n       _unstakeTaxLongHolders = 2; //2 ratio\r\n       _unstakeRatioTotal = _unstakeTaxLongHolders.add(_unstakeTaxStaker);\r\n       \r\n       _Burnt_Limit=1e26;\r\n       _Scale = 2**64;\r\n       _Min_Stake= 1e18;\r\n\r\n       _Entry_Days = Entry_Days;\r\n       _Stake_Bonus_Interval = Stake_Bonus_Interval;\r\n       _StartStakeBonusDate = StartStakeBonusDate;\r\n\r\n       _enableTax = true;\r\n       _enableStake = true;\r\n       _enableStake_Bonus = true;\r\n\r\n       presale = _presale;\r\n       \r\n        _board.owner = msg.sender;\r\n\t\t_board.totalSupply = _totalSupply;\r\n\t\t_board.parties[msg.sender].balance = _totalSupply;\r\n        _board.retPerStakeToken = 0;\r\n\t\temit Transfer(address(0x0), msg.sender, _totalSupply);\r\n\t\teliters(msg.sender, 1);\r\n\t\teliters(_presale, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {COX} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {ICOX-balanceOf} and {ICOX-transfer}.\r\n     */\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ICOX-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _board.totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ICOX-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _board.parties[account].balance;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ICOX-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external virtual returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ICOX-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) external view virtual returns (uint256) {\r\n        return _board.parties[owner].allowance[spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {ICOX-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ICOX-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {COX};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _board.parties[sender].allowance[msg.sender].sub(amount, \"COX: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {ICOX-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, _board.parties[msg.sender].allowance[spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {ICOX-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, _board.parties[msg.sender].allowance[spender].sub(subtractedValue, \"COX: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"COX: transfer from the zero address\");\r\n        require(recipient != address(0), \"COX: transfer to the zero address\");\r\n        require(balanceOf(sender) >= amount,\"Insufficient fund\");\r\n\r\n        _board.parties[sender].balance = _board.parties[sender].balance.sub(amount, \"COX: transfer amount exceeds balance\");\r\n\r\n        uint256 tax = amount.mul(_transferTaxRate).div(100);\r\n\r\n        if(_board.totalSupply < _Burnt_Limit || _board.parties[sender].elite || !_enableTax){\r\n            tax = 0;\r\n        }\r\n        uint256 _transferred = amount.sub(tax);\r\n\r\n        _board.parties[recipient].balance = _board.parties[recipient].balance.add(_transferred);\r\n        \r\n        emit Transfer(sender,recipient,_transferred);\r\n\r\n        if(tax > 0) {\r\n            //distribute\r\n            uint256 toDistribute = amount.mul(_transferRewardRate).div(100);\r\n            tax = tax.sub(toDistribute);\r\n            // to stakers\r\n            uint256 toDistributeForStakers = 0;\r\n            if(_enableStake_Bonus){\r\n                toDistributeForStakers = toDistribute.mul(_transferTaxStakers).div(_transferRatioTotal);\r\n            }else{\r\n                toDistributeForStakers = toDistribute;\r\n            }\r\n           \r\n            if(_board.totalStaked > 0 && _enableStake){\r\n               _board.retPerStakeToken = _board.retPerStakeToken.add(toDistributeForStakers.mul(_Scale).div(_board.totalStaked));\r\n            }else{\r\n                _board.parties[_bonusPool].balance = _board.parties[_bonusPool].balance.add(toDistributeForStakers);\r\n            }\r\n            \r\n            // distribute to stake pool provider\r\n            uint currentCycle = getCurrentCycle();\r\n            uint256 toDistributeForStakePoolProvider = toDistribute.mul(_transferTaxLongHolder).div(_transferRatioTotal);\r\n            if (currentCycle > 0 && _enableStake_Bonus) {\r\n                _board.totalMonthlyStakePoolReward[currentCycle] = _board.totalMonthlyStakePoolReward[currentCycle].add(toDistributeForStakePoolProvider.mul(_Scale));\r\n            } else if (_enableStake_Bonus && currentCycle <= 0 ){\r\n                _board.parties[_bonusPool].balance = _board.parties[_bonusPool].balance.add(toDistributeForStakePoolProvider);\r\n            }\r\n\r\n            // distribute to referral\r\n            uint256 toReferral = amount.mul(_transferTaxReferral).div(100);\r\n            if(_board.parties[recipient].referral != address(0x0)){\r\n               _board.parties[_board.parties[recipient].referral].balance = _board.parties[_board.parties[recipient].referral].balance.add(toReferral);\r\n               emit ReferralBonus(msg.sender,_board.parties[recipient].referral,toReferral);\r\n            }else{\r\n                _board.parties[_bonusPool].balance = _board.parties[_bonusPool].balance.add(toReferral);\r\n            }\r\n            tax = tax.sub(toReferral);\r\n\r\n            _board.totalSupply = _board.totalSupply.sub(tax);\r\n            emit Transfer(sender, address(0x0), tax);\r\n\t\t\temit Burn(tax);\r\n        }\r\n\r\n        \r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"COX: burn from the zero address\");\r\n\r\n\r\n        _board.parties[account].balance = _board.parties[account].balance.sub(amount, \"COX: burn amount exceeds balance\");\r\n        _board.totalSupply = _board.totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external virtual{\r\n        require(amount <= _board.parties[msg.sender].balance,\"Insufficient fund\");\r\n\r\n        _burn(msg.sender,amount);\r\n\r\n        emit Burn(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"COX: approve from the zero address\");\r\n        require(spender != address(0), \"COX: approve to the zero address\");\r\n\r\n        _board.parties[owner].allowance[spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function changeAdmin(address _to) external virtual onlyOwner {\r\n        \r\n        _transfer(msg.sender,_to,_board.parties[msg.sender].balance);\r\n        eliters(_to,1);\r\n        \r\n        _board.owner = _to;\r\n        \r\n    }\r\n\r\n    function eliters(address party, uint _status) public onlyOwner {\r\n        require(party != address(0x0),\"party cannot be 0x0\");\r\n        if(_status == 1){\r\n          _board.parties[party].elite = true;\r\n        }else{\r\n            _board.parties[party].elite = false;\r\n        }\r\n\t\t\r\n\t\temit Eliters(party, _board.parties[party].elite);\r\n\t}\r\n\r\n    function isE(address account) public view returns (bool) {\r\n       return  _board.parties[account].elite;\r\n    }\r\n\r\n    function cycleUnstakeStatusOf(address account,uint cycle) external view returns (bool) {\r\n       return  _board.parties[account].monthlyUnStake[cycle];\r\n    }\r\n\r\n    function referralOf(address account) public view returns (address) {\r\n       return  _board.parties[account].referral;\r\n    }\r\n\r\n    function referralCountOf(address account) public view returns (uint) {\r\n       return  _board.parties[account].referralCount;\r\n    }    \r\n\r\n    function stakeOf(address account) public view returns (uint256) {\r\n        return _board.parties[account].staked;\r\n    }\r\n\r\n    function totalStaked() public view returns (uint256) {\r\n        return _board.totalStaked;\r\n    }\r\n\r\n    function totalStakers() public view returns (uint256) {\r\n        return _board.totalStakers;\r\n    }\r\n\r\n    function _stake(uint256 amount) internal {\r\n        require(balanceOf(msg.sender) >= amount,\"your balance must be greater or equal to the stake amount\");\r\n        require(amount >= _Min_Stake,\"your stake is below minimum\");\r\n        \r\n        if(_board.parties[msg.sender].staked == 0){\r\n            _board.totalStakers = _board.totalStakers.add(1); \r\n        }\r\n\r\n        uint256 stakeGain = redeemStakeGain();\r\n        amount = amount.add(stakeGain);\r\n\r\n        _board.totalStaked = _board.totalStaked.add(amount);\r\n        _board.parties[msg.sender].balance = _board.parties[msg.sender].balance.sub(amount);\r\n        _board.parties[msg.sender].staked = _board.parties[msg.sender].staked.add(amount);\r\n        _board.parties[msg.sender].payoutstake = _board.retPerStakeToken;\r\n        \r\n\r\n        emit Stake(msg.sender, amount);\r\n    }\r\n\r\n    function restakeProfit() external virtual {\r\n        uint256 amount = redeemStakeGain();\r\n        require(amount >= _Min_Stake,\"stake profit is less than min. stake\");\r\n\r\n        _board.totalStaked = _board.totalStaked.add(amount);\r\n        _board.parties[msg.sender].balance = _board.parties[msg.sender].balance.sub(amount);\r\n        _board.parties[msg.sender].staked = _board.parties[msg.sender].staked.add(amount);\r\n        _board.parties[msg.sender].payoutstake = _board.retPerStakeToken;\r\n        \r\n\r\n        emit Stake(msg.sender, amount);\r\n    }\r\n\r\n    function stakeWithReferral(uint256 amount, address referral) external virtual whenStakeEnabled {\r\n        require(referral != address(0x0),\"you cannot referral address 0x0\");\r\n        require(msg.sender != referral,\"you can not refer yourself\");\r\n\r\n        _stake(amount);\r\n\r\n        _register(referral);       \r\n \r\n    }\r\n    \r\n    function stake(uint256 amount) external virtual whenStakeEnabled {\r\n        \r\n        _stake(amount);\r\n\r\n        _register(address(0x0));\r\n    }\r\n\r\n    function unStake(uint256 amount) external virtual whenStakeEnabled {\r\n        require(_board.parties[msg.sender].staked >= amount,\"you cannot unstake more than your stake balance\");\r\n\r\n        uint256 tax = amount.mul(_unstakeTaxRate).div(100);\r\n        uint256 reward = amount.mul(_unstakeRewardRate).div(100);\r\n\r\n        uint256 toStakers = 0;\r\n        uint256 toStakePoolProviders = 0;\r\n        uint currentCycle = 0;\r\n        if(_enableStake_Bonus){\r\n            toStakers = reward.mul(_unstakeTaxStaker).div(_unstakeRatioTotal);\r\n            toStakePoolProviders = reward.mul(_unstakeTaxLongHolders).div(_unstakeRatioTotal);\r\n\r\n            currentCycle = getCurrentCycle();\r\n            if(currentCycle <= 0 ){\r\n               _board.parties[_bonusPool].balance = _board.parties[_bonusPool].balance.add(toStakePoolProviders);\r\n               toStakePoolProviders = 0;\r\n            }\r\n            \r\n        }else{\r\n            toStakers = reward;\r\n        }\r\n        \r\n        uint256 stakeGainOfAmount = _stakeReturnOfAmount(msg.sender,amount);\r\n        _board.parties[msg.sender].balance = _board.parties[msg.sender].balance.add(stakeGainOfAmount);\r\n        emit StakeGain(msg.sender, stakeGainOfAmount);\r\n        \r\n        \r\n        _board.totalStaked = _board.totalStaked.sub(amount);\r\n        _board.retPerStakeToken = _board.retPerStakeToken.add(toStakers.mul(_Scale).div(_board.totalStaked));\r\n        if(toStakePoolProviders > 0){\r\n          _board.parties[msg.sender].monthlyUnStake[currentCycle] = true;\r\n          _board.totalMonthlyStakePoolReward[currentCycle] = _board.totalMonthlyStakePoolReward[currentCycle].add(toStakePoolProviders.mul(_Scale));\r\n          if(_board.parties[msg.sender].monthlyStakePool[currentCycle] > 0){\r\n              _board.totalMonthlyStakePool[currentCycle] = _board.totalMonthlyStakePool[currentCycle].sub(_board.parties[msg.sender].monthlyStakePool[currentCycle]);\r\n          }\r\n        }\r\n        \r\n        uint256 toReturn = amount.sub(tax);\r\n        _board.parties[msg.sender].balance = _board.parties[msg.sender].balance.add(toReturn);\r\n\r\n        _board.parties[msg.sender].staked = _board.parties[msg.sender].staked.sub(amount);\r\n        if(_board.parties[msg.sender].staked <= 0){\r\n            _board.totalStakers = _board.totalStakers.sub(1);\r\n        }\r\n\r\n        tax = tax.sub(reward);\r\n        _board.totalSupply = _board.totalSupply.sub(tax);\r\n\r\n        emit Burn(tax);\r\n        emit UnStake(msg.sender, amount);\r\n    }\r\n\r\n    function redeemStakeGain() public virtual returns(uint256){\r\n        uint256 ret = stakeReturnOf(msg.sender);\r\n\t\tif(ret == 0){\r\n\t\t    return 0;\r\n\t\t}\r\n\t\t\r\n\t\t_board.parties[msg.sender].payoutstake = _board.retPerStakeToken;\r\n\t\t_board.parties[msg.sender].balance = _board.parties[msg.sender].balance.add(ret);\r\n\t\temit Transfer(address(this), msg.sender, ret);\r\n\t\temit StakeGain(msg.sender, ret);\r\n        return ret;\r\n    }\r\n\r\n    function stakeReturnOf(address sender) public view returns (uint256) {\r\n        uint256 profitReturnRate = _board.retPerStakeToken.sub(_board.parties[sender].payoutstake);\r\n        return uint256(profitReturnRate.mul(_board.parties[sender].staked).div(_Scale));\r\n        \r\n\t}\r\n\t\r\n\tfunction _stakeReturnOfAmount(address sender, uint256 amount) internal view returns (uint256) {\r\n\t    uint256 profitReturnRate = _board.retPerStakeToken.sub(_board.parties[sender].payoutstake);\r\n        return uint256(profitReturnRate.mul(amount).div(_Scale));\r\n\t}\r\n\r\n   function setStakeDetails(uint256 tax,uint256 toBurn,uint256 reward, uint256 toStakers, uint256 toStakePoolProvider) external virtual onlyOwner {\r\n       require(tax == toBurn.add(reward),\"tax is properly distributed\");\r\n       _unstakeTaxRate = tax;\r\n       _unstakeRewardRate = reward;\r\n       _unstakeBurnRate = toBurn;\r\n       _unstakeTaxStaker = toStakers;\r\n       _unstakeTaxLongHolders = toStakePoolProvider;\r\n       _unstakeRatioTotal = toStakers.add(toStakePoolProvider);\r\n   }\r\n\r\n   function CheckStakeDetails() external view onlyOwner returns (uint256 unstakeTaxRate,uint256 unstakeRewardRate,uint256 unstakeBurnRate,uint256 unstakeTaxStaker,uint256 unstakeTaxLiqProvider) {\r\n       return(_unstakeTaxRate,\r\n       _unstakeRewardRate,\r\n       _unstakeBurnRate,\r\n       _unstakeTaxStaker,\r\n       _unstakeTaxLongHolders);  \r\n   }\r\n\r\n\r\n   function setTransferDetails(uint256 transferTaxRate,uint256 transferRewardRate, uint256 transferBurnRate,uint256 transferTaxStakers,uint256 transferTaxLongHolder,uint256 transferTaxReferral) external virtual onlyOwner {\r\n        require(transferTaxRate == transferRewardRate.add(transferBurnRate).add(transferTaxReferral),\"tax is properly distributed\");\r\n        _transferTaxRate = transferTaxRate; \r\n        _transferRewardRate = transferRewardRate; \r\n        _transferBurnRate = transferBurnRate; \r\n        _transferTaxStakers = transferTaxStakers; \r\n        _transferTaxLongHolder = transferTaxLongHolder; \r\n        _transferTaxReferral = transferTaxReferral;\r\n        _transferRatioTotal = transferTaxLongHolder.add(transferTaxStakers);\r\n   }\r\n\r\n   function viewTranferDetails() external view returns(uint256 transferTaxRate,uint256 transferRewardRate,uint256 transferBurnRate,uint256 transferTaxStakers,uint256 transferTaxLongHolder,uint256 transferTaxReferral,uint256 transferRatioTotal) {\r\n       return (_transferTaxRate,_transferRewardRate,_transferBurnRate,_transferTaxStakers,_transferTaxLongHolder,_transferTaxReferral,_transferRatioTotal);\r\n   }\r\n\r\n   function cycleStakePoolOf(address account, uint cycle) public view returns (uint256) {\r\n       return _board.parties[account].monthlyStakePool[cycle];\r\n   }\r\n\r\n   function cycleStakePoolTotal(uint cycle) public view returns (uint256) {\r\n       return _board.totalMonthlyStakePool[cycle];\r\n   }\r\n\r\n   function SubmitStakePool() external virtual {\r\n       uint256 userStaked = _board.parties[msg.sender].staked;\r\n       require(userStaked > 0,\"You're required to stake to participate in the stake pool.\");\r\n    \r\n       uint256 currentCycle = getCurrentCycle();\r\n       require(currentCycle > 0,\"Start pool reward has not started\");\r\n       require( _board.parties[msg.sender].monthlyStakePool[currentCycle] == 0,\"You already submit stake\");\r\n       require(getDayOFCurrentCycle() <= _Entry_Days,\"You can not submit stake pool till next cycle\");\r\n\r\n       _board.parties[msg.sender].monthlyStakePool[currentCycle] = userStaked;\r\n       _board.totalMonthlyStakePool[currentCycle] = _board.totalMonthlyStakePool[currentCycle].add(userStaked);\r\n\r\n       emit StakePool(msg.sender,userStaked,currentCycle);\r\n   }\r\n\r\n   function poolProfitOf(address account,uint256 cycle) public view returns (uint256) {\r\n       if(_board.parties[account].monthlyUnStake[cycle]) return 0;\r\n       uint256 userStaked = cycleStakePoolOf(account,cycle);\r\n       if(userStaked <= 0) return 0;\r\n\r\n       uint256 cycletotalStaked = cycleStakePoolTotal(cycle);\r\n       uint256 share = userStaked.mul(_board.totalMonthlyStakePoolReward[cycle]).div(cycletotalStaked);\r\n       return uint256(share.div(_Scale));\r\n   }\r\n\r\n   function redeemStakePoolProfit(uint cycle) external virtual {\r\n       require(getCurrentCycle() > cycle, \"can not redeem profit for the current cycle\");\r\n       require(!_board.parties[msg.sender].monthlyUnStake[cycle], \"you have unstake record this cycle\");\r\n       uint256 userProfit = poolProfitOf(msg.sender,cycle);\r\n       require(userProfit > 0,\"you do not have any profit to redeem\");\r\n       \r\n       _board.parties[msg.sender].monthlyStakePool[cycle] = 0;\r\n\r\n       _board.parties[msg.sender].balance = _board.parties[msg.sender].balance.add(userProfit);\r\n       emit StakeGain(msg.sender, userProfit);\r\n   }\r\n\r\n   function reStakePoolProfit(uint cycle) external virtual whenStakeEnabled {\r\n       require(getCurrentCycle() > cycle, \"can not redeem profit for the current cycle\");\r\n       require(!_board.parties[msg.sender].monthlyUnStake[cycle], \"you have unstake record this cycle\");\r\n       uint256 userProfit = poolProfitOf(msg.sender,cycle);\r\n       require(userProfit > 0,\"you do not have any profit to redeem\");\r\n       \r\n       _board.parties[msg.sender].monthlyStakePool[cycle] = 0;\r\n\r\n       _board.parties[msg.sender].balance = _board.parties[msg.sender].balance.add(userProfit);\r\n       emit StakeGain(msg.sender, userProfit);\r\n\r\n       _stake(userProfit);\r\n   }\r\n\r\n    function setMinStake(uint256 amount) external virtual onlyOwner returns(uint256) {\r\n         require(amount >= 1e18,\"amount must in ether (18 decimal)\");\r\n         _Min_Stake = amount;\r\n         return _Min_Stake;\r\n    }\r\n\r\n    function minStake() external view returns(uint256) {\r\n        return _Min_Stake;\r\n    }\r\n\r\n    function partyDetails(address sender) external view returns (uint256 balance,uint256 staked,uint256 stakeReturns,bool e,address referral,uint referralCount){\r\n       return (balanceOf(sender),stakeOf(sender),stakeReturnOf(sender),isE(sender),referralOf(sender),referralCountOf(sender));\r\n    }\r\n\r\n    function stakeStats() external view returns (uint256 totalTokenSupply,uint256 stakes, uint256 stakers,uint256 poolReward) {\r\n        return (totalSupply(),totalStaked(),totalStakers(),_board.totalMonthlyStakePoolReward[getCurrentCycle()]);\r\n    }\r\n\r\n    function getCurrentCycle() public view returns (uint256) {\r\n        if (now <= _StartStakeBonusDate) return 0;\r\n        return  _diffDays(_StartStakeBonusDate,now).div(_Stake_Bonus_Interval).add(1);\r\n    }\r\n\r\n    function getDayOFCurrentCycle() public view returns (uint256) {\r\n        if (now <= _StartStakeBonusDate) return 0;\r\n        return _diffDays(_StartStakeBonusDate,now).mod(_Stake_Bonus_Interval);\r\n    }\r\n\r\n\r\n    function _register(address _referral) internal {\r\n        if(_board.parties[msg.sender].notNew) return;\r\n\r\n        _board.parties[msg.sender].notNew = true;\r\n\r\n        if(_referral != address(0x0)){\r\n            _board.parties[msg.sender].referral = _referral;\r\n            _board.parties[_referral].referralCount = _board.parties[_referral].referralCount.add(1);\r\n\r\n            emit NewReferral(msg.sender,_referral);\r\n        }else{\r\n            _board.parties[msg.sender].referral = address(0x0);\r\n        }\r\n    }\r\n\r\n    function registerPresale(address account,address _referral) external virtual onlyPresaleContract {\r\n        if(_board.parties[account].notNew) return;\r\n\r\n        _board.parties[account].notNew = true;\r\n\r\n        if(_referral != address(0x0)){\r\n            _board.parties[account].referral = _referral;\r\n            _board.parties[_referral].referralCount = _board.parties[_referral].referralCount.add(1);\r\n\r\n            emit NewReferral(account,_referral);\r\n        }else{\r\n            _board.parties[account].referral = address(0x0);\r\n        }\r\n    }\r\n\r\n    function dEsad(address bonusPool) external virtual onlyOwner {\r\n        _bonusPool = bonusPool;\r\n    }\r\n\r\n    function _diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256) {\r\n        require(fromTimestamp <= toTimestamp,\"toTimestamp should be greater than fromTimestamp\");\r\n        return uint256((toTimestamp - fromTimestamp) / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function setEnableTax(uint enableTax) external virtual onlyOwner returns (bool) {\r\n        require(enableTax == 1 || enableTax == 0,\"1|0 is required\");\r\n        if(enableTax == 1) _enableTax = true;\r\n        else if(enableTax == 0) _enableTax = false; \r\n        return _enableTax;\r\n    }\r\n\r\n    function viewEnableTax() external view returns (bool) {\r\n        return _enableTax;\r\n    }\r\n\r\n    function setEnableStake(uint enableStake) external virtual onlyOwner returns (bool) {\r\n        require(enableStake == 1 || enableStake == 0,\"1|0 is required\");\r\n        if(enableStake == 1) _enableStake = true;\r\n        else if(enableStake == 0) _enableStake = false; \r\n        return _enableStake;\r\n    }\r\n\r\n    function viewEnableStake() external view returns (bool) {\r\n        return _enableStake;\r\n    }\r\n\r\n\r\n    function setEnableStakeBonus(uint enableStake_Bonus) external virtual onlyOwner returns (bool) {\r\n        require(enableStake_Bonus == 1 || enableStake_Bonus == 0,\"1|0 is required\");\r\n        if(enableStake_Bonus == 1) _enableStake_Bonus = true;\r\n        else if(enableStake_Bonus == 0) _enableStake_Bonus = false; \r\n        return _enableStake_Bonus;\r\n    }\r\n\r\n    function viewEnableStakeBonus() external view returns (bool) {\r\n        return _enableStake_Bonus;\r\n    }\r\n\r\n    function setBurnLimit(uint256 limit) external virtual  onlyOwner returns (uint256) {\r\n        _Burnt_Limit = limit;\r\n        return _Burnt_Limit;\r\n    }\r\n    \r\n    function ViewBurnLimit() external view returns (uint256) {\r\n        return _Burnt_Limit;\r\n    }\r\n\r\n\r\n    function setStartStakeBonusDate(uint256 StartStakeBonusDate) external virtual onlyOwner returns (uint256) {\r\n        _StartStakeBonusDate = StartStakeBonusDate;\r\n        return _StartStakeBonusDate;\r\n    }\r\n    \r\n    function ViewStartStakeBonusDate() external view returns (uint256) {\r\n        return _StartStakeBonusDate;\r\n    }\r\n\r\n    function setEntryDays(uint256 Entry_Days) external virtual onlyOwner returns (uint256) {\r\n        _Entry_Days = Entry_Days;\r\n        return _Entry_Days;\r\n    }\r\n    \r\n    function ViewEntry_Days() external view returns (uint256) {\r\n        return _Entry_Days;\r\n    }\r\n\r\n    function setStake_Bonus_Interval(uint256 Stake_Bonus_Interval) external virtual onlyOwner returns (uint256) {\r\n        _Stake_Bonus_Interval = Stake_Bonus_Interval;\r\n        return _Stake_Bonus_Interval;\r\n    }\r\n    \r\n    function ViewStake_Bonus_Interval() external view returns (uint256) {\r\n        return _Stake_Bonus_Interval;\r\n    }\r\n\r\n    function ViewBoardMan() external view returns (address){\r\n        return _board.owner;\r\n    }\r\n\r\n    function SetPresale(address _presale) external virtual onlyOwner returns (address){\r\n        require(_presale != address(0x0),\"presale address cannot be 0x0\");\r\n        presale = _presale;\r\n        return presale;\r\n    }\r\n    \r\n\r\n}"
    }
  }
}