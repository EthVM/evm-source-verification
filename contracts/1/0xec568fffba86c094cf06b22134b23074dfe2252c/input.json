{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AaveGovernanceV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.5;\r\npragma abicoder v2;\r\n\r\nfunction getChainId() pure returns (uint256) {\r\n  uint256 chainId;\r\n  assembly {\r\n    chainId := chainid()\r\n  }\r\n  return chainId;\r\n}\r\n\r\nfunction isContract(address account) view returns (bool) {\r\n  // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n  // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n  // for accounts without code, i.e. `keccak256('')`\r\n  bytes32 codehash;\r\n  bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n  // solhint-disable-next-line no-inline-assembly\r\n  assembly {\r\n    codehash := extcodehash(account)\r\n  }\r\n  return (codehash != accountHash && codehash != 0x0);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IVotingStrategy {\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IProposalValidator {\r\n  /**\r\n   * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be created\r\n   **/\r\n  function validateCreatorOfProposal(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Called to validate the cancellation of a proposal\r\n   * @param governance Governance Contract\r\n   * @param user Address of the proposal creator\r\n   * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\r\n   * @return boolean, true if can be cancelled\r\n   **/\r\n  function validateProposalCancellation(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns whether a user has enough Proposition Power to make a proposal.\r\n   * @param governance Governance Contract\r\n   * @param user Address of the user to be challenged.\r\n   * @param blockNumber Block Number against which to make the challenge.\r\n   * @return true if user has enough power\r\n   **/\r\n  function isPropositionPowerEnough(\r\n    IAaveGovernanceV2 governance,\r\n    address user,\r\n    uint256 blockNumber\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the minimum Proposition Power needed to create a proposition.\r\n   * @param governance Governance Contract\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return minimum Proposition Power needed\r\n   **/\r\n  function getMinimumPropositionPowerNeeded(IAaveGovernanceV2 governance, uint256 blockNumber)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether a proposal passed or not\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to set\r\n   * @return true if proposal passed\r\n   **/\r\n  function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\r\n   * Here quorum is not to understand as number of votes reached, but number of for-votes reached\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\r\n   * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\r\n   * @param governance Governance Contract\r\n   * @param proposalId Id of the proposal to verify\r\n   * @return true if enough For-Votes\r\n   **/\r\n  function isVoteDifferentialValid(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\r\n   * @param votingSupply Total number of oustanding voting tokens\r\n   * @return voting power needed for a proposal to pass\r\n   **/\r\n  function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get proposition threshold constant value\r\n   * @return the proposition threshold value (100 <=> 1%)\r\n   **/\r\n  function PROPOSITION_THRESHOLD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get voting duration constant value\r\n   * @return the voting duration value in seconds\r\n   **/\r\n  function VOTING_DURATION() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get the vote differential threshold constant value\r\n   * to compare with % of for votes/total supply - % of against votes/total supply\r\n   * @return the vote differential threshold value (100 <=> 1%)\r\n   **/\r\n  function VOTE_DIFFERENTIAL() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Get quorum threshold constant value\r\n   * to compare with % of for votes/total supply\r\n   * @return the quorum threshold value (100 <=> 1%)\r\n   **/\r\n  function MINIMUM_QUORUM() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev precision helper: 100% = 10000\r\n   * @return one hundred percents with our chosen precision\r\n   **/\r\n  function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\r\n}\r\n\r\ninterface IGovernanceStrategy {\r\n  /**\r\n   * @dev Returns the Proposition Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Proposition Power\r\n   * @return Power number\r\n   **/\r\n  function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Proposition Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the total supply of Outstanding Voting Tokens\r\n   * @param blockNumber Blocknumber at which to evaluate\r\n   * @return total supply at blockNumber\r\n   **/\r\n  function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the Vote Power of a user at a specific block number.\r\n   * @param user Address of the user.\r\n   * @param blockNumber Blocknumber at which to fetch Vote Power\r\n   * @return Vote number\r\n   **/\r\n  function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\r\n}\r\n\r\ninterface IExecutorWithTimelock {\r\n  /**\r\n   * @dev emitted when a new pending admin is set\r\n   * @param newPendingAdmin address of the new pending admin\r\n   **/\r\n  event NewPendingAdmin(address newPendingAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new admin is set\r\n   * @param newAdmin address of the new admin\r\n   **/\r\n  event NewAdmin(address newAdmin);\r\n\r\n  /**\r\n   * @dev emitted when a new delay (between queueing and execution) is set\r\n   * @param delay new delay\r\n   **/\r\n  event NewDelay(uint256 delay);\r\n\r\n  /**\r\n   * @dev emitted when a new (trans)action is Queued.\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event QueuedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  event CancelledAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when an action is Cancelled\r\n   * @param actionHash hash of the action\r\n   * @param target address of the targeted contract\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   * @param resultData the actual callData used on the target\r\n   **/\r\n  event ExecutedAction(\r\n    bytes32 actionHash,\r\n    address indexed target,\r\n    uint256 value,\r\n    string signature,\r\n    bytes data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall,\r\n    bytes resultData\r\n  );\r\n\r\n  /**\r\n   * @dev Getter of the current admin address (should be governance)\r\n   * @return The address of the current admin\r\n   **/\r\n  function getAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current pending admin address\r\n   * @return The address of the pending admin\r\n   **/\r\n  function getPendingAdmin() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the delay between queuing and execution\r\n   * @return The delay in seconds\r\n   **/\r\n  function getDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an action (via actionHash) is queued\r\n   * @param actionHash hash of the action to be checked\r\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\r\n   * @return true if underlying action of actionHash is queued\r\n   **/\r\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Checks whether a proposal is over its grace period\r\n   * @param governance Governance contract\r\n   * @param proposalId Id of the proposal against which to test\r\n   * @return true of proposal is over grace period\r\n   **/\r\n  function isProposalOverGracePeriod(IAaveGovernanceV2 governance, uint256 proposalId)\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n  /**\r\n   * @dev Getter of grace period constant\r\n   * @return grace period in seconds\r\n   **/\r\n  function GRACE_PERIOD() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of minimum delay constant\r\n   * @return minimum delay in seconds\r\n   **/\r\n  function MINIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of maximum delay constant\r\n   * @return maximum delay in seconds\r\n   **/\r\n  function MAXIMUM_DELAY() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that queue a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function queueTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function executeTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external payable returns (bytes memory);\r\n\r\n  /**\r\n   * @dev Function, called by Governance, that cancels a transaction, returns action hash\r\n   * @param target smart contract target\r\n   * @param value wei value of the transaction\r\n   * @param signature function signature of the transaction\r\n   * @param data function arguments of the transaction or callData if signature empty\r\n   * @param executionTime time at which to execute the transaction\r\n   * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\r\n   **/\r\n  function cancelTransaction(\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory data,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) external returns (bytes32);\r\n}\r\n\r\ninterface IAaveGovernanceV2 {\r\n  enum ProposalState {Pending, Canceled, Active, Failed, Succeeded, Queued, Expired, Executed}\r\n\r\n  struct Vote {\r\n    bool support;\r\n    uint248 votingPower;\r\n  }\r\n\r\n  struct Proposal {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n    mapping(address => Vote) votes;\r\n  }\r\n\r\n  struct ProposalWithoutVotes {\r\n    uint256 id;\r\n    address creator;\r\n    IExecutorWithTimelock executor;\r\n    address[] targets;\r\n    uint256[] values;\r\n    string[] signatures;\r\n    bytes[] calldatas;\r\n    bool[] withDelegatecalls;\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 executionTime;\r\n    uint256 forVotes;\r\n    uint256 againstVotes;\r\n    bool executed;\r\n    bool canceled;\r\n    address strategy;\r\n    bytes32 ipfsHash;\r\n  }\r\n\r\n  /**\r\n   * @dev emitted when a new proposal is created\r\n   * @param id Id of the proposal\r\n   * @param creator address of the creator\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param startBlock block number when vote starts\r\n   * @param endBlock block number when vote ends\r\n   * @param strategy address of the governanceStrategy contract\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  event ProposalCreated(\r\n    uint256 id,\r\n    address indexed creator,\r\n    IExecutorWithTimelock indexed executor,\r\n    address[] targets,\r\n    uint256[] values,\r\n    string[] signatures,\r\n    bytes[] calldatas,\r\n    bool[] withDelegatecalls,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    address strategy,\r\n    bytes32 ipfsHash\r\n  );\r\n\r\n  /**\r\n   * @dev emitted when a proposal is canceled\r\n   * @param id Id of the proposal\r\n   **/\r\n  event ProposalCanceled(uint256 id);\r\n\r\n  /**\r\n   * @dev emitted when a proposal is queued\r\n   * @param id Id of the proposal\r\n   * @param executionTime time when proposal underlying transactions can be executed\r\n   * @param initiatorQueueing address of the initiator of the queuing transaction\r\n   **/\r\n  event ProposalQueued(uint256 id, uint256 executionTime, address indexed initiatorQueueing);\r\n  /**\r\n   * @dev emitted when a proposal is executed\r\n   * @param id Id of the proposal\r\n   * @param initiatorExecution address of the initiator of the execution transaction\r\n   **/\r\n  event ProposalExecuted(uint256 id, address indexed initiatorExecution);\r\n  /**\r\n   * @dev emitted when a vote is registered\r\n   * @param id Id of the proposal\r\n   * @param voter address of the voter\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param votingPower Power of the voter/vote\r\n   **/\r\n  event VoteEmitted(uint256 id, address indexed voter, bool support, uint256 votingPower);\r\n\r\n  event GovernanceStrategyChanged(address indexed newStrategy, address indexed initiatorChange);\r\n\r\n  event VotingDelayChanged(uint256 newVotingDelay, address indexed initiatorChange);\r\n\r\n  event ExecutorAuthorized(address executor);\r\n\r\n  event ExecutorUnauthorized(address executor);\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Cancels a Proposal,\r\n   * either at anytime by guardian\r\n   * or when proposal is Pending/Active and threshold no longer reached\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external;\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable;\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external;\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external;\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in seconds\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external;\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) external;\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external;\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in seconds\r\n   **/\r\n  function getVotingDelay() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view returns (address);\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) external view returns (ProposalState);\r\n}\r\n\r\n/**\r\n * @title Governance V2 contract\r\n * @dev Main point of interaction with Aave protocol's governance\r\n * - Create a Proposal\r\n * - Cancel a Proposal\r\n * - Queue a Proposal\r\n * - Execute a Proposal\r\n * - Submit Vote to a Proposal\r\n * Proposal States : Pending => Active => Succeeded(/Failed) => Queued => Executed(/Expired)\r\n *                   The transition to \"Canceled\" can appear in multiple states\r\n * @author Aave\r\n **/\r\ncontract AaveGovernanceV2 is Ownable, IAaveGovernanceV2 {\r\n  using SafeMath for uint256;\r\n\r\n  address private _governanceStrategy;\r\n  uint256 private _votingDelay;\r\n\r\n  uint256 private _proposalsCount;\r\n  mapping(uint256 => Proposal) private _proposals;\r\n  mapping(address => bool) private _authorizedExecutors;\r\n\r\n  address private _guardian;\r\n\r\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\r\n    'EIP712Domain(string name,uint256 chainId,address verifyingContract)'\r\n  );\r\n  bytes32 public constant VOTE_EMITTED_TYPEHASH = keccak256('VoteEmitted(uint256 id,bool support)');\r\n  string public constant NAME = 'Aave Governance v2';\r\n\r\n  modifier onlyGuardian() {\r\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address governanceStrategy,\r\n    uint256 votingDelay,\r\n    address guardian,\r\n    address[] memory executors\r\n  ) {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n    _setVotingDelay(votingDelay);\r\n    _guardian = guardian;\r\n\r\n    authorizeExecutors(executors);\r\n  }\r\n\r\n  struct CreateVars {\r\n    uint256 startBlock;\r\n    uint256 endBlock;\r\n    uint256 previousProposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a Proposal (needs to be validated by the Proposal Validator)\r\n   * @param executor The ExecutorWithTimelock contract that will execute the proposal\r\n   * @param targets list of contracts called by proposal's associated transactions\r\n   * @param values list of value in wei for each propoposal's associated transaction\r\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\r\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\r\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\r\n   * @param ipfsHash IPFS hash of the proposal\r\n   **/\r\n  function create(\r\n    IExecutorWithTimelock executor,\r\n    address[] memory targets,\r\n    uint256[] memory values,\r\n    string[] memory signatures,\r\n    bytes[] memory calldatas,\r\n    bool[] memory withDelegatecalls,\r\n    bytes32 ipfsHash\r\n  ) external override returns (uint256) {\r\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\r\n    require(\r\n      targets.length == values.length &&\r\n        targets.length == signatures.length &&\r\n        targets.length == calldatas.length &&\r\n        targets.length == withDelegatecalls.length,\r\n      'INCONSISTENT_PARAMS_LENGTH'\r\n    );\r\n\r\n    require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\r\n\r\n    require(\r\n      IProposalValidator(address(executor)).validateCreatorOfProposal(\r\n        this,\r\n        msg.sender,\r\n        block.number - 1\r\n      ),\r\n      'PROPOSITION_CREATION_INVALID'\r\n    );\r\n\r\n    CreateVars memory vars;\r\n\r\n    vars.startBlock = block.number.add(_votingDelay);\r\n    vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\r\n\r\n    vars.previousProposalsCount = _proposalsCount;\r\n\r\n    Proposal storage newProposal = _proposals[vars.previousProposalsCount];\r\n    newProposal.id = vars.previousProposalsCount;\r\n    newProposal.creator = msg.sender;\r\n    newProposal.executor = executor;\r\n    newProposal.targets = targets;\r\n    newProposal.values = values;\r\n    newProposal.signatures = signatures;\r\n    newProposal.calldatas = calldatas;\r\n    newProposal.withDelegatecalls = withDelegatecalls;\r\n    newProposal.startBlock = vars.startBlock;\r\n    newProposal.endBlock = vars.endBlock;\r\n    newProposal.strategy = _governanceStrategy;\r\n    newProposal.ipfsHash = ipfsHash;\r\n    _proposalsCount++;\r\n\r\n    emit ProposalCreated(\r\n      vars.previousProposalsCount,\r\n      msg.sender,\r\n      executor,\r\n      targets,\r\n      values,\r\n      signatures,\r\n      calldatas,\r\n      withDelegatecalls,\r\n      vars.startBlock,\r\n      vars.endBlock,\r\n      _governanceStrategy,\r\n      ipfsHash\r\n    );\r\n\r\n    return newProposal.id;\r\n  }\r\n\r\n  /**\r\n   * @dev Cancels a Proposal.\r\n   * - Callable by the _guardian with relaxed conditions, or by anybody if the conditions of\r\n   *   cancellation on the executor are fulfilled\r\n   * @param proposalId id of the proposal\r\n   **/\r\n  function cancel(uint256 proposalId) external override {\r\n    ProposalState state = getProposalState(proposalId);\r\n    require(\r\n      state != ProposalState.Executed &&\r\n        state != ProposalState.Canceled &&\r\n        state != ProposalState.Expired,\r\n      'ONLY_BEFORE_EXECUTED'\r\n    );\r\n\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    require(\r\n      msg.sender == _guardian ||\r\n        IProposalValidator(address(proposal.executor)).validateProposalCancellation(\r\n          this,\r\n          proposal.creator,\r\n          block.number - 1\r\n        ),\r\n      'PROPOSITION_CANCELLATION_INVALID'\r\n    );\r\n    proposal.canceled = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.cancelTransaction(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n\r\n    emit ProposalCanceled(proposalId);\r\n  }\r\n\r\n  /**\r\n   * @dev Queue the proposal (If Proposal Succeeded)\r\n   * @param proposalId id of the proposal to queue\r\n   **/\r\n  function queue(uint256 proposalId) external override {\r\n    require(getProposalState(proposalId) == ProposalState.Succeeded, 'INVALID_STATE_FOR_QUEUE');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    uint256 executionTime = block.timestamp.add(proposal.executor.getDelay());\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      _queueOrRevert(\r\n        proposal.executor,\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    proposal.executionTime = executionTime;\r\n\r\n    emit ProposalQueued(proposalId, executionTime, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Execute the proposal (If Proposal Queued)\r\n   * @param proposalId id of the proposal to execute\r\n   **/\r\n  function execute(uint256 proposalId) external payable override {\r\n    require(getProposalState(proposalId) == ProposalState.Queued, 'ONLY_QUEUED_PROPOSALS');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    proposal.executed = true;\r\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\r\n      proposal.executor.executeTransaction{value: proposal.values[i]}(\r\n        proposal.targets[i],\r\n        proposal.values[i],\r\n        proposal.signatures[i],\r\n        proposal.calldatas[i],\r\n        proposal.executionTime,\r\n        proposal.withDelegatecalls[i]\r\n      );\r\n    }\r\n    emit ProposalExecuted(proposalId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Function allowing msg.sender to vote for/against a proposal\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   **/\r\n  function submitVote(uint256 proposalId, bool support) external override {\r\n    return _submitVote(msg.sender, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Function to register the vote of user that has voted offchain via signature\r\n   * @param proposalId id of the proposal\r\n   * @param support boolean, true = vote for, false = vote against\r\n   * @param v v part of the voter signature\r\n   * @param r r part of the voter signature\r\n   * @param s s part of the voter signature\r\n   **/\r\n  function submitVoteBySignature(\r\n    uint256 proposalId,\r\n    bool support,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external override {\r\n    bytes32 digest = keccak256(\r\n      abi.encodePacked(\r\n        '\\x19\\x01',\r\n        keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))),\r\n        keccak256(abi.encode(VOTE_EMITTED_TYPEHASH, proposalId, support))\r\n      )\r\n    );\r\n    address signer = ecrecover(digest, v, r, s);\r\n    require(signer != address(0), 'INVALID_SIGNATURE');\r\n    return _submitVote(signer, proposalId, support);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new GovernanceStrategy\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param governanceStrategy new Address of the GovernanceStrategy contract\r\n   **/\r\n  function setGovernanceStrategy(address governanceStrategy) external override onlyOwner {\r\n    _setGovernanceStrategy(governanceStrategy);\r\n  }\r\n\r\n  /**\r\n   * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\r\n   * Note: owner should be a timelocked executor, so needs to make a proposal\r\n   * @param votingDelay new voting delay in terms of blocks\r\n   **/\r\n  function setVotingDelay(uint256 votingDelay) external override onlyOwner {\r\n    _setVotingDelay(votingDelay);\r\n  }\r\n\r\n  /**\r\n   * @dev Add new addresses to the list of authorized executors\r\n   * @param executors list of new addresses to be authorized executors\r\n   **/\r\n  function authorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _authorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove addresses to the list of authorized executors\r\n   * @param executors list of addresses to be removed as authorized executors\r\n   **/\r\n  function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\r\n    for (uint256 i = 0; i < executors.length; i++) {\r\n      _unauthorizeExecutor(executors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Let the guardian abdicate from its priviledged rights\r\n   **/\r\n  function __abdicate() external override onlyGuardian {\r\n    _guardian = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current GovernanceStrategy address\r\n   * @return The address of the current GovernanceStrategy contracts\r\n   **/\r\n  function getGovernanceStrategy() external view override returns (address) {\r\n    return _governanceStrategy;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\r\n   * Different from the voting duration\r\n   * @return The voting delay in number of blocks\r\n   **/\r\n  function getVotingDelay() external view override returns (uint256) {\r\n    return _votingDelay;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is an authorized executor\r\n   * @param executor address to evaluate as authorized executor\r\n   * @return true if authorized\r\n   **/\r\n  function isExecutorAuthorized(address executor) public view override returns (bool) {\r\n    return _authorizedExecutors[executor];\r\n  }\r\n\r\n  /**\r\n   * @dev Getter the address of the guardian, that can mainly cancel proposals\r\n   * @return The address of the guardian\r\n   **/\r\n  function getGuardian() external view override returns (address) {\r\n    return _guardian;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the proposal count (the current number of proposals ever created)\r\n   * @return the proposal count\r\n   **/\r\n  function getProposalsCount() external view override returns (uint256) {\r\n    return _proposalsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of a proposal by id\r\n   * @param proposalId id of the proposal to get\r\n   * @return the proposal as ProposalWithoutVotes memory object\r\n   **/\r\n  function getProposalById(uint256 proposalId)\r\n    external\r\n    view\r\n    override\r\n    returns (ProposalWithoutVotes memory)\r\n  {\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    ProposalWithoutVotes memory proposalWithoutVotes = ProposalWithoutVotes({\r\n      id: proposal.id,\r\n      creator: proposal.creator,\r\n      executor: proposal.executor,\r\n      targets: proposal.targets,\r\n      values: proposal.values,\r\n      signatures: proposal.signatures,\r\n      calldatas: proposal.calldatas,\r\n      withDelegatecalls: proposal.withDelegatecalls,\r\n      startBlock: proposal.startBlock,\r\n      endBlock: proposal.endBlock,\r\n      executionTime: proposal.executionTime,\r\n      forVotes: proposal.forVotes,\r\n      againstVotes: proposal.againstVotes,\r\n      executed: proposal.executed,\r\n      canceled: proposal.canceled,\r\n      strategy: proposal.strategy,\r\n      ipfsHash: proposal.ipfsHash\r\n    });\r\n\r\n    return proposalWithoutVotes;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter of the Vote of a voter about a proposal\r\n   * Note: Vote is a struct: ({bool support, uint248 votingPower})\r\n   * @param proposalId id of the proposal\r\n   * @param voter address of the voter\r\n   * @return The associated Vote memory object\r\n   **/\r\n  function getVoteOnProposal(uint256 proposalId, address voter)\r\n    external\r\n    view\r\n    override\r\n    returns (Vote memory)\r\n  {\r\n    return _proposals[proposalId].votes[voter];\r\n  }\r\n\r\n  /**\r\n   * @dev Get the current state of a proposal\r\n   * @param proposalId id of the proposal\r\n   * @return The current state if the proposal\r\n   **/\r\n  function getProposalState(uint256 proposalId) public view override returns (ProposalState) {\r\n    require(_proposalsCount >= proposalId, 'INVALID_PROPOSAL_ID');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    if (proposal.canceled) {\r\n      return ProposalState.Canceled;\r\n    } else if (block.number <= proposal.startBlock) {\r\n      return ProposalState.Pending;\r\n    } else if (block.number <= proposal.endBlock) {\r\n      return ProposalState.Active;\r\n    } else if (!IProposalValidator(address(proposal.executor)).isProposalPassed(this, proposalId)) {\r\n      return ProposalState.Failed;\r\n    } else if (proposal.executionTime == 0) {\r\n      return ProposalState.Succeeded;\r\n    } else if (proposal.executed) {\r\n      return ProposalState.Executed;\r\n    } else if (proposal.executor.isProposalOverGracePeriod(this, proposalId)) {\r\n      return ProposalState.Expired;\r\n    } else {\r\n      return ProposalState.Queued;\r\n    }\r\n  }\r\n\r\n  function _queueOrRevert(\r\n    IExecutorWithTimelock executor,\r\n    address target,\r\n    uint256 value,\r\n    string memory signature,\r\n    bytes memory callData,\r\n    uint256 executionTime,\r\n    bool withDelegatecall\r\n  ) internal {\r\n    require(\r\n      !executor.isActionQueued(\r\n        keccak256(abi.encode(target, value, signature, callData, executionTime, withDelegatecall))\r\n      ),\r\n      'DUPLICATED_ACTION'\r\n    );\r\n    executor.queueTransaction(target, value, signature, callData, executionTime, withDelegatecall);\r\n  }\r\n\r\n  function _submitVote(\r\n    address voter,\r\n    uint256 proposalId,\r\n    bool support\r\n  ) internal {\r\n    require(getProposalState(proposalId) == ProposalState.Active, 'VOTING_CLOSED');\r\n    Proposal storage proposal = _proposals[proposalId];\r\n    Vote storage vote = proposal.votes[voter];\r\n\r\n    require(vote.votingPower == 0, 'VOTE_ALREADY_SUBMITTED');\r\n\r\n    uint256 votingPower = IVotingStrategy(proposal.strategy).getVotingPowerAt(\r\n      voter,\r\n      proposal.startBlock\r\n    );\r\n\r\n    if (support) {\r\n      proposal.forVotes = proposal.forVotes.add(votingPower);\r\n    } else {\r\n      proposal.againstVotes = proposal.againstVotes.add(votingPower);\r\n    }\r\n\r\n    vote.support = support;\r\n    vote.votingPower = uint248(votingPower);\r\n\r\n    emit VoteEmitted(proposalId, voter, support, votingPower);\r\n  }\r\n\r\n  function _setGovernanceStrategy(address governanceStrategy) internal {\r\n    _governanceStrategy = governanceStrategy;\r\n\r\n    emit GovernanceStrategyChanged(governanceStrategy, msg.sender);\r\n  }\r\n\r\n  function _setVotingDelay(uint256 votingDelay) internal {\r\n    _votingDelay = votingDelay;\r\n\r\n    emit VotingDelayChanged(votingDelay, msg.sender);\r\n  }\r\n\r\n  function _authorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = true;\r\n    emit ExecutorAuthorized(executor);\r\n  }\r\n\r\n  function _unauthorizeExecutor(address executor) internal {\r\n    _authorizedExecutors[executor] = false;\r\n    emit ExecutorUnauthorized(executor);\r\n  }\r\n}"
    }
  }
}