{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/VotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/ReentrancyGuardUpgradeSafe.sol\";\nimport \"./lib/PrismProxyImplementation.sol\";\nimport \"./lib/VotingPowerStorage.sol\";\nimport \"./lib/SafeERC20.sol\";\n\n/**\n * @title VotingPower\n * @dev Implementation contract for voting power prism proxy\n * Calls should not be made directly to this contract, instead make calls to the VotingPowerPrism proxy contract\n * The exception to this is the `become` function specified in PrismProxyImplementation \n * This function is called once and is used by this contract to accept its role as the implementation for the prism proxy\n */\ncontract VotingPower is PrismProxyImplementation, ReentrancyGuardUpgradeSafe {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice An event that's emitted when a user's staked balance increases\n    event Staked(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\n    /// @notice An event that's emitted when a user's staked balance decreases\n    event Withdrawn(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n\n    /// @notice An event that's emitted when an account's vote balance changes\n    event VotingPowerChanged(address indexed voter, uint256 indexed previousBalance, uint256 indexed newBalance);\n\n    /**\n     * @notice Initialize VotingPower contract\n     * @dev Should be called via VotingPowerPrism before calling anything else\n     * @param _archToken address of ARCH token\n     * @param _vestingContract address of Vesting contract\n     */\n    function initialize(\n        address _archToken,\n        address _vestingContract\n    ) public initializer {\n        __ReentrancyGuard_init_unchained();\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        app.archToken = IArchToken(_archToken);\n        app.vesting = IVesting(_vestingContract);\n    }\n\n    /**\n     * @notice Address of ARCH token\n     * @return Address of ARCH token\n     */\n    function archToken() public view returns (address) {\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        return address(app.archToken);\n    }\n\n    /**\n     * @notice Decimals used for voting power\n     * @return decimals\n     */\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Address of vesting contract\n     * @return Address of vesting contract\n     */\n    function vestingContract() public view returns (address) {\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        return address(app.vesting);\n    }\n\n    /**\n     * @notice Stake ARCH tokens using offchain approvals to unlock voting power\n     * @param amount The amount to stake\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function stakeWithPermit(uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant {\n        require(amount > 0, \"VP::stakeWithPermit: cannot stake 0\");\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        require(app.archToken.balanceOf(msg.sender) >= amount, \"VP::stakeWithPermit: not enough tokens\");\n\n        app.archToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n\n        _stake(msg.sender, address(app.archToken), amount, amount);\n    }\n\n    /**\n     * @notice Stake ARCH tokens to unlock voting power for `msg.sender`\n     * @param amount The amount to stake\n     */\n    function stake(uint256 amount) external nonReentrant {\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        require(amount > 0, \"VP::stake: cannot stake 0\");\n        require(app.archToken.balanceOf(msg.sender) >= amount, \"VP::stake: not enough tokens\");\n        require(app.archToken.allowance(msg.sender, address(this)) >= amount, \"VP::stake: must approve tokens before staking\");\n\n        _stake(msg.sender, address(app.archToken), amount, amount);\n    }\n\n    /**\n     * @notice Count vesting ARCH tokens toward voting power for `account`\n     * @param account The recipient of voting power\n     * @param amount The amount of voting power to add\n     */\n    function addVotingPowerForVestingTokens(address account, uint256 amount) external nonReentrant {\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        require(amount > 0, \"VP::addVPforVT: cannot add 0 voting power\");\n        require(msg.sender == address(app.vesting), \"VP::addVPforVT: only vesting contract\");\n\n        _increaseVotingPower(account, amount);\n    }\n\n    /**\n     * @notice Remove claimed vesting ARCH tokens from voting power for `account`\n     * @param account The account with voting power\n     * @param amount The amount of voting power to remove\n     */\n    function removeVotingPowerForClaimedTokens(address account, uint256 amount) external nonReentrant {\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        require(amount > 0, \"VP::removeVPforVT: cannot remove 0 voting power\");\n        require(msg.sender == address(app.vesting), \"VP::removeVPforVT: only vesting contract\");\n\n        _decreaseVotingPower(account, amount);\n    }\n\n    /**\n     * @notice Withdraw staked ARCH tokens, removing voting power for `msg.sender`\n     * @param amount The amount to withdraw\n     */\n    function withdraw(uint256 amount) external nonReentrant {\n        require(amount > 0, \"VP::withdraw: cannot withdraw 0\");\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        _withdraw(msg.sender, address(app.archToken), amount, amount);\n    }\n\n    /**\n     * @notice Get total amount of ARCH tokens staked in contract by `staker`\n     * @param staker The user with staked ARCH\n     * @return total ARCH amount staked\n     */\n    function getARCHAmountStaked(address staker) public view returns (uint256) {\n        return getARCHStake(staker).amount;\n    }\n\n    /**\n     * @notice Get total amount of tokens staked in contract by `staker`\n     * @param staker The user with staked tokens\n     * @param stakedToken The staked token\n     * @return total amount staked\n     */\n    function getAmountStaked(address staker, address stakedToken) public view returns (uint256) {\n        return getStake(staker, stakedToken).amount;\n    }\n\n    /**\n     * @notice Get staked amount and voting power from ARCH tokens staked in contract by `staker`\n     * @param staker The user with staked ARCH\n     * @return total ARCH staked\n     */\n    function getARCHStake(address staker) public view returns (Stake memory) {\n        AppStorage storage app = VotingPowerStorage.appStorage();\n        return getStake(staker, address(app.archToken));\n    }\n\n    /**\n     * @notice Get total staked amount and voting power from `stakedToken` staked in contract by `staker`\n     * @param staker The user with staked tokens\n     * @param stakedToken The staked token\n     * @return total staked\n     */\n    function getStake(address staker, address stakedToken) public view returns (Stake memory) {\n        StakeStorage storage ss = VotingPowerStorage.stakeStorage();\n        return ss.stakes[staker][stakedToken];\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        CheckpointStorage storage cs = VotingPowerStorage.checkpointStorage();\n        uint32 nCheckpoints = cs.numCheckpoints[account];\n        return nCheckpoints > 0 ? cs.checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function balanceOfAt(address account, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, \"VP::balanceOfAt: not yet determined\");\n        \n        CheckpointStorage storage cs = VotingPowerStorage.checkpointStorage();\n        uint32 nCheckpoints = cs.numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (cs.checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return cs.checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (cs.checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = cs.checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return cs.checkpoints[account][lower].votes;\n    }\n\n    /**\n     * @notice Internal implementation of stake\n     * @param voter The user that is staking tokens\n     * @param token The token to stake\n     * @param tokenAmount The amount of token to stake\n     * @param votingPower The amount of voting power stake translates into\n     */\n    function _stake(address voter, address token, uint256 tokenAmount, uint256 votingPower) internal {\n        IERC20(token).safeTransferFrom(voter, address(this), tokenAmount);\n\n        StakeStorage storage ss = VotingPowerStorage.stakeStorage();\n        ss.stakes[voter][token].amount = ss.stakes[voter][token].amount.add(tokenAmount);\n        ss.stakes[voter][token].votingPower = ss.stakes[voter][token].votingPower.add(votingPower);\n\n        emit Staked(voter, token, tokenAmount, votingPower);\n\n        _increaseVotingPower(voter, votingPower);\n    }\n\n    /**\n     * @notice Internal implementation of withdraw\n     * @param voter The user with tokens staked\n     * @param token The token that is staked\n     * @param tokenAmount The amount of token to withdraw\n     * @param votingPower The amount of voting power stake translates into\n     */\n    function _withdraw(address voter, address token, uint256 tokenAmount, uint256 votingPower) internal {\n        StakeStorage storage ss = VotingPowerStorage.stakeStorage();\n        require(ss.stakes[voter][token].amount >= tokenAmount, \"VP::_withdraw: not enough tokens staked\");\n        require(ss.stakes[voter][token].votingPower >= votingPower, \"VP::_withdraw: not enough voting power\");\n        ss.stakes[voter][token].amount = ss.stakes[voter][token].amount.sub(tokenAmount);\n        ss.stakes[voter][token].votingPower = ss.stakes[voter][token].votingPower.sub(votingPower);\n        \n        IERC20(token).safeTransfer(voter, tokenAmount);\n\n        emit Withdrawn(voter, token, tokenAmount, votingPower);\n        \n        _decreaseVotingPower(voter, votingPower);\n    }\n\n    /**\n     * @notice Increase voting power of voter\n     * @param voter The voter whose voting power is increasing \n     * @param amount The amount of voting power to increase by\n     */\n    function _increaseVotingPower(address voter, uint256 amount) internal {\n        CheckpointStorage storage cs = VotingPowerStorage.checkpointStorage();\n        uint32 checkpointNum = cs.numCheckpoints[voter];\n        uint256 votingPowerOld = checkpointNum > 0 ? cs.checkpoints[voter][checkpointNum - 1].votes : 0;\n        uint256 votingPowerNew = votingPowerOld.add(amount);\n        _writeCheckpoint(voter, checkpointNum, votingPowerOld, votingPowerNew);\n    }\n\n    /**\n     * @notice Decrease voting power of voter\n     * @param voter The voter whose voting power is decreasing \n     * @param amount The amount of voting power to decrease by\n     */\n    function _decreaseVotingPower(address voter, uint256 amount) internal {\n        CheckpointStorage storage cs = VotingPowerStorage.checkpointStorage();\n        uint32 checkpointNum = cs.numCheckpoints[voter];\n        uint256 votingPowerOld = checkpointNum > 0 ? cs.checkpoints[voter][checkpointNum - 1].votes : 0;\n        uint256 votingPowerNew = votingPowerOld.sub(amount);\n        _writeCheckpoint(voter, checkpointNum, votingPowerOld, votingPowerNew);\n    }\n\n    /**\n     * @notice Create checkpoint of voting power for voter at current block number\n     * @param voter The voter whose voting power is changing\n     * @param nCheckpoints The current checkpoint number for voter\n     * @param oldVotes The previous voting power of this voter\n     * @param newVotes The new voting power of this voter\n     */\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\n      uint32 blockNumber = _safe32(block.number, \"VP::_writeCheckpoint: block number exceeds 32 bits\");\n\n      CheckpointStorage storage cs = VotingPowerStorage.checkpointStorage();\n      if (nCheckpoints > 0 && cs.checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\n          cs.checkpoints[voter][nCheckpoints - 1].votes = newVotes;\n      } else {\n          cs.checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          cs.numCheckpoints[voter] = nCheckpoints + 1;\n      }\n\n      emit VotingPowerChanged(voter, oldVotes, newVotes);\n    }\n\n    /**\n     * @notice Converts uint256 to uint32 safely\n     * @param n Number\n     * @param errorMessage Error message to use if number cannot be converted\n     * @return uint32 number\n     */\n    function _safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n}"
    },
    "contracts/interfaces/IArchToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IArchToken {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function mint(address dst, uint256 amount) external returns (bool);\n    function burn(address src, uint256 amount) external returns (bool);\n    function updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external returns (bool);\n    function supplyManager() external view returns (address);\n    function metadataManager() external view returns (address);\n    function supplyChangeAllowedAfter() external view returns (uint256);\n    function supplyChangeWaitingPeriod() external view returns (uint32);\n    function supplyChangeWaitingPeriodMinimum() external view returns (uint32);\n    function mintCap() external view returns (uint16);\n    function setSupplyManager(address newSupplyManager) external returns (bool);\n    function setMetadataManager(address newMetadataManager) external returns (bool);\n    function setSupplyChangeWaitingPeriod(uint32 period) external returns (bool);\n    function setMintCap(uint16 newCap) external returns (bool);\n    event MintCapChanged(uint16 indexed oldMintCap, uint16 indexed newMintCap);\n    event SupplyManagerChanged(address indexed oldManager, address indexed newManager);\n    event SupplyChangeWaitingPeriodChanged(uint32 indexed oldWaitingPeriod, uint32 indexed newWaitingPeriod);\n    event MetadataManagerChanged(address indexed oldManager, address indexed newManager);\n    event TokenMetaUpdated(string indexed name, string indexed symbol);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IArchToken.sol\";\nimport \"./IVotingPower.sol\";\n\ninterface IVesting {\n    \n    struct Grant {\n        uint256 startTime;\n        uint256 amount;\n        uint16 vestingDuration;\n        uint16 vestingCliff;\n        uint256 totalClaimed;\n    }\n\n    function owner() external view returns (address);\n    function token() external view returns (IArchToken);\n    function votingPower() external view returns (IVotingPower);\n    function addTokenGrant(address recipient, uint256 startTime, uint256 amount, uint16 vestingDurationInDays, uint16 vestingCliffInDays) external;\n    function getTokenGrant(address recipient) external view returns(Grant memory);\n    function calculateGrantClaim(address recipient) external view returns (uint256);\n    function vestedBalance(address account) external view returns (uint256);\n    function claimedBalance(address recipient) external view returns (uint256);\n    function claimVestedTokens(address recipient) external;\n    function tokensVestedPerDay(address recipient) external view returns(uint256);\n    function setVotingPowerContract(address newContract) external;\n    function changeOwner(address newOwner) external;\n    event GrantAdded(address indexed recipient, uint256 indexed amount, uint256 startTime, uint16 vestingDurationInDays, uint16 vestingCliffInDays);\n    event GrantTokensClaimed(address indexed recipient, uint256 indexed amountClaimed);\n    event ChangedOwner(address indexed oldOwner, address indexed newOwner);\n    event ChangedVotingPower(address indexed oldContract, address indexed newContract);\n\n} "
    },
    "contracts/interfaces/IVotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/PrismProxy.sol\";\n\ninterface IVotingPower {\n\n    struct Stake {\n        uint256 amount;\n        uint256 votingPower;\n    }\n\n    function setPendingProxyImplementation(address newPendingImplementation) external returns (bool);\n    function acceptProxyImplementation() external returns (bool);\n    function setPendingProxyAdmin(address newPendingAdmin) external returns (bool);\n    function acceptProxyAdmin() external returns (bool);\n    function proxyAdmin() external view returns (address);\n    function pendingProxyAdmin() external view returns (address);\n    function proxyImplementation() external view returns (address);\n    function pendingProxyImplementation() external view returns (address);\n    function proxyImplementationVersion() external view returns (uint8);\n    function become(PrismProxy prism) external;\n    function initialize(address _archToken, address _vestingContract) external;\n    function archToken() external view returns (address);\n    function vestingContract() external view returns (address);\n    function stake(uint256 amount) external;\n    function stakeWithPermit(uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function withdraw(uint256 amount) external;\n    function addVotingPowerForVestingTokens(address account, uint256 amount) external;\n    function removeVotingPowerForClaimedTokens(address account, uint256 amount) external;\n    function getARCHAmountStaked(address staker) external view returns (uint256);\n    function getAmountStaked(address staker, address stakedToken) external view returns (uint256);\n    function getARCHStake(address staker) external view returns (Stake memory);\n    function getStake(address staker, address stakedToken) external view returns (Stake memory);\n    function balanceOf(address account) external view returns (uint256);\n    function balanceOfAt(address account, uint256 blockNumber) external view returns (uint256);\n    event NewPendingImplementation(address indexed oldPendingImplementation, address indexed newPendingImplementation);\n    event NewImplementation(address indexed oldImplementation, address indexed newImplementation);\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n    event Staked(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n    event Withdrawn(address indexed user, address indexed token, uint256 indexed amount, uint256 votingPower);\n    event VotingPowerChanged(address indexed voter, uint256 indexed previousBalance, uint256 indexed newBalance);\n}"
    },
    "contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "contracts/lib/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}"
    },
    "contracts/lib/PrismProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\ncontract PrismProxy {\n\n    /// @notice Proxy admin and implementation storage variables\n    struct ProxyStorage {\n        // Administrator for this contract\n        address admin;\n\n        // Pending administrator for this contract\n        address pendingAdmin;\n\n        // Active implementation of this contract\n        address implementation;\n\n        // Pending implementation of this contract\n        address pendingImplementation;\n\n        // Implementation version of this contract\n        uint8 version;\n    }\n\n    /// @dev Position in contract storage where prism ProxyStorage struct will be stored\n    bytes32 constant PRISM_PROXY_STORAGE_POSITION = keccak256(\"prism.proxy.storage\");\n\n    /// @notice Emitted when pendingImplementation is changed\n    event NewPendingImplementation(address indexed oldPendingImplementation, address indexed newPendingImplementation);\n\n    /// @notice Emitted when pendingImplementation is accepted, which means implementation is updated\n    event NewImplementation(address indexed oldImplementation, address indexed newImplementation);\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address indexed oldPendingAdmin, address indexed newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /**\n     * @notice Load proxy storage struct from specified PRISM_PROXY_STORAGE_POSITION\n     * @return ps ProxyStorage struct\n     */\n    function proxyStorage() internal pure returns (ProxyStorage storage ps) {        \n        bytes32 position = PRISM_PROXY_STORAGE_POSITION;\n        assembly {\n            ps.slot := position\n        }\n    }\n\n    /*** Admin Functions ***/\n    \n    /**\n     * @notice Create new pending implementation for prism. msg.sender must be admin\n     * @dev Admin function for proposing new implementation contract\n     * @return boolean indicating success of operation\n     */\n    function setPendingProxyImplementation(address newPendingImplementation) public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        require(msg.sender == s.admin, \"Prism::setPendingProxyImp: caller must be admin\");\n\n        address oldPendingImplementation = s.pendingImplementation;\n\n        s.pendingImplementation = newPendingImplementation;\n\n        emit NewPendingImplementation(oldPendingImplementation, s.pendingImplementation);\n\n        return true;\n    }\n\n    /**\n     * @notice Accepts new implementation for prism. msg.sender must be pendingImplementation\n     * @dev Admin function for new implementation to accept it's role as implementation\n     * @return boolean indicating success of operation\n     */\n    function acceptProxyImplementation() public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n        require(msg.sender == s.pendingImplementation && s.pendingImplementation != address(0), \"Prism::acceptProxyImp: caller must be pending implementation\");\n \n        // Save current values for inclusion in log\n        address oldImplementation = s.implementation;\n        address oldPendingImplementation = s.pendingImplementation;\n\n        s.implementation = s.pendingImplementation;\n\n        s.pendingImplementation = address(0);\n        s.version++;\n\n        emit NewImplementation(oldImplementation, s.implementation);\n        emit NewPendingImplementation(oldPendingImplementation, s.pendingImplementation);\n\n        return true;\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return boolean indicating success of operation\n     */\n    function setPendingProxyAdmin(address newPendingAdmin) public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        // Check caller = admin\n        require(msg.sender == s.admin, \"Prism::setPendingProxyAdmin: caller must be admin\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = s.pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        s.pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return true;\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return boolean indicating success of operation\n     */\n    function acceptProxyAdmin() public returns (bool) {\n        ProxyStorage storage s = proxyStorage();\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(msg.sender == s.pendingAdmin && msg.sender != address(0), \"Prism::acceptProxyAdmin: caller must be pending admin\");\n\n        // Save current values for inclusion in log\n        address oldAdmin = s.admin;\n        address oldPendingAdmin = s.pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        s.admin = s.pendingAdmin;\n\n        // Clear the pending value\n        s.pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, s.admin);\n        emit NewPendingAdmin(oldPendingAdmin, s.pendingAdmin);\n\n        return true;\n    }\n\n    /**\n     * @notice Get current admin for prism proxy\n     * @return admin address\n     */\n    function proxyAdmin() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.admin;\n    }\n\n    /**\n     * @notice Get pending admin for prism proxy\n     * @return admin address\n     */\n    function pendingProxyAdmin() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.pendingAdmin;\n    }\n\n    /**\n     * @notice Address of implementation contract\n     * @return implementation address\n     */\n    function proxyImplementation() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.implementation;\n    }\n\n    /**\n     * @notice Address of pending implementation contract\n     * @return pending implementation address\n     */\n    function pendingProxyImplementation() public view returns (address) {\n        ProxyStorage storage s = proxyStorage();\n        return s.pendingImplementation;\n    }\n\n    /**\n     * @notice Current implementation version for proxy\n     * @return version number\n     */\n    function proxyImplementationVersion() public view returns (uint8) {\n        ProxyStorage storage s = proxyStorage();\n        return s.version;\n    }\n\n    /**\n     * @notice Delegates execution to an implementation contract.\n     * @dev Returns to the external caller whatever the implementation returns or forwards reverts\n     */\n    function _forwardToImplementation() internal {\n        ProxyStorage storage s = proxyStorage();\n        // delegate all other functions to current implementation\n        (bool success, ) = s.implementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize())\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize()) }\n              default { return(free_mem_ptr, returndatasize()) }\n        }\n    }\n}"
    },
    "contracts/lib/PrismProxyImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Initializable.sol\";\nimport \"./PrismProxy.sol\";\n\ncontract PrismProxyImplementation is Initializable {\n    /**\n     * @notice Accept invitation to be implementation contract for proxy\n     * @param prism Prism Proxy contract\n     */\n    function become(PrismProxy prism) public {\n        require(msg.sender == prism.proxyAdmin(), \"Prism::become: only proxy admin can change implementation\");\n        require(prism.acceptProxyImplementation() == true, \"Prism::become: change not authorized\");\n    }\n}"
    },
    "contracts/lib/ReentrancyGuardUpgradeSafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeSafe is Initializable {\n    bool private _notEntered;\n\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n\n    }\n\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    uint256[49] private __gap;\n}"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/lib/VotingPowerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../interfaces/IArchToken.sol\";\r\nimport \"../interfaces/IVesting.sol\";\r\n\r\n/// @notice App metadata storage\r\nstruct AppStorage {\r\n    // A record of states for signing / validating signatures\r\n    mapping (address => uint) nonces;\r\n\r\n    // ARCH token\r\n    IArchToken archToken;\r\n\r\n    // Vesting contract\r\n    IVesting vesting;\r\n}\r\n\r\n/// @notice A checkpoint for marking number of votes from a given block\r\nstruct Checkpoint {\r\n    uint32 fromBlock;\r\n    uint256 votes;\r\n}\r\n\r\n/// @notice All storage variables related to checkpoints\r\nstruct CheckpointStorage {\r\n     // A record of vote checkpoints for each account, by index\r\n    mapping (address => mapping (uint32 => Checkpoint)) checkpoints;\r\n\r\n    // The number of checkpoints for each account\r\n    mapping (address => uint32) numCheckpoints;\r\n}\r\n\r\n/// @notice The amount of a given token that has been staked, and the resulting voting power\r\nstruct Stake {\r\n    uint256 amount;\r\n    uint256 votingPower;\r\n}\r\n\r\n/// @notice All storage variables related to staking\r\nstruct StakeStorage {\r\n    // Official record of staked balances for each account > token > stake\r\n    mapping (address => mapping (address => Stake)) stakes;\r\n}\r\n\r\nlibrary VotingPowerStorage {\r\n    bytes32 constant VOTING_POWER_APP_STORAGE_POSITION = keccak256(\"voting.power.app.storage\");\r\n    bytes32 constant VOTING_POWER_CHECKPOINT_STORAGE_POSITION = keccak256(\"voting.power.checkpoint.storage\");\r\n    bytes32 constant VOTING_POWER_STAKE_STORAGE_POSITION = keccak256(\"voting.power.stake.storage\");\r\n    \r\n    /**\r\n     * @notice Load app storage struct from specified VOTING_POWER_APP_STORAGE_POSITION\r\n     * @return app AppStorage struct\r\n     */\r\n    function appStorage() internal pure returns (AppStorage storage app) {        \r\n        bytes32 position = VOTING_POWER_APP_STORAGE_POSITION;\r\n        assembly {\r\n            app.slot := position\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Load checkpoint storage struct from specified VOTING_POWER_CHECKPOINT_STORAGE_POSITION\r\n     * @return cs CheckpointStorage struct\r\n     */\r\n    function checkpointStorage() internal pure returns (CheckpointStorage storage cs) {        \r\n        bytes32 position = VOTING_POWER_CHECKPOINT_STORAGE_POSITION;\r\n        assembly {\r\n            cs.slot := position\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Load stake storage struct from specified VOTING_POWER_STAKE_STORAGE_POSITION\r\n     * @return ss StakeStorage struct\r\n     */\r\n    function stakeStorage() internal pure returns (StakeStorage storage ss) {        \r\n        bytes32 position = VOTING_POWER_STAKE_STORAGE_POSITION;\r\n        assembly {\r\n            ss.slot := position\r\n        }\r\n    }\r\n}"
    }
  }
}