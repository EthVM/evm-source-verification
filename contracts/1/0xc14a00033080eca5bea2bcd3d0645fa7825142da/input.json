{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Defiance.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\ninterface ICallable {\r\n\tfunction tokenCallback(address _from, uint256 _tokens, bytes calldata _data) external returns (bool);\r\n}\r\n\r\n// \r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Defiance is Ownable {\r\n\r\n\tusing SafeMath for uint;\r\n\r\n\tuint256 constant private FLOAT_SCALAR = 2**64;\r\n\tuint256 constant private INITIAL_SUPPLY = 36e23; // 3.6m\r\n\tuint256 constant private BURN_RATE = 2; // 2% per tx\r\n\tuint256 constant private SUPPLY_FLOOR = 10; // 1% of 3.6m = 360k\r\n\tuint256 constant private MIN_STAKE_AMOUNT = 1e21; // 1,000\r\n\r\n\tstring constant public name = \"Defiance Phoenix\";\r\n\tstring constant public symbol = \"DEPH\";\r\n\tuint8 constant public decimals = 18;\r\n\r\n\tstruct User {\r\n\t\tbool whitelisted;\r\n\t\tbool pauseWhitelisted;\r\n\t\tuint256 balance;\r\n\t\tuint256 staked;\r\n\t\tmapping(address => uint256) allowance;\r\n\t\tint256 scaledPayout;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalSupply;\r\n\t\tuint256 totalStaked;\r\n\t\tmapping(address => User) users;\r\n\t\tuint256 scaledPayoutPerToken;\r\n\t\taddress admin;\r\n\t}\r\n\tInfo private info;\r\n\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 tokens);\r\n\tevent Whitelist(address indexed user, bool status);\r\n\tevent PauseWhitelist(address indexed user, bool status);\r\n\tevent Stake(address indexed owner, uint256 tokens);\r\n\tevent Unstake(address indexed owner, uint256 tokens);\r\n\tevent Collect(address indexed owner, uint256 tokens);\r\n\tevent Burn(uint256 tokens);\r\n\tevent Pause();\r\n\tevent Unpause();\r\n\tevent NotPausable();\r\n\r\n\tbool public paused = false;\r\n\tbool public canPause = true;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused || msg.sender == owner || info.users[msg.sender].pauseWhitelisted, \"paused.!\");\r\n    _;\r\n  }\r\n   /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused, \"not paused.!\");\r\n    _;\r\n  }\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == info.admin,\"only admin.!\");\r\n    _;\r\n  }\r\n  /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     **/\r\n    function pause() onlyOwner whenNotPaused public {\r\n        require(canPause == true);\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    require(paused == true);\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n\r\n  /**\r\n     * @dev Prevent the token from ever being paused again\r\n     **/\r\n    function notPausable() onlyOwner public{\r\n        paused = false;\r\n        canPause = false;\r\n        emit NotPausable();\r\n    }\r\n\r\n\tconstructor() public {\r\n\t\tinfo.admin = msg.sender;\r\n\t\tinfo.totalSupply = INITIAL_SUPPLY;\r\n\t\tinfo.users[msg.sender].balance = INITIAL_SUPPLY;\r\n\t\temit Transfer(address(0x0), msg.sender, INITIAL_SUPPLY);\r\n\t\twhitelist(msg.sender, true);\r\n\t\tpaused = true;\r\n\t}\r\n\r\n\tfunction stake(uint256 _tokens)  external whenNotPaused {\r\n\t\t_stake(_tokens);\r\n\t}\r\n\r\n\tfunction unstake(uint256 _tokens) external whenNotPaused {\r\n\t\t_unstake(_tokens);\r\n\t}\r\n\r\n\tfunction collect() external whenNotPaused returns (uint256) {\r\n\t\tuint256 _dividends = dividendsOf(msg.sender);\r\n\t\trequire(_dividends >= 0);\r\n\t\tinfo.users[msg.sender].scaledPayout += int256(_dividends.mul(FLOAT_SCALAR));\r\n\t\tuint _balance = info.users[msg.sender].balance;\r\n\t\tinfo.users[msg.sender].balance = _balance.add(_dividends);\r\n\t\temit Transfer(address(this), msg.sender, _dividends);\r\n\t\temit Collect(msg.sender, _dividends);\r\n\t\treturn _dividends;\r\n\t}\r\n\r\n\tfunction burn(uint256 _tokens) external {\r\n\t\trequire(msg.sender != info.admin);\r\n\t\trequire(balanceOf(msg.sender) >= _tokens);\r\n\r\n\t\tuint _balance = info.users[msg.sender].balance;\r\n\t\tinfo.users[msg.sender].balance = _balance.sub(_tokens);\r\n\t\tuint256 _burnedAmount = _tokens;\r\n\t\tif (info.totalStaked > 0) {\r\n\t\t\t_burnedAmount = _burnedAmount.div(2);\r\n\t\t\tuint _scaledPayout = _burnedAmount.mul(FLOAT_SCALAR).div(info.totalStaked);\r\n\t\t\tinfo.scaledPayoutPerToken = info.scaledPayoutPerToken.add(_scaledPayout);\r\n\t\t\temit Transfer(msg.sender, address(this), _burnedAmount);\r\n\t\t}\r\n\t\tinfo.totalSupply = info.totalSupply.sub(_burnedAmount);\r\n\t\temit Transfer(msg.sender, address(0x0), _burnedAmount);\r\n\t\temit Burn(_burnedAmount);\r\n\t}\r\n\r\n\tfunction distribute(uint256 _tokens) external {\r\n\t\trequire(info.totalStaked > 0);\r\n\t\trequire(balanceOf(msg.sender) >= _tokens);\r\n\t\tuint _balance = info.users[msg.sender].balance;\r\n\t\tinfo.users[msg.sender].balance = _balance.sub(_tokens);\r\n\t\t\r\n\t\tuint _scaledPayout = _tokens.mul(FLOAT_SCALAR).div(info.totalStaked);\r\n\t\tinfo.scaledPayoutPerToken = info.scaledPayoutPerToken.add(_scaledPayout);\r\n\t\temit Transfer(msg.sender, address(this), _tokens);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _tokens) external whenNotPaused returns (bool) {\r\n\t\t_transfer(msg.sender, _to, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _tokens) external whenNotPaused returns (bool) {\r\n\t\tinfo.users[msg.sender].allowance[_spender] = _tokens;\r\n\t\temit Approval(msg.sender, _spender, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokens) external whenNotPaused returns (bool) {\r\n\t\trequire(info.users[_from].allowance[msg.sender] >= _tokens);\r\n\r\n\t\tuint _balance = info.users[_from].allowance[msg.sender];\r\n\t\tinfo.users[_from].allowance[msg.sender] = _balance.sub(_tokens);\r\n\t\t_transfer(_from, _to, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferAndCall(address _to, uint256 _tokens, bytes calldata _data) external whenNotPaused returns (bool) {\r\n\t\tuint256 _transferred = _transfer(msg.sender, _to, _tokens);\r\n\t\tuint32 _size;\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_to)\r\n\t\t}\r\n\t\tif (_size > 0) {\r\n\t\t\trequire(ICallable(_to).tokenCallback(msg.sender, _transferred, _data));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction bulkTransfer(address[] calldata _receivers, uint256[] calldata _amounts) external whenNotPaused {\r\n\t\trequire(_receivers.length == _amounts.length);\r\n\t\tfor (uint256 i = 0; i < _receivers.length; i++) {\r\n\t\t\t_transfer(msg.sender, _receivers[i], _amounts[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction whitelist(address _user, bool _status) public onlyAdmin {\r\n\t\t//require(msg.sender == info.admin);\r\n\t\tinfo.users[_user].whitelisted = _status;\r\n\t\temit Whitelist(_user, _status);\r\n\t}\r\n\tfunction pauseWhitelist(address _user, bool _status) public onlyAdmin {\r\n\t\t//require(msg.sender == info.admin);\r\n\t\tinfo.users[_user].pauseWhitelisted = _status;\r\n\t\temit PauseWhitelist(_user, _status);\r\n\t}\r\n\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn info.totalSupply;\r\n\t}\r\n\r\n\tfunction totalStaked() public view returns (uint256) {\r\n\t\treturn info.totalStaked;\r\n\t}\r\n\r\n\tfunction balanceOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].balance.sub(stakedOf(_user));\r\n\t}\r\n\r\n\tfunction stakedOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].staked;\r\n\t}\r\n\r\n\tfunction dividendsOf(address _user) public view returns (uint256) {\r\n\t\treturn uint256(int256(info.scaledPayoutPerToken.mul(info.users[_user].staked)) - info.users[_user].scaledPayout).div(FLOAT_SCALAR);\r\n\t}\r\n\r\n\tfunction allowance(address _user, address _spender) public view returns (uint256) {\r\n\t\treturn info.users[_user].allowance[_spender];\r\n\t}\r\n\r\n\tfunction isWhitelisted(address _user) public view returns (bool) {\r\n\t\treturn info.users[_user].whitelisted;\r\n\t}\r\n\r\n\tfunction allInfoFor(address _user) public view returns (uint256 totalTokenSupply, uint256 totalTokensStaked, uint256 userBalance, uint256 userStaked, uint256 userDividends) {\r\n\t\treturn (totalSupply(), totalStaked(), balanceOf(_user), stakedOf(_user), dividendsOf(_user));\r\n\t}\r\n\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _tokens) internal returns (uint256) {\r\n\t\trequire(balanceOf(_from) >= _tokens);\r\n\t\tuint _fromBalance = info.users[_from].balance;\r\n\t\tinfo.users[_from].balance = _fromBalance.sub(_tokens);\r\n\t\t\r\n\t\tuint256 _burnedAmount = _tokens.mul(BURN_RATE).div(100);\r\n\t\tif (totalSupply().sub(_burnedAmount) < INITIAL_SUPPLY.mul(SUPPLY_FLOOR).div(100) || isWhitelisted(_from)) {\r\n\t\t\t_burnedAmount = 0;\r\n\t\t}\r\n\t\tuint256 _transferred = _tokens.sub(_burnedAmount);\r\n\t\t\r\n\t\tuint _toBalance = info.users[_to].balance;\r\n\r\n\t\tinfo.users[_to].balance = _toBalance.add(_transferred);\r\n\t\temit Transfer(_from, _to, _transferred);\r\n\t\tif (_burnedAmount > 0) {\r\n\t\t\tif (info.totalStaked > 0) {\r\n\t\t\t\t_burnedAmount = _burnedAmount.div(2);\r\n\t\t\t\t\r\n\t\t\t\tuint _scaledPayout = _burnedAmount.mul(FLOAT_SCALAR).div(info.totalStaked);\r\n\r\n\t\t\t\tinfo.scaledPayoutPerToken = info.scaledPayoutPerToken.add(_scaledPayout);\r\n\t\t\t\temit Transfer(_from, address(this), _burnedAmount);\r\n\t\t\t}\r\n\t\t\tinfo.totalSupply = info.totalSupply.sub(_burnedAmount);\r\n\t\t\temit Transfer(_from, address(0x0), _burnedAmount);\r\n\t\t\temit Burn(_burnedAmount);\r\n\t\t}\r\n\t\treturn _transferred;\r\n\t}\r\n\r\n\tfunction _stake(uint256 _amount) internal {\r\n\t\trequire(balanceOf(msg.sender) >= _amount);\r\n\t\trequire(stakedOf(msg.sender).add(_amount) >= MIN_STAKE_AMOUNT);\r\n\t\tinfo.totalStaked = info.totalStaked.add(_amount);\r\n\r\n\t\tuint _userStaked = info.users[msg.sender].staked;\r\n\t\tinfo.users[msg.sender].staked = _userStaked.add(_amount);\r\n\t\tinfo.users[msg.sender].scaledPayout += int256(_amount.mul(info.scaledPayoutPerToken));\r\n\t\temit Transfer(msg.sender, address(this), _amount);\r\n\t\temit Stake(msg.sender, _amount);\r\n\t}\r\n\tfunction _unstake(uint256 _amount) internal {\r\n\t\trequire(stakedOf(msg.sender) >= _amount);\r\n\t\tuint256 _burnedAmount = _amount.mul(BURN_RATE).div(100);\r\n\t\tinfo.scaledPayoutPerToken = info.scaledPayoutPerToken.add(_burnedAmount.mul(FLOAT_SCALAR).div(info.totalStaked));\r\n\t\tinfo.totalStaked = info.totalStaked.sub(_amount);\r\n\r\n\t\tuint _userBalance = info.users[msg.sender].balance;\r\n\t\tinfo.users[msg.sender].balance = _userBalance.sub(_burnedAmount);\r\n\r\n\t\tuint _userStaked = info.users[msg.sender].staked;\r\n\t\tinfo.users[msg.sender].staked = _userStaked.sub(_amount);\r\n\r\n\t\tinfo.users[msg.sender].scaledPayout -= int256(_amount.mul(info.scaledPayoutPerToken));\r\n\t\temit Transfer(address(this), msg.sender, _amount.sub(_burnedAmount));\r\n\t\temit Unstake(msg.sender, _amount);\r\n\t}\r\n}"
    }
  }
}