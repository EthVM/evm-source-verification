{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DSChief.sol": {
      "content": "// chief.sol - select an authority by consensus\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.4.23;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSToken is DSMath, DSAuth {\r\n    bool                                              public  stopped;\r\n    uint256                                           public  totalSupply;\r\n    mapping (address => uint256)                      public  balanceOf;\r\n    mapping (address => mapping (address => uint256)) public  allowance;\r\n    bytes32                                           public  symbol;\r\n    uint256                                           public  decimals = 18; // standard token precision. override to customize\r\n    bytes32                                           public  name = \"\";     // Optional token name\r\n\r\n    constructor(bytes32 symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n    event Stop();\r\n    event Start();\r\n\r\n    modifier stoppable {\r\n        require(!stopped, \"ds-stop-is-stopped\");\r\n        _;\r\n    }\r\n\r\n    function approve(address guy) external returns (bool) {\r\n        return approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n\r\n        require(balanceOf[src] >= wad, \"ds-token-insufficient-balance\");\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) external {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function pull(address src, uint wad) external {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n\r\n    function mint(uint wad) external {\r\n        mint(msg.sender, wad);\r\n    }\r\n\r\n    function burn(uint wad) external {\r\n        burn(msg.sender, wad);\r\n    }\r\n\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        balanceOf[guy] = add(balanceOf[guy], wad);\r\n        totalSupply = add(totalSupply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && allowance[guy][msg.sender] != uint(-1)) {\r\n            require(allowance[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\r\n        }\r\n\r\n        require(balanceOf[guy] >= wad, \"ds-token-insufficient-balance\");\r\n        balanceOf[guy] = sub(balanceOf[guy], wad);\r\n        totalSupply = sub(totalSupply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n\r\n    function stop() public auth {\r\n        stopped = true;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() public auth {\r\n        stopped = false;\r\n        emit Start();\r\n    }\r\n\r\n    function setName(bytes32 name_) external auth {\r\n        name = name_;\r\n    }\r\n}\r\n\r\ncontract DSRoles is DSAuth, DSAuthority\r\n{\r\n    mapping(address=>bool) _root_users;\r\n    mapping(address=>bytes32) _user_roles;\r\n    mapping(address=>mapping(bytes4=>bytes32)) _capability_roles;\r\n    mapping(address=>mapping(bytes4=>bool)) _public_capabilities;\r\n\r\n    function getUserRoles(address who)\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _user_roles[who];\r\n    }\r\n\r\n    function getCapabilityRoles(address code, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _capability_roles[code][sig];\r\n    }\r\n\r\n    function isUserRoot(address who)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _root_users[who];\r\n    }\r\n\r\n    function isCapabilityPublic(address code, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _public_capabilities[code][sig];\r\n    }\r\n\r\n    function hasUserRole(address who, uint8 role)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 roles = getUserRoles(who);\r\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\r\n        return bytes32(0) != roles & shifted;\r\n    }\r\n\r\n    function canCall(address caller, address code, bytes4 sig)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        if( isUserRoot(caller) || isCapabilityPublic(code, sig) ) {\r\n            return true;\r\n        } else {\r\n            bytes32 has_roles = getUserRoles(caller);\r\n            bytes32 needs_one_of = getCapabilityRoles(code, sig);\r\n            return bytes32(0) != has_roles & needs_one_of;\r\n        }\r\n    }\r\n\r\n    function BITNOT(bytes32 input) internal pure returns (bytes32 output) {\r\n        return (input ^ bytes32(uint(-1)));\r\n    }\r\n\r\n    function setRootUser(address who, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        _root_users[who] = enabled;\r\n    }\r\n\r\n    function setUserRole(address who, uint8 role, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        bytes32 last_roles = _user_roles[who];\r\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\r\n        if( enabled ) {\r\n            _user_roles[who] = last_roles | shifted;\r\n        } else {\r\n            _user_roles[who] = last_roles & BITNOT(shifted);\r\n        }\r\n    }\r\n\r\n    function setPublicCapability(address code, bytes4 sig, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        _public_capabilities[code][sig] = enabled;\r\n    }\r\n\r\n    function setRoleCapability(uint8 role, address code, bytes4 sig, bool enabled)\r\n        public\r\n        auth\r\n    {\r\n        bytes32 last_roles = _capability_roles[code][sig];\r\n        bytes32 shifted = bytes32(uint256(uint256(2) ** uint256(role)));\r\n        if( enabled ) {\r\n            _capability_roles[code][sig] = last_roles | shifted;\r\n        } else {\r\n            _capability_roles[code][sig] = last_roles & BITNOT(shifted);\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue()\r\n        }\r\n\r\n        _;\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n    }\r\n}\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n    function S(string memory s) internal pure returns (bytes4) {\r\n        return bytes4(keccak256(abi.encodePacked(s)));\r\n    }\r\n\r\n}\r\n\r\n// The right way to use this contract is probably to mix it with some kind\r\n// of `DSAuthority`, like with `ds-roles`.\r\n//   SEE DSChief\r\ncontract DSChiefApprovals is DSThing {\r\n    mapping(bytes32=>address[]) public slates;\r\n    mapping(address=>bytes32) public votes;\r\n    mapping(address=>uint256) public approvals;\r\n    mapping(address=>uint256) public deposits;\r\n    DSToken public GOV; // voting token that gets locked up\r\n    DSToken public IOU; // non-voting representation of a token, for e.g. secondary voting mechanisms\r\n    address public hat; // the chieftain's hat\r\n\r\n    uint256 public MAX_YAYS;\r\n\r\n    mapping(address=>uint256) public last;\r\n\r\n    bool public live;\r\n\r\n    uint256 constant LAUNCH_THRESHOLD = 80_000 * 10 ** 18; // 80K MKR launch threshold\r\n\r\n    event Etch(bytes32 indexed slate);\r\n\r\n    // IOU constructed outside this contract reduces deployment costs significantly\r\n    // lock/free/vote are quite sensitive to token invariants. Caution is advised.\r\n    constructor(DSToken GOV_, DSToken IOU_, uint MAX_YAYS_) public\r\n    {\r\n        GOV = GOV_;\r\n        IOU = IOU_;\r\n        MAX_YAYS = MAX_YAYS_;\r\n    }\r\n\r\n    function launch()\r\n        public\r\n        note\r\n    {\r\n        require(!live);\r\n        require(hat == address(0) && approvals[address(0)] >= LAUNCH_THRESHOLD);\r\n        live = true;\r\n    }\r\n\r\n    function lock(uint wad)\r\n        public\r\n        note\r\n    {\r\n        last[msg.sender] = block.number;\r\n        GOV.pull(msg.sender, wad);\r\n        IOU.mint(msg.sender, wad);\r\n        deposits[msg.sender] = add(deposits[msg.sender], wad);\r\n        addWeight(wad, votes[msg.sender]);\r\n    }\r\n\r\n    function free(uint wad)\r\n        public\r\n        note\r\n    {\r\n        require(block.number > last[msg.sender]);\r\n        deposits[msg.sender] = sub(deposits[msg.sender], wad);\r\n        subWeight(wad, votes[msg.sender]);\r\n        IOU.burn(msg.sender, wad);\r\n        GOV.push(msg.sender, wad);\r\n    }\r\n\r\n    function etch(address[] memory yays)\r\n        public\r\n        note\r\n        returns (bytes32 slate)\r\n    {\r\n        require( yays.length <= MAX_YAYS );\r\n        requireByteOrderedSet(yays);\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(yays));\r\n        slates[hash] = yays;\r\n        emit Etch(hash);\r\n        return hash;\r\n    }\r\n\r\n    function vote(address[] memory yays) public returns (bytes32)\r\n        // note  both sub-calls note\r\n    {\r\n        bytes32 slate = etch(yays);\r\n        vote(slate);\r\n        return slate;\r\n    }\r\n\r\n    function vote(bytes32 slate)\r\n        public\r\n        note\r\n    {\r\n        require(slates[slate].length > 0 ||\r\n            slate == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, \"ds-chief-invalid-slate\");\r\n        uint weight = deposits[msg.sender];\r\n        subWeight(weight, votes[msg.sender]);\r\n        votes[msg.sender] = slate;\r\n        addWeight(weight, votes[msg.sender]);\r\n    }\r\n\r\n    // like `drop`/`swap` except simply \"elect this address if it is higher than current hat\"\r\n    function lift(address whom)\r\n        public\r\n        note\r\n    {\r\n        require(approvals[whom] > approvals[hat]);\r\n        hat = whom;\r\n    }\r\n\r\n    function addWeight(uint weight, bytes32 slate)\r\n        internal\r\n    {\r\n        address[] storage yays = slates[slate];\r\n        for( uint i = 0; i < yays.length; i++) {\r\n            approvals[yays[i]] = add(approvals[yays[i]], weight);\r\n        }\r\n    }\r\n\r\n    function subWeight(uint weight, bytes32 slate)\r\n        internal\r\n    {\r\n        address[] storage yays = slates[slate];\r\n        for( uint i = 0; i < yays.length; i++) {\r\n            approvals[yays[i]] = sub(approvals[yays[i]], weight);\r\n        }\r\n    }\r\n\r\n    // Throws unless the array of addresses is a ordered set.\r\n    function requireByteOrderedSet(address[] memory yays)\r\n        internal\r\n        pure\r\n    {\r\n        if( yays.length == 0 || yays.length == 1 ) {\r\n            return;\r\n        }\r\n        for( uint i = 0; i < yays.length - 1; i++ ) {\r\n            // strict inequality ensures both ordering and uniqueness\r\n            require(uint(yays[i]) < uint(yays[i+1]));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// `hat` address is unique root user (has every role) and the\r\n// unique owner of role 0 (typically 'sys' or 'internal')\r\ncontract DSChief is DSRoles, DSChiefApprovals {\r\n\r\n    constructor(DSToken GOV, DSToken IOU, uint MAX_YAYS)\r\n             DSChiefApprovals (GOV, IOU, MAX_YAYS)\r\n        public\r\n    {\r\n        authority = this;\r\n        owner = address(0);\r\n    }\r\n\r\n    function setOwner(address owner_) public {\r\n        owner_;\r\n        revert();\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_) public {\r\n        authority_;\r\n        revert();\r\n    }\r\n\r\n    function isUserRoot(address who)\r\n        public view\r\n        returns (bool)\r\n    {\r\n        return (live && who == hat);\r\n    }\r\n    function setRootUser(address who, bool enabled) public {\r\n        who; enabled;\r\n        revert();\r\n    }\r\n}"
    }
  }
}