{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"IComptroller.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\ninterface Comptroller {\r\n  function _addCompMarkets ( address[] memory cTokens ) external;\r\n  function _become ( address unitroller ) external;\r\n  function _borrowGuardianPaused (  ) external view returns ( bool );\r\n  function _dropCompMarket ( address cToken ) external;\r\n  function _mintGuardianPaused (  ) external view returns ( bool );\r\n  function _setBorrowCapGuardian ( address newBorrowCapGuardian ) external;\r\n  function _setBorrowPaused ( address cToken, bool state ) external returns ( bool );\r\n  function _setClose ( uint256 newCloseFactorMantissa ) external returns ( uint256 );\r\n  function _setCollateralFactor ( address cToken, uint256 newCollateralFactorMantissa ) external returns ( uint256 );\r\n  function _setCompRate ( uint256 compRate_ ) external;\r\n  function _setLiquidationIncentive ( uint256 newLiquidationIncentiveMantissa ) external returns ( uint256 );\r\n  function _setMarketBorrowCaps ( address[] memory cTokens, uint256[] memory newBorrowCaps ) external;\r\n  function _setMaxAssets ( uint256 newMaxAssets ) external returns ( uint256 );\r\n  function _setMintPaused ( address cToken, bool state ) external returns ( bool );\r\n  function _setPauseGuardian ( address newPauseGuardian ) external returns ( uint256 );\r\n  function _setPriceOracle ( address newOracle ) external returns ( uint256 );\r\n  function _setSeizePaused ( bool state ) external returns ( bool );\r\n  function _setTransferPaused ( bool state ) external returns ( bool );\r\n  function _supportMarket ( address cToken ) external returns ( uint256 );\r\n  function accountAssets ( address, uint256 ) external view returns ( address );\r\n  function admin (  ) external view returns ( address );\r\n  function allMarkets ( uint256 ) external view returns ( address );\r\n  function borrowAllowed ( address cToken, address borrower, uint256 borrowAmount ) external returns ( uint256 );\r\n  function borrowCapGuardian (  ) external view returns ( address );\r\n  function borrowCaps ( address ) external view returns ( uint256 );\r\n  function borrowGuardianPaused ( address ) external view returns ( bool );\r\n  function borrowVerify ( address cToken, address borrower, uint256 borrowAmount ) external;\r\n  function checkMembership ( address account, address cToken ) external view returns ( bool );\r\n  function claimComp ( address holder, address[] memory cTokens ) external;\r\n  function claimComp ( address[] memory holders, address[] memory cTokens, bool borrowers, bool suppliers ) external;\r\n  function claimComp ( address holder ) external;\r\n  function closeFactorMantissa (  ) external view returns ( uint256 );\r\n  function compAccrued ( address ) external view returns ( uint256 );\r\n  function compBorrowState ( address ) external view returns ( uint224, uint32 );\r\n  function compBorrowerIndex ( address, address ) external view returns ( uint256 );\r\n  function compClaimThreshold (  ) external view returns ( uint256 );\r\n  function compInitialIndex (  ) external view returns ( uint224 );\r\n  function compRate (  ) external view returns ( uint256 );\r\n  function compSpeeds ( address ) external view returns ( uint256 );\r\n  function compSupplierIndex ( address, address ) external view returns ( uint256 );\r\n  function compSupplyState ( address ) external view returns ( uint224, uint32 );\r\n  function comptrollerImplementation (  ) external view returns ( address );\r\n  function enterMarkets ( address[] memory cTokens ) external returns ( uint256[] memory );\r\n  function exitMarket ( address cTokenAddress ) external returns ( uint256 );\r\n  function getAccountLiquidity ( address account ) external view returns ( uint256, uint256, uint256 );\r\n  function getAllMarkets (  ) external view returns ( address[] memory );\r\n  function getAssetsIn ( address account ) external view returns ( address[] memory );\r\n  function getBlockNumber (  ) external view returns ( uint256 );\r\n  function getCompAddress (  ) external view returns ( address );\r\n  function getHypotheticalAccountLiquidity ( address account, address cTokenModify, uint256 redeemTokens, uint256 borrowAmount ) external view returns ( uint256, uint256, uint256 );\r\n  function isComptroller (  ) external view returns ( bool );\r\n  function liquidateBorrowAllowed ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount ) external returns ( uint256 );\r\n  function liquidateBorrowVerify ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 actualRepayAmount, uint256 seizeTokens ) external;\r\n  function liquidateCalculateSeizeTokens ( address cTokenBorrowed, address cTokenCollateral, uint256 actualRepayAmount ) external view returns ( uint256, uint256 );\r\n  function liquidationIncentiveMantissa (  ) external view returns ( uint256 );\r\n  function markets ( address ) external view returns ( bool isListed, uint256 collateralFactorMantissa, bool isComped );\r\n  function maxAssets (  ) external view returns ( uint256 );\r\n  function mintAllowed ( address cToken, address minter, uint256 mintAmount ) external returns ( uint256 );\r\n  function mintGuardianPaused ( address ) external view returns ( bool );\r\n  function mintVerify ( address cToken, address minter, uint256 actualMintAmount, uint256 mintTokens ) external;\r\n  function oracle (  ) external view returns ( address );\r\n  function pauseGuardian (  ) external view returns ( address );\r\n  function pendingAdmin (  ) external view returns ( address );\r\n  function pendingComptrollerImplementation (  ) external view returns ( address );\r\n  function redeemAllowed ( address cToken, address redeemer, uint256 redeemTokens ) external returns ( uint256 );\r\n  function redeemVerify ( address cToken, address redeemer, uint256 redeemAmount, uint256 redeemTokens ) external;\r\n  function refreshCompSpeeds (  ) external;\r\n  function repayBorrowAllowed ( address cToken, address payer, address borrower, uint256 repayAmount ) external returns ( uint256 );\r\n  function repayBorrowVerify ( address cToken, address payer, address borrower, uint256 actualRepayAmount, uint256 borrowerIndex ) external;\r\n  function seizeAllowed ( address cTokenCollateral, address cTokenBorrowed, address liquidator, address borrower, uint256 seizeTokens ) external returns ( uint256 );\r\n  function seizeGuardianPaused (  ) external view returns ( bool );\r\n  function seizeVerify ( address cTokenCollateral, address cTokenBorrowed, address liquidator, address borrower, uint256 seizeTokens ) external;\r\n  function transferAllowed ( address cToken, address src, address dst, uint256 transferTokens ) external returns ( uint256 );\r\n  function transferGuardianPaused (  ) external view returns ( bool );\r\n  function transferVerify ( address cToken, address src, address dst, uint256 transferTokens ) external;\r\n}\r\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\ninterface ERC20 {\r\n  function liquidateBorrow ( address borrower, uint256 repayAmount, address cTokenCollateral ) external returns ( uint256 );\r\n  function approve ( address spender, uint256 amount ) external returns ( bool );\r\n  function balanceOf ( address owner ) external view returns ( uint256 );\r\n  function balanceOfUnderlying ( address owner ) external returns ( uint256 );\r\n  function decimals (  ) external view returns ( uint256 );\r\n  function mint ( uint256 mintAmount ) external returns ( uint256 );\r\n  function symbol (  ) external view returns ( string memory );\r\n  function totalSupply( ) external view returns (uint256 supply);\r\n  function transfer ( address dst, uint256 amount ) external returns ( bool );\r\n  function transferFrom ( address src, address dst, uint256 amount ) external returns ( bool );\r\n  function underlying (  ) external view returns ( address );\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n"},"IKyberNetworkProxy.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ninterface IKyberNetworkProxy {\n\n    event ExecuteTrade(\n        address indexed trader,\n        ERC20 src,\n        ERC20 dest,\n        address destAddress,\n        uint256 actualSrcAmount,\n        uint256 actualDestAmount,\n        address platformWallet,\n        uint256 platformFeeBps\n    );\n\n    /// @notice backward compatible\n    function tradeWithHint(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable walletId,\n        bytes calldata hint\n    ) external payable returns (uint256);\n\n    function tradeWithHintAndFee(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable platformWallet,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external payable returns (uint256 destAmount);\n\n    function trade(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable platformWallet\n    ) external payable returns (uint256);\n\n    /// @notice backward compatible\n    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\n    function getExpectedRate(\n        ERC20 src,\n        ERC20 dest,\n        uint256 srcQty\n    ) external view returns (uint256 expectedRate, uint256 worstRate);\n\n    function getExpectedRateAfterFee(\n        ERC20 src,\n        ERC20 dest,\n        uint256 srcQty,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external view returns (uint256 expectedRate);\n}"},"IStructs.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface Structs {\r\n    struct Val {\r\n        uint256 value;\r\n    }\r\n\r\n    enum ActionType {\r\n      Deposit,   // supply tokens\r\n      Withdraw,  // borrow tokens\r\n      Transfer,  // transfer balance between accounts\r\n      Buy,       // buy an amount of some token (externally)\r\n      Sell,      // sell an amount of some token (externally)\r\n      Trade,     // trade tokens against another account\r\n      Liquidate, // liquidate an undercollateralized or expiring account\r\n      Vaporize,  // use excnt is denominated in wei\r\n      Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta // the amount is given as a delta from the current value\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    enum AssetDenomination { Wei, Par }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n}\r\n"},"Ic_or_w_ETH.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\ninterface c_or_w_ETH {\r\n  function liquidateBorrow ( address borrower, address cTokenCollateral ) external payable;\r\n  function approve ( address spender, uint256 amount ) external returns ( bool );\r\n  function balanceOf ( address owner ) external view returns ( uint256 );\r\n  function balanceOfUnderlying ( address owner ) external returns ( uint256 );\r\n  function decimals (  ) external view returns ( uint256 );\r\n  function symbol (  ) external view returns ( string memory );\r\n  function totalSupply( ) external view returns (uint256 supply);\r\n  function transfer ( address dst, uint256 amount ) external returns ( bool );\r\n  function transferFrom ( address src, address dst, uint256 amount ) external returns ( bool );\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n"},"PreachersCompFiLqdt.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IStructs.sol\";\r\n\r\n// for CompFi Interfaces\r\nimport \"./IERC20.sol\";\r\nimport \"./Ic_or_w_ETH.sol\";\r\nimport \"./IComptroller.sol\";\r\n\r\n// KyberSwap\r\nimport \"./IKyberNetworkProxy.sol\";\r\n\r\n\r\n// dYdX flash loan contract\r\ninterface ISoloMargin {\r\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\r\n}\r\n\r\naddress constant kETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n// Compound.Finance Comptroller constants\r\n// Note:To call Comptroller functions, use the Comptroller ABI on the Unitroller address.\r\naddress constant kUnitroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\naddress constant kComptroller = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\r\naddress constant kcUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\r\naddress constant kcETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\r\n\r\n// KyberSwap Proxy contract \r\naddress constant kKyberProxy = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\r\n// KyberHintHandler (KyberMatchingEngine)\r\naddress constant kKybeHint = 0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C;\r\n\r\n// dYdX loan currencies\r\naddress constant kWETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\naddress constant kSAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\naddress constant kUSDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\naddress constant kDAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n\r\nabstract contract DyDxPool is Structs {\r\n    function getAccountWei(Info memory account, uint256 marketId) public virtual view returns (Wei memory);\r\n    function operate(Info[] memory, ActionArgs[] memory) public virtual;\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract DyDxFlashLoan is Structs {\r\n    DyDxPool kDyDxPool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\r\n\r\n    // address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    // address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    // address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    // address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    mapping(address => uint256) public currencies;\r\n    \r\n    constructor() {\r\n        currencies[kWETH] = 1;\r\n        currencies[kSAI] = 2;\r\n        currencies[kUSDC] = 3;\r\n        currencies[kDAI] = 4;\r\n    }\r\n\r\n    modifier onlyPool() {\r\n        require(msg.sender == address(kDyDxPool), \"FlashLoan: could be called by DyDx pool only\");\r\n        _;\r\n    }\r\n\r\n    function tokenToMarketId(address token) public view returns (uint256 ) {\r\n        \r\n        require(currencies[token] != 0, \"FlashLoan: Unsupported token\");\r\n        \r\n        return currencies[token] - 1;\r\n    }\r\n    \r\n\r\n    /***************************************************************************\r\n     * the DyDx will call `callFunction(address sender, Info memory accountInfo,\r\n     * bytes memory data) public` after during `operate` call\r\n     ***************************************************************************/\r\n    function flashloan(address token, uint256 amount, bytes memory data)\r\n        internal\r\n    {\r\n        ERC20(token).approve(address(kDyDxPool), amount + 1);\r\n        Info[] memory infos = new Info[](1);\r\n        ActionArgs[] memory args = new ActionArgs[](3);\r\n\r\n        infos[0] = Info(address(this), 0);\r\n\r\n        AssetAmount memory wamt = AssetAmount(\r\n            false,\r\n            AssetDenomination.Wei,\r\n            AssetReference.Delta,\r\n            amount\r\n        );\r\n        \r\n        ActionArgs memory withdraw;\r\n        withdraw.actionType = ActionType.Withdraw;\r\n        withdraw.accountId = 0;\r\n        withdraw.amount = wamt;\r\n        withdraw.primaryMarketId = tokenToMarketId(token);\r\n        withdraw.otherAddress = address(this);\r\n\r\n        args[0] = withdraw;\r\n\r\n        ActionArgs memory call;\r\n        call.actionType = ActionType.Call;\r\n        call.accountId = 0;\r\n        call.otherAddress = address(this);\r\n        call.data = data;\r\n\r\n        args[1] = call;\r\n\r\n        ActionArgs memory deposit;\r\n        AssetAmount memory damt = AssetAmount(\r\n            true,\r\n            AssetDenomination.Wei,\r\n            AssetReference.Delta,\r\n            amount + 1\r\n        );\r\n        deposit.actionType = ActionType.Deposit;\r\n        deposit.accountId = 0;\r\n        deposit.amount = damt;\r\n        deposit.primaryMarketId = tokenToMarketId(token);\r\n        deposit.otherAddress = address(this);\r\n\r\n        args[2] = deposit;\r\n\r\n        kDyDxPool.operate(infos, args);\r\n    }\r\n}\r\n\r\n\r\n/**********************************************************\r\n * Main Contract: PreachersCompFiLqdt\r\n **********************************************************/\r\npragma solidity ^0.8.0;\r\n\r\ncontract PreachersCompFiLqdt is DyDxFlashLoan {\r\n    uint256 public loan;\r\n    IKyberNetworkProxy cKyberProxy = IKyberNetworkProxy(kKyberProxy);\r\n\r\n    // Contract owner\r\n    address payable owner;\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not the owner!\");\r\n        _;\r\n    }\r\n\r\n    constructor() payable {\r\n\r\n        // Track the contract owner\r\n        owner = payable(msg.sender);\r\n        \r\n    }\r\n\r\n    /*************************************************************************************************************\r\n     * Call this contract function from the external \r\n     * remote job to perform the liquidation.\r\n     * \r\n     ************************************************************************************************************/\r\n    function doCompFiLiquidate(\r\n        //loan information\r\n        address flashToken, \r\n        uint256 flashAmount,\r\n        // Borrow Account to be liquidated\r\n        address targetAccount, \r\n        address targetToken, \r\n        uint256 liquidateAmount,\r\n        // liquidation reimbursement and Reward Token\r\n        address collateralToken\r\n        ) external returns(bool) {\r\n        \r\n        // Get the amount of the token in this contracts balance.\r\n        // At least 2 wei is needed for the loan fee.\r\n        uint256 balanceBefore = ERC20(flashToken).balanceOf(address(this));\r\n        \r\n        // Populate the passthru data structure, which will be used\r\n        // by 'callFunction'\r\n        bytes memory data = abi.encode(\r\n            flashToken, \r\n            flashAmount, \r\n            balanceBefore,\r\n            targetAccount, \r\n            targetToken, \r\n            liquidateAmount, \r\n            collateralToken);\r\n        \r\n        // execution goes to `callFunction`\r\n        // STEP 1\r\n        flashloan(flashToken, flashAmount, data);\r\n        emit Liquidated( targetAccount, targetToken, liquidateAmount );\r\n        return true;\r\n    }\r\n    \r\n    /**************************************************************************************\r\n     * Preacher's Method II\r\n     * \r\n     * 1. Obtain Flash Loan in USDC from dYdX in the amount of equal value in the \r\n     * liquidation amount.\r\n     * 2. If the liquidate token is cUSDC, skip to step (3). Otherwise, swap (Kyber) the \r\n     * USDC for an equal value of the liquidate tokens.\r\n     * 3. Pay down the liquidate amount, liquidateBorrow(). CompFi will award an equal \r\n     * value from the unsafe account's collateral + incentive reward.\r\n     * 4. Swap the received collateral tokens for USDC.\r\n     * 5. Repay the flash loan with the USDC.\r\n     * 6. Transfer what is left of the USDC to the Msg.sender.\r\n     * \r\n     **************************************************************************************/\r\n    function callFunction(\r\n        address, /* sender */\r\n        Info calldata, /* accountInfo */\r\n        bytes calldata data\r\n    ) external onlyPool {\r\n\t\r\n\t    // Decode the parameters in \"calldata\" as passed by doCompFiLiquidate.\r\n        (address flashToken, \r\n        uint256 flashAmount, \r\n        uint256 balanceBefore,\r\n        address targetAccount, \r\n        address targetToken, \r\n        uint256 liquidateAmount,\r\n        address collateralToken) = \r\n\t\t\tabi.decode(data, (address, uint256, uint256, address, address, \r\n\t\t\tuint256, address));\r\n\r\n\t\tERC20 cFlashToken = ERC20(flashToken);\r\n\r\n\t\trequire(cFlashToken.balanceOf(address(this)) - balanceBefore >=\r\n\t\t    flashAmount ,\"contract did not get the loan\");\r\n\t\temit Borrowed(flashToken, cFlashToken.balanceOf(address(this)));\r\n\t\t\r\n        // function approve(address _spender, uint256 _value) public returns (bool success)\r\n\t\tERC20 underlying = ERC20(cFlashToken.underlying( )); // get a handle for the underlying asset contract\r\n\t\trequire(underlying.approve(address(cFlashToken), flashAmount) == true, \r\n\t\t    \"01 approval failed\"); // approve the transfer\r\n\t\trequire(cFlashToken.mint(flashAmount) > 0, \"01 Mint failed\");    // mint the cTokens and assert there is no error\r\n\t\t\r\n\t\tERC20 cTargetToken = ERC20(targetToken);\r\n        // Step 2. Swap USDC for targetToken\r\n        if (targetToken != kcUSDC) {\r\n    \t   require( executeKyberSwap(cFlashToken, flashAmount,\r\n\t            cTargetToken, payable(address(this)), \r\n\t            liquidateAmount) > 0, \"02 First Token swap failed\");\r\n        }\r\n        \r\n        require(cTargetToken.approve(address(this), liquidateAmount) == true,\r\n            \"02 approval failed.\");\r\n        \r\n        // Step 3. Pay down the amount borrowed by the unsafe account\r\n\t\t// -- Enter the market for the token to be liquidated\r\n\t\tComptroller ctroll = Comptroller(kUnitroller);\r\n\r\n\t\taddress[] memory cTokens = new address[](1);\r\n\t\tcTokens[0] = targetToken;\r\n\t\tuint[] memory ERRORS = ctroll.enterMarkets(cTokens);\r\n\t\tif (ERRORS[0] != 0) {\r\n            revert(\"01 Comptroller enter Markets for target token failed. \");\r\n\t\t}\r\n\t\t\r\n\t\tif (targetToken == kcETH){\r\n\t\t    c_or_w_ETH ceTargetToken = c_or_w_ETH(targetToken);\r\n\t\t    ceTargetToken.liquidateBorrow{value: flashAmount}\r\n\t\t        (targetAccount, collateralToken);\r\n\t\t} else {\r\n\t\t    cTargetToken.liquidateBorrow(targetAccount, flashAmount, collateralToken);\r\n\t\t}\r\n\t\trequire(ctroll.exitMarket(targetToken) == 0, \r\n\t\t    \"Exit Market of target token failed. \");\r\n\t\t \r\n\t\t// 4. Swap the received collateral tokens back to USDC to repay the flash loan.\r\n\t\tcTokens[0] = collateralToken;\r\n\t\tERRORS = ctroll.enterMarkets(cTokens);\r\n\t\trequire(ERRORS[0] == 0, \"02 Comptroller.enter Markets for collateral Token failed.\");\r\n\r\n\t\tERC20 cCollateralToken = ERC20(collateralToken);\r\n\t\trequire(cCollateralToken.approve(address(this), cCollateralToken.balanceOf(address(this))) == true,\r\n\t\t    \"03 Collateral Token approval failed.\");\r\n\t\t    \r\n\t\tif (collateralToken != kcUSDC) {\r\n    \t   require( executeKyberSwap(cCollateralToken, \r\n    \t        cCollateralToken.balanceOf(address(this)),\r\n\t            cTargetToken, payable(address(this)), \r\n\t            899999999999999999) > 0, \"02 First Token swap failed\");\r\n        }\r\n        \r\n    \t// -- Liquidation is completed in flashloan()\r\n    }\r\n    \r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n        emit ChangedOwner(owner, newOwner);\r\n    }\r\n\r\n    function getTokenBalance(address tokenAddress) public view returns(uint256) {\r\n        ERC20 theToken = ERC20(tokenAddress);\r\n        return theToken.balanceOf(address(this));\r\n    }\r\n    \r\n    function withdraw(address token) public onlyOwner returns(bool) {\r\n        uint256 tokenBalance;\r\n        // withdrawing Ether\r\n        if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n            if (address(this).balance > 0){\r\n                tokenBalance = address(this).balance;\r\n                payable(msg.sender).transfer(address(this).balance);\r\n            }\r\n\r\n        } else {\r\n            ERC20 withdrawToken = ERC20(token);\r\n            if (withdrawToken.balanceOf(address(this)) > 0){\r\n                tokenBalance = withdrawToken.balanceOf(address(this));\r\n                require(withdrawToken.transfer(msg.sender, \r\n                    (withdrawToken.balanceOf(address(this)))));\r\n            }\r\n        }\r\n        emit Withdrawn(token, tokenBalance);\r\n        return true;\r\n    }\r\n\r\n    event Transfer(address from, address to, uint256 value);\r\n    event Borrowed(address tokenborrowed, uint256 amount);\r\n    event Swapped(address fromtoken, uint256 fromamount,\r\n        address totoken, uint256 toamount);\r\n    event Liquidated(address account, address token, uint256 amount );\r\n    event ChangedOwner(address payable owner, address payable newOwner);\r\n    event Withdrawn(address token, uint256 amount);\r\n\r\n    /***************************************************************************\r\n     * KyberSwap functions\r\n    ****************************************************************************/\r\n    /// Swap from srcToken to destToken (including ether)\r\n    function executeKyberSwap( ERC20 cSrcToken, uint256 srcQty, ERC20 cDestToken, \r\n        address payable destAddress, uint256 maxDestAmount\r\n    ) internal returns ( uint256 ) {\r\n        \r\n        // if not Ethereum\r\n        if (address(cSrcToken) != kETH) {\r\n\r\n            // mitigate ERC20 Approve front-running attack, by initially setting\r\n            // allowance to 0\r\n            require(cSrcToken.approve(address(cKyberProxy), 0), \"approval to 0 failed\");\r\n\r\n            // set the spender's token allowance to tokenQty\r\n            require(cSrcToken.approve(address(cKyberProxy), srcQty), \"approval to srcQty failed\");\r\n        }\r\n\r\n        // Get the minimum conversion rate\r\n        uint256 platformFeeBps = 25;    // using the Kyber example https://developer.kyber.network/docs/Integrations-SmartContractGuide/#fetching-rates\r\n        \r\n        uint256 minConversionRate = cKyberProxy.getExpectedRateAfterFee(\r\n            cSrcToken,\r\n            cDestToken,\r\n            srcQty,\r\n            platformFeeBps,\r\n            '' // empty hint\r\n        );\r\n        \r\n        \r\n        /*********************************************************************************\r\n         * function trade(ERC20 src, uint256 srcAmount,\r\n         *  ERC20 dest, address payable destAddress,\r\n         *  uint256 maxDestAmount,    // wei\r\n         * \r\n         *  uint256 minConversionRate,\r\n         *      Minimum conversion rate (in wei). Trade is canceled if actual rate is lower\r\n         *      Should match makerAssetAmount/takerAssetAmount\r\n         *      This rate means for every 1 srcAmount, a Minimum\r\n         *      of X target Tokens are expected. \r\n         *      (Source token value / Target Token value) * 10**18 \r\n         * \r\n         *  address payable platformWallet ) external payable returns (uint256);\r\n        **********************************************************************************/\r\n        // Execute the trade and send to this contract to use to pay down the unsafe account\r\n        uint256 destAmount = cKyberProxy.trade(cSrcToken, srcQty, \r\n            cDestToken, payable(address(this)), \r\n            maxDestAmount, \r\n            minConversionRate,\r\n            // this contract\r\n            destAddress);\r\n          \r\n        emit Swapped(address(cSrcToken), srcQty, address(cDestToken), destAmount);\r\n        return destAmount;\r\n    }\r\n}\r\n\r\n// These definitions are taken from across multiple dydx contracts, and are\r\n// limited to just the bare minimum necessary to make flash loans work.\r\nlibrary Types {\r\n    enum AssetDenomination { Wei, Par }\r\n    enum AssetReference { Delta, Target }\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Account {\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\r\n    }\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n"}}}