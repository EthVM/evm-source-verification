{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "UserRegistry.sol": {
      "content": "/**************************************************************************\r\n *            ____        _                              \r\n *           / ___|      | |     __ _  _   _   ___  _ __ \r\n *          | |    _____ | |    / _` || | | | / _ \\| '__|\r\n *          | |___|_____|| |___| (_| || |_| ||  __/| |   \r\n *           \\____|      |_____|\\__,_| \\__, | \\___||_|   \r\n *                                     |___/             \r\n * \r\n **************************************************************************\r\n *\r\n *  The MIT License (MIT)\r\n * SPDX-License-Identifier: MIT\r\n *\r\n * Copyright (c) 2016-2020 Cyril Lapinte\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n **************************************************************************\r\n *\r\n * Flatten Contract: UserRegistry\r\n *\r\n * Git Commit:\r\n * https://github.com/c-layer/contracts/commit/9993912325afde36151b04d0247ac9ea9ffa2a93\r\n *\r\n **************************************************************************/\r\n\r\n\r\n// File: @c-layer/common/contracts/operable/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * @dev functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n *\r\n * Error messages\r\n *   OW01: Message sender is not the owner\r\n *   OW02: New owner must be valid\r\n*/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"OW01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0), \"OW02\");\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: @c-layer/common/contracts/operable/Operable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n/**\r\n * @title Operable\r\n * @dev The Operable contract enable the restrictions of operations to a set of operators\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * OP01: Message sender must be an operator\r\n * OP02: Address must be an operator\r\n * OP03: Address must not be an operator\r\n */\r\ncontract Operable is Ownable {\r\n\r\n  mapping (address => bool) private operators_;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the operator\r\n   */\r\n  modifier onlyOperator {\r\n    require(operators_[msg.sender], \"OP01\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev constructor\r\n   */\r\n  constructor() public {\r\n    defineOperator(\"Owner\", msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev isOperator\r\n   * @param _address operator address\r\n   */\r\n  function isOperator(address _address) public view returns (bool) {\r\n    return operators_[_address];\r\n  }\r\n\r\n  /**\r\n   * @dev removeOperator\r\n   * @param _address operator address\r\n   */\r\n  function removeOperator(address _address) public onlyOwner {\r\n    require(operators_[_address], \"OP02\");\r\n    operators_[_address] = false;\r\n    emit OperatorRemoved(_address);\r\n  }\r\n\r\n  /**\r\n   * @dev defineOperator\r\n   * @param _role operator role\r\n   * @param _address operator address\r\n   */\r\n  function defineOperator(string memory _role, address _address)\r\n    public onlyOwner\r\n  {\r\n    require(!operators_[_address], \"OP03\");\r\n    operators_[_address] = true;\r\n    emit OperatorDefined(_role, _address);\r\n  }\r\n\r\n  event OperatorRemoved(address address_);\r\n  event OperatorDefined(\r\n    string role,\r\n    address address_\r\n  );\r\n}\r\n\r\n// File: contracts/interface/IUserRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title IUserRegistry\r\n * @dev IUserRegistry interface\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n **/\r\nabstract contract IUserRegistry {\r\n\r\n  enum KeyCode {\r\n    KYC_LIMIT_KEY,\r\n    RECEPTION_LIMIT_KEY,\r\n    EMISSION_LIMIT_KEY\r\n  }\r\n\r\n  event UserRegistered(uint256 indexed userId, address address_, uint256 validUntilTime);\r\n  event AddressAttached(uint256 indexed userId, address address_);\r\n  event AddressDetached(uint256 indexed userId, address address_);\r\n  event UserSuspended(uint256 indexed userId);\r\n  event UserRestored(uint256 indexed userId);\r\n  event UserValidity(uint256 indexed userId, uint256 validUntilTime);\r\n  event UserExtendedKey(uint256 indexed userId, uint256 key, uint256 value);\r\n  event UserExtendedKeys(uint256 indexed userId, uint256[] values);\r\n  event ExtendedKeysDefinition(uint256[] keys);\r\n\r\n  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\r\n    virtual external returns (bool);\r\n  function registerManyUsersFullExternal(\r\n    address[] calldata _addresses,\r\n    uint256 _validUntilTime,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n  function attachManyAddressesExternal(uint256[] calldata _userIds, address[] calldata _addresses)\r\n    virtual external returns (bool);\r\n  function detachManyAddressesExternal(address[] calldata _addresses)\r\n    virtual external returns (bool);\r\n  function suspendManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\r\n  function restoreManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\r\n  function updateManyUsersExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended) virtual external returns (bool);\r\n  function updateManyUsersExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _key, uint256 _value) virtual external returns (bool);\r\n  function updateManyUsersAllExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n  function updateManyUsersFullExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] calldata _values) virtual external returns (bool);\r\n\r\n  function name() virtual public view returns (string memory);\r\n  function currency() virtual public view returns (bytes32);\r\n\r\n  function userCount() virtual public view returns (uint256);\r\n  function userId(address _address) virtual public view returns (uint256);\r\n  function validUserId(address _address) virtual public view returns (uint256);\r\n  function validUser(address _address, uint256[] memory _keys)\r\n    virtual public view returns (uint256, uint256[] memory);\r\n  function validity(uint256 _userId) virtual public view returns (uint256, bool);\r\n\r\n  function extendedKeys() virtual public view returns (uint256[] memory);\r\n  function extended(uint256 _userId, uint256 _key)\r\n    virtual public view returns (uint256);\r\n  function manyExtended(uint256 _userId, uint256[] memory _key)\r\n    virtual public view returns (uint256[] memory);\r\n\r\n  function isAddressValid(address _address) virtual public view returns (bool);\r\n  function isValid(uint256 _userId) virtual public view returns (bool);\r\n\r\n  function defineExtendedKeys(uint256[] memory _extendedKeys) virtual public returns (bool);\r\n\r\n  function registerUser(address _address, uint256 _validUntilTime)\r\n    virtual public returns (bool);\r\n  function registerUserFull(\r\n    address _address,\r\n    uint256 _validUntilTime,\r\n    uint256[] memory _values) virtual public returns (bool);\r\n\r\n  function attachAddress(uint256 _userId, address _address) virtual public returns (bool);\r\n  function detachAddress(address _address) virtual public returns (bool);\r\n  function detachSelf() virtual public returns (bool);\r\n  function detachSelfAddress(address _address) virtual public returns (bool);\r\n  function suspendUser(uint256 _userId) virtual public returns (bool);\r\n  function restoreUser(uint256 _userId) virtual public returns (bool);\r\n  function updateUser(uint256 _userId, uint256 _validUntilTime, bool _suspended)\r\n    virtual public returns (bool);\r\n  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\r\n    virtual public returns (bool);\r\n  function updateUserAllExtended(uint256 _userId, uint256[] memory _values)\r\n    virtual public returns (bool);\r\n  function updateUserFull(\r\n    uint256 _userId,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] memory _values) virtual public returns (bool);\r\n}\r\n\r\n// File: contracts/UserRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title UserRegistry\r\n * @dev UserRegistry contract\r\n * Configure and manage users\r\n * Extended may be used externaly to store data within a user context\r\n *\r\n * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\r\n *\r\n * Error messages\r\n * UR01: UserId is invalid\r\n * UR02: WalletOwner is already known\r\n * UR03: Users length does not match with addresses\r\n * UR04: WalletOwner is unknown\r\n * UR05: Sender is not the wallet owner\r\n * UR06: User is already suspended\r\n * UR07: User is not suspended\r\n * UR08: Extended keys must exists for values\r\n*/\r\ncontract UserRegistry is IUserRegistry, Operable {\r\n\r\n  struct User {\r\n    uint256 validUntilTime;\r\n    bool suspended;\r\n    mapping(uint256 => uint256) extended;\r\n  }\r\n\r\n  uint256[] internal extendedKeys_ = [ 0, 1, 2 ];\r\n  mapping(uint256 => User) internal users;\r\n  mapping(address => uint256) internal walletOwners;\r\n  uint256 internal userCount_;\r\n\r\n  string internal name_;\r\n  bytes32 internal currency_;\r\n\r\n  /**\r\n   * @dev contructor\r\n   **/\r\n  constructor(\r\n    string memory _name,\r\n    bytes32 _currency,\r\n    address[] memory _addresses,\r\n    uint256 _validUntilTime) public\r\n  {\r\n    name_ = _name;\r\n    currency_ = _currency;\r\n    for (uint256 i = 0; i < _addresses.length; i++) {\r\n      registerUserPrivate(_addresses[i], _validUntilTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev register many users\r\n   */\r\n  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\r\n    override external onlyOperator returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _addresses.length; i++) {\r\n      registerUserPrivate(_addresses[i], _validUntilTime);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev register many users\r\n   */\r\n  function registerManyUsersFullExternal(\r\n    address[] calldata _addresses,\r\n    uint256 _validUntilTime,\r\n    uint256[] calldata _values) override external onlyOperator returns (bool)\r\n  {\r\n    require(_values.length <= extendedKeys_.length, \"UR08\");\r\n    for (uint256 i = 0; i < _addresses.length; i++) {\r\n      registerUserPrivate(_addresses[i], _validUntilTime);\r\n      updateUserExtendedPrivate(userCount_, _values);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev attach many addresses to many users\r\n   */\r\n  function attachManyAddressesExternal(\r\n    uint256[] calldata _userIds,\r\n    address[] calldata _addresses)\r\n    override external onlyOperator returns (bool)\r\n  {\r\n    require(_addresses.length == _userIds.length, \"UR03\");\r\n    for (uint256 i = 0; i < _addresses.length; i++) {\r\n      attachAddress(_userIds[i], _addresses[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev detach many addresses association between addresses and their respective users\r\n   */\r\n  function detachManyAddressesExternal(address[] calldata _addresses)\r\n    override external onlyOperator returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _addresses.length; i++) {\r\n      detachAddressPrivate(_addresses[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev suspend many users\r\n   */\r\n  function suspendManyUsersExternal(uint256[] calldata _userIds)\r\n    override external onlyOperator returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _userIds.length; i++) {\r\n      suspendUser(_userIds[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev restore many users\r\n   */\r\n  function restoreManyUsersExternal(uint256[] calldata _userIds)\r\n    override external onlyOperator returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _userIds.length; i++) {\r\n      restoreUser(_userIds[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update many users\r\n   */\r\n  function updateManyUsersExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended) override external onlyOperator returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _userIds.length; i++) {\r\n      updateUser(_userIds[i], _validUntilTime, _suspended);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update many user extended informations\r\n   */\r\n  function updateManyUsersExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _key, uint256 _value) override external onlyOperator returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _userIds.length; i++) {\r\n      updateUserExtended(_userIds[i], _key, _value);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update many user all extended informations\r\n   */\r\n  function updateManyUsersAllExtendedExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256[] calldata _values) override external onlyOperator returns (bool)\r\n  {\r\n    require(_values.length <= extendedKeys_.length, \"UR08\");\r\n    for (uint256 i = 0; i < _userIds.length; i++) {\r\n      updateUserExtendedPrivate(_userIds[i], _values);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update many users full\r\n   */\r\n  function updateManyUsersFullExternal(\r\n    uint256[] calldata _userIds,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] calldata _values) override external onlyOperator returns (bool)\r\n  {\r\n    require(_values.length <= extendedKeys_.length, \"UR08\");\r\n    for (uint256 i = 0; i < _userIds.length; i++) {\r\n      updateUser(_userIds[i], _validUntilTime, _suspended);\r\n      updateUserExtendedPrivate(_userIds[i], _values);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev user registry name\r\n   */\r\n  function name() override public view returns (string memory) {\r\n    return name_;\r\n  }\r\n\r\n  /**\r\n   * @dev user registry currency\r\n   */\r\n  function currency() override public view returns (bytes32) {\r\n    return currency_;\r\n  }\r\n\r\n  /**\r\n   * @dev number of user registered\r\n   */\r\n  function userCount() override public view returns (uint256) {\r\n    return userCount_;\r\n  }\r\n\r\n  /**\r\n   * @dev the userId associated to the provided address\r\n   */\r\n  function userId(address _address) override public view returns (uint256) {\r\n    return walletOwners[_address];\r\n  }\r\n\r\n  /**\r\n   * @dev the userId associated to the provided address if the user is valid\r\n   */\r\n  function validUserId(address _address) override public view returns (uint256) {\r\n    uint256 addressUserId = walletOwners[_address];\r\n    if (isValidPrivate(users[addressUserId])) {\r\n      return addressUserId;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * @dev the user associated to the provided address if the user is valid\r\n   */\r\n  function validUser(address _address, uint256[] memory _keys)\r\n    override public view returns (uint256, uint256[] memory)\r\n  {\r\n    uint256 addressUserId = walletOwners[_address];\r\n    if (isValidPrivate(users[addressUserId])) {\r\n      uint256[] memory values = new uint256[](_keys.length);\r\n      for (uint256 i=0; i < _keys.length; i++) {\r\n        values[i] = users[addressUserId].extended[_keys[i]];\r\n      }\r\n      return (addressUserId, values);\r\n    }\r\n    return (0, new uint256[](0));\r\n  }\r\n\r\n  /**\r\n   * @dev returns the time at which user validity ends\r\n   */\r\n  function validity(uint256 _userId)\r\n    override public view returns (uint256, bool) {\r\n    User memory user = users[_userId];\r\n    return (user.validUntilTime, user.suspended);\r\n  }\r\n\r\n  /**\r\n   * @dev extended keys\r\n   */\r\n  function extendedKeys() override public view returns (uint256[] memory) {\r\n    return extendedKeys_;\r\n  }\r\n\r\n  /**\r\n   * @dev access to extended user data\r\n   */\r\n  function extended(uint256 _userId, uint256 _key)\r\n    override public view returns (uint256)\r\n  {\r\n    return users[_userId].extended[_key];\r\n  }\r\n\r\n  /**\r\n   * @dev access to extended user data\r\n   */\r\n  function manyExtended(uint256 _userId, uint256[] memory _keys)\r\n    override public view returns (uint256[] memory values)\r\n  {\r\n    values = new uint256[](_keys.length);\r\n    for (uint256 i=0; i < _keys.length; i++) {\r\n      values[i] = users[_userId].extended[_keys[i]];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev validity of the current user\r\n   */\r\n  function isAddressValid(address _address) override public view returns (bool) {\r\n    return isValidPrivate(users[walletOwners[_address]]);\r\n  }\r\n\r\n  /**\r\n   * @dev validity of the current user\r\n   */\r\n  function isValid(uint256 _userId) override public view returns (bool) {\r\n    return isValidPrivate(users[_userId]);\r\n  }\r\n\r\n  /**\r\n   * @dev define extended keys\r\n   */\r\n  function defineExtendedKeys(uint256[] memory _extendedKeys)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    extendedKeys_ = _extendedKeys;\r\n    emit ExtendedKeysDefinition(_extendedKeys);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev register a user\r\n   */\r\n  function registerUser(address _address, uint256 _validUntilTime)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    registerUserPrivate(_address, _validUntilTime);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev register a user full\r\n   */\r\n  function registerUserFull(\r\n    address _address,\r\n    uint256 _validUntilTime,\r\n    uint256[] memory _values) override public onlyOperator returns (bool)\r\n  {\r\n    require(_values.length <= extendedKeys_.length, \"UR08\");\r\n    registerUserPrivate(_address, _validUntilTime);\r\n    updateUserExtendedPrivate(userCount_, _values);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev attach an address with a user\r\n   */\r\n  function attachAddress(uint256 _userId, address _address)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    require(_userId > 0 && _userId <= userCount_, \"UR01\");\r\n    require(walletOwners[_address] == 0, \"UR02\");\r\n    walletOwners[_address] = _userId;\r\n\r\n    emit AddressAttached(_userId, _address);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev detach the association between an address and its user\r\n   */\r\n  function detachAddress(address _address)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    detachAddressPrivate(_address);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev detach the association between an address and its user\r\n   */\r\n  function detachSelf() override public returns (bool) {\r\n    detachAddressPrivate(msg.sender);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev detach the association between an address and its user\r\n   */\r\n  function detachSelfAddress(address _address)\r\n    override public returns (bool)\r\n  {\r\n    require(\r\n      walletOwners[_address] == walletOwners[msg.sender],\r\n      \"UR05\");\r\n    detachAddressPrivate(_address);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev suspend a user\r\n   */\r\n  function suspendUser(uint256 _userId)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    require(_userId > 0 && _userId <= userCount_, \"UR01\");\r\n    require(!users[_userId].suspended, \"UR06\");\r\n    users[_userId].suspended = true;\r\n    emit UserSuspended(_userId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev restore a user\r\n   */\r\n  function restoreUser(uint256 _userId)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    require(_userId > 0 && _userId <= userCount_, \"UR01\");\r\n    require(users[_userId].suspended, \"UR07\");\r\n    users[_userId].suspended = false;\r\n    emit UserRestored(_userId);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update a user\r\n   */\r\n  function updateUser(\r\n    uint256 _userId,\r\n    uint256 _validUntilTime,\r\n    bool _suspended) override public onlyOperator returns (bool)\r\n  {\r\n    require(_userId > 0 && _userId <= userCount_, \"UR01\");\r\n    if (users[_userId].validUntilTime != _validUntilTime) {\r\n      users[_userId].validUntilTime = _validUntilTime;\r\n      emit UserValidity(_userId, _validUntilTime);\r\n    }\r\n\r\n    if (users[_userId].suspended != _suspended) {\r\n      users[_userId].suspended = _suspended;\r\n      if (_suspended) {\r\n        emit UserSuspended(_userId);\r\n      } else {\r\n        emit UserRestored(_userId);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update user extended information\r\n   */\r\n  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\r\n    override public onlyOperator returns (bool)\r\n  {\r\n    require(_userId > 0 && _userId <= userCount_, \"UR01\");\r\n    users[_userId].extended[_key] = _value;\r\n    emit UserExtendedKey(_userId, _key, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update user all extended information\r\n   */\r\n  function updateUserAllExtended(\r\n    uint256 _userId,\r\n    uint256[] memory _values) override public onlyOperator returns (bool)\r\n  {\r\n    require(_values.length <= extendedKeys_.length, \"UR08\");\r\n    updateUserExtendedPrivate(_userId, _values);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev update a user full\r\n   */\r\n  function updateUserFull(\r\n    uint256 _userId,\r\n    uint256 _validUntilTime,\r\n    bool _suspended,\r\n    uint256[] memory _values) override public onlyOperator returns (bool)\r\n  {\r\n    require(_values.length <= extendedKeys_.length, \"UR08\");\r\n    updateUser(_userId, _validUntilTime, _suspended);\r\n    updateUserExtendedPrivate(_userId, _values);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev register a user private\r\n   */\r\n  function registerUserPrivate(address _address, uint256 _validUntilTime)\r\n    private\r\n  {\r\n    require(walletOwners[_address] == 0, \"UR03\");\r\n    users[++userCount_] = User(_validUntilTime, false);\r\n    walletOwners[_address] = userCount_;\r\n\r\n    emit UserRegistered(userCount_, _address, _validUntilTime);\r\n  }\r\n\r\n  /**\r\n   * @dev update user extended private\r\n   */\r\n  function updateUserExtendedPrivate(uint256 _userId, uint256[] memory _values)\r\n    private\r\n  {\r\n    require(_userId > 0 && _userId <= userCount_, \"UR01\");\r\n    for (uint256 i = 0; i < _values.length; i++) {\r\n      users[_userId].extended[extendedKeys_[i]] = _values[i];\r\n    }\r\n    emit UserExtendedKeys(_userId, _values);\r\n  }\r\n\r\n  /**\r\n   * @dev detach the association between an address and its user\r\n   */\r\n  function detachAddressPrivate(address _address) private {\r\n    uint256 addressUserId = walletOwners[_address];\r\n    require(addressUserId != 0, \"UR04\");\r\n    emit AddressDetached(addressUserId, _address);\r\n    delete walletOwners[_address];\r\n  }\r\n\r\n  /**\r\n   * @dev validity of the current user\r\n   */\r\n  function isValidPrivate(User storage user) private view returns (bool) {\r\n    // solhint-disable-next-line not-rely-on-time\r\n    return !user.suspended && user.validUntilTime > now;\r\n  }\r\n}"
    }
  }
}