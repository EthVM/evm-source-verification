{
  "language": "Solidity",
  "sources": {
    "PairFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity 0.8.6;\n\nimport \"UpgradeableBeacon.sol\";\n\nimport \"IPairFactory.sol\";\nimport \"ILendingController.sol\";\nimport \"ILendingPair.sol\";\n\nimport \"SafeOwnable.sol\";\nimport \"AddressLibrary.sol\";\nimport \"BeaconProxyPayable.sol\";\n\nimport \"LendingPair.sol\";\n\ncontract PairFactory is IPairFactory, SafeOwnable {\n\n  using AddressLibrary for address;\n\n  UpgradeableBeacon public immutable lendingPairMaster;\n  address public immutable lpTokenMaster;\n  address public immutable uniV3Helper;\n  address public immutable feeRecipient;\n  ILendingController public immutable lendingController;\n\n  mapping(address => mapping(address => address)) public override pairByTokens;\n\n  event PairCreated(address indexed pair, address indexed tokenA, address indexed tokenB);\n\n  constructor(\n    address _lendingPairMaster,\n    address _lpTokenMaster,\n    address _uniV3Helper,\n    address _feeRecipient,\n    ILendingController _lendingController\n  ) {\n\n    require(_lendingPairMaster.isContract(), 'PairFactory: _lendingPairMaster must be a contract');\n    require(_lpTokenMaster.isContract(),     'PairFactory: _lpTokenMaster must be a contract');\n    require(_uniV3Helper.isContract(),       'PairFactory: _uniV3Helper must be a contract');\n    require(_feeRecipient.isContract(),      'PairFactory: _feeRecipient must be a contract');\n    require(address(_lendingController).isContract(), 'PairFactory: _lendingController must be a contract');\n\n    lendingPairMaster = UpgradeableBeacon(_lendingPairMaster);\n    lpTokenMaster     = _lpTokenMaster;\n    uniV3Helper       = _uniV3Helper;\n    feeRecipient      = _feeRecipient;\n    lendingController = _lendingController;\n  }\n\n  function createPair(\n    address _token0,\n    address _token1\n  ) external returns(address) {\n\n    require(_token0 != _token1, 'PairFactory: duplicate tokens');\n    require(_token0 != address(0) && _token1 != address(0), 'PairFactory: zero address');\n    require(pairByTokens[_token0][_token1] == address(0), 'PairFactory: already exists');\n\n    (address tokenA, address tokenB) = _token0 < _token1 ? (_token0, _token1) : (_token1, _token0);\n\n    require(\n      lendingController.tokenSupported(tokenA) && lendingController.tokenSupported(tokenB),\n      'PairFactory: token not supported'\n    );\n\n    address lendingPair = address(new BeaconProxyPayable(address(lendingPairMaster), \"\"));\n\n    ILendingPair(lendingPair).initialize(\n      lpTokenMaster,\n      address(lendingController),\n      uniV3Helper,\n      feeRecipient,\n      tokenA,\n      tokenB\n    );\n\n    pairByTokens[tokenA][tokenB] = lendingPair;\n    pairByTokens[tokenB][tokenA] = lendingPair;\n\n    emit PairCreated(lendingPair, tokenA, tokenB);\n\n    return lendingPair;\n  }\n}\n"
    },
    "UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IBeacon.sol\";\nimport \"Ownable.sol\";\nimport \"Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "IPairFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IPairFactory {\n  function pairByTokens(address _tokenA, address _tokenB) external view returns(address);\n}\n"
    },
    "ILendingController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ninterface ILendingController is IOwnable {\n  function interestRateModel() external view returns(address);\n  function liqFeeSystem(address _token) external view returns(uint);\n  function liqFeeCaller(address _token) external view returns(uint);\n  function uniMinOutputPct() external view returns(uint);\n  function colFactor(address _token) external view returns(uint);\n  function depositLimit(address _lendingPair, address _token) external view returns(uint);\n  function borrowLimit(address _lendingPair, address _token) external view returns(uint);\n  function depositsEnabled() external view returns(bool);\n  function borrowingEnabled() external view returns(bool);\n  function tokenPrice(address _token) external view returns(uint);\n  function minBorrow(address _token) external view returns(uint);\n  function tokenPrices(address _tokenA, address _tokenB) external view returns (uint, uint);\n  function tokenSupported(address _token) external view returns(bool);\n}\n"
    },
    "IOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IOwnable {\n  function owner() external view returns(address);\n  function transferOwnership(address _newOwner) external;\n  function acceptOwnership() external;\n}"
    },
    "ILendingPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface ILendingPair {\n\n  function tokenA() external view returns(address);\n  function tokenB() external view returns(address);\n  function lpToken(address _token) external view returns(address);\n  function deposit(address _account, address _token, uint _amount) external;\n  function withdraw(address _token, uint _amount) external;\n  function withdrawAll(address _token) external;\n  function transferLp(address _token, address _from, address _to, uint _amount) external;\n  function supplySharesOf(address _token, address _account) external view returns(uint);\n  function totalSupplyShares(address _token) external view returns(uint);\n  function totalSupplyAmount(address _token) external view returns(uint);\n  function totalDebtShares(address _token) external view returns(uint);\n  function totalDebtAmount(address _token) external view returns(uint);\n  function supplyOf(address _token, address _account) external view returns(uint);\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view returns(uint);\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external;\n}"
    },
    "SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ncontract SafeOwnable is IOwnable {\n\n  uint public constant RENOUNCE_TIMEOUT = 1 hours;\n\n  address public override owner;\n  address public pendingOwner;\n  uint public renouncedAt;\n\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\n  }\n\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function isOwner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function transferOwnership(address _newOwner) external override onlyOwner {\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferInitiated(owner, _newOwner);\n    pendingOwner = _newOwner;\n  }\n\n  function acceptOwnership() external override {\n    require(msg.sender == pendingOwner, \"Ownable: caller is not pending owner\");\n    emit OwnershipTransferConfirmed(msg.sender, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  function initiateRenounceOwnership() external onlyOwner {\n    require(renouncedAt == 0, \"Ownable: already initiated\");\n    renouncedAt = block.timestamp;\n  }\n\n  function acceptRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    require(block.timestamp - renouncedAt > RENOUNCE_TIMEOUT, \"Ownable: too early\");\n    owner = address(0);\n    pendingOwner = address(0);\n    renouncedAt = 0;\n  }\n\n  function cancelRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    renouncedAt = 0;\n  }\n}"
    },
    "AddressLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressLibrary {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"
    },
    "BeaconProxyPayable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity 0.8.6;\n\nimport \"BeaconProxy.sol\";\n\ncontract BeaconProxyPayable is BeaconProxy {\n\n  receive() external payable override {\n    // Only from the WETH contract\n    require(msg.sender == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \"LendingPair: not WETH\");\n  }\n\n  constructor(address beacon, bytes memory data) payable BeaconProxy(beacon, data) { }\n}\n"
    },
    "BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IBeacon.sol\";\nimport \"Proxy.sol\";\nimport \"ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"IBeacon.sol\";\nimport \"Address.sol\";\nimport \"StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "LendingPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity 0.8.6;\n\nimport \"IERC20.sol\";\nimport \"IERC721.sol\";\nimport \"ILPTokenMaster.sol\";\nimport \"ILendingPair.sol\";\nimport \"ILendingController.sol\";\nimport \"IInterestRateModel.sol\";\nimport \"IUniswapV3Helper.sol\";\nimport \"INonfungiblePositionManagerSimple.sol\";\n\nimport \"Math.sol\";\nimport \"Clones.sol\";\nimport \"ReentrancyGuard.sol\";\nimport \"AddressLibrary.sol\";\n\nimport \"LPTokenMaster.sol\";\n\nimport \"ERC721Receivable.sol\";\nimport \"TransferHelper.sol\";\n\ncontract LendingPair is ILendingPair, ReentrancyGuard, TransferHelper, ERC721Receivable {\n\n  INonfungiblePositionManagerSimple internal constant positionManager = INonfungiblePositionManagerSimple(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  IERC721 internal constant uniPositions = IERC721(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\n  uint    public   constant LIQ_MIN_HEALTH = 1e18;\n  uint    private  constant MIN_DECIMALS = 6;\n\n  using AddressLibrary for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public override supplySharesOf;\n  mapping (address => mapping (address => uint)) public debtSharesOf;\n  mapping (address => uint) public pendingSystemFees;\n  mapping (address => uint) public lastBlockAccrued;\n  mapping (address => uint) public override totalSupplyShares;\n  mapping (address => uint) public override totalSupplyAmount;\n  mapping (address => uint) public override totalDebtShares;\n  mapping (address => uint) public override totalDebtAmount;\n  mapping (address => uint) public uniPosition;\n  mapping (address => uint) private decimals;\n  mapping (address => address) public override lpToken;\n\n  IUniswapV3Helper   private uniV3Helper;\n  ILendingController public  lendingController;\n\n  address public feeRecipient;\n  address public override tokenA;\n  address public override tokenB;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed account, address indexed token, uint amount);\n  event Borrow(address indexed account, address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n  event CollectSystemFee(address indexed token, uint amount);\n  event DepositUniPosition(address indexed account, uint positionID);\n  event WithdrawUniPosition(address indexed account, uint positionID);\n\n  modifier onlyLpToken() {\n    require(lpToken[tokenA] == msg.sender || lpToken[tokenB] == msg.sender, \"LendingController: caller must be LP token\");\n    _;\n  }\n\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external override {\n    require(tokenA == address(0), \"LendingPair: already initialized\");\n\n    lendingController = ILendingController(_lendingController);\n    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);\n    feeRecipient      = _feeRecipient;\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    lastBlockAccrued[tokenA] = block.number;\n    lastBlockAccrued[tokenB] = block.number;\n\n    decimals[tokenA] = IERC20(tokenA).decimals();\n    decimals[tokenB] = IERC20(tokenB).decimals();\n\n    require(decimals[tokenA] >= MIN_DECIMALS && decimals[tokenB] >= MIN_DECIMALS, \"LendingPair: MIN_DECIMALS\");\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);\n  }\n\n  // Deposit limits do not apply to Uniswap positions\n  function depositUniPosition(address _account, uint _positionID) external nonReentrant {\n    _checkDepositsEnabled();\n    _validateUniPosition(_positionID);\n    require(_positionID > 0, \"LendingPair: invalid position\");\n    require(uniPosition[_account] == 0, \"LendingPair: one position per account\");\n\n    uniPositions.safeTransferFrom(msg.sender, address(this), _positionID);\n    uniPosition[_account] = _positionID;\n\n    emit DepositUniPosition(_account, _positionID);\n  }\n\n  function withdrawUniPosition() external nonReentrant {\n    uint positionID = uniPosition[msg.sender];\n    require(positionID > 0, \"LendingPair: nothing to withdraw\");\n    uniPositions.safeTransferFrom(address(this), msg.sender, positionID);\n    uniPosition[msg.sender] = 0;\n\n    accrue(tokenA);\n    accrue(tokenB);\n    checkAccountHealth(msg.sender);\n\n    emit WithdrawUniPosition(msg.sender, positionID);\n  }\n\n  // claim & mint supply from uniswap fees\n  function uniClaimDeposit() external nonReentrant {\n    accrue(tokenA);\n    accrue(tokenB);\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _mintSupplyAmount(tokenA, msg.sender, amountA);\n    _mintSupplyAmount(tokenB, msg.sender, amountB);\n  }\n\n  // claim & withdraw uniswap fees\n  function uniClaimWithdraw() external nonReentrant {\n    (uint amountA, uint amountB) = _uniCollectFees(msg.sender);\n    _safeTransfer(tokenA, msg.sender, amountA);\n    _safeTransfer(tokenB, msg.sender, amountB);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n  }\n\n  function withdraw(address _token, uint _amount) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _withdrawShares(_token, _supplyToShares(_token, _amount));\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external override nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint shares = supplySharesOf[_token][msg.sender];\n    uint amount = _sharesToSupply(_token, shares);\n    _withdrawShares(_token, shares);\n    _safeTransfer(_token, msg.sender, amount);\n  }\n\n  function withdrawAllETH() external nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint shares = supplySharesOf[address(WETH)][msg.sender];\n    uint amount = _sharesToSupply(address(WETH), shares);\n    _withdrawShares(address(WETH), shares);\n    _wethWithdrawTo(msg.sender, amount);\n  }\n\n  function borrow(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _borrow(_token, _amount);\n    _safeTransfer(_token, msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token, uint _maxAmount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    uint amount = _repayShares(_account, _token, debtSharesOf[_token][_account]);\n    require(amount <= _maxAmount, \"LendingPair: amount <= _maxAmount\");\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account) external payable nonReentrant {\n    _validateToken(address(WETH));\n    accrue(address(WETH));\n\n    uint amount = _repayShares(_account, address(WETH), debtSharesOf[address(WETH)][_account]);\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n\n    _depositWeth();\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    accrue(_token);\n\n    _repayShares(_account, _token, _debtToShares(_token, _amount));\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue(address _token) public {\n    if (lastBlockAccrued[_token] < block.number) {\n      uint newDebt   = _accrueDebt(_token);\n      uint newSupply = newDebt * _lpRate(_token) / 100e18;\n      totalSupplyAmount[_token] += newSupply;\n      pendingSystemFees[_token] += (newDebt - newSupply);\n      lastBlockAccrued[_token]   = block.number;\n    }\n  }\n\n  function collectSystemFee(address _token, uint _amount) external nonReentrant {\n    _validateToken(_token);\n    pendingSystemFees[_token] -= _amount;\n    _safeTransfer(_token, feeRecipient, _amount);\n    emit CollectSystemFee(_token, _amount);\n  }\n\n  function transferLp(address _token, address _from, address _to, uint _amount) external override onlyLpToken {\n    require(debtSharesOf[_token][_to] == 0, \"LendingPair: cannot receive borrowed token\");\n    supplySharesOf[_token][_from] -= _amount;\n    supplySharesOf[_token][_to]   += _amount;\n    checkAccountHealth(_from);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to type(uint).max to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external nonReentrant {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    accrue(supplyToken);\n    accrue(_repayToken);\n\n    uint health = accountHealth(_account);\n    require(health < LIQ_MIN_HEALTH, \"LendingPair: account health < LIQ_MIN_HEALTH\");\n\n    // Fully unwrap Uni position - withdraw & mint supply\n\n    _unwrapUniPosition(_account);\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, _debtOf(_repayToken, _account));\n    (uint repayPrice, uint supplyPrice) = lendingController.tokenPrices(_repayToken, supplyToken);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount, repayPrice, supplyPrice);\n    uint callerFee    = supplyDebt * lendingController.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * lendingController.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupplyShares(supplyToken, _account, _supplyToShares(supplyToken, supplyBurn));\n    pendingSystemFees[supplyToken] += systemFee;\n    _burnDebtShares(_repayToken, _account, _debtToShares(_repayToken, _repayAmount));\n\n    // Uni position unwrapping can mint supply of already borrowed tokens\n\n    _repayDebtFromSupply(_account, tokenA);\n    _repayDebtFromSupply(_account, tokenB);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _mintSupplyAmount(supplyToken, msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  // Compare all supply & borrow balances converted into the the same token - tokenA\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtSharesOf[tokenA][_account] == 0 && debtSharesOf[tokenB][_account] == 0) {\n      return LIQ_MIN_HEALTH;\n    }\n\n    (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n    uint colFactorA = lendingController.colFactor(tokenA);\n    uint colFactorB = lendingController.colFactor(tokenB);\n\n    uint creditA   = _supplyOf(tokenA, _account) * colFactorA / 100e18;\n    uint creditB   = _supplyBalanceConverted(_account, tokenB, tokenA, priceB, priceA) * colFactorB / 100e18;\n    uint creditUni = _convertedCreditAUni(_account, priceA, priceB, colFactorA, colFactorB);\n\n    uint totalAccountSupply = creditA + creditB + creditUni;\n\n    uint totalAccountBorrow = _debtOf(tokenA, _account) + _borrowBalanceConverted(_account, tokenB, tokenA, priceB, priceA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrow;\n  }\n\n  function debtOf(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _debtOf(_token, _account);\n  }\n\n  function supplyOf(address _token, address _account) external view override returns(uint) {\n    _validateToken(_token);\n    return _supplyOf(_token, _account);\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    (uint borrowPrice, uint returnPrice) = lendingController.tokenPrices(_borrowedToken, _returnToken);\n    return _borrowBalanceConverted(_account, _borrowedToken, _returnToken, borrowPrice, returnPrice);\n  }\n\n  function supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view override returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    (uint supplyPrice, uint returnPrice) = lendingController.tokenPrices(_suppliedToken, _returnToken);\n    return _supplyBalanceConverted(_account, _suppliedToken, _returnToken, supplyPrice, returnPrice);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    if (totalSupplyAmount[_token] == 0 || totalDebtAmount[_token] == 0) { return 0; }\n    uint utilizationRate = totalDebtAmount[_token] * 100e18 / totalSupplyAmount[_token];\n    return _interestRatePerBlock(_token) * utilizationRate * _lpRate(_token) / 100e18 / 100e18;\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _interestRatePerBlock(_token);\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= LIQ_MIN_HEALTH, \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    (uint fromPrice, uint toPrice) = lendingController.tokenPrices(_fromToken, _toToken);\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount, fromPrice, toPrice);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt          = _debtOf(_token, _account);\n    uint repayAmount   = debt > _amount ? _amount : debt;\n    uint depositAmount = _amount - repayAmount;\n\n    if (repayAmount > 0) {\n      _repayShares(_account, _token, _debtToShares(_token, repayAmount));\n    }\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount   = _supplyOf(_token, msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n    uint borrowAmount   = _amount - withdrawAmount;\n\n    if (withdrawAmount > 0) {\n      _withdrawShares(_token, _supplyToShares(_token, withdrawAmount));\n    }\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  // Uses price oracle to estimate min outputs to reduce MEV\n  // Liquidation might be temporarily unavailable due to this\n  function _unwrapUniPosition(address _account) internal {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint priceA, uint priceB) = lendingController.tokenPrices(tokenA, tokenB);\n      (uint amount0, uint amount1) = _positionAmounts(uniPosition[_account], priceA, priceB);\n      uint uniMinOutput = lendingController.uniMinOutputPct();\n\n      uniPositions.approve(address(uniV3Helper), uniPosition[_account]);\n      (uint amountA, uint amountB) = uniV3Helper.removeLiquidity(\n        uniPosition[_account],\n        amount0 * uniMinOutput / 100e18,\n        amount1 * uniMinOutput / 100e18\n      );\n      uniPosition[_account] = 0;\n\n      _mintSupplyAmount(tokenA, _account, amountA);\n      _mintSupplyAmount(tokenB, _account, amountB);\n    }\n  }\n\n  // Ensure we never have borrow + supply balances of the same token on the same account\n  function _repayDebtFromSupply(address _account, address _token) internal {\n\n    uint burnAmount = Math.min(_debtOf(_token, _account), _supplyOf(_token, _account));\n\n    if (burnAmount > 0) {\n      _burnDebtShares(_token, _account, _debtToShares(_token, burnAmount));\n      _burnSupplyShares(_token, _account, _supplyToShares(_token, burnAmount));\n    }\n  }\n\n  function _uniCollectFees(address _account) internal returns(uint, uint) {\n    uniPositions.approve(address(uniV3Helper), uniPosition[_account]);\n    return uniV3Helper.collectFees(uniPosition[_account]);\n  }\n\n  function _mintSupplyAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _supplyToShares(_token, _amount);\n      supplySharesOf[_token][_account] += shares;\n      totalSupplyShares[_token] += shares;\n      totalSupplyAmount[_token] += _amount;\n    }\n  }\n\n  function _burnSupplyShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      // Fix rounding error which can make issues during depositRepay / withdrawBorrow\n      if (supplySharesOf[_token][_account] - _shares == 1) { _shares += 1; }\n      amount = _sharesToSupply(_token, _shares);\n      supplySharesOf[_token][_account] -= _shares;\n      totalSupplyShares[_token] -= _shares;\n      totalSupplyAmount[_token] -= amount;\n    }\n  }\n\n  function _mintDebtAmount(address _token, address _account, uint _amount) internal returns(uint shares) {\n    if (_amount > 0) {\n      shares = _debtToShares(_token, _amount);\n      debtSharesOf[_token][_account] += shares;\n      totalDebtShares[_token] += shares;\n      totalDebtAmount[_token] += _amount;\n    }\n  }\n\n  function _burnDebtShares(address _token, address _account, uint _shares) internal returns(uint amount) {\n    if (_shares > 0) {\n      // Fix rounding error which can make issues during depositRepay / withdrawBorrow\n      if (debtSharesOf[_token][_account] - _shares == 1) { _shares += 1; }\n      amount = _sharesToDebt(_token, _shares);\n      debtSharesOf[_token][_account] -= _shares;\n      totalDebtShares[_token] -= _shares;\n      totalDebtAmount[_token] -= amount;\n    }\n  }\n\n  function _accrueDebt(address _token) internal returns(uint newDebt) {\n    if (totalDebtAmount[_token] > 0) {\n      uint blocksElapsed = block.number - lastBlockAccrued[_token];\n      uint pendingInterestRate = _interestRatePerBlock(_token) * blocksElapsed;\n      newDebt = totalDebtAmount[_token] * pendingInterestRate / 100e18;\n      totalDebtAmount[_token] += newDebt;\n    }\n  }\n\n  function _withdrawShares(address _token, uint _shares) internal {\n    uint amount = _burnSupplyShares(_token, msg.sender, _shares);\n    checkAccountHealth(msg.sender);\n    emit Withdraw(msg.sender, _token, amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(supplySharesOf[_token][msg.sender] == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _checkBorrowEnabled();\n    _checkBorrowLimits(_token, msg.sender, _amount);\n\n    _mintDebtAmount(_token, msg.sender, _amount);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(msg.sender, _token, _amount);\n  }\n\n  function _repayShares(address _account, address _token, uint _shares) internal returns(uint amount) {\n    amount = _burnDebtShares(_token, _account, _shares);\n    emit Repay(_account, _token, amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    require(debtSharesOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _checkDepositsEnabled();\n    _checkDepositLimit(_token, _amount);\n    _mintSupplyAmount(_token, _account, _amount);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _createLpToken(address _lpTokenMaster, address _underlying) internal returns(address) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize(_underlying, address(lendingController));\n    return address(newLPToken);\n  }\n\n  function _amountToShares(uint _totalShares, uint _totalAmount, uint _inputSupply) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputSupply * _totalShares / _totalAmount;\n    } else {\n      return _inputSupply;\n    }\n  }\n\n  function _sharesToAmount(uint _totalShares, uint _totalAmount, uint _inputShares) internal view returns(uint) {\n    if (_totalShares > 0 && _totalAmount > 0) {\n      return _inputShares * _totalAmount / _totalShares;\n    } else {\n      return _inputShares;\n    }\n  }\n\n  function _debtToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalDebtShares[_token], totalDebtAmount[_token], _amount);\n  }\n\n  function _sharesToDebt(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalDebtShares[_token], totalDebtAmount[_token], _shares);\n  }\n\n  function _supplyToShares(address _token, uint _amount) internal view returns(uint) {\n    return _amountToShares(totalSupplyShares[_token], totalSupplyAmount[_token], _amount);\n  }\n\n  function _sharesToSupply(address _token, uint _shares) internal view returns(uint) {\n    return _sharesToAmount(totalSupplyShares[_token], totalSupplyAmount[_token], _shares);\n  }\n\n  function _debtOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToDebt(_token, debtSharesOf[_token][_account]);\n  }\n\n  function _supplyOf(address _token, address _account) internal view returns(uint) {\n    return _sharesToSupply(_token, supplySharesOf[_token][_account]);\n  }\n\n  function _interestRatePerBlock(address _token) internal view returns(uint) {\n    return _interestRateModel().interestRatePerBlock(\n      address(this),\n      _token,\n      totalSupplyAmount[_token],\n      totalDebtAmount[_token]\n    );\n  }\n\n  function _interestRateModel() internal view returns(IInterestRateModel) {\n    return IInterestRateModel(lendingController.interestRateModel());\n  }\n\n  // Get borrow balance converted to the units of _returnToken\n  function _borrowBalanceConverted(\n    address _account,\n    address _borrowedToken,\n    address _returnToken,\n    uint    _borrowPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _borrowedToken,\n      _returnToken,\n      _debtOf(_borrowedToken, _account),\n      _borrowPrice,\n      _returnPrice\n    );\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalanceConverted(\n    address _account,\n    address _suppliedToken,\n    address _returnToken,\n    uint    _supplyPrice,\n    uint    _returnPrice\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(\n      _suppliedToken,\n      _returnToken,\n      _supplyOf(_suppliedToken, _account),\n      _supplyPrice,\n      _returnPrice\n    );\n  }\n\n  function _convertedCreditAUni(\n    address _account,\n    uint    _priceA,\n    uint    _priceB,\n    uint    _colFactorA,\n    uint    _colFactorB\n  ) internal view returns(uint) {\n\n    if (uniPosition[_account] > 0) {\n\n      (uint amountA, uint amountB) = _positionAmounts(uniPosition[_account], _priceA, _priceB);\n\n      uint creditA = amountA * _colFactorA / 100e18;\n      uint creditB = _convertTokenValues(tokenB, tokenA, amountB, _priceB, _priceA) * _colFactorB / 100e18;\n\n      return (creditA + creditB);\n\n    } else {\n      return 0;\n    }\n  }\n\n  function _positionAmounts(\n    uint _position,\n    uint _priceA,\n    uint _priceB\n  ) internal view returns(uint, uint) {\n\n    uint priceA = 1 * 10 ** decimals[tokenB];\n    uint priceB = _priceB * 10 ** decimals[tokenA] / _priceA;\n\n    return uniV3Helper.positionAmounts(_position, priceA, priceB);\n  }\n\n  // Not calling priceOracle.convertTokenValues() to save gas by reusing already fetched prices\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount,\n    uint    _fromPrice,\n    uint    _toPrice\n  ) internal view returns(uint) {\n\n    uint fromPrice = _fromPrice * 1e18 / 10 ** decimals[_fromToken];\n    uint toPrice   = _toPrice   * 1e18 / 10 ** decimals[_toToken];\n\n    return _inputAmount * fromPrice / toPrice;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _validateUniPosition(uint _positionID) internal view {\n    (, , address uniTokenA, address uniTokenB, , , , uint liquidity, , , ,) = positionManager.positions(_positionID);\n    require(liquidity > 0, \"LendingPair: liquidity > 0\");\n    _validateToken(uniTokenA);\n    _validateToken(uniTokenB);\n  }\n\n  function _checkDepositsEnabled() internal view {\n    require(lendingController.depositsEnabled(), \"LendingPair: deposits disabled\");\n  }\n\n  function _checkBorrowEnabled() internal view {\n    require(lendingController.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n  }\n\n  function _checkDepositLimit(address _token, uint _amount) internal view {\n    uint depositLimit = lendingController.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require(\n        totalSupplyAmount[_token] + _amount <= depositLimit,\n        \"LendingPair: deposit limit reached\"\n      );\n    }\n  }\n\n  function _checkBorrowLimits(address _token, address _account, uint _amount) internal view {\n    require(\n      _debtOf(_token, _account) + _amount >= lendingController.minBorrow(_token),\n      \"LendingPair: borrow amount below minimum\"\n    );\n\n    uint borrowLimit = lendingController.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebtAmount[_token] + _amount <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return _interestRateModel().lpRate(address(this), _token);\n  }\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address account) external view returns(uint);\n  function transfer(address recipient, uint256 amount) external returns(bool);\n  function allowance(address owner, address spender) external view returns(uint);\n  function decimals() external view returns(uint8);\n  function approve(address spender, uint amount) external returns(bool);\n  function transferFrom(address sender, address recipient, uint amount) external returns(bool);\n}"
    },
    "IERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IERC721 {\n\n  function approve(address to, uint tokenId) external;\n  function ownerOf(uint _tokenId) external view returns (address);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint tokenId\n  ) external;\n}\n"
    },
    "ILPTokenMaster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\nimport \"IERC20.sol\";\n\ninterface ILPTokenMaster is IOwnable, IERC20 {\n  function initialize(address _underlying, address _lendingController) external;\n  function underlying() external view returns(address);\n  function lendingPair() external view returns(address);\n}\n"
    },
    "IInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IInterestRateModel {\n  function lpRate(address _pair, address _token) external view returns(uint);\n  function interestRatePerBlock(address _pair, address _token, uint _totalSupply, uint _totalDebt) external view returns(uint);\n}"
    },
    "IUniswapV3Helper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >0.7.0;\n\ninterface IUniswapV3Helper {\n  function removeLiquidity(uint _tokenId, uint _minOutput0, uint _minOutput1) external returns (uint, uint);\n  function collectFees(uint _tokenId) external returns (uint amount0, uint amount1);\n  function positionTokens(uint _tokenId) external view returns(address, address);\n  function positionAmounts(uint _tokenId, uint _price0, uint _price1) external view returns(uint, uint);\n}"
    },
    "INonfungiblePositionManagerSimple.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\n// We can't use full INonfungiblePositionManager as provided by Uniswap since it's on Solidity 0.7\n\ninterface INonfungiblePositionManagerSimple {\n\n  function positions(uint256 tokenId)\n    external\n    view\n    returns (\n      uint96 nonce,\n      address operator,\n      address token0,\n      address token1,\n      uint24 fee,\n      int24 tickLower,\n      int24 tickUpper,\n      uint128 liquidity,\n      uint256 feeGrowthInside0LastX128,\n      uint256 feeGrowthInside1LastX128,\n      uint128 tokensOwed0,\n      uint128 tokensOwed1\n    );\n}"
    },
    "Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nlibrary Math {\n\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow, so we distribute.\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n  }\n\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a / b + (a % b == 0 ? 0 : 1);\n  }\n}"
    },
    "Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}"
    },
    "ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ncontract ReentrancyGuard {\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor () {\n    _status = _NOT_ENTERED;\n  }\n\n  modifier nonReentrant() {\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n    _status = _ENTERED;\n    _;\n    _status = _NOT_ENTERED;\n  }\n}"
    },
    "LPTokenMaster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity 0.8.6;\n\nimport \"ILPTokenMaster.sol\";\nimport \"ILendingPair.sol\";\nimport \"ILendingController.sol\";\nimport \"SafeOwnable.sol\";\n\ncontract LPTokenMaster is ILPTokenMaster, SafeOwnable {\n\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event NameChange(string _name, string _symbol);\n\n  mapping (address => mapping (address => uint)) public override allowance;\n\n  address public override underlying;\n  address public lendingController;\n  string  public constant name = \"WILD-LP\";\n  string  public constant symbol = \"WILD-LP\";\n  uint8   public constant override decimals = 18;\n  bool    private initialized;\n\n  modifier onlyOperator() {\n    require(msg.sender == ILendingController(lendingController).owner(), \"LPToken: caller is not an operator\");\n    _;\n  }\n\n  function initialize(address _underlying, address _lendingController) external override {\n    require(initialized != true, \"LPToken: already intialized\");\n    owner = msg.sender;\n    underlying = _underlying;\n    lendingController = _lendingController;\n    initialized = true;\n  }\n\n  function transfer(address _recipient, uint _amount) external override returns(bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  function approve(address _spender, uint _amount) external override returns(bool) {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  function transferFrom(address _sender, address _recipient, uint _amount) external override returns(bool) {\n    _approve(_sender, msg.sender, allowance[_sender][msg.sender] - _amount);\n    _transfer(_sender, _recipient, _amount);\n    return true;\n  }\n\n  function lendingPair() external view override returns(address) {\n    return owner;\n  }\n\n  function balanceOf(address _account) external view override returns(uint) {\n    return ILendingPair(owner).supplySharesOf(underlying, _account);\n  }\n\n  function totalSupply() external view override returns(uint) {\n    return ILendingPair(owner).totalSupplyShares(underlying);\n  }\n\n  function _transfer(address _sender, address _recipient, uint _amount) internal {\n    require(_sender != address(0), \"ERC20: transfer from the zero address\");\n    require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    ILendingPair(owner).transferLp(underlying, _sender, _recipient, _amount);\n\n    emit Transfer(_sender, _recipient, _amount);\n  }\n\n  function _approve(address _owner, address _spender, uint _amount) internal {\n    require(_owner != address(0), \"ERC20: approve from the zero address\");\n    require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n    allowance[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n}"
    },
    "ERC721Receivable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) WildCredit - All rights reserved\n// https://twitter.com/WildCredit\n\npragma solidity >0.7.0;\n\ncontract ERC721Receivable {\n\n  function onERC721Received(\n    address _operator,\n    address _user,\n    uint _tokenId,\n    bytes memory _data\n  ) public returns (bytes4) {\n    return 0x150b7a02;\n  }\n}\n"
    },
    "TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"IWETH.sol\";\nimport \"IERC20.sol\";\nimport \"SafeERC20.sol\";\n\ncontract TransferHelper {\n\n  using SafeERC20 for IERC20;\n\n  // Mainnet\n  IWETH internal constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  // Goerli\n  // IWETH internal constant WETH = IWETH(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6);\n\n  function _safeTransferFrom(address _token, address _sender, uint _amount) internal {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    IERC20(_token).safeTransferFrom(_sender, address(this), _amount);\n  }\n\n  function _safeTransfer(address _token, address _recipient, uint _amount) internal {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    IERC20(_token).safeTransfer(_recipient, _amount);\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    require(_to != address(0), \"TransferHelper: invalid recipient\");\n\n    WETH.withdraw(_amount);\n    (bool success, ) = _to.call { value: _amount }(new bytes(0));\n    require(success, 'TransferHelper: ETH transfer failed');\n  }\n\n  function _depositWeth() internal {\n    require(msg.value > 0, \"TransferHelper: amount must be > 0\");\n    WETH.deposit { value: msg.value }();\n  }\n}\n"
    },
    "IWETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IERC20.sol\";\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n}\n"
    },
    "SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"IERC20.sol\";\nimport \"SafeMath.sol\";\nimport \"AddressLibrary.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using AddressLibrary for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"
    },
    "SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}