{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "t2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n‚ñÑ‚ñÑ‚ñà    ‚ñÑ   ‚ñà‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñà \n‚ñà‚ñà     ‚ñà  ‚ñà ‚ñà  ‚ñà  ‚ñÑ‚ñÄ ‚ñà‚ñà \n‚ñà‚ñà ‚ñà‚ñà   ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÄ‚ñÄ‚ñå  ‚ñà‚ñà \n‚ñê‚ñà ‚ñà ‚ñà  ‚ñà ‚ñà  ‚ñà ‚ñà  ‚ñà  ‚ñê‚ñà \n ‚ñê ‚ñà  ‚ñà ‚ñà    ‚ñà   ‚ñà    ‚ñê \n   ‚ñà   ‚ñà‚ñà   ‚ñà   ‚ñÄ   \n           ‚ñÄ          */\n/// ü¶äüåæ Special thanks to Keno / Boring / Gonpachi / Karbon for review and continued inspiration.\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\n/// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n/// @notice Interface for Dai Stablecoin (DAI) `permit()` primitive.\ninterface IDaiPermit {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\n/// License-Identifier: MIT\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0\n/// License-Identifier: MIT\n\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success && revertOnFail) {\n                revert(_getRevertMsg(result));\n            }\n        }\n    }\n}\n\n/// @notice Extends `BoringBatchable` with DAI `permit()`.\ncontract BoringBatchableWithDai is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` using EIP 2612 primitive.\n    /// Lookup `IDaiPermit.permit`.\n    function permitDai(\n        IDaiPermit token,\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(holder, spender, nonce, expiry, allowed, v, r, s);\n    }\n    \n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary Babylonian {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n\n/// @notice Interface for SushiSwap.\ninterface ISushiSwap {\n    function factory() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    \n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\n/// @notice Interface for wrapped ether v9.\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\n/// @notice Library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math).\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n/// @notice Library for SushiSwap.\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = ISushiSwap(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n\n/// @notice Helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false.\nlibrary TransferHelper {\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n}\n\n/// @notice Router for SushiSwaps.\ncontract UniswapV2Router02 {\n    using SafeMath for uint;\n\n    address constant factory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            ISushiSwap(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n}\n\n/// @notice Interface for depositing into and withdrawing from Aave lending pool.\ninterface IAaveBridge {\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n    function deposit( \n        address asset, \n        uint256 amount, \n        address onBehalfOf, \n        uint16 referralCode\n    ) external;\n\n    function withdraw( \n        address token, \n        uint256 amount, \n        address destination\n    ) external;\n}\n\n/// @notice Interface for depositing into and withdrawing from BentoBox vault.\ninterface IBentoBridge {\n    function balanceOf(IERC20, address) external view returns (uint256);\n    \n    function registerProtocol() external;\n    \n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function deposit( \n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\n/// @notice Interface for depositing into and withdrawing from Compound finance protocol.\ninterface ICompoundBridge {\n    function underlying() external view returns (address);\n    function mint(uint mintAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n}\n\n/// @notice Interface for depositing into and withdrawing from SushiBar.\ninterface ISushiBarBridge { \n    function enter(uint256 amount) external;\n    function leave(uint256 share) external;\n}\n\n/// @notice SushiSwap liquidity zaps based on awesomeness from zapper.fi (0xcff6eF0B9916682B37D80c19cFF8949bc1886bC2).\ncontract Sushiswap_ZapIn_General_V3 is UniswapV2Router02 {\n    using SafeMath for uint256;\n    using BoringERC20 for IERC20;\n    \n    address constant sushiSwapFactory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac; // SushiSwap factory contract\n    ISushiSwap constant sushiSwapRouter = ISushiSwap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // SushiSwap router contract\n    uint256 constant deadline = 0xf000000000000000000000000000000000000000000000000000000000000000;\n    bytes32 constant pairCodeHash = 0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303; // SushiSwap pair code hash\n\n    event ZapIn(address sender, address pool, uint256 tokensRec);\n    \n    /// @notice This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize check.\n    function balanceOfOptimized(address token) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) =\n            token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n        require(success && data.length >= 32);\n        amount = abi.decode(data, (uint256));\n    }\n\n    /**\n     @notice This function is used to invest in given SushiSwap pair through ETH/ERC20 Tokens.\n     @param to Address to receive LP tokens.\n     @param _FromTokenContractAddress The ERC20 token used for investment (address(0x00) if ether).\n     @param _pairAddress The SushiSwap pair address.\n     @param _amount The amount of fromToken to invest.\n     @param _minPoolTokens Reverts if less tokens received than this.\n     @param _swapTarget Excecution target for the first swap.\n     @param swapData Dex quote data.\n     @return Amount of LP bought.\n     */\n    function zapIn(\n        address to,\n        address _FromTokenContractAddress,\n        address _pairAddress,\n        uint256 _amount,\n        uint256 _minPoolTokens,\n        address _swapTarget,\n        bytes calldata swapData\n    ) external payable returns (uint256) {\n        uint256 toInvest = _pullTokens(\n            _FromTokenContractAddress,\n            _amount\n        );\n        uint256 LPBought = _performZapIn(\n            _FromTokenContractAddress,\n            _pairAddress,\n            toInvest,\n            _swapTarget,\n            swapData\n        );\n        require(LPBought >= _minPoolTokens, 'ERR: High Slippage');\n        emit ZapIn(to, _pairAddress, LPBought);\n        IERC20(_pairAddress).safeTransfer(to, LPBought);\n        return LPBought;\n    }\n\n    function _getPairTokens(address _pairAddress) internal pure returns (address token0, address token1)\n    {\n        ISushiSwap sushiPair = ISushiSwap(_pairAddress);\n        token0 = sushiPair.token0();\n        token1 = sushiPair.token1();\n    }\n\n    function _pullTokens(address token, uint256 amount) internal returns (uint256 value) {\n        if (token == address(0)) {\n            require(msg.value > 0, 'No eth sent');\n            return msg.value;\n        }\n        require(amount > 0, 'Invalid token amount');\n        require(msg.value == 0, 'Eth sent with token');\n        // transfer token\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        return amount;\n    }\n\n    function _performZapIn(\n        address _FromTokenContractAddress,\n        address _pairAddress,\n        uint256 _amount,\n        address _swapTarget,\n        bytes memory swapData\n    ) internal returns (uint256) {\n        uint256 intermediateAmt;\n        address intermediateToken;\n        (\n            address _ToSushipoolToken0,\n            address _ToSushipoolToken1\n        ) = _getPairTokens(_pairAddress);\n        if (\n            _FromTokenContractAddress != _ToSushipoolToken0 &&\n            _FromTokenContractAddress != _ToSushipoolToken1\n        ) {\n            // swap to intermediate\n            (intermediateAmt, intermediateToken) = _fillQuote(\n                _FromTokenContractAddress,\n                _pairAddress,\n                _amount,\n                _swapTarget,\n                swapData\n            );\n        } else {\n            intermediateToken = _FromTokenContractAddress;\n            intermediateAmt = _amount;\n        }\n        // divide intermediate into appropriate amount to add liquidity\n        (uint256 token0Bought, uint256 token1Bought) = _swapIntermediate(\n            intermediateToken,\n            _ToSushipoolToken0,\n            _ToSushipoolToken1,\n            intermediateAmt\n        );\n        return\n            _sushiDeposit(\n                _ToSushipoolToken0,\n                _ToSushipoolToken1,\n                token0Bought,\n                token1Bought\n            );\n    }\n\n    function _sushiDeposit(\n        address _ToUnipoolToken0,\n        address _ToUnipoolToken1,\n        uint256 token0Bought,\n        uint256 token1Bought\n    ) internal returns (uint256) {\n        IERC20(_ToUnipoolToken0).approve(address(sushiSwapRouter), 0);\n        IERC20(_ToUnipoolToken1).approve(address(sushiSwapRouter), 0);\n        IERC20(_ToUnipoolToken0).approve(\n            address(sushiSwapRouter),\n            token0Bought\n        );\n        IERC20(_ToUnipoolToken1).approve(\n            address(sushiSwapRouter),\n            token1Bought\n        );\n        (uint256 amountA, uint256 amountB, uint256 LP) = sushiSwapRouter\n            .addLiquidity(\n            _ToUnipoolToken0,\n            _ToUnipoolToken1,\n            token0Bought,\n            token1Bought,\n            1,\n            1,\n            address(this),\n            deadline\n        );\n            // returning residue in token0, if any\n            if (token0Bought.sub(amountA) > 0) {\n                IERC20(_ToUnipoolToken0).safeTransfer(\n                    msg.sender,\n                    token0Bought.sub(amountA)\n                );\n            }\n            // returning residue in token1, if any\n            if (token1Bought.sub(amountB) > 0) {\n                IERC20(_ToUnipoolToken1).safeTransfer(\n                    msg.sender,\n                    token1Bought.sub(amountB)\n                );\n            }\n        return LP;\n    }\n\n    function _fillQuote(\n        address _fromTokenAddress,\n        address _pairAddress,\n        uint256 _amount,\n        address _swapTarget,\n        bytes memory swapCallData\n    ) internal returns (uint256 amountBought, address intermediateToken) {\n        uint256 valueToSend;\n        if (_fromTokenAddress == address(0)) {\n            valueToSend = _amount;\n        } else {\n            IERC20 fromToken = IERC20(_fromTokenAddress);\n            fromToken.approve(address(_swapTarget), 0);\n            fromToken.approve(address(_swapTarget), _amount);\n        }\n        (address _token0, address _token1) = _getPairTokens(_pairAddress);\n        IERC20 token0 = IERC20(_token0);\n        IERC20 token1 = IERC20(_token1);\n        uint256 initialBalance0 = balanceOfOptimized(address(token0));\n        uint256 initialBalance1 = balanceOfOptimized(address(token1));\n        (bool success, ) = _swapTarget.call{value: valueToSend}(swapCallData);\n        require(success, 'Error Swapping Tokens 1');\n        uint256 finalBalance0 = balanceOfOptimized(address(token0)).sub(\n            initialBalance0\n        );\n        uint256 finalBalance1 = balanceOfOptimized(address(token1)).sub(\n            initialBalance1\n        );\n        if (finalBalance0 > finalBalance1) {\n            amountBought = finalBalance0;\n            intermediateToken = _token0;\n        } else {\n            amountBought = finalBalance1;\n            intermediateToken = _token1;\n        }\n        require(amountBought > 0, 'Swapped to Invalid Intermediate');\n    }\n\n    function _swapIntermediate(\n        address _toContractAddress,\n        address _ToSushipoolToken0,\n        address _ToSushipoolToken1,\n        uint256 _amount\n    ) internal returns (uint256 token0Bought, uint256 token1Bought) {\n        (address token0, address token1) = _ToSushipoolToken0 < _ToSushipoolToken1 ? (_ToSushipoolToken0, _ToSushipoolToken1) : (_ToSushipoolToken1, _ToSushipoolToken0);\n        ISushiSwap pair =\n            ISushiSwap(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", sushiSwapFactory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\n                )\n            );\n        (uint256 res0, uint256 res1, ) = pair.getReserves();\n        if (_toContractAddress == _ToSushipoolToken0) {\n            uint256 amountToSwap = calculateSwapInAmount(res0, _amount);\n            // if no reserve or a new pair is created\n            if (amountToSwap <= 0) amountToSwap = _amount / 2;\n            token1Bought = _token2Token(\n                _toContractAddress,\n                _ToSushipoolToken1,\n                amountToSwap\n            );\n            token0Bought = _amount.sub(amountToSwap);\n        } else {\n            uint256 amountToSwap = calculateSwapInAmount(res1, _amount);\n            // if no reserve or a new pair is created\n            if (amountToSwap <= 0) amountToSwap = _amount / 2;\n            token0Bought = _token2Token(\n                _toContractAddress,\n                _ToSushipoolToken0,\n                amountToSwap\n            );\n            token1Bought = _amount.sub(amountToSwap);\n        }\n    }\n\n    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256)\n    {\n        return\n            Babylonian\n                .sqrt(\n                reserveIn.mul(userIn.mul(3988000) + reserveIn.mul(3988009))\n            )\n                .sub(reserveIn.mul(1997)) / 1994;\n    }\n\n    /**\n     @notice This function is used to swap ERC20 <> ERC20.\n     @param _FromTokenContractAddress The token address to swap from.\n     @param _ToTokenContractAddress The token address to swap to. \n     @param tokens2Trade The amount of tokens to swap.\n     @return tokenBought The quantity of tokens bought.\n    */\n    function _token2Token(\n        address _FromTokenContractAddress,\n        address _ToTokenContractAddress,\n        uint256 tokens2Trade\n    ) internal returns (uint256 tokenBought) {\n        if (_FromTokenContractAddress == _ToTokenContractAddress) {\n            return tokens2Trade;\n        }\n        IERC20(_FromTokenContractAddress).approve(\n            address(sushiSwapRouter),\n            0\n        );\n        IERC20(_FromTokenContractAddress).approve(\n            address(sushiSwapRouter),\n            tokens2Trade\n        );\n        (address token0, address token1) = _FromTokenContractAddress < _ToTokenContractAddress ? (_FromTokenContractAddress, _ToTokenContractAddress) : (_ToTokenContractAddress, _FromTokenContractAddress);\n        address pair =\n            address(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", sushiSwapFactory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\n                )\n            );\n        require(pair != address(0), 'No Swap Available');\n        address[] memory path = new address[](2);\n        path[0] = _FromTokenContractAddress;\n        path[1] = _ToTokenContractAddress;\n        tokenBought = sushiSwapRouter.swapExactTokensForTokens(\n            tokens2Trade,\n            1,\n            path,\n            address(this),\n            deadline\n        )[path.length - 1];\n        require(tokenBought > 0, 'Error Swapping Tokens 2');\n    }\n    \n    function zapOut(\n        address pair,\n        address to,\n        uint256 amount\n    ) external returns (uint256 amount0, uint256 amount1) {\n        IERC20(pair).safeTransferFrom(msg.sender, pair, amount); // pull `amount` to `pair`\n        (amount0, amount1) = ISushiSwap(pair).burn(to); // trigger burn to redeem liquidity for `to`\n    }\n    \n    function zapOutBalance(\n        address pair,\n        address to\n    ) external returns (uint256 amount0, uint256 amount1) {\n        IERC20(pair).safeTransfer(pair, balanceOfOptimized(pair)); // transfer local balance to `pair`\n        (amount0, amount1) = ISushiSwap(pair).burn(to); // trigger burn to redeem liquidity for `to`\n    }\n}\n\n/// @notice Interface for SUSHI MasterChef v2.\ninterface IMasterChefV2 {\n    function lpToken(uint256 pid) external view returns (IERC20);\n    function deposit(uint256 pid, uint256 amount, address to) external;\n}\n\n/// @notice Contract that batches SUSHI staking and DeFi strategies - V1 'iroirona'.\ncontract InariV1 is BoringBatchableWithDai, Sushiswap_ZapIn_General_V3 {\n    using SafeMath for uint256;\n    using BoringERC20 for IERC20;\n    \n    IERC20 constant sushiToken = IERC20(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2); // SUSHI token contract\n    address constant sushiBar = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // xSUSHI staking contract for SUSHI\n    IMasterChefV2 constant masterChefv2 = IMasterChefV2(0xEF0881eC094552b2e128Cf945EF17a6752B4Ec5d); // SUSHI MasterChef v2 contract\n    ISushiSwap constant sushiSwapSushiETHPair = ISushiSwap(0x795065dCc9f64b5614C407a6EFDC400DA6221FB0); // SUSHI/ETH pair on SushiSwap\n    IAaveBridge constant aave = IAaveBridge(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9); // AAVE lending pool contract for xSUSHI staking into aXSUSHI\n    IERC20 constant aaveSushiToken = IERC20(0xF256CC7847E919FAc9B808cC216cAc87CCF2f47a); // aXSUSHI staking contract for xSUSHI\n    IBentoBridge constant bento = IBentoBridge(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract\n    address constant crSushiToken = 0x338286C0BC081891A4Bda39C7667ae150bf5D206; // crSUSHI staking contract for SUSHI\n    address constant crXSushiToken = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2; // crXSUSHI staking contract for xSUSHI\n    address constant wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // ETH wrapper contract v9\n    \n    /// @notice Initialize this Inari contract.\n    constructor() {\n        bento.registerProtocol(); // register this contract with BENTO\n    }\n    \n    /// @notice Helper function to approve this contract to spend tokens and enable strategies.\n    function bridgeToken(IERC20[] calldata token, address[] calldata to) external {\n        for (uint256 i = 0; i < token.length; i++) {\n            token[i].approve(to[i], type(uint256).max); // max approve `to` spender to pull `token` from this contract\n        }\n    }\n\n    /**********\n    ETH HELPERS \n    **********/\n    receive() external payable {}\n    \n    function withdrawETHbalance(address to) external payable {\n        (bool success, ) = to.call{value: address(this).balance}(\"\");\n        require(success, '!payable');\n    }\n    \n    /***********\n    WETH HELPERS \n    ***********/\n    function depositBalanceToWETH() external payable {\n        IWETH(wETH).deposit{value: address(this).balance}();\n    }\n    \n    function withdrawBalanceFromWETH(address to) external {\n        uint256 balance = balanceOfOptimized(WETH); \n        IWETH(wETH).withdraw(balance);\n        (bool success, ) = to.call{value: balance}(\"\");\n        require(success, '!payable');\n    }\n    \n    /*********\n    TKN HELPER \n    *********/\n    function withdrawTokenBalance(IERC20 token, address to) external {\n        token.safeTransfer(to, balanceOfOptimized(address(token))); \n    }\n\n    /***********\n    SUSHI HELPER \n    ***********/\n    /// @notice Stake SUSHI local balance into xSushi for benefit of `to` by call to `sushiBar`.\n    function stakeSushiBalance(address to) external {\n        ISushiBarBridge(sushiBar).enter(balanceOfOptimized(address(sushiToken))); // stake local SUSHI into `sushiBar` xSUSHI\n        IERC20(sushiBar).safeTransfer(to, balanceOfOptimized(sushiBar)); // transfer resulting xSUSHI to `to`\n    }\n    \n    /**********\n    CHEF HELPER \n    **********/\n    function depositToMasterChefv2(uint256 amount, uint256 pid, address to) external {\n        masterChefv2.deposit(pid, amount, to);\n    }\n    \n    function balanceToMasterChefv2(address lpToken, uint256 pid, address to) external {\n        masterChefv2.deposit(pid, balanceOfOptimized(lpToken), to);\n    }\n/*\n‚ñà‚ñà   ‚ñà‚ñà       ‚ñÑ   ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ   \n‚ñà ‚ñà  ‚ñà ‚ñà       ‚ñà  ‚ñà‚ñÄ   ‚ñÄ  \n‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà     ‚ñà ‚ñà‚ñà‚ñÑ‚ñÑ    \n‚ñà  ‚ñà ‚ñà  ‚ñà  ‚ñà    ‚ñà ‚ñà‚ñÑ   ‚ñÑ‚ñÄ \n   ‚ñà    ‚ñà   ‚ñà  ‚ñà  ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ   \n  ‚ñà    ‚ñà     ‚ñà‚ñê           \n ‚ñÄ    ‚ñÄ      ‚ñê         */\n    \n    /***********\n    AAVE HELPERS \n    ***********/\n    function balanceToAave(address underlying, address to) external {\n        aave.deposit(underlying, balanceOfOptimized(underlying), to, 0); \n    }\n\n    function balanceFromAave(address aToken, address to) external {\n        address underlying = IAaveBridge(aToken).UNDERLYING_ASSET_ADDRESS(); // sanity check for `underlying` token\n        aave.withdraw(underlying, balanceOfOptimized(aToken), to); \n    }\n    \n    /**************************\n    AAVE -> UNDERLYING -> BENTO \n    **************************/\n    /// @notice Migrate AAVE `aToken` underlying `amount` into BENTO for benefit of `to` by batching calls to `aave` and `bento`.\n    function aaveToBento(address aToken, address to, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\n        IERC20(aToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `aToken` `amount` into this contract\n        address underlying = IAaveBridge(aToken).UNDERLYING_ASSET_ADDRESS(); // sanity check for `underlying` token\n        aave.withdraw(underlying, amount, address(bento)); // burn deposited `aToken` from `aave` into `underlying`\n        (amountOut, shareOut) = bento.deposit(IERC20(underlying), address(bento), to, amount, 0); // stake `underlying` into BENTO for `to`\n    }\n\n    /**************************\n    BENTO -> UNDERLYING -> AAVE \n    **************************/\n    /// @notice Migrate `underlying` `amount` from BENTO into AAVE for benefit of `to` by batching calls to `bento` and `aave`.\n    function bentoToAave(IERC20 underlying, address to, uint256 amount) external {\n        bento.withdraw(underlying, msg.sender, address(this), amount, 0); // withdraw `amount` of `underlying` from BENTO into this contract\n        aave.deposit(address(underlying), amount, to, 0); // stake `underlying` into `aave` for `to`\n    }\n    \n    /*************************\n    AAVE -> UNDERLYING -> COMP \n    *************************/\n    /// @notice Migrate AAVE `aToken` underlying `amount` into COMP/CREAM `cToken` for benefit of `to` by batching calls to `aave` and `cToken`.\n    function aaveToCompound(address aToken, address cToken, address to, uint256 amount) external {\n        IERC20(aToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `aToken` `amount` into this contract\n        address underlying = IAaveBridge(aToken).UNDERLYING_ASSET_ADDRESS(); // sanity check for `underlying` token\n        aave.withdraw(underlying, amount, address(this)); // burn deposited `aToken` from `aave` into `underlying`\n        ICompoundBridge(cToken).mint(amount); // stake `underlying` into `cToken`\n        IERC20(cToken).safeTransfer(to, balanceOfOptimized(cToken)); // transfer resulting `cToken` to `to`\n    }\n    \n    /*************************\n    COMP -> UNDERLYING -> AAVE \n    *************************/\n    /// @notice Migrate COMP/CREAM `cToken` underlying `amount` into AAVE for benefit of `to` by batching calls to `cToken` and `aave`.\n    function compoundToAave(address cToken, address to, uint256 amount) external {\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `cToken` `amount` into this contract\n        ICompoundBridge(cToken).redeem(amount); // burn deposited `cToken` into `underlying`\n        address underlying = ICompoundBridge(cToken).underlying(); // sanity check for `underlying` token\n        aave.deposit(underlying, balanceOfOptimized(underlying), to, 0); // stake resulting `underlying` into `aave` for `to`\n    }\n    \n    /**********************\n    SUSHI -> XSUSHI -> AAVE \n    **********************/\n    /// @notice Stake SUSHI `amount` into aXSUSHI for benefit of `to` by batching calls to `sushiBar` and `aave`.\n    function stakeSushiToAave(address to, uint256 amount) external { // SAAVE\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI into `sushiBar` xSUSHI\n        aave.deposit(sushiBar, balanceOfOptimized(sushiBar), to, 0); // stake resulting xSUSHI into `aave` aXSUSHI for `to`\n    }\n    \n    /**********************\n    AAVE -> XSUSHI -> SUSHI \n    **********************/\n    /// @notice Unstake aXSUSHI `amount` into SUSHI for benefit of `to` by batching calls to `aave` and `sushiBar`.\n    function unstakeSushiFromAave(address to, uint256 amount) external {\n        aaveSushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` aXSUSHI `amount` into this contract\n        aave.withdraw(sushiBar, amount, address(this)); // burn deposited aXSUSHI from `aave` into xSUSHI\n        ISushiBarBridge(sushiBar).leave(amount); // burn resulting xSUSHI from `sushiBar` into SUSHI\n        sushiToken.safeTransfer(to, balanceOfOptimized(address(sushiToken))); // transfer resulting SUSHI to `to`\n    }\n/*\n‚ñà‚ñà‚ñà   ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ      ‚ñÑ     ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÄ ‚ñà‚ñà‚ñà‚ñà‚ñÑ \n‚ñà  ‚ñà  ‚ñà‚ñÄ   ‚ñÄ      ‚ñà ‚ñÄ‚ñÄ‚ñÄ ‚ñà    ‚ñà   ‚ñà \n‚ñà ‚ñÄ ‚ñÑ ‚ñà‚ñà‚ñÑ‚ñÑ    ‚ñà‚ñà   ‚ñà    ‚ñà    ‚ñà   ‚ñà \n‚ñà  ‚ñÑ‚ñÄ ‚ñà‚ñÑ   ‚ñÑ‚ñÄ ‚ñà ‚ñà  ‚ñà   ‚ñà     ‚ñÄ‚ñà‚ñà‚ñà‚ñà \n‚ñà‚ñà‚ñà   ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ   ‚ñà  ‚ñà ‚ñà  ‚ñÄ            \n              ‚ñà   ‚ñà‚ñà            */ \n    /// @notice Liquidity zap into BENTO.\n    function zapToBento(\n        address to,\n        address _FromTokenContractAddress,\n        address _pairAddress,\n        uint256 _amount,\n        uint256 _minPoolTokens,\n        address _swapTarget,\n        bytes calldata swapData\n    ) external payable returns (uint256) {\n        uint256 toInvest = _pullTokens(\n            _FromTokenContractAddress,\n            _amount\n        );\n        uint256 LPBought = _performZapIn(\n            _FromTokenContractAddress,\n            _pairAddress,\n            toInvest,\n            _swapTarget,\n            swapData\n        );\n        require(LPBought >= _minPoolTokens, \"ERR: High Slippage\");\n        emit ZapIn(to, _pairAddress, LPBought);\n        bento.deposit(IERC20(_pairAddress), address(this), to, LPBought, 0); \n        return LPBought;\n    }\n    \n    /// @notice Liquidity zap from BENTO.\n    function zapFromBento(\n        address pair,\n        address to,\n        uint256 amount\n    ) external returns (uint256 amount0, uint256 amount1) {\n        bento.withdraw(IERC20(pair), msg.sender, pair, amount, 0); // withdraw `amount` to `pair` from BENTO\n        (amount0, amount1) = ISushiSwap(pair).burn(to); // trigger burn to redeem liquidity for `to`\n    }\n \n    /************\n    BENTO HELPERS \n    ************/\n    function balanceToBento(IERC20 token, address to) external returns (uint256 amountOut, uint256 shareOut) {\n        (amountOut, shareOut) = bento.deposit(token, address(this), to, balanceOfOptimized(address(token)), 0); \n    }\n    \n    function depositFromBento(IERC20 token, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\n        (amountOut, shareOut) = bento.withdraw(token, msg.sender, address(this), amount, 0); \n    }\n\n    /// @dev Included to be able to approve `bento` in the same transaction (using `batch()`).\n    function setBentoApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bento.setMasterContractApproval(user, masterContract, approved, v, r, s);\n    }\n\n    /***********************\n    SUSHI -> XSUSHI -> BENTO \n    ***********************/\n    /// @notice Stake SUSHI `amount` into BENTO xSUSHI for benefit of `to` by batching calls to `sushiBar` and `bento`.\n    function stakeSushiToBento(address to, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI into `sushiBar` xSUSHI\n        (amountOut, shareOut) = bento.deposit(IERC20(sushiBar), address(this), to, balanceOfOptimized(sushiBar), 0); // stake resulting xSUSHI into BENTO for `to`\n    }\n    \n    /***********************\n    BENTO -> XSUSHI -> SUSHI \n    ***********************/\n    /// @notice Unstake xSUSHI `amount` from BENTO into SUSHI for benefit of `to` by batching calls to `bento` and `sushiBar`.\n    function unstakeSushiFromBento(address to, uint256 amount) external {\n        bento.withdraw(IERC20(sushiBar), msg.sender, address(this), amount, 0); // withdraw `amount` of xSUSHI from BENTO into this contract\n        ISushiBarBridge(sushiBar).leave(amount); // burn withdrawn xSUSHI from `sushiBar` into SUSHI\n        sushiToken.safeTransfer(to, balanceOfOptimized(address(sushiToken))); // transfer resulting SUSHI to `to`\n    }\n/*    \n‚ñÑ‚ñà‚ñÑ    ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ   ‚ñà‚ñà   ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà \n‚ñà‚ñÄ ‚ñÄ‚ñÑ  ‚ñà  ‚ñÑ‚ñÄ ‚ñà‚ñÄ   ‚ñÄ  ‚ñà ‚ñà  ‚ñà ‚ñà ‚ñà \n‚ñà   ‚ñÄ  ‚ñà‚ñÄ‚ñÄ‚ñå  ‚ñà‚ñà‚ñÑ‚ñÑ    ‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà ‚ñÑ ‚ñà \n‚ñà‚ñÑ  ‚ñÑ‚ñÄ ‚ñà  ‚ñà  ‚ñà‚ñÑ   ‚ñÑ‚ñÄ ‚ñà  ‚ñà ‚ñà   ‚ñà \n‚ñÄ‚ñà‚ñà‚ñà‚ñÄ    ‚ñà   ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ      ‚ñà    ‚ñà  \n        ‚ñÄ              ‚ñà    ‚ñÄ  \n                      ‚ñÄ      */\n// - COMPOUND - //\n    /***********\n    COMP HELPERS \n    ***********/\n    function balanceToCompound(ICompoundBridge cToken) external {\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\n        cToken.mint(balanceOfOptimized(address(underlying)));\n    }\n\n    function balanceFromCompound(address cToken) external {\n        ICompoundBridge(cToken).redeem(balanceOfOptimized(cToken));\n    }\n    \n    /**************************\n    COMP -> UNDERLYING -> BENTO \n    **************************/\n    /// @notice Migrate COMP/CREAM `cToken` `cTokenAmount` into underlying and BENTO for benefit of `to` by batching calls to `cToken` and `bento`.\n    function compoundToBento(address cToken, address to, uint256 cTokenAmount) external returns (uint256 amountOut, uint256 shareOut) {\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), cTokenAmount); // deposit `msg.sender` `cToken` `cTokenAmount` into this contract\n        ICompoundBridge(cToken).redeem(cTokenAmount); // burn deposited `cToken` into `underlying`\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\n        (amountOut, shareOut) = bento.deposit(underlying, address(this), to, balanceOfOptimized(address(underlying)), 0); // stake resulting `underlying` into BENTO for `to`\n    }\n    \n    /**************************\n    BENTO -> UNDERLYING -> COMP \n    **************************/\n    /// @notice Migrate `cToken` `underlyingAmount` from BENTO into COMP/CREAM for benefit of `to` by batching calls to `bento` and `cToken`.\n    function bentoToCompound(address cToken, address to, uint256 underlyingAmount) external {\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\n        bento.withdraw(underlying, msg.sender, address(this), underlyingAmount, 0); // withdraw `underlyingAmount` of `underlying` from BENTO into this contract\n        ICompoundBridge(cToken).mint(underlyingAmount); // stake `underlying` into `cToken`\n        IERC20(cToken).safeTransfer(to, balanceOfOptimized(cToken)); // transfer resulting `cToken` to `to`\n    }\n    \n    /**********************\n    SUSHI -> CREAM -> BENTO \n    **********************/\n    /// @notice Stake SUSHI `amount` into crSUSHI and BENTO for benefit of `to` by batching calls to `crSushiToken` and `bento`.\n    function sushiToCreamToBento(address to, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\n        ICompoundBridge(crSushiToken).mint(amount); // stake deposited SUSHI into crSUSHI\n        (amountOut, shareOut) = bento.deposit(IERC20(crSushiToken), address(this), to, balanceOfOptimized(crSushiToken), 0); // stake resulting crSUSHI into BENTO for `to`\n    }\n    \n    /**********************\n    BENTO -> CREAM -> SUSHI \n    **********************/\n    /// @notice Unstake crSUSHI `cTokenAmount` into SUSHI from BENTO for benefit of `to` by batching calls to `bento` and `crSushiToken`.\n    function sushiFromCreamFromBento(address to, uint256 cTokenAmount) external {\n        bento.withdraw(IERC20(crSushiToken), msg.sender, address(this), cTokenAmount, 0); // withdraw `cTokenAmount` of `crSushiToken` from BENTO into this contract\n        ICompoundBridge(crSushiToken).redeem(cTokenAmount); // burn deposited `crSushiToken` into SUSHI\n        sushiToken.safeTransfer(to, balanceOfOptimized(address(sushiToken))); // transfer resulting SUSHI to `to`\n    }\n    \n    /***********************\n    SUSHI -> XSUSHI -> CREAM \n    ***********************/\n    /// @notice Stake SUSHI `amount` into crXSUSHI for benefit of `to` by batching calls to `sushiBar` and `crXSushiToken`.\n    function stakeSushiToCream(address to, uint256 amount) external { // SCREAM\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI `amount` into `sushiBar` xSUSHI\n        ICompoundBridge(crXSushiToken).mint(balanceOfOptimized(sushiBar)); // stake resulting xSUSHI into crXSUSHI\n        IERC20(crXSushiToken).safeTransfer(to, balanceOfOptimized(crXSushiToken)); // transfer resulting crXSUSHI to `to`\n    }\n    \n    /***********************\n    CREAM -> XSUSHI -> SUSHI \n    ***********************/\n    /// @notice Unstake crXSUSHI `cTokenAmount` into SUSHI for benefit of `to` by batching calls to `crXSushiToken` and `sushiBar`.\n    function unstakeSushiFromCream(address to, uint256 cTokenAmount) external {\n        IERC20(crXSushiToken).safeTransferFrom(msg.sender, address(this), cTokenAmount); // deposit `msg.sender` `crXSushiToken` `cTokenAmount` into this contract\n        ICompoundBridge(crXSushiToken).redeem(cTokenAmount); // burn deposited `crXSushiToken` `cTokenAmount` into xSUSHI\n        ISushiBarBridge(sushiBar).leave(balanceOfOptimized(sushiBar)); // burn resulting xSUSHI `amount` from `sushiBar` into SUSHI\n        sushiToken.safeTransfer(to, balanceOfOptimized(address(sushiToken))); // transfer resulting SUSHI to `to`\n    }\n    \n    /********************************\n    SUSHI -> XSUSHI -> CREAM -> BENTO \n    ********************************/\n    /// @notice Stake SUSHI `amount` into crXSUSHI and BENTO for benefit of `to` by batching calls to `sushiBar`, `crXSushiToken` and `bento`.\n    function stakeSushiToCreamToBento(address to, uint256 amount) external returns (uint256 amountOut, uint256 shareOut) {\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI `amount` into `sushiBar` xSUSHI\n        ICompoundBridge(crXSushiToken).mint(balanceOfOptimized(sushiBar)); // stake resulting xSUSHI into crXSUSHI\n        (amountOut, shareOut) = bento.deposit(IERC20(crXSushiToken), address(this), to, balanceOfOptimized(crXSushiToken), 0); // stake resulting crXSUSHI into BENTO for `to`\n    }\n    \n    /********************************\n    BENTO -> CREAM -> XSUSHI -> SUSHI \n    ********************************/\n    /// @notice Unstake crXSUSHI `cTokenAmount` into SUSHI from BENTO for benefit of `to` by batching calls to `bento`, `crXSushiToken` and `sushiBar`.\n    function unstakeSushiFromCreamFromBento(address to, uint256 cTokenAmount) external {\n        bento.withdraw(IERC20(crXSushiToken), msg.sender, address(this), cTokenAmount, 0); // withdraw `cTokenAmount` of `crXSushiToken` from BENTO into this contract\n        ICompoundBridge(crXSushiToken).redeem(cTokenAmount); // burn deposited `crXSushiToken` `cTokenAmount` into xSUSHI\n        ISushiBarBridge(sushiBar).leave(balanceOfOptimized(sushiBar)); // burn resulting xSUSHI from `sushiBar` into SUSHI\n        sushiToken.safeTransfer(to, balanceOfOptimized(address(sushiToken))); // transfer resulting SUSHI to `to`\n    }\n/*\n   ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ    ‚ñÑ ‚ñÑ   ‚ñà‚ñà   ‚ñà ‚ñÑ‚ñÑ      \n  ‚ñà     ‚ñÄ‚ñÑ ‚ñà   ‚ñà  ‚ñà ‚ñà  ‚ñà   ‚ñà     \n‚ñÑ  ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ  ‚ñà ‚ñÑ   ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÄ‚ñÄ‚ñÄ      \n ‚ñÄ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÄ   ‚ñà  ‚ñà  ‚ñà ‚ñà  ‚ñà ‚ñà         \n           ‚ñà ‚ñà ‚ñà     ‚ñà  ‚ñà        \n            ‚ñÄ ‚ñÄ     ‚ñà    ‚ñÄ       \n                   ‚ñÄ     */\n    /// @notice SushiSwap ETH to stake SUSHI into xSUSHI and BENTO for benefit of `to`. \n    function inariZushi(address to) external payable returns (uint256 amountOut, uint256 shareOut) { // INARIZUSHI\n        (uint256 reserve0, uint256 reserve1, ) = sushiSwapSushiETHPair.getReserves();\n        uint256 amountInWithFee = msg.value.mul(997);\n        uint256 out =\n            amountInWithFee.mul(reserve0) /\n            reserve1.mul(1000).add(amountInWithFee);\n        IWETH(wETH).deposit{value: msg.value}();\n        IERC20(wETH).safeTransfer(address(sushiSwapSushiETHPair), msg.value);\n        sushiSwapSushiETHPair.swap(out, 0, address(this), \"\");\n        ISushiBarBridge(sushiBar).enter(balanceOfOptimized(address(sushiToken))); // stake resulting SUSHI into `sushiBar` xSUSHI\n        (amountOut, shareOut) = bento.deposit(IERC20(sushiBar), address(this), to, balanceOfOptimized(sushiBar), 0); // stake resulting xSUSHI into BENTO for `to`\n    }\n    \n    /// @notice SushiSwap `fromToken` `amountIn` to `toToken` for benefit of `to`.\n    function swapSingle(address fromToken, address toToken, address to, uint256 amountIn) external returns (uint256 amountOut) {\n        (address token0, address token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n        ISushiSwap pair =\n            ISushiSwap(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", sushiSwapFactory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\n                )\n            );\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        uint256 amountInWithFee = amountIn.mul(997);\n        IERC20(fromToken).safeTransferFrom(msg.sender, address(this), amountIn);\n        if (toToken > fromToken) {\n            amountOut =\n                amountInWithFee.mul(reserve1) /\n                reserve0.mul(1000).add(amountInWithFee);\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n            pair.swap(0, amountOut, to, \"\");\n        } else {\n            amountOut =\n                amountInWithFee.mul(reserve0) /\n                reserve1.mul(1000).add(amountInWithFee);\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n            pair.swap(amountOut, 0, to, \"\");\n        }\n    }\n    \n    /// @notice SushiSwap local `fromToken` balance in this contract to `toToken` for benefit of `to`.\n    function swapBalance(address fromToken, address toToken, address to) external returns (uint256 amountOut) {\n        (address token0, address token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n        ISushiSwap pair =\n            ISushiSwap(\n                uint256(\n                    keccak256(abi.encodePacked(hex\"ff\", sushiSwapFactory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\n                )\n            );\n        uint256 amountIn = balanceOfOptimized(fromToken);\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        uint256 amountInWithFee = amountIn.mul(997);\n        if (toToken > fromToken) {\n            amountOut =\n                amountInWithFee.mul(reserve1) /\n                reserve0.mul(1000).add(amountInWithFee);\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n            pair.swap(0, amountOut, to, \"\");\n        } else {\n            amountOut =\n                amountInWithFee.mul(reserve0) /\n                reserve1.mul(1000).add(amountInWithFee);\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n            pair.swap(amountOut, 0, to, \"\");\n        }\n    }\n}"
    }
  }
}