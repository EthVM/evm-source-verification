{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "erc20token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"t001\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"t002\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"t003\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"m001\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"t006\");\r\n        require(isContract(target), \"t007\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value : value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"t010\");\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"t012\");\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"t013\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"m007\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"t014\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n}\r\n\r\ncontract ClaimErc20 is ReentrancyGuard, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    uint256 RewardNum = 5000;\r\n    bool public canClaimErc20 = false;\r\n    mapping(uint256 => bool) public hasClaimStatus;\r\n    IERC20 public RewardAddress = IERC20(0xd947773b93455e3D97fCb8D4A030C5D0D8F3b278);\r\n    IERC721 public NftAddress = IERC721(0xb840EC0DB3b9ab7b920710D6fc21A9D206f994Aa);\r\n\r\n    function setRewardNum(uint256 _RewardNum) public onlyOwner {\r\n        RewardNum = _RewardNum;\r\n    }\r\n\r\n    function setRewardAddress(IERC20 _RewardAddress) public onlyOwner {\r\n        RewardAddress = _RewardAddress;\r\n    }\r\n\r\n    function setNftAddress(IERC721 _NftAddress) public onlyOwner {\r\n        NftAddress = _NftAddress;\r\n    }\r\n\r\n    function enableCanClaimErc20() public onlyOwner {\r\n        canClaimErc20 = true;\r\n    }\r\n\r\n    function disableCanClaimErc20() public onlyOwner {\r\n        canClaimErc20 = false;\r\n    }\r\n\r\n    function claimErc20Token() public {\r\n        uint256 num = NftAddress.balanceOf(msg.sender);\r\n        require(num > 0, \"t015\");\r\n        require(canClaimErc20 == true, \"t016\");\r\n        uint256 num2 = 0;\r\n        for (uint256 i = 0; i < num; i++) {\r\n            uint256 _tokenID = NftAddress.tokenOfOwnerByIndex(msg.sender, i);\r\n            if (hasClaimStatus[_tokenID] == false) {\r\n                num2 = num2.add(1);\r\n                hasClaimStatus[_tokenID] = true;\r\n            }\r\n        }\r\n        require(num2 > 0, \"t017\");\r\n        uint256 reward_num = RewardNum.mul(num2).mul(10 ** RewardAddress.decimals());\r\n        RewardAddress.safeApprove(address(this), reward_num);\r\n        RewardAddress.safeTransferFrom(address(this), msg.sender, reward_num);\r\n    }\r\n\r\n    function getClaimErc20TokenNum(address _user) public view returns (uint256){\r\n        uint256 num = NftAddress.balanceOf(_user);\r\n        if (num == 0 || canClaimErc20 == false) {\r\n            return 0;\r\n        }\r\n        uint256 num2 = 0;\r\n        for (uint256 i = 0; i < num; i++) {\r\n            uint256 _tokenID = NftAddress.tokenOfOwnerByIndex(_user, i);\r\n            if (hasClaimStatus[_tokenID] == false) {\r\n                num2 = num2.add(1);\r\n            }\r\n        }\r\n        return num2;\r\n    }\r\n\r\n    function getErc20Token(IERC20 _token) public onlyOwner {\r\n        _token.safeApprove(address(this), _token.balanceOf(address(this)));\r\n        _token.safeTransferFrom(address(this), msg.sender, _token.balanceOf(address(this)));\r\n    }\r\n}"
    }
  }
}