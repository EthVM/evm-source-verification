{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"contracts/mainnet/resolvers/ubiquity/helpers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces.sol\";\n\ncontract Helpers {\n    address internal constant dsaConnectorAddress = 0x8EC066D75d665616A94F2EccDBE49b54eAeefc78;\n\n    IUbiquityAlgorithmicDollarManager internal constant ubiquityManager =\n        IUbiquityAlgorithmicDollarManager(0x4DA97a8b831C345dBe6d16FF7432DF2b7b776d98);\n\n    struct UbiquityAddresses {\n        address ubiquityManagerAddress;\n        address masterChefAddress;\n        address twapOracleAddress;\n        address uadAddress;\n        address uarAddress;\n        address udebtAddress;\n        address ubqAddress;\n        address cr3Address;\n        address uadcrv3Address;\n        address bondingShareAddress;\n        address dsaResolverAddress;\n        address dsaConnectorAddress;\n    }\n\n    struct UbiquityDatas {\n        uint256 twapPrice;\n        uint256 uadTotalSupply;\n        uint256 uarTotalSupply;\n        uint256 udebtTotalSupply;\n        uint256 ubqTotalSupply;\n        uint256 uadcrv3TotalSupply;\n        uint256 bondingSharesTotalSupply;\n        uint256 lpTotalSupply;\n    }\n\n    struct UbiquityInventory {\n        uint256 uadBalance;\n        uint256 uarBalance;\n        uint256 udebtBalance;\n        uint256 ubqBalance;\n        uint256 crv3Balance;\n        uint256 uad3crvBalance;\n        uint256 ubqRewards;\n        uint256 bondingSharesBalance;\n        uint256 lpBalance;\n        uint256 bondBalance;\n        uint256 ubqPendingBalance;\n    }\n\n    function getMasterChef() internal view returns (IMasterChefV2) {\n        return IMasterChefV2(ubiquityManager.masterChefAddress());\n    }\n\n    function getTWAPOracle() internal view returns (ITWAPOracle) {\n        return ITWAPOracle(ubiquityManager.twapOracleAddress());\n    }\n\n    function getUAD() internal view returns (IERC20) {\n        return IERC20(ubiquityManager.dollarTokenAddress());\n    }\n\n    function getUAR() internal view returns (IERC20) {\n        return IERC20(ubiquityManager.autoRedeemTokenAddress());\n    }\n\n    function getUBQ() internal view returns (IERC20) {\n        return IERC20(ubiquityManager.governanceTokenAddress());\n    }\n\n    function getCRV3() internal view returns (IERC20) {\n        return IERC20(ubiquityManager.curve3PoolTokenAddress());\n    }\n\n    function getUADCRV3() internal view returns (IERC20) {\n        return IERC20(ubiquityManager.stableSwapMetaPoolAddress());\n    }\n\n    function getUDEBT() internal view returns (IERC1155) {\n        return IERC1155(ubiquityManager.debtCouponAddress());\n    }\n\n    function getBondingShare() internal view returns (IBondingShareV2) {\n        return IBondingShareV2(ubiquityManager.bondingShareAddress());\n    }\n\n    function getBondingShareIds(address user) internal view returns (uint256[] memory bondIds) {\n        return getBondingShare().holderTokens(user);\n    }\n\n    function getBondingShareBalanceOf(address user) internal view returns (uint256 balance) {\n        uint256[] memory bondIds = getBondingShareIds(user);\n        for (uint256 i = 0; i < bondIds.length; i += 1) {\n            balance += getBondingShare().getBond(bondIds[i]).lpAmount;\n        }\n    }\n\n    function getPendingUBQ(address user) internal view returns (uint256 amount) {\n        uint256[] memory bondIds = getBondingShareIds(user);\n        for (uint256 i = 0; i < bondIds.length; i += 1) {\n            amount += getMasterChef().pendingUGOV(bondIds[i]);\n        }\n    }\n}\n"},"contracts/mainnet/resolvers/ubiquity/interfaces.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC1155.sol\";\n\ninterface ITWAPOracle {\n    function update() external;\n\n    function token0() external view returns (address);\n\n    function consult(address token) external view returns (uint256 amountOut);\n}\n\ninterface IUbiquityAlgorithmicDollarManager {\n    function twapOracleAddress() external view returns (address);\n\n    function dollarTokenAddress() external view returns (address);\n\n    function autoRedeemTokenAddress() external view returns (address);\n\n    function governanceTokenAddress() external view returns (address);\n\n    function curve3PoolTokenAddress() external view returns (address);\n\n    function stableSwapMetaPoolAddress() external view returns (address);\n\n    function debtCouponAddress() external view returns (address);\n\n    function bondingShareAddress() external view returns (address);\n\n    function masterChefAddress() external view returns (address);\n}\n\ninterface IBondingShareV2 {\n    struct Bond {\n        address minter;\n        uint256 lpFirstDeposited;\n        uint256 creationBlock;\n        uint256 lpRewardDebt;\n        uint256 endBlock;\n        uint256 lpAmount;\n    }\n\n    function holderTokens(address) external view returns (uint256[] memory);\n\n    function totalLP() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function getBond(uint256 id) external view returns (Bond memory);\n}\n\ninterface IMasterChefV2 {\n    function lastPrice() external view returns (uint256);\n\n    function pendingUGOV(uint256) external view returns (uint256);\n\n    function minPriceDiffToUpdateMultiplier() external view returns (uint256);\n\n    function pool() external view returns (uint256 lastRewardBlock, uint256 accuGOVPerShare);\n\n    function totalShares() external view returns (uint256);\n\n    function uGOVDivider() external view returns (uint256);\n\n    function uGOVPerBlock() external view returns (uint256);\n\n    function uGOVmultiplier() external view returns (uint256);\n}\n"},"contracts/mainnet/resolvers/ubiquity/interfaces/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"},"contracts/mainnet/resolvers/ubiquity/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"contracts/mainnet/resolvers/ubiquity/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"contracts/mainnet/resolvers/ubiquity/main.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces.sol\";\nimport \"./helpers.sol\";\n\ncontract Resolver is Helpers {\n    function getUbiquityAddresses() public view returns (UbiquityAddresses memory addresses) {\n        addresses.ubiquityManagerAddress = address(ubiquityManager);\n        addresses.masterChefAddress = address(getMasterChef());\n        addresses.twapOracleAddress = address(getTWAPOracle());\n        addresses.uadAddress = address(getUAD());\n        addresses.uarAddress = address(getUAR());\n        addresses.udebtAddress = address(getUDEBT());\n        addresses.ubqAddress = address(getUBQ());\n        addresses.cr3Address = address(getCRV3());\n        addresses.uadcrv3Address = address(getUADCRV3());\n        addresses.bondingShareAddress = address(getBondingShare());\n        addresses.dsaResolverAddress = address(this);\n        addresses.dsaConnectorAddress = address(dsaConnectorAddress);\n    }\n\n    function getUbiquityDatas() public view returns (UbiquityDatas memory datas) {\n        datas.twapPrice = getTWAPOracle().consult(getTWAPOracle().token0());\n        datas.uadTotalSupply = getUAD().totalSupply();\n        datas.uarTotalSupply = getUAR().totalSupply();\n        datas.ubqTotalSupply = getUBQ().totalSupply();\n        datas.uadcrv3TotalSupply = getUADCRV3().totalSupply();\n        datas.bondingSharesTotalSupply = getBondingShare().totalSupply();\n        datas.lpTotalSupply = getBondingShare().totalLP();\n    }\n\n    function getUbiquityInventory(address user) public view returns (UbiquityInventory memory inventory) {\n        inventory.uadBalance = getUAD().balanceOf(user);\n        inventory.uarBalance = getUAR().balanceOf(user);\n        inventory.ubqBalance = getUBQ().balanceOf(user);\n        inventory.crv3Balance = getCRV3().balanceOf(user);\n        inventory.uad3crvBalance = getUADCRV3().balanceOf(user);\n        inventory.bondingSharesBalance = getBondingShareBalanceOf(user);\n        inventory.lpBalance = getBondingShareBalanceOf(user);\n        inventory.bondBalance = getBondingShareIds(user).length;\n        inventory.ubqPendingBalance = getPendingUBQ(user);\n    }\n}\n\ncontract InstaUbiquityResolver is Resolver {\n    string public constant name = \"Ubiquity-Resolver-v0.1\";\n}\n"}}}