{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LiquidityMining.sol":{"content":"//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\ncontract LiquidityMining {\r\n\r\n    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\r\n    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    address private WETH_ADDRESS = IUniswapV2Router(UNISWAP_V2_ROUTER).WETH();\r\n\r\n    address[] private TOKENS;\r\n\r\n    mapping(uint256 => uint256) private _totalPoolAmount;\r\n\r\n    uint256[] private TIME_WINDOWS;\r\n\r\n    uint256[] private REWARD_MULTIPLIERS;\r\n\r\n    uint256[] private REWARD_DIVIDERS;\r\n\r\n    uint256[] private REWARD_SPLIT_TRANCHES;\r\n\r\n    address private _doubleProxy;\r\n\r\n    address private _mainTokenAddress;\r\n\r\n    address private _rewardTokenAddress;\r\n\r\n    struct StakeInfo {\r\n        address sender;\r\n        uint256 poolPosition;\r\n        uint256 firstAmount;\r\n        uint256 secondAmount;\r\n        uint256 poolAmount;\r\n        uint256 reward;\r\n        uint256 endBlock;\r\n        uint256[] partialRewardBlockTimes;\r\n        uint256 splittedReward;\r\n    }\r\n\r\n    uint256 private _startBlock;\r\n    uint256 private _endBlock;\r\n\r\n    mapping(uint256 => mapping(uint256 => StakeInfo)) private _stakeInfo;\r\n    mapping(uint256 => uint256) private _stakeInfoLength;\r\n\r\n    event Staked(address indexed sender, uint256 indexed tier, uint256 indexed poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, uint256 reward, uint256 endBlock, uint256[] partialRewardBlockTimes, uint256 splittedReward);\r\n    event Withdrawn(address sender, address indexed receiver, uint256 indexed tier, uint256 indexed poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, uint256 reward);\r\n    event PartialWithdrawn(address sender, address indexed receiver, uint256 indexed tier, uint256 reward);\r\n\r\n    event Unlocked(address indexed receiver, uint256 indexed tier, uint256 position, uint256 indexed poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, uint256 reward);\r\n    event Flushed(address indexed receiver, uint256 indexed tier, uint256 position, uint256 indexed poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, uint256 reward);\r\n\r\n    constructor(address mainTokenAddress, address rewardTokenAddress, uint256 startBlock, uint256 endBlock, address doubleProxy, address[] memory tokens, uint256[] memory timeWindows, uint256[] memory rewardMultipliers, uint256[] memory rewardDividers, uint256[] memory rewardSplitTranches) {\r\n\r\n        _mainTokenAddress = mainTokenAddress;\r\n\r\n        _rewardTokenAddress = rewardTokenAddress;\r\n\r\n        _startBlock = startBlock;\r\n\r\n        _endBlock = endBlock;\r\n\r\n        _doubleProxy = doubleProxy;\r\n\r\n        _initArrays(tokens, timeWindows, rewardMultipliers, rewardDividers, rewardSplitTranches);\r\n    }\r\n\r\n    function _initArrays(address[] memory tokens, uint256[] memory timeWindows, uint256[] memory rewardMultipliers, uint256[] memory rewardDividers, uint256[] memory rewardSplitTranches) private {\r\n\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            TOKENS.push(tokens[i]);\r\n        }\r\n\r\n        assert(timeWindows.length == rewardMultipliers.length && rewardMultipliers.length == rewardDividers.length && rewardDividers.length == rewardSplitTranches.length);\r\n        for(uint256 i = 0; i < timeWindows.length; i++) {\r\n            TIME_WINDOWS.push(timeWindows[i]);\r\n        }\r\n\r\n        for(uint256 i = 0; i < rewardMultipliers.length; i++) {\r\n            REWARD_MULTIPLIERS.push(rewardMultipliers[i]);\r\n        }\r\n\r\n        for(uint256 i = 0; i < rewardDividers.length; i++) {\r\n            REWARD_DIVIDERS.push(rewardDividers[i]);\r\n        }\r\n\r\n        for(uint256 i = 0; i < rewardSplitTranches.length; i++) {\r\n            REWARD_SPLIT_TRANCHES.push(rewardSplitTranches[i]);\r\n        }\r\n    }\r\n\r\n    function doubleProxy() public view returns(address) {\r\n        return _doubleProxy;\r\n    }\r\n\r\n    function tokenAddress() public view returns(address) {\r\n        return _mainTokenAddress;\r\n    }\r\n\r\n    function rewardTokenAddress() public view returns(address) {\r\n        return _rewardTokenAddress;\r\n    }\r\n\r\n    function tokens() public view returns(address[] memory) {\r\n        return TOKENS;\r\n    }\r\n\r\n    function tierData() public view returns(uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory) {\r\n        return (TIME_WINDOWS, REWARD_MULTIPLIERS, REWARD_DIVIDERS, REWARD_SPLIT_TRANCHES);\r\n    }\r\n\r\n    function startBlock() public view returns(uint256) {\r\n        return _startBlock;\r\n    }\r\n\r\n    function endBlock() public view returns(uint256) {\r\n        return _endBlock;\r\n    }\r\n\r\n    function totalPoolAmount(uint256 poolPosition) public view returns(uint256) {\r\n        return _totalPoolAmount[poolPosition];\r\n    }\r\n\r\n    function setDoubleProxy(address newDoubleProxy) public {\r\n        require(IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), \"Unauthorized Action!\");\r\n        _doubleProxy = newDoubleProxy;\r\n    }\r\n\r\n    function stake(uint256 tier, uint256 poolPosition, uint256 originalFirstAmount, uint256 firstAmountMin, uint256 value, uint256 secondAmountMin) public payable {\r\n        require(block.number >= _startBlock, \"Staking is still not available\");\r\n        require(block.number < _endBlock, \"Staking has reached end block\");\r\n        require(poolPosition < TOKENS.length, \"Unknown Pool\");\r\n        require(tier < TIME_WINDOWS.length, \"Unknown tier\");\r\n\r\n        require(originalFirstAmount > 0, \"First amount must be greater than 0\");\r\n\r\n        uint256 originalSecondAmount = TOKENS[poolPosition] == WETH_ADDRESS ? msg.value : value;\r\n        require(originalSecondAmount > 0, \"Second amount must be greater than 0\");\r\n\r\n        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\r\n\r\n        _transferTokensAndCheckAllowance(_mainTokenAddress, originalFirstAmount);\r\n        _transferTokensAndCheckAllowance(TOKENS[poolPosition], originalSecondAmount);\r\n\r\n        address secondToken = TOKENS[poolPosition];\r\n\r\n        (uint256 firstAmount, uint256 secondAmount, uint256 poolAmount) = _createPoolToken(originalFirstAmount, firstAmountMin, originalSecondAmount, secondAmountMin, _mainTokenAddress, secondToken);\r\n\r\n        _totalPoolAmount[poolPosition] += poolAmount;\r\n\r\n        (uint256 minCap,, uint256 remainingToStake) = getStakingInfo(tier);\r\n        require(firstAmount >= minCap, \"Amount to stake is less than the current min cap\");\r\n        require(firstAmount <= remainingToStake, \"Amount to stake must be less than the current remaining one\");\r\n\r\n        calculateRewardAndAddStakingPosition(tier, poolPosition, firstAmount, secondAmount, poolAmount, proxy);\r\n    }\r\n\r\n    function getStakingInfo(uint256 tier) public view returns(uint256 minCap, uint256 hardCap, uint256 remainingToStake) {\r\n        (minCap, hardCap) = getStakingCap(tier);\r\n        remainingToStake = hardCap;\r\n        uint256 length = _stakeInfoLength[tier];\r\n        for(uint256 i = 0; i < length; i++) {\r\n            if(_stakeInfo[tier][i].endBlock > block.number) {\r\n                remainingToStake -= _stakeInfo[tier][i].firstAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStakingCap(uint256 tier) public view returns(uint256, uint256) {\r\n        IStateHolder stateHolder = IStateHolder(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getStateHolderAddress());\r\n        string memory tierString = _toString(tier);\r\n        string memory addressString = _toLowerCase(_toString(address(this)));\r\n        return (\r\n            stateHolder.getUint256(string(abi.encodePacked(\"staking.\", addressString, \".tiers[\", tierString, \"].minCap\"))),\r\n            stateHolder.getUint256(string(abi.encodePacked(\"staking.\", addressString, \".tiers[\", tierString, \"].hardCap\")))\r\n        );\r\n    }\r\n\r\n    function _transferTokensAndCheckAllowance(address tokenAddr, uint256 value) private {\r\n        if(tokenAddr == WETH_ADDRESS) {\r\n            return;\r\n        }\r\n        IERC20 token = IERC20(tokenAddr);\r\n        token.transferFrom(msg.sender, address(this), value);\r\n        if(token.allowance(address(this), UNISWAP_V2_ROUTER) <= value) {\r\n            token.approve(UNISWAP_V2_ROUTER, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        }\r\n    }\r\n\r\n    function _createPoolToken(uint256 originalFirstAmount, uint256 firstAmountMin, uint256 originalSecondAmount, uint256 secondAmountMin, address firstToken, address secondToken) private returns(uint256 firstAmount, uint256 secondAmount, uint256 poolAmount) {\r\n        if(secondToken == WETH_ADDRESS) {\r\n            (firstAmount, secondAmount, poolAmount) = IUniswapV2Router(UNISWAP_V2_ROUTER).addLiquidityETH{value: originalSecondAmount}(\r\n                firstToken,\r\n                originalFirstAmount,\r\n                firstAmountMin,\r\n                secondAmountMin,\r\n                address(this),\r\n                block.timestamp + 1000\r\n            );\r\n        } else {\r\n            (firstAmount, secondAmount, poolAmount) = IUniswapV2Router(UNISWAP_V2_ROUTER).addLiquidity(\r\n                firstToken,\r\n                secondToken,\r\n                originalFirstAmount,\r\n                originalSecondAmount,\r\n                firstAmountMin,\r\n                secondAmountMin,\r\n                address(this),\r\n                block.timestamp + 1000\r\n            );\r\n        }\r\n        if(firstAmount < originalFirstAmount) {\r\n            IERC20(firstToken).transfer(msg.sender, originalFirstAmount - firstAmount);\r\n        }\r\n        if(secondAmount < originalSecondAmount) {\r\n            if(secondToken == WETH_ADDRESS) {\r\n                payable(msg.sender).transfer(originalSecondAmount - secondAmount);\r\n            } else {\r\n                IERC20(secondToken).transfer(msg.sender, originalSecondAmount - secondAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateRewardAndAddStakingPosition(uint256 tier, uint256 poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, IMVDProxy proxy) private {\r\n        uint256 partialRewardSingleBlockTime = TIME_WINDOWS[tier] / REWARD_SPLIT_TRANCHES[tier];\r\n        uint256[] memory partialRewardBlockTimes = new uint256[](REWARD_SPLIT_TRANCHES[tier]);\r\n        if(partialRewardBlockTimes.length > 0) {\r\n            partialRewardBlockTimes[0] = block.number + partialRewardSingleBlockTime;\r\n            for(uint256 i = 1; i < partialRewardBlockTimes.length; i++) {\r\n                partialRewardBlockTimes[i] = partialRewardBlockTimes[i - 1] + partialRewardSingleBlockTime;\r\n            }\r\n        }\r\n        uint256 reward = firstAmount * REWARD_MULTIPLIERS[tier] / REWARD_DIVIDERS[tier];\r\n        StakeInfo memory stakeInfo = StakeInfo(msg.sender, poolPosition, firstAmount, secondAmount, poolAmount, reward, block.number + TIME_WINDOWS[tier], partialRewardBlockTimes, reward / REWARD_SPLIT_TRANCHES[tier]);\r\n        _add(tier, stakeInfo);\r\n        proxy.submit(\"liquidityMiningTransfer\", abi.encode(address(0), 0, reward, _rewardTokenAddress));\r\n        emit Staked(msg.sender, tier, poolPosition, firstAmount, secondAmount, poolAmount, reward, stakeInfo.endBlock, partialRewardBlockTimes, stakeInfo.splittedReward);\r\n    }\r\n\r\n    function _add(uint256 tier, StakeInfo memory element) private returns(uint256, uint256) {\r\n        _stakeInfo[tier][_stakeInfoLength[tier]] = element;\r\n        _stakeInfoLength[tier] = _stakeInfoLength[tier] + 1;\r\n        return (element.reward, element.endBlock);\r\n    }\r\n\r\n    function _remove(uint256 tier, uint256 i) private {\r\n        if(_stakeInfoLength[tier] <= i) {\r\n            return;\r\n        }\r\n        _stakeInfoLength[tier] = _stakeInfoLength[tier] - 1;\r\n        if(_stakeInfoLength[tier] > i) {\r\n            _stakeInfo[tier][i] = _stakeInfo[tier][_stakeInfoLength[tier]];\r\n        }\r\n        delete _stakeInfo[tier][_stakeInfoLength[tier]];\r\n    }\r\n\r\n    function length(uint256 tier) public view returns(uint256) {\r\n        return _stakeInfoLength[tier];\r\n    }\r\n\r\n    function stakeInfo(uint256 tier, uint256 position) public view returns(\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256[] memory,\r\n        uint256\r\n    ) {\r\n        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\r\n        return(\r\n            tierStakeInfo.sender,\r\n            tierStakeInfo.poolPosition,\r\n            tierStakeInfo.firstAmount,\r\n            tierStakeInfo.secondAmount,\r\n            tierStakeInfo.poolAmount,\r\n            tierStakeInfo.reward,\r\n            tierStakeInfo.endBlock,\r\n            tierStakeInfo.partialRewardBlockTimes,\r\n            tierStakeInfo.splittedReward\r\n        );\r\n    }\r\n\r\n    function partialReward(uint256 tier, uint256 position) public {\r\n        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\r\n        require(tierStakeInfo.sender != address(0), \"Unknown Position!\");\r\n        if(block.number >= tierStakeInfo.endBlock) {\r\n            return withdraw(tier, position);\r\n        }\r\n        require(tierStakeInfo.reward > 0, \"No more reward for this staking position\");\r\n        uint256 reward = 0;\r\n        for(uint256 i = 0; i < tierStakeInfo.partialRewardBlockTimes.length; i++) {\r\n            if(tierStakeInfo.partialRewardBlockTimes[i] > 0 && block.number >= tierStakeInfo.partialRewardBlockTimes[i]) {\r\n                reward += tierStakeInfo.splittedReward;\r\n                tierStakeInfo.partialRewardBlockTimes[i] = 0;\r\n            }\r\n        }\r\n        reward = reward > tierStakeInfo.reward ? tierStakeInfo.reward : reward;\r\n        require(reward > 0, \"No reward to redeem\");\r\n        IERC20 token = IERC20(_rewardTokenAddress);\r\n        token.transfer(tierStakeInfo.sender, reward);\r\n        tierStakeInfo.reward = tierStakeInfo.reward - reward;\r\n        _stakeInfo[tier][position] = tierStakeInfo;\r\n        emit PartialWithdrawn(msg.sender, tierStakeInfo.sender, tier, reward);\r\n    }\r\n\r\n    function withdraw(uint256 tier, uint256 position) public {\r\n        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\r\n        require(tierStakeInfo.sender != address(0), \"Unknown Position!\");\r\n        require(block.number >= tierStakeInfo.endBlock, \"Cannot actually withdraw this position\");\r\n        IERC20 token = IERC20(_rewardTokenAddress);\r\n        if(tierStakeInfo.reward > 0) {\r\n            token.transfer(tierStakeInfo.sender, tierStakeInfo.reward);\r\n        }\r\n        token = IERC20(IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(_mainTokenAddress, TOKENS[tierStakeInfo.poolPosition]));\r\n        token.transfer(tierStakeInfo.sender, tierStakeInfo.poolAmount);\r\n        _totalPoolAmount[tierStakeInfo.poolPosition] = _totalPoolAmount[tierStakeInfo.poolPosition] - tierStakeInfo.poolAmount;\r\n        emit Withdrawn(msg.sender, tierStakeInfo.sender, tier, tierStakeInfo.poolPosition, tierStakeInfo.firstAmount, tierStakeInfo.secondAmount, tierStakeInfo.poolAmount, tierStakeInfo.reward);\r\n        _remove(tier, position);\r\n    }\r\n\r\n    function unlock(uint256 tier, uint256 position) public {\r\n        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\r\n        require(tierStakeInfo.sender != address(0), \"Unknown Position!\");\r\n        require(msg.sender == tierStakeInfo.sender, \"Unlock can be done only by position owner\");\r\n        if(block.number >= tierStakeInfo.endBlock) {\r\n            return withdraw(tier, position);\r\n        }\r\n        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\r\n        address walletAddress = proxy.getMVDWalletAddress();\r\n        uint256 reward = 0;\r\n        for(uint256 i = 0; i < tierStakeInfo.partialRewardBlockTimes.length; i++) {\r\n            if(tierStakeInfo.partialRewardBlockTimes[i] == 0) {\r\n                reward += tierStakeInfo.splittedReward;\r\n            }\r\n        }\r\n        IERC20 token = IERC20(_rewardTokenAddress);\r\n        if(reward > 0) {\r\n            token.transferFrom(tierStakeInfo.sender, walletAddress, reward);\r\n        }\r\n        token.transfer(walletAddress, tierStakeInfo.reward);\r\n        token = IERC20(IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(_mainTokenAddress, TOKENS[tierStakeInfo.poolPosition]));\r\n        token.transfer(tierStakeInfo.sender, tierStakeInfo.poolAmount);\r\n        _totalPoolAmount[tierStakeInfo.poolPosition] = _totalPoolAmount[tierStakeInfo.poolPosition] - tierStakeInfo.poolAmount;\r\n        emit Unlocked(tierStakeInfo.sender, tier, position, tierStakeInfo.poolPosition, tierStakeInfo.firstAmount, tierStakeInfo.secondAmount, tierStakeInfo.poolAmount, tierStakeInfo.reward + reward);\r\n        _remove(tier, position);\r\n    }\r\n\r\n    function flushToDFO(uint256 tier, uint256 position) public {\r\n        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\r\n        require(tierStakeInfo.sender != address(0), \"Unknown Position!\");\r\n        require(msg.sender == tierStakeInfo.sender, \"Flush can be done only by position owner\");\r\n        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\r\n        address walletAddress = proxy.getMVDWalletAddress();\r\n        uint256 reward = 0;\r\n        for(uint256 i = 0; i < tierStakeInfo.partialRewardBlockTimes.length; i++) {\r\n            if(tierStakeInfo.partialRewardBlockTimes[i] > 0 && block.number >= tierStakeInfo.partialRewardBlockTimes[i]) {\r\n                reward += tierStakeInfo.splittedReward;\r\n                tierStakeInfo.partialRewardBlockTimes[i] = 0;\r\n            }\r\n        }\r\n        reward = reward > tierStakeInfo.reward ? tierStakeInfo.reward : reward;\r\n        IERC20 token = IERC20(_rewardTokenAddress);\r\n        if(reward > 0) {\r\n            token.transfer(tierStakeInfo.sender, reward);\r\n        }\r\n        if(tierStakeInfo.reward - reward > 0) {\r\n            token.transfer(walletAddress, tierStakeInfo.reward - reward);\r\n        }\r\n        token = IERC20(IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(_mainTokenAddress, TOKENS[tierStakeInfo.poolPosition]));\r\n        token.transfer(walletAddress, tierStakeInfo.poolAmount);\r\n        _totalPoolAmount[tierStakeInfo.poolPosition] = _totalPoolAmount[tierStakeInfo.poolPosition] - tierStakeInfo.poolAmount;\r\n        emit Flushed(tierStakeInfo.sender, tier, position, tierStakeInfo.poolPosition, tierStakeInfo.firstAmount, tierStakeInfo.secondAmount, tierStakeInfo.poolAmount, tierStakeInfo.reward + reward);\r\n        _remove(tier, position);\r\n    }\r\n\r\n    function _toString(uint _i) private pure returns(string memory) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function _toString(address _addr) private pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function _toLowerCase(string memory str) private pure returns(string memory) {\r\n        bytes memory bStr = bytes(str);\r\n        for (uint i = 0; i < bStr.length; i++) {\r\n            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\r\n        }\r\n        return string(bStr);\r\n    }\r\n}\r\n\r\ninterface IMVDProxy {\r\n    function getStateHolderAddress() external view returns(address);\r\n    function getMVDWalletAddress() external view returns(address);\r\n    function getMVDFunctionalitiesManagerAddress() external view returns(address);\r\n    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\r\n}\r\n\r\ninterface IStateHolder {\r\n    function setUint256(string calldata name, uint256 value) external returns(uint256);\r\n    function getUint256(string calldata name) external view returns(uint256);\r\n    function getBool(string calldata varName) external view returns (bool);\r\n    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\r\n}\r\n\r\ninterface IMVDFunctionalitiesManager {\r\n    function isAuthorizedFunctionality(address functionality) external view returns(bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IDoubleProxy {\r\n    function proxy() external view returns(address);\r\n}"}}}