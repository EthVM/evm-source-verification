{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Main.sol": {
      "content": "/**\n * WWWW.LADYLUCKCOIN.COM\n * \n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@&#*,(&@@&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(,&@@&&@@@@@@@@@@@@@@@@&@@@@@@@@@@@@@@@@@@@@&@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@&@@%*(@@@@@@@&@@%(,...,,,.,,#%@@&@@@@@@@@@@@@@@@@&@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@&&(*&@&@&@@&**#@@&&@@@@@@@@@@@@@@@@@&&&@@@@@@@@@@&*,@&(,,@@\n * @@@@@@@@@&  .%@@@@@@%*(@&@&@&*(&@@@@@@@@&&*.(&@@@@@@@@@@@@@@@@@@@@@@@@&&*..@@@@@\n * @@@@@@@@@@&        .#@&@&&(#&@@@@@@@@&@.       &@@@@@@@@@@@@@@@@&@#@&@%*#@@@&@@@\n * @@@@@@@@@@@@%             #@@@@@@&@@@@.        &@@@@@@@@@@@@@@&&*  .&@@@@@@@@@@@\n * @@@@@@@@@@@@@(&((@#.            (&@@@@*        @@@@@@@@@@@&#    (@@&&@@@@@@@@@@@\n * @@@@@@@@@@@@&&      .(@@@@#,         (@      .&@@@@@@@%.     #&@@&@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@**&            ,%@@@&,    ,     .&&.       .&@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@&@**&@%#*%@@&@@@&%(*.   (@(            &&,%@@@&@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@&#*(@@@*             .,*(#*              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@  @@@@*@@(***(((##@@@@@@@.             *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@**@@@&*@@@@@@@@@@@@@@@@@@   %         (@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@**@@@&*@@@@@@@@@@@@@@@@@&  .@%       .@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@**@@@@*@@@@@@@@@@@@@@@@*  #&&        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@**(@@@#*@@@@@@@@@@@@@@@@   @&         ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@**(@@@*#@@@@@@@@@@@@&@@  #@           *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@(**@&&@*(@@@@@@@@@@@@&*  @(            @&@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@&(**@@@@(*@@@@@@@@@@@@  (@(            *@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@&(**&@@@&*(@@@@@@@@@*  &@#             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@%(((@&@@%*(@@@@@@@  @@@%             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@&@(**(@&&&&((%&&@&@(&@@&             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@(***&@@@@&(((&@@&@&@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@#*(*(@@&@@@&(,,*#@,            @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@&@@(****&@@@@@@@@@#      ..   .@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@&&*,,,,*&@@@@*      %.   *@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&*....        @.   (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&@@(          @    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,            @@    (@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@&@@@#               %@,    (&@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@&@@@.                 @@@     ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@(                   &@@@,      @@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@&&.                  (&&&@&@&       &@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@&@@&@@@@@@@@@@@@@@@@&&&@@@@@@@@&@&@@@&&@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@  ██╗░░░░░░█████╗░██████╗░██╗░░░██╗██╗░░░░░██╗░░░██╗░█████╗░██╗░░██╗ @@@@@@\n * @@@@@  ██║░░░░░██╔══██╗██╔══██╗╚██╗░██╔╝██║░░░░░██║░░░██║██╔══██╗██║░██╔╝ @@@@@@\n * @@@@@  ██║░░░░░███████║██║░░██║░╚████╔╝░██║░░░░░██║░░░██║██║░░╚═╝█████═╝░ @@@@@@\n * @@@@@  ██║░░░░░██╔══██║██║░░██║░░╚██╔╝░░██║░░░░░██║░░░██║██║░░██╗██╔═██╗░ @@@@@@\n * @@@@@  ███████╗██║░░██║██████╔╝░░░██║░░░███████╗╚██████╔╝╚█████╔╝██║░╚██╗ @@@@@@\n * @@@@@  ╚══════╝╚═╝░░╚═╝╚═════╝░░░░╚═╝░░░╚══════╝░╚═════╝░░╚════╝░╚═╝░░╚═╝ @@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n *\n * SPDX-License-Identifier: MIT\n * \n */\n \npragma solidity ^0.8.0;\n                     \nabstract contract Initializable {\n\n    \n    bool private _initialized;\n\n    bool private _initializing;\n\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n\ncontract VRFRequestIDBase {\n    \n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n    address _requester, uint256 _nonce)\n    internal pure returns (uint256)\n  {\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n  \n  function makeRequestId(\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n  \n}\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n\nlibrary SafeMathChainlink {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n\nabstract contract VRFConsumerBase is Initializable, VRFRequestIDBase {\n\n  using SafeMathChainlink for uint256;\n\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\n    internal virtual;\n\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\n    internal returns (bytes32 requestId)\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\n\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\n\n    nonces[_keyHash] = nonces[_keyHash].add(1);\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface  internal LINK;\n  address  private vrfCoordinator;\n\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n    function __VRFConsumerBase_init() internal initializer {\n        __VRFConsumerBase_init_unchained();\n    }\n    function __VRFConsumerBase_init_unchained() internal initializer {\n        vrfCoordinator = 0xf0d54349aDdcf704F77AE15b96510dEA15cb7952;\n        LINK = LinkTokenInterface(0x514910771AF9Ca656af840dff83E8264EcF986CA);\n    }\n\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n\n}\n\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    event Paused(address account);\n\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n\nlibrary MathUpgradeable {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\nlibrary ArraysUpgradeable {\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n\nlibrary AddressUpgradeable {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IERC20Upgradeable {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    \n    using ArraysUpgradeable for uint256[];\n    using AddressUpgradeable for address;\n    \n    mapping(address => bool) internal _isHolder;\n    mapping(uint256 => mapping(address => address)) internal _groupNextHolder;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    \n    mapping (address => uint256) internal  _balances;\n    mapping (uint256 => uint256) internal _groupHolders;\n    mapping (address => uint256) internal _addressGroup;\n    mapping (address => uint256) internal _weekLotto;  \n\n    uint256[] internal GroupIDList;\n\n    uint256 internal _totalSupply;\n    string private _name;\n    string private _symbol;\n    \n    uint256 public ExchangeSupply;\n    uint256 public HoldersNum;    \n    uint256 public WeekCounter;\n\n    address public MegaPot;\n    address public LuckPot;\n    address public DevWallet;\n    address public MarketingWallet;\n    \n    address constant MOJO = address(1);\n\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        MarketingWallet = address(0x05dD722A8478715eC4ab7CDdecB82D598A313072);\n        MegaPot = address(0x83F9B450a5d71dC6CBeef6D8E7214181FAf5D41f);\n        LuckPot = address(0xc4e017a03Cee1F129E93052e6b150466102B3aF5);        \n        DevWallet = address(0x538Ca3c8ad2F0e50730E51D730b907ab993EC326); \n        \n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function EligibleSupply() public view virtual returns (uint256){\n        uint256 ExcludedSupply = _totalSupply - ExchangeSupply - balanceOf(MegaPot) - balanceOf(LuckPot) - balanceOf(DevWallet) - balanceOf(MarketingWallet); \n        return ExcludedSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        \n        if (_isHolder[account] && _weekLotto[account] < WeekCounter && account != DevWallet && account != MegaPot && account != LuckPot && account != MarketingWallet && !account.isContract()){\n            uint256 temp = _balances[account];\n            \n            uint256 WeekDelta = WeekCounter - _weekLotto[account];\n            temp = (temp * (99 ** WeekDelta))/(100** WeekDelta);\n            return temp;\n            \n        } else {\n            return _balances[account];\n        }\n    }\n \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n    \n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        \n        uint256 feeAmount =  amount/100;\n        uint256 gasAmount = amount/100;\n        \n        if (sender == MegaPot || sender == LuckPot || sender == DevWallet || sender == MarketingWallet || recipient == DevWallet || recipient == MegaPot || recipient == LuckPot || recipient == MarketingWallet) {\n            feeAmount = 0;\n            gasAmount = 0;\n        }        \n\n        uint256 senderBalance = balanceOf(sender);\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        \n        uint256 receiveAmount = amount - feeAmount - gasAmount;\n        \n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += receiveAmount;\n        _balances[MegaPot] += feeAmount;\n        _balances[MarketingWallet] += gasAmount;\n        \n        emit Transfer(sender, recipient, amount);\n        emit Transfer(sender, MegaPot, feeAmount);        \n        emit Transfer(sender, MarketingWallet, gasAmount);\n\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        \n\n        _beforeTokenTransfer(address(0), account, amount);\n        \n        \n        if(_totalSupply == 0){\n            _totalSupply += amount;\n        }\n        \n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");    \n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n\n\n        \n        _balances[account] = accountBalance - amount;\n        \n        if(account != MegaPot && account != LuckPot){\n            _totalSupply -= amount;\n        }\n\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function AddGroupHolder(address holder) internal {\n        if(_isHolder[holder] == false && holder != address(0) && holder != MegaPot && holder != LuckPot && holder != DevWallet && holder != MarketingWallet && !holder.isContract()){\n            \n            _isHolder[holder] = true;\n            \n            uint256 GroupNumber = 1;\n            while (_groupHolders[GroupNumber] >=100){\n                GroupNumber++;\n            }\n            \n            if(_groupNextHolder[GroupNumber][MOJO] == address(0)){\n                _groupNextHolder[GroupNumber][MOJO] = MOJO;\n                GroupIDList.push(GroupNumber);\n            }\n            _groupNextHolder[GroupNumber][holder] = _groupNextHolder[GroupNumber][MOJO];\n            _groupNextHolder[GroupNumber][MOJO] = holder;\n            \n            _addressGroup[holder] = GroupNumber;\n            _groupHolders[GroupNumber]++;\n            \n            HoldersNum++;\n            \n            _weekLotto[holder] = WeekCounter;\n\n        }\n    }\n    \n    function RemoveGroupHolder(address holder) internal {\n        if(_isHolder[holder] == true && holder != address(0) && holder != MegaPot && holder != LuckPot && holder != DevWallet && holder != MarketingWallet && !holder.isContract()){\n            \n            _isHolder[holder] = false;\n            \n            uint256 GroupNumber = _addressGroup[holder];\n            \n            address prevHolder = GetPrevHolder(holder);\n            \n            _groupNextHolder[GroupNumber][prevHolder] = _groupNextHolder[GroupNumber][holder];\n            _groupNextHolder[GroupNumber][holder] = address(0);\n\n            _addressGroup[holder] = 0;\n            _groupHolders[GroupNumber] = _groupHolders[GroupNumber] - 1;\n            \n            HoldersNum = HoldersNum - 1;\n            \n            \n            _weekLotto[holder] = 0;\n                        \n    }\n    }\n    \n    function GetPrevHolder(address holder) internal view returns(address){\n        \n        address currentAddress = MOJO;\n        uint256 GroupNumber = _addressGroup[holder];        \n        \n        while(_groupNextHolder[GroupNumber][currentAddress] != MOJO){\n            if(_groupNextHolder[GroupNumber][currentAddress] == holder){\n                return currentAddress;\n            }\n            currentAddress = _groupNextHolder[GroupNumber][currentAddress];\n        }\n        return address(0);\n    }\n    \n    function GetGroupHolders(uint256 GroupNumber) internal view returns (address[] memory){\n        address[] memory holders = new address[](_groupHolders[GroupNumber]);\n        address currentAddress = _groupNextHolder[GroupNumber][MOJO];\n        for(uint256 i = 0; currentAddress != MOJO; ++i){\n            holders[i] = currentAddress;\n            currentAddress = _groupNextHolder[GroupNumber][currentAddress];\n        }\n        return holders;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {\n\n    if(to.isContract()){ExchangeSupply  =ExchangeSupply + amount;}\n    if(from.isContract()){ExchangeSupply =ExchangeSupply - amount;}\n    \n    _balances[from] = balanceOf(from);\n    _weekLotto[from] = WeekCounter;\n    _balances[to] - balanceOf(to);\n    _weekLotto[to] = WeekCounter;\n    \n    \n    if (from == address(0)) {\n      AddGroupHolder(to);\n      \n    } else if (to == address(0)) {\n      if (balanceOf(from) - amount == 0){RemoveGroupHolder(from);}\n      \n    } else {\n      AddGroupHolder(to);\n      if (balanceOf(from) - amount == 0){RemoveGroupHolder(from);}\n    }\n\n    }\n    uint256[45] private __gap;\n}\n\ncontract LadyLuck is Initializable, ERC20Upgradeable, OwnableUpgradeable, PausableUpgradeable, VRFConsumerBase  {\n    \n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n    \n    uint public LastJackpotTime;\n    uint public NextJackpotTime;\n    uint256 internal JackpotFreq;\n    \n    uint256 public JackpotStarted;  \n    uint256 internal PreviousRandomNumber;\n    uint256[] internal GroupBalanceList;\n    \n    uint256 internal WinningGroupMega; \n    address public WinningWalletMega;\n    uint256 public WinningNumberMega;\n\n    uint256 internal WinningGroupLuck;     \n    address public WinningWalletLuck;\n    uint256 public WinningNumberLuck;\n\n    uint256 internal RollingGroupTotal;    \n    \n    function initialize() public virtual initializer {\n        \n        __ERC20_init(\"Lady Luck\", \"LUCK\");\n        \n        __Context_init();\n        __Pausable_init();\n        __Ownable_init();\n    \n        __VRFConsumerBase_init();\n        \n        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\n        fee = 2 * 10 ** 18; // 0.1 LINK        \n        \n        _mint(DevWallet, 1000000000 * 10 ** decimals());\n        WinningWalletMega = MegaPot;\n        WinningWalletLuck = LuckPot;\n        \n        JackpotFreq = 604000;//One Week;        \n        LastJackpotTime = block.timestamp;\n        NextJackpotTime = block.timestamp + JackpotFreq;   \n    }\n    \n    function distributeToken(address[] memory addresses, uint256 _value) public onlyOwner {\n\t    for( uint256 i=0;i<addresses.length;i++){\n\t        transfer(addresses[i], _value);\n\t    }\n\t}\n    \n    function PrepareLottery() public onlyOwner {\n        /////require(block.timestamp > NextJackpotTime);\n        uint256 NumberOfGroups = ShowGroupIDList().length;          \n        require(JackpotStarted < NumberOfGroups, \"Lottery Has Already Been Prepared\");\n        \n        JackpotStarted++;\n\n        if(JackpotStarted == 1){\n            _pause();\n            delete GroupBalanceList;\n            uint256 temp = GetTrueGroupBalance(JackpotStarted);\n            GroupBalanceList.push(temp);\n            RollingGroupTotal = temp;\n            \n        } else if(JackpotStarted <= NumberOfGroups){\n            uint256 temp = GetTrueGroupBalance(JackpotStarted);\n            GroupBalanceList.push(temp);\n            RollingGroupTotal += temp;\n        }\n        \n        if(JackpotStarted == NumberOfGroups){\n            PreviousRandomNumber = randomResult;\n            getRandomNumber(block.timestamp*block.difficulty);\n        }\n    }\n\n        \n    function RunLuckLottery() public onlyOwner {\n        uint256[] memory GroupIDList = ShowGroupIDList();  \n        require(JackpotStarted == GroupIDList.length, \"Please Prepare Lottery Or End Mega Lottery\");        \n        require(PreviousRandomNumber != randomResult, \"Please Wait For Chainlink To Provide The Random Number\");\n        \n        uint256 FirstRandomResult = uint256(keccak256(abi.encode(randomResult, 0)));\n        WinningNumberLuck = FirstRandomResult % RollingGroupTotal + 1;\n\n        uint256 i = 0;\n        WinningGroupLuck = 0;\n        uint256 RollingTotal = 0;        \n        while (WinningGroupLuck == 0){\n            uint256 CurrentGroupBalance = GroupBalanceList[i];\n            if (RollingTotal < WinningNumberLuck && WinningNumberLuck <= RollingTotal + CurrentGroupBalance){\n                WinningGroupLuck = GroupIDList[i];\n            } else {\n                RollingTotal += CurrentGroupBalance;\n            }\n            i++;\n        }\n\n        address[] memory GroupWinnerList = GetGroupHolders(WinningGroupLuck);\n        \n        for (uint j=0; j<GroupWinnerList.length; j++) {\n            uint256 CurrentUserBalance = balanceOf(GroupWinnerList[j]);\n            if (RollingTotal < WinningNumberLuck && WinningNumberLuck <= RollingTotal + CurrentUserBalance){\n                  WinningWalletLuck = GroupWinnerList[j];\n            }\n            RollingTotal += CurrentUserBalance; \n        }\n        JackpotStarted++;\n    }\n    \n    \n    function RunMegaLottery() public onlyOwner {\n\n        uint256[] memory GroupIDList = ShowGroupIDList(); \n        require(JackpotStarted == GroupIDList.length + 1, \"Please Prepare Lottery & End Luck Lottery\");\n\n        uint256 SecondRandomResult = uint256(keccak256(abi.encode(randomResult, 1)));\n        WinningNumberMega = SecondRandomResult % RollingGroupTotal + 1;\n        \n        uint256 i = 0;\n        WinningGroupMega = 0;\n        uint256 RollingTotal = 0;        \n        while (WinningGroupMega == 0){\n            uint256 CurrentGroupBalance = GroupBalanceList[i];\n            if (RollingTotal < WinningNumberMega && WinningNumberMega <= RollingTotal + CurrentGroupBalance){\n                WinningGroupMega = GroupIDList[i];\n            } else {\n                RollingTotal += CurrentGroupBalance;\n            }\n            i++;\n        }\n        \n        address[] memory GroupWinnerList = GetGroupHolders(WinningGroupMega);\n        \n        for (uint j=0; j<GroupWinnerList.length; j++) {\n            uint256 CurrentUserBalance = balanceOf(GroupWinnerList[j]);\n            if (RollingTotal < WinningNumberMega && WinningNumberMega <= RollingTotal + CurrentUserBalance){\n                  WinningWalletMega = GroupWinnerList[j];\n            }\n            RollingTotal += CurrentUserBalance; \n        }\n        \n        WeekCounter++;\n        \n        _unpause();\n        \n        uint256 MegaPotBalance = balanceOf(MegaPot);\n        _burn(MegaPot, MegaPotBalance);\n        _mint(WinningWalletMega, MegaPotBalance);\n\n        _mint(LuckPot, RollingGroupTotal/100);\n    \n        LastJackpotTime = block.timestamp;\n        NextJackpotTime = LastJackpotTime + JackpotFreq;\n\n        JackpotStarted = 0;\n    }\n    \n    function PayLuckWinner() public onlyOwner {\n        uint256 LuckPotBalance = balanceOf(LuckPot);\n        _burn(LuckPot, LuckPotBalance);\n        _mint(WinningWalletLuck, LuckPotBalance);\n\n    }\n    \n    function GetTrueGroupBalance(uint256 Groups) internal view returns(uint256){\n        uint256 Temp; \n        address[] memory TempList = GetGroupHolders(Groups); \n        for (uint j=0; j<TempList.length; j++) {\n            Temp += balanceOf(TempList[j]);\n        }\n        return Temp;\n    }    \n    \n    function ShowGroupIDList() internal view virtual returns(uint256[] memory){\n        return GroupIDList;\n    }\n\n    function CurrentTime() public view virtual returns (uint){\n        return block.timestamp;\n    }     \n    \n    function ChangeLotteryFreq(uint256 Freq) public onlyOwner {\n        JackpotFreq = Freq;\n    }\n    \n    function ResetLotteryStarted() public onlyOwner {\n        JackpotStarted = 0;\n    }\n    \n    function CurrentMegaPotSize() public view returns(uint256){\n        return balanceOf(MegaPot);\n    }    \n    \n    function CurrentLuckPotSize() public view returns(uint256){\n        return balanceOf(LuckPot);\n    }       \n    \n     function getRandomNumber(uint256 userProvidedSeed) internal returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK - fill contract with faucet\");\n        return requestRandomness(keyHash, fee, userProvidedSeed);\n    }\n\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n    }\n\n    function withdrawLink() public onlyOwner {\n        require(LINK.transfer(msg.sender, LINK.balanceOf(address(this))), \"Unable to transfer\");\n    }   \n    \n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal\n        whenNotPaused\n        override(ERC20Upgradeable)\n    {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n        \n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }    \n\n    function pause() public onlyOwner{\n        _pause();\n    }\n\n    function unpause() public onlyOwner{\n        _unpause();\n    }\n\n\n        \n    ////\n    \n    function resetGroup(uint256 start, uint256 end) public onlyOwner{\n        address[] memory GroupHoldersList = GetGroupHolders(1);\n        \n        for (uint i=start; i<end; i++) {\n            \n            RemoveGroupHolder(GroupHoldersList[i]);\n            \n            AddGroupHolder(GroupHoldersList[i]);\n        }\n    }\n\n    function resetTotalSupply(uint256 amount) public onlyOwner{\n        _totalSupply = amount;\n    }\n    \n    function callMint(uint256 amount) public onlyOwner{\n        _mint(DevWallet, amount);\n    }\n        \n\n    \n    ////\n\n}"
    }
  }
}