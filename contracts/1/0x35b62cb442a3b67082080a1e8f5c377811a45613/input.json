{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Address.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n// OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}"},"AucReceiverInterface.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title AucReceiverInterface\r\n * @dev Contract interface to receive Auc through an EIP 223 transfer.\r\n */\r\ninterface AucReceiverInterface {\r\n\tfunction tokenFallback(address from, uint256 amount, bytes calldata data) external;\r\n}"},"DPiggyAssetData.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\nimport \"DPiggyBaseProxyData.sol\";\r\nimport \"ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title DPiggyAssetData\r\n * @dev Contract for all dPiggy asset stored data.\r\n * It must inherit from DPiggyBaseProxyData contract for properly generate the proxy.\r\n * Each dPiggy asset has your own DPiggyAssetData.\r\n */\r\ncontract DPiggyAssetData is DPiggyBaseProxyData, ReentrancyGuard {\r\n    \r\n    /**\r\n     * @dev The Struct to store each Compound redeem execution data.\r\n     */\r\n    struct Execution {\r\n        /**\r\n         * @dev The time in Unix.\r\n         */\r\n        uint256 time;\r\n        \r\n        /**\r\n         * @dev The calculated rate based on Dai amount variation on Compound.\r\n         */\r\n        uint256 rate;\r\n        \r\n        /**\r\n         * @dev The total amount of Dai on Compound.\r\n         */\r\n        uint256 totalDai;\r\n        \r\n        /**\r\n         * @dev The amount of Dai redeemed on Compound.\r\n         */\r\n        uint256 totalRedeemed;\r\n        \r\n        /**\r\n         * @dev The amount of asset purchased.\r\n         */\r\n        uint256 totalBought;\r\n        \r\n        /**\r\n         * @dev The total of Dai deposited on the contract.\r\n         */\r\n        uint256 totalBalance;\r\n        \r\n        /**\r\n         * @dev The total of Dai with fee exemption.\r\n         */\r\n        uint256 totalFeeDeduction;\r\n        \r\n        /**\r\n         * @dev The total of Dai redeemed that was regarded as the fee.\r\n         */\r\n        uint256 feeAmount;\r\n    }\r\n    \r\n    /**\r\n     * @dev The Struct to store the user data.\r\n     */\r\n    struct UserData {\r\n        /**\r\n         * @dev The last execution Id on deposit.\r\n         */\r\n        uint256 baseExecutionId;\r\n        \r\n        /**\r\n         * @dev The rate on deposit.\r\n         * The value is the weighted average of all deposit rates with the same base execution Id.\r\n         * It is used to calculate the user's corresponding profit on the next Compound redeem execution (baseExecutionId + 1).\r\n         */\r\n        uint256 baseExecutionAvgRate;\r\n        \r\n        /**\r\n         * @dev The amount of Dai on deposit.\r\n         * The value is the amount of Dai accumulated of all deposits with the same base execution Id.\r\n         */\r\n        uint256 baseExecutionAccumulatedAmount;\r\n        \r\n        /**\r\n         * @dev The accumulated weight for the rate calculation.\r\n         * The value is auxiliary for the base execution rate calculation for all deposits with the same base execution Id.\r\n         */\r\n        uint256 baseExecutionAccumulatedWeightForRate;\r\n        \r\n        /**\r\n         * @dev The amount of Dai that will be applied the fee on the next Compound redeem execution (baseExecutionId + 1).\r\n         */\r\n        uint256 baseExecutionAmountForFee;\r\n        \r\n        /**\r\n         * @dev The total of Dai deposited.\r\n         */\r\n        uint256 currentAllocated;\r\n        \r\n        /**\r\n         * @dev The total of Dai previously deposited before the regarded deposit.\r\n         * The deposits are regarded the same if they have the same base execution Id.\r\n         */\r\n        uint256 previousAllocated;\r\n        \r\n        /**\r\n         * @dev The previous Dai profit before the regarded deposit.\r\n         * The deposits are regarded the same if they have the same base execution Id.\r\n         */\r\n        uint256 previousProfit;\r\n        \r\n        /**\r\n         * @dev The previous asset amount before the regarded deposit.\r\n         * The deposits are regarded the same if they have the same base execution Id.\r\n         */\r\n        uint256 previousAssetAmount;\r\n        \r\n        /**\r\n         * @dev The previous fee on Dai before the regarded deposit.\r\n         * The deposits are regarded the same if they have the same base execution Id.\r\n         */\r\n        uint256 previousFeeAmount;\r\n        \r\n        /**\r\n         * @dev The total amount of asset redeemed.\r\n         */\r\n        uint256 redeemed;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emitted when the minimum time between Compound redeem executions has been changed.\r\n     * @param newTime The new minimum time between Compound redeem executions.\r\n     * @param oldTime The previous minimum time between Compound redeem executions.\r\n     */\r\n    event SetMinimumTimeBetweenExecutions(uint256 newTime, uint256 oldTime);\r\n    \r\n    /**\r\n     * @dev Emitted when a user has deposited Dai on the contract.\r\n     * @param user The user's address.\r\n     * @param amount The amount of Dai deposited.\r\n     * @param rate The calculated rate.\r\n     * @param baseExecutionId The last Compound redeem execution Id.\r\n     * @param baseExecutionAmountForFee The amount of Dai that will be applied the fee on the next Compound redeem execution (baseExecutionId + 1).\r\n     */\r\n    event Deposit(address indexed user, uint256 amount, uint256 rate, uint256 baseExecutionId, uint256 baseExecutionAmountForFee);\r\n    \r\n    /**\r\n     * @dev Emitted when a user has redeemed the asset profit on the contract.\r\n     * @param user The user's address.\r\n     * @param amount The amount of asset redeemed.\r\n     */\r\n    event Redeem(address indexed user, uint256 amount);\r\n    \r\n    /**\r\n     * @dev Emitted when a Compound redeem has been executed.\r\n     * @param executionId The respective Id.\r\n     * @param rate The calculated rate.\r\n     * @param totalBalance The total of Dai deposited on the contract.\r\n     * @param totalRedeemed The amount of Dai redeemed on Compound.\r\n     * @param fee The total of Dai redeemed that was regarded as the fee.\r\n     * @param totalBought The amount of asset purchased.\r\n     * @param totalAucBurned The amount of Auc purchased and burned with the fee.\r\n     */\r\n    event CompoundRedeem(uint256 indexed executionId, uint256 rate, uint256 totalBalance, uint256 totalRedeemed, uint256 fee, uint256 totalBought, uint256 totalAucBurned);\r\n    \r\n    /**\r\n     * @dev Emitted when a user has finished the own participation on the dPiggy asset.\r\n     * All asset profit is redeemed as well as all the Dai deposited. \r\n     * @param user The user's address.\r\n     * @param totalRedeemed The amount of Dai redeemed on Compound.\r\n     * @param yield The user yield in Dai redeemed since the last Compound redeem execution.\r\n     * @param fee The total of Dai redeemed that was regarded as the fee.\r\n     * @param totalAucBurned The amount of Auc purchased and burned with the fee.\r\n     */\r\n    event Finish(address indexed user, uint256 totalRedeemed, uint256 yield, uint256 fee, uint256 totalAucBurned);\r\n    \r\n    /**\r\n     * @dev Emitted when the contract is initialized with a previous data due to a proxy migration.\r\n     * @param previousContract The previous contract address.\r\n     */\r\n    event SetMigration(address previousContract);\r\n\r\n    /**\r\n     * @dev The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * It is the asset for the respective contract. \r\n     */\r\n    address public tokenAddress;\r\n    \r\n    /**\r\n     * @dev Minimum time in seconds between executions to run the Compound redeem.\r\n     */\r\n    uint256 public minimumTimeBetweenExecutions;\r\n    \r\n    /**\r\n     * @dev Last Compound redeem execution Id (it is an incremental number).\r\n     */\r\n    uint256 public executionId;\r\n    \r\n    /**\r\n     * @dev The total balance of Dai deposited.\r\n     */\r\n    uint256 public totalBalance;\r\n    \r\n    /**\r\n     * @dev The amount of deposited Dai that has a fee exemption due to the Auc escrowed.\r\n     */\r\n    uint256 public feeExemptionAmountForAucEscrowed;\r\n    \r\n    /**\r\n     * @dev It indicates if the contract asset is the cDai.\r\n     */\r\n    bool public isCompound;\r\n    \r\n    /**\r\n     * @dev The difference between the amount of Dai deposited and the respective value normalized to the last Compound redeem execution time.\r\n     * _key is the execution Id.\r\n     * _value is the difference of Dai.\r\n     */\r\n    mapping(uint256 => uint256) public totalBalanceNormalizedDifference;\r\n    \r\n    /**\r\n     * @dev The difference between the amount of Dai with fee exemption and the respective value normalized to the last Compound redeem execution time.\r\n     * _key is the execution Id.\r\n     * _value is the difference of Dai.\r\n     */\r\n    mapping(uint256 => uint256) public feeExemptionNormalizedDifference;\r\n    \r\n    /**\r\n     * @dev The remaining profit redeemed from Compound.\r\n     * Used on Compound asset to adjust the remaining value on the contract between executions.\r\n     * _key is the execution Id.\r\n     * _value is the redeemed value.\r\n     */\r\n    mapping(uint256 => uint256) public remainingValueRedeemed;\r\n    \r\n    /**\r\n     * @dev The amount of Dai that has a fee exemption for the respective execution due to the user deposit time.\r\n     * _key is the execution Id.\r\n     * _value is the amount of Dai.\r\n     * The user amount of Dai proportion is calculated based on the difference between the deposit time and the next execution time.\r\n     */\r\n    mapping(uint256 => uint256) public feeExemptionAmountForUserBaseData;\r\n    \r\n    /**\r\n     * @dev The Compound redeem executions data.\r\n     * _key is the execution Id.\r\n     * _value is the execution data.\r\n     */\r\n    mapping(uint256 => Execution) public executions;\r\n    \r\n    /**\r\n     * @dev The user data for the asset.\r\n     * _key is the user address.\r\n     * _value is the user data.\r\n     */\r\n    mapping(address => UserData) public usersData;\r\n}\r\n"},"DPiggyAssetInterface.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title DPiggyAssetInterface\r\n * @dev DPiggyAsset interface for external functions used directly on dPiggy.\r\n */\r\ninterface DPiggyAssetInterface {\r\n    function getUserProfitsAndFeeAmount(address user) external view returns(uint256, uint256, uint256);\r\n    function setMinimumTimeBetweenExecutions(uint256 time) external;\r\n    function deposit(address user, uint256 amount) external;\r\n    function addEscrow(address user) external returns(bool);\r\n}"},"DPiggyAssetProxy.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\nimport \"DPiggyBaseProxy.sol\";\r\nimport \"DPiggyAssetData.sol\";\r\n\r\n/**\r\n * @title DPiggyAssetProxy\r\n * @dev A proxy contract for dPiggy asset.\r\n * It must inherit first from DPiggyBaseProxy contract for properly works.\r\n * The stored data is on DPiggyAssetData contract.\r\n */\r\ncontract DPiggyAssetProxy is DPiggyBaseProxy, DPiggyAssetData {\r\n    constructor(\r\n        address _admin, \r\n        address _implementation, \r\n        bytes memory data\r\n    ) public payable DPiggyBaseProxy(_admin, _implementation, data) {\r\n    } \r\n}"},"DPiggyBaseProxy.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\nimport \"Address.sol\";\r\nimport \"DPiggyBaseProxyData.sol\";\r\nimport \"DPiggyBaseProxyInterface.sol\";\r\n\r\n/**\r\n * @title DPiggyBaseProxy\r\n * @dev A proxy contract that implements delegation of calls to other contracts.\r\n * The stored data is on DPiggyBaseProxyData contract.\r\n */\r\ncontract DPiggyBaseProxy is DPiggyBaseProxyData, DPiggyBaseProxyInterface {\r\n\r\n    constructor(address _admin, address _implementation, bytes memory data) public payable {\r\n        admin = _admin;\r\n        _setImplementation(_implementation, data);\r\n    } \r\n  \r\n    /**\r\n     * @dev Fallback function that delegates the execution to an implementation contract.\r\n     */\r\n    fallback() external payable {\r\n        address addr = implementation;\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), addr, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n  \r\n    /**\r\n     * @dev Function to be compliance with EIP 897.\r\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\r\n     * It is an \"upgradable proxy\".\r\n     */\r\n    function proxyType() public pure returns(uint256) {\r\n        return 2; \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the proxy implementation address.\r\n     * Only can be called by the proxy admin.\r\n     * The implementation address must a contract.\r\n     * @param newImplementation Address of the new proxy implementation.\r\n     * @param data ABI encoded with signature data that will be delegated over the new implementation.\r\n     */\r\n    function setImplementation(address newImplementation, bytes calldata data) onlyAdmin external override(DPiggyBaseProxyInterface) payable {\r\n        require(Address.isContract(newImplementation));\r\n        address oldImplementation = implementation;\r\n        _setImplementation(newImplementation, data);\r\n        emit SetProxyImplementation(newImplementation, oldImplementation);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the proxy admin address.\r\n     * Only can be called by the proxy admin.\r\n     * @param newAdmin Address of the new proxy admin.\r\n     */\r\n    function setAdmin(address newAdmin) onlyAdmin external override(DPiggyBaseProxyInterface) {\r\n        require(newAdmin != address(0));\r\n        address oldAdmin = admin;\r\n        admin = newAdmin;\r\n        emit SetProxyAdmin(newAdmin, oldAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the implementation address.\r\n     * @param _implementation Address of the new proxy implementation.\r\n     * @param data ABI encoded with signature data that will be delegated over the new implementation.\r\n     */\r\n    function _setImplementation(address _implementation, bytes memory data) internal {\r\n        implementation = _implementation;\r\n        if (data.length > 0) {\r\n            (bool success,) = _implementation.delegatecall(data);\r\n            assert(success);\r\n        }\r\n    }\r\n}\r\n"},"DPiggyBaseProxyData.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title DPiggyBaseProxyData\r\n * @dev Contract for all DPiggyBaseProxyData stored data.\r\n */\r\ncontract DPiggyBaseProxyData {\r\n    \r\n    /**\r\n     * @dev Emitted when the proxy implementation has been changed.\r\n     * @param newImplementation Address of the new proxy implementation.\r\n     * @param oldImplementation Address of the previous proxy implementation.\r\n     */\r\n    event SetProxyImplementation(address indexed newImplementation, address oldImplementation);\r\n    \r\n    /**\r\n     * @dev Emitted when the admin address has been changed.\r\n     * @param newAdmin Address of the new admin.\r\n     * @param oldAdmin Address of the previous admin.\r\n     */\r\n    event SetProxyAdmin(address indexed newAdmin, address oldAdmin);\r\n    \r\n    /**\r\n     * @dev Modifier to check if the `msg.sender` is the admin.\r\n     * Only admin address can execute.\r\n     */\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev The contract address of the implementation.\r\n     */\r\n    address public implementation;\r\n    \r\n    /**\r\n     * @dev The admin address.\r\n     */\r\n    address public admin;\r\n}\r\n"},"DPiggyBaseProxyInterface.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title DPiggyBaseProxyInterface\r\n * @dev DPiggyBaseProxy interface with external functions.\r\n */\r\ninterface DPiggyBaseProxyInterface {\r\n    function setImplementation(address newImplementation, bytes calldata data) external payable;\r\n    function setAdmin(address newAdmin) external;\r\n}"},"DPiggyData.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\nimport \"DPiggyBaseProxyData.sol\";\r\nimport \"ReentrancyGuard.sol\";\r\nimport \"DPiggyInterface.sol\";\r\n\r\n/**\r\n * @title DPiggyData\r\n * @dev Contract for all dPiggy stored data.\r\n * It must inherit from DPiggyBaseProxyData contract for properly generate the proxy.\r\n */\r\ncontract DPiggyData is DPiggyBaseProxyData, ReentrancyGuard, DPiggyDataInterface {\r\n    \r\n    /**\r\n     * @dev The Struct to store each user escrow data.\r\n     */\r\n    struct EscrowData {\r\n        /**\r\n         * @dev The amount of Auc escrowed.\r\n         */\r\n        uint256 amount;\r\n        \r\n        /**\r\n         * @dev The time in Unix that the escrow occurred.\r\n         */\r\n        uint256 time;\r\n    }\r\n    \r\n    /**\r\n     * @dev The Struct to store each dPiggy asset data.\r\n     */\r\n    struct AssetData {\r\n        /**\r\n         * @dev The proxy contract address that runs the asset base implementation contract.\r\n         */\r\n        address proxy;\r\n        \r\n        /**\r\n         * @dev It defines whether the deposit of Dai is allowed.\r\n         */\r\n        bool depositAllowed;\r\n        \r\n        /**\r\n         * @dev The creation time in Unix.\r\n         */\r\n        uint256 time;\r\n        \r\n        /**\r\n         * @dev The minimum amount of Dai that can be deposited.\r\n         */\r\n        uint256 minimumDeposit;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emitted when the daily fee has been changed.\r\n     * @param newDailylFee The new daily fee.\r\n     * @param oldDailylFee The previous daily fee.\r\n     */\r\n    event SetDailyFee(uint256 newDailylFee, uint256 oldDailylFee);\r\n    \r\n    /**\r\n     * @dev Emitted when the minimum amount of Auc escrowed to have the fee exemption has been changed.\r\n     * @param newMinimumAuc The new minimum amount of Auc escrowed to have the fee exemption.\r\n     * @param oldMinimumAuc The previous minimum amount of Auc escrowed to have the fee exemption.\r\n     */\r\n    event SetMinimumAucToFreeFee(uint256 newMinimumAuc, uint256 oldMinimumAuc);\r\n    \r\n    /**\r\n     * @dev Emitted when a user has escrowed Auc on the contract.\r\n     * @param user The user's address.\r\n     * @param amount The amount of Auc escrowed.\r\n     */\r\n    event SetUserAucEscrow(address indexed user, uint256 amount);\r\n    \r\n    /**\r\n     * @dev Emitted when a user has redeemed the Auc escrowed.\r\n     * @param user The user's address.\r\n     * @param amount The amount of Auc redeemed.\r\n     */\r\n    event RedeemUserAucEscrow(address indexed user, uint256 amount);\r\n    \r\n    /**\r\n     * @dev Emitted when a new dPiggy asset has been created.\r\n     * @param tokenAddress The ERC20 token address (0x0 for Ethereum).\r\n     * @param proxy The proxy contract address created that runs the asset base implementation contract.\r\n     */\r\n    event SetNewAsset(address indexed tokenAddress, address proxy);\r\n    \r\n    /**\r\n     * @dev Emitted when the dPiggy asset deposit permission has changed.\r\n     * @param tokenAddress The ERC20 token address (0x0 for Ethereum).\r\n     * @param newDepositAllowed The new condition for the permission for the deposit of Dai.\r\n     * @param oldDepositAllowed The previous condition for the permission for the deposit of Dai.\r\n     */\r\n    event SetAssetDepositAllowed(address indexed tokenAddress, bool newDepositAllowed, bool oldDepositAllowed);\r\n    \r\n    /**\r\n     * @dev Emitted when the dPiggy asset minimum Dai for deposit has changed.\r\n     * @param tokenAddress The ERC20 token address (0x0 for Ethereum).\r\n     * @param newMinimumDeposit The new minimum amount of Dai that can be deposited.\r\n     * @param oldMinimumDeposit The previous minimum amount of Dai that can be deposited.\r\n     */\r\n    event SetAssetMinimumDeposit(address indexed tokenAddress, uint256 newMinimumDeposit, uint256 oldMinimumDeposit);\r\n\r\n    /**\r\n     * @dev Address for the Auc token contract.\r\n     */\r\n    address public override(DPiggyDataInterface) auc;\r\n    \r\n    /**\r\n     * @dev Address for the Dai token contract.\r\n     */\r\n    address public override(DPiggyDataInterface) dai;\r\n    \r\n    /**\r\n     * @dev Address for the cDai (the Compound contract).\r\n     */\r\n    address public override(DPiggyDataInterface) compound;\r\n    \r\n    /**\r\n     * @dev Address for the Uniswap Dai exchange contract.\r\n     */\r\n    address public override(DPiggyDataInterface) exchange;\r\n    \r\n    /**\r\n     * @dev Address for the Uniswap factory contract.\r\n     */\r\n    address public uniswapFactory;\r\n    \r\n    /**\r\n     * @dev Address for the asset base implementation contract.\r\n     */\r\n    address public assetImplementation;\r\n    \r\n    /**\r\n     * @dev The percentage precision. \r\n     * The value represents the 100%.\r\n     */\r\n    uint256 public override(DPiggyDataInterface) percentagePrecision;\r\n    \r\n    /**\r\n     * @dev The minimum amount of Auc escrowed to have the fee exemption.\r\n     */\r\n    uint256 public minimumAucToFreeFee;\r\n    \r\n    /**\r\n     * @dev Total amount of Auc escrowed.\r\n     */\r\n    uint256 public totalEscrow;\r\n    \r\n    /**\r\n     * @dev The maximum value that can be defined for the daily fee percentage.\r\n     */\r\n    uint256 public maximumDailyFee;\r\n    \r\n    /**\r\n     * @dev The daily fee percentage (with percentage precision).\r\n     */\r\n    uint256 public dailyFee;\r\n    \r\n    /**\r\n     * @dev The number of dPiggy assets.\r\n     */\r\n    uint256 public numberOfAssets;\r\n    \r\n    /**\r\n     * @dev Array for all dPiggy assets. \r\n     * The ERC20 token addresses (0x0 for Ethereum).\r\n     */\r\n    address[] public assets;\r\n    \r\n    /**\r\n     * @dev The user escrow data.\r\n     * _key is the user address.\r\n     * _value is the user escrow data.\r\n     */\r\n    mapping(address => EscrowData) public usersEscrow;\r\n    \r\n    /**\r\n     * @dev The dPiggy asset data.\r\n     * _key is the ERC20 token address (0x0 for Ethereum).\r\n     * _value is the dPiggy asset data.\r\n     */\r\n    mapping(address => AssetData) public assetsData;\r\n}"},"DPiggyInterface.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title DPiggyDataInterface\r\n * @dev DPiggyData interface with stored data used by other contracts.\r\n */\r\ninterface DPiggyDataInterface {\r\n    function auc() external view returns(address);\r\n    function dai() external view returns(address);\r\n    function compound() external view returns(address);\r\n    function exchange() external view returns(address);\r\n    function percentagePrecision() external view returns(uint256);\r\n}\r\n\r\n/**\r\n * @title DPiggyInterface\r\n * @dev DPiggy interface with stored data and functions used by other contracts.\r\n */\r\ninterface DPiggyInterface is DPiggyDataInterface {\r\n    function executionFee(uint256 baseTime) external view returns(uint256);\r\n    function escrowStart(address user) external view returns(uint256);\r\n}"},"EIP20Interface.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title EIP20Interface\r\n * @dev EIP 20 token contract interface.\r\n */\r\ninterface EIP20Interface {\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint8);\r\n    function totalSupply() external view returns(uint256);\r\n    function balanceOf(address owner) external view returns(uint256);\r\n    function allowance(address owner, address spender) external view returns(uint256);\r\n    function approve(address usr, uint amount) external returns(bool);\r\n    function transfer(address dst, uint256 amount) external returns(bool);\r\n    function transferFrom(address src, address dst, uint amount) external returns(bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}"},"ReentrancyGuard.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @dev Base contract with a modifier that implements a reentrancy guard.\r\n */\r\ncontract ReentrancyGuard {\r\n    /**\r\n     * @dev Internal data to control the reentrancy.\r\n     */\r\n    bool internal _notEntered;\r\n\r\n    /**\r\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\r\n     */\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"ReentrancyGuard:: reentry\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true;\r\n    }\r\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n// OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol \r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"UniswapFactoryInterface.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\n/**\r\n * @title UniswapFactoryInterface\r\n * @dev Uniswap factory interface.\r\n * https://docs.uniswap.io/smart-contract-api/factory\r\n */\r\ninterface UniswapFactoryInterface {\r\n    // Create Exchange\r\n    function createExchange(address token) external returns (address exchange);\r\n    // Get Exchange and Token Info\r\n    function getExchange(address token) external view returns (address exchange);\r\n    function getToken(address exchange) external view returns (address token);\r\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\r\n    // Never use\r\n    function initializeFactory(address template) external;\r\n}"},"browser/DPiggy.sol":{"content":"pragma solidity ^0.6.4;\r\n\r\nimport \"SafeMath.sol\";\r\nimport \"EIP20Interface.sol\";\r\nimport \"AucReceiverInterface.sol\";\r\nimport \"UniswapFactoryInterface.sol\";\r\nimport \"DPiggyInterface.sol\";\r\nimport \"DPiggyAssetInterface.sol\";\r\nimport \"DPiggyBaseProxyInterface.sol\";\r\nimport \"DPiggyAssetProxy.sol\";\r\nimport \"DPiggyData.sol\";\r\n\r\n/**\r\n * @title DPiggy\r\n * @dev The contract is proxied for dPiggyProxy.\r\n * It is the implementation of the gateway contract for dPiggy.\r\n * The contract manages all assets and general data for dPiggy system.\r\n */\r\ncontract DPiggy is DPiggyData, DPiggyInterface, AucReceiverInterface {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Function to initialize the contract.\r\n     * It should be called through the `data` argument when creating the proxy.\r\n     * It must be called only once. The `assert` is to guarantee that behavior.\r\n     * @param _percentagePrecision The percentage precision. The value represents the 100%.\r\n     * @param _dailyFee The daily fee percentage (with percentage precision).\r\n     * @param _maximumDailyFee The maximum value that can be defined for the daily fee percentage.\r\n     * @param _minimumAucToFreeFee The minimum amount of Auc escrowed to have the fee exemption.\r\n     * @param _dai Address for the Dai token contract.\r\n     * @param _compound Address for the cDai (the Compound contract).\r\n     * @param _uniswapFactory Address for the Uniswap factory contract.\r\n     * @param _auc Address for the Auc token contract.\r\n     * @param _assetImplementation Address for the asset base implementation contract.\r\n     */\r\n    function init(\r\n        uint256 _percentagePrecision,\r\n        uint256 _dailyFee,\r\n        uint256 _maximumDailyFee,\r\n        uint256 _minimumAucToFreeFee,\r\n        address _dai,\r\n        address _compound,\r\n        address _uniswapFactory,\r\n        address _auc,\r\n        address _assetImplementation) public {\r\n        \r\n        assert(\r\n            assetImplementation == address(0) && \r\n            auc == address(0) && \r\n            dai == address(0) && \r\n            percentagePrecision == 0 && \r\n            maximumDailyFee == 0\r\n        );\r\n        \r\n        require(_dailyFee <= _maximumDailyFee, \"DPiggy::init: Invalid fee\");\r\n        \r\n        percentagePrecision = _percentagePrecision;\r\n        dailyFee = _dailyFee;\r\n        maximumDailyFee = _maximumDailyFee;\r\n        minimumAucToFreeFee = _minimumAucToFreeFee;\r\n        dai = _dai;\r\n        auc = _auc;\r\n        compound = _compound;\r\n        assetImplementation = _assetImplementation;\r\n        uniswapFactory = _uniswapFactory;\r\n        \r\n        //Set Dai Uniswap exchange using the uniswapFactory address.\r\n        setExchange();\r\n        \r\n        /* Initialize the stored data that controls the reentrancy guard.\r\n         * Due to the proxy, it must be set on a separate initialize method instead of the constructor.\r\n         */\r\n        _notEntered = true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to guarantee that the contract will not receive ether.\r\n     */\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to calculate the Compound redeem fee.\r\n     * It calculates how many days the argument represents then it is calculated:\r\n     * (100% + `dailyFee`)^(number of days) - 100%\r\n     * @param baseTime Period of time in seconds. It is not a Unix time.\r\n     * @return Fee for the amount of time informed with a dPiggy percentage precision.\r\n     */\r\n    function executionFee(uint256 baseTime) external override(DPiggyInterface) view returns(uint256) {\r\n        uint256 daysAmount = baseTime / 86400;\r\n        if (daysAmount == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 pow = percentagePrecision + dailyFee;\r\n            uint256 base = pow;\r\n            for (uint256 i = 1; i < daysAmount; ++i) {\r\n                pow = (base * pow / percentagePrecision);\r\n            }\r\n            return pow - percentagePrecision;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to return the escrow start time.\r\n     * @param user User's address.\r\n     * @return The Unix time for user escrow start. Zero means no escrow.\r\n     */\r\n    function escrowStart(address user) external override(DPiggyInterface) view returns(uint256) {\r\n        EscrowData storage escrow = usersEscrow[user];\r\n        return escrow.time;\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the total amount of Dai deposited.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @return The total amount of Dai deposited.\r\n     */\r\n    function getTotalInvested(address tokenAddress) external view returns(uint256) {\r\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\"totalBalance()\"));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the minimum time for the next Compound redeem execution.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @return The minimum time in Unix for the next Compound redeem execution.\r\n     */\r\n    function getMinimumTimeForNextExecution(address tokenAddress) external view returns(uint256) {\r\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\"getMinimumTimeForNextExecution()\"));\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the minimum amount of Dai allowed to deposit on the asset.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @return The minimum amount of Dai allowed to deposit on the asset.\r\n     */\r\n    function getMinimumDeposit(address tokenAddress) external view returns(uint256) {\r\n        AssetData storage assetData = assetsData[tokenAddress];\r\n        if (assetData.time > 0) {\r\n            return assetData.minimumDeposit;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the user's Dai gross profit, asset net profit and the fee amount in Dai.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param user User's address. \r\n     * @return The user's Dai gross profit, asset net profit and the fee amount charged in Dai. \r\n     * First return is the gross profit in Dai.\r\n     * Second return is the asset net profit.\r\n     * Third return is the fee amount charged in Dai.\r\n     */\r\n    function getUserProfitsAndFeeAmount(address tokenAddress, address user) external view returns(uint256, uint256, uint256) {\r\n        AssetData storage assetData = assetsData[tokenAddress];\r\n        if (assetData.time > 0) {\r\n            return DPiggyAssetInterface(assetData.proxy).getUserProfitsAndFeeAmount(user);\r\n        }\r\n        return (0, 0, 0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the estimated current gross profit in Dai for the user.\r\n     * So it is not the total gross profit, it is only for the user amount of Dai on the next Compound redeem execution.\r\n     * The estimative to the amount of Dai on the Compound redeem execution considering the Compound exchange rate now.\r\n     * For an estimated total of the gross profit: `getUserProfit` + `getUserEstimatedCurrentProfitWithoutFee`.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param user User's address. \r\n     * @return The estimated gross profit in Dai. \r\n     */\r\n    function getUserEstimatedCurrentProfitWithoutFee(address tokenAddress, address user) external view returns(uint256) {\r\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\"getUserEstimatedCurrentProfitWithoutFee(address)\", user));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the estimated current fee in Dai for the user.\r\n     * To estimate the amount of fee on the Compound redeem execution, it is calculated by the difference between the `time` and the last execution time.\r\n     * So it is not the total amount of fee, for an estimated total of the fee in Dai: \r\n     * `getUserAssetProfitAndFeeAmount(second return)` + `getUserEstimatedCurrentFee`.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param user User's address. \r\n     * @param time The Unix time to calculate the fee. It should be the current Unix time. \r\n     * @return The estimated fee in Dai. \r\n     */\r\n    function getUserEstimatedCurrentFee(address tokenAddress, address user, uint256 time) external view returns(uint256) {\r\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\"getUserEstimatedCurrentFee(address,uint256)\", user, time));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the amount of asset redeemed for the user.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param user User's address. \r\n     * @return The amount of asset redeemed. \r\n     */\r\n    function getUserAssetRedeemed(address tokenAddress, address user) external view returns(uint256) {\r\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\"getUserAssetRedeemed(address)\", user));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to get the amount of Dai deposited for the user.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param user User's address. \r\n     * @return The amount of Dai deposited. \r\n     */\r\n    function getUserTotalInvested(address tokenAddress, address user) external view returns(uint256) {\r\n        return _getValueFromAsset(tokenAddress, abi.encodeWithSignature(\"getUserTotalInvested(address)\", user));\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set Dai Uniswap exchange using the uniswapFactory address.\r\n     * It is public because uses fixed and controlled parameters.\r\n     */\r\n    function setExchange() public {\r\n        exchange = UniswapFactoryInterface(uniswapFactory).getExchange(dai);  \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the daily fee.\r\n     * Only can be called by the admin.\r\n     * The new value must be lower than the stored maximum daily fee.\r\n     * @param _dailyFee New daily fee with dPiggy percentage precision.\r\n     */\r\n    function setDailyFee(uint256 _dailyFee) onlyAdmin external {\r\n        require(_dailyFee <= maximumDailyFee, \"DPiggy::setDailyFee: Invalid fee\");\r\n        uint256 oldDailyFee = dailyFee;\r\n        dailyFee = _dailyFee;\r\n        emit SetDailyFee(_dailyFee, oldDailyFee);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the minimum amount of Auc escrowed to have the fee exemption.\r\n     * Only can be called by the admin.\r\n     * @param _minimumAucToFreeFee New minimum amount of Auc.\r\n     */\r\n    function setMinimumAucToFreeFee(uint256 _minimumAucToFreeFee) onlyAdmin external {\r\n        uint256 oldMinimumAucToFreeFee = minimumAucToFreeFee;\r\n        minimumAucToFreeFee = _minimumAucToFreeFee;\r\n        emit SetMinimumAucToFreeFee(_minimumAucToFreeFee, oldMinimumAucToFreeFee);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the implementation address for the dPiggy assets proxy.\r\n     * Only can be called by the admin.\r\n     * @param _assetImplementation New implementation contract address.\r\n     * @param updateData (optional) ABI encoded with signature data that will be delegated on the new implementation.\r\n     */\r\n    function setAssetImplementation(address _assetImplementation, bytes calldata updateData) onlyAdmin external payable {\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            AssetData storage assetData = assetsData[assets[i]];\r\n            DPiggyBaseProxyInterface(assetData.proxy).setImplementation(_assetImplementation, updateData);\r\n        }\r\n        \r\n        assetImplementation = _assetImplementation;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the new proxy for the dPiggy asset and migrates the previous data.\r\n     * Only can be called by the admin.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param _assetImplementation New implementation contract address.\r\n     * @param users The users to copy their stored data.\r\n     */\r\n    function migrateAssetProxy(address tokenAddress, address _assetImplementation, address[] calldata users) onlyAdmin external {\r\n        AssetData storage assetData = assetsData[tokenAddress];\r\n        require(assetData.time > 0, \"DPiggy::migrateAssetProxy: Invalid tokenAddress\");\r\n        \r\n        // Encoded data to initialize the new proxy with the previous asset data.\r\n        bytes memory initData = abi.encodeWithSignature(\"initMigratingData(address,address[])\", assetData.proxy, users);    \r\n        address newProxy = address(new DPiggyAssetProxy(address(this), _assetImplementation, initData));\r\n        \r\n        // Encoded data to resign the previous implementation of the asset.\r\n        bytes memory resignData = abi.encodeWithSignature(\"resignAssetForMigration(address[])\", users);\r\n        // Resign the implementation and get the cDai and asset amount.\r\n        (bool success, bytes memory returnData) = assetData.proxy.call(resignData);\r\n        assert(success);\r\n        uint256[] memory amounts = _getUint256(returnData);\r\n        \r\n        // Transfer the amounts for the new proxy contract.\r\n        if (amounts[0] > 0) {\r\n            assert(EIP20Interface(compound).transfer(newProxy, amounts[0]));\r\n        }\r\n        if (amounts[1] > 0) {\r\n            if (tokenAddress != address(0)) {\r\n                assert(EIP20Interface(tokenAddress).transfer(newProxy, amounts[1]));\r\n            } else {\r\n                Address.toPayable(newProxy).transfer(amounts[1]);\r\n            }\r\n        }\r\n        \r\n        // Update the asset proxy address.\r\n        assetData.proxy = newProxy;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to create a new dPiggy asset.\r\n     * Only can be called by the admin.\r\n     * The asset cannot already exist on dPiggy.\r\n     * A DPiggyAssetProxy is created using the `assetImplementation` address.\r\n     * dPiggy contract is the admin for this proxy.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. \r\n     * @param minimumDeposit The minimum amount of Dai that can be deposited for the asset.\r\n     * @param creationData ABI encoded with signature data that will be delegated on the new implementation.\r\n     */\r\n    function createAsset(\r\n        address tokenAddress, \r\n        uint256 minimumDeposit,\r\n        bytes calldata creationData\r\n    ) onlyAdmin external payable {     \r\n        \r\n        AssetData storage assetData = assetsData[tokenAddress];\r\n        require(assetData.time == 0, \"DPiggy::createAsset: Asset already exists\");\r\n        assetData.time = now;\r\n        assetData.depositAllowed = false;\r\n        assetData.minimumDeposit = minimumDeposit;\r\n        assetData.proxy = address(new DPiggyAssetProxy(address(this), assetImplementation, creationData));\r\n        \r\n        assets.push(tokenAddress);\r\n        numberOfAssets++;\r\n        \r\n        emit SetNewAsset(tokenAddress, assetData.proxy); \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the deposit permission for dPiggy asset.\r\n     * Only can be called by the admin.\r\n     * Both array parameters must be the same size because the value is set through the same array index position.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     * @param allowed Array with the deposit permission conditions.\r\n     */\r\n    function setAssetsDepositAllowed(address[] calldata tokenAddresses, bool[] calldata allowed) onlyAdmin external {\r\n        require(tokenAddresses.length > 0, \"DPiggy::setAssetsDepositAllowed: tokenAddresses is required\");\r\n        require(tokenAddresses.length == allowed.length, \"DPiggy::setAssetsDepositAllowed: Invalid data\");\r\n        \r\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\r\n            AssetData storage assetData = assetsData[tokenAddresses[i]];\r\n            if (assetData.time > 0) {\r\n                bool oldDepositAllowed = assetData.depositAllowed;\r\n                assetData.depositAllowed = allowed[i];\r\n                emit SetAssetDepositAllowed(tokenAddresses[i], allowed[i], oldDepositAllowed);\r\n            }\r\n        }   \r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the minimum amount of Dai allowed to deposit on dPiggy asset.\r\n     * Only can be called by the admin.\r\n     * Both array parameters must be the same size because the value is set through the same array index position.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     * @param minimumDeposits Array with the minimum amount of Dai allowed for deposit.\r\n     */\r\n    function setAssetsMinimumDeposit(address[] calldata tokenAddresses, uint256[] calldata minimumDeposits) onlyAdmin external {\r\n        require(tokenAddresses.length > 0, \"DPiggy::setAssetsMinimumDeposit: tokenAddresses is required\");\r\n        require(tokenAddresses.length == minimumDeposits.length, \"DPiggy::setAssetsMinimumDeposit: Invalid data\");\r\n        \r\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\r\n            AssetData storage assetData = assetsData[tokenAddresses[i]];\r\n            if (assetData.time > 0) {\r\n                uint256 oldMinimumDeposit = assetData.minimumDeposit;\r\n                assetData.minimumDeposit = minimumDeposits[i];\r\n                emit SetAssetMinimumDeposit(tokenAddresses[i], minimumDeposits[i], oldMinimumDeposit);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to set the minimum time between the Compound redeem executions for a dPiggy asset.\r\n     * Only can be called by the admin.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     * @param time New minimum time in seconds between the Compound redeem executions.\r\n     */\r\n    function setMinimumTimeBetweenExecutions(address tokenAddress, uint256 time) onlyAdmin external {\r\n        AssetData storage assetData = assetsData[tokenAddress];\r\n        require(assetData.time > 0, \"DPiggy::setMinimumTimeBetweenExecutions: Invalid tokenAddress\");\r\n        DPiggyAssetInterface(assetData.proxy).setMinimumTimeBetweenExecutions(time);  \r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to deliberately redeem the user asset profit.\r\n     * Only can be called by the admin.\r\n     * Although being called by the admin, the user asset profit is redeemed to the respective user address. \r\n     * @param users Array with user addresses.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     */\r\n    function forceRedeem(address[] calldata users, address[] calldata tokenAddresses) nonReentrant onlyAdmin external {\r\n        require(users.length > 0, \"DPiggy::forceRedeem: users is required\");\r\n        \r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            _setAsset(tokenAddresses, abi.encodeWithSignature(\"forceRedeem(address)\", users[i]));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to deliberately finish the user participation.\r\n     * All asset profit is redeemed as well as all the Dai deposited for the respective assets. \r\n     * Only can be called by the admin.\r\n     * Although being called by the admin, assets and Dai redeemed are done to the respective user address. \r\n     * @param users Array with user addresses.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     */\r\n    function forceFinish(address[] calldata users, address[] calldata tokenAddresses) nonReentrant onlyAdmin external {\r\n        require(users.length > 0, \"DPiggyAssetManager::forceFinish: users is required\");\r\n        \r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            _setAsset(tokenAddresses, abi.encodeWithSignature(\"forceFinish(address)\", users[i]));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to deliberately finish the user participation in all dPiggy assets.\r\n     * All assets profit is redeemed as well as all the Dai deposited. \r\n     * Whether the user has the Auc escrow it will be redeemed also.\r\n     * Only can be called by the admin.\r\n     * Although being called by the admin, assets and Dai redeemed are done to the respective user address. \r\n     * @param users Array with user addresses.\r\n     */\r\n    function forceFinishAll(address[] calldata users) nonReentrant onlyAdmin external {\r\n        require(users.length > 0, \"DPiggyAssetManager::forceFinishAll: users is required\");\r\n        \r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            _setAsset(assets, abi.encodeWithSignature(\"forceFinish(address)\", users[i]));\r\n            _redeemEscrow(users[i]);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to deposit Dai on dPiggy assets.\r\n     * Both array parameters must be the same size because the percentage is set through the same array index position.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. \r\n     * @param percentages Array with respective assets percentage allocation (with dPiggy percentage precision).\r\n     */\r\n    function deposit(address[] calldata tokenAddresses, uint256[] calldata percentages) nonReentrant external {\r\n        require(tokenAddresses.length > 0, \"DPiggy::deposit: Distribution is required\");\r\n        require(tokenAddresses.length == percentages.length, \"DPiggy::deposit: Invalid distribution\");\r\n        \r\n        //The amount of Dai is the allowed quantity defined by the user for the dPiggy contract on a previous transaction.\r\n        uint256 amount = EIP20Interface(dai).allowance(msg.sender, address(this));\r\n        \r\n        if (amount > 0) {\r\n            require(EIP20Interface(dai).transferFrom(msg.sender, address(this), amount), \"DPiggy::deposit: Error on transfer Dai\");\r\n            \r\n            uint256 totalDistribution = 0;\r\n            uint256 remainingAmount = amount;\r\n            for (uint256 i = 0; i < tokenAddresses.length; i++) {\r\n                AssetData storage assetData = assetsData[tokenAddresses[i]];\r\n                \r\n                require(assetData.depositAllowed, \"DPiggy::deposit: Deposit denied\");\r\n                \r\n                uint256 assetAmount;\r\n                if (i == (tokenAddresses.length - 1)) {\r\n                    //The last iterated asset gets the remaining amount to avoid rounding losses on percentage calculations.\r\n                    assetAmount = remainingAmount;\r\n                } else {\r\n                    assetAmount = amount.mul(percentages[i]).div(percentagePrecision);\r\n                    remainingAmount = remainingAmount.sub(assetAmount);\r\n                } \r\n                \r\n                require(assetAmount >= assetData.minimumDeposit, \"DPiggy::deposit: Invalid amount\");\r\n                \r\n                //Forwarding the deposit amount of Dai for the respective asset.\r\n                require(EIP20Interface(dai).transfer(assetData.proxy, assetAmount), \"DPiggy::deposit: Error on transfer Dai to asset\");\r\n                DPiggyAssetInterface(assetData.proxy).deposit(msg.sender, assetAmount);\r\n                \r\n                totalDistribution = totalDistribution.add(percentages[i]);\r\n            }\r\n            \r\n            require(totalDistribution == percentagePrecision, \"DPiggy::deposit: Invalid percentage distribution\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to execute the Compound redeem.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     */\r\n    function executeCompoundRedeem(address[] calldata tokenAddresses) nonReentrant external {\r\n        _setAsset(tokenAddresses, abi.encodeWithSignature(\"executeCompoundRedeem()\"));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to redeem the asset profit.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     */\r\n    function redeem(address[] calldata tokenAddresses) nonReentrant external {\r\n        _setAsset(tokenAddresses, abi.encodeWithSignature(\"forceRedeem(address)\", msg.sender));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to finish the participation.\r\n     * All assets profit is redeemed as well as all the Dai deposited.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy.\r\n     */\r\n    function finish(address[] calldata tokenAddresses) nonReentrant external {\r\n        _setAsset(tokenAddresses, abi.encodeWithSignature(\"forceFinish(address)\", msg.sender));\r\n    }\r\n    \r\n    /**\r\n     * @dev Forwarding function to dPiggy asset to finish the participation in all dPiggy assets.\r\n     * All assets profit is redeemed as well as all the Dai deposited.\r\n     * Whether the transaction sender has the Auc escrow it will be redeemed also.\r\n     */\r\n    function finishAll() nonReentrant external {\r\n        _setAsset(assets, abi.encodeWithSignature(\"forceFinish(address)\", msg.sender));\r\n        _redeemEscrow(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to receive the Auc escrowed.\r\n     * The sender must be the Auc token contract. It occurs after an EIP 223 transfer call.\r\n     * On this transfer, the destination address is the dPiggy contract.\r\n     * The user must send exactly the minimum amount of Auc to have the fee exemption and cannot already have Auc escrowed.\r\n     * @param from The user address. \r\n     * @param amount Amount of Auc.\r\n     */\r\n    function tokenFallback(address from, uint256 amount, bytes calldata) nonReentrant external override(AucReceiverInterface) {\r\n        require(msg.sender == address(auc), \"DPiggy::tokenFallback: Invalid sender\");\r\n        require(amount == minimumAucToFreeFee, \"DPiggy::tokenFallback: Invalid amount\");\r\n        \r\n        EscrowData storage escrow = usersEscrow[from];\r\n        require(escrow.time == 0, \"DPiggy::tokenFallback: User already has an escrow\");\r\n        \r\n        escrow.time = now;\r\n        escrow.amount = amount;\r\n        totalEscrow = totalEscrow.add(amount);\r\n        \r\n        bool escrowAdded = false;\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            AssetData storage assetData = assetsData[assets[i]];\r\n            \r\n            //Forwarding the Auc escrowed situation for the respective asset.\r\n            if (DPiggyAssetInterface(assetData.proxy).addEscrow(from) && !escrowAdded) {\r\n                escrowAdded = true;\r\n            }\r\n        }\r\n        require(escrowAdded, \"DPiggy::tokenFallback: User without data\");\r\n        \r\n        emit SetUserAucEscrow(from, amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to redeem the Auc escrowed.\r\n     * It transfers the Auc escrowed for the user address and remove the escrow from the stored data.\r\n     * @param user User's address. \r\n     */\r\n    function _redeemEscrow(address user) internal {\r\n        EscrowData storage escrow = usersEscrow[user];\r\n        uint256 amount = escrow.amount;\r\n        if (amount > 0) {\r\n            escrow.time = 0;\r\n            escrow.amount = 0;\r\n            totalEscrow = totalEscrow.sub(amount);\r\n            require(EIP20Interface(auc).transfer(user, amount), \"DPiggy::redeemEscrow: Error on transfer escrow\");\r\n            emit RedeemUserAucEscrow(user, amount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to run a command on dPiggy asset.\r\n     * @param tokenAddresses Array with ERC20 token addresses or '0x0' for Ethereum. The asset must already exist on dPiggy. \r\n     * @param data ABI encoded with signature data that will be called on dPiggy asset.\r\n     */\r\n    function _setAsset(address[] memory tokenAddresses, bytes memory data) internal {\r\n        require(tokenAddresses.length > 0, \"DPiggy::setAsset: tokenAddresses is required\");\r\n        \r\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\r\n            AssetData storage assetData = assetsData[tokenAddresses[i]];\r\n            if (assetData.time > 0) {\r\n                (bool success,) = assetData.proxy.call(data);\r\n                assert(success);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get a unit256 value on dPiggy asset.\r\n     * @param tokenAddress The ERC20 token address on the chain or '0x0' for Ethereum. The asset must already exist on dPiggy. \r\n     * @param data ABI encoded with signature data that will be static called on dPiggy asset.\r\n     */\r\n    function _getValueFromAsset(address tokenAddress, bytes memory data) internal view returns(uint256) {\r\n        AssetData storage assetData = assetsData[tokenAddress];\r\n        if (assetData.time > 0) {\r\n            (bool success, bytes memory returndata) = assetData.proxy.staticcall(data);\r\n            if (success) {\r\n                return abi.decode(returndata, (uint256));\r\n            } else {\r\n                return 0;\r\n            }\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function _getUint256(bytes memory data) internal pure returns(uint256[] memory) {\r\n        uint256 size = data.length / 32;\r\n        uint256[] memory returnUint = new uint256[](size);\r\n        uint256 offset = 0;\r\n        for (uint256 i = 0; i < size; ++i) {\r\n            bytes32 number;\r\n            for (uint256 j = 0; j < 32; j++) {\r\n                number |= bytes32(data[offset + j] & 0xFF) >> (j * 8);\r\n            }\r\n            returnUint[i] = uint256(number);\r\n            offset += 32;\r\n        }\r\n        return returnUint;\r\n    }\r\n}\r\n"}}}