{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ETHVault.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call{ value : amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract pFDIVault {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n    \n    struct RewardDivide {\n        uint256 amount;\n        uint256 startTime;\n        uint256 checkTime;\n    }\n\n    string public _vaultName;\n    IERC20 public token1;\n    address payable public feeAddress;\n    address payable public vaultAddress;\n    uint32 public feePermill = 5;\n    uint256 public delayDuration = 7 days;\n    bool public withdrawable;\n    \n    address public gov;\n    uint256 public totalDeposit;\n    mapping(address => uint256) public depositBalances;\n    mapping(address => uint256) public rewardBalances;\n    address[] public addressIndices;\n\n    mapping(uint256 => RewardDivide) public _rewards;\n    uint256 public _rewardCount;\n\n    event SentReward(uint256 amount);\n    event Deposited(address indexed user, uint256 amount);\n    event ClaimedReward(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    constructor (address _token1, address payable _feeAddress, address payable _vaultAddress, string memory name) {\n        token1 = IERC20(_token1);\n        feeAddress = _feeAddress;\n        vaultAddress = _vaultAddress;\n        _vaultName = name;\n        gov = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == gov, \"!governance\");\n        _;\n    }\n\n    function setGovernance(address _gov)\n        external\n        onlyGov\n    {\n        gov = _gov;\n    }\n\n    function setToken1(address _token)\n        external\n        onlyGov\n    {\n        token1 = IERC20(_token);\n    }\n\n    function setFeeAddress(address payable _feeAddress)\n        external\n        onlyGov\n    {\n        feeAddress = _feeAddress;\n    }\n\n    function setVaultAddress(address payable _vaultAddress)\n        external\n        onlyGov\n    {\n        vaultAddress = _vaultAddress;\n    }\n\n    function setFeePermill(uint32 _feePermill)\n        external\n        onlyGov\n    {\n        feePermill = _feePermill;\n    }\n\n    function setDelayDuration(uint32 _delayDuration)\n        external\n        onlyGov\n    {\n        delayDuration = _delayDuration;\n    }\n\n    function setWithdrawable(bool _withdrawable)\n        external\n        onlyGov\n    {\n        withdrawable = _withdrawable;\n    }\n\n    function setVaultName(string memory name)\n        external\n        onlyGov\n    {\n        _vaultName = name;\n    }\n\n    function balance0()\n        public\n        view\n        returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function balance1()\n        public\n        view\n        returns (uint256)\n    {\n        return token1.balanceOf(address(this));\n    }\n\n    function rewardUpdate()\n        public\n    {\n        if (_rewardCount > 0 && totalDeposit > 0) {\n            uint256 i;\n            uint256 j;\n\n            for (i = _rewardCount - 1; _rewards[i].startTime < block.timestamp; --i) {\n                uint256 duration;\n                if (block.timestamp.sub(_rewards[i].startTime) > delayDuration) {\n                    duration = _rewards[i].startTime.add(delayDuration).sub(_rewards[i].checkTime);\n                    _rewards[i].startTime = uint256(-1);\n                } else {\n                    duration = block.timestamp.sub(_rewards[i].checkTime);\n                }\n                _rewards[i].checkTime = block.timestamp;\n                uint256 timedAmount = _rewards[i].amount.mul(duration).div(delayDuration);\n                uint256 addAmount;\n                for (j = 0; j < addressIndices.length; j++) {\n                    addAmount = timedAmount.mul(depositBalances[addressIndices[j]]).div(totalDeposit);\n                    rewardBalances[addressIndices[j]] = rewardBalances[addressIndices[j]].add(addAmount);\n                }\n                if (i == 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    function deposit()\n        public\n        payable\n    {\n        uint256 _amount = msg.value;\n        require(_amount > 0, \"can't deposit 0\");\n\n        rewardUpdate();\n\n        uint256 arrayLength = addressIndices.length;\n        bool found = false;\n        for (uint256 i = 0; i < arrayLength; i++) {\n            if (addressIndices[i]==msg.sender){\n                found=true;\n                break;\n            }\n        }\n        \n        if(!found){\n            addressIndices.push(msg.sender);\n        }\n        \n        uint256 feeAmount = _amount.mul(feePermill).div(1000);\n        uint256 realAmount = _amount.sub(feeAmount);\n        \n        if ( ! feeAddress.send(feeAmount)) {\n            feeAddress.transfer(feeAmount);\n        }\n\n        if ( ! vaultAddress.send(realAmount)) {\n            vaultAddress.transfer(realAmount);\n        }\n        \n        totalDeposit = totalDeposit.add(realAmount);\n        depositBalances[msg.sender] = depositBalances[msg.sender].add(realAmount);\n        emit Deposited(msg.sender, realAmount);\n    }\n    \n    function sendReward(uint256 _amount)\n        external\n    {\n        require(_amount > 0, \"can't reward 0\");\n        require(totalDeposit > 0, \"totalDeposit must bigger than 0\");\n        token1.safeTransferFrom(msg.sender, address(this), _amount);\n\n        rewardUpdate();\n\n        _rewards[_rewardCount].amount = _amount;\n        _rewards[_rewardCount].startTime = block.timestamp;\n        _rewards[_rewardCount].checkTime = block.timestamp;\n        _rewardCount++;\n        emit SentReward(_amount);\n    }\n    \n    function claimRewardAll()\n        external\n    {\n        claimReward(uint256(-1));\n    }\n    \n    function claimReward(uint256 _amount)\n        public\n    {\n        require(_rewardCount > 0, \"no reward amount\");\n\n        rewardUpdate();\n\n        if (_amount > rewardBalances[msg.sender]) {\n            _amount = rewardBalances[msg.sender];\n        }\n\n        require(_amount > 0, \"can't claim reward 0\");\n\n        token1.safeTransfer(msg.sender, _amount);\n        \n        rewardBalances[msg.sender] = rewardBalances[msg.sender].sub(_amount);\n        emit ClaimedReward(msg.sender, _amount);\n    }\n\n    function availableRewardAmount(address owner)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 i;\n        uint256 availableReward = rewardBalances[owner];\n        if (_rewardCount > 0 && totalDeposit > 0) {\n            for (i = _rewardCount - 1; _rewards[i].startTime < block.timestamp; --i) {\n                uint256 duration;\n                if (block.timestamp.sub(_rewards[i].startTime) > delayDuration) {\n                    duration = _rewards[i].startTime.add(delayDuration).sub(_rewards[i].checkTime);\n                } else {\n                    duration = block.timestamp.sub(_rewards[i].checkTime);\n                }\n                uint256 timedAmount = _rewards[i].amount.mul(duration).div(delayDuration);\n                uint256 addAmount = timedAmount.mul(depositBalances[owner]).div(totalDeposit);\n                    availableReward = availableReward.add(addAmount);\n                if (i == 0) {\n                    break;\n                }\n            }\n        }\n        return availableReward;\n    }\n}\n"}}}