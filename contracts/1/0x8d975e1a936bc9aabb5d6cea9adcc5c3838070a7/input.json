{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BalanceChecker.sol": {
      "content": "/*\r\n\r\n  Copyright 2020 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.5.9;\r\n\r\n// ERC20 contract interface\r\ncontract IToken {\r\n    /// @dev Query the balance of owner\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return Balance of owner\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint);\r\n}\r\n\r\ncontract BalanceChecker {\r\n    /* Fallback function, don't accept any ETH */\r\n    function() external payable {\r\n      revert(\"BalanceChecker does not accept payments\");\r\n    }\r\n\r\n    /*\r\n      Check the token balance of a wallet in a token contract\r\n\r\n      Returns the balance of the token for user. Avoids possible errors:\r\n        - return 0 on non-contract address \r\n        - returns 0 if the contract doesn't implement balanceOf\r\n    */\r\n    function tokenBalance(address user, address token) public view returns (uint) {\r\n        // check if token is actually a contract\r\n        uint256 tokenCode;\r\n        assembly { tokenCode := extcodesize(token) } // contract code size\r\n\r\n        // checks that it's a contract\r\n        // TODO: check function exists on contract\r\n        if (tokenCode > 0) {  \r\n            return IToken(token).balanceOf(user);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n      Check the token balances of wallet-token pairs.\r\n      Pass 0x0 as a \"token\" address to get ETH balance.\r\n      Possible error throws:\r\n        - extremely large arrays for user and or tokens (gas cost too high)\r\n\r\n      Returns a one-dimensional that's user.length long.\r\n    */\r\n    function balances(address[] calldata users, address[] calldata tokens) external view returns (uint[] memory) {\r\n        // make sure the users array and tokens array are of equal length\r\n        require(users.length == tokens.length, \"users array is a different length than the tokens array\");\r\n\r\n        uint[] memory addrBalances = new uint[](users.length);\r\n\r\n        for(uint i = 0; i < users.length; i++) {\r\n            if (tokens[i] != address(0x0)) {\r\n                addrBalances[i] = tokenBalance(users[i], tokens[i]);\r\n            } else {\r\n                addrBalances[i] = users[i].balance; // ETH balance\r\n            }\r\n        }\r\n\r\n        return addrBalances;\r\n    }\r\n\r\n    /*\r\n      Check the allowance for a given owner, spender, and token\r\n\r\n      Returns the balance of the token for user. Avoids possible errors:\r\n        - return 0 on non-contract address \r\n        - returns 0 if the contract doesn't implement allowance function\r\n    */\r\n    function allowance(address owner, address spender, address token) public view returns (uint) {\r\n        // check if token is actually a contract\r\n        uint256 tokenCode;\r\n        assembly { tokenCode := extcodesize(token) } // contract code size\r\n\r\n        // checks that it's a contract\r\n        // TODO: check function exists on contract\r\n        if (tokenCode > 0) {  \r\n            return IToken(token).allowance(owner, spender);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /*\r\n      Check the allowances of an array of owner-spender-tokens\r\n      \r\n      Returns 0 for 0x0\r\n      Possible error throws:\r\n        - extremely large arrays for user and or tokens (gas cost too high)\r\n\r\n      Returns a one-dimensional array that's owners.length long.\r\n    */\r\n    function allowances(address[] calldata owners, address[] calldata spenders, address[] calldata tokens) external view returns (uint[] memory) {\r\n        // make sure the arrays are all of equal length\r\n        require(owners.length == spenders.length, \"all arrays must be of equal length\");\r\n        require(owners.length == tokens.length, \"all arrays must be of equal length\");\r\n\r\n        uint[] memory addrAllowances = new uint[](owners.length);\r\n\r\n        for(uint i = 0; i < owners.length; i++) {\r\n            if (tokens[i] != address(0x0)) {\r\n                addrAllowances[i] = allowance(owners[i], spenders[i], tokens[i]);\r\n            } else {\r\n                // ETH\r\n                addrAllowances[i] = 0;\r\n            }\r\n        }\r\n\r\n        return addrAllowances;\r\n    }\r\n\r\n\r\n}"
    }
  }
}