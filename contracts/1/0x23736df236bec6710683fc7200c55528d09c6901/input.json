{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/constants/CMaker.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\naddress constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;"},"contracts/contracts/resolvers/MakerResolver.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\nimport {\n    _getMakerRawVaultDebt,\n    _getMakerVaultCollateralBalance\n} from \"../../functions/dapps/FMaker.sol\";\n\ncontract MakerResolver {\n    /// @dev Return Debt in wad of the vault associated to the vaultId.\n    function getMakerVaultDebt(uint256 _vaultId) public view returns (uint256) {\n        return _getMakerRawVaultDebt(_vaultId);\n    }\n\n    /// @dev Return Collateral in wad of the vault associated to the vaultId.\n    function getMakerVaultCollateralBalance(uint256 _vaultId)\n        public\n        view\n        returns (uint256)\n    {\n        return _getMakerVaultCollateralBalance(_vaultId);\n    }\n}\n"},"contracts/functions/dapps/FMaker.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\nimport {MCD_MANAGER} from \"../../constants/CMaker.sol\";\nimport {IMcdManager} from \"../../interfaces/dapps/Maker/IMcdManager.sol\";\nimport {IVat} from \"../../interfaces/dapps/Maker/IVat.sol\";\nimport {RAY, sub, mul} from \"../../vendor/DSMath.sol\";\n\nfunction _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    IVat vat = IVat(manager.vat());\n    (, uint256 rate, , , ) = vat.ilks(ilk);\n    (, uint256 art) = vat.urns(ilk, urn);\n    uint256 dai = vat.dai(urn);\n\n    uint256 rad = sub(mul(art, rate), dai);\n    wad = rad / RAY;\n\n    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n}\n\nfunction _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    IVat vat = IVat(manager.vat());\n    (, uint256 rate, , , ) = vat.ilks(ilk);\n    (, uint256 art) = vat.urns(ilk, urn);\n\n    uint256 rad = mul(art, rate);\n\n    tab = rad / RAY;\n    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\n}\n\nfunction _getMakerVaultCollateralBalance(uint256 _vaultId)\n    view\n    returns (uint256)\n{\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    IVat vat = IVat(manager.vat());\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    (uint256 ink, ) = vat.urns(ilk, urn);\n\n    return ink;\n}\n\nfunction _getVaultData(IMcdManager manager, uint256 vault)\n    view\n    returns (bytes32 ilk, address urn)\n{\n    ilk = manager.ilks(vault);\n    urn = manager.urns(vault);\n}\n"},"contracts/interfaces/dapps/Maker/IMcdManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\ninterface IMcdManager {\n    function ilks(uint256) external view returns (bytes32);\n\n    function urns(uint256) external view returns (address);\n\n    function vat() external view returns (address);\n}\n"},"contracts/interfaces/dapps/Maker/IVat.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\ninterface IVat {\n    function ilks(bytes32)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function dai(address) external view returns (uint256);\n\n    function urns(bytes32, address) external view returns (uint256, uint256);\n}\n"},"contracts/vendor/DSMath.sol":{"content":"// \"SPDX-License-Identifier: AGPL-3.0-or-later\"\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.7.4;\n\nfunction add(uint x, uint y) pure returns (uint z) {\n    require((z = x + y) >= x, \"ds-math-add-overflow\");\n}\nfunction sub(uint x, uint y) pure returns (uint z) {\n    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n}\nfunction mul(uint x, uint y) pure returns (uint z) {\n    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n}\n\nfunction min(uint x, uint y) pure returns (uint z) {\n    return x <= y ? x : y;\n}\nfunction max(uint x, uint y) pure returns (uint z) {\n    return x >= y ? x : y;\n}\nfunction imin(int x, int y) pure returns (int z) {\n    return x <= y ? x : y;\n}\nfunction imax(int x, int y) pure returns (int z) {\n    return x >= y ? x : y;\n}\n\nuint constant WAD = 10 ** 18;\nuint constant RAY = 10 ** 27;\n\n//rounds to zero if x*y < WAD / 2\nfunction wmul(uint x, uint y) pure returns (uint z) {\n    z = add(mul(x, y), WAD / 2) / WAD;\n}\n//rounds to zero if x*y < WAD / 2\nfunction rmul(uint x, uint y) pure returns (uint z) {\n    z = add(mul(x, y), RAY / 2) / RAY;\n}\n//rounds to zero if x*y < WAD / 2\nfunction wdiv(uint x, uint y) pure returns (uint z) {\n    z = add(mul(x, WAD), y / 2) / y;\n}\n//rounds to zero if x*y < RAY / 2\nfunction rdiv(uint x, uint y) pure returns (uint z) {\n    z = add(mul(x, RAY), y / 2) / y;\n}\n\n// This famous algorithm is called \"exponentiation by squaring\"\n// and calculates x^n with x as fixed-point and n as regular unsigned.\n//\n// It's O(log n), instead of O(n) for naive repeated multiplication.\n//\n// These facts are why it works:\n//\n//  If n is even, then x^n = (x^2)^(n/2).\n//  If n is odd,  then x^n = x * x^(n-1),\n//   and applying the equation for even x gives\n//    x^n = x * (x^2)^((n-1) / 2).\n//\n//  Also, EVM division is flooring and\n//    floor[(n-1) / 2] = floor[n / 2].\n//\nfunction rpow(uint x, uint n) pure returns (uint z) {\n    z = n % 2 != 0 ? x : RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n        x = rmul(x, x);\n\n        if (n % 2 != 0) {\n            z = rmul(z, x);\n        }\n    }\n}\n"}}}