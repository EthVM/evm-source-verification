{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor(){\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\n\n\n"
    },
    "SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n"
    },
    "XIVDatabase.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\"; \nimport \"./XIVInterface.sol\";\ncontract XIVDatabase is Ownable{\n    \n    using SafeMath for uint256;\n    mapping (address=>uint256) tokensStaked; //amount of XIV staked by user + incentive from betting\n    mapping(address=> uint256) actualAmountStakingByUser; // XIV staked by users.\n    address[] userStakedAddress; // array of user's address who has staked..\n    address[] tempArray;\n    // XIVDatabaseLib.BetInfo[] tempBetArray;\n    uint256 tokenStakedAmount; // total Amount currently staked by all users.\n    uint256 minStakeXIVAmount; // min amount that user can bet on.\n    uint256 maxStakeXIVAmount; // max amount that user can bet on.\n    uint256 totalTransactions; // sum of all transactions\n    uint256 investmentId;\n    uint256 slotExecutionId;\n    uint256 slotId;\n    mapping(address=>bool) isStakeMapping;\n    \n    mapping(uint256=> XIVDatabaseLib.IncentiveInfo[]) incentiveMapping;\n    \n    mapping(address=> XIVDatabaseLib.StakingInfo[]) StakingInfoMapping;\n    \n    uint256 minLPvalue; // min amount of token that user can stake in LP\n    mapping(address=>XIVDatabaseLib.LPLockedInfo) lockingPeriodForLPMapping; // time for which staked value is locked \n    \n    uint256 betFactorLP; // this is the ratio according to which users can bet considering the amount staked..\n    \n    address XIVMainContractAddress;\n    address XIVBettingFixedContractAddress;\n    address XIVBettingFlexibleContractAddress;\n    \n    address oracleWrapperContractAddress = 0xBc79719636EC60Bc3d98901Af82B278F17a58037; //address of oracle wrapper from where the prices would be fetched\n    address XIVTokenContractAddress = 0x44f262622248027f8E2a8Fb1090c4Cf85072392C; //XIV contract address\n   \n  \n    // mapping and arry of the currencies in the flash individuals vaults.\n    mapping(address=>XIVDatabaseLib.DefiCoin) flashVaultMapping;\n    address[] flashVaultContractAddressArray;\n   \n   /*\n   * fixed individuals starts\n   */\n    // mapping and arry of the currencies in the fixed individuals vaults.\n    mapping(address=>XIVDatabaseLib.DefiCoin) defiCoinsFixedMapping;\n    address[] allDefiCoinFixedContractAddressArray;\n    // array of daysCount and its % drop and other values for fixed\n    XIVDatabaseLib.FixedInfo[] fixedDefiCoinArray;\n   \n    /*\n   * flexible individuals starts\n   */\n    // mapping and arry of the currencies in the flexible individuals vaults.\n    mapping(address=>XIVDatabaseLib.DefiCoin) defiCoinsFlexibleMapping;\n    address[] allDefiCoinFlexibleContractAddressArray;\n    // flexible individual dropvalue and other values\n    XIVDatabaseLib.FlexibleInfo[]  flexibleDefiCoinArray;\n    // flexible individual time periods days\n    XIVDatabaseLib.TimePeriod[] flexibleDefiCoinTimePeriodArray;\n    \n    \n    /*\n   * fixed and flexible adding currency index starts\n   */\n    // mapping and arry of the currencies for all index vaults.\n    mapping(address=>XIVDatabaseLib.IndexCoin)  defiCoinsIndexMapping;\n    address[]  allIndexDefiCoinContractAddressArray;\n    \n    /*\n   * flexible index starts\n   */\n    // flexible index dropvalue and other values\n    XIVDatabaseLib.FlexibleInfo[]  flexibleIndexArray;\n    // flexible index time periods days\n    XIVDatabaseLib.TimePeriod[]  flexibleIndexTimePeriodArray;\n    // this include array of imdex on which bet is placed. key will be betId and value will be array of all index...\n    mapping(uint256=>XIVDatabaseLib.IndexCoin[]) betIndexForFlexibleArray;  \n    // this contains the values on which flexible index bet is placed\n    mapping(uint256=>XIVDatabaseLib.BetPriceHistory) betPriceHistoryFlexibleMapping; \n    \n    /*\n   * fixed index starts\n   */\n    XIVDatabaseLib.FixedInfo[]  fixedDefiIndexArray;\n    // this include array of imdex on which bet is placed. key will be betId and value will be array of all index...\n    mapping(uint256=>XIVDatabaseLib.IndexCoin[]) betIndexForFixedArray;  \n    // this contains the values on which fixed index bet is placed\n    mapping(uint256=>XIVDatabaseLib.BetPriceHistory) betPriceHistoryFixedMapping;\n    \n    \n    uint256  betBaseIndexValue; //10**8 index value \n    uint256  betActualIndexValue; // marketcap value\n    \n    uint256 betid;\n    \n    XIVDatabaseLib.BetInfo[]  betArray;\n    mapping(uint256=>uint256)  findBetInArrayUsingBetIdMapping; // getting the bet index using betid... Key is betId and value will be index in the betArray...\n    mapping(address=> uint256[])  betAddressesArray;\n    \n    uint256 plentyOneDayPercentage; // percentage in 10**2\n    mapping(uint256=>uint256)  plentyThreeDayPercentage; // key is day and value is percentage in 10**2\n    mapping(uint256=>uint256)  plentySevenDayPercentage; // key is day and value is percentage in 10**2\n    \n    uint256[] daysArray;\n    \n    uint256 rewardGeneratedAmount;\n    address[] userAddressUsedForBetting;\n    \n    mapping(address=>mapping(uint256=>mapping(address=>bool))) existingBetCheckMapping;\n    \n    event BetDetails(uint256 indexed betId, uint256 indexed status, uint256 indexed betEndTime);\n    event LPEvent(uint256 typeOfLP, address indexed userAddress, uint256 amount, uint256 timestamp);\n    \n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external onlyMyContracts{\n        emit BetDetails( betId, status, betEndTime);\n    }\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external onlyMyContracts{\n        emit LPEvent(typeOfLP,  userAddress, amount, timestamp);\n    }\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external onlyMyContracts{\n        existingBetCheckMapping[_userAddress][_betType][_BetContractAddress]=status;\n    }\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool){\n        return (existingBetCheckMapping[_userAddress][_betType][_BetContractAddress]);\n    }\n    \n     function addFixedDefiCoinArray(uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n         bool isAvailable=false;\n         for(uint256 i=0;i<fixedDefiCoinArray.length;i++){\n             if(fixedDefiCoinArray[i].daysCount==_daysCount){\n                 isAvailable=true;\n                 break;\n             }\n         }\n        require(!isAvailable,\"Already have this data.\");\n        XIVDatabaseLib.FixedInfo memory fobject=XIVDatabaseLib.FixedInfo({\n            id:fixedDefiCoinArray.length,\n            daysCount:_daysCount,\n            upDownPercentage:_upDownPercentage,\n            riskFactor:_riskFactor,\n            rewardFactor:_rewardFactor,\n            status:true\n        });\n        fixedDefiCoinArray.push(fobject);\n        addDaysToDayArray(_daysCount);\n    }\n    function updateFixedDefiCoinArray(uint256 index,uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n        fixedDefiCoinArray[index].daysCount=_daysCount;\n        fixedDefiCoinArray[index].upDownPercentage=_upDownPercentage;\n        fixedDefiCoinArray[index].riskFactor=_riskFactor;\n        fixedDefiCoinArray[index].rewardFactor=_rewardFactor;\n        fixedDefiCoinArray[index].status=_status;\n        addDaysToDayArray(_daysCount);\n    }\n    \n    function addUpdateForDefiFixedCoin(address _ContractAddress,  string memory _currencySymbol,\n                                            uint16 _OracleType, bool _Status, bool isFlashVault) public onlyOwner{\n        // add update defi felxible coin\n        XIVDatabaseLib.DefiCoin memory dCoin=XIVDatabaseLib.DefiCoin({\n            oracleType:_OracleType,\n            currencySymbol:_currencySymbol,\n            status:_Status\n        });\n        if(isFlashVault){\n            flashVaultMapping[_ContractAddress]=dCoin;\n        }else{\n            defiCoinsFixedMapping[_ContractAddress]=dCoin;\n        }\n        // check wheather contract exists in allFlexibleContractAddressArray array\n        if(!contractAvailableInArray(_ContractAddress,isFlashVault?flashVaultContractAddressArray:allDefiCoinFixedContractAddressArray)){\n            (isFlashVault?flashVaultContractAddressArray:allDefiCoinFixedContractAddressArray).push(_ContractAddress);\n        }\n    }\n    \n    function getDefiCoinsFixedMapping(address _betContractAddress, bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory){\n        return (isFlashVault?flashVaultMapping[_betContractAddress]:defiCoinsFixedMapping[_betContractAddress]);\n    }\n    function getDefiCoinsFixedContractAddressArray(bool isFlashVault) external view returns(address[] memory){\n        return (isFlashVault?flashVaultContractAddressArray:allDefiCoinFixedContractAddressArray);\n    }\n    \n    function addUpdateForDefiCoinFlexible(address _ContractAddress,  string memory _currencySymbol,\n                                            uint16 _OracleType, bool _Status) public onlyOwner{\n        // add update defi felxible coin\n        XIVDatabaseLib.DefiCoin memory dCoin=XIVDatabaseLib.DefiCoin({\n            oracleType:_OracleType,\n            currencySymbol:_currencySymbol,\n            status:_Status\n        });\n        defiCoinsFlexibleMapping[_ContractAddress]=dCoin;\n        // check wheather contract exists in allFlexibleContractAddressArray array\n        if(!contractAvailableInArray(_ContractAddress,allDefiCoinFlexibleContractAddressArray)){\n            allDefiCoinFlexibleContractAddressArray.push(_ContractAddress);\n        }\n    }\n    \n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory){\n        return (defiCoinsFlexibleMapping[_betContractAddress]);\n    }\n    function getDefiCoinsFlexibleContractAddressArray() external view returns(address[] memory){\n        return allDefiCoinFlexibleContractAddressArray;\n    }\n    function addflexibleDefiCoinArray(uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n        XIVDatabaseLib.FlexibleInfo memory fobject=XIVDatabaseLib.FlexibleInfo({\n            id:flexibleDefiCoinArray.length,\n            upDownPercentage:_upDownPercentage,\n            riskFactor:_riskFactor,\n            rewardFactor:_rewardFactor,\n            status:true\n        });\n        flexibleDefiCoinArray.push(fobject);\n    }\n    function updateflexibleDefiCoinArray(uint256 index,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n        flexibleDefiCoinArray[index].upDownPercentage=_upDownPercentage;\n        flexibleDefiCoinArray[index].riskFactor=_riskFactor;\n        flexibleDefiCoinArray[index].rewardFactor=_rewardFactor;\n        flexibleDefiCoinArray[index].status=_status;\n    }\n     function addFlexibleDefiCoinTimePeriodArray(uint256 _tdays) public onlyOwner{\n         bool isAvailable=false;\n         for(uint256 i=0;i<flexibleDefiCoinTimePeriodArray.length;i++){\n             if(flexibleDefiCoinTimePeriodArray[i]._days==_tdays){\n                 isAvailable=true;\n                 break;\n             }\n         }\n        require(!isAvailable,\"Already have this data.\");\n         XIVDatabaseLib.TimePeriod memory tobject= XIVDatabaseLib.TimePeriod({\n             _days:_tdays,\n             status:true\n         });\n        flexibleDefiCoinTimePeriodArray.push(tobject);\n        addDaysToDayArray(_tdays);\n    }\n    function updateFlexibleDefiCoinTimePeriodArray(uint256 index, uint256 _tdays, bool _status) public onlyOwner{\n        flexibleDefiCoinTimePeriodArray[index]._days=_tdays;\n        flexibleDefiCoinTimePeriodArray[index].status=_status;\n        addDaysToDayArray(_tdays);\n    }\n    \n    function getFlexibleDefiCoinTimePeriodArray() public view returns(XIVDatabaseLib.TimePeriod[] memory){\n        return flexibleDefiCoinTimePeriodArray;\n    }\n    \n     function addUpdateForIndexCoin(XIVDatabaseLib.IndexCoin[] memory tupleCoinArray) public onlyOwner{\n        // add update index fixed coin\n        tempArray=new address[](0);\n        allIndexDefiCoinContractAddressArray=tempArray;\n        \n        for(uint256 i=0;i<tupleCoinArray.length;i++){\n            defiCoinsIndexMapping[tupleCoinArray[i].contractAddress]=tupleCoinArray[i];\n            // check wheather contract exists in allFixedContractAddressArray array\n            if(!contractAvailableInArray(tupleCoinArray[i].contractAddress,allIndexDefiCoinContractAddressArray)){\n                allIndexDefiCoinContractAddressArray.push(tupleCoinArray[i].contractAddress);\n            }\n        }\n    }\n    function addflexibleIndexCoinArray(uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n        XIVDatabaseLib.FlexibleInfo memory fobject=XIVDatabaseLib.FlexibleInfo({\n            id:flexibleIndexArray.length,\n            upDownPercentage:_upDownPercentage,\n            riskFactor:_riskFactor,\n            rewardFactor:_rewardFactor,\n            status:true\n        });\n        flexibleIndexArray.push(fobject);\n    }\n    function updateflexibleIndexCoinArray(uint256 index,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n        flexibleIndexArray[index].upDownPercentage=_upDownPercentage;\n        flexibleIndexArray[index].riskFactor=_riskFactor;\n        flexibleIndexArray[index].rewardFactor=_rewardFactor;\n        flexibleIndexArray[index].status=_status;\n    }\n    \n    function addFlexibleIndexTimePeriodArray(uint256 _tdays) public onlyOwner{\n         bool isAvailable=false;\n         for(uint256 i=0;i<flexibleIndexTimePeriodArray.length;i++){\n             if(flexibleIndexTimePeriodArray[i]._days==_tdays){\n                 isAvailable=true;\n                 break;\n             }\n         }\n        require(!isAvailable,\"Already have this data.\");\n         XIVDatabaseLib.TimePeriod memory tobject= XIVDatabaseLib.TimePeriod({\n             _days:_tdays,\n             status:true\n         });\n        flexibleIndexTimePeriodArray.push(tobject);\n        addDaysToDayArray(_tdays);\n    }\n    function updateFlexibleIndexTimePeriodArray(uint256 index, uint256 _tdays, bool _status) public onlyOwner{\n        flexibleIndexTimePeriodArray[index]._days=_tdays;\n        flexibleIndexTimePeriodArray[index].status=_status;\n        addDaysToDayArray(_tdays);\n    }\n    function getFlexibleIndexTimePeriodArray() public view returns(XIVDatabaseLib.TimePeriod[] memory){\n        return flexibleIndexTimePeriodArray;\n    }\n   function addFixedDefiIndexArray(uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n         bool isAvailable=false;\n         for(uint256 i=0;i<fixedDefiIndexArray.length;i++){\n             if(fixedDefiIndexArray[i].daysCount==_daysCount){\n                 isAvailable=true;\n                 break;\n             }\n         }\n        require(!isAvailable,\"Already have this data.\");\n        XIVDatabaseLib.FixedInfo memory fobject=XIVDatabaseLib.FixedInfo({\n            id:fixedDefiIndexArray.length,\n            daysCount:_daysCount,\n            upDownPercentage:_upDownPercentage,\n            riskFactor:_riskFactor,\n            rewardFactor:_rewardFactor,\n            status:true\n        });\n        fixedDefiIndexArray.push(fobject);\n        addDaysToDayArray(_daysCount);\n    }\n    function updateFixedDefiIndexArray(uint256 index,uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n        fixedDefiIndexArray[index].daysCount=_daysCount;\n        fixedDefiIndexArray[index].upDownPercentage=_upDownPercentage;\n        fixedDefiIndexArray[index].riskFactor=_riskFactor;\n        fixedDefiIndexArray[index].rewardFactor=_rewardFactor;\n        fixedDefiIndexArray[index].status=_status;\n        addDaysToDayArray(_daysCount);\n    }\n    function contractAvailableInArray(address _ContractAddress,address[] memory _contractArray) internal pure returns(bool){\n        for(uint256 i=0;i<_contractArray.length;i++){\n            if(_ContractAddress==_contractArray[i]){\n                return true;\n            }\n        }\n        return false;\n    }  \n   \n    \n    function updateMaxStakeXIVAmount(uint256 _maxStakeXIVAmount) external onlyOwner{\n        maxStakeXIVAmount=_maxStakeXIVAmount;\n    }\n    function getMaxStakeXIVAmount() external view returns(uint256){\n        return maxStakeXIVAmount;\n    }\n    function updateMinStakeXIVAmount(uint256 _minStakeXIVAmount) external onlyOwner{\n        minStakeXIVAmount=_minStakeXIVAmount;\n    }\n    function getMinStakeXIVAmount() external view returns(uint256){\n        return minStakeXIVAmount;\n    }\n    function updateMinLPvalue(uint256 _minLPvalue) external onlyOwner{\n        minLPvalue=_minLPvalue;\n    }\n    function getMinLPvalue() external view returns(uint256){\n        return minLPvalue;\n    }\n    function updateBetFactorLP(uint256 _betFactorLP) external onlyOwner{\n        betFactorLP=_betFactorLP;\n    }\n    function getBetFactorLP() external view returns(uint256){\n        return betFactorLP;\n    }\n    \n    function updateTotalTransactions(uint256 _totalTransactions) external onlyMyContracts{\n        totalTransactions=_totalTransactions;\n    }\n    function getTotalTransactions() external view returns(uint256){\n        return totalTransactions;\n    }\n    \n    function updateXIVMainContractAddress(address _XIVMainContractAddress) external onlyOwner{\n        XIVMainContractAddress=_XIVMainContractAddress;\n    }\n    function updateXIVBettingFixedContractAddress(address _XIVBettingFixedContractAddress) external onlyOwner{\n        XIVBettingFixedContractAddress=_XIVBettingFixedContractAddress;\n    }\n    function updateXIVBettingFlexibleContractAddress(address _XIVBettingFlexibleContractAddress) external onlyOwner{\n        XIVBettingFlexibleContractAddress=_XIVBettingFlexibleContractAddress;\n    }\n    function updateXIVTokenContractAddress(address _XIVTokenContractAddress) external onlyOwner{\n        XIVTokenContractAddress=_XIVTokenContractAddress;\n    }\n    function getXIVTokenContractAddress() external view returns(address){\n        return XIVTokenContractAddress;\n    }\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValue) external onlyMyContracts{\n        betBaseIndexValue=_betBaseIndexValue;\n    }\n    function getBetBaseIndexValue() external view returns(uint256){\n        return betBaseIndexValue;\n    }\n    function updateBetActualIndexValue(uint256 _betActualIndexValue) external onlyMyContracts{\n        betActualIndexValue=_betActualIndexValue;\n    }\n    function getBetActualIndexValue() external view returns(uint256){\n        return betActualIndexValue;\n    }\n    \n    // function transferETH(address payable userAddress,uint256 amount) external onlyMyContracts {\n    //     require(address(this).balance >= amount,\"The Contract does not have enough ethers.\");\n    //     userAddress.transfer(amount);\n    // }\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external onlyMyContracts {\n        Token tokenObj=Token(contractAddress);\n        require(tokenObj.balanceOf(address(this))>= amount, \"Tokens not available\");\n        tokenObj.transfer(userAddress, amount);\n    }\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external onlyMyContracts {\n        require(checkTokens(contractAddress,amount,fromAddress));\n        Token(contractAddress).transferFrom(fromAddress, toAddress, amount);\n    }\n    function checkTokens(address contractAddress,uint256 amount, address fromAddress) internal view returns(bool){\n         Token tokenObj = Token(contractAddress);\n        //check if user has balance\n        require(tokenObj.balanceOf(fromAddress) >= amount, \"You don't have enough XIV balance\");\n        //check if user has provided allowance\n        require(tokenObj.allowance(fromAddress,address(this)) >= amount, \n        \"Please allow smart contract to spend on your behalf\");\n        return true;\n    }\n    function getTokensStaked(address userAddress) external view returns(uint256){\n        return (tokensStaked[userAddress]);\n    }\n    function updateTokensStaked(address userAddress, uint256 amount) external onlyMyContracts{\n        tokensStaked[userAddress]=amount;\n    }\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory){\n        return (StakingInfoMapping[userAddress]);\n    }\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external onlyMyContracts{\n        StakingInfoMapping[userAddress].push(sInfo);\n    }\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256){\n        return (actualAmountStakingByUser[userAddress]);\n    } \n    function updateIsStakeMapping(address userAddress,bool isStake) external onlyMyContracts{\n        isStakeMapping[userAddress]=(isStake);\n    }\n    function getIsStakeMapping(address userAddress) external view returns(bool){\n        return (isStakeMapping[userAddress]);\n    }\n    \n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external onlyMyContracts{\n        incentiveMapping[_slotId].push(iInfo);\n    }\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory){\n        return (incentiveMapping[_slotId]);\n    }\n    \n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external onlyMyContracts{\n        actualAmountStakingByUser[userAddress]=amount;\n    }\n    \n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory){\n        return (lockingPeriodForLPMapping[userAddress]);\n    }\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external onlyMyContracts{\n        XIVDatabaseLib.LPLockedInfo memory lpLockedInfo= XIVDatabaseLib.LPLockedInfo({\n            lockedTimeStamp:_lockedTimeStamp,\n            amountLocked:_amountLocked\n        });\n        lockingPeriodForLPMapping[userAddress]=lpLockedInfo;\n    }\n    \n    function getTokenStakedAmount() external view returns(uint256){\n        return (tokenStakedAmount);\n    }\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external onlyMyContracts{\n        tokenStakedAmount=_tokenStakedAmount;\n    }\n    function getBetId() external view returns(uint256){\n        return betid;\n    }\n    function updateBetId(uint256 _userBetId) external onlyMyContracts{\n        betid=_userBetId;\n    }\n    function getInvestmentId() external view returns(uint256){\n        return investmentId;\n    }\n    function updateInvestmentId(uint256 _investmentId) external onlyMyContracts{\n        investmentId=_investmentId;\n    }\n    function getSlotExecutionId() external view returns(uint256){\n        return slotExecutionId;\n    }\n    function updateSlotExecutionId(uint256 _slotExecutionId) external onlyMyContracts{\n        slotExecutionId=_slotExecutionId;\n    }\n    function getSlotId() external view returns(uint256){\n        return slotId;\n    }\n    function updateSlotId(uint256 _slotId) external onlyMyContracts{\n        slotId=_slotId;\n    }\n    \n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external onlyMyContracts{\n        betArray.push(bObject);\n    }\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external onlyMyContracts{\n        betArray[index]=bObject;\n    }\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory){\n        return betArray;\n    }\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256){\n        return findBetInArrayUsingBetIdMapping[_betid];\n    }\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external onlyMyContracts{\n        findBetInArrayUsingBetIdMapping[_betid]=value;\n    }\n    function updateUserStakedAddress(address _address) external onlyMyContracts{\n        userStakedAddress.push(_address);\n    }\n    function getUserStakedAddress() external view returns(address[] memory){\n        return userStakedAddress;\n    }\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external onlyMyContracts{\n        userStakedAddress=_userStakedAddress;\n    }\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory){\n        return flexibleDefiCoinArray;\n    }\n    \n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory){\n        return flexibleIndexArray;\n    }\n    \n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory){\n        return fixedDefiCoinArray;\n    }\n    \n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory){\n        return fixedDefiIndexArray;\n    }\n    function getAllIndexContractAddressArray() external view returns(address[] memory){\n        return allIndexDefiCoinContractAddressArray;\n    }\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory){\n        return (defiCoinsIndexMapping[_ContractAddress]);\n    }\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external onlyMyContracts{\n        betIndexForFixedArray[_betId].push(iCArray);\n    }\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory){\n        return (betIndexForFixedArray[_betId]);\n    }\n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external onlyMyContracts{\n        betIndexForFlexibleArray[_betId].push(iCArray);\n    }\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory){\n        return (betIndexForFlexibleArray[_betId]);\n    }\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external onlyMyContracts{\n        betPriceHistoryFixedMapping[_betId]=bPHObj;\n    }\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory){\n        return (betPriceHistoryFixedMapping[_betId]);\n    }\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external onlyMyContracts{\n        betPriceHistoryFlexibleMapping[_betId]=bPHObj;\n    }\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory){\n        return (betPriceHistoryFlexibleMapping[_betId]);\n    }\n    function addUpdatePlentyOneDayPercentage(uint256 percentage) public onlyOwner{\n        plentyOneDayPercentage=percentage;\n    }\n    function getPlentyOneDayPercentage() external view returns(uint256){\n        return (plentyOneDayPercentage);\n    }\n    \n    function addUpdatePlentyThreeDayPercentage(uint256 _days, uint256 percentage) public onlyOwner{\n        plentyThreeDayPercentage[_days]=percentage;\n    }\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256){\n        return (plentyThreeDayPercentage[_days]);\n    }\n    \n    function addUpdatePlentySevenDayPercentage(uint256 _days, uint256 percentage) public onlyOwner{\n        plentySevenDayPercentage[_days]=percentage;\n    }\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256){\n        return (plentySevenDayPercentage[_days]);\n    }\n    function updateOrcaleAddress(address oracleAddress) external onlyOwner{\n        oracleWrapperContractAddress=oracleAddress;\n    }\n    function getOracleWrapperContractAddress() external view returns(address){\n        return oracleWrapperContractAddress;\n    }\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory){\n        return betAddressesArray[userAddress];\n    }\n    function getUserBetCount(address userAddress) external view returns(uint256){\n        return betAddressesArray[userAddress].length;\n    }\n    function getUserBetArray(address userAddress, uint256 pageNo, uint256 pageSize) external view returns(XIVDatabaseLib.BetInfo[] memory){\n        uint256[] memory betIndexes=betAddressesArray[userAddress];\n        if(betIndexes.length>0){\n            uint256 startIndex=(((betIndexes.length).sub(pageNo.mul(pageSize))).sub(1));\n            uint256 endIndex;\n            uint256 pageCount=startIndex.add(1);\n            if(pageSize.sub(1)<startIndex){\n                endIndex=(startIndex.sub(pageSize.sub(1)));\n                pageCount=pageSize;\n            }\n            XIVDatabaseLib.BetInfo[] memory bArray=new XIVDatabaseLib.BetInfo[](pageCount);\n            uint256 value;\n            for(uint256 i=endIndex;i<=startIndex;i++){\n                bArray[value]=betArray[findBetInArrayUsingBetIdMapping[betIndexes[i]]];\n                value++;\n            }\n            return bArray;\n        }\n        return new XIVDatabaseLib.BetInfo[](0);\n    }\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external onlyMyContracts{\n        betAddressesArray[userAddress].push(_betId);\n    }\n    function getRewardGeneratedAmount() external view returns(uint256){\n        return rewardGeneratedAmount;\n    }\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external onlyMyContracts{\n        rewardGeneratedAmount=_rewardGeneratedAmount;\n    }\n    \n    function addUserAddressUsedForBetting(address userAddress) external onlyMyContracts{\n        userAddressUsedForBetting.push(userAddress);\n    }\n    function getUserAddressUsedForBetting() external view returns(address[] memory){\n        return userAddressUsedForBetting;\n    }\n    function addDaysToDayArray(uint256 _days) internal{\n        bool isAvailable;\n        for(uint256 i=0;i<daysArray.length;i++){\n            if(daysArray[i]==_days){\n                isAvailable=true;\n                break;\n            }\n        }\n        if(!isAvailable){\n            daysArray.push(_days);\n        }\n    }\n    function isDaysAvailable(uint256 _days) external view returns(bool){\n        for(uint256 i=0;i<daysArray.length;i++){\n            if(daysArray[i]==_days){\n                return true;\n            }\n        }\n        return false;\n    }\n    function getDaysArray() external view returns(uint256[] memory){\n        return daysArray;\n    }\n    \n    \n    modifier onlyMyContracts() {\n        require(msg.sender == XIVMainContractAddress || msg.sender==XIVBettingFixedContractAddress || msg.sender== XIVBettingFlexibleContractAddress);\n        _;\n    }\n    fallback() external payable {\n    }\n}\n"
    },
    "XIVDatabaseLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nlibrary XIVDatabaseLib{\n    // deficoin struct for deficoinmappings..\n    struct DefiCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        bool status;\n    }\n    struct TimePeriod{\n        uint256 _days;\n        bool status;\n    }\n     struct FlexibleInfo{\n        uint256 id;\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct FixedInfo{\n        uint256 id;\n        uint256 daysCount;// integer value\n        uint16 upDownPercentage; //10**2\n        uint16 riskFactor;       //10**2\n        uint16 rewardFactor;     //10**2\n        bool status;\n    }\n    struct IndexCoin{\n        uint16 oracleType;\n        string currencySymbol;\n        address contractAddress;\n        bool status;\n        uint256 contributionPercentage; //10**2\n    }\n    struct BetPriceHistory{\n        uint256 baseIndexValue;\n        uint256 actualIndexValue;\n    }\n    struct LPLockedInfo{\n        uint256 lockedTimeStamp;\n        uint256 amountLocked;\n    }\n    struct StakingInfo{\n        uint256 investmentId;\n        uint256 stakeAmount;\n    }\n    struct IncentiveInfo{\n        uint256 tillInvestmentId;\n        uint256 incentiveAmount;\n        uint256 totalAmountStakedAtIncentiveTime;\n    }\n    struct BetInfo{\n        uint256 id;\n        uint256 principalAmount;\n        uint256 amount;\n        address userAddress;\n        address contractAddress;\n        uint256 betType; //\n        uint256 currentPrice;\n        uint256 timestamp;\n        uint256 betTimePeriod;\n        uint16 checkpointPercent;\n        uint16 rewardFactor;\n        uint16 riskFactor;\n        uint256 adminCommissionFee;\n        uint16 status; // 0->bet active, 1->bet won, 2->bet lost, 3-> withdraw before result\n    }\n}\n"
    },
    "XIVInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENCED\npragma solidity >=0.6.0 <0.8.0;\npragma abicoder v2;\n\nimport \"./XIVDatabaseLib.sol\";\n\ninterface Token{\n    function decimals() external view returns(uint256);\n    function symbol() external view returns(string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n}\n\n\ninterface OracleWrapper{\n    function getPrice(string calldata currencySymbol,uint256 oracleType) external view returns (uint256);\n}\ninterface DatabaseContract{\n    function transferTokens(address contractAddress,address userAddress,uint256 amount) external;\n    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external;\n    function getTokensStaked(address userAddress) external view returns(uint256);\n    function updateTokensStaked(address userAddress, uint256 amount) external;\n    function getTokenStakedAmount() external view returns(uint256);\n    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external;\n    function getBetId() external view returns(uint256);\n    function updateBetId(uint256 _userBetId) external;\n    function updateBetArray(XIVDatabaseLib.BetInfo memory bObject) external;\n    function getBetArray() external view returns(XIVDatabaseLib.BetInfo[] memory);\n    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256);\n    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external;\n    function updateUserStakedAddress(address _address) external;\n    function updateUserStakedAddress(address[] memory _userStakedAddress) external;\n    function getUserStakedAddress() external view returns(address[] memory);\n    function getDefiCoinsFixedMapping(address _betContractAddress,bool isFlashVault) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(XIVDatabaseLib.DefiCoin memory);\n    function getFlexibleDefiCoinArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function getFlexibleIndexArray() external view returns(XIVDatabaseLib.FlexibleInfo[] memory);\n    function updateBetArrayIndex(XIVDatabaseLib.BetInfo memory bObject, uint256 index) external;\n    function updateBetIndexForFixedArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function updateBetBaseIndexValue(uint256 _betBaseIndexValueFixed) external;\n    function getBetBaseIndexValue() external view returns(uint256);\n    function updateBetPriceHistoryFixedMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function updateBetActualIndexValue(uint256 _betActualIndexValueFixed) external;\n    function getBetActualIndexValue() external view returns(uint256);\n    function getBetIndexForFixedArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    function getXIVTokenContractAddress() external view returns(address);\n    function getAllIndexContractAddressArray() external view returns(address[] memory);\n    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(XIVDatabaseLib.IndexCoin memory);\n    \n    function updateBetIndexForFlexibleArray(uint256 _betId, XIVDatabaseLib.IndexCoin memory iCArray) external;\n    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(XIVDatabaseLib.IndexCoin[] memory);\n    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, XIVDatabaseLib.BetPriceHistory memory bPHObj) external;\n    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(XIVDatabaseLib.BetPriceHistory memory);\n    \n    function getOracleWrapperContractAddress() external view returns(address);\n    function getPlentyOneDayPercentage() external view returns(uint256);\n    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256);\n    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256);\n    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory);\n    function updateBetAddressesArray(address userAddress, uint256 _betId) external;\n    function getRewardGeneratedAmount() external view returns(uint256);\n    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external;\n    function addUserAddressUsedForBetting(address userAddress) external;\n    function getUserAddressUsedForBetting() external view returns(address[] memory);\n    function getFixedDefiCoinArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getFixedDefiIndexArray() external view returns(XIVDatabaseLib.FixedInfo[] memory);\n    function getMaxStakeXIVAmount() external view returns(uint256);\n    function getMinStakeXIVAmount() external view returns(uint256);\n    function getBetFactorLP() external view returns(uint256);\n    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external;\n    function getActualAmountStakedByUser(address userAddress) external view returns(uint256);\n    function isDaysAvailable(uint256 _days) external view returns(bool);\n    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external;\n    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool);\n    function updateTotalTransactions(uint256 _totalTransactions) external;\n    function getTotalTransactions() external view returns(uint256);\n    function getFlexibleDefiCoinTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getFlexibleIndexTimePeriodArray() external view returns(XIVDatabaseLib.TimePeriod[] memory);\n    function getMinLPvalue() external view returns(uint256);\n    function getLockingPeriodForLPMapping(address userAddress) external view returns(XIVDatabaseLib.LPLockedInfo memory);\n    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external;\n    function getStakingInfoMapping(address userAddress) external view returns(XIVDatabaseLib.StakingInfo[] memory);\n    function updateStakingInfoMapping(address userAddress, XIVDatabaseLib.StakingInfo memory sInfo) external;\n    function getInvestmentId() external view returns(uint256);\n    function updateInvestmentId(uint256 _investmentId) external;\n    function getSlotExecutionId() external view returns(uint256);\n    function updateSlotExecutionId(uint256 _slotExecutionId) external;\n    function getSlotId() external view returns(uint256);\n    function updateSlotId(uint256 _slotId) external;\n    function updateIncentiveMapping(uint256 _slotId, XIVDatabaseLib.IncentiveInfo memory iInfo) external;\n    function getIncentiveMapping(uint256 _slotId) external view returns(XIVDatabaseLib.IncentiveInfo[] memory);\n    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external;\n    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external ;\n    function updateIsStakeMapping(address userAddress,bool isStake) external;\n    function getIsStakeMapping(address userAddress) external view returns(bool);\n    \n}\n"
    }
  }
}