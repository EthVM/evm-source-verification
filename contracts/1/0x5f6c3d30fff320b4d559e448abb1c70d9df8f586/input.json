{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"new farm.sol":{"content":"/**\n *Submitted for verification at BscScan.com on 2021-04-14\n*/\n\n// SPDX-License-Identifier: UNLICENSED \npragma solidity 0.8.3;     \n\n\n/*\n* Must wrap your BNB for fETH to use FEGex DEX\n\nBuilt for fETH - FEG Wapped BNB - Built in 1% frictionless rewards of BNB!  Stake BNB with fETH and earn rewards!\n*/\n\n\nabstract contract ReentrancyGuard {\n\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        _status = _ENTERED;\n\n        _;\n\n        _status = _NOT_ENTERED;\n    }\n}\n\ninterface stakeContract {\n    function DisributeTxFunds() external;\n    function ADDFUNDS(uint256 tokens) external;\n}\n\ncontract FSilver  {\n     function getColor()\n        external pure\n        returns (bytes32) {\n            return bytes32(\"BRONZE\");\n        }\n}\n\n\ncontract FConst is FSilver, ReentrancyGuard {\n    uint public constant BASE              = 10**18;\n\n    uint public constant MIN_BOUND_TOKENS  = 2;\n    uint public constant MAX_BOUND_TOKENS  = 8;\n\n    uint public constant MIN_FEE           = 2000000000000000; \n    uint public constant MAX_FEE           = 2000000000000000; // FREE BUYS\n    uint public constant EXIT_FEE          = 0;\n\n    uint public constant MIN_WEIGHT        = BASE;\n    uint public constant MAX_WEIGHT        = BASE * 50;\n    uint public constant MAX_TOTAL_WEIGHT  = BASE * 50;\n    uint public constant MIN_BALANCE       = BASE / 10**12;\n\n    uint public constant INIT_POOL_SUPPLY  = BASE * 100;\n    \n    uint public  SM = 10;\n    uint public  M1 = 10;\n    address public FEGstake = 0x04788562Ab11eA3a5201d579e2b3Ee7A3F74F1fA;\n    uint public constant MIN_BPOW_BASE     = 1 wei;\n    uint public constant MAX_BPOW_BASE     = (2 * BASE) - 1 wei;\n    uint public constant BPOW_PRECISION    = BASE / 10**10;\n\n    uint public constant MAX_IN_RATIO      = BASE / 2;\n    uint public constant MAX_OUT_RATIO     = (BASE / 3) + 1 wei;\n    uint public MAX_SELL_RATIO             = BASE / SM;\n    uint public MAX_1_RATIO             = BASE / M1;\n}\n\n\ncontract FNum is ReentrancyGuard, FConst {\n\n    function btoi(uint a)\n        internal pure\n        returns (uint)\n    {\n        return a / BASE;\n    }\n\n    function bfloor(uint a)\n        internal pure\n        returns (uint)\n    {\n        return btoi(a) * BASE;\n    }\n\n    function badd(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c = a + b;\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\n        return c;\n    }\n\n    function bsub(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        (uint c, bool flag) = bsubSign(a, b);\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\n        return c;\n    }\n\n    function bsubSign(uint a, uint b)\n        internal pure\n        returns (uint, bool)\n    {\n        if (a >= b) {\n            return (a - b, false);\n        } else {\n            return (b - a, true);\n        }\n    }\n\n    function bmul(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        uint c0 = a * b;\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n        uint c1 = c0 + (BASE / 2);\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n        uint c2 = c1 / BASE;\n        return c2;\n    }\n\n    function bdiv(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint c0 = a * BASE;\n        require(a == 0 || c0 / a == BASE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n        uint c1 = c0 + (b / 2);\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint c2 = c1 / b;\n        return c2;\n    }\n\n    // DSMath.wpow\n    function bpowi(uint a, uint n)\n        internal pure\n        returns (uint)\n    {\n        uint z = n % 2 != 0 ? a : BASE;\n\n        for (n /= 2; n != 0; n /= 2) {\n            a = bmul(a, a);\n\n            if (n % 2 != 0) {\n                z = bmul(z, a);\n            }\n        }\n        return z;\n    }\n\n    function bpow(uint base, uint exp)\n        internal pure\n        returns (uint)\n    {\n        require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n        require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n        uint whole  = bfloor(exp);\n        uint remain = bsub(exp, whole);\n\n        uint wholePow = bpowi(base, btoi(whole));\n\n        if (remain == 0) {\n            return wholePow;\n        }\n\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n        return bmul(wholePow, partialResult);\n    }\n\n    function bpowApprox(uint base, uint exp, uint precision)\n        internal pure\n        returns (uint)\n    {\n        // term 0:\n        uint a     = exp;\n        (uint x, bool xneg)  = bsubSign(base, BASE);\n        uint term = BASE;\n        uint sum   = term;\n        bool negative = false;\n\n\n        for (uint i = 1; term >= precision; i++) {\n            uint bigK = i * BASE;\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BASE));\n            term = bmul(term, bmul(c, x));\n            term = bdiv(term, bigK);\n            if (term == 0) break;\n\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = bsub(sum, term);\n            } else {\n                sum = badd(sum, term);\n            }\n        }\n\n        return sum;\n    }\n}\n\ncontract FMath is FSilver, FConst, FNum {\n    \n    function calcSpotPrice(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint spotPrice)\n    {\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n        uint ratio = bdiv(numer, denom);\n        uint scale = bdiv(BASE, bsub(BASE, swapFee));\n        return  (spotPrice = bmul(ratio, scale));\n    }\n    \n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut, uint tokenInFee)\n    {\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n        uint adjustedIn = bsub(BASE, swapFee);\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n        uint foo = bpow(y, weightRatio);\n        uint bar = bsub(BASE, foo);\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\n        tokenInFee = bsub(tokenAmountIn, adjustedIn);\n        return (tokenAmountOut, tokenInFee);\n    }\n\n\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountIn, uint tokenInFee)\n    {\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n        uint y = bdiv(tokenBalanceOut, diff);\n        uint foo = bpow(y, weightRatio);\n        foo = bsub(foo, BASE);\n        foo = bmul(tokenBalanceIn, foo);\n        tokenAmountIn = bsub(BASE, swapFee);\n        tokenAmountIn = bdiv(foo, tokenAmountIn);\n        tokenInFee = bdiv(foo, BASE);\n        tokenInFee = bsub(tokenAmountIn, tokenInFee);\n        return (tokenAmountIn, tokenInFee);\n    }\n\n\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountOut)\n    {\n\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n         uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BASE, zaz));\n\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n\n \n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\n        return (poolAmountOut);\n    }\n\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    )\n        public pure\n        returns (uint tokenAmountOut)\n    {\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BASE, EXIT_FEE));\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n\n\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BASE, normalizedWeight));\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n        uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BASE, zaz));\n        return tokenAmountOut;\n    }\n\n\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    )\n        public pure\n        returns (uint poolAmountIn)\n    {\n\n\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n        uint zar = bmul(bsub(BASE, normalizedWeight), swapFee);\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BASE, zar));\n\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n\n\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n\n\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BASE, EXIT_FEE));\n        return (poolAmountIn);\n    }\n}\n// Highly opinionated token implementation\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address whom) external view returns (uint);\n    function allowance(address src, address dst) external view returns (uint);\n\n    function approve(address dst, uint amt) external returns (bool);\n    function transfer(address dst, uint amt) external returns (bool);\n    function transferFrom(\n        address src, address dst, uint amt\n    ) external returns (bool);\n}\n\ncontract FTokenBase is ReentrancyGuard, FNum {\n\n    mapping(address => uint)                   internal _balance;\n    mapping(address => uint)                   internal _balance1;\n    mapping(address => uint)                   internal _balance2;\n    mapping(address => mapping(address=>uint)) internal _allowance;\n    uint internal _totalSupply;\n    \n\n    event Approval(address indexed src, address indexed dst, uint amt);\n    event Transfer(address indexed src, address indexed dst, uint amt);\n    //event DepositFEG(address indexed src, address indexed dst, uint amt);\n\n    function _mint(uint amt) internal {\n        _balance[address(this)] = badd(_balance[address(this)], amt);\n        _totalSupply = badd(_totalSupply, amt);\n        emit Transfer(address(0), address(this), amt);\n    }\n\n    function _burn(uint amt) internal {\n        require(_balance[address(this)] >= amt);\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\n        _totalSupply = bsub(_totalSupply, amt);\n        emit Transfer(address(this), address(0), amt);\n    }\n\n    function _move(address src, address dst, uint amt) internal {\n        require(_balance[src] >= amt, \"error: Low Balance\");\n        _balance[src] = bsub(_balance[src], amt);\n        _balance[dst] = badd(_balance[dst], amt);\n        emit Transfer(src, dst, amt);\n    }\n\n    function _push(address to, uint amt) internal {\n        _move(address(this), to, amt);\n    }\n\n    function _pull(address from, uint amt) internal {\n        _move(from, address(this), amt);\n    }\n}\n\ncontract FToken is ReentrancyGuard, FTokenBase {\n\n    string  private _name     = \" TRYfETH\";\n    string  private _symbol   = \"fETHTRYeLP\";\n    uint8   private _decimals = 18;\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns(uint8) {\n        return _decimals;\n    }\n\n    function allowance(address src, address dst) external view returns (uint) {\n        return _allowance[src][dst];\n    }\n\n    function balanceOf(address whom) external view returns (uint) {\n        return _balance[whom];\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function approve(address dst, uint amt) external returns (bool) {\n        _allowance[msg.sender][dst] = amt;\n        emit Approval(msg.sender, dst, amt);\n        return true;\n    }\n\n    function increaseApproval(address dst, uint amt) external returns (bool) {\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\n        uint oldValue = _allowance[msg.sender][dst];\n        if (amt > oldValue) {\n            _allowance[msg.sender][dst] = 0;\n        } else {\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n        }\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n        return true;\n    }\n}\n\ncontract FEGexSmartSwap is FSilver, ReentrancyGuard, FToken, FMath {\n\n    struct Record {\n        bool bound;   // is token bound to pool\n        uint index;   // private\n        uint denorm;  // denormalized weight\n        uint balance;\n    }\n    \n    struct userLock {\n        bool setLock; // true = locked, false=unlocked\n        uint unlockTime;\n    }\n    \n    function getUserLock(address usr) public view returns(bool lock){\n        return _userlock[usr].setLock;\n    }\n    \n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256         tokenAmountIn,\n        uint256         tokenAmountOut\n);\n\n    event LOG_JOIN(\n        address indexed caller,\n        address indexed tokenIn,\n        uint256         tokenAmountIn\n);\n\n    event LOG_EXIT(\n        address indexed caller,\n        address indexed tokenOut,\n        uint256         tokenAmountOut\n    );\n\n    event LOG_CALL(\n        bytes4  indexed sig,\n        address indexed caller,\n        bytes           data\n    ) anonymous;\n\n    modifier _logs_() {\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex);\n        _mutex = true;\n        _;\n        _mutex = false;\n    } \n\n    modifier _viewlock_() {\n        require(!_mutex);\n        _;\n    }\n\n    bool private _mutex;\n\n\n    address private _factory = 0xf6A12645453990bC2Fe2f39C5B662e16B7f1f430;    // BFactory address to push token exitFee to\n    address private _controller =0x3B30Bac3c331168e40FC6338BA2295A2F3adDe52; // has CONTROL role \n    address private _poolOwner = 0x76EFf89CDe6ff68103E76dD492e8b25a058fcB2B;\n    address public fETH = 0xf786c34106762Ab4Eeb45a51B42a62470E9D5332;\n    address public TRY = 0xc12eCeE46ed65D970EE5C899FCC7AE133AfF9b03;\n    address public pairRewardPool = 0x88aD06b773350c113093E5F9852e1FC57424A301;\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\n\n    uint private _swapFee;\n    bool private _launched;\n    uint public FSS = 25;\n    uint public PSS = 500; // TRY has a 5% Sell Fee\n\n    address[] private _tokens;\n    uint256 public _totalSupply1;\n    uint256 public _totalSupply2;\n    mapping(address=>Record) private  _records;\n    mapping(address=>userLock) public  _userlock;\n    mapping(address=>bool) public whiteListContract;\n    mapping(address => uint256) private _balances1;\n    mapping(address => uint256) private _balances2;\n    \n    uint private _totalWeight;\n\n    constructor() {\n        _poolOwner = msg.sender;\n        _swapFee = MIN_FEE;\n        _publicSwap = false;\n        _launched = false;\n        \n    }\n    \n    function userBalanceOfTRY(address account) public view returns (uint256) {\n        return _balances1[account]; \n    }\n    \n    function userBalanceOffETH(address account) public view returns (uint256) {\n        return _balances2[account]; \n    }\n    \n    function transfer(address dst, uint amt) external returns (bool) {\n        userLock storage ulock = _userlock[msg.sender];\n        \n        if(ulock.setLock == true) {\n            require(ulock.unlockTime <= block.timestamp, \"Liquidity is locked, you cannot removed liquidity until after lock time.\");\n        }\n        _move(msg.sender, dst, amt);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\n        require(msg.sender == src || amt <= _allowance[src][msg.sender]);\n        userLock storage ulock = _userlock[msg.sender];\n        \n        if(ulock.setLock == true) {\n            require(ulock.unlockTime <= block.timestamp, \"Liquidity is locked, you cannot removed liquidity until after lock time.\");\n        }\n        \n        _move(src, dst, amt);\n        \n        if (msg.sender != src && _allowance[src][msg.sender] > 0) {\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n        }\n       return true;\n    }\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        if(IsWhiteListContract(account)) {  return false; }\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    \n    function addWhiteListContract(address _addy, bool boolean) public {\n        require(msg.sender == _controller);\n        require(_addy != address(0), \"setting 0 address;;\");\n        \n        whiteListContract[_addy] = boolean;\n    }\n    \n    function IsWhiteListContract(address _addy) public view returns(bool){\n        require(_addy != address(0), \"setting 0 address;;\");\n        \n        return whiteListContract[_addy];\n    }\n    \n    modifier noContract() {\n        require(isContract(msg.sender) == false, 'Unapproved contracts are not allowed to interact with the swap');\n        _;\n    }\n    \n    function setMaxSellRatio(uint256 _amount) public {\n        require(msg.sender == _poolOwner, \"You do not have permission\");\n        require (_amount > 0, \"cannot turn off\");\n        require (_amount <= 100, \"cannot set under 1%\");\n        SM = _amount;\n    }\n    \n    function setMax1SideLiquidityRatio(uint256 _amount) public {\n        require(msg.sender == _poolOwner, \"You do not have permission\");\n        require (_amount > 10, \"cannot set over 10%\");\n        require (_amount <= 200, \"cannot set under 0.5%\");\n        M1 = _amount;\n    }\n    \n    /*function setStakePool(address _addy) public {\n        require(msg.sender == _controller);\n    TRYstake = _addy;\n    }*/\n    \n    function setPairRewardPool(address _addy) public {\n        require(msg.sender == _controller);\n    pairRewardPool = _addy;\n    }\n    \n    function isPublicSwap()\n        external view\n        returns (bool)\n    {\n        return _publicSwap;\n        \n    }    \n    \n    function isBound(address t)\n        external view\n        returns (bool)\n    {\n        return _records[t].bound;\n    }\n\n    /*function getFinalTokens()\n        external view\n        _viewlock_\n        returns (address[] memory tokens)\n    {\n        require(_launched);\n        return _tokens;\n    }*/\n\n    function getDenormalizedWeight(address token)\n        external view\n        _viewlock_\n        returns (uint)\n    {\n\n        require(_records[token].bound);\n        return _records[token].denorm;\n    }\n\n    function getBalance(address token)\n        external view\n        _viewlock_\n        returns (uint)\n    {\n\n        require(_records[token].bound);\n        return _records[token].balance;\n    }\n    \n    function getTotalBalanceTRY(address token)\n        external view\n        _viewlock_\n        returns (uint)\n    {\n\n        require(_records[token].bound);\n        return _records[token].balance + _totalSupply1;\n    }\n    \n    function getTotalBalancefETH(address token)\n        external view\n        _viewlock_\n        returns (uint)\n    {\n\n        require(_records[token].bound);\n        return _records[token].balance + _totalSupply2;\n    }\n\n    function getSwapFee()\n        external view\n        _viewlock_\n        returns (uint)\n    {\n        return _swapFee;\n    }\n\n    function getController()\n        external view\n        _viewlock_\n        returns (address)\n    {\n        return _controller;\n    }\n\n    function setController(address manager)\n        external\n        _logs_\n        _lock_\n    {\n        require(msg.sender == _controller);\n        _controller = manager;\n    }\n\n\n    function Launch()\n        external\n        _logs_\n        _lock_\n    {\n        require(msg.sender == _poolOwner);\n        require(!_launched);\n        require(_tokens.length >= MIN_BOUND_TOKENS);\n\n        _launched = true;\n        _publicSwap = true;\n\n        _mintPoolShare(INIT_POOL_SUPPLY);\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n    }\n\n\n    function AddTokenInitial(address token, uint balance, uint denorm)\n        external\n        _logs_\n    {\n        require(msg.sender == _poolOwner);\n        require(!_records[token].bound);\n        require(!_launched);\n\n        require(_tokens.length < MAX_BOUND_TOKENS);\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0,    // balance and denorm will be validated\n            balance: 0  // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance * 98/100, denorm);\n    }\n    \n    function AddfETHInitial(address token, uint balance, uint denorm)\n        external\n        _logs_\n    {\n        require(token == fETH);\n        require(msg.sender == _poolOwner);\n        require(!_records[token].bound);\n        require(!_launched);\n\n        require(_tokens.length < MAX_BOUND_TOKENS);\n\n        _records[token] = Record({\n            bound: true,\n            index: _tokens.length,\n            denorm: 0,    // balance and denorm will be validated\n            balance: 0  // and set by `rebind`\n        });\n        _tokens.push(token);\n        rebind(token, balance * 99/100, denorm);\n    }\n\n    function rebind(address token, uint balance, uint denorm)\n        public\n        _logs_\n        _lock_\n    {\n\n        require(msg.sender == _poolOwner);\n        require(_records[token].bound);\n        require(!_launched);\n\n        require(denorm >= MIN_WEIGHT);\n        require(denorm <= MAX_WEIGHT);\n        require(balance >= MIN_BALANCE);\n\n        // Adjust the denorm and totalWeight\n        uint oldWeight = _records[token].denorm;\n        if (denorm > oldWeight) {\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n            require(_totalWeight <= MAX_TOTAL_WEIGHT);\n        } else if (denorm < oldWeight) {\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n        }\n        _records[token].denorm = denorm;\n\n        // Adjust the balance record and actual token balance\n        uint oldBalance = _records[token].balance;\n        _records[token].balance = balance;\n        if (balance > oldBalance) {\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n        } else if (balance < oldBalance) {\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE if enabled\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\n            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n            _pushUnderlying(token, _factory, tokenExitFee);\n        }\n    }\n   \n    function saveLostTokens(address token, uint amount)\n        external\n        _logs_\n        _lock_\n    {\n        require(msg.sender == _controller);\n        require(!_records[token].bound);\n\n        uint bal = IERC20(token).balanceOf(address(this));\n        require(amount <= bal);\n\n        _pushUnderlying(token, msg.sender, amount);\n    }\n\n    function getSpotPrice(address tokenIn, address tokenOut)\n        external view\n        _viewlock_\n        returns (uint spotPrice)\n    {\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(_records[tokenOut].bound, \"ERR_NOT_BOUND\");\n        Record storage inRecord = _records[tokenIn];\n        Record storage outRecord = _records[tokenOut];\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n    }\n\n    function addBothLiquidity(uint poolAmountOut, uint[] calldata maxAmountsIn)\n        external\n        _logs_\n        _lock_\n    {\n        require(_launched, \"ERR_NOT_LAUNCHED\");\n\n        uint poolTotal = totalSupply();\n        uint ratio = bdiv(poolAmountOut, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        for (uint i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint bal = _records[t].balance;\n            uint tokenAmountIn = bmul(ratio, bal);\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\n            _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n            _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        }\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        \n    }\n   \n    function removeBothLiquidity(uint poolAmountIn, uint[] calldata minAmountsOut)\n        external\n        _logs_\n        _lock_\n    {\n        require(_launched, \"ERR_NOT_LAUNCHED\");\n        userLock storage ulock = _userlock[msg.sender];\n        \n        if(ulock.setLock == true) {\n            require(ulock.unlockTime <= block.timestamp, \"Liquidity is locked, you cannot removed liquidity until after lock time.\");\n        }\n\n        uint poolTotal = totalSupply();\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\n        require(ratio != 0, \"ERR_MATH_APPROX\");\n\n        _pullPoolShare(msg.sender, poolAmountIn);\n        _pushPoolShare(_factory, exitFee);\n        _burnPoolShare(pAiAfterExitFee);\n        \n        \n        for (uint i = 0; i < _tokens.length; i++) {\n            address t = _tokens[i];\n            uint bal = _records[t].balance;\n            uint tokenAmountOut = bmul(ratio, bal);\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\n            _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n            _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        }\n\n    }\n\n    function DepositTRY(address tokenIn, uint256 amount) external  {\n        //require(amount > 0, \"Cannot deposit nothing\");\n        require(tokenIn == TRY, \"Only TRY allowed\"); \n        uint256 _txfee = amount * 98/100;\n        _pullUnderlying(tokenIn, msg.sender, amount);\n        \n       \n        uint256 finalAmount = amount - _txfee;\n        _totalSupply1 = _totalSupply1 + finalAmount;\n        _balances1[msg.sender] = _balances1[msg.sender] + finalAmount;\n        \n       // emit Transfer(tokenIn, msg.sender, finalAmount);\n    }\n    \n    function DepositfETH(address tokenIn, uint256 amount) external  {\n        require(tokenIn == fETH, \"Only fETH allowed\"); \n        //uint256 _txfee = 99/100;\n        _pullUnderlying(tokenIn, msg.sender, amount);\n        \n       \n        uint256 finalAmount = amount * 99/100;\n        _totalSupply2 = _totalSupply2 + finalAmount;\n        _balances2[msg.sender] = _balances2[msg.sender] + finalAmount;\n        \n       // emit Transfer(tokenIn, msg.sender, finalAmount);\n    }\n    \n    function WithdrawTRY(address tokenIn, uint256 amount) external  {\n        //require(amount > 0, \"Cannot deposit nothing\");\n        require(_balances1[msg.sender] >= amount, \"Not enough TRY\");\n        require(tokenIn == TRY, \"Only TRY allowed\");\n        \n        _totalSupply1 = _totalSupply1 - amount;\n        _balances1[msg.sender] = _balances1[msg.sender] - amount;\n        \n        _pushUnderlying(tokenIn, msg.sender, amount);\n        //emit Transfer(tokenIn, msg.sender, amount);\n        \n        \n    }\n    \n    function WithdrawfETH(address tokenIn, uint256 amount) external  {\n        require(tokenIn == fETH, \"Only fETH allowed\"); \n        require(_balances2[msg.sender] >= amount, \"Not enough fETH\");\n        \n        _totalSupply2 = _totalSupply2 - amount;\n        _balances2[msg.sender] = _balances2[msg.sender] - amount;\n        \n        _pushUnderlying(tokenIn, msg.sender, amount);\n        //emit Transfer(tokenIn, msg.sender, amount);\n       \n        \n    }\n\n    function BUYSmart(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) noContract\n        external\n        _logs_\n        _lock_\n        returns (uint tokenAmountOut, uint spotPriceAfter)\n    {\n        \n        require(tokenIn == fETH, \"Can only buy with fETH\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n        require(_balances2[msg.sender] >= tokenAmountIn, \"Not enough fETH, deposit more\");\n        \n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        uint spotPriceBefore = calcSpotPrice(\n                                    inRecord.balance,\n                                    inRecord.denorm,\n                                    outRecord.balance,\n                                    outRecord.denorm,\n                                    _swapFee * 0\n                                );\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        uint tokenInFee;\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n                                            inRecord.balance,\n                                            inRecord.denorm,\n                                            outRecord.balance,\n                                            outRecord.denorm,\n                                            tokenAmountIn,\n                                            _swapFee * 0\n                                        );\n                                        \n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        spotPriceAfter = calcSpotPrice(\n                                inRecord.balance,\n                                inRecord.denorm,\n                                outRecord.balance,\n                                outRecord.denorm,\n                                _swapFee * 0\n                            );\n                            \n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n\n         _balances2[msg.sender] = _balances2[msg.sender] - tokenAmountIn;\n        _balances1[msg.sender] = _balances1[msg.sender] + tokenAmountOut;\n        _totalSupply2 = _totalSupply2 - tokenAmountIn;\n        _totalSupply1 = _totalSupply1 + tokenAmountOut;\n        _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n        _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        return (tokenAmountOut, spotPriceAfter);\n    }\n    \n    function BUY(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) noContract\n        external\n        _logs_\n        _lock_\n        returns (uint tokenAmountOut, uint spotPriceAfter)\n    {\n        \n        require(tokenIn == fETH, \"Can only buy with fETH\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n        \n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        uint spotPriceBefore = calcSpotPrice(\n                                    inRecord.balance,\n                                    inRecord.denorm,\n                                    outRecord.balance,\n                                    outRecord.denorm,\n                                    _swapFee * 0\n                                );\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        uint tokenInFee;\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n                                            inRecord.balance,\n                                            inRecord.denorm,\n                                            outRecord.balance,\n                                            outRecord.denorm,\n                                            tokenAmountIn * 99/100,\n                                            _swapFee * 0\n                                        );\n                                        \n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        spotPriceAfter = calcSpotPrice(\n                                inRecord.balance,\n                                inRecord.denorm,\n                                outRecord.balance,\n                                outRecord.denorm,\n                                _swapFee\n                            );\n                            \n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn * 99/100, tokenAmountOut * 98/100);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n        _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n        _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        return (tokenAmountOut, spotPriceAfter);\n    }\n\n    function SELL(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) noContract\n        external\n        _logs_\n        _lock_\n        returns (uint tokenAmountOut, uint spotPriceAfter)\n    {\n        \n        require(tokenIn == TRY, \"Can only sell TRY\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n\n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_SELL_RATIO), \"ERR_SELL_RATIO\");\n\n        uint spotPriceBefore = calcSpotPrice(\n                                    inRecord.balance,\n                                    inRecord.denorm,\n                                    outRecord.balance,\n                                    outRecord.denorm,\n                                    _swapFee\n                                );\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        uint tokenInFee;\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n                                            inRecord.balance,\n                                            inRecord.denorm,\n                                            outRecord.balance,\n                                            outRecord.denorm,\n                                            tokenAmountIn,\n                                            _swapFee\n                                        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        spotPriceAfter = calcSpotPrice(\n                                inRecord.balance,\n                                inRecord.denorm,\n                                outRecord.balance,\n                                outRecord.denorm,\n                                _swapFee\n                            );\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn * 98/100, tokenAmountOut * 99/100);\n\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        uint256 tokAmountI  = bmul(tokenAmountOut, bdiv(FSS, 10000));\n        uint256 tokAmountI2 =  bmul(tokenAmountOut, bdiv(PSS, 10000));\n        uint256 tokAmountI1 = bsub(tokenAmountOut, badd(tokAmountI, tokAmountI2));\n        \n        _pushUnderlying(tokenOut, msg.sender, tokAmountI1);\n        _pushUnderlying1(tokenOut, tokAmountI);\n        _pushUnderlying2(tokenOut, tokAmountI2);\n        \n        _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n        _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        return (tokenAmountOut, spotPriceAfter);\n    }\n    \n     function SELLSmart(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) noContract\n        external\n        _logs_\n        _lock_\n        returns (uint tokenAmountOut, uint spotPriceAfter)\n    {\n        \n        require(tokenIn == TRY, \"Can only sell TRY\");\n        require(_publicSwap, \"ERR_SWAP_NOT_PUBLIC\");\n        require(_balances1[msg.sender] >= tokenAmountIn, \"Not enough TRY\");\n        \n        Record storage inRecord = _records[address(tokenIn)];\n        Record storage outRecord = _records[address(tokenOut)];\n\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_SELL_RATIO), \"ERR_SELL_RATIO\");\n\n        uint spotPriceBefore = calcSpotPrice(\n                                    inRecord.balance,\n                                    inRecord.denorm,\n                                    outRecord.balance,\n                                    outRecord.denorm,\n                                    _swapFee\n                                );\n        require(spotPriceBefore <= maxPrice, \"ERR_BAD_LIMIT_PRICE\");\n\n        uint tokenInFee;\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n                                            inRecord.balance,\n                                            inRecord.denorm,\n                                            outRecord.balance,\n                                            outRecord.denorm,\n                                            tokenAmountIn,\n                                            _swapFee\n                                        );\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\n\n        spotPriceAfter = calcSpotPrice(\n                                inRecord.balance,\n                                inRecord.denorm,\n                                outRecord.balance,\n                                outRecord.denorm,\n                                _swapFee\n                            );\n        require(spotPriceAfter >= spotPriceBefore, \"ERR_MATH_APPROX\");\n        require(spotPriceAfter <= maxPrice, \"ERR_LIMIT_PRICE\");\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \"ERR_MATH_APPROX\");\n\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n        uint256 tokAmountI  = bmul(tokenAmountOut, bdiv(FSS, 10000));\n        uint256 tokAmountI2 =  bmul(tokenAmountOut, bdiv(PSS, 10000));\n        uint256 tokAmountI1 = bsub(tokenAmountOut, badd(tokAmountI, tokAmountI2));\n        _balances1[msg.sender] = _balances1[msg.sender] - tokenAmountIn;\n        \n        _balances2[msg.sender] = _balances2[msg.sender] + tokAmountI1;\n        _totalSupply2 = _totalSupply2 + tokAmountI1;\n        _totalSupply1 = _totalSupply1 - tokenAmountIn;\n        \n        _pushUnderlying1(tokenOut, tokAmountI);\n        _pushUnderlying2(tokenOut, tokAmountI2);\n        \n        _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n        _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        \n        return (tokenAmountOut, spotPriceAfter);\n    }\n    \n    function setFSS(uint _FSS ) external {\n        require(msg.sender == _controller);\n        FSS = _FSS;\n    }\n    \n    function setPSS(uint _PSS ) external {\n        require(msg.sender == _controller);\n        PSS = _PSS;\n    }\n\n    function setLockLiquidity() external {\n        address user = msg.sender;\n        userLock storage ulock = _userlock[user];\n        \n        ulock.setLock = true;\n        ulock.unlockTime = block.timestamp + 90 days ; \n    }\n    \n    function emergencyLockOverride(address user, bool _bool) external {\n        require(msg.sender == _controller);\n        //address user = msg.sender;\n        userLock storage ulock = _userlock[user];\n        ulock.setLock = _bool;\n    }\n    \n    function addLiquidityfETH(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n        external noContract\n        _logs_\n        _lock_\n        returns (uint poolAmountOut)\n        \n    {\n        require(tokenIn == fETH, \"Can only add fETH\");\n        require(_launched, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_1_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n        \n        inRecord.balance = bsub(inRecord.balance, tokenAmountIn * 99/100);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n        _records[TRY].balance = IERC20(TRY).balanceOf(address(this)) - _totalSupply1;\n        _records[fETH].balance = IERC20(fETH).balanceOf(address(this)) - _totalSupply2;\n        return poolAmountOut;\n    }\n\n    function addLiquidityTRY(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n        external\n        _logs_\n        _lock_\n        returns (uint poolAmountOut)\n\n    {\n        require(tokenIn == TRY, \"Can only add TRY\");\n        require(_launched, \"ERR_NOT_FINALIZED\");\n        require(_records[tokenIn].bound, \"ERR_NOT_BOUND\");\n        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_1_RATIO), \"ERR_MAX_IN_RATIO\");\n\n        Record storage inRecord = _records[tokenIn];\n\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\n\n        inRecord.balance = bsub(inRecord.balance, tokenAmountIn * 98/100);\n\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n\n        _mintPoolShare(poolAmountOut);\n        _pushPoolShare(msg.sender, poolAmountOut);\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n    \n        return poolAmountOut;\n    }\n\n    function _pullUnderlying(address erc20, address from, uint amount)\n        internal\n        nonReentrant\n    {\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n    \n    function _pushUnderlying(address erc20, address to, uint amount)\n        internal\n        nonReentrant\n    {\n        bool xfer = IERC20(erc20).transfer(to, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n    \n    function _pushUnderlying1(address erc20, uint amount)\n        internal\n        nonReentrant\n    {\n        bool xfer = IERC20(erc20).transfer(FEGstake, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n    \n    function _pushUnderlying2(address erc20, uint amount)\n        internal\n        nonReentrant\n    {\n        bool xfer = IERC20(erc20).transfer(pairRewardPool, amount);\n        require(xfer, \"ERR_ERC20_FALSE\");\n    }\n\n    function _pullPoolShare(address from, uint amount)\n        internal\n        nonReentrant\n    {\n        _pull(from, amount);\n    }\n\n    function _pushPoolShare(address to, uint amount)\n        internal\n        nonReentrant\n    {\n        _push(to, amount);\n    }\n\n    function _mintPoolShare(uint amount)\n        internal\n        nonReentrant\n    {\n        _mint(amount);\n    }\n\n    function _burnPoolShare(uint amount)\n        internal\n    {\n        _burn(amount);\n    }\n}"}}}