{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "GEMI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n\n//\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * > It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\n//\ncontract ERC20 {\n    uint256                                           internal  _totalSupply;\n    mapping (address => uint256)                      internal  _balanceOf;\n    mapping (address => mapping (address => uint256)) internal  _allowance;\n    string                                            public  symbol;\n    uint8                                             public  immutable  decimals = 18;\n    string                                            public  name;     // Optional token name\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    event Approval(address indexed owner, address indexed spender, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address guy) public view virtual returns (uint256) {\n        return _balanceOf[guy];\n    }\n\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function approve(address spender, uint wad) public virtual returns (bool) {\n        return _approve(msg.sender, spender, wad);\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowance[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowance[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public virtual returns (bool) {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad) public virtual returns (bool) {\n        uint256 allowed = _allowance[src][msg.sender];\n\n        if (src != msg.sender && allowed != type(uint).max) {\n            require(allowed >= wad, \"ERC20: Insufficient approval\");\n            _approve(src, msg.sender, allowed - wad);\n        }\n\n        return _transfer(src, dst, wad);\n    }\n\n\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\n        require(dst != address(0), \"ERC20:cannot transfer to the zero address\");\n        require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n        _balanceOf[src] = _balanceOf[src] - wad;\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint wad) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n        return true;\n    }\n\n    function _mint(address dst, uint wad) internal virtual {\n        require(dst != address(0), \"ERC20: mint to the zero address\");\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n    }\n\n    function _burn(address src, uint wad) internal virtual {\n        require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n        _balanceOf[src] = _balanceOf[src] - wad;\n        _totalSupply = _totalSupply - wad;\n        emit Transfer(src, address(0), wad);\n    }\n\n    function _burnFrom(address src, uint wad) internal virtual {\n      uint256 allowed = _allowance[src][msg.sender];\n      if (src != msg.sender && allowed != type(uint).max) {\n          require(allowed >= wad, \"ERC20: Insufficient approval\");\n          _approve(src, msg.sender, allowed - wad);\n      }\n\n      _burn(src, wad);\n    }\n\n    \n}\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function nonces(address owner) external view returns (uint256);\n}\n\n//\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping (address => uint256) public override nonces;\n\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        uint256 chainId = block.chainid;\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name_)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n\n        _approve(owner, spender, amount);\n    }\n}\n\n//\nabstract contract DelegateERC20 is ERC20Permit {\n\n  mapping (address => address) public delegates;\n  \n  struct Checkpoint {\n    uint32 fromBlock;\n    uint votes;\n  }\n\n  mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n  mapping (address => uint32) public numCheckpoints;\n\n\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n  event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n\n  constructor(string memory name_, string memory symbol_) ERC20Permit(name_, symbol_) {\n  }\n\n  function _mint(address dst, uint wad) internal override {\n    super._mint(dst, wad); \n    _moveDelegates(address(0), delegates[dst], wad);\n  }\n\n  function _transfer(address src, address dst, uint wad) internal override returns (bool) {\n    super._transfer(src, dst, wad);\n    _moveDelegates(delegates[src], delegates[dst], wad);\n    return true;\n  }\n\n  function _burn(address src, uint wad) internal override {\n    super._burn(src, wad);\n    _moveDelegates(delegates[src], address(0), wad);\n  }\n\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    \n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"delegateBySig: invalid nonce\");\n    require(block.timestamp <= expiry, \"delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  function getCurrentVotes(address account) external view returns (uint256) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  function getPriorVotes(address account, uint blockNumber) public view returns (uint256) {\n    require(blockNumber < block.number, \"getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n        return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n        return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n        return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n        uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n        Checkpoint memory cp = checkpoints[account][center];\n        if (cp.fromBlock == blockNumber) {\n            return cp.votes;\n        } else if (cp.fromBlock < blockNumber) {\n            lower = center;\n        } else {\n            upper = center - 1;\n        }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint delegatorBalance = balanceOf(delegator);\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _moveDelegates(address srcRep, address dstRep, uint amount) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n          uint32 srcRepNum = numCheckpoints[srcRep];\n          uint srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n          uint srcRepNew = srcRepOld - amount;\n          _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n          uint32 dstRepNum = numCheckpoints[dstRep];\n          uint dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n          uint dstRepNew = dstRepOld + amount;\n          _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint oldVotes, uint newVotes) internal {\n    uint32 blockNumber = safe32(block.number, \"_writeCheckpoint: block number exceeds 32 bits\");\n\n    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n        checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n        checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n        numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n}\n\n//\ninterface TokenRecipient {\n  // must return ture\n  function tokensReceived(\n      address from,\n      uint amount,\n      bytes calldata exData\n  ) external returns (bool);\n}\n\ncontract GEMI is DelegateERC20 {\n  using Address for address;\n\n  uint256 private constant preMineSupply = 1000000000 * 1e18;\n\n  constructor (address owner) DelegateERC20(\"GEMIVERSE\", \"GEMI\")  {\n    _mint(owner, preMineSupply);\n  }\n\n  function burn(uint amount) public {\n    _burn(msg.sender, amount);\n  }\n\n  function burnFrom(address account, uint amount) public {\n    _burnFrom(account, amount);\n  }\n\n  function send(address recipient, uint amount, bytes calldata exData) external returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n\n    if (recipient.isContract()) {\n      bool rv = TokenRecipient(recipient).tokensReceived(msg.sender, amount, exData);\n      require(rv, \"No TokenRecipient\");\n    }\n\n    return true;\n  }\n\n}"
    }
  }
}