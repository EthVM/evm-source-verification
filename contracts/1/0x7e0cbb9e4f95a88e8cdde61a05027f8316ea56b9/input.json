{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DC.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract LockIdGen {\r\n\r\n    uint256 public requestCount;\r\n\r\n    constructor() public {\r\n        requestCount = 0;\r\n    }\r\n\r\n    function generateLockId() internal returns (bytes32 lockId) {\r\n        return keccak256(abi.encodePacked(blockhash(block.number-1), address(this), ++requestCount));\r\n    }\r\n}\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(StandardToken token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(StandardToken token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(StandardToken token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(StandardToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(StandardToken token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ManagerUpgradeable is LockIdGen {\r\n\r\n    struct ChangeRequest {\r\n        address proposedNew;\r\n        address proposedClear;\r\n    }\r\n\r\n    // address public custodian;\r\n    mapping (address => address) public managers;\r\n\r\n    mapping (bytes32 => ChangeRequest) public changeReqs;\r\n\r\n    uint256     public    mancount  ;\r\n\r\n    // CONSTRUCTOR\r\n    constructor(\r\n         address  [] memory _mans\r\n    )\r\n      LockIdGen()\r\n      public\r\n    {\r\n        uint256 numMans = _mans.length;\r\n        for (uint256 i = 0; i < numMans; i++) {\r\n          address pto = _mans[i];\r\n          require(pto != address(0));\r\n          managers[pto] = pto;\r\n        }\r\n        mancount = numMans;\r\n    }\r\n\r\n\r\n\r\n    modifier onlyManager {\r\n        require(msg.sender == managers[msg.sender],\"onlyManger must use\");\r\n        _;\r\n    }\r\n\r\n    //replace managers\r\n    function replaceManager(address _new,address _clear) public onlyManager {\r\n        require( _clear != address(0) || _new != address(0) );\r\n\r\n        require( _clear == address(0) || managers[_clear] == _clear);\r\n        \r\n        if(_new != address(0))\r\n        {\r\n            managers[_new] = _new;\r\n            mancount = mancount + 1;\r\n        }\r\n\r\n        if(_clear != address(0) && managers[_clear] == _clear)\r\n        {\r\n            delete managers[_clear];\r\n            mancount = mancount - 1;\r\n        }\r\n\r\n    }\r\n    \r\n    // for manager change\r\n    function requestChange(address _new,address _clear) public onlyManager returns (bytes32 lockId) {\r\n        require( _clear != address(0) || _new != address(0) );\r\n\r\n        require( _clear == address(0) || managers[_clear] == _clear);\r\n\r\n        lockId = generateLockId();\r\n\r\n        changeReqs[lockId] = ChangeRequest({\r\n            proposedNew: _new,\r\n            proposedClear: _clear\r\n        });\r\n\r\n        emit ChangeRequested(lockId, msg.sender, _new,_clear);\r\n    }\r\n\r\n    event ChangeRequested(\r\n        bytes32 _lockId,\r\n        address _msgSender,\r\n        address _new,\r\n        address _clear\r\n    );\r\n\r\n   function confirmChange(bytes32 _lockId) public onlyManager {\r\n        ChangeRequest storage changeRequest = changeReqs[_lockId];\r\n        require( changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0));\r\n\r\n        if(changeRequest.proposedNew != address(0))\r\n        {\r\n            managers[changeRequest.proposedNew] = changeRequest.proposedNew;\r\n            mancount = mancount + 1;\r\n        }\r\n\r\n        if(changeRequest.proposedClear != address(0))\r\n        {\r\n            delete managers[changeRequest.proposedClear];\r\n            mancount = mancount - 1;\r\n        }\r\n\r\n        delete changeReqs[_lockId];\r\n\r\n        emit ChangeConfirmed(_lockId, changeRequest.proposedNew,changeRequest.proposedClear);\r\n    }\r\n    event ChangeConfirmed(bytes32 _lockId, address _newCustodian, address _clearCustodian);\r\n\r\n    function sweepChange(bytes32 _lockId) public onlyManager {\r\n        ChangeRequest storage changeRequest=changeReqs[_lockId];\r\n        require((changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0) ));\r\n        delete changeReqs[_lockId];\r\n        emit ChangeSweep(_lockId, msg.sender);\r\n    }\r\n    event ChangeSweep(bytes32 _lockId, address _sender);\r\n    \r\n    function sweeptoken(address tokenaddr,uint256 amount) public onlyManager{\r\n        TransferHelper.safeTransfer(tokenaddr,msg.sender,amount);\r\n    }\r\n    function sweepeth(uint256 amount) public onlyManager{\r\n        msg.sender.transfer(amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    // events\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // public functions\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address addr) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    // events\r\n    event Approval(address indexed owner, address indexed agent, uint256 value);\r\n\r\n    // public functions\r\n    function allowance(address owner, address agent) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address agent, uint256 value) public returns (bool);\r\n\r\n}\r\n\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  // public variables\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals = 18;\r\n\r\n  // internal variables\r\n  uint256 _totalSupply;\r\n  mapping(address => uint256) _balances;\r\n\r\n  // events\r\n\r\n  // public functions\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address addr) public view returns (uint256 balance) {\r\n    return _balances[addr];\r\n  }\r\n\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    require(to != address(0));\r\n    require(value <= _balances[msg.sender]);\r\n\r\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  // internal functions\r\n\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n  // public variables\r\n\r\n  // internal variables\r\n  mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n  // events\r\n\r\n  // public functions\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    require(to != address(0));\r\n    require(value <= _balances[from],\"value lt from\");\r\n    require(value <= _allowances[from][msg.sender],\"value lt _allowances from \");\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\r\n    emit Transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address agent, uint256 value) public returns (bool) {\r\n    _allowances[msg.sender][agent] = value;\r\n    emit Approval(msg.sender, agent, value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address agent) public view returns (uint256) {\r\n    return _allowances[owner][agent];\r\n  }\r\n\r\n  function increaseApproval(address agent, uint value) public returns (bool) {\r\n    _allowances[msg.sender][agent] = _allowances[msg.sender][agent].add(value);\r\n    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval(address agent, uint value) public returns (bool) {\r\n    uint allowanceValue = _allowances[msg.sender][agent];\r\n    if (value > allowanceValue) {\r\n      _allowances[msg.sender][agent] = 0;\r\n    } else {\r\n      _allowances[msg.sender][agent] = allowanceValue.sub(value);\r\n    }\r\n    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\r\n    return true;\r\n  }\r\n  // internal functions\r\n}\r\n\r\n\r\n\r\ncontract MinableToken is StandardToken,ManagerUpgradeable{\r\n    \r\n    \r\n    uint256 maxMined =0;\r\n    constructor(uint256 _maxMined,address [] memory _mans) public ManagerUpgradeable(_mans){\r\n        maxMined = _maxMined;\r\n    }\r\n    \r\n    function _mint(address to, uint256 value) public onlyManager  {\r\n        require(maxMined==0||_totalSupply.add(value)<=maxMined,\"_mint value invalid\");\r\n        _totalSupply = _totalSupply.add(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) public {\r\n        _balances[from] = _balances[from].sub(value);\r\n        _totalSupply = _totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract DC is MinableToken {\r\n  // public variables\r\n  string public name = \"Decentralized CNY Stablecoin\";\r\n  string public symbol = \"DC\";\r\n  uint8 public decimals = 18;\r\n  string  public constant version  = \"1\";\r\n\r\n\r\n  // internal variables\r\n \r\n  // events\r\n\r\n  // public functions\r\n  constructor(address [] memory _mans,uint256 _maxMined) public MinableToken(_maxMined,_mans) {\r\n\r\n  }\r\n\r\n  // internal functions\r\n}\r\n\r\n\r\n\r\ncontract USDT is MinableToken {\r\n  // public variables\r\n  string public name = \"Defiking.finance Version 2.0\";\r\n  string public symbol = \"USDT\";\r\n  uint8 public decimals = 6;\r\n\r\n  // internal variables\r\n \r\n  // events\r\n\r\n  // public functions\r\n  constructor(address [] memory _mans,uint256 _maxMined) public MinableToken(_maxMined,_mans) {\r\n    //init _totalSupply\r\n    // _totalSupply = 1000*10000 * (10 ** uint256(decimals));\r\n    \r\n    // _balances[msg.sender] = _totalSupply;\r\n    // emit Transfer(address(0x0), msg.sender, _totalSupply);\r\n  }\r\n\r\n  // internal functions\r\n}\r\n\r\n\r\ncontract DBank is ManagerUpgradeable{\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint8;\r\n    using SafeERC20 for ERC20;\r\n    \r\n    int8 public status;//1:正常，0:暂停,3:其他\r\n\r\n    uint256  public FIX_MUL = 100;\r\n    uint256  public  buy_price = 650; //买入（抵押价格）\r\n    uint256  public  sell_price = 655; //卖出价格（赎回）\r\n    \r\n    uint256  public  total_deposit_eu = 0; //总抵押eu数量\r\n\r\n    uint256  public  total_withdraw_dc = 0; //总出售dc数量\r\n\r\n\r\n    address   public dcToken;\r\n    address   public euToken;\r\n\r\n    uint256 public EU_decimals = 10 ** 6;\r\n    uint256 public DC_decimals = 10 ** 18;\r\n\r\n    mapping(address => uint256) public withdrawWhiteLists;//address->0：m没有限额，其他则有限额\r\n    \r\n    \r\n    constructor(address _dcToken,address _euToken,uint256 _buy_price,uint256 _sell_price,address  [] memory _mans) public ManagerUpgradeable(_mans){\r\n        require(_sell_price>_buy_price);\r\n        status = 1;\r\n        dcToken = _dcToken;\r\n        euToken = _euToken; \r\n        buy_price = _buy_price;\r\n        sell_price = _sell_price;\r\n    }\r\n\r\n    function setDCToken(address _dcToken) public onlyManager {\r\n        dcToken = _dcToken;\r\n    }\r\n    \r\n     function setStatus(int8 _status) public onlyManager {\r\n        status = _status;\r\n    }\r\n    \r\n    function setDCPrice(uint256 _buy_price,uint256 _sell_price) public onlyManager {\r\n        require(_sell_price>_buy_price);\r\n        buy_price = _buy_price;\r\n        sell_price = _sell_price;\r\n    }\r\n    \r\n\r\n    modifier onRunning {\r\n        require(status == 1,\"status not corrent\");\r\n        _;\r\n    }\r\n\r\n    function deposit(uint256 _amount) public onRunning payable returns (bool){\r\n        require(_amount>0,\"_amount must gt zero\");\r\n\r\n        // user must call prove first.\r\n        \r\n        //euToken.transferFrom(msg.sender,address(this),_amount);\r\n\r\n        TransferHelper.safeTransferFrom(euToken,msg.sender,address(this),_amount);\r\n\r\n        //\r\n        uint256  dcAmount = _amount.mul(DC_decimals).mul(buy_price).div(FIX_MUL).div(EU_decimals);\r\n\r\n        DC(dcToken)._mint(msg.sender,dcAmount);\r\n\r\n        total_deposit_eu = total_deposit_eu.add(_amount);         \r\n        \r\n    }\r\n\r\n    function withdraw(uint256 dcAmount) public onRunning payable returns (bool){\r\n        require(dcAmount>0,\"dcAmount must gt zero\");\r\n\r\n        require(DC(dcToken).balanceOf(msg.sender)>=dcAmount);\r\n        \r\n        uint256 euAmount = dcAmount.mul(EU_decimals).mul(FIX_MUL).div(sell_price).div(DC_decimals);\r\n        \r\n        require(ERC20(euToken).balanceOf(msg.sender)>=euAmount);\r\n        \r\n        TransferHelper.safeTransfer(euToken,msg.sender,euAmount); \r\n        \r\n        DC(dcToken)._burn(msg.sender,dcAmount);\r\n\r\n        total_withdraw_dc = total_withdraw_dc.add(dcAmount);        \r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    // function safeTransferETH(address to, uint value) internal {\r\n    //     (bool success,bt) = to.call{value:value}(new bytes(0));\r\n    //     require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    // }\r\n}"
    }
  }
}