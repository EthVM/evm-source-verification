{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/BMining.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >= 0.5.1;\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\nlibrary Math {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        z = x < y ? x : y;\n    }\n}\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\ninterface IBSpare {\n    function requestSpare(uint amount) external;\n}\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract BMining {\n    using SafeMath for uint;\n    \n    uint public constant CONTRACT_DURATION = 6500 * 365;\n    uint public constant INCOME_NUMERATOR  = 136;\n    uint public constant INCOME_DENOMINATOR  = 100;\n    \n    uint public startBlock;\n    uint public endBlock;\n    address public BETH;\n    address public owner;\n    address public admin;\n    address public BSpare;\n\n    struct Data {\n        uint stakes;\n        uint lastAuditBlock;\n        uint rewards;\n        bool used;\n    }\n    \n    mapping (address => Data) users;\n    Data public global;\n    uint public sparedReward;\n    uint public mintedReward;\n    uint public totalIncome;\n    uint public userCount;\n    \n    receive() external payable {\n        if(msg.sender != BSpare) {\n            totalIncome += msg.value;\n        }\n    }\n    \n    constructor(address _BETH) public {\n        BETH = _BETH;\n        owner = msg.sender;\n        admin = msg.sender;\n    }\n    \n    function setupAdmin(address _admin) public {\n        require(msg.sender == owner, \"REQUIRE OWNER\");\n        admin = _admin;\n    }\n    \n    function setupSpare(address _spare) public {\n        require(msg.sender == owner, \"REQUIRE OWNER\");\n        BSpare = _spare;\n    }\n    \n    function turnOn() public returns (bool) {\n        require(BSpare != address(0), \"SETUP Spare FIRST\");\n        require(msg.sender == admin, \"REQUIRE ADMIN\");\n        require(startBlock == 0, \"ALREADY TURN ON\");\n        startBlock = block.number;\n        endBlock = startBlock.add(CONTRACT_DURATION);\n        \n        return true;\n    }\n    \n    function isOn() view public returns (bool) {\n        return endBlock > 0;\n    }\n    \n    function stake(uint amount) external {\n        require(endBlock == 0 || block.number < endBlock, \"ALREADY END\");\n        Data storage data = users[msg.sender];\n        _audit(msg.sender);\n        TransferHelper.safeTransferFrom(BETH, msg.sender, address(this), amount);\n        data.stakes = data.stakes.add(amount);\n        global.stakes = global.stakes.add(amount);\n        if(!data.used) {\n            userCount = userCount.add(1);\n            data.used = true;\n        }\n    }\n    \n    function withdraw(uint amount) external {\n        require(users[msg.sender].stakes >= amount, \"INSUFFCIENT WITHDRAW AMOUNT\");\n        _audit(msg.sender);\n        \n        TransferHelper.safeTransfer(BETH, msg.sender, amount);\n        users[msg.sender].stakes = users[msg.sender].stakes.sub(amount);\n        global.stakes = global.stakes.sub(amount);\n    }\n    \n    function mintReward() public returns(uint) {\n        _audit(msg.sender);\n        return _transferReward();\n    }\n    \n    function queryStakeInfo() public view returns(uint stakeAmount, uint lastAuditBlock, uint rewards, uint blockNumber) {\n        Data memory data = users[msg.sender];\n        stakeAmount = data.stakes;\n        lastAuditBlock = data.lastAuditBlock;\n        rewards = data.rewards.add(_getReward(data));\n        blockNumber = block.number;\n    }\n    \n    function queryGlobalInfo() public view returns (uint, uint, uint, uint, uint, uint) {\n        return (totalIncome, global.rewards.add(_getReward(global)), global.stakes, userCount, endBlock, INCOME_NUMERATOR);\n    }\n    \n    function queryAmountToExtract() view public returns (uint){\n        uint globalReward = _getReward(global) + global.rewards;\n        require(globalReward >= mintedReward, \"UNKNOWN ERROR\");\n        if(address(this).balance > sparedReward.add(globalReward).sub(mintedReward)) {\n            return address(this).balance.sub(sparedReward.add(globalReward).sub(mintedReward));\n        }\n        \n        return 0;\n    }\n    \n    function extractToSpare() public {\n        require(msg.sender == admin, \"REQUIRE ADMIN\");\n        uint amount = queryAmountToExtract();\n        if(amount > 0) {\n            TransferHelper.safeTransferETH(BSpare, amount);\n            sparedReward = 0;\n        }\n    }\n    \n    // private method\n    function _audit(address user) private {\n        Data storage data = users[user];\n        data.rewards = data.rewards.add(_getReward(data));\n        data.lastAuditBlock = Math.min(block.number, endBlock);\n        \n        _auditGlobal();\n    }\n    \n    function _auditGlobal() private {\n        global.rewards = global.rewards.add(_getReward(global));\n        global.lastAuditBlock = Math.min(block.number, endBlock);\n    }\n    \n    function _transferReward() private returns(uint rewards){\n        Data storage data = users[msg.sender];\n        require(data.rewards > 0, \"INSUFFCIENT STAKE REWARDS\");\n        if(address(this).balance < data.rewards) {\n            sparedReward = sparedReward.add(data.rewards.sub(address(this).balance));\n            IBSpare(BSpare).requestSpare(data.rewards.sub(address(this).balance));\n        }\n        \n        mintedReward = mintedReward.add(data.rewards);\n        require(address(this).balance >= data.rewards, \"NOT ENOUGH BALANCE NOW\");\n        \n        TransferHelper.safeTransferETH(msg.sender, data.rewards);\n        rewards = data.rewards;\n        data.rewards = 0;\n    }\n    \n    function _getReward (Data memory data) private view returns(uint reward) {\n        if(!isOn()) {\n            return 0;\n        } \n        uint auditBlock = Math.min(block.number, endBlock);\n        uint stakeDuration = data.lastAuditBlock > startBlock ? auditBlock.sub(data.lastAuditBlock) : auditBlock.sub(startBlock);\n        reward = data.stakes.mul(stakeDuration).mul(INCOME_NUMERATOR) / INCOME_DENOMINATOR / CONTRACT_DURATION;\n    }\n}"}}}