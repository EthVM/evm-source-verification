{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/UniswapPairInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/// SWC-103:  Floating Pragma\npragma solidity 0.6.12;\n\ninterface UniswapPairInterface {\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveEthereumInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface XplosiveEthereumInterface {\n    //Public functions\n    function maxScalingFactor() external view returns (uint256);\n    function xETHScalingFactor() external view returns (uint256);\n    //rebase permissioned\n    function setTxFee(uint16 fee) external ;\n    function setSellFee(uint16 fee) external ;\n    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\n}\n"
    },
    "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveGovenorable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract XplosiveGovenorable is Ownable {\n  address private _governor;\n\n  event TransferredGovenorship(address indexed previousGovenor, address indexed newGovenor);\n\n  constructor()\n  internal\n  {\n    address msgSender = _msgSender();\n    _governor = msgSender;\n    emit TransferredGovenorship(address(0), msgSender);\n  }\n\n  function Governor() public view returns(address) {\n    return _governor;\n  }\n\n  modifier onlyGovenor() {\n    require(_governor == _msgSender(), \"caller is not govenor\");\n    _;\n  }\n\n  function transferGovenorship(address newGovenor) public virtual onlyOwner {\n    require(newGovenor != address(0), \"new rebaser is address zero\");\n    emit TransferredGovenorship(_governor, newGovenor);\n    _governor = newGovenor;\n  }\n}\n"
    },
    "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveRebaseOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/**\n *\n * ██╗  ██╗███████╗████████╗██╗  ██╗\n * ╚██╗██╔╝██╔════╝╚══██╔══╝██║  ██║\n *  ╚███╔╝ █████╗     ██║   ███████║\n *  ██╔██╗ ██╔══╝     ██║   ██╔══██║\n * ██╔╝ ██╗███████╗   ██║   ██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝\n *\n *    An Ethereum pegged\n * base-down, burn-up currency.\n *       Rebase-Oracle\n *\n *  https://xEth.finance\n *\n *\n**/\n\n\n/// SWC-103:  Floating Pragma\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./XplosiveSafeMath.sol\";\nimport \"./XplosiveEthereumInterface.sol\";\nimport \"./UniswapPairInterface.sol\";\nimport './XplosiveGovenorable.sol';\n\ncontract XplosiveRebaseOracle is Ownable, XplosiveGovenorable\n{\n  using XplosiveSafeMath for uint256;\n\n  /// @notice an event emitted when deviationThreshold is changed\n  event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\n\n  event TargetToleranceChanged(uint256 _newTolerance);\n\n  /// @notice Spreads out getting to the target price\n  uint256 public rebaseLag;\n\n  /// @notice Peg target\n  uint256 public targetRate;\n\n  uint256 private targetTolerance = 0.2 ether;\n\n  // If the current exchange rate is within this fractional distance from the target, no supply\n  // update is performed. Fixed point number--same format as the rate.\n  // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\n  uint256 public deviationThreshold;\n\n  /// @notice More than this much time must pass between rebase operations.\n  uint256 public minRebaseTimeIntervalSec;\n\n  /// @notice Block timestamp of last rebase operation\n  uint256 public lastRebaseTimestampSec;\n\n  /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\n  // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\n  uint256 public rebaseWindowOffsetSec;\n\n  /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\n  uint256 public rebaseWindowLengthSec;\n\n  /// @notice The number of rebase cycles since inception\n  uint256 public epoch;\n\n  /// @notice delays rebasing activation to facilitate liquidity\n  uint256 public constant rebaseDelay = 0;\n\n  address public xETHAddress;\n\n  address public uniswap_xeth_eth_pair;\n\n  mapping(address => bool) public whitelistFrom;\n\n  constructor(address _XplosiveTokenAddress, address _XplosiveUniswapPairAddress)\n  public\n  Ownable()\n  XplosiveGovenorable()\n  {\n      minRebaseTimeIntervalSec = 1 days;\n      rebaseWindowOffsetSec = 0; // 00:00 UTC rebases\n      // Default Target Rate Set For 1 ETH\n      targetRate = 10**18;\n      // daily rebase, with targeting reaching peg\n      rebaseLag = 1;\n      // 5%\n      // deviationThreshold = 5 * 10**15;\n      // 20%\n      deviationThreshold = 0.2 ether;\n      // 24 hours\n      rebaseWindowLengthSec = 24 hours;\n      uniswap_xeth_eth_pair = _XplosiveUniswapPairAddress;\n      xETHAddress = _XplosiveTokenAddress;\n  }\n\n  function setWhitelistedRebaserAddress(address _addr, bool _whitelisted)\n  external\n  onlyGovenor\n  {\n      whitelistFrom[_addr] = _whitelisted;\n  }\n\n\n  function _isWhitelisted(address _from)\n  internal\n  view\n  returns (bool)\n  {\n      return whitelistFrom[_from];\n  }\n\n  /**\n  * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n  *\n  * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\n  *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n  *      and targetRate is 1e18\n  */\n  function rebase()\n  public\n  {\n    // EOA only\n    require(msg.sender == tx.origin);\n    require(_isWhitelisted(msg.sender));\n    // ensure rebasing at correct time\n    _inRebaseWindow();\n\n    require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\n\n    // Snap the rebase time to the start of this window.\n    lastRebaseTimestampSec = now;\n\n    epoch = epoch.add(1);\n\n    // get price from uniswap v2;\n    // uint256 exchangeRate = getPrice();\n    (uint xethReserve, uint ethReserve, ) = UniswapPairInterface(uniswap_xeth_eth_pair).getReserves();\n    uint uniPrice = ethReserve.mul(10e18).div(xethReserve);\n\n    // calculates % change to supply\n    // (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\n    (uint256 offPegPerc, bool positive) = computeOffPegPerc(uniPrice);\n\n    uint256 indexDelta;\n    if(!positive)\n    {\n      indexDelta = uniPrice;\n    }\n    else\n    {\n      indexDelta = offPegPerc;\n    }\n\n    // Apply the Dampening factor.\n    indexDelta = indexDelta.div(rebaseLag);\n\n    XplosiveEthereumInterface xETH = XplosiveEthereumInterface(xETHAddress);\n\n    if (positive)\n    {\n      require(xETH.xETHScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < xETH.maxScalingFactor(), \"new scaling factor will be too big\");\n    }\n\n    // rebase\n    xETH.rebase(epoch, indexDelta, positive);\n    assert(xETH.xETHScalingFactor() <= xETH.maxScalingFactor());\n  }\n\n  /**\n  * @dev Use Circuit Breakers (Prevents some un godly amount of XETHG to be minted)\n  * 1.xETHG Price Marker\n  * 2.Set Rebase 20% treashold\n  * 3.Calculate Uni Pair Price\n  * 4.Target Price + Circuit Breaker\n  * 5.Accepted xETHprice Price For Rebase\n  * 6.Is Uniswap Price Over Circuit Breaker?\n  * 7.Yes, Use Rebase xETHCircuit Breaker Price\n  * 8.No, Use Uniswap Price\n  */\n  // function getPrice()\n  // public\n  // view\n  // onlyGovenor\n  // returns (uint256)\n  // {\n  //   (uint xethReserve, uint ethReserve, ) = UniswapPairInterface(uniswap_xeth_eth_pair).getReserves();\n  //   // uint xEthPrice;\n  //   // uint ETHER = 1 ether;\n  //   // uint ETHER_80 = 0.8 ether;\n  //   // uint BASE_20 = ETHER.sub(ETHER_80);\n  //   // uint BASE_20 = 0.2 ether;\n\n  //   // uint uniPrice = ethReserve.mul(ETHER).div(xethReserve);\n  //   uint uniPrice = ethReserve.mul(10e18).div(xethReserve);\n  //   // uint circuitBreaker = (targetRate.mul(BASE_20)).div(10e18);\n  //   uint newTargetRate = targetRate.mul(targetTolerance).div(10e18);\n  //   // uint xEthCircuitBreakerPrice = targetRate.add(circuitBreaker);\n  //   uint expectedTargetRate = targetRate.add(newTargetRate);\n  //   if (uniPrice > expectedTargetRate)\n  //   {\n  //     // return xEthPrice = xEthCircuitBreakerPrice;\n  //     return expectedTargetRate;\n  //   }\n  //   else\n  //   {\n  //     // return xEthPrice = uniPrice;\n  //     return uniPrice;\n  //   }\n\n  // }\n\n  function setDeviationThreshold(uint256 deviationThreshold_)\n  external\n    onlyGovenor\n\n  {\n    require(deviationThreshold > 0);\n    uint256 oldDeviationThreshold = deviationThreshold;\n    deviationThreshold = deviationThreshold_;\n    emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\n  }\n\n  /**\n  * @notice Sets the rebase lag parameter.\n  It is used to dampen the applied supply adjustment by 1 / rebaseLag\n  If the rebase lag R, equals 1, the smallest value for R, then the full supply\n  correction is applied on each rebase cycle.\n  If it is greater than 1, then a correction of 1/R of is applied on each rebase.\n  * @param rebaseLag_ The new rebase lag parameter.\n  */\n  function setRebaseLag(uint256 rebaseLag_)\n  external\n  onlyGovenor\n  {\n    require(rebaseLag_ > 0);\n    rebaseLag = rebaseLag_;\n  }\n\n  /**\n  * @notice Sets the targetRate parameter.\n  * @param targetRate_ The new target rate parameter.\n  */\n  function setTargetRate(uint256 targetRate_)\n  external\n  onlyGovenor\n  {\n    require(targetRate_ > 0);\n    targetRate = targetRate_;\n  }\n\n  /**\n  * @notice Sets the parameters which control the timing and frequency of\n  *         rebase operations.\n  *         a) the minimum time period that must elapse between rebase cycles.\n  *         b) the rebase window offset parameter.\n  *         c) the rebase window length parameter.\n  * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\n  *        operations, in seconds.\n  * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\n  the rebase interval, where the rebase window begins.\n  * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\n  */\n  function setRebaseTimingParameters(uint256 minRebaseTimeIntervalSec_, uint256 rebaseWindowOffsetSec_, uint256 rebaseWindowLengthSec_)\n  external\n  onlyGovenor\n  {\n    require(minRebaseTimeIntervalSec_ > 0);\n    require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\n\n    minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\n    rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\n    rebaseWindowLengthSec = rebaseWindowLengthSec_;\n  }\n\n  /**\n  * @return If the latest block timestamp is within the rebase time window it, returns true.\n  *         Otherwise, returns false.\n  */\n  function inRebaseWindow()\n  public\n  view\n  returns (bool)\n  {\n    // rebasing is delayed until there is a liquid market\n    _inRebaseWindow();\n    return true;\n  }\n\n  function _inRebaseWindow()\n  internal\n  view\n  {\n    require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, \"too early\");\n    require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), \"too late\");\n  }\n\n  // function testComputeOddPegPercent(uint256 _rate)\n  // external\n  // view\n  // onlyOwner\n  // returns (uint256, bool)\n  // {\n  //   (uint256 difference, bool overtarget) = computeOffPegPerc(_rate);\n  //   return (difference, overtarget);\n  // }\n\n  /**\n  * @return Computes in % how far off market is from peg\n  */\n  function computeOffPegPerc(uint256 rate)\n  private\n  view\n  returns (uint256, bool)\n  {\n    if (withinDeviationThreshold(rate))\n    {\n      return (0, false);\n    }\n\n    // indexDelta =  (rate - targetRate) / targetRate\n    if (rate > targetRate)\n    {\n      uint256 t = rate.sub(targetRate).mul(10**18).div(targetRate);\n      if(t > deviationThreshold)\n      {\n        return (deviationThreshold, true);\n      }\n\n      return (t, true);\n    }\n\n    // return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\n    return (0, false);\n  }\n\n  // function testWithinDeviationThreshold(uint256 _rate)\n  // external\n  // view\n  // onlyOwner\n  // returns (bool)\n  // {\n  //   bool b = withinDeviationThreshold(_rate);\n  //   return b;\n  // }\n\n  /**\n  * @param rate The current exchange rate, an 18 decimal fixed point number.\n  * @return If the rate is within the deviation threshold from the target rate, returns true.\n  *         Otherwise, returns false.\n  */\n  function withinDeviationThreshold(uint256 rate)\n  private\n  view\n  returns (bool)\n  {\n    uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold).div(10 ** 18);\n    return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold) || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\n  }\n\n  // function getTargetTolerance()\n  // public\n  // view\n  // returns (uint256)\n  // {\n  //   return targetTolerance;\n  // }\n\n  // function setTargetTolerance(uint256 _newTolerance)\n  // external\n  // onlyGovenor\n  // {\n  //   targetTolerance = _newTolerance;\n  //   emit TargetToleranceChanged(targetTolerance);\n  // }\n}\n"
    },
    "/Users/mrbitkoin/Projects/LindaCEOJonah/Repositories/Sparkle-Developers/XETH/xeth-v2-oracle/contracts/XplosiveSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary XplosiveSafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256)\n    {\n        uint256 c = add(a,m);\n        uint256 d = sub(c,1);\n        return mul(div(d,m),m);\n    }\n\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0, \"Div by zero\");\n        uint256 r = x / y;\n        if (x % y != 0) {\n            r = r + 1;\n        }\n\n        return r;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    }
  }
}