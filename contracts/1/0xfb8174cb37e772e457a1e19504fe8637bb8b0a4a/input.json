{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BankController.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma experimental ABIEncoderV2;\r\npragma solidity 0.6.4;\r\n\r\nlibrary EthAddressLib {\r\n    /**\r\n     * @dev returns the address used within the protocol to identify ETH\r\n     * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return b - a;\r\n        }\r\n        return a - b;\r\n    }\r\n}\r\ncontract Exponential {\r\n    uint256 constant expScale = 1e18;\r\n    uint256 constant doubleScale = 1e36;\r\n    uint256 constant halfExpScale = expScale / 2;\r\n\r\n    using SafeMath for uint256;\r\n\r\n    function getExp(uint256 num, uint256 denom)\r\n        public\r\n        pure\r\n        returns (uint256 rational)\r\n    {\r\n        rational = num.mul(expScale).div(denom);\r\n    }\r\n\r\n    function getDiv(uint256 num, uint256 denom)\r\n        public\r\n        pure\r\n        returns (uint256 rational)\r\n    {\r\n        rational = num.mul(expScale).div(denom);\r\n    }\r\n\r\n    function addExp(uint256 a, uint256 b) public pure returns (uint256 result) {\r\n        result = a.add(b);\r\n    }\r\n\r\n    function subExp(uint256 a, uint256 b) public pure returns (uint256 result) {\r\n        result = a.sub(b);\r\n    }\r\n\r\n    function mulExp(uint256 a, uint256 b) public pure returns (uint256) {\r\n        uint256 doubleScaledProduct = a.mul(b);\r\n\r\n        uint256 doubleScaledProductWithHalfScale = halfExpScale.add(\r\n            doubleScaledProduct\r\n        );\r\n\r\n        return doubleScaledProductWithHalfScale.div(expScale);\r\n    }\r\n\r\n    function divExp(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return getDiv(a, b);\r\n    }\r\n\r\n    function mulExp3(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c\r\n    ) public pure returns (uint256) {\r\n        return mulExp(mulExp(a, b), c);\r\n    }\r\n\r\n    function mulScalar(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256 scaled)\r\n    {\r\n        scaled = a.mul(scalar);\r\n    }\r\n\r\n    function mulScalarTruncate(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 product = mulScalar(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    function mulScalarTruncateAddUInt(\r\n        uint256 a,\r\n        uint256 scalar,\r\n        uint256 addend\r\n    ) public pure returns (uint256) {\r\n        uint256 product = mulScalar(a, scalar);\r\n        return truncate(product).add(addend);\r\n    }\r\n\r\n    function divScalarByExpTruncate(uint256 scalar, uint256 divisor)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 fraction = divScalarByExp(scalar, divisor);\r\n        return truncate(fraction);\r\n    }\r\n\r\n    function divScalarByExp(uint256 scalar, uint256 divisor)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numerator = expScale.mul(scalar);\r\n        return getExp(numerator, divisor);\r\n    }\r\n\r\n    function divScalar(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.div(scalar);\r\n    }\r\n\r\n    function truncate(uint256 exp) public pure returns (uint256) {\r\n        return exp.div(expScale);\r\n    }\r\n}\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\ninterface IFToken is IERC20 {\r\n    function mint(address user, uint256 amount) external returns (bytes memory);\r\n\r\n    function borrow(address borrower, uint256 borrowAmount)\r\n        external\r\n        returns (bytes memory);\r\n\r\n    function withdraw(\r\n        address payable withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) external returns (uint256, bytes memory);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function accrueInterest() external;\r\n\r\n    function getAccountState(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function MonitorEventCallback(\r\n        address who,\r\n        bytes32 funcName,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    //用户存借取还操作后的兑换率\r\n    function exchangeRateCurrent() external view returns (uint256 exchangeRate);\r\n\r\n    function repay(address borrower, uint256 repayAmount)\r\n        external\r\n        returns (uint256, bytes memory);\r\n\r\n    function borrowBalanceStored(address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256 exchangeRate);\r\n\r\n    function liquidateBorrow(\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        address fTokenCollateral\r\n    ) external returns (bytes memory);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    function _reduceReserves(uint256 reduceAmount) external;\r\n\r\n    function _addReservesFresh(uint256 addAmount) external;\r\n\r\n    function cancellingOut(address striker)\r\n        external\r\n        returns (bool strikeOk, bytes memory strikeLog);\r\n\r\n    function APR() external view returns (uint256);\r\n\r\n    function APY() external view returns (uint256);\r\n\r\n    function calcBalanceOfUnderlying(address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function borrowSafeRatio() external view returns (uint256);\r\n\r\n    function tokenCash(address token, address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowRate() external view returns (uint256);\r\n\r\n    function addTotalCash(uint256 _addAmount) external;\r\n    function subTotalCash(uint256 _subAmount) external;\r\n\r\n    function totalCash() external view returns (uint256);\r\n    function totalReserves() external view returns (uint256);\r\n    function totalBorrows() external view returns (uint256);\r\n}\r\ninterface IOracle {\r\n    function get(address token) external view returns (uint256, bool);\r\n}\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\nenum RewardType {\r\n    DefaultType,\r\n    Deposit,\r\n    Borrow,\r\n    Withdraw,\r\n    Repay,\r\n    Liquidation,\r\n    TokenIn, //入金，为还款和存款的组合\r\n    TokenOut //出金， 为取款和借款的组合\r\n}\r\ninterface IBank {\r\n    function MonitorEventCallback(bytes32 funcName, bytes calldata payload)\r\n        external;\r\n\r\n    function deposit(address token, uint256 amount) external payable;\r\n\r\n    function borrow(address token, uint256 amount) external;\r\n\r\n    function withdraw(address underlying, uint256 withdrawTokens) external;\r\n\r\n    function withdrawUnderlying(address underlying, uint256 amount) external;\r\n\r\n    function repay(address token, uint256 amount) external payable;\r\n\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        address underlyingBorrow,\r\n        address underlyingCollateral,\r\n        uint256 repayAmount\r\n    ) external payable;\r\n\r\n    function tokenIn(address token, uint256 amountIn) external payable;\r\n\r\n    function tokenOut(address token, uint256 amountOut) external;\r\n\r\n    function cancellingOut(address token) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\ninterface IRewardPool {\r\n    function theForceToken() external view returns (address);\r\n    function bankController() external view returns (address);\r\n    function admin() external view returns (address);\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n    function withdraw() external;\r\n\r\n    function setTheForceToken(address _theForceToken) external;\r\n    function setBankController(address _bankController) external;\r\n\r\n    function reward(address who, uint256 amount) external;\r\n}\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\ncontract BankController is Exponential, Initializable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    struct Market {\r\n        // 原生币种对应的 fToken 地址\r\n        address fTokenAddress;\r\n        // 币种是否可用\r\n        bool isValid;\r\n        // 该币种所拥有的质押能力\r\n        uint256 collateralAbility;\r\n        // 市场所参与的用户\r\n        mapping(address => bool) accountsIn;\r\n        // 该币种的清算奖励\r\n        uint256 liquidationIncentive;\r\n    }\r\n\r\n    // 原生币种地址 => 币种信息\r\n    mapping(address => Market) public markets;\r\n\r\n    address public bankEntryAddress; // bank主合约入口地址\r\n    address public theForceToken; // 奖励的FOR token地址\r\n\r\n    //返利百分比，根据用户存，借，取，还花费的gas返还对应价值比例的奖励token， 奖励FOR数量 = ETH价值 * rewardFactor / price(for)， 1e18 scale\r\n    mapping(uint256 => uint256) public rewardFactors; // RewardType ==> rewardFactor (1e18 scale);\r\n\r\n    // 用户地址 =》 币种地址（用户参与的币种）\r\n    mapping(address => IFToken[]) public accountAssets;\r\n\r\n    IFToken[] public allMarkets;\r\n\r\n    address[] public allUnderlyingMarkets;\r\n\r\n    IOracle public oracle;\r\n\r\n    address public mulsig;\r\n\r\n    //FIXME: 统一权限管理\r\n    modifier auth {\r\n        require(\r\n            msg.sender == admin || msg.sender == bankEntryAddress,\r\n            \"msg.sender need admin or bank\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setBankEntryAddress(address _newBank) external auth {\r\n        bankEntryAddress = _newBank;\r\n    }\r\n\r\n    function setTheForceToken(address _theForceToken) external auth {\r\n        theForceToken = _theForceToken;\r\n    }\r\n\r\n    function setRewardFactorByType(uint256 rewaradType, uint256 factor)\r\n        external\r\n        auth\r\n    {\r\n        rewardFactors[rewaradType] = factor;\r\n    }\r\n\r\n    function marketsContains(address fToken) public view returns (bool) {\r\n        uint256 len = allMarkets.length;\r\n        for (uint256 i = 0; i < len; ++i) {\r\n            if (address(allMarkets[i]) == fToken) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    uint256 public closeFactor;\r\n\r\n    address public admin;\r\n\r\n    address public proposedAdmin;\r\n\r\n    // 将FOR奖励池单独放到另外一个合约中\r\n    address public rewardPool;\r\n\r\n    uint256 public transferEthGasCost;\r\n\r\n    // @notice Borrow caps enforced by borrowAllowed for each token address. Defaults to zero which corresponds to unlimited borrowing.\r\n    mapping(address => uint) public borrowCaps;\r\n    \r\n    // @notice Supply caps enforced by mintAllowed for each token address. Defaults to zero which corresponds to unlimited supplying.\r\n    mapping(address => uint) public supplyCaps;\r\n\r\n    // 原生token的存，借，取，取，还和清算配置设置\r\n    struct TokenConfig {\r\n        bool depositDisabled; //存款：true:禁用，false: 启用\r\n        bool borrowDisabled;// 借款\r\n        bool withdrawDisabled;// 取款\r\n        bool repayDisabled; //还款\r\n        bool liquidateBorrowDisabled;//清算\r\n    }\r\n    \r\n    //underlying => TokenConfig\r\n    mapping (address => TokenConfig) public tokenConfigs;\r\n\r\n    // _setMarketBorrowSupplyCaps = _setMarketBorrowCaps + _setMarketSupplyCaps\r\n    function _setMarketBorrowSupplyCaps(address[] calldata tokens, uint[] calldata newBorrowCaps, uint[] calldata newSupplyCaps) external {\r\n        require(msg.sender == admin, \"only admin can set borrow/supply caps\"); \r\n\r\n        uint numMarkets = tokens.length;\r\n        uint numBorrowCaps = newBorrowCaps.length;\r\n        uint numSupplyCaps = newSupplyCaps.length;\r\n\r\n        require(numMarkets != 0 && numMarkets == numBorrowCaps && numMarkets == numSupplyCaps, \"invalid input\");\r\n\r\n        for(uint i = 0; i < numMarkets; i++) {\r\n            borrowCaps[tokens[i]] = newBorrowCaps[i];\r\n            supplyCaps[tokens[i]] = newSupplyCaps[i];\r\n        }\r\n    }\r\n\r\n    \r\n    function setTokenConfig(\r\n        address t, \r\n        bool _depositDisabled, \r\n        bool _borrowDisabled, \r\n        bool _withdrawDisabled,\r\n        bool _repayDisabled,\r\n        bool _liquidateBorrowDisabled) external {\r\n        require(msg.sender == admin, \"only admin can set token configs\");\r\n        tokenConfigs[t] = TokenConfig(\r\n            _depositDisabled,\r\n            _borrowDisabled,\r\n            _withdrawDisabled,\r\n            _repayDisabled,\r\n            _liquidateBorrowDisabled\r\n        );\r\n    }\r\n\r\n    function initialize(address _mulsig) public initializer {\r\n        admin = msg.sender;\r\n        mulsig = _mulsig;\r\n        transferEthGasCost = 5000;\r\n    }\r\n\r\n    modifier onlyMulSig {\r\n        require(msg.sender == mulsig, \"require admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin, \"require admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFToken(address fToken) {\r\n        require(marketsContains(fToken), \"only supported fToken\");\r\n        _;\r\n    }\r\n\r\n    event AddTokenToMarket(address underlying, address fToken);\r\n\r\n    function proposeNewAdmin(address admin_) external onlyMulSig {\r\n        proposedAdmin = admin_;\r\n    }\r\n\r\n    function claimAdministration() external {\r\n        require(msg.sender == proposedAdmin, \"Not proposed admin.\");\r\n        admin = proposedAdmin;\r\n        proposedAdmin = address(0);\r\n    }\r\n\r\n    // 获取原生 token 对应的 fToken 地址\r\n    function getFTokeAddress(address underlying) public view returns (address) {\r\n        return markets[underlying].fTokenAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the assets an account has entered\r\n     返回该账户已经参与的币种\r\n     * @param account The address of the account to pull assets for\r\n     * @return A dynamic list with the assets the account has entered\r\n     */\r\n    function getAssetsIn(address account)\r\n        external\r\n        view\r\n        returns (IFToken[] memory)\r\n    {\r\n        IFToken[] memory assetsIn = accountAssets[account];\r\n\r\n        return assetsIn;\r\n    }\r\n\r\n    function checkAccountsIn(address account, IFToken fToken)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            markets[IFToken(address(fToken)).underlying()].accountsIn[account];\r\n    }\r\n\r\n    function userEnterMarket(IFToken fToken, address borrower) internal {\r\n        Market storage marketToJoin = markets[fToken.underlying()];\r\n\r\n        require(marketToJoin.isValid, \"Market not valid\");\r\n\r\n        if (marketToJoin.accountsIn[borrower]) {\r\n            return;\r\n        }\r\n\r\n        marketToJoin.accountsIn[borrower] = true;\r\n\r\n        accountAssets[borrower].push(fToken);\r\n    }\r\n\r\n    function transferCheck(\r\n        address fToken,\r\n        address src,\r\n        address dst,\r\n        uint256 transferTokens\r\n    ) external onlyFToken(msg.sender) {\r\n        withdrawCheck(fToken, src, transferTokens);\r\n        userEnterMarket(IFToken(fToken), dst);\r\n    }\r\n\r\n    function withdrawCheck(\r\n        address fToken,\r\n        address withdrawer,\r\n        uint256 withdrawTokens\r\n    ) public view returns (uint256) {\r\n        address underlying = IFToken(fToken).underlying();\r\n        require(\r\n            markets[underlying].isValid,\r\n            \"Market not valid\"\r\n        );\r\n        require(!tokenConfigs[underlying].withdrawDisabled, \"withdraw disabled\");\r\n\r\n        (uint256 sumCollaterals, uint256 sumBorrows) = getUserLiquidity(\r\n            withdrawer,\r\n            IFToken(fToken),\r\n            withdrawTokens,\r\n            0\r\n        );\r\n        require(sumCollaterals >= sumBorrows, \"Cannot withdraw tokens\");\r\n    }\r\n\r\n    // 接收转账\r\n    function transferIn(\r\n        address account,\r\n        address underlying,\r\n        uint256 amount\r\n    ) public payable {\r\n        if (underlying != EthAddressLib.ethAddress()) {\r\n            require(msg.value == 0, \"ERC20 do not accecpt ETH.\");\r\n            uint256 balanceBefore = IERC20(underlying).balanceOf(address(this));\r\n            IERC20(underlying).safeTransferFrom(account, address(this), amount);\r\n            uint256 balanceAfter = IERC20(underlying).balanceOf(address(this));\r\n            require(\r\n                balanceAfter - balanceBefore == amount,\r\n                \"TransferIn amount not valid\"\r\n            );\r\n            // erc 20 => transferFrom\r\n        } else {\r\n            // 接收 eth 转账，已经通过 payable 转入\r\n            require(msg.value >= amount, \"Eth value is not enough\");\r\n            if (msg.value > amount) {\r\n                //send back excess ETH\r\n                uint256 excessAmount = msg.value.sub(amount);\r\n                //solium-disable-next-line\r\n                (bool result, ) = account.call{\r\n                    value: excessAmount,\r\n                    gas: transferEthGasCost\r\n                }(\"\");\r\n                require(result, \"Transfer of ETH failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // 向用户转账\r\n    function transferToUser(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 amount\r\n    ) external onlyFToken(msg.sender) {\r\n        require(\r\n            markets[IFToken(msg.sender).underlying()].isValid,\r\n            \"TransferToUser not allowed\"\r\n        );\r\n        transferToUserInternal(underlying, account, amount);\r\n    }\r\n\r\n    function transferToUserInternal(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 amount\r\n    ) internal {\r\n        if (underlying != EthAddressLib.ethAddress()) {\r\n            // erc 20\r\n            // ERC20(token).safeTransfer(user, _amount);\r\n            IERC20(underlying).safeTransfer(account, amount);\r\n        } else {\r\n            (bool result, ) = account.call{\r\n                value: amount,\r\n                gas: transferEthGasCost\r\n            }(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    //1:1返还\r\n    function calcRewardAmount(\r\n        uint256 gasSpend,\r\n        uint256 gasPrice,\r\n        address _for\r\n    ) public view returns (uint256) {\r\n        (uint256 _ethPrice, bool _ethValid) = fetchAssetPrice(\r\n            EthAddressLib.ethAddress()\r\n        );\r\n        (uint256 _forPrice, bool _forValid) = fetchAssetPrice(_for);\r\n        if (!_ethValid || !_forValid || IERC20(_for).decimals() != 18) {\r\n            return 0;\r\n        }\r\n        return gasSpend.mul(gasPrice).mul(_ethPrice).div(_forPrice);\r\n    }\r\n\r\n    //0.5 * 1e18, 表返还0.5ETH价值的FOR\r\n    //1.5 * 1e18, 表返还1.5倍ETH价值的FOR\r\n    function calcRewardAmountByFactor(\r\n        uint256 gasSpend,\r\n        uint256 gasPrice,\r\n        address _for,\r\n        uint256 factor\r\n    ) public view returns (uint256) {\r\n        return calcRewardAmount(gasSpend, gasPrice, _for).mul(factor).div(1e18);\r\n    }\r\n\r\n    function setRewardPool(address _rewardPool) external onlyAdmin {\r\n        rewardPool = _rewardPool;\r\n    }\r\n\r\n    function setTransferEthGasCost(uint256 _transferEthGasCost)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        transferEthGasCost = _transferEthGasCost;\r\n    }\r\n\r\n    function rewardForByType(\r\n        address account,\r\n        uint256 gasSpend,\r\n        uint256 gasPrice,\r\n        uint256 rewardType\r\n    ) external auth {\r\n        uint256 amount = calcRewardAmountByFactor(\r\n            gasSpend,\r\n            gasPrice,\r\n            theForceToken,\r\n            rewardFactors[rewardType]\r\n        );\r\n        amount = SafeMath.min(\r\n            amount,\r\n            IERC20(theForceToken).balanceOf(rewardPool)\r\n        );\r\n        if (amount > 0) {\r\n            IRewardPool(rewardPool).reward(account, amount);\r\n        }\r\n    }\r\n\r\n    // 获取实际原生代币的余额\r\n    function getCashPrior(address underlying) public view returns (uint256) {\r\n        IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n        return fToken.totalCash();\r\n    }\r\n\r\n    // 获取将要更新后的原生代币的余额（预判）\r\n    function getCashAfter(address underlying, uint256 transferInAmount)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return getCashPrior(underlying).add(transferInAmount);\r\n    }\r\n\r\n    function mintCheck(address underlying, address minter, uint256 amount) external {\r\n        require(\r\n            markets[IFToken(msg.sender).underlying()].isValid,\r\n            \"MintCheck fails\"\r\n        );\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        require(!tokenConfigs[underlying].depositDisabled, \"deposit disabled\");\r\n\r\n        uint supplyCap = supplyCaps[underlying];\r\n        // Supply cap of 0 corresponds to unlimited supplying\r\n        if (supplyCap != 0) {\r\n            uint totalSupply = IFToken(msg.sender).totalSupply();\r\n            uint _exchangeRate = IFToken(msg.sender).exchangeRateStored();\r\n            // 兑换率乘总发行ftoken数量，得到原生token数量\r\n            uint256 totalUnderlyingSupply = mulScalarTruncate(_exchangeRate, totalSupply);\r\n            uint nextTotalUnderlyingSupply = totalUnderlyingSupply.add(amount);\r\n            require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\r\n        }\r\n\r\n        if (!markets[underlying].accountsIn[minter]) {\r\n            userEnterMarket(IFToken(getFTokeAddress(underlying)), minter);\r\n        }\r\n    }\r\n\r\n    function borrowCheck(\r\n        address account,\r\n        address underlying,\r\n        address fToken,\r\n        uint256 borrowAmount\r\n    ) external {\r\n        address underlying = IFToken(msg.sender).underlying();\r\n        require(\r\n            markets[underlying].isValid,\r\n            \"BorrowCheck fails\"\r\n        );\r\n        require(!tokenConfigs[underlying].borrowDisabled, \"borrow disabled\");\r\n\r\n        uint borrowCap = borrowCaps[underlying];\r\n        // Borrow cap of 0 corresponds to unlimited borrowing\r\n        if (borrowCap != 0) {\r\n            uint totalBorrows = IFToken(msg.sender).totalBorrows();\r\n            uint nextTotalBorrows = totalBorrows.add(borrowAmount);\r\n            require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\r\n        }\r\n\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        (, bool valid) = fetchAssetPrice(underlying);\r\n        require(valid, \"Price is not valid\");\r\n        if (!markets[underlying].accountsIn[account]) {\r\n            userEnterMarket(IFToken(getFTokeAddress(underlying)), account);\r\n        }\r\n        // 校验用户流动性，liquidity\r\n        (uint256 sumCollaterals, uint256 sumBorrows) = getUserLiquidity(\r\n            account,\r\n            IFToken(fToken),\r\n            0,\r\n            borrowAmount\r\n        );\r\n        require(sumBorrows > 0, \"borrow value too low\");\r\n        require(sumCollaterals >= sumBorrows, \"insufficient liquidity\");\r\n    }\r\n\r\n    function repayCheck(address underlying) external view {\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n        require(!tokenConfigs[underlying].repayDisabled, \"repay disabled\");\r\n    }\r\n\r\n    // 获取用户总体的存款和借款情况\r\n    function getTotalDepositAndBorrow(address account)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return getUserLiquidity(account, IFToken(0), 0, 0);\r\n    }\r\n\r\n    // 获取账户流动性\r\n    function getAccountLiquidity(address account)\r\n        public\r\n        view\r\n        returns (uint256 liquidity, uint256 shortfall)\r\n    {\r\n        (uint256 sumCollaterals, uint256 sumBorrows) = getUserLiquidity(\r\n            account,\r\n            IFToken(0),\r\n            0,\r\n            0\r\n        );\r\n        // These are safe, as the underflow condition is checked first\r\n        if (sumCollaterals > sumBorrows) {\r\n            return (sumCollaterals - sumBorrows, 0);\r\n        } else {\r\n            return (0, sumBorrows - sumCollaterals);\r\n        }\r\n    }\r\n\r\n    // 不包含FToken的流动性\r\n    function getAccountLiquidityExcludeDeposit(address account, address token)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        IFToken fToken = IFToken(getFTokeAddress(token));\r\n        (uint256 sumCollaterals, uint256 sumBorrows) = getUserLiquidity(\r\n            account,\r\n            fToken,\r\n            fToken.balanceOf(account), //用户的fToken数量\r\n            0\r\n        );\r\n\r\n        // These are safe, as the underflow condition is checked first\r\n        if (sumCollaterals > sumBorrows) {\r\n            return (sumCollaterals - sumBorrows, 0);\r\n        } else {\r\n            return (0, sumBorrows - sumCollaterals);\r\n        }\r\n    }\r\n\r\n    // Get price of oracle\r\n    function fetchAssetPrice(address token)\r\n        public\r\n        view\r\n        returns (uint256, bool)\r\n    {\r\n        require(address(oracle) != address(0), \"oracle not set\");\r\n        return oracle.get(token);\r\n    }\r\n\r\n    function setOracle(address _oracle) external onlyAdmin {\r\n        oracle = IOracle(_oracle);\r\n    }\r\n\r\n    function _supportMarket(\r\n        IFToken fToken,\r\n        uint256 _collateralAbility,\r\n        uint256 _liquidationIncentive\r\n    ) public onlyAdmin {\r\n        address underlying = fToken.underlying();\r\n\r\n        require(!markets[underlying].isValid, \"martket existed\");\r\n\r\n        markets[underlying] = Market({\r\n            isValid: true,\r\n            collateralAbility: _collateralAbility,\r\n            fTokenAddress: address(fToken),\r\n            liquidationIncentive: _liquidationIncentive\r\n        });\r\n\r\n        addTokenToMarket(underlying, address(fToken));\r\n    }\r\n\r\n    function addTokenToMarket(address underlying, address fToken) internal {\r\n        for (uint256 i = 0; i < allUnderlyingMarkets.length; i++) {\r\n            require(\r\n                allUnderlyingMarkets[i] != underlying,\r\n                \"token exists\"\r\n            );\r\n            require(allMarkets[i] != IFToken(fToken), \"token exists\");\r\n        }\r\n        allMarkets.push(IFToken(fToken));\r\n        allUnderlyingMarkets.push(underlying);\r\n\r\n        emit AddTokenToMarket(underlying, fToken);\r\n    }\r\n\r\n    function _setCollateralAbility(\r\n        address underlying,\r\n        uint256 newCollateralAbility\r\n    ) external onlyAdmin {\r\n        require(markets[underlying].isValid, \"Market not valid\");\r\n\r\n        Market storage market = markets[underlying];\r\n\r\n        market.collateralAbility = newCollateralAbility;\r\n    }\r\n\r\n    function setCloseFactor(uint256 _closeFactor) external onlyAdmin {\r\n        closeFactor = _closeFactor;\r\n    }\r\n\r\n    // 设置某币种的交易状态，禁止存借取还，清算和转账。\r\n    function setMarketIsValid(address underlying, bool isValid) external onlyAdmin {\r\n        Market storage market = markets[underlying];\r\n        market.isValid = isValid;\r\n    }\r\n\r\n    /**\r\n     * @notice Return all of the markets\r\n     * @dev The automatic getter may be used to access an individual market.\r\n     * @return The list of market addresses\r\n     */\r\n    function getAllMarkets() external view returns (IFToken[] memory) {\r\n        return allMarkets;\r\n    }\r\n\r\n    function seizeCheck(address cTokenCollateral, address cTokenBorrowed)\r\n        external\r\n        view\r\n        onlyFToken(msg.sender)\r\n    {\r\n        require(\r\n            markets[IFToken(cTokenCollateral).underlying()].isValid &&\r\n                markets[IFToken(cTokenBorrowed).underlying()].isValid,\r\n            \"Seize market not valid\"\r\n        );\r\n    }\r\n\r\n    struct LiquidityLocals {\r\n        uint256 sumCollateral;\r\n        uint256 sumBorrows;\r\n        uint256 fTokenBalance;\r\n        uint256 borrowBalance;\r\n        uint256 exchangeRate;\r\n        uint256 oraclePrice;\r\n        uint256 collateralAbility;\r\n        uint256 collateral;\r\n    }\r\n\r\n    function getUserLiquidity(\r\n        address account,\r\n        IFToken fTokenNow,\r\n        uint256 withdrawTokens,\r\n        uint256 borrowAmount\r\n    ) public view returns (uint256, uint256) {\r\n        // 用户参与的每个币种\r\n        IFToken[] memory assets = accountAssets[account];\r\n        LiquidityLocals memory vars;\r\n        // 对于每个币种\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            IFToken asset = assets[i];\r\n            // 获取 fToken 的余额和兑换率\r\n            (vars.fTokenBalance, vars.borrowBalance, vars.exchangeRate) = asset\r\n                .getAccountState(account);\r\n            // 该币种的质押率\r\n            vars.collateralAbility = markets[asset.underlying()]\r\n                .collateralAbility;\r\n            // 获取币种价格\r\n            (uint256 oraclePrice, bool valid) = fetchAssetPrice(\r\n                asset.underlying()\r\n            );\r\n            require(valid, \"Price is not valid\");\r\n            vars.oraclePrice = oraclePrice;\r\n\r\n            uint256 fixUnit = calcExchangeUnit(address(asset));\r\n            uint256 exchangeRateFixed = mulScalar(vars.exchangeRate, fixUnit);\r\n\r\n            vars.collateral = mulExp3(\r\n                vars.collateralAbility,\r\n                exchangeRateFixed,\r\n                vars.oraclePrice\r\n            );\r\n\r\n            vars.sumCollateral = mulScalarTruncateAddUInt(\r\n                vars.collateral,\r\n                vars.fTokenBalance,\r\n                vars.sumCollateral\r\n            );\r\n\r\n            vars.borrowBalance = vars.borrowBalance.mul(fixUnit);\r\n\r\n            vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                vars.oraclePrice,\r\n                vars.borrowBalance,\r\n                vars.sumBorrows\r\n            );\r\n\r\n            // 借款和取款的时候，将当前要操作的数量，直接计算在账户流动性里面\r\n            if (asset == fTokenNow) {\r\n                // 取款\r\n                vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                    vars.collateral,\r\n                    withdrawTokens,\r\n                    vars.sumBorrows\r\n                );\r\n\r\n                borrowAmount = borrowAmount.mul(fixUnit);\r\n\r\n                // 借款\r\n                vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                    vars.oraclePrice,\r\n                    borrowAmount,\r\n                    vars.sumBorrows\r\n                );\r\n            }\r\n        }\r\n\r\n        return (vars.sumCollateral, vars.sumBorrows);\r\n    }\r\n\r\n    //不包含某一token的流动性\r\n    function getUserLiquidityExcludeToken(\r\n        address account,\r\n        IFToken excludeToken,\r\n        IFToken fTokenNow,\r\n        uint256 withdrawTokens,\r\n        uint256 borrowAmount\r\n    ) external view returns (uint256, uint256) {\r\n        // 用户参与的每个币种\r\n        IFToken[] memory assets = accountAssets[account];\r\n        LiquidityLocals memory vars;\r\n        // 对于每个币种\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            IFToken asset = assets[i];\r\n\r\n            //不包含token\r\n            if (address(asset) == address(excludeToken)) {\r\n                continue;\r\n            }\r\n\r\n            // 获取 fToken 的余额和兑换率\r\n            (vars.fTokenBalance, vars.borrowBalance, vars.exchangeRate) = asset\r\n                .getAccountState(account);\r\n            // 该币种的质押率\r\n            vars.collateralAbility = markets[asset.underlying()]\r\n                .collateralAbility;\r\n            // 获取币种价格\r\n            (uint256 oraclePrice, bool valid) = fetchAssetPrice(\r\n                asset.underlying()\r\n            );\r\n            require(valid, \"Price is not valid\");\r\n            vars.oraclePrice = oraclePrice;\r\n\r\n            uint256 fixUnit = calcExchangeUnit(address(asset));\r\n            uint256 exchangeRateFixed = mulScalar(\r\n                vars.exchangeRate,\r\n                fixUnit\r\n            );\r\n\r\n            vars.collateral = mulExp3(\r\n                vars.collateralAbility,\r\n                exchangeRateFixed,\r\n                vars.oraclePrice\r\n            );\r\n\r\n            vars.sumCollateral = mulScalarTruncateAddUInt(\r\n                vars.collateral,\r\n                vars.fTokenBalance,\r\n                vars.sumCollateral\r\n            );\r\n\r\n            vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                vars.oraclePrice,\r\n                vars.borrowBalance,\r\n                vars.sumBorrows\r\n            );\r\n\r\n            // 借款和取款的时候，将当前要操作的数量，直接计算在账户流动性里面\r\n            if (asset == fTokenNow) {\r\n                // 取款\r\n                vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                    vars.collateral,\r\n                    withdrawTokens,\r\n                    vars.sumBorrows\r\n                );\r\n\r\n                borrowAmount = borrowAmount.mul(fixUnit);\r\n\r\n                // 借款\r\n                vars.sumBorrows = mulScalarTruncateAddUInt(\r\n                    vars.oraclePrice,\r\n                    borrowAmount,\r\n                    vars.sumBorrows\r\n                );\r\n            }\r\n        }\r\n\r\n        return (vars.sumCollateral, vars.sumBorrows);\r\n    }\r\n\r\n    function tokenDecimals(address token) public view returns (uint256) {\r\n        return\r\n            token == EthAddressLib.ethAddress()\r\n                ? 18\r\n                : uint256(IERC20(token).decimals());\r\n    }\r\n\r\n    //计算user的取款指定token的最大数量\r\n    function calcMaxWithdrawAmount(address user, address token)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 depoistValue, uint256 borrowValue) = getTotalDepositAndBorrow(\r\n            user\r\n        );\r\n        if (depoistValue <= borrowValue) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 netValue = subExp(depoistValue, borrowValue);\r\n        // redeemValue = netValue / collateralAblility;\r\n        uint256 redeemValue = divExp(\r\n            netValue,\r\n            markets[token].collateralAbility\r\n        );\r\n\r\n        (uint256 oraclePrice, bool valid) = fetchAssetPrice(token);\r\n        require(valid, \"Price is not valid\");\r\n\r\n        uint fixUnit = 10 ** SafeMath.abs(18, tokenDecimals(token));\r\n        uint256 redeemAmount = divExp(redeemValue, oraclePrice).div(fixUnit);\r\n        IFToken fToken = IFToken(getFTokeAddress(token));\r\n\r\n        redeemAmount = SafeMath.min(\r\n            redeemAmount,\r\n            fToken.calcBalanceOfUnderlying(user)\r\n        );\r\n        return redeemAmount;\r\n    }\r\n\r\n    function calcMaxBorrowAmount(address user, address token)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (\r\n            uint256 depoistValue,\r\n            uint256 borrowValue\r\n        ) = getAccountLiquidityExcludeDeposit(user, token);\r\n        if (depoistValue <= borrowValue) {\r\n            return 0;\r\n        }\r\n        uint256 netValue = subExp(depoistValue, borrowValue);\r\n        (uint256 oraclePrice, bool valid) = fetchAssetPrice(token);\r\n        require(valid, \"Price is not valid\");\r\n\r\n        uint fixUnit = 10 ** SafeMath.abs(18, tokenDecimals(token));\r\n        uint256 borrowAmount = divExp(netValue, oraclePrice).div(fixUnit);\r\n\r\n        return borrowAmount;\r\n    }\r\n\r\n    function calcMaxBorrowAmountWithRatio(address user, address token)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IFToken fToken = IFToken(getFTokeAddress(token));\r\n\r\n        return\r\n            SafeMath.mul(calcMaxBorrowAmount(user, token), 1e18).div(fToken.borrowSafeRatio());\r\n    }\r\n\r\n    function calcMaxCashOutAmount(address user, address token)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            addExp(\r\n                calcMaxWithdrawAmount(user, token),\r\n                calcMaxBorrowAmountWithRatio(user, token)\r\n            );\r\n    }\r\n\r\n    function isFTokenValid(address fToken) external view returns (bool) {\r\n        return markets[IFToken(fToken).underlying()].isValid;\r\n    }\r\n\r\n    function liquidateBorrowCheck(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        address borrower,\r\n        address liquidator,\r\n        uint256 repayAmount\r\n    ) external onlyFToken(msg.sender) {\r\n        address underlyingBorrowed = IFToken(fTokenBorrowed).underlying();\r\n        address underlyingCollateral = IFToken(fTokenCollateral).underlying();\r\n        require(!tokenConfigs[underlyingBorrowed].liquidateBorrowDisabled, \"liquidateBorrow: liquidate borrow disabled\");\r\n        require(!tokenConfigs[underlyingCollateral].liquidateBorrowDisabled, \"liquidateBorrow: liquidate colleteral disabled\");\r\n\r\n        (, uint256 shortfall) = getAccountLiquidity(borrower);\r\n        require(shortfall != 0, \"Insufficient shortfall\");\r\n        userEnterMarket(IFToken(fTokenCollateral), liquidator);\r\n\r\n        uint256 borrowBalance = IFToken(fTokenBorrowed).borrowBalanceStored(\r\n            borrower\r\n        );\r\n        uint256 maxClose = mulScalarTruncate(closeFactor, borrowBalance);\r\n        require(repayAmount <= maxClose, \"Too much repay\");\r\n    }\r\n\r\n    function calcExchangeUnit(address fToken) public view returns (uint256) {\r\n        uint256 fTokenDecimals = uint256(IFToken(fToken).decimals());\r\n        uint256 underlyingDecimals = IFToken(fToken).underlying() ==\r\n            EthAddressLib.ethAddress()\r\n            ? 18\r\n            : uint256(IERC20(IFToken(fToken).underlying()).decimals());\r\n\r\n        return 10**SafeMath.abs(fTokenDecimals, underlyingDecimals);\r\n    }\r\n\r\n    function liquidateTokens(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        uint256 actualRepayAmount\r\n    ) external view returns (uint256) {\r\n        (uint256 borrowPrice, bool borrowValid) = fetchAssetPrice(\r\n            IFToken(fTokenBorrowed).underlying()\r\n        );\r\n        (uint256 collateralPrice, bool collateralValid) = fetchAssetPrice(\r\n            IFToken(fTokenCollateral).underlying()\r\n        );\r\n        require(borrowValid && collateralValid, \"Price not valid\");\r\n\r\n        /*\r\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\r\n         *  seizeTokens = seizeAmount / exchangeRate\r\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\r\n         */\r\n        uint256 exchangeRate = IFToken(fTokenCollateral).exchangeRateStored();\r\n\r\n        uint256 fixCollateralUnit = calcExchangeUnit(fTokenCollateral);\r\n        uint256 fixBorrowlUnit = calcExchangeUnit(fTokenBorrowed);\r\n\r\n        uint256 numerator = mulExp(\r\n            markets[IFToken(fTokenCollateral).underlying()]\r\n                .liquidationIncentive,\r\n            borrowPrice\r\n        );\r\n        exchangeRate = exchangeRate.mul(fixCollateralUnit);\r\n\r\n        actualRepayAmount = actualRepayAmount.mul(fixBorrowlUnit);\r\n\r\n        uint256 denominator = mulExp(collateralPrice, exchangeRate);\r\n        uint256 seizeTokens = mulScalarTruncate(\r\n            divExp(numerator, denominator),\r\n            actualRepayAmount\r\n        );\r\n\r\n        return seizeTokens;\r\n    }\r\n\r\n    function _setLiquidationIncentive(\r\n        address underlying,\r\n        uint256 _liquidationIncentive\r\n    ) public onlyAdmin {\r\n        markets[underlying].liquidationIncentive = _liquidationIncentive;\r\n    }\r\n\r\n    struct ReserveWithdrawalLogStruct {\r\n        address token_address;\r\n        uint256 reserve_withdrawed;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function reduceReserves(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 reduceAmount\r\n    ) public onlyMulSig {\r\n        IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n        fToken._reduceReserves(reduceAmount);\r\n        transferToUserInternal(underlying, account, reduceAmount);\r\n        fToken.subTotalCash(reduceAmount);\r\n\r\n        ReserveWithdrawalLogStruct memory rds = ReserveWithdrawalLogStruct(\r\n            underlying,\r\n            reduceAmount,\r\n            fToken.exchangeRateStored(),\r\n            fToken.getBorrowRate(),\r\n            fToken.tokenCash(underlying, address(this))\r\n        );\r\n\r\n        IBank(bankEntryAddress).MonitorEventCallback(\r\n            \"ReserveWithdrawal\",\r\n            abi.encode(rds)\r\n        );\r\n    }\r\n\r\n    function batchReduceReserves(\r\n        address[] calldata underlyings,\r\n        address payable account,\r\n        uint256[] calldata reduceAmounts\r\n    ) external onlyMulSig {\r\n        require(underlyings.length == reduceAmounts.length, \"length not match\");\r\n        uint256 n = underlyings.length;\r\n        for (uint256 i = 0; i < n; i++) {\r\n            reduceReserves(underlyings[i], account, reduceAmounts[i]);\r\n        }\r\n    }\r\n\r\n    function batchReduceAllReserves(\r\n        address[] calldata underlyings,\r\n        address payable account\r\n    ) external onlyMulSig {\r\n        uint256 n = underlyings.length;\r\n        for (uint i = 0; i < n; i++) {\r\n            IFToken fToken = IFToken(getFTokeAddress(underlyings[i]));\r\n            uint256 amount = SafeMath.min(fToken.totalReserves(), fToken.tokenCash(underlyings[i], address(this)));\r\n            if (amount > 0) {\r\n                reduceReserves(underlyings[i], account, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function batchReduceAllReserves(\r\n        address payable account\r\n    ) external onlyMulSig {\r\n        uint256 n = allUnderlyingMarkets.length;\r\n        for (uint i = 0; i < n; i++) {\r\n            address underlying = allUnderlyingMarkets[i];\r\n            IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n            uint256 amount = SafeMath.min(fToken.totalReserves(), fToken.tokenCash(underlying, address(this)));\r\n            if (amount > 0) {\r\n                reduceReserves(underlying, account, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    struct ReserveDepositLogStruct {\r\n        address token_address;\r\n        uint256 reserve_funded;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function addReserves(address underlying, uint256 addAmount)\r\n        external\r\n        payable\r\n    {\r\n        IFToken fToken = IFToken(getFTokeAddress(underlying));\r\n        fToken._addReservesFresh(addAmount);\r\n        transferIn(msg.sender, underlying, addAmount);\r\n        fToken.addTotalCash(addAmount);\r\n\r\n        ReserveDepositLogStruct memory rds = ReserveDepositLogStruct(\r\n            underlying,\r\n            addAmount,\r\n            fToken.exchangeRateStored(),\r\n            fToken.getBorrowRate(),\r\n            fToken.tokenCash(underlying, address(this))\r\n        );\r\n\r\n        IBank(bankEntryAddress).MonitorEventCallback(\r\n            \"ReserveDeposit\",\r\n            abi.encode(rds)\r\n        );\r\n    }\r\n}"}}}