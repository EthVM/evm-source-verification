{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"vesting.sol":{"content":"pragma solidity 0.6.11;\n// SPDX-License-Identifier: BSD-3-Clause\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n    address public pendingOwner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner());\n        _;\n    }\n    \n    /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyPendingOwner() {\n        assert(msg.sender != address(0));\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        pendingOwner = _newOwner;\n    }\n  \n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() onlyPendingOwner public {\n        _transferOwnership(pendingOwner);\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface Token {\n    function transfer(address, uint) external returns (bool);\n}\n\ninterface LegacyToken {\n    function transfer(address, uint) external;\n}\n\ncontract TokenLock is Ownable {\n    using SafeMath for uint;\n    \n    // unix unlock\n    uint public unlockTime;\n    // max extension allowed - prevents owner from extending indefinitely by mistake\n    uint public constant MAX_EXTENSION_ALLOWED = 30 days;\n    \n    constructor(uint initialUnlockTime) public {\n        require(initialUnlockTime > now, \"Cannot set an unlock time in past!\");\n        unlockTime = initialUnlockTime;\n    }\n    \n    function isUnlocked() public view returns (bool) {\n        return now > unlockTime;\n    }\n    \n    function extendLock(uint extendedUnlockTimestamp) external onlyOwner {\n        require(extendedUnlockTimestamp > now && extendedUnlockTimestamp > unlockTime , \"Cannot set an unlock time in past!\");\n        require(extendedUnlockTimestamp.sub(now) <= MAX_EXTENSION_ALLOWED, \"Cannot extend beyond MAX_EXTENSION_ALLOWED period!\");\n        unlockTime = extendedUnlockTimestamp;\n    }\n    \n    function claim(address tokenAddress, address recipient, uint amount) external onlyOwner {\n        require(isUnlocked(), \"Not Unlocked Yet!\");\n        require(Token(tokenAddress).transfer(recipient, amount), \"Transfer Failed!\");\n    }\n\n    function claimLegacyToken(address tokenAddress, address recipient, uint amount) external onlyOwner {\n        require(isUnlocked(), \"Not Unlocked Yet!\");\n        LegacyToken(tokenAddress).transfer(recipient, amount);\n    }\n}"}}}