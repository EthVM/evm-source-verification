{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GamingChickNest.sol":{"content":"// File: @openzeppelin\\contracts\\utils\\Strings.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts\\OwnableContract.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract OwnableContract {\r\n    address public owner;\r\n    address public pendingOwner;\r\n    address public admin;\r\n    address public dev;\r\n\r\n    event NewAdmin(address oldAdmin, address newAdmin);\r\n    event NewDev(address oldDev, address newDev);\r\n    event NewOwner(address oldOwner, address newOwner);\r\n    event NewPendingOwner(address oldPendingOwner, address newPendingOwner);\r\n\r\n    constructor(){\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n        dev   = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPendingOwner {\r\n        require(msg.sender == pendingOwner,\"onlyPendingOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin || msg.sender == owner,\"onlyAdmin\");\r\n        _;\r\n    } \r\n\r\n    modifier onlyDev {\r\n        require(msg.sender == dev  || msg.sender == owner,\"onlyDev\");\r\n        _;\r\n    } \r\n    \r\n    function transferOwnership(address _pendingOwner) public onlyOwner {\r\n        emit NewPendingOwner(pendingOwner, _pendingOwner);\r\n        pendingOwner = _pendingOwner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit NewOwner(owner, address(0));\r\n        emit NewAdmin(admin, address(0));\r\n        emit NewPendingOwner(pendingOwner, address(0));\r\n\r\n        owner = address(0);\r\n        pendingOwner = address(0);\r\n        admin = address(0);\r\n    }\r\n    \r\n    function acceptOwner() public onlyPendingOwner {\r\n        emit NewOwner(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n\r\n        address newPendingOwner = address(0);\r\n        emit NewPendingOwner(pendingOwner, newPendingOwner);\r\n        pendingOwner = newPendingOwner;\r\n    }    \r\n    \r\n    function setAdmin(address newAdmin) public onlyOwner {\r\n        emit NewAdmin(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function setDev(address newDev) public onlyOwner {\r\n        emit NewDev(dev, newDev);\r\n        dev = newDev;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts\\GamingChickNest.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface HeadPortrait721Interface{\r\n\r\n    struct Attribute{\r\n        uint32 background;\r\n        uint32 skinColor;\r\n        uint32 clothes;\r\n        uint32 hatBack;\r\n        uint32 beak;\r\n        uint32 hatFront;\r\n        uint32 eyes;\r\n        uint32 front;\r\n        uint256 reserve;\r\n    }\r\n    \r\n    function mint(address user, uint256 tokenId, Attribute memory attribute) external;\r\n}\r\n\r\ncontract GamingChickNest is OwnableContract{\r\n\r\n    using Strings for uint256;\r\n\r\n    address public headPortrait721;\r\n\r\n    address public signer1;\r\n    address public signer2;\r\n\r\n    uint16 public tokenId = 1001;\r\n    \r\n    uint256 public aleadyClaimCount = 0;\r\n    uint256 public maxClaimCount = 20;\r\n\r\n    bool public isUseTokenIdRandom = true;\r\n\r\n    uint256[] public clothes;\r\n\r\n    mapping(uint256 => bool) public claimedOrderId;\r\n\r\n    mapping(uint256 => uint256) public categoryToNumberMap;\r\n\r\n    event Claim(uint256 orderId, uint256 tokenId, address user);\r\n    event AleadyClaim(uint256 orderId, uint256 tokenId, address user);\r\n\r\n    constructor(address _headPortrait721){\r\n        headPortrait721 = _headPortrait721;\r\n        signer1 = address(0xd5F6cfca09240650Af7c4E46E7337cDA495fDfd7);\r\n        signer2 = signer1;\r\n        categoryToNumberMap[2] = 5;\r\n        categoryToNumberMap[7] = 5;\r\n        categoryToNumberMap[4] = 5;\r\n    }\r\n\r\n    function updateMaxClaimCount(uint256 _maxClaimCount) public onlyAdmin{\r\n        maxClaimCount = _maxClaimCount;\r\n    }\r\n\r\n    function updateCategoryToNumberMap(uint256 _type, uint256 number) public onlyAdmin{\r\n        categoryToNumberMap[_type] = number;\r\n    }\r\n\r\n    function initClothes(uint256[] memory _clothes) public onlyAdmin{\r\n        clothes = _clothes;\r\n    }\r\n\r\n    function updateClothes(uint256 _clothes) public onlyAdmin{\r\n        clothes.push(_clothes);\r\n    }\r\n\r\n    function updateIsUseTokenIdRandom(bool _isUseTokenIdRandom) public onlyAdmin{\r\n        isUseTokenIdRandom = _isUseTokenIdRandom;\r\n    }\r\n\r\n    function setSigner1(address _signer) public onlyOwner{\r\n        signer1 = _signer;\r\n    }\r\n\r\n    function setSigner2(address _signer) public onlyOwner{\r\n        signer2 = _signer;\r\n    }\r\n\r\n    function updateHeadPortrait721(address _headPortrait721) public onlyAdmin{\r\n        headPortrait721 = _headPortrait721;\r\n    }\r\n\r\n    function getOrderIdIsClaim(uint256[] memory orderId) public view returns(uint256[] memory){\r\n        uint256[] memory unconfirmedOrderId = new uint256[](orderId.length);\r\n        uint256 count = 0;\r\n        for(uint256 i=0; i<orderId.length; i++){\r\n            if(!claimedOrderId[orderId[i]]){\r\n                unconfirmedOrderId[count] = orderId[i];\r\n                count++;\r\n            }\r\n        }\r\n        return unconfirmedOrderId;\r\n    }\r\n\r\n    function batchClaim(uint256[] memory orderId, uint256[] memory tokenIds, bytes[] memory signature) public{\r\n        require(aleadyClaimCount + orderId.length <= maxClaimCount, \"Maximum claims exceeded.\");\r\n        require(orderId.length == tokenIds.length, \"orderId length should eq floatAmount length\");\r\n        require(orderId.length == signature.length, \"orderId length should eq signature length\");\r\n        for(uint256 i=0; i<orderId.length; i++){\r\n            claim(orderId[i], tokenIds[i], signature[i]);\r\n        }\r\n    }\r\n\r\n    function claim(uint256 orderId, uint256 _tokenId, bytes memory signature) internal{\r\n        if(claimedOrderId[orderId]){\r\n            emit AleadyClaim(orderId, tokenId, msg.sender);\r\n            return;\r\n        }\r\n    \r\n        bytes32 hash1 = keccak256(abi.encode(address(this), msg.sender, orderId, _tokenId));\r\n\r\n        bytes32 hash2 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash1));\r\n\r\n        address _signer = recover(hash2, signature);\r\n        require(_signer == signer1 || _signer == signer2, \"invalid signer\");\r\n\r\n        uint256 nftTokenId;\r\n        if(_tokenId == 0){\r\n            nftTokenId = tokenId;\r\n            tokenId++;\r\n        }else{\r\n            require(0 < _tokenId && _tokenId <= 1000, \"_tokenId is error.\");\r\n            nftTokenId = _tokenId;\r\n        }\r\n\r\n        HeadPortrait721Interface.Attribute memory attribute = getAttributes(nftTokenId);\r\n        HeadPortrait721Interface headPortrait721Interface = HeadPortrait721Interface(headPortrait721);\r\n        headPortrait721Interface.mint(msg.sender, nftTokenId, attribute);\r\n\r\n        claimedOrderId[orderId] = true;\r\n\r\n        emit Claim(orderId, nftTokenId, msg.sender);\r\n\r\n        aleadyClaimCount++;\r\n    }\r\n\r\n    function claimOfAdmin(address user, uint256 _tokenId) public onlyAdmin{\r\n        require(_tokenId <= 1000, \"_tokenId is error.\");\r\n        HeadPortrait721Interface.Attribute memory attribute = getAttributes(_tokenId);\r\n        HeadPortrait721Interface headPortrait721Interface = HeadPortrait721Interface(headPortrait721);\r\n        headPortrait721Interface.mint(user, _tokenId, attribute);\r\n\r\n        emit Claim(0, tokenId, user);\r\n    }\r\n\r\n    // Clothes = Body、Head = SkinColor\r\n    // 7 - Front\r\n    // 6 - Eyes\r\n    // 5 - Hat Front\r\n    // 4 - Beak\r\n    // 3 - SkinColor\r\n    // 2 - Hat Back\r\n    // 1 - Clothes 1011400\r\n    // 0 - Background\r\n    // 001、1011400、2011000、3010400、4011400、5011000、6010400\r\n    function getAttributes(uint256 _tokenId) public view returns(HeadPortrait721Interface.Attribute memory attribute){\r\n        uint256 random = getRandom(_tokenId);\r\n        uint256 _background = random % 1000;\r\n        if(_background < 10){\r\n            attribute.background = 7;\r\n        }else if(_background < 60){\r\n            attribute.background = 5;\r\n        }else if(_background < 160){\r\n            attribute.background = 3;\r\n        }else if(_background < 310){\r\n            attribute.background = 4;\r\n        }else if(_background < 540){\r\n            attribute.background = 6;\r\n        }else if(_background < 770){\r\n            attribute.background = 1;\r\n        }else if(_background < 1000){\r\n            attribute.background = 2;\r\n        }\r\n\r\n        uint256 random1 = uint256(keccak256(abi.encode(random, 1)));\r\n        uint256 clothesIndex = random1 % clothes.length;\r\n        uint32 _clothes = uint32(clothes[clothesIndex]);\r\n        attribute.clothes = _clothes;\r\n\r\n        // 1113501\r\n        uint32 one = _clothes % 10;                 // 1\r\n        uint32 three = _clothes / 100 % 10;         // 5\r\n        uint32 four = _clothes / 1000 % 10;         // 3\r\n\r\n        attribute.skinColor = 301 * 10000 + three * 100;\r\n        if(four != 0){\r\n            if(one == 0){\r\n                attribute.hatBack = 201 * 10000 + four * 1000;\r\n                attribute.hatFront = 501 * 10000 + four * 1000;\r\n            }else{\r\n                attribute.front = 701 * 10000 + four * 1000;\r\n            }\r\n            attribute.beak = 401 * 10000 + four * 1000 + three * 100;\r\n        }else{\r\n            if(one == 0){\r\n                uint256 random2 = uint256(keccak256(abi.encode(random, 2)));\r\n                uint32 hatBackIndex = uint32(random2 % categoryToNumberMap[2] + 1);\r\n                attribute.hatBack = 201 * 10000 + hatBackIndex * 1000;\r\n                attribute.hatFront = 501 * 10000 + hatBackIndex * 1000;\r\n            }else{\r\n                uint256 random3 = uint256(keccak256(abi.encode(random, 3)));\r\n                uint32 frontIndex = uint32(random3 % categoryToNumberMap[7] + 1);\r\n                attribute.front = 701 * 10000 + frontIndex * 1000;\r\n            }\r\n            uint256 random4 = uint256(keccak256(abi.encode(random, 4)));\r\n            uint32 beakIndex = uint32(random4 % categoryToNumberMap[4] + 1);\r\n            attribute.beak = 401 * 10000 + beakIndex * 1000 + three * 100;\r\n        }\r\n        attribute.eyes = 6010 * 1000 + three * 100;\r\n    }\r\n\r\n    function getRandom(uint256 _tokenId) public view returns(uint256){\r\n        uint256 random;\r\n        if(isUseTokenIdRandom){\r\n            random = uint256(keccak256(abi.encodePacked(_tokenId)));\r\n        }else{\r\n            random = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.coinbase))) + block.timestamp + _tokenId;\r\n        }\r\n        return random;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n}"}}}