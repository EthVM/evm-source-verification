{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "NonFungibleCEO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Author: 0xTycoon\r\n// Repo: github.com/0xTycoon/punksceo\r\n\r\npragma solidity ^0.8.11;\r\n\r\n//import \"./safemath.sol\"; // don't need it\r\n\r\n/**\r\n* \"Non fungible CEO\"\r\n* This is a NFT that gets transferred to the address that hold the CEO title.\r\n* Think of it as a \"title belt\" in boxing.\r\n* The purpose is so that the NFT will show up in CEOs gallery, so that everyone will be able to see it!\r\n*\r\n* Properties:\r\n* - There is only 1 NFT, NFT ID is 0\r\n* - Only the CIG token contract has permission to transfer it\r\n* - Admin key only used for deployment\r\n*\r\n*/\r\ncontract NonFungibleCEO {\r\n    ICigToken private cigToken;\r\n    address public owner;\r\n    string private metadataURI;\r\n\r\n    constructor(string memory _uri) {\r\n        metadataURI = _uri;\r\n        emit BaseURI(_uri);\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"only admin can call this\"\r\n        );\r\n        _;\r\n    }\r\n    /**\r\n    * @dev onlyCig ensures only the cig token contract can use it\r\n    */\r\n    modifier onlyCig {\r\n        require(address(cigToken) == msg.sender, 'must be called from cigtoken');\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev onlyCEO ensures that only the CEO can use it\r\n    */\r\n    modifier onlyCEO {\r\n        require(cigToken.The_CEO() == msg.sender, 'must be called by CEO');\r\n        _;\r\n    }\r\n\r\n    function baseTokenURI() public view returns (string memory) {\r\n        return metadataURI;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev renounceOwnership burns the admin key\r\n    */\r\n    function renounceOwnership() external onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external  onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n    /**\r\n    * @dev setCigToken sets the address to the cig token\r\n    * @param _addr address to the cig token\r\n    */\r\n    function setCigToken(address _addr) external onlyOwner {\r\n        cigToken = ICigToken(_addr);\r\n    }\r\n\r\n    /***\r\n    * ERC721 stuff\r\n    */\r\n    address private holder; // the NFT owner\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event BaseURI(string);\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    function totalSupply() external pure returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external pure returns (uint256) {\r\n        if (_index == 0) {return 0; }\r\n        revert(\"404\");\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        if (_owner == holder) {\r\n            return 0;\r\n        }\r\n        revert(\"404\");\r\n    }\r\n\r\n    function balanceOf(address _holder) public view returns (uint256) {\r\n        if (_holder == holder) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return \"CEO of CryptoPunks\";\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return \"CEO\";\r\n    }\r\n\r\n    /**\r\n    * @dev setBaseURI sets the baseURI value\r\n    */\r\n    function setBaseURI(string memory _uri) external onlyCEO {\r\n        metadataURI = _uri;\r\n        emit BaseURI(_uri);\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\r\n        if (_tokenId != 0) revert(\"404\");\r\n        return string(abi.encodePacked(metadataURI, \"0.json\"));\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        if (_tokenId != 0) revert(\"404\");\r\n        return holder;\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external onlyCig {\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external onlyCig {\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external onlyCig {\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external onlyCig {\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external onlyCig {\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return address(cigToken);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public pure returns (bool) {\r\n\r\n        return false;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\r\n        return\r\n        interfaceId == type(IERC721).interfaceId ||\r\n        interfaceId == type(IERC721Metadata).interfaceId ||\r\n        interfaceId == type(IERC165).interfaceId ||\r\n        interfaceId == type(ERC721Enumerable).interfaceId ||\r\n        interfaceId == type(ERC721TokenReceiver).interfaceId;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        require(_tokenId == 0, \"404\");\r\n        holder = _to;\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external pure returns (bytes4) {\r\n        revert(\"nope\");\r\n        return bytes4(keccak256(\"nope\"));\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the\r\n    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n    /// of other than the magic value MUST result in the transaction being reverted.\r\n    /// @notice The contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\ninterface ICigToken {\r\n    function The_CEO() external  returns (address);\r\n}"
    }
  }
}