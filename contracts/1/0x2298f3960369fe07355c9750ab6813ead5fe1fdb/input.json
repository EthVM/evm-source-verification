{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LiquidityMigrator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.7.5;\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return _functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function _functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 weiValue,\r\n    string memory errorMessage\r\n  ) private returns (bytes memory) {\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n      data\r\n    );\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transfer.selector, to, value)\r\n    );\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n    );\r\n  }\r\n\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    bytes memory returndata = address(token).functionCall(\r\n      data,\r\n      \"SafeERC20: low-level call failed\"\r\n    );\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      // solhint-disable-next-line max-line-length\r\n      require(\r\n        abi.decode(returndata, (bool)),\r\n        \"SafeERC20: ERC20 operation did not succeed\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amountA,\r\n      uint256 amountB,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n}\r\n\r\ninterface ITreasury {\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _token,\r\n    uint256 _profit\r\n  ) external returns (uint256);\r\n\r\n  function withdraw(uint256 _amount, address _token) external;\r\n\r\n  function tokenValue(address _token, uint256 _amount)\r\n    external\r\n    view\r\n    returns (uint256 value_);\r\n\r\n  function mint(address _recipient, uint256 _amount) external;\r\n\r\n  function manage(address _token, uint256 _amount) external;\r\n\r\n  function incurDebt(uint256 amount_, address token_) external;\r\n\r\n  function repayDebtWithReserve(uint256 amount_, address token_) external;\r\n\r\n  function excessReserves() external view returns (uint256);\r\n\r\n  function baseSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IMigrator {\r\n  enum TYPE {\r\n    UNSTAKED,\r\n    STAKED,\r\n    WRAPPED\r\n  }\r\n\r\n  // migrate OHMv1, sOHMv1, or wsOHM for OHMv2, sOHMv2, or gOHM\r\n  function migrate(\r\n    uint256 _amount,\r\n    TYPE _from,\r\n    TYPE _to\r\n  ) external;\r\n}\r\n\r\ncontract LiquidityMigrator {\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n\r\n  address public policy;\r\n  address public leftoverRecipient;\r\n\r\n  ITreasury internal immutable treasury =\r\n    ITreasury(0x873ad91fA4F2aA0d557C0919eC3F6c9D240cDd05);\r\n\r\n  IERC20 internal immutable oldOHM =\r\n    IERC20(0x383518188C0C6d7730D91b2c03a03C837814a899);\r\n\r\n  IERC20 internal immutable newOHM =\r\n    IERC20(0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5);\r\n\r\n  IMigrator internal immutable migrator =\r\n    IMigrator(0x184f3FAd8618a6F458C16bae63F70C426fE784B3);\r\n\r\n  constructor(address _leftoverRecipient) public {\r\n    policy = msg.sender;\r\n    leftoverRecipient = _leftoverRecipient;\r\n  }\r\n\r\n  modifier onlyPolicy() {\r\n    require(msg.sender == policy, \"!policy\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Migrate LP and pair with new OHM\r\n   */\r\n  function migrateLP(\r\n    address pair,\r\n    IUniswapV2Router routerFrom,\r\n    IUniswapV2Router routerTo,\r\n    address token,\r\n    uint256 _minA,\r\n    uint256 _minB,\r\n    uint256 _deadline\r\n  ) external onlyPolicy {\r\n    // Since we are adding liquidity, any existing balance should be excluded\r\n    uint256 initialNewOHMBalance = newOHM.balanceOf(address(this));\r\n    // Fetch the treasury balance of the given liquidity pair\r\n    uint256 oldLPAmount = IERC20(pair).balanceOf(address(treasury));\r\n    treasury.manage(pair, oldLPAmount);\r\n\r\n    // Remove the V1 liquidity\r\n    IERC20(pair).approve(address(routerFrom), oldLPAmount);\r\n\r\n    (uint256 amountToken, uint256 amountOHM) = routerFrom.removeLiquidity(\r\n      token,\r\n      address(oldOHM),\r\n      oldLPAmount,\r\n      _minA,\r\n      _minB,\r\n      address(this),\r\n      _deadline\r\n    );\r\n\r\n    // Migrate the V1 OHM to V2 OHM\r\n    oldOHM.approve(address(migrator), amountOHM);\r\n    migrator.migrate(\r\n      amountOHM,\r\n      IMigrator.TYPE.UNSTAKED,\r\n      IMigrator.TYPE.UNSTAKED\r\n    );\r\n    uint256 amountNewOHM = newOHM.balanceOf(address(this)).sub(\r\n      initialNewOHMBalance\r\n    ); // # V1 out != # V2 in\r\n\r\n    // Add the V2 liquidity\r\n    IERC20(token).approve(address(routerTo), amountToken);\r\n    newOHM.approve(address(routerTo), amountNewOHM);\r\n\r\n    routerTo.addLiquidity(\r\n      token,\r\n      address(newOHM),\r\n      amountToken,\r\n      amountNewOHM,\r\n      amountToken,\r\n      amountNewOHM,\r\n      address(treasury),\r\n      _deadline\r\n    );\r\n\r\n    // Send any leftover balance to the governor\r\n    newOHM.safeTransfer(leftoverRecipient, newOHM.balanceOf(address(this)));\r\n    oldOHM.safeTransfer(leftoverRecipient, oldOHM.balanceOf(address(this)));\r\n\r\n    IERC20(token).safeTransfer(\r\n      leftoverRecipient,\r\n      IERC20(token).balanceOf(address(this))\r\n    );\r\n  }\r\n}"}}}