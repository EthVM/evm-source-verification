{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BurnBase.sol": {
      "content": "/*\r\n\r\n!!!!!!!!!!!!!!!Notice!!!!!!!!!!!!!!!!!!!!\r\nThere are scam groups copying our work. We are not affiliated with any of them. They just steal from us. Do NOT invest with them. \r\n\r\n\r\n\r\nJoin our telegram group \r\nhttps://t.me/BurnBase\r\n\r\n\r\nOnly uniswap router is whitelisted. Owner address is whitelisted to facilitate pool creation and closing. \r\n\r\n\r\nNo affiliations.\r\n\r\n\r\nShill this!\r\n\r\n\r\nWe create clean, fair, fun games and projects for us and the degen community!\r\n\r\nOur past projects did 18x, 5x, 10x, 8x, 5x. Let's get to 20x, 50x, 100x, and 1000x !!!!\r\nCheck dextools!\r\n\r\nThis is not a fork. Liquidity will be locked soon after listing.\r\n\r\nTeam share is small and team NEVER sells all tokens in one shot. Several partial sells, and yes, sometimes the team loses. \r\nThat's life, win some, lose some. We live and we learn.\r\n\r\ntwitter: tweet tweet \r\n\r\nwebsite: ????!!\r\n\r\nDYOR - Do your own research\r\n\r\nbe fast\r\n\r\ndon't be greedy\r\n\r\nDon't cry if you lose. Wait for next angel round and try to make your money back...don't forget to learn! \r\n\r\nAngel round: No team tokens. Token is a gift to the community! 100% goes to pool and Eth provided by the team.\r\nSpecial round today\r\n\r\n\r\n\r\nNot financial advice...\r\n\r\nDegen means degenerate \r\n\r\nUsecase: \r\nBuy low sell high. \r\n\r\nBrought to you by Micheal Sirianni (not indian, not African so stop asking and stop calling him pajeet).\r\nMicheal: I do NOT use a bot. The bot owners are NOT my friends. The bots are impossible to fight because they keep evolving. The bot creators are smart and they \r\nare in the group listening. They change their bots and adapt to our new plans to fight them. \r\n\r\n\r\nGood luck. \r\n*/\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n\r\n  uint8 private _Tokendecimals;\r\n  string private _Tokenname;\r\n  string private _Tokensymbol;\r\n\r\n  constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n   \r\n   _Tokendecimals = decimals;\r\n    _Tokenname = name;\r\n    _Tokensymbol = symbol;\r\n    \r\n  }\r\n\r\n  function name() public view returns(string memory) {\r\n    return _Tokenname;\r\n  }\r\n\r\n  function symbol() public view returns(string memory) {\r\n    return _Tokensymbol;\r\n  }\r\n\r\n  function decimals() public view returns(uint8) {\r\n    return _Tokendecimals;\r\n  }\r\n}\r\n\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    \r\n}\r\n\r\ncontract BurnBase is ERC20Detailed {\r\n\r\n  using SafeMath for uint256;\r\n    \r\n  ERC20Detailed internal WETH = ERC20Detailed(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); \r\n\r\n  IUniswapV2Factory public uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n\r\n\r\n  \r\n  mapping (address => uint256) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n  string constant tokenName = \"BurnBase\";\r\n  string constant tokenSymbol = \"BurnBase\";\r\n  uint8  constant tokenDecimals = 18;\r\n  \r\n  uint256 constant easyDecimals = 1000000000000000000;\r\n  // yes you can use an exponent instead if you want\r\n  uint256 _totalSupply = 5000 * easyDecimals;\r\n  \r\n  //any tokens sent here ? \r\n  IERC20 currentToken ;\r\n  \taddress payable public _owner;\r\n  \taddress public _pairAddress;\r\n    \r\n    \r\n    //modifiers\t\r\n\tmodifier onlyOwner() {\r\n      require(msg.sender == _owner);\r\n      _;\r\n  }\r\n  \r\n  \r\n    \r\n  \r\n\r\n  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\r\n      \r\n    _owner = msg.sender;\r\n    //temporarily until the proper pair address is set. To prevent errors if transfer occurs prior to setting pair address. \r\n    _pairAddress = msg.sender;\r\n    \r\n    require(_totalSupply != 0);\r\n    //create initialSupply\r\n    _balances[_owner] = _balances[_owner].add(_totalSupply);\r\n    emit Transfer(address(0), _owner, _totalSupply);\r\n    \r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  function allowance(address owner, address spender) public view returns (uint256) {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n\r\n function transfer(address to, uint256 value) public returns (bool) \r\n    {\r\n        _executeTransfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n    \r\n    function multiTransfer(address[] memory receivers, uint256[] memory values) public\r\n    {\r\n        require(receivers.length == values.length);\r\n        for(uint256 i = 0; i < receivers.length; i++)\r\n            _executeTransfer(msg.sender, receivers[i], values[i]);\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) \r\n    {\r\n        require(value <= _allowed[from][msg.sender]);\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        _executeTransfer(from, to, value);\r\n        return true;\r\n    }\r\n   \r\n  \r\n  //0% \r\n  uint256 public basePercentage = 1000;\r\n  \r\n  function findPercentage(uint256 amount) public view returns (uint256)  {\r\n\r\n    uint256 percent = amount.mul(basePercentage).div(10000);\r\n    return percent;\r\n  }\r\n\r\n\r\n//turns burn on/off called by owner only \r\n  function burnOnOff() external onlyOwner {\r\n    \r\n    \r\n    if(basePercentage == 0)\r\n        basePercentage = 1000;\r\n    else\r\n        basePercentage = 0;\r\n}\r\n\r\n    \r\n    //burn\r\n        function burn(uint256 amount) external {\r\n            _burn(msg.sender, amount);\r\n        }\r\n\r\n        function _burn(address account, uint256 amount) internal {\r\n            require(amount != 0);\r\n            require(amount <= _balances[account]);\r\n            _totalSupply = _totalSupply.sub(amount);\r\n            _balances[account] = _balances[account].sub(amount);\r\n            emit Transfer(account, address(0), amount);\r\n        }\r\n\r\n\r\n        \r\n  \r\n\r\n\r\n\r\n\r\n\r\n  \r\n  \r\n  \r\n  //no zeros for decimals necessary \r\n  function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public {\r\n    uint256 amountWithDecimals = amount * 10**uint256(tokenDecimals);\r\n\r\n    for (uint256 i = 0; i < receivers.length; i++) {\r\n      transfer(receivers[i], amountWithDecimals);\r\n    }\r\n  }\r\n\r\n\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  \r\n  \r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    require(spender != address(0));\r\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \r\n    {\r\n        require(spender != address(0));\r\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    //_pairAddress\r\n    function setPairAddress() external onlyOwner \r\n    {\r\n        _pairAddress = uniswapFactory.getPair(address(WETH), address(this));\r\n    }\r\n\t\r\n        \r\n    //take back unclaimed tokens\r\n    function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner \r\n    {\r\n          currentToken = IERC20(contractUnclaimed);\r\n          uint256 amount = currentToken.balanceOf(address(this));\r\n          currentToken.transfer(_owner, amount);\r\n    }\r\n   \r\n    \r\n    \r\n\r\n\r\n    //   transfer \r\n    function _executeTransfer(address _from, address _to, uint256 _value) private\r\n    {\r\n        if (_to == address(0)) revert();                               // Prevent transfer to 0x0 address. Use burn() instead\r\n    \tif (_value <= 0) revert(); \r\n        if (_balances[_from] < _value) revert();           // Check if the sender has enough\r\n        if (_balances[_to] + _value < _balances[_to]) revert(); // Check for overflows\r\n    \r\n    \r\n            \r\n        //burn if selling only. do not burn if owner adds/removes Liquidity\r\n        if(_to != _pairAddress || _from == _owner || _to == _owner)\r\n        {\r\n\r\n            _balances[_from] = SafeMath.sub(_balances[_from], _value);                     // Subtract from the sender\r\n            _balances[_to] = SafeMath.add(_balances[_to], _value);                            // Add the same to the recipient\r\n            emit Transfer(_from, _to, _value);                   // Notify anyone listening that this transfer took place\r\n\r\n        }//if\r\n        else //selling \r\n        {\r\n            //limit on sell \r\n            //if(_value > 25 * easyDecimals) revert(\"25 token sell limit exceeded\"); //sell limit\r\n            \r\n            uint256 tokensToBurn = findPercentage(_value);\r\n            uint256 tokensToTransfer = _value.sub(tokensToBurn);\r\n\r\n\r\n            _balances[_from] = SafeMath.sub(_balances[_from], tokensToTransfer);                     // Subtract from the sender\r\n            _balances[_to] = _balances[_to].add(tokensToTransfer);          \r\n\r\n            \r\n            emit Transfer(_from, _to, tokensToTransfer);                   // Notify anyone listening that this transfer took place\r\n            \r\n            //anything to burn? burn it\r\n            if(tokensToBurn > 0)\r\n                _burn(_from, tokensToBurn);\r\n    \r\n        }//else\r\n        \r\n    \r\n        \r\n    }//_executeTransfer\r\n    \r\n\r\n\r\n\r\n}"
    }
  }
}