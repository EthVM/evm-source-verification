{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "VoxxtPrimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract ERC721I {\r\n\r\n    string public name; string public symbol;\r\n    string internal baseTokenURI; string internal baseTokenURI_EXT;\r\n    constructor(string memory name_, string memory symbol_) { name = name_; symbol = symbol_; }\r\n\r\n    uint256 public totalSupply; \r\n    mapping(uint256 => address) public ownerOf; \r\n    mapping(address => uint256) public balanceOf; \r\n\r\n    mapping(uint256 => address) public getApproved; \r\n    mapping(address => mapping(address => bool)) public isApprovedForAll; \r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Mint(address indexed to, uint256 tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    // // internal write functions\r\n    // mint\r\n    function _mint(address to_, uint256 tokenId_) internal virtual {\r\n        require(to_ != address(0x0), \"ERC721I: _mint() Mint to Zero Address\");\r\n        require(ownerOf[tokenId_] == address(0x0), \"ERC721I: _mint() Token to Mint Already Exists!\");\r\n\r\n        // ERC721I Starts Here\r\n        ownerOf[tokenId_] = to_;\r\n        balanceOf[to_]++;\r\n        totalSupply++; \r\n        // ERC721I Ends Here\r\n\r\n        emit Transfer(address(0x0), to_, tokenId_);\r\n        emit Mint(to_, tokenId_);\r\n    }\r\n\r\n    // transfer\r\n    function _transfer(address from_, address to_, uint256 tokenId_) internal virtual {\r\n        require(from_ == ownerOf[tokenId_], \"ERC721I: _transfer() Transfer Not Owner of Token!\");\r\n        require(to_ != address(0x0), \"ERC721I: _transfer() Transfer to Zero Address!\");\r\n\r\n        // ERC721I Starts Here\r\n        // checks if there is an approved address clears it if there is\r\n        if (getApproved[tokenId_] != address(0x0)) { \r\n            _approve(address(0x0), tokenId_); \r\n        } \r\n\r\n        ownerOf[tokenId_] = to_; \r\n        balanceOf[from_]--;\r\n        balanceOf[to_]++;\r\n        // ERC721I Ends Here\r\n\r\n        emit Transfer(from_, to_, tokenId_);\r\n    }\r\n\r\n    // approve\r\n    function _approve(address to_, uint256 tokenId_) internal virtual {\r\n        if (getApproved[tokenId_] != to_) {\r\n            getApproved[tokenId_] = to_;\r\n            emit Approval(ownerOf[tokenId_], to_, tokenId_);\r\n        }\r\n    }\r\n    function _setApprovalForAll(address owner_, address operator_, bool approved_) internal virtual {\r\n        require(owner_ != operator_, \"ERC721I: _setApprovalForAll() Owner must not be the Operator!\");\r\n        isApprovedForAll[owner_][operator_] = approved_;\r\n        emit ApprovalForAll(owner_, operator_, approved_);\r\n    }\r\n\r\n    // token uri\r\n    function _setBaseTokenURI(string memory uri_) internal virtual {\r\n        baseTokenURI = uri_;\r\n    }\r\n    function _setBaseTokenURI_EXT(string memory ext_) internal virtual {\r\n        baseTokenURI_EXT = ext_;\r\n    }\r\n\r\n    // // Internal View Functions\r\n    // Embedded Libraries\r\n    function _toString(uint256 value_) internal pure returns (string memory) {\r\n        if (value_ == 0) { return \"0\"; }\r\n        uint256 _iterate = value_; uint256 _digits;\r\n        while (_iterate != 0) { _digits++; _iterate /= 10; } // get digits in value_\r\n        bytes memory _buffer = new bytes(_digits);\r\n        while (value_ != 0) { _digits--; _buffer[_digits] = bytes1(uint8(48 + uint256(value_ % 10 ))); value_ /= 10; } // create bytes of value_\r\n        return string(_buffer); // return string converted bytes of value_\r\n    }\r\n\r\n    // Functional Views\r\n    function _isApprovedOrOwner(address spender_, uint256 tokenId_) internal view virtual returns (bool) {\r\n        require(ownerOf[tokenId_] != address(0x0), \"ERC721I: _isApprovedOrOwner() Owner is Zero Address!\");\r\n        address _owner = ownerOf[tokenId_];\r\n        return (spender_ == _owner || spender_ == getApproved[tokenId_] || isApprovedForAll[_owner][spender_]);\r\n    }\r\n    function _exists(uint256 tokenId_) internal view virtual returns (bool) {\r\n        return ownerOf[tokenId_] != address(0x0);\r\n    }\r\n\r\n    // // public write functions\r\n    function approve(address to_, uint256 tokenId_) public virtual {\r\n        address _owner = ownerOf[tokenId_];\r\n        require(to_ != _owner, \"ERC721I: approve() Cannot approve yourself!\");\r\n        require(msg.sender == _owner || isApprovedForAll[_owner][msg.sender], \"ERC721I: Caller not owner or Approved!\");\r\n        _approve(to_, tokenId_);\r\n    }\r\n    function setApprovalForAll(address operator_, bool approved_) public virtual {\r\n        _setApprovalForAll(msg.sender, operator_, approved_);\r\n    }\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) public virtual {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId_), \"ERC721I: transferFrom() _isApprovedOrOwner = false!\");\r\n        _transfer(from_, to_, tokenId_);\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_, bytes memory data_) public virtual {\r\n        transferFrom(from_, to_, tokenId_);\r\n        if (to_.code.length != 0) {\r\n            (, bytes memory _returned) = to_.staticcall(abi.encodeWithSelector(0x150b7a02, msg.sender, from_, tokenId_, data_));\r\n            bytes4 _selector = abi.decode(_returned, (bytes4));\r\n            require(_selector == 0x150b7a02, \"ERC721I: safeTransferFrom() to_ not ERC721Receivable!\");\r\n        }\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_) public virtual {\r\n        safeTransferFrom(from_, to_, tokenId_, \"\");\r\n    }\r\n\r\n    // 0xInuarashi Custom Functions\r\n    function multiTransferFrom(address from_, address to_, uint256[] memory tokenIds_) public virtual {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            transferFrom(from_, to_, tokenIds_[i]);\r\n        }\r\n    }\r\n    function multiSafeTransferFrom(address from_, address to_, uint256[] memory tokenIds_, bytes memory data_) public virtual {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            safeTransferFrom(from_, to_, tokenIds_[i], data_);\r\n        }\r\n    }\r\n\r\n    // OZ Standard Stuff\r\n    function supportsInterface(bytes4 interfaceId_) public pure returns (bool) {\r\n        return (interfaceId_ == 0x80ac58cd || interfaceId_ == 0x5b5e139f);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId_) public view virtual returns (string memory) {\r\n        require(ownerOf[tokenId_] != address(0x0), \"ERC721I: tokenURI() Token does not exist!\");\r\n        return string(abi.encodePacked(baseTokenURI, _toString(tokenId_), baseTokenURI_EXT));\r\n    }\r\n    // // public view functions\r\n    // never use these for functions ever, they are expensive af and for view only (this will be an issue in the future for interfaces)\r\n    function walletOfOwner(address address_) public virtual view returns (uint256[] memory) {\r\n        uint256 _balance = balanceOf[address_];\r\n        uint256[] memory _tokens = new uint256[] (_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = totalSupply;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf[i] == address(0x0) && _tokens[_balance - 1] == 0) { _loopThrough++; }\r\n            if (ownerOf[i] == address_) { _tokens[_index] = i; _index++; }\r\n        }\r\n        return _tokens;\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed oldOwner_, address indexed newOwner_);\r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function _transferOwnership(address newOwner_) internal virtual {\r\n        address _oldOwner = owner;\r\n        owner = newOwner_;\r\n        emit OwnershipTransferred(_oldOwner, newOwner_);    \r\n    }\r\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\r\n        require(newOwner_ != address(0x0), \"Ownable: new owner is the zero address!\");\r\n        _transferOwnership(newOwner_);\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0x0));\r\n    }\r\n}\r\n\r\ncontract VoxxtPrimal is ERC721I, Ownable {\r\n    constructor() payable ERC721I(\"Voxxt Primal\",\"VP\") {}\r\n    \r\n    // Project Settings\r\n    uint256 public mintPrice = 0.08 ether;\r\n    uint256 public maxTokens = 10000;\r\n    \r\n    // Whitelist Stuff\r\n    uint256 public whitelistAmount = 1200; // 1200 (1000 + 200) >> (1200 - 276) = 924\r\n    uint256 public mintsPerWhitelist = 4; // 4 mints per whitelist\r\n    mapping(address => uint256) public addressToWhitelistMinted;\r\n    mapping(address => bool) public isWhitelisted;\r\n\r\n    bool public whitelistMintEnabled = false; // default false\r\n    uint256 public whitelistMintStartTime = 1641726000; // Sun Jan 09 2022 11:00:00 GMT+0000\r\n\r\n    // Public Mint Stuff\r\n    uint256 public maxMintsPerTx = 10; // 10 mints per tx\r\n\r\n    bool public publicMintEnabled = false; // default false\r\n    uint256 public publicMintStartTime; // default unset\r\n\r\n    // Modifiers\r\n    modifier onlySender {\r\n        require(msg.sender == tx.origin, \r\n            \"No smart contracts!\");\r\n        _;\r\n    }\r\n    modifier whitelistMinting {\r\n        require(whitelistMintEnabled && block.timestamp >= whitelistMintStartTime,\r\n            \"Whitelist Mints are not enabled yet!\");\r\n        _;\r\n    }\r\n    modifier publicMinting {\r\n        require(publicMintEnabled && block.timestamp >= publicMintStartTime,\r\n            \"Public Mints are not enabled yet!\");\r\n        _;\r\n    }\r\n\r\n    // Owner Administration\r\n    function setMintPrice(uint256 mintPrice_) external onlyOwner {\r\n        mintPrice = mintPrice_;\r\n    }\r\n    function setMaxTokens(uint256 maxTokens_) external onlyOwner {\r\n        require(maxTokens_ >= totalSupply, \r\n            \"maxTokens cannot be set lower than totalSupply!\");\r\n\r\n        maxTokens = maxTokens_;\r\n    }\r\n    function setWhitelistAmount(uint256 whitelistAmount_) external onlyOwner {\r\n        whitelistAmount = whitelistAmount_;\r\n    }\r\n    function setMintsPerWhitelist(uint256 mintsPerWhitelist_) external onlyOwner {\r\n        mintsPerWhitelist = mintsPerWhitelist_;\r\n    }\r\n    function setMaxMintsPerTx(uint256 maxMintsPerTx_) external onlyOwner {\r\n        maxMintsPerTx = maxMintsPerTx_;\r\n    }\r\n    function setWhitelists(address[] calldata addresses_, bool bool_) external onlyOwner {\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            isWhitelisted[addresses_[i]] = bool_;\r\n        }\r\n    }\r\n    function setWhitelistParams(bool whitelistMintEnabled_, uint256 whitelistMintStartTime_) external onlyOwner {\r\n        whitelistMintEnabled = whitelistMintEnabled_;\r\n        whitelistMintStartTime = whitelistMintStartTime_;\r\n    }\r\n    function setPublicMintParams(bool publicMintEnabled_, uint256 publicMintStartTime_) external onlyOwner {\r\n        publicMintEnabled = publicMintEnabled_;\r\n        publicMintStartTime = publicMintStartTime_;\r\n    }\r\n    function setBaseTokenURI(string memory uri_) external onlyOwner {\r\n        _setBaseTokenURI(uri_);\r\n    }\r\n    function setBaseTokenURI_EXT(string memory ext_) external onlyOwner {\r\n        _setBaseTokenURI_EXT(ext_);\r\n    }\r\n\r\n    // Internal Mint \r\n    function _mintMany(address to_, uint256 amount_) internal {\r\n        require(maxTokens >= totalSupply + amount_,\r\n            \"Not enough tokens remaining!\");\r\n\r\n        uint256 _startId = totalSupply + 1; // iterate from 1\r\n        \r\n        for (uint256 i = 0; i < amount_; i++) {\r\n            _mint(to_, _startId + i);\r\n        }\r\n    }\r\n\r\n    // Owner Mint Functions\r\n    function ownerMint(address to_, uint256 amount_) external onlyOwner {\r\n        _mintMany(to_, amount_);\r\n    }\r\n    function ownerMintToMany(address[] calldata tos_, uint256[] calldata amounts_) external onlyOwner {\r\n        require(tos_.length == amounts_.length, \r\n            \"Array lengths mismatch!\");\r\n            \r\n        for (uint256 i = 0; i < tos_.length; i++) {\r\n            _mintMany(tos_[i], amounts_[i]);\r\n        }\r\n    }\r\n\r\n    // Whitelist Mint Functions\r\n    function whitelistMint(uint256 amount_) external payable onlySender whitelistMinting {\r\n        require(isWhitelisted[msg.sender], \r\n            \"You are not whitelisted!\");\r\n        require(mintsPerWhitelist >= amount_,\r\n            \"Amount exceeds max mints per whitelist!\");\r\n        require(mintsPerWhitelist >= addressToWhitelistMinted[msg.sender] + amount_,\r\n            \"You don't have enough whitelist mints remaining!\");\r\n        require(msg.value == amount_ * mintPrice, \r\n            \"Invalid amount sent!\");\r\n        require(whitelistAmount >= totalSupply + amount_,\r\n            \"Not enough whitelist mints remaining!\");\r\n        \r\n        addressToWhitelistMinted[msg.sender] += amount_;\r\n\r\n        _mintMany(msg.sender, amount_);\r\n    }\r\n\r\n    // Public Mint Functions\r\n    function publicMint(uint256 amount_) external payable onlySender publicMinting {\r\n        require(maxMintsPerTx >= amount_, \r\n            \"Amount exceeds max mints per tx!\");\r\n        require(msg.value == amount_ * mintPrice, \r\n            \"Invalid amount sent!\");\r\n        require(maxTokens >= totalSupply + amount_,\r\n            \"Not enough tokens remaining!\");\r\n        \r\n        _mintMany(msg.sender, amount_);\r\n    }\r\n\r\n    // Withdraw Funds\r\n    function _sendETH(address payable address_, uint256 amount_) internal {\r\n        (bool success, ) = payable(address_).call{value: amount_}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n    function withdraw() external onlyOwner {\r\n        uint256 _balance = address(this).balance;\r\n        uint256 _toShare1 = (_balance * 5) / 100;\r\n        uint256 _toShare2 = _balance - _toShare1;\r\n\r\n        _sendETH( payable(0x2D3C70A7b4d9C8Cba7D6f78F8B707256eE40A3c0), _toShare1);\r\n        _sendETH( payable(msg.sender), _toShare2);\r\n    }\r\n\r\n    // Emergency Withdraw (if all fails!)\r\n    mapping(address => bool) public shareSigned;\r\n    function signShare() external {\r\n        require(msg.sender == owner \r\n            || msg.sender == 0x2D3C70A7b4d9C8Cba7D6f78F8B707256eE40A3c0,\r\n            \"You cannot sign!\");\r\n        \r\n        shareSigned[msg.sender] = true;\r\n    }\r\n    function emergencyWithdraw() external onlyOwner {\r\n        require(shareSigned[msg.sender] \r\n            && shareSigned[0x2D3C70A7b4d9C8Cba7D6f78F8B707256eE40A3c0],\r\n            \"Both parties have not agreed to unlock this function!\"); // both parties must sign\r\n\r\n        _sendETH( payable(msg.sender), address(this).balance); // send contract eth to msg.sender\r\n    }\r\n}"
    }
  }
}