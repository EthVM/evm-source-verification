{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CombineMetadata_flat.sol":{"content":"// SPDX-License-Identifier: MIT\n// File: Strings.sol\n\n\n\npragma solidity ^0.8.6;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n}\n// File: Roots.sol\n\n\n\npragma solidity ^0.8.6;\n\nlibrary Roots {\n\n// calculates a^(1/n) to dp decimal places\n    // maxIts bounds the number of iterations performed\n    function nthRoot(uint _a, uint _n, uint _dp, uint _maxIts) pure internal returns(uint) {\n        assert (_n > 1);\n\n        // The scale factor is a crude way to turn everything into integer calcs.\n        // Actually do (a * (10 ^ ((dp + 1) * n))) ^ (1/n)\n        // We calculate to one extra dp and round at the end\n        uint one = 10 ** (1 + _dp);\n        uint a0 = one ** _n * _a;\n\n        // Initial guess: 1.0\n        uint xNew = one;\n\n        uint iter = 0;\n        while (iter < _maxIts) {\n            uint x = xNew;\n            uint t0 = x ** (_n - 1);\n            if (x * t0 > a0) {\n                xNew = x - (x - a0 / t0) / _n;\n            } else {\n                xNew = x + (a0 / t0 - x) / _n;\n            }\n            ++iter;\n            if(xNew == x) {\n                break;\n            }\n        }\n\n        // Round to nearest in the last dp.\n        return (xNew + 5) / 10;\n    }\n}\n// File: Base64.sol\n\n\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n// File: ABDKMath64x64.sol\n\n\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.6;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        assert (xh == hi >> 128);\n\n        result += xl / y;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x8) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}\n// File: CombineMetadata.sol\n\n\npragma solidity ^0.8.6;\n\n\n\n\n\ninterface ICombineMetadata {    \n    function tokenMetadata(\n        uint256 tokenId, \n        uint256 rarity, \n        uint256 tokenDensity, \n        uint256 alphaDensity, \n        bool isAlpha, \n        uint256 mergeCount) external view returns (string memory);\n}\n\ncontract CombineMetadata is ICombineMetadata {\n    \n    struct ERC721MetadataStructure {\n        bool isImageLinked;\n        string name;\n        string description;\n        string createdBy;\n        string image;\n        ERC721MetadataAttribute[] attributes;\n    }\n\n    struct ERC721MetadataAttribute {\n        bool includeDisplayType;\n        bool includeTraitType;\n        bool isValueAString;\n        string displayType;\n        string traitType;\n        string value;\n    }\n    \n    using ABDKMath64x64 for int128;    \n    using Base64 for string;\n    using Roots for uint;    \n    using Strings for uint256;    \n    \n    address public owner;  \n\n    string private _name;\n    string private _imageBaseURI;\n    string private _imageExtension;\n    uint256 private _maxRadius;\n    string[] private _imageParts;\n    mapping (string => string) private _classStyles;\n  \n    string constant private _OFFSET_TAG = '<OFFSET>';\n    string constant private _RADIUS_TAG = '<RADIUS>';\n    string constant private _CLASS_TAG = '<CLASS>';  \n    string constant private _CLASS_STYLE_TAG = '<CLASS_STYLE>';\n\n    function getRadius() public view returns (uint256) { \n        return _maxRadius;\n    }\n  \n    constructor() {\n        owner = msg.sender;\n        _name = \"c\";\n        _imageBaseURI = \"\"; // Set to empty string - results in on-chain SVG generation by default unless this is set later\n        _imageExtension = \"\"; // Set to empty string - can be changed later to remain empty, .png, .mp4, etc\n        _maxRadius = 2000;\n\n        // Deploy with default SVG image parts - can be completely replaced later\n        _imageParts.push(\"<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='2000' height='2000'>\");\n            _imageParts.push(\"<style>\");\n                _imageParts.push(\".m1 #c{fill: #fff;}\");\n                _imageParts.push(\".m1 #r{fill: #000;}\");\n                _imageParts.push(\".m2 #c{fill: #fff;}\");\n                _imageParts.push(\".m2 #r{fill: #10a;}\"); // b\n                _imageParts.push(\".m3 #c{fill: #df0;}\"); // y\n                _imageParts.push(\".m3 #r{fill: #000;}\");\n                _imageParts.push(\".m4 #c{fill: #f00;}\"); // r\n                _imageParts.push(\".m4 #r{fill: #000;}\");\n                _imageParts.push(\".a #c{fill: #000 !important;}\"); // b\n                _imageParts.push(\".a #r{fill: #000 !important;}\");\n                _imageParts.push(_CLASS_STYLE_TAG);\n            _imageParts.push(\"</style>\");\n            _imageParts.push(\"<g class='\");\n                _imageParts.push(_CLASS_TAG);\n                _imageParts.push(\"'>\");\n                    _imageParts.push(\"<rect id='r' width='2000' height='2000'/>\");\n                    _imageParts.push(\"<rect id='c' x='\");\n                        _imageParts.push(_OFFSET_TAG);\n                    _imageParts.push(\"' y='\");\n                        _imageParts.push(_OFFSET_TAG);\n                    _imageParts.push(\"' width='\");\n                        _imageParts.push(_RADIUS_TAG);\n                    _imageParts.push(\"' height='\");\n                        _imageParts.push(_RADIUS_TAG);\n                    _imageParts.push(\"'/>\");\n\n            _imageParts.push(\"</g>\");                \n        _imageParts.push(\"</svg>\");\n    }        \n    \n    function setName(string calldata name_) external { \n        _requireOnlyOwner();       \n        _name = name_;\n    }\n\n    function setImageBaseURI(string calldata imageBaseURI_, string calldata imageExtension_) external {        \n        _requireOnlyOwner();\n        _imageBaseURI = imageBaseURI_;\n        _imageExtension = imageExtension_;\n    }\n\n    function setMaxRadius(uint256 maxRadius_) external {\n        _requireOnlyOwner();\n        _maxRadius = maxRadius_;\n    }    \n\n    function tokenMetadata(uint256 tokenId, uint256 rarity, uint256 tokenDensity, uint256 alphaDensity, bool isAlpha, uint256 mergeCount) external view override returns (string memory) {        \n        string memory base64Json = Base64.encode(bytes(string(abi.encodePacked(_getJson(tokenId, rarity, tokenDensity, alphaDensity, isAlpha, mergeCount)))));\n        return string(abi.encodePacked('data:application/json;base64,', base64Json));\n    }\n\n    function updateImageParts(string[] memory imageParts_) public {\n        _requireOnlyOwner();\n        _imageParts = imageParts_;\n    }\n\n    function updateClassStyle(string calldata cssClass, string calldata cssStyle) external {\n        _requireOnlyOwner();\n        _classStyles[cssClass] = cssStyle;\n    }\n\n    function getClassStyle(string memory cssClass) public view returns (string memory) {\n        return _classStyles[cssClass];\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function imageBaseURI() public view returns (string memory) {\n        return _imageBaseURI;\n    }\n\n    function imageExtension() public view returns (string memory) {\n        return _imageExtension;\n    }\n\n    function maxRadius() public view returns (uint256) {\n        return _maxRadius;\n    }            \n\n    function getClassString(uint256 tokenId, uint256 rarity, bool isAlpha, bool offchainImage) public pure returns (string memory) {\n        return _getClassString(tokenId, rarity, isAlpha, offchainImage);\n    }\n\n    function _getJson(uint256 tokenId, uint256 rarity, uint256 tokenDensity, uint256 alphaDensity, bool isAlpha, uint256 mergeCount) private view returns (string memory) {        \n        string memory imageData = \n            bytes(_imageBaseURI).length == 0 ? \n                _getSvg(tokenId, rarity, tokenDensity, alphaDensity, isAlpha) :\n                string(abi.encodePacked(imageBaseURI(), _getClassString(tokenId, rarity, isAlpha, true), \"_\", uint256(int256(_getScaledRadius(tokenDensity, alphaDensity, _maxRadius).toInt())).toString(), imageExtension()));\n\n        ERC721MetadataStructure memory metadata = ERC721MetadataStructure({\n            isImageLinked: bytes(_imageBaseURI).length > 0, \n            name: string(abi.encodePacked(name(), \"(\", tokenDensity.toString(), \") #\", tokenId.toString())),\n            description: tokenDensity.toString(),\n            createdBy: \"Hak\",\n            image: imageData,\n            attributes: _getJsonAttributes(tokenId, rarity, tokenDensity, mergeCount, isAlpha)\n        });\n\n        return _generateERC721Metadata(metadata);\n    }        \n\n    function _getJsonAttributes(uint256 tokenId, uint256 rarity, uint256 tokenDensity, uint256 mergeCount, bool isAlpha) private pure returns (ERC721MetadataAttribute[] memory) {\n        uint256 tensDigit = tokenId % 100 / 10;\n        uint256 onesDigit = tokenId % 10;\n        uint256 class = tensDigit * 10 + onesDigit;\n\n        ERC721MetadataAttribute[] memory metadataAttributes = new ERC721MetadataAttribute[](5);\n        metadataAttributes[0] = _getERC721MetadataAttribute(false, true, false, \"\", \"Density\", tokenDensity.toString());\n        metadataAttributes[1] = _getERC721MetadataAttribute(false, true, false, \"\", \"Alpha\", isAlpha ? \"1\" : \"0\");\n        metadataAttributes[2] = _getERC721MetadataAttribute(false, true, false, \"\", \"Tier\", rarity.toString());\n        metadataAttributes[3] = _getERC721MetadataAttribute(false, true, false, \"\", \"Class\", class.toString());\n        metadataAttributes[4] = _getERC721MetadataAttribute(false, true, false, \"\", \"Combines\", mergeCount.toString());\n        return metadataAttributes;\n    }    \n\n    function _getERC721MetadataAttribute(bool includeDisplayType, bool includeTraitType, bool isValueAString, string memory displayType, string memory traitType, string memory value) private pure returns (ERC721MetadataAttribute memory) {\n        ERC721MetadataAttribute memory attribute = ERC721MetadataAttribute({\n            includeDisplayType: includeDisplayType,\n            includeTraitType: includeTraitType,\n            isValueAString: isValueAString,\n            displayType: displayType,\n            traitType: traitType,\n            value: value\n        });\n\n        return attribute;\n    }    \n\n    function _getSvg(uint256 tokenId, uint256 rarity, uint256 tokenDensity, uint256 alphaDensity, bool isAlpha) private view returns (string memory) {\n        bytes memory byteString;\n        int128 radius = _getScaledRadius(tokenDensity, alphaDensity, _maxRadius);\n        int128 offset = _getOffset(radius, _maxRadius);\n        //return _floatToString(offset);\n        for (uint i = 0; i < _imageParts.length; i++) {\n          if (_checkTag(_imageParts[i], _RADIUS_TAG)) {\n            byteString = abi.encodePacked(byteString, _floatToString(radius));\n          } else if (_checkTag(_imageParts[i], _OFFSET_TAG)) {\n            byteString = abi.encodePacked(byteString, _floatToString(offset));\n          } else if (_checkTag(_imageParts[i], _CLASS_TAG)) {\n            byteString = abi.encodePacked(byteString, _getClassString(tokenId, rarity, isAlpha, false));\n          } else if (_checkTag(_imageParts[i], _CLASS_STYLE_TAG)) {\n              uint256 tensDigit = tokenId % 100 / 10;\n              uint256 onesDigit = tokenId % 10;\n              uint256 class = tensDigit * 10 + onesDigit;\n              string memory classCss = getClassStyle(_getTokenIdClass(class));\n              if(bytes(classCss).length > 0) {\n                  byteString = abi.encodePacked(byteString, classCss);\n              }            \n          } else {\n            byteString = abi.encodePacked(byteString, _imageParts[i]);\n          }\n        }\n        return string(byteString); \n    }\n\n    function _getScaledRadius(uint256 tokenDensity, uint256 alphaDensity, uint256 maximumRadius) private pure returns (int128) {\n        int128 radiusDensity = _getRadius64x64(tokenDensity);\n        int128 radiusAlphaDensity = _getRadius64x64(alphaDensity);\n        int128 scalePercentage = ABDKMath64x64.div(radiusDensity, radiusAlphaDensity);                \n        int128 scaledRadius = ABDKMath64x64.mul(ABDKMath64x64.fromUInt(maximumRadius), scalePercentage);\n        if(uint256(int256(scaledRadius.toInt())) == 0) {\n            scaledRadius = ABDKMath64x64.fromUInt(1);\n        }\n        return scaledRadius;\n    }\n\n    function _getOffset(int128 radius, uint256 maximumRadius) private pure returns (int128) {\n        \n        int128 remainLength = ABDKMath64x64.sub(ABDKMath64x64.fromUInt(maximumRadius), radius);                \n        int128 offset = ABDKMath64x64.div(remainLength, ABDKMath64x64.fromUInt(2));\n        if(uint256(int256(offset.toInt())) == 0) {\n            offset = ABDKMath64x64.fromUInt(0);\n        }\n        return offset;\n    }\n\n    // Radius = Cube Root(Density) * Cube Root (0.23873241463)\n    // Radius = Cube Root(Density) * 0.62035049089\n    function _getRadius64x64(uint256 density) private pure returns (int128) {        \n        int128 cubeRootScalar = ABDKMath64x64.divu(62035049089, 100000000000);\n        int128 cubeRootDensity = ABDKMath64x64.divu(density.nthRoot(3, 6, 32), 1000000);\n        int128 radius = ABDKMath64x64.mul(cubeRootDensity, cubeRootScalar);        \n        return radius;\n    }            \n\n    function _generateERC721Metadata(ERC721MetadataStructure memory metadata) private pure returns (string memory) {\n      bytes memory byteString;    \n    \n        byteString = abi.encodePacked(\n          byteString,\n          _openJsonObject());\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _pushJsonPrimitiveStringAttribute(\"name\", metadata.name, true));\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _pushJsonPrimitiveStringAttribute(\"description\", metadata.description, true));\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _pushJsonPrimitiveStringAttribute(\"created_by\", metadata.createdBy, true));\n    \n        if(metadata.isImageLinked) {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"image\", metadata.image, true));\n        } else {\n            byteString = abi.encodePacked(\n                byteString,\n                _pushJsonPrimitiveStringAttribute(\"image_data\", metadata.image, true));\n        }\n\n        byteString = abi.encodePacked(\n          byteString,\n          _pushJsonComplexAttribute(\"attributes\", _getAttributes(metadata.attributes), false));\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _closeJsonObject());\n    \n        return string(byteString);\n    }\n\n    function _getAttributes(ERC721MetadataAttribute[] memory attributes) private pure returns (string memory) {\n        bytes memory byteString;\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _openJsonArray());\n    \n        for (uint i = 0; i < attributes.length; i++) {\n          ERC721MetadataAttribute memory attribute = attributes[i];\n\n          byteString = abi.encodePacked(\n            byteString,\n            _pushJsonArrayElement(_getAttribute(attribute), i < (attributes.length - 1)));\n        }\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _closeJsonArray());\n    \n        return string(byteString);\n    }\n\n    function _getAttribute(ERC721MetadataAttribute memory attribute) private pure returns (string memory) {\n        bytes memory byteString;\n        \n        byteString = abi.encodePacked(\n          byteString,\n          _openJsonObject());\n    \n        if(attribute.includeDisplayType) {\n          byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveStringAttribute(\"display_type\", attribute.displayType, true));\n        }\n    \n        if(attribute.includeTraitType) {\n          byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveStringAttribute(\"trait_type\", attribute.traitType, true));\n        }\n    \n        if(attribute.isValueAString) {\n          byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveStringAttribute(\"value\", attribute.value, false));\n        } else {\n          byteString = abi.encodePacked(\n            byteString,\n            _pushJsonPrimitiveNonStringAttribute(\"value\", attribute.value, false));\n        }\n    \n        byteString = abi.encodePacked(\n          byteString,\n          _closeJsonObject());\n    \n        return string(byteString);\n    }\n\n    function _getClassString(uint256 tokenId, uint256 rarity, bool isAlpha, bool offchainImage) private pure returns (string memory) {\n        bytes memory byteString;    \n    \n        byteString = abi.encodePacked(byteString, _getRarityClass(rarity));\n        \n        if(isAlpha) {\n            byteString = abi.encodePacked(\n              byteString,\n              string(abi.encodePacked(offchainImage ? \"_\" : \" \", \"a\")));\n        }\n\n        uint256 tensDigit = tokenId % 100 / 10;\n        uint256 onesDigit = tokenId % 10;\n        uint256 class = tensDigit * 10 + onesDigit;\n\n        byteString = abi.encodePacked(\n          byteString,\n          string(abi.encodePacked(offchainImage ? \"_\" : \" \", _getTokenIdClass(class))));\n\n        return string(byteString);    \n    }\n\n    function _getRarityClass(uint256 rarity) private pure returns (string memory) {\n        return string(abi.encodePacked(\"m\", rarity.toString()));\n    }\n\n    function _getTokenIdClass(uint256 class) private pure returns (string memory) {\n        return string(abi.encodePacked(\"c\", class.toString()));\n    }\n\n    function _checkTag(string storage a, string memory b) private pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    function _floatToString(int128 value) private pure returns (string memory) {\n        uint256 decimal4 = (value & 0xFFFFFFFFFFFFFFFF).mulu(10000);\n        return string(abi.encodePacked(uint256(int256(value.toInt())).toString(), '.', _decimal4ToString(decimal4)));\n    }\n  \n    function _decimal4ToString(uint256 decimal4) private pure returns (string memory) {\n        bytes memory decimal4Characters = new bytes(4);\n        for (uint i = 0; i < 4; i++) {\n          decimal4Characters[3 - i] = bytes1(uint8(0x30 + decimal4 % 10));\n          decimal4 /= 10;\n        }\n        return string(abi.encodePacked(decimal4Characters));\n    }\n\n    function _requireOnlyOwner() private view {\n        require(msg.sender == owner, \"You are not the owner\");\n    }\n\n    function _openJsonObject() private pure returns (string memory) {        \n        return string(abi.encodePacked(\"{\"));\n    }\n\n    function _closeJsonObject() private pure returns (string memory) {\n        return string(abi.encodePacked(\"}\"));\n    }\n\n    function _openJsonArray() private pure returns (string memory) {        \n        return string(abi.encodePacked(\"[\"));\n    }\n\n    function _closeJsonArray() private pure returns (string memory) {        \n        return string(abi.encodePacked(\"]\"));\n    }\n\n    function _pushJsonPrimitiveStringAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked('\"', key, '\": \"', value, '\"', insertComma ? ',' : ''));\n    }\n\n    function _pushJsonPrimitiveNonStringAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked('\"', key, '\": ', value, insertComma ? ',' : ''));\n    }\n\n    function _pushJsonComplexAttribute(string memory key, string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked('\"', key, '\": ', value, insertComma ? ',' : ''));\n    }\n\n    function _pushJsonArrayElement(string memory value, bool insertComma) private pure returns (string memory) {\n        return string(abi.encodePacked(value, insertComma ? ',' : ''));\n    }\n}"}}}