{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"all_main.sol":{"content":"// File: @openzeppelin/contracts/token/ERC777/IERC777.sol\n\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n\n// File: @openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\n\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// File: @openzeppelin/contracts/introspection/IERC1820Registry.sol\n\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: crosslend/data.sol\n\npragma solidity >=0.6.2 <0.8.0;\n\nenum FinancialType{CRFI, CFil}\n\nstruct FinancialPackage {\n  FinancialType Type;\n  \n  uint256 Days;\n  uint256 CFilInterestRate;\n  uint256 CRFIInterestRateDyn;\n  uint256 ID;\n\n  uint256 Weight;\n  uint256 ParamCRFI;\n  uint256 ParamCFil;\n  uint256 Total;\n}\n\nstruct LoanCFilPackage {\n  uint256 APY;\n  uint256 PledgeRate;\n  uint256 PaymentDue;\n  uint256 PaymentDue99;\n\n  uint256 UpdateTime;\n  uint256 Param;\n}\n\nstruct ViewSystemInfo{\n  FinancialPackage[] Packages;\n  uint256 AffRate;\n  uint256 AffRequire;\n  uint256 EnableAffCFil;\n  \n  LoanCFilPackage LoanCFil;\n\n  ChainManager ChainM;\n\n  // invest\n  uint256 NewInvestID;\n  mapping(uint256 => InvestInfo) Invests;\n  mapping(address => uint256) InvestAddrID;\n        \n  // setting power\n  address SuperAdmin;\n  mapping(address => bool) Admins;\n\n  // statistic\n  uint256 nowInvestCRFI;\n  uint256 nowInvestCFil; \n  uint256 cfilInterestPool;\n  uint256 crfiInterestPool;\n\n  uint256 cfilLendingTotal;\n  uint256 crfiRewardTotal;\n  uint256 avaiCFilAmount;\n  \n  uint256 totalWeightCFil;\n  uint256 totalWeightCRFI;\n  uint256 crfiMinerPerDayCFil;\n  uint256 crfiMinerPerDayCRFI;\n  \n  uint256 ParamUpdateTime;\n}\n\nstruct SystemInfoView {\n  uint256 AffRate;\n  uint256 AffRequire;\n  uint256 EnableAffCFil;\n  \n  // invest\n  uint256 NewInvestID;\n\n  // statistic\n  uint256 nowInvestCRFI;\n  uint256 nowInvestCFil; \n  uint256 cfilInterestPool;\n  uint256 crfiInterestPool;\n\n  uint256 cfilLendingTotal;\n  uint256 crfiRewardTotal;\n  uint256 avaiCFilAmount;\n  \n  uint256 totalWeightCFil;\n  uint256 totalWeightCRFI;\n  uint256 crfiMinerPerDayCFil;\n  uint256 crfiMinerPerDayCRFI;\n  \n  uint256 ParamUpdateTime;\n}\n\nstruct SystemInfo {\n\n  FinancialPackage[] Packages;\n  uint256 AffRate;\n  uint256 AffRequire;\n  uint256 EnableAffCFil;\n  \n  LoanCFilPackage LoanCFil;\n\n  ChainManager ChainM;\n\n  // invest\n  uint256 NewInvestID;\n  mapping(uint256 => InvestInfo) Invests;\n  mapping(address => uint256) InvestAddrID;\n        \n  // setting power\n  address SuperAdmin;\n  mapping(address => bool) Admins;\n\n  // statistic\n  uint256 nowInvestCRFI;\n  uint256 nowInvestCFil; \n  uint256 cfilInterestPool;\n  uint256 crfiInterestPool;\n\n  uint256 cfilLendingTotal;\n  uint256 crfiRewardTotal;\n  uint256 avaiCFilAmount;\n  \n  uint256 totalWeightCFil;\n  uint256 totalWeightCRFI;\n  uint256 crfiMinerPerDayCFil;\n  uint256 crfiMinerPerDayCRFI;\n  \n  uint256 ParamUpdateTime;\n\n  mapping(string => string) kvMap;\n}\n\nstruct InterestDetail{\n  uint256 crfiInterest;\n  uint256 cfilInterest;\n}\n\nstruct LoanInvest{\n  uint256 Lending;\n  uint256 Pledge;\n  uint256 Param;\n  uint256 NowInterest;\n}\n\nstruct InvestInfoView {\n  address Addr;\n  uint256 ID;\n\n  uint256 affID;\n\n  // statistic for financial\n  uint256 totalAffTimes;\n  uint256 totalAffPackageTimes;\n  \n  uint256 totalAffCRFI;\n  uint256 totalAffCFil;\n  \n  uint256 nowInvestFinCRFI;\n  uint256 nowInvestFinCFil;\n}\n\nstruct InvestInfo {\n  mapping(uint256 => ChainQueue) InvestRecords;\n\n  address Addr;\n  uint256 ID;\n\n  uint256 affID;\n\n  LoanInvest LoanCFil;\n\n  // statistic for financial\n  uint256 totalAffTimes;\n  uint256 totalAffPackageTimes;\n  \n  uint256 totalAffCRFI;\n  uint256 totalAffCFil;\n  \n  uint256 nowInvestFinCRFI;\n  uint256 nowInvestFinCFil;\n}\n\n\n//////////////////// queue\n\nstruct QueueData {\n  uint256 RecordID;\n  \n  FinancialType Type;\n  uint256 PackageID;\n  uint256 Days;\n  uint256 EndTime;\n  uint256 AffID;\n  uint256 Amount;\n\n  uint256 ParamCRFI;\n  uint256 ParamCFil;\n}\n\nstruct ChainItem {\n  uint256 Next;\n  uint256 Prev;\n  uint256 My;\n  \n  QueueData Data;\n}\n\nstruct ChainQueue{\n  uint256 First;\n  uint256 End;\n\n  uint256 Size;\n}\n\n\nstruct ChainManager{\n  ChainItem[] rawQueue;\n\n  ChainQueue avaiQueue;\n}\n\nlibrary ChainQueueLib{\n\n  //////////////////// item\n  function GetNullItem(ChainManager storage chainM)\n    internal\n    view\n    returns(ChainItem storage item){\n    return chainM.rawQueue[0];\n  }\n\n  function HasNext(ChainManager storage chainM,\n                   ChainItem storage item)\n    internal\n    view\n    returns(bool has){\n\n    if(item.Next == 0){\n      return false;\n    }\n\n    return true;\n  }\n\n  function Next(ChainManager storage chainM,\n                ChainItem storage item)\n    internal\n    view\n    returns(ChainItem storage nextItem){\n\n    uint256 nextIdx = item.Next;\n    require(nextIdx > 0, \"no next item\");\n\n    return chainM.rawQueue[uint256(nextIdx)];\n  }\n\n  //////////////////// chain\n  function GetFirstItem(ChainManager storage chainM,\n                        ChainQueue storage chain)\n    internal\n    view\n    returns(ChainItem storage item){\n\n    require(chain.Size > 0, \"chain is empty\");\n\n    return chainM.rawQueue[chain.First];\n  }\n\n  function GetEndItem(ChainManager storage chainM,\n                      ChainQueue storage chain)\n    internal\n    view\n    returns(ChainItem storage item){\n\n    require(chain.Size > 0, \"chain is empty\");\n\n    return chainM.rawQueue[chain.End];\n  }\n\n  // need ensure the item is in chain\n  function DeleteItem(ChainManager storage chainM,\n                      ChainQueue storage chain,\n                      ChainItem storage item)\n    internal{\n\n    if(chain.First == item.My){\n      PopPutFirst(chainM, chain);\n      return;\n    } else if (chain.End == item.My){\n      PopPutEnd(chainM, chain);\n      return;\n    }\n\n    ChainItem storage next = chainM.rawQueue[item.Next];\n    ChainItem storage prev = chainM.rawQueue[item.Prev];\n\n    next.Prev = item.Prev;\n    prev.Next = item.Next;\n\n    item.Prev = 0;\n    item.Next = 0;\n\n    chain.Size--;\n\n    PutItem(chainM, item);\n  }\n\n  function PopPutFirst(ChainManager storage chainM,\n                       ChainQueue storage chain)\n    internal{\n\n    ChainItem storage item = PopFirstItem(chainM, chain);\n    PutItem(chainM, item);\n  }\n\n  function PopPutEnd(ChainManager storage chainM,\n                     ChainQueue storage chain)\n    internal{\n\n    ChainItem storage item = PopEndItem(chainM, chain);\n    PutItem(chainM, item);\n  }\n\n  function PopEndItem(ChainManager storage chainM,\n                        ChainQueue storage chain)\n    internal\n    returns(ChainItem storage item){\n    \n    require(chain.Size >0, \"chain is empty\");\n    \n    uint256 itemIdx = chain.End;\n    chain.End = chainM.rawQueue[itemIdx].Prev;\n    if(chain.End > 0){\n      chainM.rawQueue[chain.End].Next = 0;\n    } else {\n      chain.First = 0;\n    }\n    chain.Size--;\n    item = chainM.rawQueue[itemIdx];\n    item.Prev = 0;\n    return item;\n  }\n\n  function PopFirstItem(ChainManager storage chainM,\n                        ChainQueue storage chain)\n    internal\n    returns(ChainItem storage item){\n\n    require(chain.Size > 0, \"chain is empty\");\n\n    uint256 itemIdx = chain.First;\n    chain.First = chainM.rawQueue[itemIdx].Next;\n    if(chain.First > 0){\n      chainM.rawQueue[chain.First].Prev = 0;\n    } else {\n      chain.End = 0;\n    }\n    chain.Size--;\n\n    item = chainM.rawQueue[itemIdx];\n    item.Next = 0;\n\n    return item;\n  }\n\n  function PushEndItem(ChainManager storage chainM,\n                       ChainQueue storage chain,\n                       ChainItem storage item)\n    internal{\n\n    item.Prev = chain.End;\n    item.Next = 0;\n\n    if(chain.Size == 0){\n      chain.First = item.My;\n      chain.End = item.My;\n    } else {\n      chainM.rawQueue[chain.End].Next = item.My;\n      chain.End = item.My;\n    }\n    chain.Size++;\n  }\n\n  //////////////////// chain manager\n  function InitChainManager(ChainManager storage chainM)\n    internal{\n    if(chainM.rawQueue.length == 0){\n      chainM.rawQueue.push();\n    }\n  }\n  \n  function GetAvaiItem(ChainManager storage chainM)\n    internal\n    returns(ChainItem storage item){\n    \n    if(chainM.avaiQueue.Size == 0){\n      if(chainM.rawQueue.length == 0){\n        chainM.rawQueue.push();\n      }\n      \n      uint256 itemIdx = chainM.rawQueue.length;\n      chainM.rawQueue.push();\n\n      item = chainM.rawQueue[itemIdx];\n      item.Next = 0;\n      item.Prev = 0;\n      item.My = itemIdx;\n      \n      return item;\n    }\n\n    return PopFirstItem(chainM, chainM.avaiQueue);\n  }\n\n  function PutItem(ChainManager storage chainM,\n                   ChainItem storage item)\n    internal{\n    \n    PushEndItem(chainM, chainM.avaiQueue, item);\n  }\n}\n\n// File: crosslend/main.sol\n\npragma solidity >=0.7.0 <0.8.0;\npragma abicoder v2;\n\n\n\n\n\n\n\ncontract CrossLend is IERC777Recipient, ReentrancyGuard{\n  //////////////////// for using\n  using ChainQueueLib for ChainManager;\n  using SafeMath for uint256;\n\n  //////////////////// constant\n  IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n  uint256 constant Decimal = 1e18;\n\n  uint256 public OneDayTime;\n\n  //////////////////// var\n  SystemInfo internal SInfo;\n  \n  IERC777 public CRFI;\n  IERC777 public CFil;\n  IERC777 public SFil;\n\n  //////////////////// modifier\n  modifier IsAdmin() {\n    require(msg.sender == SInfo.SuperAdmin || SInfo.Admins[msg.sender], \"only admin\");\n    _;\n  }\n\n  modifier IsSuperAdmin() {\n    require(SInfo.SuperAdmin == msg.sender, \"only super admin\");\n    _;\n  }\n\n  //////////////////// event\n  event AffEvent(address indexed receiver, address indexed sender, uint256 indexed affTimes, uint256 crfiInterest, uint256 cfilInterest, uint256 packageID, uint256 timestamp);\n\n  event AffBought(address indexed affer, address indexed sender, uint256 indexed affPackageTimes, uint256 amount, uint256 packageID, uint256 timestamp);\n  \n  event loanCFilEvent(address indexed addr, uint256 cfilAmount, uint256 sfilAmount);\n\n  //////////////////// constructor\n  constructor(address crfiAddr, address cfilAddr, address sfilAddr) {\n    CRFI = IERC777(crfiAddr);\n    CFil = IERC777(cfilAddr);\n    SFil = IERC777(sfilAddr);\n    OneDayTime = 60 * 60 * 24;\n\n    SInfo.SuperAdmin = msg.sender;\n\n    SInfo.AffRate = Decimal / 10;\n    SInfo.EnableAffCFil = 1;\n\n    SInfo.ChainM.InitChainManager();\n    \n    ////////// add package\n\n    SInfo.crfiMinerPerDayCFil = 1917808 * Decimal / 100;\n    SInfo.crfiMinerPerDayCRFI = 821918 * Decimal / 100;\n\n    SInfo.ParamUpdateTime = block.timestamp;\n    \n    // loan CFil\n    ChangeLoanRate(201 * Decimal / 1000,\n                   56 * Decimal / 100,\n                   2300 * Decimal);\n    SInfo.LoanCFil.UpdateTime = block.timestamp;\n\n    // add crfi\n    AddPackage(FinancialType.CRFI,\n               0,\n               (20 * Decimal) / 1000,\n               Decimal);\n    \n    AddPackage(FinancialType.CRFI,\n               90,\n               (32 * Decimal) / 1000,\n               (15 * Decimal) / 10);\n\n    AddPackage(FinancialType.CRFI,\n               180,\n               (34 * Decimal) / 1000,\n               2 * Decimal);\n\n    AddPackage(FinancialType.CRFI,\n               365,\n               (36 * Decimal) / 1000,\n               (25 * Decimal) / 10);\n                   \n    AddPackage(FinancialType.CRFI,\n               540,\n               (40 * Decimal) / 1000,\n               3 * Decimal);\n    \n    // add cfil\n    AddPackage(FinancialType.CFil,\n               0,\n               (20 * Decimal) / 1000,\n               Decimal);\n    \n    AddPackage(FinancialType.CFil,\n               90,\n               (33 * Decimal) / 1000,\n               (15 * Decimal) / 10);\n\n    AddPackage(FinancialType.CFil,\n               180, \n               (35 * Decimal) / 1000,\n               2 * Decimal);\n\n    AddPackage(FinancialType.CFil,\n               365,\n               (37 * Decimal) / 1000,\n               (25 * Decimal) / 10);\n                   \n    AddPackage(FinancialType.CFil,\n               540,\n               (41 * Decimal) / 1000,\n               3 * Decimal);\n    \n    // register interfaces\n    _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n  }\n  \n  //////////////////// super admin func\n  function AddAdmin(address admin)\n    public\n    IsSuperAdmin(){\n    require(!SInfo.Admins[admin], \"already add this admin\");\n    SInfo.Admins[admin] = true;\n  }\n\n  function DelAdmin(address admin)\n    public\n    IsSuperAdmin(){\n    require(SInfo.Admins[admin], \"this addr is not admin\");\n    SInfo.Admins[admin] = false;\n  }\n\n  function ChangeSuperAdmin(address suAdmin)\n    public\n    IsSuperAdmin(){\n    require(suAdmin != address(0x0), \"empty new super admin\");\n\n    if(suAdmin == SInfo.SuperAdmin){\n      return;\n    }\n    \n    SInfo.SuperAdmin = suAdmin;\n  }\n\n  //////////////////// admin func\n  function SetMap(string memory key,\n                  string memory value)\n    public\n    IsAdmin(){\n\n    SInfo.kvMap[key] = value;\n  }\n  \n  function ChangePackageRate(uint256 packageID,\n                             uint256 cfilInterestRate,\n                             uint256 weight)\n    public\n    IsAdmin(){\n    \n    require(packageID < SInfo.Packages.length, \"packageID error\");\n\n    updateAllParam();\n    \n    FinancialPackage storage package = SInfo.Packages[packageID];\n    package.CFilInterestRate = cfilInterestRate;\n\n    uint256 nowTotal = package.Total.mul(package.Weight) / Decimal;\n    if(package.Type == FinancialType.CRFI){\n      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.sub(nowTotal);\n    } else {\n      SInfo.totalWeightCFil = SInfo.totalWeightCFil.sub(nowTotal);\n    }\n\n    package.Weight = weight;\n\n    nowTotal = package.Total.mul(package.Weight) / Decimal;\n    if(package.Type == FinancialType.CRFI){\n      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.add(nowTotal);\n    } else {\n      SInfo.totalWeightCFil = SInfo.totalWeightCFil.add(nowTotal);\n    }\n  }\n\n  function AddPackage(FinancialType _type,\n                      uint256 dayTimes,\n                      uint256 cfilInterestRate,\n                      uint256 weight)\n    public\n    IsAdmin(){\n\n    updateAllParam();\n    \n    uint256 idx = SInfo.Packages.length;\n    SInfo.Packages.push();\n    FinancialPackage storage package = SInfo.Packages[idx];\n\n    package.Type = _type;\n    package.Days = dayTimes;\n    package.Weight = weight;\n    package.CFilInterestRate = cfilInterestRate;\n    package.ID = idx;\n  }\n\n  function ChangeCRFIMinerPerDay(uint256 crfi, uint256 cfil)\n    public\n    IsAdmin(){\n\n    updateAllParam();\n\n    SInfo.crfiMinerPerDayCFil = cfil;\n    SInfo.crfiMinerPerDayCRFI = crfi;\n  }\n\n  function ChangeLoanRate(uint256 apy, uint256 pledgeRate, uint256 paymentDue)\n    public\n    IsAdmin(){\n\n    require(pledgeRate > 0, \"pledge rate can't = 0\");\n\n    SInfo.LoanCFil.APY = apy;\n    SInfo.LoanCFil.PledgeRate = pledgeRate;\n    SInfo.LoanCFil.PaymentDue = paymentDue;\n    SInfo.LoanCFil.PaymentDue99 = paymentDue.mul(99) / 100;\n  }\n\n  function ChangeAffCFil(bool enable)\n    public\n    IsAdmin(){\n    if(enable && SInfo.EnableAffCFil == 0){\n      SInfo.EnableAffCFil = 1;\n    } else if(!enable && SInfo.EnableAffCFil > 0){\n      SInfo.EnableAffCFil = 0;\n    }\n  }\n\n  function ChangeAffRate(uint256 rate)\n    public\n    IsAdmin(){\n    \n    SInfo.AffRate = rate;\n  }\n\n  function ChangeAffRequire(uint256 amount)\n    public\n    IsAdmin(){\n    SInfo.AffRequire = amount;\n  }\n\n  function WithdrawCRFIInterestPool(uint256 amount)\n    public\n    IsAdmin(){\n    SInfo.crfiInterestPool = SInfo.crfiInterestPool.sub(amount);\n    CRFI.send(msg.sender, amount, \"\");\n  }\n\n  function WithdrawCFilInterestPool(uint256 amount)\n    public\n    IsAdmin(){\n    SInfo.cfilInterestPool = SInfo.cfilInterestPool.sub(amount);\n    CFil.send(msg.sender, amount, \"\");\n  }\n  \n  //////////////////// public\n  function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData)\n    public\n    override\n    nonReentrant(){\n\n    ////////// check\n    require(userData.length > 0, \"no user data\");\n    \n    // mode = 0, normal bought financial package\n    // mode = 2, charge cfil interest pool\n    // mode = 3, charge crfi interest pool\n    // mode = 4, loan cfil\n    // mode = 5, repay cfil by loan\n    (uint256 mode, uint256 param, address addr) = abi.decode(userData, (uint256,uint256, address));\n    require(from != address(0x0), \"from is zero\");\n\n    if(mode == 5){\n      _repayLoanCFil(from, amount);\n    }else if(mode == 4){\n      _loanCFil(from, amount);\n    }else if(mode == 3){\n      require(amount > 0, \"no amount\");\n      require(msg.sender == address(CRFI), \"only charge crfi\");\n      SInfo.crfiInterestPool = SInfo.crfiInterestPool.add(amount);\n      return;\n    }else if(mode == 2){\n      require(amount > 0, \"no amount\");\n      require(msg.sender == address(CFil), \"only charge cfil\");\n      SInfo.cfilInterestPool = SInfo.cfilInterestPool.add(amount);\n      \n      return;\n    } else if (mode == 0){\n      _buyFinancialPackage(from, param, addr, amount);\n    } else {\n      revert(\"mode error\");\n    }\n  }\n  \n  function Withdraw(uint256 packageID, bool only, uint256 maxNum)\n    public\n    nonReentrant(){\n\n    InvestInfo storage uInfo = SInfo.Invests[getUID(msg.sender)];\n    \n    uint256 cfil;\n    uint256 cfilInterest;\n    uint256 crfi;\n    uint256 crfiInterest;\n\n    (crfi, crfiInterest, cfil, cfilInterest) = _withdrawFinancial(uInfo, packageID, only, maxNum);\n\n    if(crfi > 0){\n      uInfo.nowInvestFinCRFI = uInfo.nowInvestFinCRFI.sub(crfi);\n    }\n    if(cfil > 0){\n      uInfo.nowInvestFinCFil = uInfo.nowInvestFinCFil.sub(cfil);\n    }\n\n    withdrawCoin(uInfo.Addr, crfi, crfiInterest, cfil, cfilInterest);\n  }\n\n  //////////////////// view func\n\n  function GetMap(string memory key)\n    public\n    view\n    returns(string memory value){\n\n    return SInfo.kvMap[key];\n  }\n\n  function GetFinancialPackage()\n    public\n    view\n    returns(FinancialPackage[] memory packages){\n\n    packages = new FinancialPackage[](SInfo.Packages.length);\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n      packages[packageID] = SInfo.Packages[packageID];\n      packages[packageID].CRFIInterestRateDyn = getFinancialCRFIRate(SInfo.Packages[packageID]);\n    }\n    \n    return packages;\n  }\n\n  function GetInvesterFinRecords(address addr)\n    public\n    view\n    returns(QueueData[] memory records){\n\n    uint256 uid = SInfo.InvestAddrID[addr];\n    if(uid == 0){\n      return records;\n    }\n\n    InvestInfo storage uInfo = SInfo.Invests[uid];\n\n    uint256 recordSize = 0;\n\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n      ChainQueue storage chain = uInfo.InvestRecords[packageID];\n      recordSize = recordSize.add(chain.Size);\n    }\n\n    records = new QueueData[](recordSize);\n    uint256 id = 0;\n    \n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n      ChainQueue storage chain = uInfo.InvestRecords[packageID];\n      if(chain.Size == 0){\n        continue;\n      }\n\n      ChainItem storage item = SInfo.ChainM.GetFirstItem(chain);\n      for(;;){\n        records[id] = item.Data;\n        id++;\n\n        if(!SInfo.ChainM.HasNext(item)){\n          break;\n        }\n\n        item = SInfo.ChainM.Next(item);\n      }\n    }\n    \n    return records;\n  }\n\n\n  function GetSystemInfo()\n    public\n    view\n    returns(SystemInfoView memory sInfoView){\n\n    sInfoView.AffRate = SInfo.AffRate;\n    sInfoView.AffRequire = SInfo.AffRequire;\n    sInfoView.EnableAffCFil = SInfo.EnableAffCFil;\n    sInfoView.NewInvestID = SInfo.NewInvestID;\n    sInfoView.nowInvestCRFI = SInfo.nowInvestCRFI;\n    sInfoView.nowInvestCFil = SInfo.nowInvestCFil;\n    sInfoView.cfilInterestPool = SInfo.cfilInterestPool;\n    sInfoView.crfiInterestPool = SInfo.crfiInterestPool;\n\n    sInfoView.cfilLendingTotal = SInfo.cfilLendingTotal;\n    sInfoView.crfiRewardTotal = SInfo.crfiRewardTotal;\n    sInfoView.avaiCFilAmount = SInfo.avaiCFilAmount;\n  \n    sInfoView.totalWeightCFil = SInfo.totalWeightCFil;\n    sInfoView.totalWeightCRFI = SInfo.totalWeightCRFI;\n    sInfoView.crfiMinerPerDayCFil = SInfo.crfiMinerPerDayCFil;\n    sInfoView.crfiMinerPerDayCRFI = SInfo.crfiMinerPerDayCRFI;\n  \n    sInfoView.ParamUpdateTime = SInfo.ParamUpdateTime;\n\n    return sInfoView;\n  }\n\n  function GetPackages()\n    public\n    view\n    returns(FinancialPackage[] memory financialPackages,\n            LoanCFilPackage memory loanCFil){\n\n    return (GetFinancialPackage(),\n            SInfo.LoanCFil);\n  }\n\n\n  function GetInvestRecords(address addr)\n    public\n    view\n    returns(QueueData[] memory records,\n            LoanInvest memory loanInvest,\n            InterestDetail[] memory interestDetail){\n\n    uint256 uid = SInfo.InvestAddrID[addr];\n    if(uid == 0){\n      return (records, loanInvest, interestDetail);\n    }\n\n    InvestInfo storage uInfo = SInfo.Invests[uid];\n\n    records = GetInvesterFinRecords(addr);\n    interestDetail = new InterestDetail[](records.length+1);\n\n    uint256 id = 0;\n    for(; id < records.length; id++){\n      (interestDetail[id].crfiInterest, interestDetail[id].cfilInterest) = _calcInvestFinancial(records[id].PackageID, records[id].Amount, records[id].ParamCRFI, records[id].ParamCFil);\n    }\n\n    interestDetail[id].cfilInterest = calcInvestLoanStatus(uInfo);\n    interestDetail[id].cfilInterest = interestDetail[id].cfilInterest.add(uInfo.LoanCFil.NowInterest);\n\n    return(records,\n           uInfo.LoanCFil,\n           interestDetail);\n  }\n\n  function GetInvestInfo(uint256 uid, address addr)\n    public\n    view\n    returns(bool admin,\n            InvestInfoView memory uInfoView){\n    if(uid == 0){\n      uid = SInfo.InvestAddrID[addr];\n    }\n\n    if(uid == 0){\n      if(addr != address(0x0)){\n        admin = (SInfo.SuperAdmin == addr) || (SInfo.Admins[addr]);\n      }\n      return (admin,\n              uInfoView);\n    }\n    \n    InvestInfo storage uInfo = SInfo.Invests[uid];\n\n    admin = (SInfo.SuperAdmin == uInfo.Addr) || (SInfo.Admins[uInfo.Addr]);\n\n    uInfoView.Addr = uInfo.Addr;\n    uInfoView.ID = uInfo.ID;\n    uInfoView.affID = uInfo.affID;\n    uInfoView.totalAffTimes = uInfo.totalAffTimes;\n    uInfoView.totalAffPackageTimes = uInfo.totalAffPackageTimes;\n    uInfoView.totalAffCRFI = uInfo.totalAffCRFI;\n    uInfoView.totalAffCFil = uInfo.totalAffCFil;\n    uInfoView.nowInvestFinCRFI = uInfo.nowInvestFinCRFI;\n    uInfoView.nowInvestFinCFil = uInfo.nowInvestFinCFil;\n\n    return (admin,\n            uInfoView);\n  }\n\n  function calcSFilToCFil(uint256 sfil)\n    public\n    view\n    returns(uint256 cfil){\n    cfil = sfil.mul(SInfo.LoanCFil.PledgeRate) / Decimal;\n    return cfil;\n  }\n\n  function calcCFilToSFil(uint256 cfil)\n    public\n    view\n    returns(uint256 sfil){\n\n    sfil = cfil.mul(Decimal) / SInfo.LoanCFil.PledgeRate;\n    return sfil;\n  }\n  \n  //////////////////// for debug\n\n  function getChainMDetail()\n    public\n    view\n    returns(ChainManager memory chaimM){\n\n    return SInfo.ChainM;\n  }\n\n  function getInvestChainDetail(uint256 id)\n    public\n    view\n    returns(ChainQueue[] memory chains){\n\n    InvestInfo storage uInfo = SInfo.Invests[id];\n\n    chains = new ChainQueue[](SInfo.Packages.length);\n\n    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n      chains[packageID] = uInfo.InvestRecords[packageID];\n    }\n\n    return chains;\n  }\n  \n  //////////////////// internal func\n  function _repayLoanCFil(address from,\n                          uint256 cfilAmount)\n    internal{\n    require(cfilAmount > 0, \"no cfil amount\");\n    require(msg.sender == address(CFil), \"not cfil coin type\");\n\n    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];\n    updateInvesterLoanCFil(uInfo);\n\n    // deal interest\n    uint256 repayInterest = cfilAmount;\n    if(uInfo.LoanCFil.NowInterest < cfilAmount){\n      repayInterest = uInfo.LoanCFil.NowInterest;\n    }\n\n    uInfo.LoanCFil.NowInterest = uInfo.LoanCFil.NowInterest.sub(repayInterest);\n    SInfo.cfilInterestPool = SInfo.cfilInterestPool.add(repayInterest);\n    cfilAmount = cfilAmount.sub(repayInterest);\n\n    // deal lending\n    if(cfilAmount == 0){\n      return;\n    }\n\n    uint256 repayLending = cfilAmount;\n    if(uInfo.LoanCFil.Lending < cfilAmount){\n      repayLending = uInfo.LoanCFil.Lending;\n    }\n\n    uint256 pledge = repayLending.mul(uInfo.LoanCFil.Pledge) / uInfo.LoanCFil.Lending;\n    uInfo.LoanCFil.Lending = uInfo.LoanCFil.Lending.sub(repayLending);\n    uInfo.LoanCFil.Pledge = uInfo.LoanCFil.Pledge.sub(pledge);\n    SInfo.cfilLendingTotal = SInfo.cfilLendingTotal.sub(repayLending);\n    SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.add(repayLending);\n    cfilAmount = cfilAmount.sub(repayLending);\n\n    if(pledge > 0){\n      SFil.send(from, pledge, \"\");\n    }\n    \n    if(cfilAmount > 0){\n      CFil.send(from, cfilAmount, \"\");\n    }\n  }\n  \n  function _loanCFil(address from,\n                     uint256 sfilAmount)\n    internal{\n\n    require(sfilAmount > 0, \"no sfil amount\");\n    require(msg.sender == address(SFil), \"not sfil coin type\");\n\n    uint256 cfilAmount = calcSFilToCFil(sfilAmount);\n    require(cfilAmount <= SInfo.avaiCFilAmount, \"not enough cfil to loan\");\n    require(cfilAmount >= SInfo.LoanCFil.PaymentDue99, \"cfil amount is too small\");\n\n    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];\n    updateInvesterLoanCFil(uInfo);\n    \n    if(uInfo.LoanCFil.Param < SInfo.LoanCFil.Param){\n      uInfo.LoanCFil.Param = SInfo.LoanCFil.Param;\n    }\n    uInfo.LoanCFil.Lending = uInfo.LoanCFil.Lending.add(cfilAmount);\n    uInfo.LoanCFil.Pledge = uInfo.LoanCFil.Pledge.add(sfilAmount);\n\n    SInfo.cfilLendingTotal = SInfo.cfilLendingTotal.add(cfilAmount);\n    SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.sub(cfilAmount);\n\n    CFil.send(from, cfilAmount, \"\");\n    emit loanCFilEvent(from, cfilAmount, sfilAmount);\n  }\n  \n  function _buyFinancialPackage(address from,\n                                uint256 packageID,\n                                address affAddr,\n                                uint256 amount)\n    internal{\n    // check\n    require(amount > 0, \"no amount\");\n    require(packageID < SInfo.Packages.length, \"invalid packageID\");\n    FinancialPackage storage package = SInfo.Packages[packageID];\n    if(package.Type == FinancialType.CRFI){\n      require(msg.sender == address(CRFI), \"not CRFI coin type\");\n    }else if(package.Type == FinancialType.CFil){\n      require(msg.sender == address(CFil), \"not CFil coin type\");\n    } else {\n      revert(\"not avai package type\");\n    }\n\n    updateAllParam();\n    \n    // exec\n    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];    \n\n    uint256 affID = uInfo.affID;\n\n    if(affID == 0 && affAddr != from && affAddr != address(0x0)){\n      uInfo.affID = getUID(affAddr);\n      affID = uInfo.affID;\n    }\n\n    if(package.Days == 0){\n      affID = 0;\n    }\n\n    if(affID != 0){\n      InvestInfo storage affInfo = SInfo.Invests[affID];\n      affInfo.totalAffPackageTimes++;      \n      emit AffBought(affAddr, from, affInfo.totalAffPackageTimes, amount, packageID, block.timestamp); \n    }\n\n    ChainQueue storage recordQ = uInfo.InvestRecords[package.ID];\n\n    ChainItem storage item = SInfo.ChainM.GetAvaiItem();\n\n    item.Data.Type = package.Type;\n    item.Data.PackageID = package.ID;\n    item.Data.Days = package.Days;\n    item.Data.EndTime = block.timestamp.add(package.Days.mul(OneDayTime));\n    item.Data.AffID = affID;\n    item.Data.Amount = amount;\n    item.Data.ParamCRFI = package.ParamCRFI;\n    item.Data.ParamCFil = package.ParamCFil;\n\n    SInfo.ChainM.PushEndItem(recordQ, item);\n\n    ////////// for statistic\n    package.Total = package.Total.add(amount);\n    if(package.Type == FinancialType.CRFI){\n      uInfo.nowInvestFinCRFI = uInfo.nowInvestFinCRFI.add(amount);\n      SInfo.nowInvestCRFI = SInfo.nowInvestCRFI.add(amount);\n      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.add(amount.mul(package.Weight) / Decimal);\n    } else if(package.Type == FinancialType.CFil){\n      uInfo.nowInvestFinCFil = uInfo.nowInvestFinCFil.add(amount);\n      SInfo.nowInvestCFil = SInfo.nowInvestCFil.add(amount);\n      SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.add(amount);\n      SInfo.totalWeightCFil = SInfo.totalWeightCFil.add(amount.mul(package.Weight) / Decimal);\n    }\n  }\n\n  function _withdrawFinancial(InvestInfo storage uInfo, uint256 onlyPackageID, bool only, uint256 maxNum)\n    internal\n    returns(uint256 crfi,\n            uint256 crfiInterest,\n            uint256 cfil,\n            uint256 cfilInterest){\n\n    updateAllParam();\n\n    if(!only){\n      onlyPackageID = 0;\n    }\n\n    if(maxNum == 0){\n      maxNum -= 1;\n    }\n    \n    (uint256 packageID, ChainItem storage item, bool has) = getFirstValidItem(uInfo, onlyPackageID);\n    \n    while(has && maxNum > 0 && (!only || packageID == onlyPackageID)){\n      maxNum--;\n      QueueData storage data = item.Data;\n      FinancialPackage storage package = SInfo.Packages[data.PackageID];\n\n      (uint256 _crfiInterest, uint256 _cfilInterest) = calcInvestFinancial(data);\n      crfiInterest = crfiInterest.add(_crfiInterest);\n      cfilInterest = cfilInterest.add(_cfilInterest);\n\n      addAffCRFI(uInfo, data, _crfiInterest, _cfilInterest);\n\n      if((block.timestamp > data.EndTime && data.Days > 0) || (data.Days ==0 && only)){\n        package.Total = package.Total.sub(data.Amount);\n        if(data.Type == FinancialType.CFil){\n          cfil = cfil.add(data.Amount);\n          SInfo.totalWeightCFil = SInfo.totalWeightCFil.sub(data.Amount.mul(package.Weight) / Decimal);\n        } else {\n          crfi = crfi.add(data.Amount);\n          SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.sub(data.Amount.mul(package.Weight) / Decimal);\n        }\n        SInfo.ChainM.PopPutFirst(uInfo.InvestRecords[packageID]);\n        (packageID, item, has) = getFirstValidItem(uInfo, packageID);\n      } else {\n        data.ParamCRFI = package.ParamCRFI;\n        data.ParamCFil = package.ParamCFil;\n        (packageID, item, has) = getNextItem(uInfo, packageID, item);\n      }\n    }\n\n    return (crfi, crfiInterest, cfil, cfilInterest);\n  }\n        \n  function getUID(address addr) internal returns(uint256 uID){\n    uID = SInfo.InvestAddrID[addr];\n    if(uID != 0){\n      return uID;\n    }\n    \n    SInfo.NewInvestID++;\n    uID = SInfo.NewInvestID;\n\n    InvestInfo storage uInfo = SInfo.Invests[uID];\n    uInfo.Addr = addr;\n    uInfo.ID = uID;\n        \n    SInfo.InvestAddrID[addr] = uID;\n    return uID;\n  }\n\n  function calcSystemLoanStatus()\n    internal\n    view\n    returns(uint256 param){\n\n    if(block.timestamp == SInfo.LoanCFil.UpdateTime){\n      return SInfo.LoanCFil.Param;\n    }\n\n    uint256 diffSec = block.timestamp.sub(SInfo.LoanCFil.UpdateTime);\n\n    param = SInfo.LoanCFil.Param.add(calcInterest(Decimal, SInfo.LoanCFil.APY, diffSec));\n\n    return param;\n  }\n\n  function calcInvestLoanStatus(InvestInfo storage uInfo)\n    internal\n    view\n    returns(uint256 cfilInterest){\n\n    if(uInfo.LoanCFil.Lending == 0){\n      return 0;\n    }\n    \n    uint256 param = calcSystemLoanStatus();\n    if(uInfo.LoanCFil.Param >= param){\n      return 0;\n    }\n    \n    cfilInterest = uInfo.LoanCFil.Lending.mul(param.sub(uInfo.LoanCFil.Param)) / Decimal;\n    \n    return cfilInterest;\n  }\n\n  function updateSystemLoanStatus()\n    internal{\n    uint256 param;\n    param = calcSystemLoanStatus();\n    if(param <= SInfo.LoanCFil.Param){\n      return;\n    }\n\n    SInfo.LoanCFil.Param = param;\n    SInfo.LoanCFil.UpdateTime = block.timestamp;\n  }\n\n  function updateInvesterLoanCFil(InvestInfo storage uInfo)\n    internal{\n    updateSystemLoanStatus();\n    uint256 cfilInterest = calcInvestLoanStatus(uInfo);\n    if(cfilInterest == 0){\n      return;\n    }\n\n    uInfo.LoanCFil.Param = SInfo.LoanCFil.Param;\n    uInfo.LoanCFil.NowInterest = uInfo.LoanCFil.NowInterest.add(cfilInterest);\n  }\n\n  function calcInterest(uint256 amount, uint256 rate, uint256 sec)\n    internal\n    view\n    returns(uint256){\n    \n    return amount.mul(rate).mul(sec) / 365 / OneDayTime / Decimal;    \n  }\n\n  function getFirstValidItem(InvestInfo storage uInfo, uint256 packageID)\n    internal\n    view\n    returns(uint256 newPackageID, ChainItem storage item, bool has){\n    \n    while(packageID < SInfo.Packages.length){\n      ChainQueue storage chain = uInfo.InvestRecords[packageID];\n      if(chain.Size == 0){\n        packageID++;\n        continue;\n      }\n      item = SInfo.ChainM.GetFirstItem(chain);\n      return (packageID, item, true);\n    }\n\n    return (0, SInfo.ChainM.GetNullItem(), false);\n  }\n\n  function getNextItem(InvestInfo storage uInfo,\n                       uint256 packageID,\n                       ChainItem storage item)\n    internal\n    view\n    returns(uint256, ChainItem storage, bool){\n\n    if(packageID >= SInfo.Packages.length){\n      return (0, item, false);\n    }\n\n    if(SInfo.ChainM.HasNext(item)){\n      return (packageID, SInfo.ChainM.Next(item), true);\n    }\n\n    return getFirstValidItem(uInfo, packageID+1);\n  }\n\n  function addAffCRFI(InvestInfo storage uInfo, QueueData storage data, uint256 crfiInterest, uint256 cfilInterest)\n    internal{\n    if(data.Days == 0){\n      return;\n    }\n    \n    uint256 affID = data.AffID;\n    if(affID == 0){\n      return;\n    }\n    InvestInfo storage affInfo = SInfo.Invests[affID];\n    if(affInfo.nowInvestFinCFil < SInfo.AffRequire){\n      return;\n    }\n    \n    uint256 affCRFI = crfiInterest.mul(SInfo.AffRate) / Decimal;\n    uint256 affCFil;\n\n    bool emitFlag;\n    if(affCRFI != 0){\n      emitFlag = true;\n      affInfo.totalAffCRFI = affInfo.totalAffCRFI.add(affCRFI);\n    }\n\n    if(SInfo.EnableAffCFil > 0){\n      affCFil = cfilInterest.mul(SInfo.AffRate) / Decimal;\n      if(affCFil != 0){\n        emitFlag = true;\n        affInfo.totalAffCFil = affInfo.totalAffCFil.add(affCFil);\n      }\n    }\n\n    if(!emitFlag){\n      return;\n    }\n    \n    affInfo.totalAffTimes++;\n    emit AffEvent(affInfo.Addr, uInfo.Addr, affInfo.totalAffTimes, affCRFI, affCFil, data.PackageID, block.timestamp);\n\n    withdrawCoin(affInfo.Addr, 0, affCRFI, 0, affCFil);\n\n  }\n\n  function withdrawCoin(address addr,\n                        uint256 crfi,\n                        uint256 crfiInterest,\n                        uint256 cfil,\n                        uint256 cfilInterest)\n    internal{\n    \n    require(cfil <= SInfo.nowInvestCFil, \"cfil invest now error\");\n    require(cfil <= SInfo.avaiCFilAmount, \"not enough cfil to withdraw\");    \n    require(crfi <= SInfo.nowInvestCRFI, \"crfi invest now error\");\n    \n    if(cfil > 0){\n      SInfo.nowInvestCFil = SInfo.nowInvestCFil.sub(cfil);\n      SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.sub(cfil);\n    }\n\n    if(crfi > 0){\n      SInfo.nowInvestCRFI = SInfo.nowInvestCRFI.sub(crfi);\n    }\n    \n    if(cfilInterest > 0){\n      require(SInfo.cfilInterestPool >= cfilInterest, \"cfil interest pool is not enough\");\n      SInfo.cfilInterestPool = SInfo.cfilInterestPool.sub(cfilInterest);\n      cfil = cfil.add(cfilInterest);\n    }\n\n    if(crfiInterest > 0){\n      require(SInfo.crfiInterestPool >= crfiInterest, \"crfi interest pool is not enough\");\n      SInfo.crfiInterestPool = SInfo.crfiInterestPool.sub(crfiInterest);\n      crfi = crfi.add(crfiInterest);\n      SInfo.crfiRewardTotal = SInfo.crfiRewardTotal.add(crfiInterest);\n    }\n\n    if(cfil > 0){\n      CFil.send(addr, cfil, \"\");\n    }\n\n    if(crfi > 0){\n      CRFI.send(addr, crfi, \"\");\n    }\n  }\n\n  //////////////////// for update param\n  \n  function getFinancialCRFIRate(FinancialPackage storage package)\n    internal\n    view\n    returns(uint256 rate){\n    if(package.Total == 0){\n      return 0;\n    }\n    \n    uint256 x = package.Total.mul(package.Weight);\n    if(package.Type == FinancialType.CRFI){\n      if(SInfo.totalWeightCRFI == 0){\n        return 0;\n      }\n      rate = x.mul(SInfo.crfiMinerPerDayCRFI) / SInfo.totalWeightCRFI;\n    } else {\n      if(SInfo.totalWeightCFil == 0){\n        return 0;\n      }\n      rate = x.mul(SInfo.crfiMinerPerDayCFil) / SInfo.totalWeightCFil;\n    }\n\n    rate = rate.mul(365) / package.Total ;\n    \n    return rate;\n  }\n\n  function calcFinancialParam(FinancialPackage storage package)\n    internal\n    view\n    returns(uint256 paramCRFI,\n            uint256 paramCFil){\n\n    uint256 diffSec = block.timestamp.sub(SInfo.ParamUpdateTime);\n    if(diffSec == 0){\n      return (package.ParamCRFI, package.ParamCFil);\n    }\n\n    paramCFil = package.ParamCFil.add(calcInterest(Decimal, package.CFilInterestRate, diffSec));\n    paramCRFI = package.ParamCRFI.add(calcInterest(Decimal,\n                                                   getFinancialCRFIRate(package),\n                                                   diffSec));\n    return (paramCRFI, paramCFil);\n  }\n\n  function updateFinancialParam(FinancialPackage storage package)\n    internal{\n\n    (package.ParamCRFI, package.ParamCFil) = calcFinancialParam(package);\n  }\n\n  function updateAllParam()\n    internal{\n    if(block.timestamp == SInfo.ParamUpdateTime){\n      return;\n    }\n\n    for(uint256 i = 0; i < SInfo.Packages.length; i++){\n      updateFinancialParam(SInfo.Packages[i]);\n    }\n\n    SInfo.ParamUpdateTime = block.timestamp;\n  }\n\n  function _calcInvestFinancial(uint256 packageID, uint256 amount, uint256 paramCRFI, uint256 paramCFil)\n    internal\n    view\n    returns(uint256 crfiInterest, uint256 cfilInterest){\n    \n    FinancialPackage storage package = SInfo.Packages[packageID];\n\n    (uint256 packageParamCRFI, uint256 packageParamCFil) = calcFinancialParam(package);\n    crfiInterest = amount.mul(packageParamCRFI.sub(paramCRFI)) / Decimal;\n    cfilInterest = amount.mul(packageParamCFil.sub(paramCFil)) / Decimal;\n\n    return(crfiInterest, cfilInterest);\n  }\n\n  function calcInvestFinancial(QueueData storage data)\n    internal\n    view\n    returns(uint256 crfiInterest, uint256 cfilInterest){\n    return _calcInvestFinancial(data.PackageID, data.Amount, data.ParamCRFI, data.ParamCFil);\n  }\n}\n"}}}