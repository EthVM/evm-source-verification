{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SmartCrowdSharing.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.7.1;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract SmartCrowdSharing {\r\n    \r\n    using SafeMath for *;\r\n    \r\n    address public system_owner;\r\n    uint public current_id = 0;\r\n    mapping(uint => uint) private BONUS_A;\r\n    mapping(uint => uint) private BONUS_B;\r\n    mapping(uint => uint) private I_PRICE;\r\n    uint private price_id = 0;\r\n\r\n    struct MemberObject {\r\n        bool is_exist;\r\n        uint member_id;\r\n        address member_address;\r\n        uint sponsor_id;\r\n        address[] downlines;\r\n        uint downline_qty;\r\n        uint create_time;\r\n    }\r\n\r\n    mapping (uint => MemberObject) public map_id_members;\r\n    mapping (address => MemberObject) public map_address_members;\r\n\r\n    event Create_new_member(address indexed _address_member, address indexed _address_sponsor, uint _time);\r\n    event Change_price_index(uint current_index, uint new_index);\r\n    event Sent_sponsor_bonus(address indexed _address_sponsor, address indexed _address_member, uint _level, uint _bonus, uint _time);\r\n    event Get_ethereum_balance(address indexed _system_owner, address indexed _address_member, uint _amount, uint _time);\r\n    event Change_owner(address indexed _current_owner, address indexed _new_owner, uint _time);\r\n\r\n\r\n    constructor() public {\r\n\r\n        BONUS_A[1] = 40;\r\n        BONUS_A[2] = 4;\r\n        BONUS_A[3] = 3;\r\n        BONUS_A[4] = 2;\r\n        BONUS_A[5] = 1;\r\n\r\n        BONUS_B[1] = 3;\r\n        BONUS_B[2] = 3;\r\n        BONUS_B[3] = 3;\r\n        BONUS_B[4] = 3;\r\n        BONUS_B[5] = 3;\r\n        BONUS_B[6] = 3;\r\n        BONUS_B[7] = 3;\r\n        BONUS_B[8] = 3;\r\n        BONUS_B[9] = 3;\r\n        BONUS_B[10] = 3;\r\n\r\n        I_PRICE[1] = 0.1 ether;\r\n        I_PRICE[2] = 0.2 ether;\r\n        I_PRICE[3] = 0.3 ether;\r\n        I_PRICE[4] = 0.4 ether;\r\n        I_PRICE[5] = 0.5 ether;\r\n        I_PRICE[6] = 0.6 ether;\r\n        I_PRICE[7] = 0.7 ether;\r\n        I_PRICE[8] = 0.8 ether;\r\n        I_PRICE[9] = 0.9 ether;\r\n        I_PRICE[10] = 1.0 ether;\r\n\r\n        price_id = 5;\r\n\r\n        system_owner = msg.sender;\r\n\r\n        current_id++;\r\n\r\n        MemberObject memory member;\r\n\r\n        member = MemberObject({\r\n            is_exist: true,\r\n            member_id: current_id,\r\n            member_address: msg.sender,\r\n            sponsor_id: 0,\r\n            downlines: new address[](0),\r\n            downline_qty: 0,\r\n            create_time: block.timestamp\r\n        });\r\n        map_id_members[current_id] = member;\r\n        map_address_members[msg.sender] = member;\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.value != I_PRICE[price_id]) {\r\n            revert('Incorrect value send');\r\n        }\r\n\r\n        if (map_address_members[msg.sender].is_exist) {\r\n            revert('Cancel transaction, the account is already exist');\r\n        }\r\n\r\n        uint from_id = 0;\r\n\r\n        address sponsor_address = bytes_address(msg.data);\r\n\r\n        if (map_address_members[sponsor_address].is_exist) {\r\n            from_id = map_address_members[sponsor_address].sponsor_id;\r\n        } else {\r\n            revert('Incorrect sponsor');\r\n        }\r\n\r\n        new_member(from_id);\r\n    }\r\n\r\n    function new_member(uint from_id) public payable {\r\n        require(!map_address_members[msg.sender].is_exist, 'This account is already exist');\r\n        require(from_id > 0 && from_id <= current_id, 'Incorrect sponsor id');\r\n        require(msg.value == I_PRICE[price_id], 'Incorrect value send');\r\n\r\n        uint time_now = block.timestamp;\r\n\r\n        MemberObject memory member;\r\n        current_id++;\r\n\r\n        member = MemberObject({\r\n            is_exist: true,\r\n            member_id: current_id,\r\n            member_address: msg.sender,\r\n            sponsor_id: from_id,\r\n            downlines: new address[](0),\r\n            downline_qty: 0,\r\n            create_time: time_now\r\n        });\r\n        map_id_members[current_id] = member;\r\n        map_address_members[msg.sender] = member;\r\n\r\n        map_id_members[from_id].downlines.push(msg.sender);\r\n        map_id_members[from_id].downline_qty++;\r\n\r\n        uint sponsor_id = from_id;\r\n        uint level = 1;\r\n        uint not_found = 0;\r\n\r\n        uint percent = 0;\r\n        uint256 amount = I_PRICE[price_id];\r\n        uint256 bonus = 0;\r\n        uint256 bonus_paid = 0;\r\n        uint256 amount_balance = 0;\r\n\r\n        while (level <= 10 && not_found == 0) {\r\n            if (map_id_members[sponsor_id].is_exist) {\r\n\r\n                // Calculate bonus\r\n                percent = 0;\r\n                if (level <= 5) {\r\n                    percent = BONUS_A[level];\r\n                }\r\n                if (map_id_members[sponsor_id].downline_qty >= 5) {\r\n                    percent += BONUS_B[level];\r\n                } else if (map_id_members[sponsor_id].downline_qty >= 4) {\r\n                    if (level <= 8) {\r\n                        percent += BONUS_B[level];\r\n                    }\r\n                } else if (map_id_members[sponsor_id].downline_qty >= 3) {\r\n                    if (level <= 6) {\r\n                        percent += BONUS_B[level];\r\n                    }\r\n                } else if (map_id_members[sponsor_id].downline_qty >= 2) {\r\n                    if (level <= 4) {\r\n                        percent += BONUS_B[level];\r\n                    }\r\n                } else if (map_id_members[sponsor_id].downline_qty >= 1) {\r\n                    if (level <= 2) {\r\n                        percent += BONUS_B[level];\r\n                    }\r\n                }\r\n\r\n                bonus = amount.mul(percent).div(100);\r\n\r\n                if (bonus > 0) {\r\n                    bonus_paid = bonus_paid.add(bonus);\r\n                    pay_sponsor_bonus(level, bonus, map_id_members[sponsor_id].member_address);\r\n                }\r\n\r\n                // Next upline\r\n                sponsor_id = map_id_members[sponsor_id].sponsor_id;\r\n                if (sponsor_id == 0) {\r\n                    not_found = 1;\r\n                }\r\n            } else {\r\n                not_found = 1;\r\n            }\r\n            level++;\r\n        }\r\n\r\n        bool is_sent = false;\r\n        amount_balance = amount.sub(bonus_paid);\r\n        is_sent = address(uint160(system_owner)).send(amount_balance);\r\n        if (is_sent) {\r\n            emit Get_ethereum_balance(system_owner, msg.sender, amount_balance, time_now);\r\n        }\r\n        emit Create_new_member(msg.sender, map_id_members[from_id].member_address, time_now);\r\n    }\r\n\r\n    function pay_sponsor_bonus(uint _level, uint _bonus, address _sponsor_address) internal {\r\n        bool is_sent = false;\r\n        is_sent = address(uint160(_sponsor_address)).send(_bonus);\r\n        if (is_sent) {\r\n            emit Sent_sponsor_bonus(_sponsor_address, msg.sender, _level, _bonus, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function bytes_address(bytes memory data) private pure returns (address sponsor_address) {\r\n        assembly {\r\n            sponsor_address := mload(add(data, 20))\r\n        }\r\n    }\r\n\r\n    function change_price_index(uint new_index) external {\r\n        require(msg.sender == system_owner, \"Reserved function\");\r\n        _change_price_index(new_index);\r\n    }\r\n\r\n    function _change_price_index(uint new_index) internal {\r\n        require(new_index >= 1 && new_index <= 10, \"Incorrect index\");\r\n        emit Change_price_index(price_id, new_index);\r\n        price_id = new_index;\r\n    }\r\n\r\n    function get_price_index() public view returns (uint) {\r\n        return price_id;\r\n    }\r\n\r\n    function get_current_price() public view returns(uint) {\r\n        return I_PRICE[price_id];\r\n    }\r\n\r\n    function transfer_owner(address new_owner) external {\r\n        require(msg.sender == system_owner,\"Reserved function\");\r\n        _transfer_owner(new_owner);\r\n    }\r\n\r\n    function _transfer_owner(address new_owner) internal {\r\n        require(new_owner != address(0), \"New owner is not zero address\");\r\n        emit Change_owner(system_owner, new_owner, block.timestamp);\r\n        system_owner = new_owner;\r\n    }\r\n}"
    }
  }
}