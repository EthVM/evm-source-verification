{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GSwap.sol":{"content":"/////////NO Presale\r\n/////////Official website: https://gswap.finance\r\n/////////Circulating supply: 100 GSwap\r\n/////////Max Supply: 300 GSwap\r\n/////////The first Liquidity is Locked. check the unicrypt\r\n//...........................................................................................\r\n//.....GGGGGGG..........SSSSSSS....... WWW..WWWWW...WWW ........AAAAA..........PPPPPPPPP....\r\n//...GGGGGGGGGG........SSSSSSSSS....... WWW..WWWWW..WWWW.........AAAAA..........PPPPPPPPPP...\r\n//..GGGGGGGGGGGG.......SSSSSSSSSS...... WWW..WWWWWW.WWWW........AAAAAA..........PPPPPPPPPPP..\r\n//..GGGGG..GGGGG...... SSSS..SSSS...... WWW.WWWWWWW.WWWW........AAAAAAA.........PPPP...PPPP..\r\n//.GGGGG....GGG....... SSSS............ WWW.WWWWWWW.WWWW.......AAAAAAAA.........PPPP...PPPP..\r\n//.GGGG................SSSSSSS..........WWWWWWWWWWW.WWW........AAAAAAAA.........PPPPPPPPPPP..\r\n//.GGGG..GGGGGGGG.......SSSSSSSSS.......WWWWWWW.WWWWWWW........AAAA.AAAA........PPPPPPPPPP...\r\n//.GGGG..GGGGGGGG.........SSSSSSS.......WWWWWWW.WWWWWWW.......AAAAAAAAAA........PPPPPPPPP....\r\n//.GGGGG.GGGGGGGG............SSSSS......WWWWWWW.WWWWWWW.......AAAAAAAAAAA.......PPPP.........\r\n//..GGGGG....GGGG..... SSS....SSSS......WWWWWWW.WWWWWWW.......AAAAAAAAAAA.......PPPP.........\r\n//..GGGGGGGGGGGG...... SSSSSSSSSSS.......WWWWW...WWWWW.......AAAA....AAAA.......PPPP.........\r\n//...GGGGGGGGGG........SSSSSSSSSS........WWWWW...WWWWW.......AAAA.....AAAA......PPPP.........\r\n//.....GGGGGGG..........SSSSSSSS.........WWWWW...WWWWW...... AAAA.....AAAA......PPPP.........\r\n//...........................................................................................\r\n\r\npragma solidity ^0.5.12;\r\ncontract ERC20Interface {\r\n    \r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Claim(address indexed _gamer,uint256 _value);\r\n    event plant(address indexed _gamer);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function sync() external;\r\n\r\n}\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n    \r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\ncontract GSwap is ERC20Interface {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n    uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n    mapping (address => uint256) public balances;\r\n    \r\n\r\n    \r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    \r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;     \r\n    address private _owner;\r\n    uint private LastPlantTime;\r\n    uint private PlantStep=12*3600;\r\n    address PairAddress;   //the uniswap pair address\r\n    \r\n    uint256 private MaxSupply=300*10**18;\r\n    \r\n    uint8 private TreesAge=30;\r\n    uint8 private MaxTrees=16;\r\n    uint private TreePrice=10**18;\r\n    uint private Ctransactions=400;\r\n    uint8 private LiqPercentage=10;\r\n    uint private FruitReward=10**16;\r\n    uint256 private ClaimCommand=123*10**14;\r\n    uint256 private plantCommand=12*10**15;\r\n\r\n    uint256 Transactions=0;\r\n    \r\n    struct tree{\r\n        address owner;\r\n        uint planttime;\r\n        uint LastClaimCount;\r\n    }\r\n    \r\n    tree[] Farms;\r\n    constructor() public {\r\n        decimals = 18;                   \r\n        totalSupply = 100*10**uint256(decimals);\r\n        balances[msg.sender] = 70*10**uint256(decimals);\r\n        SetDevBalances();\r\n        LastPlantTime=block.timestamp - 12*3600;\r\n        _owner = msg.sender;\r\n        name = \"GSwap.finance\";                                                              \r\n        symbol = \"GSwap\";                               \r\n    }\r\n   function SetGameParams(uint8 _TreesAge,uint _Ctransactions,uint8 _LiqPercentage,uint _FruitReward,uint _PlantStep,uint8 _MaxTrees,uint _TreePrice) external onlyOwner {\r\n       TreesAge=_TreesAge;\r\n       Ctransactions=_Ctransactions;\r\n       LiqPercentage=_LiqPercentage;\r\n       FruitReward=_FruitReward;\r\n       PlantStep=_PlantStep;\r\n       MaxTrees=_MaxTrees;\r\n       TreePrice=_TreePrice;\r\n   }\r\n   function SetGameCommands(uint256 _ClaimCommand,uint256 _plantCommand) external onlyOwner\r\n   {\r\n       ClaimCommand=_ClaimCommand;\r\n       plantCommand=_plantCommand;\r\n   }\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    function CheckLiquidityPercentage(address _adr,uint8 _LiqPercent) public view returns(bool)\r\n    {\r\n        uint LQPercent=ERC20Interface(PairAddress).balanceOf(_adr)*100/ERC20Interface(PairAddress).totalSupply();\r\n        if(LQPercent >= _LiqPercent){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    function CheckBeforeClaim(address _gamer) internal\r\n    {\r\n       for(uint i=0;i<Farms.length;i++){\r\n               if(!CheckLiquidityPercentage(Farms[i].owner,LiqPercentage)){ \r\n                    if(Farms[i].planttime+TreesAge*24*3600<block.timestamp){\r\n                        Farms[i].owner=_gamer;\r\n                        Farms[i].planttime=block.timestamp;\r\n                        Farms[i].LastClaimCount=Transactions;\r\n                    }\r\n               }\r\n        }\r\n    }\r\n    function ClaimFruits(address _gamer) internal \r\n    {\r\n        uint8 _trees;\r\n        uint _Fruits;\r\n        (_trees,_Fruits)=GetFarmData(_gamer);\r\n        if(_Fruits>0){\r\n            uint Rewards=_Fruits*FruitReward;\r\n            if(totalSupply<MaxSupply-Rewards){\r\n                for(uint i=0;i<Farms.length;i++){\r\n                    if(Farms[i].owner==_gamer) {\r\n                       Farms[i].LastClaimCount=Transactions;\r\n                    }\r\n                }\r\n                balances[_gamer]=balances[_gamer].add(Rewards);\r\n                totalSupply=totalSupply.add(Rewards);\r\n                emit Transfer(address(0),_gamer,Rewards);\r\n                emit Claim(_gamer,Rewards);\r\n            }\r\n        }\r\n    }\r\n    function BurnOnpair(uint _val) external onlyOwner{\r\n        require(_val<balances[PairAddress]);\r\n        balances[PairAddress]=balances[PairAddress].sub(_val);\r\n        totalSupply=totalSupply.sub(_val);\r\n        IUniswapV2Pair(PairAddress).sync();\r\n        emit Transfer(PairAddress,address(0),_val);\r\n        \r\n    }\r\n    function Burn(uint _val) external{\r\n        balances[msg.sender]=balances[msg.sender].sub(_val);\r\n        totalSupply=totalSupply.sub(_val);\r\n        emit Transfer(msg.sender,address(0),_val);\r\n    }\r\n\r\n    function Plant(address _gamer,bool isBuy) internal{\r\n        uint8 _trees;\r\n        uint _fruits;\r\n        (_trees,_fruits)=GetFarmData(_gamer);\r\n        if(_trees <= MaxTrees){\r\n            if(!isBuy){\r\n                if(CheckLiquidityPercentage(_gamer,LiqPercentage)){\r\n                    if(_trees<1){\r\n                        Farms.push(tree(_gamer,block.timestamp-TreesAge*24*3600,Transactions));\r\n                        emit plant(_gamer);\r\n                    }\r\n                }else{\r\n                    if(block.timestamp - LastPlantTime > PlantStep){\r\n                        LastPlantTime=block.timestamp;\r\n                        Farms.push(tree(_gamer,block.timestamp,Transactions));\r\n                        emit plant(_gamer);\r\n                    }\r\n                }\r\n            }else{\r\n                 Farms.push(tree(_gamer,block.timestamp,Transactions));\r\n                 emit plant(_gamer);\r\n            }\r\n        }\r\n    }\r\n    function BuyTree() external{\r\n        require(balances[msg.sender]>TreePrice,\"You don't have enough gswap to buy a tree.\");\r\n        balances[msg.sender]=balances[msg.sender].sub(TreePrice);\r\n        totalSupply=totalSupply.sub(TreePrice);\r\n        Plant(msg.sender,true);\r\n        emit Transfer(msg.sender,address(0),TreePrice);\r\n    }\r\n    function SetPairAddress(address _pair) external onlyOwner{\r\n        PairAddress=_pair;\r\n    }\r\n    \r\n    function GetFarmData(address _gamer) public view returns(uint8,uint){\r\n        uint Fruits=0;\r\n        uint8 trees=0;\r\n        for(uint i=0;i<Farms.length;i++){\r\n            if(Farms[i].owner==_gamer) {\r\n                uint Fcount=(Transactions.sub(Farms[i].LastClaimCount))/Ctransactions;\r\n                Fruits+=Fcount;\r\n                trees++;\r\n            }\r\n        }\r\n        return(trees,Fruits);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _owner = newOwner;\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    //10 Percent of max supply for the devs.\r\n    function SetDevBalances() internal{\r\n        balances[0x903Ac7e443220C3c5773aD827cAE47CA265462F5] = 10*10**uint256(decimals);\r\n        balances[0x7152C26072645b30c89B8D2fff8745f6f6602C1d] = 10*10**uint256(decimals);\r\n        balances[0x847713dc4FdAbA0C3CcB525903819f972EE8EA48] = 10*10**uint256(decimals);\r\n\r\n    }\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] =balances[msg.sender].sub(_value);\r\n        balances[_to] =balances[_to].add(_value);\r\n        AfterTransfer(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        \r\n        \r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] =balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(_value);\r\n        }\r\n        AfterTransfer(_from, _to, _value);\r\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n    \r\n    function AfterTransfer(address _from, address _to, uint256 _value) private {\r\n        if(_from == PairAddress || _to == PairAddress){\r\n            if(_from == PairAddress){\r\n                if(!_to.isContract()){\r\n                    CheckBeforeClaim(_to);\r\n                    \r\n                    if(_value==ClaimCommand){\r\n                        ClaimFruits(_to);\r\n                    }\r\n                    if(_value==plantCommand){\r\n                        Plant(_to,false);\r\n                    }\r\n                }\r\n            }\r\n            Transactions++;\r\n        }\r\n    }\r\n    function balanceOf(address _user) public view returns (uint256 balance) {\r\n        return balances[_user];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _user, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_user][_spender];\r\n    }\r\n\r\n}"}}}