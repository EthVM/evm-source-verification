{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Escrow.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n//Copied from OZ contracts\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n//Wrap around Aave oracle\r\ninterface IPriceOracleGetter {\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n\r\n//Copied from OZ contracts\r\nlibrary SafeERC20 {\r\n   \r\n    function verifyCallResult(bool success,bytes memory returndata,string memory errorMessage) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function safeTransfer(IERC20 token,address to,uint256 value) internal {\r\n        require(isContract(address(token)), \"Call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(abi.encodeWithSelector(token.transfer.selector, to, value));\r\n        bytes memory returnedData = verifyCallResult(success, returndata, \"Call reverted\");\r\n        if (returnedData.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token,address from,address to,uint256 value) internal {\r\n        require(isContract(address(token)), \"Call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n        bytes memory returnedData = verifyCallResult(success, returndata, \"Call to non-contract\");\r\n        if (returnedData.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract Escrow {\r\n    using SafeERC20 for IERC20;\r\n   \r\n    enum FundingState {\r\n        PAUSED,\r\n        ACTIVE,\r\n        CLOSED,\r\n        REFUND\r\n    }\r\n   \r\n    address public whitelister;\r\n    address public recipient;\r\n    address public owner;\r\n    address public usdc;\r\n    uint256 public lastRecordedETHPrice;\r\n    uint256 public firstWithdrawalLevel;\r\n    uint8 public state;\r\n    bool public isFirstWithdrawalExecuted;\r\n    IPriceOracleGetter public ethUSDCFeed;\r\n\r\n    event USDCDeposited(address indexed payee, uint256 indexed amount);\r\n    event USDCWithdrawn(address indexed payee, uint256 indexed amount);\r\n    event Deposited(address indexed payee, uint256 indexed weiAmount);\r\n    event Withdrawn(address indexed payee, uint256 indexed weiAmount);\r\n    event RemovedReservation(address indexed user, uint256 indexed id);\r\n   \r\n    //Map of registered id with their owners\r\n    mapping(uint256 => address) public reservations;\r\n   \r\n    //Map of whitelisted users\r\n    mapping(address => bool) public whitelistedUsers;\r\n   \r\n    //Assets reserved by each users, it returns an unordered list of reserved IDs\r\n    mapping(address => uint256[]) public userReservedAssets;\r\n    mapping(uint256 => uint256) public assetToIndex;\r\n\r\n    //Track the USDC and ETH deposited by each users (useful for claimbacks)\r\n    mapping(address => uint256) public ethDeposited;\r\n    mapping(uint256 => uint256) public buyingETHPrice;\r\n    mapping(address => uint256) public usdcDeposited;\r\n\r\n    modifier onlyWhitelister {\r\n        require(msg.sender == whitelister, \"Caller is not whitelister\");\r\n        _;\r\n    }\r\n   \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n   \r\n    modifier onlyRecipient {\r\n        require(msg.sender == recipient, \"Caller is not recipient\");\r\n        _;\r\n    }\r\n   \r\n    constructor(\r\n        address _priceOracleGetter, //Aave oracle\r\n        address _whitelister, //Who can whitelist users to buy\r\n        address _usdc, //USDC address to be used on the oracle\r\n        address _recipient //Who can withdraw funds from the contract\r\n    ) {\r\n        whitelister = _whitelister;\r\n        usdc = _usdc;\r\n        owner = msg.sender;\r\n        recipient = _recipient;\r\n        firstWithdrawalLevel = 1050000000000000000000000;\r\n        ethUSDCFeed = IPriceOracleGetter(_priceOracleGetter);\r\n        state = uint8(FundingState.ACTIVE);\r\n       _updateETHPrice();\r\n    }\r\n   \r\n    // Owner restricted functions\r\n   \r\n    function setPaused() public onlyOwner {\r\n        _updateETHPrice();\r\n        state = uint8(FundingState.PAUSED);\r\n    }\r\n   \r\n    function setClosed() public onlyOwner {\r\n        _updateETHPrice();\r\n        state = uint8(FundingState.CLOSED);\r\n    }\r\n   \r\n    function setRefund() public onlyOwner {\r\n        _updateETHPrice();\r\n        state = uint8(FundingState.REFUND);\r\n    }\r\n\r\n    function setActive() public onlyOwner {\r\n        _updateETHPrice();\r\n        state = uint8(FundingState.ACTIVE);\r\n    }\r\n   \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        owner = newOwner;\r\n    }\r\n   \r\n    // Whitelister restricted functions\r\n   \r\n    function whitelist(address user, bool value) public onlyWhitelister {\r\n        _updateETHPrice();\r\n        whitelistedUsers[user] = value;\r\n    }\r\n   \r\n    function whitelistInBatch(address[] memory users, bool[] memory values) public onlyWhitelister {\r\n        _updateETHPrice();\r\n        require(users.length == values.length, \"Length mismatch\");\r\n        for(uint256 i = 0; i < users.length; i++) {\r\n            whitelistedUsers[users[i]] = values[i];\r\n        }\r\n    }\r\n\r\n    // Recipient restricted functions\r\n    function firstWithdraw(address payable receiver, uint256 usdcAmount, uint256 ethInWei) public onlyRecipient {\r\n        require(!isFirstWithdrawalExecuted, \"Already executed\");\r\n\r\n        _updateETHPrice();\r\n        uint256 amount = totalValue();\r\n        uint256 totalToWithdraw = usdcAmount + ethInWei;\r\n\r\n        require(amount >= firstWithdrawalLevel, \"Contract has not recollected enough yet\");\r\n        require(totalToWithdraw <= amount, \"Wrong amount\");\r\n        require(usdcAmount <= IERC20(usdc).balanceOf(address(this)), \"Invalid USDC amount\");\r\n        require(ethInWei <= address(this).balance, \"Invalid ETH amount\");\r\n\r\n        if(usdcAmount > 0) IERC20(usdc).safeTransfer(receiver, usdcAmount);\r\n        if(ethInWei > 0) _sendValue(receiver, ethInWei);\r\n\r\n        isFirstWithdrawalExecuted = true;\r\n\r\n        emit Withdrawn(receiver, amount);\r\n    }\r\n\r\n    function withdrawETH(address payable receiver) public onlyRecipient {\r\n        _updateETHPrice();\r\n        _validateWithdraw();\r\n       \r\n        emit Withdrawn(receiver, address(this).balance);\r\n        _sendValue(receiver, address(this).balance);\r\n    }\r\n   \r\n    function withdrawUSDC(address receiver) public onlyRecipient {\r\n        _updateETHPrice();\r\n        _validateWithdraw();\r\n       \r\n        emit USDCWithdrawn(receiver, IERC20(usdc).balanceOf(address(this)));\r\n        IERC20(usdc).safeTransfer(receiver, IERC20(usdc).balanceOf(address(this)));\r\n    }\r\n   \r\n    function withdrawAll(address payable receiver) public onlyRecipient {\r\n        _updateETHPrice();\r\n        _validateWithdraw();\r\n       \r\n        emit Withdrawn(receiver, address(this).balance);\r\n        emit USDCWithdrawn(receiver, IERC20(usdc).balanceOf(address(this)));\r\n       \r\n        _sendValue(receiver, address(this).balance);\r\n        IERC20(usdc).safeTransfer(receiver, IERC20(usdc).balanceOf(address(this)));\r\n    }\r\n   \r\n    // Public getters functions to retrieve data\r\n   \r\n    function totalValue() public view returns (uint256 funded) {\r\n        uint256 etherAmount = address(this).balance;\r\n        uint256 unit = 1e18;\r\n        uint256 oneEtherPriceInUSD = unit * unit / lastRecordedETHPrice;\r\n        uint256 amountInUSD = etherAmount * oneEtherPriceInUSD / unit;\r\n       \r\n        funded = amountInUSD + IERC20(usdc).balanceOf(address(this))*1e12;\r\n        return funded;\r\n    }\r\n   \r\n    function getReservationOwner(uint256 id) public view returns (address reservationOwner) {\r\n        reservationOwner = reservations[id];\r\n        return reservationOwner;\r\n    }\r\n   \r\n    function getReservedAsset(address user, uint256 index) public view returns (uint256 id) {\r\n        require(index < userReservedAssets[user].length, \"Index out of range\");\r\n        id = userReservedAssets[user][index];\r\n        return id;\r\n    }\r\n   \r\n    function getNumberOfReservedAssets(address user) public view returns (uint256 value) {\r\n        value = userReservedAssets[user].length;\r\n        return value;\r\n    }\r\n   \r\n    function getUSDPrice(uint256 id) public pure returns (uint256) {\r\n        if(id < 7000) return uint256(3500);\r\n        else if(id >= 7000 && id < 19000) return uint256(2900);\r\n        else if(id >= 19000 && id < 29000) return uint256(2500);\r\n        else if(id >= 29000 && id < 41000) return uint256(1600);\r\n        else if(id >= 41000 && id < 58000) return uint256(995);\r\n        else revert(\"ID is out of range\");\r\n    }\r\n   \r\n    function checkIDValidity(uint256 id) public pure returns(bool) {\r\n       \r\n        if (id >= 58000) return false;\r\n         \r\n        uint256 base;\r\n\r\n        if (id < 1000) {\r\n            base = id / 100;\r\n            if (6 <= base) {\r\n                return false;\r\n            }\r\n        } else if (id < 10000) {\r\n            base = ((id / 10) % 100) / 10;\r\n            if (6 <= base) {\r\n                return false;\r\n            }\r\n        } else {\r\n            base = (id / 100) % 10;\r\n            if (6 <= base) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // User interacting functions\r\n\r\n    function buyWithUSDC(uint256 id) public {\r\n        _updateETHPrice();\r\n        _buyWithUSDC(id);\r\n    }\r\n\r\n    function buyWithUSDCBatch(uint256[] memory ids) public {\r\n        _updateETHPrice();\r\n        for(uint i = 0; i < ids.length; i++) {\r\n            buyWithUSDC(ids[i]);\r\n        }\r\n    }\r\n\r\n    function buyWithEther(uint256 id) public payable {\r\n        _updateETHPrice();\r\n        uint256 amount = msg.value;\r\n        uint256 leftover = _buyWithEther(id, amount);\r\n        if(leftover > 0) _sendValue(payable(msg.sender), leftover);\r\n    }\r\n\r\n    function buyWithEtherBatch(uint256[] memory ids) public payable {\r\n        _updateETHPrice();\r\n        uint256 amount = msg.value;\r\n        uint256 leftover;\r\n        for(uint i = 0; i < ids.length; i++) {\r\n            leftover = _buyWithEther(ids[i], amount);\r\n            amount = leftover;\r\n        }\r\n        if(leftover > 0) _sendValue(payable(msg.sender), leftover);\r\n    }\r\n   \r\n    // Create a receive function that reverts to avoid having people sending ETH directly\r\n   \r\n    function claimBackUSDC(uint256 id) public {\r\n        _validateClaimBack(id);\r\n        _updateETHPrice();\r\n       \r\n        uint256 ticketPrice = getUSDPrice(id);\r\n        uint256 usdcUnits = 1e6;\r\n        uint256 priceInERC20Units = ticketPrice * usdcUnits;\r\n       \r\n        require(usdcDeposited[msg.sender] >= priceInERC20Units, \"Insufficient funds\");\r\n\r\n        // Delete reservation and give back to the user his funds for this ID\r\n        usdcDeposited[msg.sender] -= priceInERC20Units;\r\n        _deleteReservation(id);\r\n       \r\n        IERC20(usdc).safeTransfer(msg.sender, priceInERC20Units);\r\n    }\r\n   \r\n    function claimBackETH(uint256 id) public {\r\n        _validateClaimBack(id);\r\n        _updateETHPrice();\r\n       \r\n        uint256 pricePaid = buyingETHPrice[id];\r\n        require(pricePaid > 0, \"No valid reservation\");\r\n        require(pricePaid <= address(this).balance, \"Insufficient funds\");\r\n\r\n        ethDeposited[msg.sender] -= pricePaid;\r\n        buyingETHPrice[id] = 0;\r\n        _deleteReservation(id);\r\n       \r\n        _sendValue(payable(msg.sender), pricePaid);\r\n    }\r\n   \r\n    // internal functions\r\n   \r\n    function _sendValue(address payable receiver, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = receiver.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n   \r\n    function _deleteReservation(uint256 id) internal {\r\n        reservations[id] = address(0);\r\n\r\n        uint256 lastAsset = userReservedAssets[msg.sender][userReservedAssets[msg.sender].length - 1];\r\n        uint256 position = assetToIndex[id];\r\n        userReservedAssets[msg.sender][position] = lastAsset;\r\n        assetToIndex[lastAsset] = position;\r\n        userReservedAssets[msg.sender].pop();         \r\n        assetToIndex[id] = 0;\r\n\r\n        emit RemovedReservation(msg.sender, id);\r\n    }\r\n   \r\n    function _validateWithdraw() internal view {\r\n        require(state == uint8(FundingState.CLOSED), \"System state is not closed\");\r\n    }\r\n   \r\n    function _validateDeposit(uint256 id) internal view {\r\n        require(state == uint8(FundingState.ACTIVE), \"System state is not active\");\r\n        require(whitelistedUsers[msg.sender], \"User is not whitelisted\");\r\n        require(reservations[id] == address(0), \"ID already taken\");\r\n        require(checkIDValidity(id), \"Invalid or reserved ID\");\r\n    }\r\n   \r\n    function _validateClaimBack(uint256 id) internal view {\r\n        require(state == uint8(FundingState.REFUND), \"System state is not in refund\");\r\n        require(whitelistedUsers[msg.sender], \"User is not whitelisted\");\r\n        require(reservations[id] == address(msg.sender), \"Msg sender is not the owner\");\r\n        require(checkIDValidity(id), \"Invalid or reserved ID\");\r\n    }\r\n   \r\n    function _updateETHPrice() internal {\r\n        // This will give USDC price in ETH (wei units)\r\n        // Being 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 the USDC address\r\n        // The value returned is the value in wei of 1 USDC ie 1 usd = 227260770000000\r\n        lastRecordedETHPrice = ethUSDCFeed.getAssetPrice(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    }\r\n\r\n    function _buyWithEther(uint id, uint amount) internal returns(uint256 leftover) {\r\n        require(amount > 0, \"Zero amount not allowed\");\r\n\r\n        _validateDeposit(id);\r\n       \r\n        uint256 unit = 1e18;\r\n        uint256 oneEtherPriceInUSD = unit * unit / lastRecordedETHPrice;\r\n        uint256 amountInUSD = amount * oneEtherPriceInUSD / unit;\r\n\r\n        uint256 ticketPrice = getUSDPrice(id);\r\n\r\n        require(\r\n            amountInUSD >= ticketPrice*unit,\r\n            \"Insufficient ETH amount\"\r\n        );\r\n\r\n        if(amountInUSD > ticketPrice*unit) leftover = ((amountInUSD - ticketPrice*unit)*unit) / oneEtherPriceInUSD;\r\n\r\n        uint deposited = leftover == 0 ? amount : ticketPrice*unit*unit/oneEtherPriceInUSD;\r\n\r\n        reservations[id] = address(msg.sender);\r\n        buyingETHPrice[id] = oneEtherPriceInUSD;\r\n        userReservedAssets[msg.sender].push(id);\r\n        assetToIndex[id] = userReservedAssets[msg.sender].length - 1;\r\n        ethDeposited[msg.sender] += deposited;\r\n        buyingETHPrice[id] = deposited;\r\n\r\n        emit Deposited(msg.sender, deposited);\r\n    }\r\n\r\n    function _buyWithUSDC(uint id) internal {\r\n        _validateDeposit(id);\r\n       \r\n        uint256 ticketPrice = getUSDPrice(id);\r\n        uint256 usdcUnits = 1e6;\r\n        uint256 priceInERC20Units = ticketPrice * usdcUnits;\r\n       \r\n        require(IERC20(usdc).allowance(msg.sender, address(this)) >= priceInERC20Units, \"Contract has not enough allowance\");\r\n       \r\n        IERC20(usdc).safeTransferFrom(msg.sender, address(this), priceInERC20Units);\r\n       \r\n        usdcDeposited[msg.sender] += priceInERC20Units;\r\n        reservations[id] = address(msg.sender);\r\n        userReservedAssets[msg.sender].push(id);\r\n        assetToIndex[id] = userReservedAssets[msg.sender].length - 1;\r\n\r\n        emit USDCDeposited(msg.sender, priceInERC20Units);\r\n    }\r\n}"}}}