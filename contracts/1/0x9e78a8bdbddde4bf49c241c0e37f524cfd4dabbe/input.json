{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/market.sol": {
      "content": "// File: @openzeppelin/contracts/math/SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: contracts/marketplace/MarketplaceStorage.sol\n\npragma solidity ^0.7.6;\n\n\n/**\n * @title Interface for contracts conforming to ERC-20\n */\ninterface ERC20Interface {\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\n}\n\n\n/**\n * @title Interface for contracts conforming to ERC-721\n */\ninterface ERC721Interface {\n  function ownerOf(uint256 _tokenId) external view returns (address _owner);\n  function approve(address _to, uint256 _tokenId) external;\n  function getApproved(uint256 _tokenId) external view returns (address);\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n  function supportsInterface(bytes4) external view returns (bool);\n}\n\n\ninterface ERC721Verifiable is ERC721Interface {\n  function verifyFingerprint(uint256, bytes memory) external view returns (bool);\n}\n\n\ncontract MarketplaceStorage {\n  using Address for address;\n  ERC20Interface public immutable acceptedToken;\n  constructor(address _acceptedToken){\n    require(_acceptedToken.isContract(), \"The accepted token address must be a deployed contract\");\n    acceptedToken = ERC20Interface(_acceptedToken);\n  }\n  struct Order {\n    // Order ID\n    bytes32 id;\n    // Owner of the NFT\n    address seller;\n    // NFT registry address\n    address nftAddress;\n    // Price (in wei) for the published item\n    uint256 price;\n    // Time when this sale ends\n    uint256 expiresAt;\n  }\n\n  // From ERC721 registry assetId to Order (to avoid asset collision)\n  mapping (address => mapping(uint256 => Order)) public orderByAssetId;\n\n  uint256 public ownerCutPerMillion;\n  uint256 public publicationFeeInWei;\n  uint256 public transactionFeePerMillion;\n\n  bytes4 public constant InterfaceId_ValidateFingerprint = bytes4(\n    keccak256(\"verifyFingerprint(uint256,bytes)\")\n  );\n\n  bytes4 public constant ERC721_Interface = bytes4(0x80ac58cd);\n\n  // EVENTS\n  event OrderCreated(\n    bytes32 id,\n    uint256 indexed assetId,\n    address indexed seller,\n    address nftAddress,\n    uint256 priceInWei,\n    uint256 expiresAt\n  );\n  event OrderSuccessful(\n    bytes32 id,\n    uint256 indexed assetId,\n    address indexed seller,\n    address nftAddress,\n    uint256 totalPrice,\n    address indexed buyer\n  );\n  event OrderCancelled(\n    bytes32 id,\n    uint256 indexed assetId,\n    address indexed seller,\n    address nftAddress\n  );\n\n  event ChangedPublicationFee(uint256 publicationFee);\n  event ChangedTransactionFeePerMillion(uint256 transactionFeePerMillion);\n\n  event ChangedOwnerCutPerMillion(uint256 ownerCutPerMillion);\n\n  event SpayMining(\n    bytes32 id,\n    uint256 indexed assetId,\n    address indexed seller,\n    address indexed buyer,\n    address nftAddress,\n    uint256 priceInWei,\n    uint256 minedSpay\n  );\n}\n\n// File: contracts/commons/ContextMixin.sol\n\npragma solidity ^0.7.6;\n\ncontract ContextMixin {\n    function _msgSender()\n        internal\n        view\n        returns (address sender)\n    {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender = msg.sender;\n        }\n        return sender;\n    }\n}\n\n// File: contracts/commons/Ownable.sol\n\npragma solidity ^0.7.6;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is ContextMixin {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/commons/Pausable.sol\n\npragma solidity ^0.7.6;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is ContextMixin {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// File: contracts/commons/EIP712Base.sol\n\npragma solidity ^0.7.6;\n\n\ncontract EIP712Base {\n    struct EIP712Domain {\n        string name;\n        string version;\n        address verifyingContract;\n        bytes32 salt;\n    }\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n        bytes(\n            \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n        )\n    );\n    bytes32 public domainSeparator;\n\n    // supposed to be called once while initializing.\n    // one of the contractsa that inherits this contract follows proxy pattern\n    // so it is not possible to do this in a constructor\n    function _initializeEIP712(\n        string memory name,\n        string memory version\n    )\n        internal\n    {\n        domainSeparator = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                address(this),\n                bytes32(getChainId())\n            )\n        );\n    }\n\n    function getChainId() public view virtual returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * Accept message hash and returns hash message in EIP712 compatible form\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n     * https://eips.ethereum.org/EIPS/eip-712\n     * \"\\\\x19\" makes the encoding deterministic\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\n     */\n    function toTypedMessageHash(bytes32 messageHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, messageHash)\n            );\n    }\n}\n\n// File: contracts/commons/NativeMetaTransaction.sol\n\npragma solidity ^0.7.6;\n\n\ncontract NativeMetaTransaction is EIP712Base {\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\n        bytes(\n            \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\n        )\n    );\n    event MetaTransactionExecuted(\n        address userAddress,\n        address relayerAddress,\n        bytes functionSignature\n    );\n    mapping(address => uint256) nonces;\n\n    /*\n     * Meta transaction structure.\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n     * He should call the desired function directly in that case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) external payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"NMT#executeMetaTransaction: SIGNER_AND_SIGNATURE_DO_NOT_MATCH\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress] + 1;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            msg.sender,\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"NMT#executeMetaTransaction: CALL_FAILED\");\n\n        return returnData;\n    }\n\n    function hashMetaTransaction(MetaTransaction memory metaTx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    META_TRANSACTION_TYPEHASH,\n                    metaTx.nonce,\n                    metaTx.from,\n                    keccak256(metaTx.functionSignature)\n                )\n            );\n    }\n\n    function getNonce(address user) external view returns (uint256 nonce) {\n        nonce = nonces[user];\n    }\n\n    function verify(\n        address signer,\n        MetaTransaction memory metaTx,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) internal view returns (bool) {\n        require(signer != address(0), \"NMT#verify: INVALID_SIGNER\");\n        return\n            signer ==\n            ecrecover(\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\n                sigV,\n                sigR,\n                sigS\n            );\n    }\n}\n\n// File: contracts/marketplace/Marketplace.sol\n\npragma solidity ^0.7.6;\n\n\ncontract Marketplace is Ownable, Pausable, MarketplaceStorage, NativeMetaTransaction {\n  using SafeMath for uint256;\n  using Address for address;\n\n  address immutable sellerAddress;\n\n  /**\n    * @dev Initialize this contract. Acts as a constructor\n    * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\n    * @param _ownerCutPerMillion - owner cut per million\n\n    */\n  constructor (\n    address _acceptedToken,\n    uint256 _ownerCutPerMillion,\n    address _owner,\n    address _seller\n  )  MarketplaceStorage( _acceptedToken)\n  {\n    // EIP712 init\n    _initializeEIP712('SpaceY Marketplace', '1');\n\n    // Fee init\n    setOwnerCutPerMillion(_ownerCutPerMillion);\n\n    require(_owner != address(0), \"Invalid owner\");\n    transferOwnership(_owner);\n\n   \n\n    require(_seller != address(0), \"Invalid seller\");\n    sellerAddress = _seller;\n  }\n\n\n  /**\n    * @dev Sets the publication fee that's charged to users to publish items\n    * @param _publicationFee - Fee amount in wei this contract charges to publish an item\n    */\n  function setPublicationFee(uint256 _publicationFee) external onlyOwner {\n    publicationFeeInWei = _publicationFee;\n    emit ChangedPublicationFee(publicationFeeInWei);\n  }\n\n  function setTransactionFeePerMillion(uint256 _transactionFeePerMillion) external onlyOwner {\n    require(_transactionFeePerMillion < 1000000, \"The transaction fee should be between 0 and 999,999\");\n    transactionFeePerMillion = _transactionFeePerMillion;\n    emit ChangedTransactionFeePerMillion(transactionFeePerMillion);\n  }\n\n  /**\n    * @dev Sets the share cut for the owner of the contract that's\n    *  charged to the seller on a successful sale\n    * @param _ownerCutPerMillion - Share amount, from 0 to 999,999\n    */\n  function setOwnerCutPerMillion(uint256 _ownerCutPerMillion) public onlyOwner {\n    require(_ownerCutPerMillion < 1000000, \"The owner cut should be between 0 and 999,999\");\n\n    ownerCutPerMillion = _ownerCutPerMillion;\n    emit ChangedOwnerCutPerMillion(ownerCutPerMillion);\n  }\n\n  /**\n    * @dev Creates a new order\n    * @param nftAddress - Non fungible registry address\n    * @param assetId - ID of the published NFT\n    * @param priceInWei - Price in Wei for the supported coin\n    * @param expiresAt - Duration of the order (in hours)\n    */\n  function createOrder(\n    address nftAddress,\n    uint256 assetId,\n    uint256 priceInWei,\n    uint256 expiresAt\n  )\n    external\n    whenNotPaused\n  {\n    _createOrder(\n      nftAddress,\n      assetId,\n      priceInWei,\n      expiresAt\n    );\n  }\n\n  /**\n    * @dev Cancel an already published order\n    *  can only be canceled by seller or the contract owner\n    * @param nftAddress - Address of the NFT registry\n    * @param assetId - ID of the published NFT\n    */\n  function cancelOrder(address nftAddress, uint256 assetId) external whenNotPaused {\n    _cancelOrder(nftAddress, assetId);\n  }\n\n  /**\n    * @dev Executes the sale for a published NFT and checks for the asset fingerprint\n    * @param nftAddress - Address of the NFT registry\n    * @param assetId - ID of the published NFT\n    * @param price - Order price\n    * @param fingerprint - Verification info for the asset\n    */\n  function safeExecuteOrder(\n    address nftAddress,\n    uint256 assetId,\n    uint256 price,\n    bytes memory fingerprint\n  )\n   external\n   whenNotPaused\n  {\n    _executeOrder(\n      nftAddress,\n      assetId,\n      price,\n      fingerprint\n    );\n  }\n\n  /**\n    * @dev Executes the sale for a published NFT\n    * @param nftAddress - Address of the NFT registry\n    * @param assetId - ID of the published NFT\n    * @param price - Order price\n    */\n  function executeOrder(\n    address nftAddress,\n    uint256 assetId,\n    uint256 price\n  )\n   external\n   whenNotPaused\n  {\n    _executeOrder(\n      nftAddress,\n      assetId,\n      price,\n      \"\"\n    );\n  }\n\n  /**\n    * @dev Creates a new order\n    * @param nftAddress - Non fungible registry address\n    * @param assetId - ID of the published NFT\n    * @param priceInWei - Price in Wei for the supported coin\n    * @param expiresAt - Duration of the order (in hours)\n    */\n  function _createOrder(\n    address nftAddress,\n    uint256 assetId,\n    uint256 priceInWei,\n    uint256 expiresAt\n  )\n    internal\n  {\n    _requireERC721(nftAddress);\n\n    address sender = _msgSender();\n\n    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\n    address assetOwner = nftRegistry.ownerOf(assetId);\n\n    require(sender == assetOwner, \"Only the owner can create orders\");\n    require(\n      nftRegistry.getApproved(assetId) == address(this) || nftRegistry.isApprovedForAll(assetOwner, address(this)),\n      \"The contract is not authorized to manage the asset\"\n    );\n    require(priceInWei > 0, \"Price should be bigger than 0\");\n    require(expiresAt > block.timestamp.add(1 minutes), \"Publication should be more than 1 minute in the future\");\n\n    bytes32 orderId = keccak256(\n      abi.encodePacked(\n        block.timestamp,\n        assetOwner,\n        assetId,\n        nftAddress,\n        priceInWei\n      )\n    );\n\n    orderByAssetId[nftAddress][assetId] = Order({\n      id: orderId,\n      seller: assetOwner,\n      nftAddress: nftAddress,\n      price: priceInWei,\n      expiresAt: expiresAt\n    });\n\n    // Check if there's a publication fee and\n    // transfer the amount to marketplace owner\n    if (publicationFeeInWei > 0) {\n      require(\n        acceptedToken.transferFrom(sender, owner(), publicationFeeInWei),\n        \"Transfering the publication fee to the Marketplace owner failed\"\n      );\n    }\n\n    emit OrderCreated(\n      orderId,\n      assetId,\n      assetOwner,\n      nftAddress,\n      priceInWei,\n      expiresAt\n    );\n  }\n\n  /**\n    * @dev Cancel an already published order\n    *  can only be canceled by seller or the contract owner\n    * @param nftAddress - Address of the NFT registry\n    * @param assetId - ID of the published NFT\n    */\n  function _cancelOrder(address nftAddress, uint256 assetId) internal returns (Order memory) {\n    address sender = _msgSender();\n    Order memory order = orderByAssetId[nftAddress][assetId];\n\n    require(order.id != 0, \"Asset not published\");\n    require(order.seller == sender || sender == owner(), \"Unauthorized user\");\n\n    bytes32 orderId = order.id;\n    address orderSeller = order.seller;\n    address orderNftAddress = order.nftAddress;\n    delete orderByAssetId[nftAddress][assetId];\n\n    emit OrderCancelled(\n      orderId,\n      assetId,\n      orderSeller,\n      orderNftAddress\n    );\n\n    return order;\n  }\n\n  /**\n    * @dev Executes the sale for a published NFT\n    * @param nftAddress - Address of the NFT registry\n    * @param assetId - ID of the published NFT\n    * @param price - Order price\n    * @param fingerprint - Verification info for the asset\n    */\n  function _executeOrder(\n    address nftAddress,\n    uint256 assetId,\n    uint256 price,\n    bytes memory fingerprint\n  )\n   internal returns (Order memory)\n  {\n    _requireERC721(nftAddress);\n\n    address sender = _msgSender();\n\n    ERC721Verifiable nftRegistry = ERC721Verifiable(nftAddress);\n\n    if (nftRegistry.supportsInterface(InterfaceId_ValidateFingerprint)) {\n      require(\n        nftRegistry.verifyFingerprint(assetId, fingerprint),\n        \"The asset fingerprint is not valid\"\n      );\n    }\n    Order memory order = orderByAssetId[nftAddress][assetId];\n\n    require(order.id != 0, \"Asset not published\");\n\n    address seller = order.seller;\n\n    require(seller != address(0), \"Invalid address\");\n    require(seller != sender, \"Unauthorized user\");\n    require(order.price == price, \"The price is not correct\");\n    require(block.timestamp < order.expiresAt, \"The order expired\");\n    require(seller == nftRegistry.ownerOf(assetId), \"The seller is no longer the owner\");\n\n    uint mineShareAmount = 0;\n\n    bytes32 orderId = order.id;\n    delete orderByAssetId[nftAddress][assetId];\n\n    if (ownerCutPerMillion > 0 && seller == sellerAddress) {\n      // Calculate sale share\n      mineShareAmount = price.mul(ownerCutPerMillion).div(1000000);\n\n      emit SpayMining(\n        orderId,\n        assetId,\n        seller,\n        sender,\n        nftAddress,\n        price,\n        mineShareAmount\n      );\n      \n    }\n\n    if (transactionFeePerMillion >0 && seller != sellerAddress){\n        mineShareAmount=price.mul(transactionFeePerMillion).div(1000000);\n\n        //Transfer transaction fee amount to owner\n        require(\n            acceptedToken.transferFrom(sender, owner(), mineShareAmount),\n            \"Transfering the sale amount to the owner failed\"\n        );\n        price-=mineShareAmount;\n\n        //now use mineShareAmount as mineShareAmount\n        mineShareAmount = mineShareAmount.mul(ownerCutPerMillion).div(1000000);\n        emit SpayMining(\n          orderId,\n          assetId,\n          seller,\n          sender,\n          nftAddress,\n          price,\n          mineShareAmount\n        );\n    }\n\n    // Transfer sale amount to seller\n    require(\n      acceptedToken.transferFrom(sender, seller, price),\n      \"Transfering the sale amount to the seller failed\"\n    );\n\n    // Transfer asset owner\n    nftRegistry.safeTransferFrom(\n      seller,\n      sender,\n      assetId\n    );\n\n    emit OrderSuccessful(\n      orderId,\n      assetId,\n      seller,\n      nftAddress,\n      price,\n      sender\n    );\n\n    return order;\n  }\n\n  function _requireERC721(address nftAddress) internal view {\n    require(nftAddress.isContract(), \"The NFT Address should be a contract\");\n\n    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\n    require(\n      nftRegistry.supportsInterface(ERC721_Interface),\n      \"The NFT contract has an invalid ERC721 implementation\"\n    );\n  }\n}\n"
    }
  }
}