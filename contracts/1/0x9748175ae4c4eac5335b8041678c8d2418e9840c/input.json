{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "./contracts/debt/mozart/MozartStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {IOracle} from \"../../oracle/IOracle.sol\";\n\nimport {Decimal} from \"../../lib/Decimal.sol\";\nimport {Amount} from \"../../lib/Amount.sol\";\n\nimport {MozartTypes} from \"./MozartTypes.sol\";\n\n/**\n * @title MoazartStorage\n * @author Kerman Kohli\n * @notice The storage contract that gets used inside MozartV1.\n *         IMPORTANT:\n *         - DO NOT change the order of ANY variables\n *         - If you would like to add more variables, create a a new\n *           versioned contract (MozartStorageV99) and inherit from\n *           it via MozartStorage\n */\ncontract MozartStorageV1 {\n\n    /**\n     * @notice Determines whether the contract is paused or not\n     */\n    bool public paused;\n\n    /**\n     * @notice An active counter oall the number of positions in the protocol\n     */\n    uint256 public positionCount;\n\n    /**\n     * @dev The details about a vault, identified by a unint256\n     */\n    mapping (uint256 => MozartTypes.Position) internal positions;\n\n    /**\n     * @dev Allow a position have multiple addresses act on it's behalf\n     */\n    mapping (uint256 => mapping (address => bool)) internal positionOperators;\n\n    /**\n     * @dev Allow an address to act on behalf of any position.\n     */\n    mapping (address => bool) internal globalOperators;\n\n    /**\n     * @dev The instance of the oracle that reports prices for this synth\n     */\n    IOracle internal oracle;\n\n    /**\n     * @dev If a colalteral asset is used that has less than 18 decimal places\n     *      a precision scalar is required to calcualte the corect values.\n     */\n    uint256 internal precisionScalar;\n\n    /**\n     * @dev The actual address of the collateral used for this core system.\n     */\n    address internal collateralAsset;\n\n    /**\n     * @dev The address of the synthetic token where this core is approved to mint from\n     */\n    address internal syntheticAsset;\n\n    /**\n     * @dev The actual amount of collateral provided to the protocol. This amount\n     *      will be multiplied by the precision scalar if the token has less than 18 d.p\n     */\n    uint256 internal totalSupplied;\n\n    /**\n     * @dev An account of the total amount being borrowed by all depositors. This includes\n     *      the amount of interest accrued.\n     */\n    uint256 internal totalBorrowed;\n\n    /**\n     * @dev The accumulated borrow index. Each time a borrows, their borrow amount is expressed\n     *      in relation to the borrow index.\n     */\n    uint256 internal borrowIndex;\n\n    /**\n     * @dev The last time the updateIndex() function was called. This helps to determine how much\n     *      interest has accrued in the contract since a user interacted with the protocol.\n     */\n    uint256 internal indexLastUpdate;\n\n    /**\n     * @dev The interest rate charged to borrowers. Expressed as the interest rate per second and 18 d.p\n     */\n    uint256 internal interestRate;\n\n    /**\n     * @dev The ratio of how much collateral should have relative to it's debt\n     */\n    Decimal.D256 internal collateralRatio;\n\n    /**\n     * @dev How much should the liquidation penalty be, expressed as a decimal.\n     */\n    Decimal.D256 internal liquidationUserFee;\n\n    /**\n     * @dev How much of the profit acquired from a liquidation should ARC receive\n     */\n    Decimal.D256 internal liquidationArcRatio;\n\n    /**\n     * @notice Which address can set interest rates for this contract\n     */\n    address public interestSetter;\n\n    /**\n     * @dev The limit of how much collateral can be deposited from this contract.\n     */\n    uint256 internal collateralLimit;\n\n    /**\n     * @dev The amount of collateral a new position should hvae at the minimum\n     */\n    uint256 internal positionCollateralMinimum;\n}\n\ncontract MozartStorage is MozartStorageV1 { /* solium-disable-line no-empty-blocks */ }\n"
    },
    "./contracts/debt/mozart/MozartTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {Math} from \"../../lib/Math.sol\";\nimport {Amount} from \"../../lib/Amount.sol\";\n\nlibrary MozartTypes {\n\n    /* ========== Structs ========== */\n\n    struct Position {\n        address owner;\n        Amount.Principal collateralAmount;\n        Amount.Principal borrowedAmount;\n    }\n\n}\n"
    },
    "./contracts/debt/mozart/MozartV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {ISyntheticToken} from \"../../token/ISyntheticToken.sol\";\nimport {IMintableToken} from \"../../token/IMintableToken.sol\";\nimport {IERC20} from \"../../token/IERC20.sol\";\n\nimport {IOracle} from \"../../oracle/IOracle.sol\";\n\nimport {Adminable} from \"../../lib/Adminable.sol\";\nimport {Decimal} from \"../../lib/Decimal.sol\";\nimport {Math} from \"../../lib/Math.sol\";\nimport {Amount} from \"../../lib/Amount.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\n\nimport {MozartStorage} from \"./MozartStorage.sol\";\nimport {MozartTypes} from  \"./MozartTypes.sol\";\n\n/**\n * @title MoazartV1\n * @author Kerman Kohli\n * @notice This contract holds both the implementation logic and storage (indirectly).\n *         The key optimization of this contract is around simplicity and the actions\n *         a user can call. In addition, the architecture is designed for safety around upgrades\n *         where new storage variables are introduced through the inherited storage contract pattern.\n */\ncontract MozartV1 is Adminable, MozartStorage {\n\n    /* ========== Libraries ========== */\n\n    using SafeMath for uint256;\n    using Math for uint256;\n    using Amount for Amount.Principal;\n\n    /* ========== Constants ========== */\n\n    uint256 constant BASE = 10**18;\n\n    /* ========== Types ========== */\n\n    enum Operation {\n        Open,\n        Borrow,\n        Repay,\n        Liquidate,\n        TransferOwnership\n    }\n\n    struct OperationParams {\n        uint256 id;\n        uint256 amountOne;\n        uint256 amountTwo;\n        address addressOne;\n    }\n\n    /* ========== Events ========== */\n\n    event ActionOperated(\n        uint8 operation,\n        OperationParams params,\n        MozartTypes.Position updatedPosition\n    );\n\n    event ExcessTokensWithdrawn(\n        address token,\n        uint256 amount,\n        address destination\n    );\n\n    event FeesUpdated(\n        Decimal.D256 _liquidationUserFee,\n        Decimal.D256 _liquidationArcRatio\n    );\n\n    event LimitsUpdated(\n        uint256 _collateralLimit,\n        uint256 _positionCollateralMinimum\n    );\n\n    event GlobalOperatorSet(\n        address _operator,\n        bool _status\n    );\n\n    event PositionOperatorSet(\n        uint256 _positionId,\n        address _operator,\n        bool _status\n    );\n\n    event IndexUpdated(\n        uint256 newIndex,\n        uint256 lastUpdateTime\n    );\n\n    event RateUpdated(uint256 value);\n\n    event OracleUpdated(address value);\n\n    event CollateralRatioUpdated(Decimal.D256 value);\n\n    event PrinterUpdated(address value);\n\n    event PauseStatusUpdated(bool value);\n\n    event InterestSetterUpdated(address value);\n\n    /* ========== Modifiers ========== */\n\n    /**\n     * @dev Check if a user is authorized to act on behalf of another user's position.\n     *      Main checks are if:\n     *      - The address is the actual owner of the position\n     *      - The address is a valid global operator\n     *      - The address is a valid operator for that particular position\n     *\n     * @param _positionId The position in question here\n     */\n    modifier isAuthorized(uint256 _positionId) {\n        MozartTypes.Position memory position = positions[_positionId];\n\n        require(\n            position.owner == msg.sender ||\n            isGlobalOperator(msg.sender) ||\n            isPositionOperator(_positionId, msg.sender),\n            \"D2Core: msg.sender is not the owner or position/global operator\"\n        );\n        _;\n    }\n\n    /* ========== Constructor ========== */\n\n    constructor()\n        public\n    {\n        paused = true;\n    }\n\n    /* ========== Admin Setters ========== */\n\n    /**\n     * @dev Intitialise the protocol with the appropriate parameters. Can only be called once.\n     *\n     * @param _collateralDecimals  How many decimals does the collateral contain\n     * @param _collateralAddress   The address of the collateral to be used\n     * @param _syntheticAddress    The address of the synthetic token proxy\n     * @param _oracleAddress       Address of the IOracle conforming contract\n     * @param _interestSetter      Address which can update interest rates\n     * @param _collateralRatio     How much colalteral is needed to borrow\n     * @param _liquidationUserFee  How much is a user penalised if they go below their c-ratio\n     * @param _liquidationArcRatio How much of the liquidation profit should ARC take\n     */\n    function init(\n        uint8   _collateralDecimals,\n        address _collateralAddress,\n        address _syntheticAddress,\n        address _oracleAddress,\n        address _interestSetter,\n        Decimal.D256 memory _collateralRatio,\n        Decimal.D256 memory _liquidationUserFee,\n        Decimal.D256 memory _liquidationArcRatio\n    )\n        public\n    {\n        require(\n            collateralAsset == address(0),\n            \"MozartV1: cannot re-call init()\"\n        );\n\n        precisionScalar = 10 ** (18 - uint256(_collateralDecimals));\n        collateralAsset = _collateralAddress;\n        syntheticAsset = _syntheticAddress;\n\n        borrowIndex = uint256(10**18);\n        indexLastUpdate = currentTimestamp();\n\n        setOracle(_oracleAddress);\n        setCollateralRatio(_collateralRatio);\n        setInterestSetter(_interestSetter);\n\n        setFees(\n            _liquidationUserFee,\n            _liquidationArcRatio\n        );\n    }\n\n    /**\n     * @dev Update the interest rate of the protocol. Since this rate is compounded\n     *      every second rather than being purely linear, the calculate for r is expressed\n     *      as the following (assuming you want 5% APY):\n     *\n     *      r^N = 1.005\n     *      since N = 364 * 24 * 60 * 60 (number of seconds in a year)\n     *      r = 1.000000000158153903837946258002097\n     *      rate = 1000000000158153903 (18 decimal places solidity value)\n     *\n     * @notice Can only be called by the interest setter of the protocol and the maximum\n     *         rate settable by the admin is 99% (21820606489)\n     *\n     * @param _rate The interest rate expressed per second\n     */\n    function setInterestRate(\n        uint256 _rate\n    )\n        public\n    {\n        require(\n            msg.sender == interestSetter,\n            \"MozartV1: only callable by interest setter\"\n        );\n\n        require(\n            _rate <= 21820606489,\n            \"MozartV1: interest rate cannot be set to over 99%\"\n        );\n\n        interestRate = _rate;\n        emit RateUpdated(_rate);\n    }\n\n    /**\n     * @dev Set the instance of the oracle to report prices from. Must conform to IOracle.sol\n     *\n     * @notice Can only be called by the admin of the proxy.\n     *\n     * @param _oracle The address of the IOracle instance\n     */\n    function setOracle(\n        address _oracle\n    )\n        public\n        onlyAdmin\n    {\n        oracle = IOracle(_oracle);\n        emit OracleUpdated(_oracle);\n    }\n\n    /**\n     * @dev Set the collateral ratio of value to debt.\n     *\n     * @notice Can only be called by the admin of the proxy.\n     *\n     * @param _collateralRatio The ratio expressed up to 18 decimal places\n     */\n    function setCollateralRatio(\n        Decimal.D256 memory _collateralRatio\n    )\n        public\n        onlyAdmin\n    {\n        require(\n            _collateralRatio.value < BASE.mul(10) &&\n            _collateralRatio.value > BASE,\n            \"setCollateralRatio(): must be between 100% and 1000%\"\n        );\n\n        collateralRatio = _collateralRatio;\n        emit CollateralRatioUpdated(_collateralRatio);\n    }\n\n    /**\n     * @dev Set the fees in the system.\n     *\n     * @notice Can only be called by the admin of the proxy.\n     *\n     * @param _liquidationUserFee Determines the penalty a user must pay by discounting\n     *                            their collateral to provide a profit incentive for liquidators\n     * @param _liquidationArcRatio The amount ARC earns from the profit earned from the liquidation.\n     */\n    function setFees(\n        Decimal.D256 memory _liquidationUserFee,\n        Decimal.D256 memory _liquidationArcRatio\n    )\n        public\n        onlyAdmin\n    {\n        liquidationUserFee = _liquidationUserFee;\n        liquidationArcRatio = _liquidationArcRatio;\n\n        emit FeesUpdated(\n            liquidationUserFee,\n            liquidationArcRatio\n        );\n    }\n\n    /**\n     * @dev Set the limits of the system to ensure value can be capped.\n     *\n     * @notice Can only be called by the admin of the proxy\n     *\n     * @param _collateralLimit Maximum amount of collateral that can be held in the system.\n     *                         This should be expressed as 18 decimal places since the precision\n     *                         scalar will handle the rest.\n     * @param _positionCollateralMinimum The minimum of collateral per position\n     */\n    function setLimits(\n        uint256 _collateralLimit,\n        uint256 _positionCollateralMinimum\n    )\n        public\n        onlyAdmin\n    {\n        collateralLimit = _collateralLimit;\n        positionCollateralMinimum = _positionCollateralMinimum;\n\n        emit LimitsUpdated(\n            collateralLimit,\n            positionCollateralMinimum\n        );\n    }\n\n    /**\n     * @dev Set the address which can set interest rates\n     *\n     * @notice Can only be called by the admin of the proxy\n     *\n     * @param _setter The address of the new interest rate setter\n     */\n    function setInterestSetter(\n        address _setter\n    )\n        public\n        onlyAdmin\n    {\n        interestSetter = _setter;\n\n        emit InterestSetterUpdated(_setter);\n    }\n\n    /**\n     * @dev Set an address to be able to manage any user's position.\n     *\n     * @notice Can only be called by the admin of the proxy\n     *\n     * @param _operator Address of the new operator\n     * @param _status True indicates they are a valid address, false means they are not\n     */\n    function setGlobalOperatorStatus(\n        address _operator,\n        bool    _status\n    )\n        public\n        onlyAdmin\n    {\n        globalOperators[_operator] = _status;\n\n        emit GlobalOperatorSet(_operator, _status);\n    }\n\n    /* ========== Public Functions ========== */\n\n    /**\n     * @dev Add/remove an address to operate a position on the owner's behalf. This will include\n     *      the ability to borrow and repay on their behalf as well.\n     *\n     * @param _positionId The position to become an operator for\n     * @param _operator The address set to become the operator\n     * @param _status The ability to s\n     */\n    function setPositionOperatorStatus(\n        uint256 _positionId,\n        address _operator,\n        bool    _status\n    )\n        public\n    {\n        MozartTypes.Position memory position = positions[_positionId];\n\n        require(\n            position.owner == msg.sender || isGlobalOperator(msg.sender),\n            \"setPositionOperatorStatus(): must be owner or global operator\"\n        );\n\n        positionOperators[_positionId][_operator] = _status;\n\n        emit PositionOperatorSet(\n            _positionId,\n            _operator,\n            _status\n        );\n    }\n\n    /**\n     * @dev This is the only function that can be called by user's of the system\n     *      and uses an enum and struct to parse the args. This structure guarantees\n     *      the state machine will always meet certain properties\n     *\n     * @param operation An enum of the operation to execute\n     * @param params Parameters to exceute the operation against\n     */\n    function operateAction(\n        Operation operation,\n        OperationParams memory params\n    )\n        public\n    {\n        require(\n            paused == false,\n            \"operateAction(): contracts cannot be paused\"\n        );\n\n        MozartTypes.Position memory operatedPosition;\n\n        // Update the index to calculate how much interest has accrued\n        // And then subsequently mint more of the synth to the printer\n        updateIndex();\n\n        if (operation == Operation.Open) {\n            (operatedPosition, params.id) = openPosition(\n                params.amountOne,\n                params.amountTwo\n            );\n\n            require(\n                params.amountOne >= positionCollateralMinimum,\n                \"operateAction(): must exceed minimum collateral amount\"\n            );\n        } else if (operation == Operation.Borrow) {\n            operatedPosition = borrow(\n                params.id,\n                params.amountOne,\n                params.amountTwo\n            );\n        } else if (operation == Operation.Repay) {\n            operatedPosition = repay(\n                params.id,\n                params.amountOne,\n                params.amountTwo\n            );\n        } else if (operation == Operation.Liquidate) {\n            operatedPosition = liquidate(\n                params.id\n            );\n        } else if (operation == Operation.TransferOwnership) {\n            operatedPosition = transferOwnership(\n                params.id,\n                params.addressOne\n            );\n        } else {\n            revert(\"operateAction(): invalid action\");\n        }\n\n        // Ensure that the operated action is collateralised again, unless a liquidation\n        // has occured in which case the position might be under-collataralised\n        require(\n            isCollateralized(operatedPosition) == true || operation == Operation.Liquidate,\n            \"operateAction(): the operated position is undercollateralised\"\n        );\n\n        // Ensure the amount supplied is less than the collateral limit of the system\n        require(\n            totalSupplied <= collateralLimit || collateralLimit == 0,\n            \"operateAction(): collateral locked cannot be greater than limit\"\n        );\n\n        // Collateral should never be expressed as negative since it means value has been drained\n        assert(operatedPosition.collateralAmount.sign == true);\n\n        // Debt should never be expressed as positive since it means the protocol is in debt to the user\n        assert(operatedPosition.borrowedAmount.sign == false);\n\n        emit ActionOperated(\n            uint8(operation),\n            params,\n            operatedPosition\n        );\n    }\n\n    /**\n     * @dev Update the index of the contracts to compute the current interest rate.\n     *      This function simply calculates the last time this function was called\n     *      (in seconds) then multiplied by the interest rate. The result is then\n     *      multiplied by the totalBorrowed amount.\n    */\n    function updateIndex()\n        public\n    {\n        if (currentTimestamp() == indexLastUpdate) {\n            return;\n        }\n\n        if (totalBorrowed == 0 || interestRate == 0) {\n            indexLastUpdate = currentTimestamp();\n            emit IndexUpdated(borrowIndex, indexLastUpdate);\n            return;\n        }\n\n        // First we multiply the interest rate (expressed in rate/sec) by the time since\n        // the last update. This result represents the proportional amount of interest to\n        // apply to the system at a whole\n        uint256 interestAccumulated = interestRate.mul(currentTimestamp().sub(indexLastUpdate));\n\n        // Then we multiply the existing index by the newly generated rate so that we can\n        // get a compounded interest rate.\n        // ie. interestAccumulated = 0.1, borrowIndex = 1.1, new borrowIndex = 0.1 + 1.1 = 1.2\n        borrowIndex = borrowIndex.add(interestAccumulated);\n\n        // Update the total borrows based on the proportional rate of interest applied\n        // to the entire system\n        totalBorrowed = totalBorrowed.mul(borrowIndex).div(BASE);\n\n        // Set the last time the index was updated to now\n        indexLastUpdate = currentTimestamp();\n\n        emit IndexUpdated(\n            borrowIndex,\n            indexLastUpdate\n        );\n    }\n\n    /* ========== Admin Functions ========== */\n\n    /**\n     * @dev Withdraw tokens owned by the proxy. This will never include depositor funds\n     *      since all the collateral is held by the synthetic token itself. The only funds\n     *      that will accrue based on CoreV1 & StateV1 is the liquidation fees.\n     *\n     * @param token Address of the token to withdraw\n     * @param destination Destination to withdraw to\n     * @param amount The total amount of tokens withdraw\n     */\n    function withdrawTokens(\n        address token,\n        address destination,\n        uint256 amount\n    )\n        external\n        onlyAdmin\n    {\n        SafeERC20.safeTransfer(\n            IERC20(token),\n            destination,\n            amount\n        );\n    }\n\n    function setPause(bool value)\n        external\n        onlyAdmin\n    {\n        paused = value;\n\n        emit PauseStatusUpdated(value);\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Open a new position.\n     *\n     * @return The new position and the ID of the opened position\n     */\n    function openPosition(\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    )\n        internal\n        returns (MozartTypes.Position memory, uint256)\n    {\n        // CHECKS:\n        // 1. No checks required as it's all processed in borrow()\n\n        // EFFECTS:\n        // 1. Create a new Position struct with the basic fields filled out and save it to storage\n        // 2. Call `borrow()`\n\n        MozartTypes.Position memory newPosition = MozartTypes.Position({\n            owner: msg.sender,\n            collateralAmount: Amount.zero(),\n            borrowedAmount: Amount.zero()\n        });\n\n        // This position is saved to storage to make the logic around borrowing\n        // uniform. This is slightly gas inefficient but ok given the ability to\n        // ensure no diverging logic.\n\n        uint256 positionId = positionCount;\n        positions[positionCount] = newPosition;\n        positionCount = positionCount.add(1);\n\n        newPosition = borrow(\n            positionId,\n            collateralAmount,\n            borrowAmount\n        );\n\n        return (\n            newPosition,\n            positionId\n        );\n    }\n\n    /**\n     * @dev Borrow against an existing position.\n     *\n     * @param positionId ID of the position you'd like to borrow against\n     * @param collateralAmount Collateral deposit amount\n     * @param borrowAmount How much would you'd like to borrow/mint\n     */\n    function borrow(\n        uint256 positionId,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    )\n        private\n        isAuthorized(positionId)\n        returns (MozartTypes.Position memory)\n    {\n        // CHECKS:\n        // 1. Ensure that the position actually exists\n        // 2. Convert the borrow amount to a Principal value\n        // 3. Ensure the position is collateralised before borrowing against it\n        // 4. Ensure that msg.sender == owner of position (done in the modifier)\n        // 5. Determine if there's enough liquidity of the `borrowAsset`\n        // 6. Calculate the amount of collateral actually needed given the `collateralRatio`\n        // 7. Ensure the user has provided enough of the collateral asset\n\n        // EFFECTS:\n        // 1. Increase the collateral amount to calculate the maximum the amount the user can borrow\n        // 2. Calculate the proportional new par value based on the borrow amount\n        // 3. Update the total supplied collateral amount\n        // 4. Calculate the collateral needed and ensuring the position has that much\n\n        // INTERACTIONS:\n        // 1. Mint the synthetic asset\n        // 2. Transfer the collateral to the synthetic token itself.\n        //    This ensures on Etherscan people can see how much collateral is backing\n        //    the synthetic\n\n        // Get the current position\n        MozartTypes.Position storage position = positions[positionId];\n\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\n        // Increase the user's collateral amount & increase the global supplied amount\n        position = setCollateralAmount(\n            positionId,\n            position.collateralAmount.add(\n                Amount.Principal({\n                    sign: true,\n                    value: collateralAmount.mul(precisionScalar)\n                })\n            )\n        );\n\n        // Sometimes a user may want to only deposit more collateral and not borrow more\n        // so in that case we don't need to recheck any borrowing requirements\n        if (borrowAmount > 0) {\n            // Calculate the principal amount based on the current index of the market\n            Amount.Principal memory convertedPrincipal = Amount.calculatePrincipal(\n                borrowAmount,\n                borrowIndex,\n                false\n            );\n\n            // Set the total new borrowed amount. We need to use this function\n            // in order to adjust the total borrowed amount proportionally as well.\n            position = setBorrowAmount(\n                positionId,\n                position.borrowedAmount.add(convertedPrincipal)\n            );\n\n            // Check how much collateral they need based on their new position details\n            Amount.Principal memory collateralRequired = calculateCollateralRequired(\n                position.borrowedAmount.calculateAdjusted(borrowIndex),\n                currentPrice\n            );\n\n            // Ensure the user's collateral amount is greater than the collateral needed\n            require(\n                position.collateralAmount.value >= collateralRequired.value,\n                \"borrowPosition(): not enough collateral provided\"\n            );\n        }\n\n        IERC20 syntheticAsset = IERC20(syntheticAsset);\n        IERC20 collateralAsset = IERC20(collateralAsset);\n\n        // Transfer the collateral asset to the synthetic contract\n        SafeERC20.safeTransferFrom(\n            collateralAsset,\n            msg.sender,\n            address(syntheticAsset),\n            collateralAmount\n        );\n\n        ISyntheticToken(address(syntheticAsset)).mint(\n            msg.sender,\n            borrowAmount\n        );\n\n        return position;\n    }\n\n    /**\n     * @dev Repay money against a borrowed position. When this process occurs the position's\n     *      debt will be reduced and in turn will allow them to withdraw their collateral should they choose.\n     *\n     * @param positionId ID of the position to repay\n     * @param repayAmount Amount of debt to repay\n     * @param withdrawAmount Amount of collateral to withdraw\n     */\n    function repay(\n        uint256 positionId,\n        uint256 repayAmount,\n        uint256 withdrawAmount\n    )\n        private\n        isAuthorized(positionId)\n        returns (MozartTypes.Position memory)\n    {\n        // CHECKS:\n        // 1. Ensure the position actually exists by ensuring the owner == msg.sender (done in the modifier)\n        // 2. The position does not have to be collateralised since we want people to repay\n        //    before a liquidator does if they do actually have a chance\n\n        // EFFECTS:\n        // 1. Calculate the new par value of the position based on the amount they're going to repay\n        // 2. Update the user's borrow amount by calling the setBorrowAmount() function\n        // 3. Calculate how much collateral they can withdraw based on their new borrow amount\n        // 4. Check if the amount being withdrawn is enough given their borrowing requirement\n        // 5. Update the user's collateral amount by calling the setCollateralAmount() function\n\n        // INTERACTIONS:\n        // 1. Burn the synths being repaid directly from their wallet\n        // 2. Transfer the collateral back to the user\n\n        MozartTypes.Position storage position = positions[positionId];\n\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\n\n        uint256 scaledWithdrawAmount = withdrawAmount.mul(precisionScalar);\n\n        // Calculate the principal amount based on the current index of the market\n        Amount.Principal memory convertedPrincipal = Amount.calculatePrincipal(\n            repayAmount,\n            borrowIndex,\n            true\n        );\n\n        // Set the user's new borrow amount by decreasing their debt amount.\n        // A positive par value will increase a negative par value.\n        position = setBorrowAmount(\n            positionId,\n            position.borrowedAmount.add(convertedPrincipal)\n        );\n\n        // Calculate how much the user is allowed to withdraw given their debt was repaid\n        Amount.Principal memory collateralDelta = calculateCollateralDelta(\n            position.collateralAmount,\n            position.borrowedAmount.calculateAdjusted(borrowIndex),\n            currentPrice\n        );\n\n        // Ensure that the amount they are trying to withdraw is less than their limit\n        // Also, make sure that the delta is positive (aka collateralized).\n        require(\n            collateralDelta.sign == true && scaledWithdrawAmount <= collateralDelta.value,\n            \"repay(): cannot withdraw more than allowed\"\n        );\n\n        // Decrease the user's collateral amount by adding a negative principal amount\n        position = setCollateralAmount(\n            positionId,\n            position.collateralAmount.add(\n                Amount.Principal({\n                    sign: false,\n                    value: scaledWithdrawAmount\n                })\n            )\n        );\n\n        ISyntheticToken synthetic = ISyntheticToken(syntheticAsset);\n        IERC20 collateralAsset = IERC20(collateralAsset);\n\n        synthetic.burn(\n            msg.sender,\n            repayAmount\n        );\n\n        // Transfer collateral back to the user\n        bool transferResult = synthetic.transferCollateral(\n            address(collateralAsset),\n            msg.sender,\n            withdrawAmount\n        );\n\n        require(\n            transferResult == true,\n            \"repay(): collateral failed to transfer\"\n        );\n\n        return position;\n    }\n\n    /**\n     * @dev Liquidate a user's position. When this process occurs you're essentially\n     *      purchasing the users's debt at a discount (liquidation spread) in exchange\n     *      for the collateral they have deposited inside their position.\n     *\n     * @param positionId ID of the position to liquidate\n     */\n    function liquidate(\n        uint256 positionId\n    )\n        private\n        returns (MozartTypes.Position memory)\n    {\n        // CHECKS:\n        // 1. Ensure that the position is valid (check if there is a non-0x0 owner)\n        // 2. Ensure that the position is indeed undercollateralized\n\n        // EFFECTS:\n        // 1. Calculate the liquidation price based on the liquidation penalty\n        // 2. Calculate how much the user is in debt by\n        // 3. Add the liquidation penalty to the liquidation amount so there's\n        //    a buffer that exists to ensure they can't get liquidated again\n        // 4. If the collateral to liquidate is greater than the collateral, bound it.\n        // 5. Calculate how much of the borrowed asset is to be liquidated\n        // 5. Decrease the user's debt obligation\n        // 6. Decrease the user's collateral amount\n\n        // INTERACTIONS:\n        // 1. Burn the synthetic from the liquidator\n        // 2. Tranfer the collateral from the synthetic token to the liquidator\n        // 3. Transfer a portion to the ARC Core contract as a fee\n\n        MozartTypes.Position storage position = positions[positionId];\n\n        require(\n            position.owner != address(0),\n            \"liquidatePosition(): must be a valid position\"\n        );\n\n        // Ensure that the position is not collateralized\n        require(\n            isCollateralized(position) == false,\n            \"liquidatePosition(): position is collateralised\"\n        );\n\n        // Get the liquidation price of the asset (discount for liquidator)\n        Decimal.D256 memory liquidationPrice = calculateLiquidationPrice();\n\n        // Calculate how much the user is in debt by to be whole again at a discounted price\n        (Amount.Principal memory liquidationCollateralDelta) = calculateCollateralDelta(\n            position.collateralAmount,\n            position.borrowedAmount.calculateAdjusted(borrowIndex),\n            liquidationPrice\n        );\n\n        // Liquidate a slight bit more to ensure the user is guarded against futher price drops\n        liquidationCollateralDelta.value = Decimal.mul(\n            liquidationCollateralDelta.value,\n            Decimal.add(\n                liquidationUserFee,\n                Decimal.one().value\n            )\n        );\n\n        // Calculate how much collateral this is going to cost the liquidator\n        // The sign is negative since we need to subtract from the liquidation delta\n        // which is a negative sign and subtracting a negative will actually add it\n\n        // Calculate the amount of collateral actually needed in order to perform this liquidation.\n        // Since the liquidationUserFee is the penalty, by multiplying (1-fee) we can get the\n        // actual collateral amount needed. We'll ultimately be adding this amount to the\n        // liquidation delta (which is negative) to give us the profit amount.\n        (Amount.Principal memory liquidatorCollateralCost) = Amount.Principal({\n            sign: true,\n            value: Decimal.mul(\n                liquidationCollateralDelta.value,\n                Decimal.sub(\n                    Decimal.one(),\n                    liquidationUserFee.value\n                )\n            )\n        });\n\n        // If the maximum they're down by is greater than their collateral, bound to the maximum\n        // This case will only arise if the position has truly become under-collateralized.\n\n        // This check also ensures that no one can create a position which can drain the system\n        // for more collateral than the position itself has.\n        if (liquidationCollateralDelta.value > position.collateralAmount.value) {\n            liquidationCollateralDelta.value = position.collateralAmount.value;\n\n            // If the the original collateral delta is to be the same as the\n            // collateral amount. What this does is that the profit calculated\n            // will be 0 since the liquidationCollateralDelta less the\n            // originalCollateralDelta will be the same.\n            liquidatorCollateralCost.value = position.collateralAmount.value;\n        }\n\n        // Calculate how much borrowed assets to liquidate (at a discounted price)\n        // We can use the liquidationCollateralDelta.value since it's already using\n        // interest-adjusted values rather than principal values\n        uint256 borrowToLiquidate = Decimal.mul(\n            liquidationCollateralDelta.value,\n            liquidationPrice\n        );\n\n        // Decrease the user's debt amout by the principal amount\n        position = setBorrowAmount(\n            positionId,\n            position.borrowedAmount.add(\n                Amount.calculatePrincipal(\n                    borrowToLiquidate,\n                    borrowIndex,\n                    true\n                )\n            )\n        );\n\n        // Decrease the user's collateral amount by adding the collateral delta (which is negative)\n        position = setCollateralAmount(\n            positionId,\n            position.collateralAmount.add(liquidationCollateralDelta)\n        );\n\n        require(\n            IERC20(collateralAsset).balanceOf(msg.sender) >= borrowToLiquidate,\n            \"liquidatePosition(): msg.sender not enough of borrowed asset to liquidate\"\n        );\n\n        _settleLiquidation(\n            borrowToLiquidate,\n            liquidationCollateralDelta,\n            liquidatorCollateralCost\n        );\n\n        return position;\n    }\n\n    function _settleLiquidation(\n        uint256 borrowToLiquidate,\n        Amount.Principal memory liquidationCollateralDelta,\n        Amount.Principal memory liquidatorCollateralCost\n    )\n        private\n    {\n        ISyntheticToken synthetic = ISyntheticToken(syntheticAsset);\n        IERC20 collateralAsset = IERC20(collateralAsset);\n\n        synthetic.burn(\n            msg.sender,\n            borrowToLiquidate\n        );\n\n        // This is the actual profit collected from the liquidation\n        // Since the liquidationCollateralDelta is negative and liquidationCollateralCost\n        // is a positive value, by adding them the result gives us the profit\n        Amount.Principal memory collateralProfit = liquidationCollateralDelta.add(\n            liquidatorCollateralCost\n        );\n\n        // ARC's profit is simple a percentage of the profit, not net total\n        uint256 arcProfit = Decimal.mul(\n            collateralProfit.value,\n            liquidationArcRatio\n        );\n\n        // Transfer them the collateral assets they acquired at a discount\n        bool userTransferResult = synthetic.transferCollateral(\n            address(collateralAsset),\n            msg.sender,\n            uint256(liquidationCollateralDelta.value).sub(arcProfit).div(precisionScalar)\n        );\n\n        require(\n            userTransferResult == true,\n            \"liquidate(): collateral failed to transfer to user\"\n        );\n\n        // Transfer ARC the collateral asset acquired at a discount\n        bool arcTransferResult = synthetic.transferCollateral(\n            address(collateralAsset),\n            address(this),\n            arcProfit.div(precisionScalar)\n        );\n\n        require(\n            arcTransferResult == true,\n            \"liquidate(): collateral failed to transfer to arc\"\n        );\n    }\n\n    /**\n     * @dev Update a position's collateral amount. This function is used to ensure\n     *      consistency in the total supplied amount as a user's collateral balance changes.\n     *\n     * @param positionId The id of the position to update the collateral amount for\n     * @param newSupplyAmount How much to set their new supply values to\n     */\n    function setCollateralAmount(\n        uint256 positionId,\n        Amount.Principal memory newSupplyAmount\n    )\n        private\n        returns (MozartTypes.Position storage)\n    {\n        MozartTypes.Position storage position = positions[positionId];\n\n        if (position.collateralAmount.equals(newSupplyAmount)) {\n            return position;\n        }\n\n        uint256 newTotalSupplied = totalSupplied;\n\n        // Roll back the old amount\n        newTotalSupplied = newTotalSupplied.sub(position.collateralAmount.value);\n\n        // Roll forward the new amount\n        newTotalSupplied = newTotalSupplied.add(newSupplyAmount.value);\n\n        // Update the total borrowed storage value to the final result\n        totalSupplied = newTotalSupplied;\n\n        // Update the actual position's supplied amount\n        position.collateralAmount = newSupplyAmount;\n\n        // Prevent having collateral represented by negative values\n        if (position.collateralAmount.value == 0) {\n            position.collateralAmount.sign = true;\n        }\n\n        return position;\n    }\n\n    /**\n     * @dev Update a position's borrow amount. This function is used to ensure consistency in the\n     *      total borrowed amount as the user's borrowed amount changes.\n     *\n     * @param positionId The id of the position to update the borrow amount for\n     * @param newBorrowAmount The new borrow amount for the position\n     */\n    function setBorrowAmount(\n        uint256 positionId,\n        Amount.Principal memory newBorrowAmount\n    )\n        private\n        returns (MozartTypes.Position storage)\n    {\n        MozartTypes.Position storage position = positions[positionId];\n        Amount.Principal memory existingAmount = position.borrowedAmount;\n\n        if (position.borrowedAmount.equals(newBorrowAmount)) {\n            return position;\n        }\n\n        uint256 newTotalBorrowed = totalBorrowed;\n\n        // Roll back the old amount\n        newTotalBorrowed = newTotalBorrowed.sub(existingAmount.value);\n\n        // Roll forward the new amount\n        newTotalBorrowed = newTotalBorrowed.add(newBorrowAmount.value);\n\n        // Update the total borrowed storage value to the final result\n        totalBorrowed = newTotalBorrowed;\n\n        // Update the actual position's borrowed amount\n        position.borrowedAmount = newBorrowAmount;\n\n        // Prevent having debt represented by positive values\n        if (position.borrowedAmount.value == 0) {\n            position.borrowedAmount.sign = false;\n        }\n\n        return position;\n    }\n\n    /**\n     * @dev This should allow a user to transfer ownership of a position to a\n     *      a different address to operate their position.\n     *\n     * @param positionId ID of the position to transfer ownership to\n     * @param newOwner New owner of the position to set\n     */\n    function transferOwnership(\n        uint256 positionId,\n        address newOwner\n    )\n        private\n        returns (MozartTypes.Position storage)\n    {\n        MozartTypes.Position storage position = positions[positionId];\n\n        require(\n            msg.sender == position.owner,\n            \"transferOwnership(): must be the owner of the position\"\n        );\n\n        position.owner = newOwner;\n\n        return position;\n    }\n\n    /* ========== Public Getters ========== */\n\n    function getPosition(\n        uint256 id\n    )\n        external\n        view\n        returns (MozartTypes.Position memory)\n    {\n        return positions[id];\n    }\n\n    function getCurrentPrice()\n        external\n        view\n        returns (Decimal.D256 memory)\n    {\n        return oracle.fetchCurrentPrice();\n    }\n\n    function getSyntheticAsset()\n        external\n        view\n        returns (address)\n    {\n        return address(syntheticAsset);\n    }\n\n    function getCollateralAsset()\n        external\n        view\n        returns (address)\n    {\n        return address(collateralAsset);\n    }\n\n    function getCurrentOracle()\n        external\n        view\n        returns (address)\n    {\n        return address(oracle);\n    }\n\n    function getInterestSetter()\n        external\n        view\n        returns (address)\n    {\n        return interestSetter;\n    }\n\n    function getBorrowIndex()\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return (borrowIndex, indexLastUpdate);\n    }\n\n    function getCollateralRatio()\n        external\n        view\n        returns (Decimal.D256 memory)\n    {\n        return collateralRatio;\n    }\n\n    function getTotals()\n        external\n        view\n        returns (\n            uint256,\n            uint256\n        )\n    {\n        return (\n            totalSupplied,\n            totalBorrowed\n        );\n    }\n\n    function getLimits()\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return (collateralLimit, positionCollateralMinimum);\n    }\n\n    function getInterestRate()\n        external\n        view\n        returns (uint256)\n    {\n        return interestRate;\n    }\n\n    function getFees()\n        external\n        view\n        returns (\n            Decimal.D256 memory _liquidationUserFee,\n            Decimal.D256 memory _liquidationArcRatio\n        )\n    {\n        return (\n            liquidationUserFee,\n            liquidationArcRatio\n        );\n    }\n\n    function isPositionOperator(\n        uint256 _positionId,\n        address _operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return positionOperators[_positionId][_operator];\n    }\n\n    function isGlobalOperator(\n        address _operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return globalOperators[_operator];\n    }\n\n    /* ========== Developer Functions ========== */\n\n    function currentTimestamp()\n        public\n        view\n        returns (uint256)\n    {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Check if a position is collateralised or not\n     *\n     * @param position The struct of a position to validate if it's underwater or not\n     */\n    function isCollateralized(\n        MozartTypes.Position memory position\n    )\n        public\n        view\n        returns (bool)\n    {\n        if (position.borrowedAmount.value == 0) {\n            return true;\n        }\n\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\n\n        (Amount.Principal memory collateralDelta) = calculateCollateralDelta(\n            position.collateralAmount,\n            position.borrowedAmount.calculateAdjusted(borrowIndex),\n            currentPrice\n        );\n\n        if (collateralDelta.value == 0) {\n            collateralDelta.sign = true;\n        }\n\n        return collateralDelta.sign;\n    }\n\n    /**\n     * @dev Calculate how much collateral you need given a certain borrow amount\n     *\n     * @param borrowedAmount The borrowed amount expressed as a uint256 (NOT principal)\n     * @param price What price do you want to calculate the inverse at\n     */\n    function calculateCollateralRequired(\n        uint256 borrowedAmount,\n        Decimal.D256 memory price\n    )\n        public\n        view\n        returns (Amount.Principal memory)\n    {\n\n        uint256 inverseRequired = Decimal.div(\n            borrowedAmount,\n            price\n        );\n\n        inverseRequired = Decimal.mul(\n            inverseRequired,\n            collateralRatio\n        );\n\n        return Amount.Principal({\n            sign: true,\n            value: inverseRequired\n        });\n    }\n\n    /**\n     * @dev Given an asset being borrowed, figure out how much collateral can this still borrow or\n     *      is in the red by. This function is used to check if a position is undercolalteralised and\n     *      also to calculate how much can a position be liquidated by.\n     *\n     * @param parSupply The amount being supplied\n     * @param borrowedAmount The non-par amount being borrowed\n     * @param price The price to calculate this difference by\n     */\n    function calculateCollateralDelta(\n        Amount.Principal memory parSupply,\n        uint256 borrowedAmount,\n        Decimal.D256 memory price\n    )\n        public\n        view\n        returns (Amount.Principal memory)\n    {\n        Amount.Principal memory collateralDelta;\n        Amount.Principal memory collateralRequired;\n\n        collateralRequired = calculateCollateralRequired(\n            borrowedAmount,\n            price\n        );\n\n        // If the amount of collateral needed exceeds the par supply amount\n        // then the result will be negative indicating the position is undercollateralised.\n        collateralDelta = parSupply.sub(collateralRequired);\n\n        return collateralDelta;\n    }\n\n    /**\n     * @dev When executing a liqudation, the price of the asset has to be calculated\n     *      at a discount in order for it to be profitable for the liquidator. This function\n     *      will get the current oracle price for the asset and find the discounted price.\n     *\n     */\n    function calculateLiquidationPrice()\n        public\n        view\n        returns (Decimal.D256 memory)\n    {\n        Decimal.D256 memory result;\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\n\n        result = Decimal.sub(\n            Decimal.one(),\n            liquidationUserFee.value\n        );\n\n        result = Decimal.mul(\n            currentPrice,\n            result\n        );\n\n        return result;\n    }\n}\n"
    },
    "./contracts/lib/Adminable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Storage } from \"./Storage.sol\";\n\n/**\n * @title Adminable\n * @author dYdX\n *\n * @dev EIP-1967 Proxy Admin contract.\n */\ncontract Adminable {\n    /**\n     * @dev Storage slot with the admin of the contract.\n     *  This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n    * @dev Modifier to check whether the `msg.sender` is the admin.\n    *  If it is, it will run the function. Otherwise, it will revert.\n    */\n    modifier onlyAdmin() {\n        require(\n            msg.sender == getAdmin(),\n            \"Adminable: caller is not admin\"\n        );\n        _;\n    }\n\n    /**\n     * @return The EIP-1967 proxy admin\n     */\n    function getAdmin()\n        public\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\n    }\n}"
    },
    "./contracts/lib/Amount.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Math} from \"../lib/Math.sol\";\n\nlibrary Amount {\n\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // A Principal Amount is an amount that's been adjusted by an index\n\n    struct Principal {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    function zero()\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: false,\n            value: 0\n        });\n    }\n\n    function sub(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return add(a, negative(b));\n    }\n\n    function add(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        Principal memory result;\n\n        if (a.sign == b.sign) {\n            result.sign = a.sign;\n            result.value = SafeMath.add(a.value, b.value);\n        } else {\n            if (a.value >= b.value) {\n                result.sign = a.sign;\n                result.value = SafeMath.sub(a.value, b.value);\n            } else {\n                result.sign = b.sign;\n                result.value = SafeMath.sub(b.value, a.value);\n            }\n        }\n        return result;\n    }\n\n    function equals(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.value == b.value) {\n            if (a.value == 0) {\n                return true;\n            }\n            return a.sign == b.sign;\n        }\n        return false;\n    }\n\n    function negative(\n        Principal memory a\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: !a.sign,\n            value: a.value\n        });\n    }\n\n    function calculateAdjusted(\n        Principal memory a,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(a.value, index, BASE);\n    }\n\n    function calculatePrincipal(\n        uint256 value,\n        uint256 index,\n        bool sign\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: sign,\n            value: Math.getPartial(value, BASE, index)\n        });\n    }\n\n}\n"
    },
    "./contracts/lib/Decimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Math} from \"./Math.sol\";\n\n/**\n * @title Decimal\n *\n * Library that defines a fixed-point number with 18 decimal places.\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Functions ============\n\n    function one()\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: BASE });\n    }\n\n    function onePlus(\n        D256 memory d\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(BASE) });\n    }\n\n    function mul(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, d.value, BASE);\n    }\n\n    function mul(\n        D256 memory d1,\n        D256 memory d2\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\n    }\n\n    function div(\n        uint256 target,\n        D256 memory d\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, BASE, d.value);\n    }\n\n    function add(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.add(amount) });\n    }\n\n    function sub(\n        D256 memory d,\n        uint256 amount\n    )\n        internal\n        pure\n        returns (D256 memory)\n    {\n        return D256({ value: d.value.sub(amount) });\n    }\n\n}\n"
    },
    "./contracts/lib/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./SafeMath.sol\";\n\n/**\n * @title Math\n *\n * Library for non-standard Math functions\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(\n            result == number,\n            \"Math: Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "./contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.5.16;\n\nimport {IERC20} from \"../token/IERC20.sol\";\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary SafeERC20 {\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        /* solium-disable-next-line */\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(\n                0x23b872dd,\n                from,\n                to,\n                value\n            )\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TRANSFER_FROM_FAILED\"\n        );\n    }\n}\n"
    },
    "./contracts/lib/SafeMath.sol": {
      "content": "\npragma solidity ^0.5.16;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "./contracts/lib/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nlibrary Storage {\n\n    /**\n     * @dev Performs an SLOAD and returns the data in the slot.\n     */\n    function load(\n        bytes32 slot\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32 result;\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            result := sload(slot)\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs an SSTORE to save the value to the slot.\n     */\n    function store(\n        bytes32 slot,\n        bytes32 value\n    )\n        internal\n    {\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}"
    },
    "./contracts/oracle/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../lib/Decimal.sol\";\n\ninterface IOracle {\n\n    function fetchCurrentPrice()\n        external\n        view\n        returns (Decimal.D256 memory);\n\n}"
    },
    "./contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "./contracts/token/IMintableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\ninterface IMintableToken {\n\n    function mint(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function burn(\n        address to,\n        uint256 value\n    )\n        external;\n\n}"
    },
    "./contracts/token/ISyntheticToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Amount} from \"../lib/Amount.sol\";\n\ninterface ISyntheticToken {\n\n    function symbolKey()\n        external\n        view\n        returns (bytes32);\n\n    function mint(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function burn(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function transferCollateral(\n        address token,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    function getMinterIssued(\n        address _minter\n    )\n        external\n        view\n        returns (Amount.Principal memory);\n\n    function getMinterLimit(\n        address _minter\n    )\n        external\n        view\n        returns (uint256);\n\n}\n"
    }
  }
}