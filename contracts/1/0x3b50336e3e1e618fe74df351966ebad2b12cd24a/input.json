{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\n\nimport \"./IGelatoCondition.sol\";\n\nabstract contract GelatoConditionsStandard is IGelatoCondition {\n    string internal constant OK = \"OK\";\n}\n"
    },
    "@gelatonetwork/core/contracts/conditions/IGelatoCondition.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n    ///  \"ok\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n    ///  source of Task identification.\n    /// @param _conditionData This is the Condition.data field developers must encode their\n    ///  Condition's specific parameters in.\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\n        external\n        view\n        returns(string memory);\n}"
    },
    "contracts/contracts/gelato/conditions/ConditionMakerVaultUnsafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/conditions/GelatoConditionsStandard.sol\";\nimport {wmul, wdiv} from \"../../../vendor/DSMath.sol\";\nimport {GelatoBytes} from \"../../../lib/GelatoBytes.sol\";\nimport {\n    IInstaMakerResolver\n} from \"../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\";\n\n/// @title ConditionMakerVaultUnsafe\n/// @notice Condition tracking Maker vault collateralization safety requirements.\n/// @author Gelato Team\ncontract ConditionMakerVaultUnsafe is GelatoConditionsStandard {\n    using GelatoBytes for bytes;\n\n    /// @notice Convenience function for off-chain _conditionData encoding\n    /// @dev Use the return for your Task's Condition.data field off-chain.\n    /// @return The encoded payload for your Task's Condition.data field.\n    function getConditionData(\n        uint256 _vaultId,\n        address _priceOracle,\n        bytes calldata _oraclePayload,\n        uint256 _minColRatio\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.isVaultUnsafe.selector,\n                _vaultId,\n                _priceOracle,\n                _oraclePayload,\n                _minColRatio\n            );\n    }\n\n    /// @notice Standard GelatoCore system function\n    /// @dev A standard interface for GelatoCore to read Conditions\n    /// @param _conditionData The data you get from `getConditionData()`\n    /// @return OK if the Condition is there, else some error message.\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            uint256 _vaultID,\n            address _priceOracle,\n            bytes memory _oraclePayload,\n            uint256 _minColRatio\n        ) = abi.decode(_conditionData[4:], (uint256, address, bytes, uint256));\n\n        return\n            isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio);\n    }\n\n    /// @notice Specific implementation of this Condition's ok function\n    /// @dev The price oracle must return a uint256 WAD (10**18) value.\n    /// @param _vaultId The id of the Maker vault\n    /// @param _priceOracle The price oracle contract to supply the collateral price\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\n    ///  method e.g. the selector for MakerOracle's read fn.\n    /// @param _minColRatio The minimum collateral ratio measured in the price\n    /// of the collateral as specified by the _priceOracle.\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\n    function isVaultUnsafe(\n        uint256 _vaultId,\n        address _priceOracle,\n        bytes memory _oraclePayload,\n        uint256 _minColRatio\n    ) public view virtual returns (string memory) {\n        (bool success, bytes memory returndata) =\n            _priceOracle.staticcall(_oraclePayload);\n\n        if (!success) {\n            returndata.revertWithError(\n                \"ConditionMakerVaultUnsafe.isVaultUnsafe:oracle:\"\n            );\n        }\n\n        uint256 colPriceInWad = abi.decode(returndata, (uint256));\n\n        IInstaMakerResolver.VaultData memory vault =\n            IInstaMakerResolver(0x0A7008B38E7015F8C36A49eEbc32513ECA8801E5)\n                .getVaultById(_vaultId);\n\n        uint256 colRatio =\n            wdiv(wmul(vault.collateral, colPriceInWad), vault.debt);\n\n        return colRatio < _minColRatio ? OK : \"MakerVaultNotUnsafe\";\n    }\n}\n"
    },
    "contracts/interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface IInstaMakerResolver {\n    struct VaultData {\n        uint256 id;\n        address owner;\n        string colType;\n        uint256 collateral;\n        uint256 art;\n        uint256 debt;\n        uint256 liquidatedCol;\n        uint256 borrowRate;\n        uint256 colPrice;\n        uint256 liquidationRatio;\n        address vaultAddress;\n    }\n\n    function getVaultById(uint256 id) external view returns (VaultData memory);\n}\n"
    },
    "contracts/lib/GelatoBytes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\nlibrary GelatoBytes {\n    function calldataSliceSelector(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function memorySliceSelector(bytes memory _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly {\n                selector := mload(add(0x20, _bytes))\n            }\n            if (selector == 0x08c379a0) {\n                // Function selector for Error(string)\n                assembly {\n                    _bytes := add(_bytes, 68)\n                }\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n            } else {\n                revert(\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"))\n                );\n            }\n        } else {\n            revert(\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"))\n            );\n        }\n    }\n\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n        returns (string memory)\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly {\n                selector := mload(add(0x20, _bytes))\n            }\n            if (selector == 0x08c379a0) {\n                // Function selector for Error(string)\n                assembly {\n                    _bytes := add(_bytes, 68)\n                }\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\n            } else {\n                return\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"));\n            }\n        } else {\n            return\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"));\n        }\n    }\n}\n"
    },
    "contracts/vendor/DSMath.sol": {
      "content": "// \"SPDX-License-Identifier: AGPL-3.0-or-later\"\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.7.4;\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    require((z = x + y) >= x, \"ds-math-add-overflow\");\n}\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n}\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    return x <= y ? x : y;\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    return x >= y ? x : y;\n}\n\nfunction imin(int256 x, int256 y) pure returns (int256 z) {\n    return x <= y ? x : y;\n}\n\nfunction imax(int256 x, int256 y) pure returns (int256 z) {\n    return x >= y ? x : y;\n}\n\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**27;\n\n//rounds to zero if x*y < WAD / 2\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, y), WAD / 2) / WAD;\n}\n\n//rounds to zero if x*y < WAD / 2\nfunction rmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, y), RAY / 2) / RAY;\n}\n\n//rounds to zero if x*y < WAD / 2\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, WAD), y / 2) / y;\n}\n\n//rounds to zero if x*y < RAY / 2\nfunction rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, RAY), y / 2) / y;\n}\n\n// This famous algorithm is called \"exponentiation by squaring\"\n// and calculates x^n with x as fixed-point and n as regular unsigned.\n//\n// It's O(log n), instead of O(n) for naive repeated multiplication.\n//\n// These facts are why it works:\n//\n//  If n is even, then x^n = (x^2)^(n/2).\n//  If n is odd,  then x^n = x * x^(n-1),\n//   and applying the equation for even x gives\n//    x^n = x * (x^2)^((n-1) / 2).\n//\n//  Also, EVM division is flooring and\n//    floor[(n-1) / 2] = floor[n / 2].\n//\nfunction rpow(uint256 x, uint256 n) pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n        x = rmul(x, x);\n\n        if (n % 2 != 0) {\n            z = rmul(z, x);\n        }\n    }\n}\n"
    }
  }
}