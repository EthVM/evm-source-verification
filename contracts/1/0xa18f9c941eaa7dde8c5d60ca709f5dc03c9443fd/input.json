{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/access/AdminControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"../openzeppelin/utils/ContextUpgradeable.sol\";\nimport \"../openzeppelin/proxy/Initializable.sol\";\n\nabstract contract AdminControl is Initializable, ContextUpgradeable {\n\n    event NewAdmin(address oldAdmin, address newAdmin);\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    address public admin;\n    address public pendingAdmin;\n\n    modifier onlyAdmin() {\n        require(_msgSender() == admin, \"only admin\");\n        _;\n    }\n\n    function __AdminControl_init(address admin_) internal initializer {\n        admin = admin_;\n    }\n\n    function setPendingAdmin(address newPendingAdmin_) external virtual onlyAdmin {\n        emit NewPendingAdmin(pendingAdmin, newPendingAdmin_);\n        pendingAdmin = newPendingAdmin_;        \n    }\n\n    function acceptAdmin() external virtual {\n        require(_msgSender() == pendingAdmin, \"only pending admin\");\n        emit NewAdmin(admin, pendingAdmin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n}"
    },
    "@solv/v2-solidity-utils/contracts/helpers/ERC20TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\nimport \"../misc/Constants.sol\";\n\ninterface ERC20Interface {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary ERC20TransferHelper {\n    function doTransferIn(\n        address underlying,\n        address from,\n        uint256 amount\n    ) internal returns (uint256) {\n        if (underlying == Constants.ETH_ADDRESS) {\n            // Sanity checks\n            require(tx.origin == from || msg.sender == from, \"sender mismatch\");\n            require(msg.value == amount, \"value mismatch\");\n\n            return amount;\n        } else {\n            require(msg.value == 0, \"don't support msg.value\");\n            uint256 balanceBefore = ERC20Interface(underlying).balanceOf(\n                address(this)\n            );\n            (bool success, bytes memory data) = underlying.call(\n                abi.encodeWithSelector(\n                    ERC20Interface.transferFrom.selector,\n                    from,\n                    address(this),\n                    amount\n                )\n            );\n            require(\n                success && (data.length == 0 || abi.decode(data, (bool))),\n                \"STF\"\n            );\n\n            // Calculate the amount that was *actually* transferred\n            uint256 balanceAfter = ERC20Interface(underlying).balanceOf(\n                address(this)\n            );\n            require(\n                balanceAfter >= balanceBefore,\n                \"TOKEN_TRANSFER_IN_OVERFLOW\"\n            );\n            return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n        }\n    }\n\n    function doTransferOut(\n        address underlying,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (underlying == Constants.ETH_ADDRESS) {\n            (bool success, ) = to.call{value: amount}(new bytes(0));\n            require(success, \"STE\");\n        } else {\n            (bool success, bytes memory data) = underlying.call(\n                abi.encodeWithSelector(\n                    ERC20Interface.transfer.selector,\n                    to,\n                    amount\n                )\n            );\n            require(\n                success && (data.length == 0 || abi.decode(data, (bool))),\n                \"ST\"\n            );\n        }\n    }\n\n    function getCashPrior(address underlying_) internal view returns (uint256) {\n        if (underlying_ == Constants.ETH_ADDRESS) {\n            uint256 startingBalance = sub(address(this).balance, msg.value);\n            return startingBalance;\n        } else {\n            ERC20Interface token = ERC20Interface(underlying_);\n            return token.balanceOf(address(this));\n        }\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/helpers/VNFTTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ERC721Interface {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}\n\ninterface VNFTInterface {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) external returns (uint256 newTokenId);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 units,\n        bytes calldata data\n    ) external returns (uint256 newTokenId);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units,\n        bytes calldata data\n    ) external;\n}\n\nlibrary VNFTTransferHelper {\n    function doTransferIn(\n        address underlying,\n        address from,\n        uint256 tokenId\n    ) internal {\n        ERC721Interface token = ERC721Interface(underlying);\n        token.transferFrom(from, address(this), tokenId);\n    }\n\n    function doTransferOut(\n        address underlying,\n        address to,\n        uint256 tokenId\n    ) internal {\n        ERC721Interface token = ERC721Interface(underlying);\n        token.transferFrom(address(this), to, tokenId);\n    }\n\n    function doTransferIn(\n        address underlying,\n        address from,\n        uint256 tokenId,\n        uint256 units\n    ) internal {\n        VNFTInterface token = VNFTInterface(underlying);\n        token.safeTransferFrom(from, address(this), tokenId, units, \"\");\n    }\n\n    function doTransferOut(\n        address underlying,\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) internal returns (uint256 newTokenId) {\n        VNFTInterface token = VNFTInterface(underlying);\n        newTokenId = token.safeTransferFrom(\n            address(this),\n            to,\n            tokenId,\n            units,\n            \"\"\n        );\n    }\n\n    function doTransferOut(\n        address underlying,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units\n    ) internal {\n        VNFTInterface token = VNFTInterface(underlying);\n        token.safeTransferFrom(\n            address(this),\n            to,\n            tokenId,\n            targetTokenId,\n            units,\n            \"\"\n        );\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/misc/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}"
    },
    "@solv/v2-solidity-utils/contracts/misc/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nlibrary Constants {\n    enum ClaimType {\n        LINEAR,\n        ONE_TIME,\n        STAGED\n    }\n\n    enum VoucherType {\n        STANDARD_VESTING,\n        FLEXIBLE_DATE_VESTING,\n        BOUNDING\n    }\n\n    uint32 internal constant FULL_PERCENTAGE = 10000;\n    address internal constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/misc/StringConvertor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport './BokkyPooBahsDateTimeLibrary.sol';\n\nlibrary StringConvertor {\n\n    using Strings for uint256;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n\n    function uint2decimal(uint256 self, uint8 decimals) \n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 base = 10 ** decimals;\n        string memory round = self.div(base).toString();\n        string memory fraction = self.mod(base).toString();\n        uint256 fractionLength = bytes(fraction).length;\n\n        bytes memory fullStr = abi.encodePacked(round, '.');\n        if (fractionLength < decimals) {\n            for (uint8 i = 0; i < decimals - fractionLength; i++) {\n                fullStr = abi.encodePacked(fullStr, '0');\n            }\n        }\n\n        return abi.encodePacked(fullStr, fraction);\n    }\n\n    function trim(bytes memory self, uint256 cutLength) \n        internal \n        pure\n        returns (bytes memory newString)\n    {\n        newString = new bytes(self.length - cutLength);\n        uint256 index = newString.length;\n        while (index-- > 0) {\n            newString[index] = self[index];\n        }\n    }\n\n    function addThousandsSeparator(bytes memory self)\n        internal\n        pure\n        returns (bytes memory newString)\n    {\n        if (self.length <= 6) {\n            return self;\n        }\n\n        newString = new bytes(self.length + (self.length - 4) / 3);\n        uint256 oriIndex = self.length - 1;\n        uint256 newIndex = newString.length - 1;\n        for (uint256 i = 0; i < self.length; i++) {\n            if (i >= 6 && i % 3 == 0) {\n                newString[newIndex--] = ',';\n            }\n            newString[newIndex--] = self[oriIndex--];\n        }\n    }\n\n    function addressToString(address self) \n        internal \n        pure \n        returns (string memory) \n    {\n        bytes32 value = bytes32(uint256(self));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(42);\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint i = 0; i < 20; i++) {\n            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    function datetimeToString(uint256 timestamp) \n        internal\n        pure\n        returns (string memory)\n    {\n        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second)\n            = BokkyPooBahsDateTimeLibrary.timestampToDateTime(timestamp);\n        return \n            string(\n                abi.encodePacked(\n                    year.toString(), '/', \n                    month < 10 ? '0' : '', month.toString(), '/', \n                    day < 10 ? '0' : '', day.toString(), ' ',\n                    hour < 10 ? '0' : '', hour.toString(), ':', \n                    minute < 10 ? '0' : '', minute.toString(), ':',\n                    second < 10 ? '0' : '',  second.toString()\n                )\n            );\n    }\n\n    function dateToString(uint256 timestamp)\n        internal\n        pure\n        returns (string memory)\n    {\n        (uint256 year, uint256 month, uint256 day)\n            = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);\n        return \n            string(\n                abi.encodePacked(\n                    year.toString(), '/', \n                    month < 10 ? '0' : '', month.toString(), '/', \n                    day < 10 ? '0' : '', day.toString()\n                )\n            );\n    }\n\n    function uintArray2str(uint64[] memory array) \n        internal \n        pure \n        returns (string memory) \n    {\n        bytes memory pack = abi.encodePacked('[');\n        for (uint256 i = 0; i < array.length; i++) {\n            if (i == array.length - 1) {\n                pack = abi.encodePacked(pack, uint256(array[i]).toString());\n            } else {\n                pack = abi.encodePacked(pack, uint256(array[i]).toString(), ',');\n            }\n        }\n        return string(abi.encodePacked(pack, ']'));\n    }\n\n    function percentArray2str(uint32[] memory array) \n        internal \n        pure \n        returns (string memory) \n    {\n        bytes memory pack = abi.encodePacked('[');\n        for (uint256 i = 0; i < array.length; i++) {\n            bytes memory percent = abi.encodePacked('\"', uint2decimal(array[i], 2), '%\"');\n\n            if (i == array.length - 1) {\n                pack = abi.encodePacked(pack, percent);\n            } else {\n                pack = abi.encodePacked(pack, percent, ',');\n            }\n        }\n        return string(abi.encodePacked(pack, ']'));\n    }\n\n}"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721MetadataUpgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/EnumerableSetUpgradeable.sol\";\nimport \"../../utils/EnumerableMapUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;\n    using StringsUpgradeable for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721ReceiverUpgradeable(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n    uint256[41] private __gap;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC721/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC721/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/utils/EnumerableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMapUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@solv/v2-solidity-utils/contracts/openzeppelin/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@solv/v2-solver/contracts/interface/ISolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface ISolver {\n\n    event SetOperationPaused (\n        address product,\n        string operation,\n        bool setPaused\n    );\n\n\n    function isSolver() external pure returns (bool);\n\n    function setOperationPaused(address product_, string calldata operation_, bool setPaused_) external;\n\n    function operationAllowed(string calldata operation_, bytes calldata data_) external returns (uint256);\n\n    function operationVerify(string calldata operation_, bytes calldata data_) external returns (uint256);\n    \n}"
    },
    "@solv/v2-vnft-core/contracts/VNFTCoreV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC721/ERC721Upgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/utils/EnumerableSetUpgradeable.sol\";\nimport \"./interface/IVNFT.sol\";\nimport \"./interface/optional/IVNFTMetadata.sol\";\n\nabstract contract VNFTCoreV2 is IVNFT, IVNFTMetadata, ERC721Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    struct ApproveUnits {\n        address[] approvals;\n        mapping(address => uint256) allowances;\n    }\n\n    /// @dev tokenId => units\n    mapping(uint256 => uint256) internal _units;\n\n    /// @dev tokenId => operator => units\n    mapping(uint256 => ApproveUnits) private _tokenApprovalUnits;\n\n    /// @dev slot => tokenIds\n    mapping(uint256 => EnumerableSetUpgradeable.UintSet) private _slotTokens;\n\n    uint8 internal _unitDecimals;\n\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 unitDecimals_\n    ) internal virtual {\n        ERC721Upgradeable.__ERC721_init(name_, symbol_);\n        ERC165Upgradeable._registerInterface(type(IVNFT).interfaceId);\n        _unitDecimals = unitDecimals_;\n    }\n\n    function _safeTransferUnitsFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_,\n        bytes memory data_\n    ) internal virtual {\n        _transferUnitsFrom(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n        require(\n            _checkOnVNFTReceived(\n                from_,\n                to_,\n                targetTokenId_,\n                transferUnits_,\n                data_\n            ),\n            \"to non VNFTReceiver implementer\"\n        );\n    }\n\n    function _transferUnitsFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) internal virtual {\n        require(from_ == ownerOf(tokenId_), \"source token owner mismatch\");\n        require(to_ != address(0), \"transfer to the zero address\");\n\n        _beforeTransferUnits(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n\n        // approve allapprove units\n        if (_msgSender() != from_ && !isApprovedForAll(from_, _msgSender())) {\n            _tokenApprovalUnits[tokenId_].allowances[\n                _msgSender()\n            ] = _tokenApprovalUnits[tokenId_].allowances[_msgSender()].sub(\n                transferUnits_,\n                \"transfer units exceeds allowance\"\n            );\n        }\n\n        _units[tokenId_] = _units[tokenId_].sub(\n            transferUnits_,\n            \"transfer excess units\"\n        );\n\n        if (!_exists(targetTokenId_)) {\n            _mintUnits(to_, targetTokenId_, _slotOf(tokenId_), transferUnits_);\n        } else {\n            require(\n                ownerOf(targetTokenId_) == to_,\n                \"target token owner mismatch\"\n            );\n            require(\n                _slotOf(tokenId_) == _slotOf(targetTokenId_),\n                \"slot mismatch\"\n            );\n            _units[targetTokenId_] = _units[targetTokenId_].add(transferUnits_);\n        }\n\n        emit TransferUnits(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n    }\n\n    function _merge(uint256 tokenId_, uint256 targetTokenId_) internal virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId_),\n            \"VNFT: not owner nor approved\"\n        );\n        require(tokenId_ != targetTokenId_, \"self merge not allowed\");\n        require(_slotOf(tokenId_) == _slotOf(targetTokenId_), \"slot mismatch\");\n\n        address owner = ownerOf(tokenId_);\n        require(owner == ownerOf(targetTokenId_), \"not same owner\");\n\n        uint256 mergeUnits = _units[tokenId_];\n        _units[targetTokenId_] = _units[tokenId_].add(_units[targetTokenId_]);\n        _burn(tokenId_);\n\n        emit Merge(owner, tokenId_, targetTokenId_, mergeUnits);\n    }\n\n    function _split(\n        uint256 tokenId_,\n        uint256 newTokenId_,\n        uint256 splitUnits_\n    ) internal virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId_),\n            \"VNFT: not owner nor approved\"\n        );\n        require(!_exists(newTokenId_), \"new token already exists\");\n\n        _units[tokenId_] = _units[tokenId_].sub(splitUnits_);\n\n        address owner = ownerOf(tokenId_);\n        _mintUnits(owner, newTokenId_, _slotOf(tokenId_), splitUnits_);\n\n        emit Split(owner, tokenId_, newTokenId_, splitUnits_);\n    }\n\n    function _mintUnits(\n        address minter_,\n        uint256 tokenId_,\n        uint256 slot_,\n        uint256 units_\n    ) internal virtual {\n        if (!_exists(tokenId_)) {\n            ERC721Upgradeable._mint(minter_, tokenId_);\n            _slotTokens[slot_].add(tokenId_);\n        }\n\n        _units[tokenId_] = _units[tokenId_].add(units_);\n        emit TransferUnits(address(0), minter_, 0, tokenId_, units_);\n    }\n\n    function _burn(uint256 tokenId_) internal virtual override {\n        address owner = ownerOf(tokenId_);\n        uint256 slot = _slotOf(tokenId_);\n        uint256 burnUnits = _units[tokenId_];\n\n        _slotTokens[slot].remove(tokenId_);\n        delete _units[tokenId_];\n\n        ERC721Upgradeable._burn(tokenId_);\n        emit TransferUnits(owner, address(0), tokenId_, 0, burnUnits);\n    }\n\n    function _burnUnits(uint256 tokenId_, uint256 burnUnits_)\n        internal\n        virtual\n        returns (uint256 balance)\n    {\n        address owner = ownerOf(tokenId_);\n        _units[tokenId_] = _units[tokenId_].sub(\n            burnUnits_,\n            \"burn excess units\"\n        );\n\n        emit TransferUnits(owner, address(0), tokenId_, 0, burnUnits_);\n        return _units[tokenId_];\n    }\n\n    function approve(\n        address to_,\n        uint256 tokenId_,\n        uint256 allowance_\n    ) public virtual override {\n        require(_msgSender() == ownerOf(tokenId_), \"VNFT: only owner\");\n        _approveUnits(to_, tokenId_, allowance_);\n    }\n\n    function allowance(uint256 tokenId_, address spender_)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _tokenApprovalUnits[tokenId_].allowances[spender_];\n    }\n\n    /**\n     * @dev Approve `to_` to operate on `tokenId_` within range of `allowance_`\n     */\n    function _approveUnits(\n        address to_,\n        uint256 tokenId_,\n        uint256 allowance_\n    ) internal virtual {\n        if (_tokenApprovalUnits[tokenId_].allowances[to_] == 0) {\n            _tokenApprovalUnits[tokenId_].approvals.push(to_);\n        }\n        _tokenApprovalUnits[tokenId_].allowances[to_] = allowance_;\n        emit ApprovalUnits(to_, tokenId_, allowance_);\n    }\n\n    /**\n     * @dev Clear existing approveUnits for `tokenId_`, including approved addresses and their approved units.\n     */\n    function _clearApproveUnits(uint256 tokenId_) internal virtual {\n        ApproveUnits storage approveUnits = _tokenApprovalUnits[tokenId_];\n        for (uint256 i = 0; i < approveUnits.approvals.length; i++) {\n            delete approveUnits.allowances[approveUnits.approvals[i]];\n            delete approveUnits.approvals[i];\n        }\n    }\n\n    function unitDecimals() public view override returns (uint8) {\n        return _unitDecimals;\n    }\n\n    function unitsInSlot(uint256 slot_)\n        public\n        view\n        override\n        returns (uint256 units_)\n    {\n        for (uint256 i = 0; i < tokensInSlot(slot_); i++) {\n            units_ = units_.add(unitsInToken(tokenOfSlotByIndex(slot_, i)));\n        }\n    }\n\n    function unitsInToken(uint256 tokenId_)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _units[tokenId_];\n    }\n\n    function tokensInSlot(uint256 slot_)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _slotTokens[slot_].length();\n    }\n\n    function tokenOfSlotByIndex(uint256 slot_, uint256 index_)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _slotTokens[slot_].at(index_);\n    }\n\n    function slotOf(uint256 tokenId_) public view override returns (uint256) {\n        return _slotOf(tokenId_);\n    }\n\n    function _slotOf(uint256 tokenId_) internal view virtual returns (uint256);\n\n    /**\n     * @dev Before transferring or burning a token, the existing approveUnits should be cleared.\n     */\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_\n    ) internal virtual override {\n        if (from_ != address(0)) {\n            _clearApproveUnits(tokenId_);\n        }\n    }\n\n    function _beforeTransferUnits(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) internal virtual {}\n\n    function _checkOnVNFTReceived(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 units_,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!to_.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to_.functionCall(\n            abi.encodeWithSelector(\n                IVNFTReceiver(to_).onVNFTReceived.selector,\n                _msgSender(),\n                from_,\n                tokenId_,\n                units_,\n                _data\n            ),\n            \"non VNFTReceiver implementer\"\n        );\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        /*b382cdcd  =>  onVNFTReceived(address,address,uint256,uint256,bytes)*/\n        return (retval == type(IVNFTReceiver).interfaceId);\n    }\n}\n"
    },
    "@solv/v2-vnft-core/contracts/interface/IVNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n/* is ERC721, ERC165 */\ninterface IVNFT {\n    event TransferUnits(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId,\n        uint256 targetTokenId,\n        uint256 transferUnits\n    );\n\n    event Split(\n        address indexed owner,\n        uint256 indexed tokenId,\n        uint256 newTokenId,\n        uint256 splitUnits\n    );\n\n    event Merge(\n        address indexed owner,\n        uint256 indexed tokenId,\n        uint256 indexed targetTokenId,\n        uint256 mergeUnits\n    );\n\n    event ApprovalUnits(\n        address indexed approval,\n        uint256 indexed tokenId,\n        uint256 allowance\n    );\n\n    function slotOf(uint256 tokenId) external view returns (uint256 slot);\n\n    function unitDecimals() external view returns (uint8);\n\n    function unitsInSlot(uint256 slot) external view returns (uint256);\n\n    function tokensInSlot(uint256 slot)\n        external\n        view\n        returns (uint256 tokenCount);\n\n    function tokenOfSlotByIndex(uint256 slot, uint256 index)\n        external\n        view\n        returns (uint256 tokenId);\n\n    function unitsInToken(uint256 tokenId)\n        external\n        view\n        returns (uint256 units);\n\n    function approve(\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) external;\n\n    function allowance(uint256 tokenId, address spender)\n        external\n        view\n        returns (uint256 allowed);\n\n    function split(uint256 tokenId, uint256[] calldata units)\n        external\n        returns (uint256[] memory newTokenIds);\n\n    function merge(uint256[] calldata tokenIds, uint256 targetTokenId) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) external returns (uint256 newTokenId);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 units,\n        bytes calldata data\n    ) external returns (uint256 newTokenId);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units\n    ) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 targetTokenId,\n        uint256 units,\n        bytes calldata data\n    ) external;\n}\n\ninterface IVNFTReceiver {\n    function onVNFTReceived(\n        address operator,\n        address from,\n        uint256 tokenId,\n        uint256 units,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@solv/v2-vnft-core/contracts/interface/optional/IUnderlyingContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IUnderlyingContainer {\n    function totalUnderlyingAmount() external view returns (uint256);\n    function underlying() external view returns (address);\n}"
    },
    "@solv/v2-vnft-core/contracts/interface/optional/IVNFTMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IVNFTMetadata /* is IERC721Metadata */ {\n    function contractURI() external view returns (string memory);\n    function slotURI(uint256 slot) external view returns (string memory);\n}"
    },
    "@solv/v2-voucher-core/contracts/VoucherCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@solv/v2-solidity-utils/contracts/access/AdminControl.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/Constants.sol\";\nimport \"@solv/v2-vnft-core/contracts/VNFTCoreV2.sol\";\n\nabstract contract VoucherCore is VNFTCoreV2, AdminControl {\n    /// @dev tokenId => slot\n    mapping(uint256 => uint256) public voucherSlotMapping;\n\n    uint32 public nextTokenId;\n\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 unitDecimals_\n    ) internal override {\n        AdminControl.__AdminControl_init(_msgSender());\n        VNFTCoreV2._initialize(name_, symbol_, unitDecimals_);\n        nextTokenId = 1;\n    }\n\n    function _generateTokenId() internal virtual returns (uint256) {\n        return nextTokenId++;\n    }\n\n    function split(uint256 tokenId_, uint256[] calldata splitUnits_)\n        public\n        virtual\n        override\n        returns (uint256[] memory newTokenIds)\n    {\n        require(splitUnits_.length > 0, \"empty splitUnits\");\n        newTokenIds = new uint256[](splitUnits_.length);\n\n        for (uint256 i = 0; i < splitUnits_.length; i++) {\n            uint256 newTokenId = _generateTokenId();\n            newTokenIds[i] = newTokenId;\n            VNFTCoreV2._split(tokenId_, newTokenId, splitUnits_[i]);\n            voucherSlotMapping[newTokenId] = voucherSlotMapping[tokenId_];\n        }\n    }\n\n    function merge(uint256[] calldata tokenIds_, uint256 targetTokenId_)\n        public\n        virtual\n        override\n    {\n        require(tokenIds_.length > 0, \"empty tokenIds\");\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            VNFTCoreV2._merge(tokenIds_[i], targetTokenId_);\n            delete voucherSlotMapping[tokenIds_[i]];\n        }\n    }\n\n    /**\n     * @notice Transfer part of units of a Voucher to target address.\n     * @param from_ Address of the Voucher sender\n     * @param to_ Address of the Voucher recipient\n     * @param tokenId_ Id of the Voucher to transfer\n     * @param transferUnits_ Amount of units to transfer\n     */\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 transferUnits_\n    ) public virtual override returns (uint256 newTokenId) {\n        newTokenId = _generateTokenId();\n        _transferUnitsFrom(from_, to_, tokenId_, newTokenId, transferUnits_);\n    }\n\n    /**\n     * @notice Transfer part of units of a Voucher to another Voucher.\n     * @param from_ Address of the Voucher sender\n     * @param to_ Address of the Voucher recipient\n     * @param tokenId_ Id of the Voucher to transfer\n     * @param targetTokenId_ Id of the Voucher to receive\n     * @param transferUnits_ Amount of units to transfer\n     */\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) public virtual override {\n        require(_exists(targetTokenId_), \"target token not exists\");\n        _transferUnitsFrom(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n    }\n\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 transferUnits_,\n        bytes memory data_\n    ) public virtual override returns (uint256 newTokenId) {\n        newTokenId = transferFrom(from_, to_, tokenId_, transferUnits_);\n        require(\n            _checkOnVNFTReceived(from_, to_, newTokenId, transferUnits_, data_),\n            \"to non VNFTReceiver\"\n        );\n        return newTokenId;\n    }\n\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_,\n        bytes memory data_\n    ) public virtual override {\n        transferFrom(from_, to_, tokenId_, targetTokenId_, transferUnits_);\n        require(\n            _checkOnVNFTReceived(\n                from_,\n                to_,\n                targetTokenId_,\n                transferUnits_,\n                data_\n            ),\n            \"to non VNFTReceiver\"\n        );\n    }\n\n    function _transferUnitsFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) internal virtual override {\n        VNFTCoreV2._transferUnitsFrom(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n        voucherSlotMapping[targetTokenId_] = voucherSlotMapping[tokenId_];\n    }\n\n    function _mint(\n        address minter_,\n        uint256 slot_,\n        uint256 units_\n    ) internal virtual returns (uint256 tokenId) {\n        tokenId = _generateTokenId();\n        voucherSlotMapping[tokenId] = slot_;\n        VNFTCoreV2._mintUnits(minter_, tokenId, slot_, units_);\n    }\n\n    function burn(uint256 tokenId_) external virtual {\n        require(_msgSender() == ownerOf(tokenId_), \"only owner\");\n        _burnVoucher(tokenId_);\n    }\n\n    function _burnVoucher(uint256 tokenId_) internal virtual {\n        delete voucherSlotMapping[tokenId_];\n        VNFTCoreV2._burn(tokenId_);\n    }\n\n    function _slotOf(uint256 tokenId_)\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return voucherSlotMapping[tokenId_];\n    }\n\n    function owner() external view virtual returns (address) {\n        return admin;\n    }\n\n    function voucherType() external view virtual returns (Constants.VoucherType) {}\n\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/FlexibleDateVestingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@solv/v2-solidity-utils/contracts/access/AdminControl.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/Constants.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/StringConvertor.sol\";\nimport \"@solv/v2-solidity-utils/contracts/helpers/ERC20TransferHelper.sol\";\nimport \"@solv/v2-solidity-utils/contracts/helpers/VNFTTransferHelper.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/utils/EnumerableSetUpgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/math/SafeMathUpgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC20/IERC20.sol\";\nimport \"@solv/v2-vnft-core/contracts/interface/optional/IUnderlyingContainer.sol\";\nimport \"./interface/IFlexibleDateVestingPool.sol\";\nimport \"./interface/external/IICToken.sol\";\n\ncontract FlexibleDateVestingPool is\n    IFlexibleDateVestingPool,\n    AdminControl,\n    ReentrancyGuardUpgradeable\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using StringConvertor for address;\n    using StringConvertor for uint64;\n    using StringConvertor for uint64[];\n    using StringConvertor for uint32[];\n    using SafeMathUpgradeable for uint256;\n\n    /// @dev slot => SlotDetail\n    mapping(uint256 => SlotDetail) internal _slotDetails;\n\n    mapping(address => EnumerableSetUpgradeable.UintSet) internal _issuerSlots;\n\n    address public underlyingVestingVoucher;\n    address public underlyingToken;\n\n    address public manager;\n\n    uint256 public totalAmount;\n    mapping(uint256 => uint256) public amountOfSlot;\n\n    modifier onlyManager() {\n        require(_msgSender() == manager, \"only manager\");\n        _;\n    }\n\n    function initialize(address underlyingVestingVoucher_)\n        external\n        initializer\n    {\n        AdminControl.__AdminControl_init(_msgSender());\n        underlyingVestingVoucher = underlyingVestingVoucher_;\n        underlyingToken = IUnderlyingContainer(underlyingVestingVoucher)\n            .underlying();\n    }\n\n    function createSlot(\n        address issuer_,\n        uint8 claimType_,\n        uint64 latestStartTime_,\n        uint64[] calldata terms_,\n        uint32[] calldata percentages_\n    ) external onlyManager returns (uint256 slot) {\n        require(issuer_ != address(0), \"issuer cannot be 0 address\");\n        slot = getSlot(\n            issuer_,\n            claimType_,\n            latestStartTime_,\n            terms_,\n            percentages_\n        );\n        require(!_slotDetails[slot].isValid, \"slot already existed\");\n        require(\n            terms_.length == percentages_.length,\n            \"invalid terms and percentages\"\n        );\n        // latestStartTime should not be later than 2100/01/01 00:00:00\n        require(latestStartTime_ < 4102416000, \"latest start time too late\");\n        // number of stages should not be more than 50\n        require(percentages_.length <= 50, \"too many stages\");\n\n        uint256 sumOfPercentages = 0;\n        for (uint256 i = 0; i < percentages_.length; i++) {\n            // value of each term should not be larger than 10 years\n            require(terms_[i] <= 315360000, \"term value too large\");\n            // value of each percentage should not be larger than 10000\n            require(percentages_[i] <= Constants.FULL_PERCENTAGE, \"percentage value too large\");\n            sumOfPercentages += percentages_[i];\n        }\n        require(\n            sumOfPercentages == Constants.FULL_PERCENTAGE,\n            \"not full percentage\"\n        );\n\n        require(\n            (claimType_ == uint8(Constants.ClaimType.LINEAR) &&\n                percentages_.length == 1) ||\n                (claimType_ == uint8(Constants.ClaimType.ONE_TIME) &&\n                    percentages_.length == 1) ||\n                (claimType_ == uint8(Constants.ClaimType.STAGED) &&\n                    percentages_.length > 1),\n            \"invalid params\"\n        );\n\n        _slotDetails[slot] = SlotDetail({\n            issuer: issuer_,\n            claimType: claimType_,\n            startTime: 0,\n            latestStartTime: latestStartTime_,\n            terms: terms_,\n            percentages: percentages_,\n            isValid: true\n        });\n\n        _issuerSlots[issuer_].add(slot);\n\n        emit CreateSlot(\n            slot,\n            issuer_,\n            claimType_,\n            latestStartTime_,\n            terms_,\n            percentages_\n        );\n    }\n\n    function mint(\n        address minter_,\n        uint256 slot_,\n        uint256 vestingAmount_\n    ) external nonReentrant onlyManager {\n        amountOfSlot[slot_] = amountOfSlot[slot_].add(vestingAmount_);\n        totalAmount = totalAmount.add(vestingAmount_);\n        ERC20TransferHelper.doTransferIn(\n            underlyingToken,\n            minter_,\n            vestingAmount_\n        );\n        emit Mint(minter_, slot_, vestingAmount_);\n    }\n\n    function claim(\n        uint256 slot_,\n        address to_,\n        uint256 claimAmount\n    ) external nonReentrant onlyManager {\n        if (claimAmount > amountOfSlot[slot_]) {\n            claimAmount = amountOfSlot[slot_];\n        }\n        amountOfSlot[slot_] = amountOfSlot[slot_].sub(claimAmount);\n        totalAmount = totalAmount.sub(claimAmount);\n\n        SlotDetail storage slotDetail = _slotDetails[slot_];\n        uint64 finalTerm = slotDetail.claimType ==\n            uint8(Constants.ClaimType.LINEAR)\n            ? slotDetail.terms[0]\n            : slotDetail.claimType == uint8(Constants.ClaimType.ONE_TIME)\n            ? 0\n            : stagedTermsToVestingTerm(slotDetail.terms);\n        uint64 startTime = slotDetail.startTime > 0\n            ? slotDetail.startTime\n            : slotDetail.latestStartTime;\n\n        // Since the `startTime` and `terms` are read from storage, and their values have been \n        // checked before stored when minting a new voucher, so there is no need here to check \n        // the overflow of the values of `maturities`.\n        uint64[] memory maturities = new uint64[](slotDetail.terms.length);\n        maturities[0] = startTime + slotDetail.terms[0];\n        for (uint256 i = 1; i < maturities.length; i++) {\n            maturities[i] = maturities[i - 1] + slotDetail.terms[i];\n        }\n\n        IERC20(underlyingToken).approve(\n            address(IICToken(underlyingVestingVoucher).vestingPool()),\n            claimAmount\n        );\n        (, uint256 vestingVoucherId) = IICToken(underlyingVestingVoucher).mint(\n            finalTerm,\n            claimAmount,\n            maturities,\n            slotDetail.percentages,\n            \"\"\n        );\n        VNFTTransferHelper.doTransferOut(\n            address(underlyingVestingVoucher),\n            to_,\n            vestingVoucherId\n        );\n        emit Claim(slot_, to_, claimAmount);\n    }\n\n    function setStartTime(\n        address setter_,\n        uint256 slot_,\n        uint64 startTime_\n    ) external onlyManager {\n        SlotDetail storage slotDetail = _slotDetails[slot_];\n        require(slotDetail.isValid, \"invalid slot\");\n        require(setter_ == slotDetail.issuer, \"only issuer\");\n        require(\n            startTime_ <= slotDetail.latestStartTime,\n            \"exceeds latestStartTime\"\n        );\n        if (slotDetail.startTime > 0) {\n            require(block.timestamp < slotDetail.startTime, \"unchangeable\");\n        }\n\n        emit SetStartTime(slot_, slotDetail.startTime, startTime_);\n        slotDetail.startTime = startTime_;\n    }\n\n    function isClaimable(uint256 slot_) external view returns (bool) {\n        SlotDetail storage slotDetail = _slotDetails[slot_];\n        return\n            (slotDetail.isValid &&\n                (slotDetail.startTime == 0 &&\n                    block.timestamp >= slotDetail.latestStartTime)) ||\n            (slotDetail.startTime > 0 &&\n                block.timestamp >= slotDetail.startTime);\n    }\n\n    function getSlot(\n        address issuer_,\n        uint8 claimType_,\n        uint64 latestStartTime_,\n        uint64[] calldata terms_,\n        uint32[] calldata percentages_\n    ) public view returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encode(\n                        underlyingToken,\n                        underlyingVestingVoucher,\n                        issuer_,\n                        claimType_,\n                        latestStartTime_,\n                        terms_,\n                        percentages_\n                    )\n                )\n            );\n    }\n\n    function getSlotDetail(uint256 slot_)\n        external\n        view\n        returns (SlotDetail memory)\n    {\n        return _slotDetails[slot_];\n    }\n\n    function getIssuerSlots(address issuer_)\n        external\n        view\n        returns (uint256[] memory slots)\n    {\n        slots = new uint256[](_issuerSlots[issuer_].length());\n        for (uint256 i = 0; i < slots.length; i++) {\n            slots[i] = _issuerSlots[issuer_].at(i);\n        }\n    }\n\n    function getIssuerSlotDetails(address issuer_)\n        external\n        view\n        returns (SlotDetail[] memory slotDetails)\n    {\n        slotDetails = new SlotDetail[](_issuerSlots[issuer_].length());\n        for (uint256 i = 0; i < slotDetails.length; i++) {\n            slotDetails[i] = _slotDetails[_issuerSlots[issuer_].at(i)];\n        }\n    }\n\n    function slotProperties(uint256 slot_)\n        external\n        view\n        returns (string memory)\n    {\n        SlotDetail storage slotDetail = _slotDetails[slot_];\n        return\n            string(\n                abi.encodePacked(\n                    abi.encodePacked(\n                        '{\"underlyingToken\":\"',\n                        underlyingToken.addressToString(),\n                        '\",\"underlyingVesting\":\"',\n                        underlyingVestingVoucher.addressToString(),\n                        '\",\"claimType:\"',\n                        _parseClaimType(slotDetail.claimType),\n                        '\",\"terms:\"',\n                        slotDetail.terms.uintArray2str(),\n                        '\",\"percentages:\"',\n                        slotDetail.percentages.percentArray2str()\n                    ),\n                    abi.encodePacked(\n                        '\",\"issuer\":\"',\n                        slotDetail.issuer.addressToString(),\n                        '\",\"startTime:\"',\n                        slotDetail.startTime.toString(),\n                        '\",\"latestStartTime:\"',\n                        slotDetail.latestStartTime.toString(),\n                        '\"}'\n                    )\n                )\n            );\n    }\n\n    function setManager(address newManager_) external onlyAdmin {\n        require(newManager_ != address(0), \"new manager cannot be 0 address\");\n        emit NewManager(manager, newManager_);\n        manager = newManager_;\n    }\n\n    function stagedTermsToVestingTerm(uint64[] memory terms_)\n        private\n        pure\n        returns (uint64 vestingTerm)\n    {\n        for (uint256 i = 1; i < terms_.length; i++) {\n            // The value of `terms_` are read from storage, and their values have been checked before \n            // stored, so there is no need here to check the overflow of `vestingTerm`.\n            vestingTerm += terms_[i];\n        }\n    }\n\n    function _parseClaimType(uint8 claimTypeInNum_)\n        private\n        pure\n        returns (string memory)\n    {\n        return\n            claimTypeInNum_ == 0 ? \"LINEAR\" : claimTypeInNum_ == 1\n                ? \"ONE_TIME\"\n                : claimTypeInNum_ == 2\n                ? \"STAGED\"\n                : \"UNKNOWN\";\n    }\n}\n"
    },
    "contracts/FlexibleDateVestingVoucher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@solv/v2-solidity-utils/contracts/access/AdminControl.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/Constants.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/StringConvertor.sol\";\nimport \"@solv/v2-solver/contracts/interface/ISolver.sol\";\nimport \"@solv/v2-voucher-core/contracts/VoucherCore.sol\";\nimport \"./interface/IFlexibleDateVestingVoucher.sol\";\nimport \"./interface/IVNFTDescriptor.sol\";\nimport \"./FlexibleDateVestingPool.sol\";\n\ncontract FlexibleDateVestingVoucher is IFlexibleDateVestingVoucher, VoucherCore, ReentrancyGuardUpgradeable {\n    using StringConvertor for uint256;\n\n    FlexibleDateVestingPool public flexibleDateVestingPool;\n\n    IVNFTDescriptor public voucherDescriptor;\n\n    ISolver public solver;\n\n    function initialize(\n        address flexibleDateVestingPool_,\n        address voucherDescriptor_,\n        address solver_,\n        uint8 unitDecimals_,\n        string calldata name_,\n        string calldata symbol_\n    ) external initializer {\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        VoucherCore._initialize(name_, symbol_, unitDecimals_);\n        \n        flexibleDateVestingPool = FlexibleDateVestingPool(flexibleDateVestingPool_);\n        voucherDescriptor = IVNFTDescriptor(voucherDescriptor_);\n        solver = ISolver(solver_);\n\n        ERC165Upgradeable._registerInterface(type(IFlexibleDateVestingVoucher).interfaceId);\n    }\n\n    function mint(\n        address issuer_,\n        uint8 claimType_,\n        uint64 latestStartTime_,\n        uint64[] calldata terms_,\n        uint32[] calldata percentages_,\n        uint256 vestingAmount_\n    ) \n        external \n        override\n        returns (uint256 slot, uint256 tokenId) \n    {\n        uint256 err = solver.operationAllowed(\n            \"mint\",\n            abi.encode(\n                _msgSender(),\n                issuer_,\n                claimType_,\n                latestStartTime_,\n                terms_,\n                percentages_,\n                vestingAmount_\n            )\n        );\n        require(err == 0, \"Solver: not allowed\");\n\n        require(issuer_ != address(0), \"issuer cannot be 0 address\");\n        require(latestStartTime_ > 0, \"latestStartTime cannot be 0\");\n\n        slot = getSlot(issuer_, claimType_, latestStartTime_, terms_, percentages_);\n        FlexibleDateVestingPool.SlotDetail memory slotDetail = getSlotDetail(slot);\n        if (!slotDetail.isValid) {\n            flexibleDateVestingPool.createSlot(issuer_, claimType_, latestStartTime_, terms_, percentages_);\n        }\n\n        flexibleDateVestingPool.mint(_msgSender(), slot, vestingAmount_);\n        tokenId = VoucherCore._mint(_msgSender(), slot, vestingAmount_);\n\n        solver.operationVerify(\n            \"mint\", \n            abi.encode(_msgSender(), issuer_, slot, tokenId, vestingAmount_)\n        );\n    }\n\n    function claim(uint256 tokenId_, uint256 claimAmount_) external override {\n        claimTo(tokenId_, _msgSender(), claimAmount_);\n    }\n\n    function claimTo(uint256 tokenId_, address to_, uint256 claimAmount_) public override nonReentrant {\n        require(_msgSender() == ownerOf(tokenId_), \"only owner\");\n        require(claimAmount_ <= unitsInToken(tokenId_), \"over claim\");\n        require(isClaimable(voucherSlotMapping[tokenId_]));\n\n        uint256 err = solver.operationAllowed(\n            \"claim\",\n            abi.encode(_msgSender(), tokenId_, to_, claimAmount_)\n        );\n        require(err == 0, \"Solver: not allowed\");\n\n        flexibleDateVestingPool.claim(voucherSlotMapping[tokenId_], to_, claimAmount_);\n\n        if (claimAmount_ == unitsInToken(tokenId_)) {\n            _burnVoucher(tokenId_);\n        } else {\n            _burnUnits(tokenId_, claimAmount_);\n        }\n\n        solver.operationVerify(\n            \"claim\",\n            abi.encode(_msgSender(), tokenId_, to_, claimAmount_)\n        );\n\n        emit Claim(tokenId_, to_, claimAmount_);\n    }\n\n    function setStartTime(uint256 slot_, uint64 startTime_) external override {\n        flexibleDateVestingPool.setStartTime(_msgSender(), slot_, startTime_);\n    }\n\n    function setVoucherDescriptor(IVNFTDescriptor newDescriptor_) external onlyAdmin {\n        emit SetDescriptor(address(voucherDescriptor), address(newDescriptor_));\n        voucherDescriptor = newDescriptor_;\n    }\n\n    function setSolver(ISolver newSolver_) external onlyAdmin {\n        require(newSolver_.isSolver(), \"invalid solver\");\n        emit SetSolver(address(solver), address(newSolver_));\n        solver = newSolver_;\n    }\n\n    function isClaimable(uint256 slot_) public view override returns (bool) {\n        return flexibleDateVestingPool.isClaimable(slot_);\n    }\n\n    function getSlot(\n        address issuer_, uint8 claimType_, uint64 latestStartTime_,\n        uint64[] calldata terms_, uint32[] calldata percentages_\n    ) \n        public  \n        view \n        returns (uint256) \n    {\n        return flexibleDateVestingPool.getSlot(issuer_, claimType_, latestStartTime_, terms_, percentages_);\n    }\n\n    function getSlotDetail(uint256 slot_) public view returns (IFlexibleDateVestingPool.SlotDetail memory) {\n        return flexibleDateVestingPool.getSlotDetail(slot_);\n    }\n\n    function getIssuerSlots(address issuer_) external view returns (uint256[] memory slots) {\n        return flexibleDateVestingPool.getIssuerSlots(issuer_);\n    }\n\n    function contractURI() external view override returns (string memory) {\n        return voucherDescriptor.contractURI();\n    }\n\n    function slotURI(uint256 slot_) external view override returns (string memory) {\n        return voucherDescriptor.slotURI(slot_);\n    }\n\n    function tokenURI(uint256 tokenId_)\n        public\n        view\n        virtual\n        override\n        returns (string memory) \n    {\n        require(_exists(tokenId_), \"token not exists\");\n        return voucherDescriptor.tokenURI(tokenId_);\n    }\n\n    function getSnapshot(uint256 tokenId_)\n        external\n        view\n        returns (FlexibleDateVestingVoucherSnapshot memory snapshot)\n    {\n        snapshot.tokenId = tokenId_;\n        snapshot.vestingAmount = unitsInToken(tokenId_);\n        snapshot.slotSnapshot = flexibleDateVestingPool.getSlotDetail(voucherSlotMapping[tokenId_]);\n    }\n\n    function underlying() external view override returns (address) {\n        return flexibleDateVestingPool.underlyingToken();\n    }\n\n    function underlyingVestingVoucher() external view override returns (address) {\n        return address(flexibleDateVestingPool.underlyingVestingVoucher());\n    }\n\n    function voucherType() external pure override returns (Constants.VoucherType) {\n        return Constants.VoucherType.FLEXIBLE_DATE_VESTING;\n    }\n\n    function version() external pure returns (string memory) {\n        return \"2.5\";\n    }\n\n}"
    },
    "contracts/FlexibleDateVestingVoucherDescriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@solv/v2-solidity-utils/contracts/access/AdminControl.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/StringConvertor.sol\";\nimport \"@solv/v2-solidity-utils/contracts/misc/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"@solv/v2-solidity-utils/contracts/openzeppelin/token/ERC20/ERC20Upgradeable.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"./interface/IVNFTDescriptor.sol\";\nimport \"./interface/IVoucherSVG.sol\";\nimport \"./FlexibleDateVestingVoucher.sol\";\nimport \"./FlexibleDateVestingPool.sol\";\n\ncontract FlexibleDateVestingVoucherDescriptor is IVNFTDescriptor, AdminControl {\n\n    event SetVoucherSVG(\n        address indexed voucher,\n        address oldVoucherSVG,\n        address newVoucherSVG\n    );\n\n    using StringConvertor for uint256;\n    using StringConvertor for address;\n    using StringConvertor for uint64[];\n    using StringConvertor for uint32[];\n\n    // FlexibleDateVestingVoucher address => VoucherSVG address\n    // Value of key `0x0` is defined as default VoucherSVG\n    mapping(address => address) public voucherSVGs;\n\n    bool internal _initialized;\n\n    function initialize(address defaultVoucherSVG_) external initializer {\n        AdminControl.__AdminControl_init(_msgSender());\n        setVoucherSVG(address(0), defaultVoucherSVG_);\n    }\n\n    function setVoucherSVG(address voucher_, address voucherSVG_) public onlyAdmin {\n        emit SetVoucherSVG(voucher_, voucherSVGs[voucher_], voucherSVG_);\n        voucherSVGs[voucher_] = voucherSVG_;\n    }\n\n    function contractURI() external view override returns (string memory) { \n        FlexibleDateVestingVoucher voucher = FlexibleDateVestingVoucher(_msgSender());\n        return string(\n            abi.encodePacked(\n                'data:application/json;{\"name\":\"', voucher.name(),\n                '\",\"description\":\"', _contractDescription(voucher),\n                '\",\"unitDecimals\":\"', uint256(voucher.unitDecimals()).toString(),\n                '\",\"properties\":{}}'\n            )\n        );\n    }\n\n    function slotURI(uint256 slot_) external view override returns (string memory) {\n        FlexibleDateVestingVoucher voucher = FlexibleDateVestingVoucher(_msgSender());\n        FlexibleDateVestingPool pool = voucher.flexibleDateVestingPool();\n        FlexibleDateVestingPool.SlotDetail memory slotDetail = pool.getSlotDetail(slot_);\n\n        return string(\n            abi.encodePacked(\n                'data:application/json;{\"unitsInSlot\":\"', voucher.unitsInSlot(slot_).toString(),\n                '\",\"tokensInSlot\":\"', voucher.tokensInSlot(slot_).toString(),\n                '\",\"properties\":', _properties(pool, slotDetail),\n                '}'\n            )\n        );\n    }\n\n    function tokenURI(uint256 tokenId_)\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        FlexibleDateVestingVoucher voucher = FlexibleDateVestingVoucher(_msgSender());\n        FlexibleDateVestingPool pool = voucher.flexibleDateVestingPool();\n\n        uint256 slot = voucher.slotOf(tokenId_);\n        FlexibleDateVestingPool.SlotDetail memory slotDetail = pool.getSlotDetail(slot);\n\n        bytes memory name = abi.encodePacked(\n            voucher.name(), ' #', tokenId_.toString(), ' - ', \n            _parseClaimType(slotDetail.claimType)\n        );\n\n        address voucherSVG = voucherSVGs[_msgSender()];\n        if (voucherSVG == address(0)) {\n            voucherSVG = voucherSVGs[address(0)];\n        }\n        string memory image = IVoucherSVG(voucherSVG).generateSVG(_msgSender(), tokenId_);\n\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        abi.encodePacked(\n                            '{\"name\":\"', name, \n                            '\",\"description\":\"', _tokenDescription(voucher, tokenId_, slotDetail),\n                            '\",\"image\":\"data:image/svg+xml;base64,', Base64.encode(bytes(image)),\n                            '\",\"units\":\"', voucher.unitsInToken(tokenId_).toString(),\n                            '\",\"slot\":\"', slot.toString(),\n                            '\",\"properties\":', _properties(pool, slotDetail),\n                            '}'\n                        )\n                    )\n                )\n            );\n    }\n\n    function _contractDescription(FlexibleDateVestingVoucher voucher) \n        private \n        view\n        returns (bytes memory)\n    {\n        string memory underlyingSymbol = ERC20Upgradeable(voucher.underlying()).symbol();\n\n        return abi.encodePacked(\n            unicode' ', _descAlert(), '\\\\n\\\\n',\n            'Flexible Date Vesting Voucher of ', underlyingSymbol, '. ',\n            _descVoucher(), '\\\\n\\\\n', \n            _descProtocol()\n        );\n    }\n\n    function _tokenDescription(\n        FlexibleDateVestingVoucher voucher, \n        uint256 tokenId, \n        FlexibleDateVestingPool.SlotDetail memory slotDetail\n    )\n        private\n        view\n        returns (bytes memory)\n    {\n        string memory underlyingSymbol = ERC20Upgradeable(voucher.underlying()).symbol();\n\n        return abi.encodePacked(\n            unicode' ', _descAlert(), '\\\\n\\\\n',\n            'Flexible Date Vesting Voucher #', tokenId.toString(), ' of ', underlyingSymbol, '. ',\n            _descVoucher(), '\\\\n\\\\n', \n            abi.encodePacked(\n                '- Claim Type: ', _parseClaimType(slotDetail.claimType), '\\\\n',\n                '- Latest Start Time: ', uint256(slotDetail.latestStartTime).datetimeToString(), '\\\\n',\n                '- Term: ', _parseTerms(slotDetail.terms), '\\\\n',\n                '- Voucher Address: ', address(voucher).addressToString(), '\\\\n',\n                '- Pool Address: ', address(voucher.flexibleDateVestingPool()).addressToString(), '\\\\n',\n                '- Underlying Address: ', voucher.underlying().addressToString()\n            )\n        );\n    }\n\n    function _descVoucher() private pure returns (string memory) {\n        return \"A Vesting Voucher with flexible date is used to represent a vesting plan with an undetermined start date. Once the date is settled, you will get a standard Vesting Voucher as the Voucher described.\";\n    }\n\n    function _descProtocol() private pure returns (string memory) {\n        return \"Solv Protocol is the decentralized platform for creating, managing and trading Financial NFTs. As its first Financial NFT product, Vesting Vouchers are fractionalized NFTs representing lock-up vesting tokens, thus releasing their liquidity and enabling financial scenarios such as fundraising, community building, and token liquidity management for crypto projects.\";\n    }\n\n    function _descAlert() private pure returns (string memory) {\n        return \"**Alert**: The amount of tokens in this Voucher NFT may have been out of date due to certain mechanisms of third-party marketplaces, thus leading you to mis-priced NFT on this page. Please be sure you're viewing on this Voucher on [Solv Protocol dApp](https://app.solv.finance) for details when you make offer or purchase it.\";\n    }\n\n    function _properties(\n        FlexibleDateVestingPool pool,\n        FlexibleDateVestingPool.SlotDetail memory slotDetail\n    ) \n        private\n        view\n        returns (bytes memory data) \n    {\n        return \n            abi.encodePacked(\n                abi.encodePacked(\n                    '{\"underlyingToken\":\"', pool.underlyingToken().addressToString(),\n                    '\",\"underlyingVesting\":\"', pool.underlyingVestingVoucher().addressToString()\n                ),\n                abi.encodePacked(\n                    '\",\"issuer\":\"', slotDetail.issuer.addressToString(), \n                    '\",\"claimType\":\"', _parseClaimType(slotDetail.claimType),\n                    '\",\"startTime\":\"', uint256(slotDetail.startTime).toString(),\n                    '\",\"latestStartTime\":\"', uint256(slotDetail.latestStartTime).toString(),\n                    '\",\"terms\":', slotDetail.terms.uintArray2str(),\n                    ',\"percentages\":', slotDetail.percentages.percentArray2str(),\n                    '}'\n                )\n            );\n    }\n\n    function _parseClaimType(uint8 claimTypeInNum_) private pure returns (string memory) {\n        return \n            claimTypeInNum_ == 0 ? \"Linear\" : \n            claimTypeInNum_ == 1 ? \"OneTime\" :\n            claimTypeInNum_ == 2 ? \"Staged\" : \n            \"Unknown\";\n    }\n\n    function _parseTerms(uint64[] memory terms) private pure returns (string memory) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < terms.length; i++) {\n            sum += terms[i];\n        }\n        return \n            string(\n                abi.encodePacked(\n                    (sum / 86400).toString(), ' days'\n                )\n            );\n    }\n}\n"
    },
    "contracts/interface/IFlexibleDateVestingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IFlexibleDateVestingPool {\n\n    struct SlotDetail {\n        address issuer;\n        uint8 claimType;\n        uint64 startTime;\n        uint64 latestStartTime;\n        uint64[] terms;\n        uint32[] percentages;\n        bool isValid;\n    }\n\n    /** ===== Begin of events emited by FlexibleDateVestingPool ===== */\n    event NewManager(address oldManager, address newManager);\n\n    event CreateSlot (\n        uint256 indexed slot,\n        address indexed issuer,\n        uint8 claimType,\n        uint64 latestStartTime,\n        uint64[] terms,\n        uint32[] percentages\n    );\n\n    event Mint (\n        address indexed minter,\n        uint256 indexed slot,\n        uint256 vestingAmount\n    );\n\n    event Claim (\n        uint256 indexed slot,\n        address indexed claimer,\n        uint256 claimAmount\n    );\n\n    event SetStartTime (\n        uint256 indexed slot,\n        uint64 oldStartTime,\n        uint64 newStartTime\n    );\n    /** ===== End of events emited by FlexibleDateVestingPool ===== */\n\n}"
    },
    "contracts/interface/IFlexibleDateVestingVoucher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\nimport \"@solv/v2-vnft-core/contracts/interface/IVNFT.sol\";\nimport \"@solv/v2-vnft-core/contracts/interface/optional/IVNFTMetadata.sol\";\nimport \"./IFlexibleDateVestingPool.sol\";\n\ninterface IFlexibleDateVestingVoucher is IVNFT, IVNFTMetadata {\n\n    struct FlexibleDateVestingVoucherSnapshot {\n        IFlexibleDateVestingPool.SlotDetail slotSnapshot;\n        uint256 tokenId;\n        uint256 vestingAmount;\n    }\n\n    /** ===== Begin of events emited by FlexibleDateVestingVoucher ===== */\n    event SetDescriptor(address oldDescriptor, address newDescriptor);\n\n    event SetSolver(address oldSolver, address newSolver);\n\n    event Claim(uint256 indexed tokenId, address to, uint256 claimAmount);\n    /** ===== End of events emited by FlexibleDateVestingVoucher ===== */\n\n\n    /** ===== Begin of interfaces of FlexibleDateVestingVoucher ===== */\n    function mint(\n        address issuer_,\n        uint8 claimType_,\n        uint64 latestStartTime_,\n        uint64[] calldata terms_,\n        uint32[] calldata percentages_,\n        uint256 vestingAmount_\n    ) \n        external \n        returns (uint256 slot, uint256 tokenId);\n\n    function claim(uint256 tokenId_, uint256 claimAmount_) external;\n\n    function claimTo(uint256 tokenId_, address to_, uint256 claimAmount_) external;\n\n    function setStartTime(uint256 slot_, uint64 startTime_) external;\n\n    function isClaimable(uint256 slot_) external view returns (bool);\n\n    function underlying() external view returns (address);\n\n    function underlyingVestingVoucher() external view returns (address);\n    /** ===== End of interfaces of FlexibleDateVestingVoucher ===== */\n\n}"
    },
    "contracts/interface/IVNFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IVNFTDescriptor {\n\n    function contractURI() external view returns (string memory);\n    function slotURI(uint256 slot) external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n}\n"
    },
    "contracts/interface/IVoucherSVG.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IVoucherSVG {\n\n    function generateSVG(address voucher_, uint256 tokenId_) external view returns (string memory);\n\n}"
    },
    "contracts/interface/external/IICToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\ninterface IICToken {\n\n    function mint(\n        uint64 term, \n        uint256 amount,\n        uint64[] calldata maturities, \n        uint32[] calldata percentages,\n        string memory originalInvestor\n    ) \n        external \n        returns (uint256 slot, uint256 tokenId);\n    \n    function vestingPool() external view returns (address vestingPoolAddress);\n\n}"
    }
  }
}