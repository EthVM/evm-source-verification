{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/PlanManager.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-03-26\n*/\n\n// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\n\npragma solidity ^0.6.6;\n\ninterface IArmorMaster {\n    function registerModule(bytes32 _key, address _module) external;\n    function getModule(bytes32 _key) external view returns(address);\n    function keep() external;\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n * \n * @dev Completely default OpenZeppelin.\n */\ncontract Ownable {\n    address private _owner;\n    address private _pendingOwner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    function initializeOwnable() internal {\n        require(_owner == address(0), \"already initialized\");\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"msg.sender is not owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _pendingOwner = newOwner;\n    }\n\n    function receiveOwnership() public {\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\n        _transferOwnership(_pendingOwner);\n        _pendingOwner = address(0);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    uint256[50] private __gap;\n}\n\nlibrary Bytes32 {\n    function toString(bytes32 x) internal pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n}\n\n/**\n * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\n**/\ncontract ArmorModule {\n    IArmorMaster internal _master;\n\n    using Bytes32 for bytes32;\n\n    modifier onlyOwner() {\n        require(msg.sender == Ownable(address(_master)).owner(), \"only owner can call this function\");\n        _;\n    }\n\n    modifier doKeep() {\n        _master.keep();\n        _;\n    }\n\n    modifier onlyModule(bytes32 _module) {\n        string memory message = string(abi.encodePacked(\"only module \", _module.toString(),\" can call this function\"));\n        require(msg.sender == getModule(_module), message);\n        _;\n    }\n\n    /**\n     * @dev Used when multiple can call.\n    **/\n    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\n        string memory message = string(abi.encodePacked(\"only module \", _moduleOne.toString(),\" or \", _moduleTwo.toString(),\" can call this function\"));\n        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\n        _;\n    }\n\n    function initializeModule(address _armorMaster) internal {\n        require(address(_master) == address(0), \"already initialized\");\n        require(_armorMaster != address(0), \"master cannot be zero address\");\n        _master = IArmorMaster(_armorMaster);\n    }\n\n    function changeMaster(address _newMaster) external onlyOwner {\n        _master = IArmorMaster(_newMaster);\n    }\n\n    function getModule(bytes32 _key) internal view returns(address) {\n        return _master.getModule(_key);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n * \n * @dev Default OpenZeppelin\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n  function calculateRoot(bytes32[] memory leaves) internal pure returns(bytes32) {\n    require(leaves.length > 0, \"Cannot compute zero length\");\n    bytes32[] memory elements = leaves;\n    bytes32[] memory nextLayer = new bytes32[]((elements.length+1)/2) ;\n    while(elements.length > 1) {\n      for(uint256 i = 0; i<elements.length;i+=2){\n        bytes32 left;\n        bytes32 right;\n        if(i == elements.length - 1){\n          left = elements[i];\n          right = elements[i];\n        }\n        else if(elements[i] <= elements[i+1]){\n          left = elements[i];\n          right = elements[i+1];\n        }\n        else {\n          left = elements[i+1];\n          right = elements[i];\n        }\n        bytes32 elem = keccak256(abi.encodePacked(left,right));\n        nextLayer[i/2] = elem;\n      }\n      elements = nextLayer;\n      nextLayer = new bytes32[]((elements.length+1)/2);\n    }\n    return elements[0];\n\n  }\n  /**\n   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n   * defined by `root`. For this, a `proof` must be provided, containing\n   * sibling hashes on the branch from the leaf to the root of the tree. Each\n   * pair of leaves and each pair of pre-images are assumed to be sorted.\n   */\n  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    bytes32 computedHash = leaf;\n\n    for (uint256 i = 0; i < proof.length; i++) {\n      bytes32 proofElement = proof[i];\n\n      if (computedHash <= proofElement) {\n        // Hash(current computed hash + current element of the proof)\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n      } else {\n        // Hash(current element of the proof + current computed hash)\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n      }\n    }\n\n    // Check if the computed hash (root) is equal to the provided root\n    return computedHash == root;\n  }\n}\n\ninterface IStakeManager {\n    function totalStakedAmount(address protocol) external view returns(uint256);\n    function protocolAddress(uint64 id) external view returns(address);\n    function protocolId(address protocol) external view returns(uint64);\n    function initialize(address _armorMaster) external;\n    function allowedCover(address _newProtocol, uint256 _newTotalCover) external view returns (bool);\n    function subtractTotal(uint256 _nftId, address _protocol, uint256 _subtractAmount) external;\n}\n\ninterface IBalanceManager {\n  event Deposit(address indexed user, uint256 amount);\n  event Withdraw(address indexed user, uint256 amount);\n  event Loss(address indexed user, uint256 amount);\n  event PriceChange(address indexed user, uint256 price);\n  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\n  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\n  function expireBalance(address _user) external;\n  function deposit(address _referrer) external payable;\n  function withdraw(uint256 _amount) external;\n  function initialize(address _armormaster, address _devWallet) external;\n  function balanceOf(address _user) external view returns (uint256);\n  function perSecondPrice(address _user) external view returns(uint256);\n  function changePrice(address user, uint64 _newPricePerSec) external;\n}\n\ninterface IPlanManager {\n  // Mapping = protocol => cover amount\n  struct Plan {\n      uint64 startTime;\n      uint64 endTime;\n      uint128 length;\n  }\n  \n  struct ProtocolPlan {\n      uint64 protocolId;\n      uint192 amount;\n  }\n    \n  // Event to notify frontend of plan update.\n  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\n  function userCoverageLimit(address _user, address _protocol) external view returns(uint256);\n  function markup() external view returns(uint256);\n  function nftCoverPrice(address _protocol) external view returns(uint256);\n  function initialize(address _armorManager) external;\n  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\n  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\n  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\n  function coverageLeft(address _protocol) external view returns(uint256);\n  function getCurrentPlan(address _user) external view returns(uint256 idx, uint128 start, uint128 end);\n  function updateExpireTime(address _user, uint256 _expiry) external;\n  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\n  function totalUsedCover(address _scAddress) external view returns (uint256);\n}\n\ninterface IClaimManager {\n    function initialize(address _armorMaster) external;\n    function transferNft(address _to, uint256 _nftId) external;\n    function exchangeWithdrawal(uint256 _amount) external;\n}\n\ncontract PlanManager is ArmorModule, IPlanManager {\n    \n    using SafeMath for uint;\n    \n    uint256 constant private DENOMINATOR = 1000;\n    \n    // List of plans that a user has purchased so there is a historical record.\n    mapping (address => Plan[]) public plans;\n\n    // keccak256(\"ARMORFI.PLAN\", address(user), uint256(planIdx), uint256(protocolIdx)) => ProtocolPlan\n    mapping (bytes32 => ProtocolPlan) public protocolPlan;\n    \n    // StakeManager calls this when a new NFT is added to update what the price for that protocol is.\n    // Cover price in ETH (1e18) of price per second per ETH covered.\n    mapping (address => uint256) public override nftCoverPrice;\n    \n    // Mapping to doKeep track of how much coverage we've sold for each protocol.\n    // smart contract address => total borrowed cover\n    mapping (address => uint256) public override totalUsedCover;\n    \n    // Protocol => amount of coverage bought by shields (then shields plus) for that protocol.\n    // Keep track of these to only allow a % of staked NFTs to be bought by each.\n    mapping (address => uint256) public arShieldCover;\n    mapping (address => uint256) public arShieldPlusCover;\n    mapping (address => uint256) public coreCover;\n    \n    // Percent allocated to each part of the system. 350 == 35%.\n    uint256 public arShieldPercent;\n    uint256 public arShieldPlusPercent;\n    uint256 public corePercent;\n    \n    // Mapping of the address of shields => 1 if they're arShield and 2 if they're arShieldPlus.\n    mapping (address => uint256) public arShields;\n    \n    // The amount of markup for Armor's service vs. the original cover cost. 200 == 200%.\n    uint256 public override markup;\n\n    modifier checkExpiry(address _user) {\n        IBalanceManager balanceManager = IBalanceManager(getModule(\"BALANCE\"));\n        if(balanceManager.balanceOf(_user) == 0 ){\n            balanceManager.expireBalance(_user);\n        }\n        _;\n    }\n    \n    function initialize(\n        address _armorMaster\n    ) external override {\n        initializeModule(_armorMaster);\n        markup = 150;\n        arShieldPercent = 350;\n        arShieldPlusPercent = 350;\n        corePercent = 300;\n    }\n    \n    function getCurrentPlan(address _user) external view override returns(uint256 idx, uint128 start, uint128 end){\n        if(plans[_user].length == 0){\n            return(0,0,0);\n        }\n        Plan memory plan = plans[_user][plans[_user].length-1];\n        \n        //return 0 if there is no active plan\n        if(plan.endTime < now){\n            return(0,0,0);\n        } else {\n            idx = plans[_user].length - 1;\n            start = plan.startTime;\n            end = plan.endTime;\n        }\n    }\n\n    function getProtocolPlan(address _user, uint256 _idx, address _protocol) external view returns(uint256 idx, uint64 protocolId, uint192 amount) {\n        IStakeManager stakeManager = IStakeManager(getModule(\"STAKE\"));\n        uint256 length = plans[_user][_idx].length;\n        for(uint256 i = 0; i<length; i++){\n            ProtocolPlan memory protocol = protocolPlan[_hashKey(_user, _idx, i)];\n            address addr = stakeManager.protocolAddress(protocol.protocolId);\n            if(addr == _protocol){\n                return (i, protocol.protocolId, protocol.amount);\n            }\n        }\n        return(0,0,0);\n    }\n\n    function userCoverageLimit(address _user, address _protocol) external view override returns(uint256){\n        IStakeManager stakeManager = IStakeManager(getModule(\"STAKE\"));\n        uint64 protocolId = stakeManager.protocolId(_protocol);\n       \n        uint256 idx = plans[_user].length - 1;\n        uint256 currentCover = 0;\n        if(idx != uint256(-1)){ \n            Plan memory plan = plans[_user][idx];\n            uint256 length = uint256( plan.length );\n\n            for (uint256 i = 0; i < length; i++) {\n                ProtocolPlan memory protocol = protocolPlan[ _hashKey(_user, idx, i) ];\n                if (protocol.protocolId == protocolId) currentCover = uint256( protocol.amount );\n            }\n        }\n\n        uint256 extraCover = coverageLeft(_protocol);\n\n        // Add current coverage because coverageLeft on planManager does not include what we're currently using.\n        return extraCover.add(currentCover);\n    }\n\n    /*\n     * @dev User can update their plan for cover amount on any protocol.\n     * @param _protocols Addresses of the protocols that we want coverage for.\n     * @param _coverAmounts The amount of coverage desired in WEI.\n     * @notice Let's simplify this somehow--even just splitting into different functions.\n    **/\n    function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts)\n      external\n      override\n      checkExpiry(msg.sender)\n      // doKeep\n    {\n        require(_protocols.length == _coverAmounts.length, \"protocol and coverAmount length mismatch\");\n        require(_protocols.length <= 30, \"You may not protect more than 30 protocols at once.\");\n        IBalanceManager balanceManager = IBalanceManager(getModule(\"BALANCE\"));\n        \n        // Need to get price of the protocol here\n        if(plans[msg.sender].length > 0){\n          Plan storage lastPlan = plans[msg.sender][plans[msg.sender].length - 1];\n\n          // this should happen only when plan is not expired yet\n          if(lastPlan.endTime > now) {\n              // First go through and subtract all old cover amounts.\n              _removeLatestTotals(msg.sender);\n              lastPlan.endTime = uint64(now);\n          }\n        }\n\n        _addNewTotals(_protocols, _coverAmounts);\n        uint256 newPricePerSec;\n        uint256 _markup = markup;\n        \n        // Loop through protocols, find price per second, add to rate, add coverage amount to mapping.\n        for (uint256 i = 0; i < _protocols.length; i++) {\n            require(nftCoverPrice[_protocols[i]] != 0, \"Protocol price is zero\");\n            \n            // nftCoverPrice is Wei per second per full Ether, so a cover amont in Wei. This is divided after this loop.\n            uint256 pricePerSec = nftCoverPrice[ _protocols[i] ].mul(_coverAmounts[i]);\n            newPricePerSec = newPricePerSec.add(pricePerSec);\n        }\n        \n        //newPricePerSec = newPricePerSec * _markup / 1e18 for decimals / 100 to make up for markup (200 == 200%);\n        newPricePerSec = newPricePerSec.mul(_markup).div(1e18).div(100);\n        \n        // this means user is canceling all plans\n        if(newPricePerSec == 0){\n            Plan memory newPlan;\n            newPlan = Plan(uint64(now), uint64(-1), uint128(0));\n            plans[msg.sender].push(newPlan);\n            balanceManager.changePrice(msg.sender, 0);\n            emit PlanUpdate(msg.sender, _protocols, _coverAmounts, uint64(-1));\n            return;\n        }\n\n        uint256 endTime = balanceManager.balanceOf(msg.sender).div(newPricePerSec).add(block.timestamp);\n        \n        // Let's make sure a user can pay for this for at least a week. Weird manipulation of utilization farming could happen otherwise.\n        require(endTime >= block.timestamp.add(7 days), \"Balance must be enough for 7 days of coverage.\");\n        \n        //add plan\n        Plan memory newPlan;\n        newPlan = Plan(uint64(now), uint64(endTime), uint128(_protocols.length));\n        plans[msg.sender].push(newPlan);\n        \n        //add protocol plan\n        for(uint256 i = 0;i<_protocols.length; i++){\n            bytes32 key = _hashKey(msg.sender, plans[msg.sender].length - 1, i);\n            uint64 protocolId = IStakeManager(getModule(\"STAKE\")).protocolId(_protocols[i]);\n            protocolPlan[key] = ProtocolPlan(protocolId, uint192(_coverAmounts[i]));\n        }\n        \n        // update balance price per second here\n        uint64 castPricePerSec = uint64(newPricePerSec);\n        require(uint256(castPricePerSec) == newPricePerSec);\n        IBalanceManager(getModule(\"BALANCE\")).changePrice(msg.sender, castPricePerSec);\n\n        emit PlanUpdate(msg.sender, _protocols, _coverAmounts, endTime);\n    }\n\n    /**\n     * @dev Update the contract-wide totals for each protocol that has changed.\n     * @param _user User whose plan is updating these totals.\n    **/\n    function _removeLatestTotals(address _user) internal {\n        Plan storage plan = plans[_user][plans[_user].length - 1];\n\n        uint256 idx = plans[_user].length - 1;\n\n        for (uint256 i = 0; i < plan.length; i++) {\n            bytes32 key = _hashKey(_user, idx, i);\n            ProtocolPlan memory protocol = protocolPlan[key];\n            address protocolAddress = IStakeManager(getModule(\"STAKE\")).protocolAddress(protocol.protocolId);\n            totalUsedCover[protocolAddress] = totalUsedCover[protocolAddress].sub(uint256(protocol.amount));\n            \n            uint256 shield = arShields[_user];\n            if (shield == 1) {\n                arShieldCover[protocolAddress] = arShieldCover[protocolAddress].sub(protocol.amount);\n            } else if (shield == 2) {\n                arShieldPlusCover[protocolAddress] = arShieldPlusCover[protocolAddress].sub(protocol.amount);\n            } else {\n                coreCover[protocolAddress] = coreCover[protocolAddress].sub(protocol.amount);\n            }   \n        }\n    }\n\n    /**\n     * @dev Add new totals for new protocol/cover amounts.\n     * @param _newProtocols Protocols that are being borrowed for.\n     * @param _newCoverAmounts Cover amounts (in Wei) that are being borrowed.\n    **/\n    function _addNewTotals(address[] memory _newProtocols, uint256[] memory _newCoverAmounts) internal {\n        for (uint256 i = 0; i < _newProtocols.length; i++) {\n            \n            (uint256 shield, uint256 allowed) = _checkBuyerAllowed(_newProtocols[i]);\n            require(allowed >= _newCoverAmounts[i], \"Exceeds allowed cover amount.\");\n            \n            totalUsedCover[_newProtocols[i]] = totalUsedCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n            \n            if (shield == 1) {\n                arShieldCover[_newProtocols[i]] = arShieldCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n            } else if (shield == 2) {\n                arShieldPlusCover[_newProtocols[i]] = arShieldPlusCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n            } else {\n                coreCover[_newProtocols[i]] = coreCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n            }\n        }\n    }\n\n    /**\n     * @dev Determine the amount of coverage left for a specific protocol.\n     * @param _protocol The address of the protocol we're determining coverage left for.\n    **/\n    function coverageLeft(address _protocol)\n      public\n      override\n      view\n    returns (uint256) {\n        (/* uint256 shield */, uint256 allowed) = _checkBuyerAllowed(_protocol);\n        return allowed;\n    }\n    \n    /**\n     * @dev Check whether the buyer is allowed to purchase this amount of cover.\n     *      Used because core can only buy 30%, and 35% for shields.\n     * @param _protocol The protocol cover is being purchased for.\n    **/\n    function _checkBuyerAllowed(address _protocol)\n      internal\n      view\n    returns (uint256, uint256)\n    {\n        uint256 totalAllowed = IStakeManager(getModule(\"STAKE\")).totalStakedAmount(_protocol);\n        uint256 shield = arShields[msg.sender];\n            \n        if (shield == 1) {\n            uint256 currentCover = arShieldCover[_protocol];\n            uint256 allowed = totalAllowed * arShieldPercent / DENOMINATOR;\n            return (shield, allowed > currentCover ? allowed - currentCover : 0);\n        } else if (shield == 2) {\n            uint256 currentCover = arShieldPlusCover[_protocol];\n            uint256 allowed = totalAllowed * arShieldPlusPercent / DENOMINATOR;\n            return (shield, allowed > currentCover ? allowed - currentCover : 0);\n        } else {\n            uint256 currentCover = coreCover[_protocol];\n            uint256 allowed = totalAllowed * corePercent / DENOMINATOR;\n            return (shield, allowed > currentCover ? allowed - currentCover : 0);        \n        }\n    }\n    \n    /**\n     * @dev Used by ClaimManager to check how much coverage the user had at the time of a hack.\n     * @param _user The user to check coverage for.\n     * @param _protocol The address of the protocol that was hacked. (Address used according to arNFT).\n     * @param _hackTime The timestamp of when a hack happened.\n     * @return index index of plan for hackTime\n     * @return check whether amount is allowed\n    **/\n    function checkCoverage(address _user, address _protocol, uint256 _hackTime, uint256 _amount)\n      external\n      view\n      override\n      returns(uint256 index, bool check)\n    {\n        // This may be more gas efficient if we don't grab this first but instead grab each plan from storage individually?\n        Plan[] storage planArray = plans[_user];\n        \n        // In normal operation, this for loop should never get too big.\n        // If it does (from malicious action), the user will be the only one to suffer.\n        for (int256 i = int256(planArray.length - 1); i >= 0; i--) {\n            Plan storage plan = planArray[uint256(i)];\n            // Only one plan will be active at the time of a hack--return cover amount from then.\n            if (_hackTime >= plan.startTime && _hackTime < plan.endTime) {\n                for(uint256 j = 0; j< plan.length; j++){\n                    bytes32 key = _hashKey(_user, uint256(i), j);\n                    if(IStakeManager(getModule(\"STAKE\")).protocolAddress(protocolPlan[key].protocolId) == _protocol){\n                        return (uint256(i), _amount <= uint256(protocolPlan[key].amount));\n                    }\n                }\n                return (uint256(i), false);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n    /**\n     * @dev ClaimManager redeems the plan if it has been claimed. Sets claim amount to 0 so it cannot be claimed again.\n     * @param _user User that is redeeming this plan.\n     * @param _planIndex The index in the user's Plan array that we're checking.\n     * @param _protocol Address of the protocol that a claim is being redeemed for.\n    **/\n    function planRedeemed(address _user, uint256 _planIndex, address _protocol) \n      external \n      override \n      onlyModule(\"CLAIM\")\n    {\n        Plan storage plan = plans[_user][_planIndex];\n        require(plan.endTime <= now, \"Cannot redeem active plan, update plan to redeem properly.\");\n\n        for (uint256 i = 0; i < plan.length; i++) {\n            bytes32 key = _hashKey(_user,_planIndex,i);\n            \n            ProtocolPlan memory protocol = protocolPlan[key];\n            address protocolAddress = IStakeManager(getModule(\"STAKE\")).protocolAddress(protocol.protocolId);\n            \n            if (protocolAddress == _protocol) protocolPlan[key].amount = 0;\n        }\n    }\n\n    /**\n     * @dev Armor has the ability to change the price that a user is paying for their insurance.\n     * @param _protocol The protocol whose arNFT price is being updated.\n     * @param _newPrice the new price PER SECOND that the user will be paying.\n    **/\n    function changePrice(address _protocol, uint256 _newPrice)\n      external\n      override\n      onlyModule(\"STAKE\")\n    {\n        nftCoverPrice[_protocol] = _newPrice;\n    }\n\n    /**\n     * @dev BalanceManager calls to update expire time of a plan when a deposit/withdrawal happens.\n     * @param _user Address whose balance was updated.\n     * @param _expiry New time plans expire.\n    **/\n    function updateExpireTime(address _user, uint256 _expiry)\n      external\n      override\n      onlyModule(\"BALANCE\")\n    {\n        if (plans[_user].length == 0) return;\n        Plan storage plan = plans[_user][plans[_user].length-1];\n        if (_expiry <= block.timestamp) _removeLatestTotals(_user);\n        plan.endTime = uint64(_expiry);\n    }\n    \n    /**\n     * @dev Hash for protocol info identifier.\n     * @param _user Address of the user.\n     * @param _planIndex Index of the plan in the user's plan array.\n     * @param _protoIndex Index of the protocol in the plan.\n     * @return Hash for identifier for protocolPlan mapping.\n    **/\n    function _hashKey(address _user, uint256 _planIndex, uint256 _protoIndex)\n      internal\n      pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\"ARMORFI.PLAN.\", _user, _planIndex, _protoIndex));\n    }\n    \n    /**\n     * @dev Owner (DAO) can adjust the markup buyers pay for coverage.\n     * @param _newMarkup The new markup that will be used. 100 == 100% (no markup).\n    **/\n    function adjustMarkup(uint256 _newMarkup)\n      external\n      onlyOwner\n    {\n        require(_newMarkup >= 100, \"Markup must be at least 0 (100%).\");\n        markup = _newMarkup;\n    }\n    \n    /**\n     * @dev Owner (DAO) can adjust the percent of coverage allowed for each product.\n     * @param _newCorePercent New percent of coverage for general arCore users.\n     * @param _newArShieldPercent New percent of coverage for arShields.\n     * @param _newArShieldPlusPercent New percent of coverage for arShield Plus.\n    **/\n    function adjustPercents(uint256 _newCorePercent, uint256 _newArShieldPercent, uint256 _newArShieldPlusPercent)\n      external\n      onlyOwner\n    {\n        require(_newCorePercent + _newArShieldPercent + _newArShieldPlusPercent == 1000, \"Total allocation cannot be more than 100%.\");\n        corePercent = _newCorePercent;\n        arShieldPercent = _newArShieldPercent;\n        arShieldPlusPercent = _newArShieldPlusPercent;\n    }\n    \n    /**\n     * @dev Owner (DAO) can adjust shields on the contract.\n     * @param _shieldAddress Array of addresses we're adjusting.\n     * @param _shieldType Type of shield: 1 for arShield, 2 for arShield Plus.\n    **/\n    function adjustShields(address[] calldata _shieldAddress, uint256[] calldata _shieldType)\n      external\n      onlyOwner\n    {\n        require(_shieldAddress.length == _shieldType.length, \"Submitted arrays are not of equal length.\");\n        for (uint256 i = 0; i < _shieldAddress.length; i++) {\n            arShields[_shieldAddress[i]] = _shieldType[i];\n        }\n    }\n\n    function forceAdjustTotalUsedCover(address[] calldata _protocols, uint256[] calldata _usedCovers) external onlyOwner {\n        for(uint256 i = 0; i<_protocols.length; i++){\n            totalUsedCover[_protocols[i]] = _usedCovers[i];\n        }\n    }\n}"}}}