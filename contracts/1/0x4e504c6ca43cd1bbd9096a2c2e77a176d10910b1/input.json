{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GenericKeep3rV2.sol":{"content":"pragma solidity >=0.6.8;\r\n\r\n\r\n// \r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// \r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n// \r\ninterface IMMStrategyHarvestKp3r {\r\n    event Keep3rSet(address keep3r);\r\n    event Keep3rHelperSet(address keep3rHelper);\r\n    event SlidingOracleSet(address slidingOracle);\r\n\r\n    // Actions by Keeper\r\n    event HarvestedByKeeper(address _strategy);\r\n\t\r\n    // Harvestable check\r\n    event HarvestableCheck(address _strategy, uint256 profitTokenAmount, uint256 profitFactor, uint256 profitInEther, uint256 ethCallCost);\r\n\r\n    // Setters\r\n    function setKeep3r(address _keep3r) external;\r\n\r\n    function setKeep3rHelper(address _keep3rHelper) external;\r\n\r\n    function setSlidingOracle(address _slidingOracle) external;\r\n\t\r\n    function setMinHarvestInterval(uint256 _interval) external;\r\n\t\r\n    function setProfitFactor(uint256 _profitFactor) external;\r\n\r\n    // Getters\r\n    function strategies() external view returns (address[] memory);\r\n\r\n    // psuedo view method, please use something similar to below tool to query\r\n    // https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic \r\n    function harvestable(address _strategy) external returns (bool);\r\n\r\n    // harvest actions for Keep3r\r\n    function harvest(address _strategy) external;\r\n\t\r\n    // harvest actions for free\r\n    function harvestForFree(address _strategy) external;\r\n\r\n    // Name of the Keep3r\r\n    function name() external pure returns (string memory);\r\n\r\n    event HarvestStrategyAdded(address _strategy, uint256 _requiredHarvest);\r\n\r\n    event HarvestStrategyModified(address _strategy, uint256 _requiredHarvest);\r\n\r\n    event HarvestStrategyRemoved(address _strategy);\r\n\r\n    // Modifiers\r\n    function addStrategy(address _strategy, uint256 _requiredHarvest) external;\r\n\r\n    function updateRequiredHarvestAmount(address _strategy, uint256 _requiredHarvest) external;\r\n\r\n    function removeHarvestStrategy(address _strategy) external;\r\n\r\n}\r\n\r\n// \r\ninterface IKeep3rV1 {\r\n    function KPRH() external returns (address);\r\n\r\n    function name() external returns (string memory);\r\n\r\n    function isKeeper(address) external returns (bool);\r\n\r\n    function worked(address keeper) external;\r\n\r\n    function addKPRCredit(address job, uint256 amount) external;\r\n\r\n    function addJob(address job) external;\r\n}\r\n\r\n// \r\nabstract contract Keep3r {\r\n    IKeep3rV1 public keep3r;\r\n\r\n    constructor(address _keep3r) public {\r\n        _setKeep3r(_keep3r);\r\n    }\r\n\r\n    function _setKeep3r(address _keep3r) internal {\r\n        keep3r = IKeep3rV1(_keep3r);\r\n    }\r\n\r\n    function _isKeeper() internal {\r\n        require(tx.origin == msg.sender, \"keep3r::isKeeper:keeper-is-a-smart-contract\");\r\n        require(keep3r.isKeeper(msg.sender), \"keep3r::isKeeper:keeper-is-not-registered\");\r\n    }\r\n\r\n    // Only checks if caller is a valid keeper, payment should be handled manually\r\n    modifier onlyKeeper() {\r\n        _isKeeper();\r\n        _;\r\n    }\r\n\r\n    // Checks if caller is a valid keeper, handles default payment after execution\r\n    modifier paysKeeper() {\r\n        _isKeeper();\r\n        _;\r\n        keep3r.worked(msg.sender);\r\n    }\r\n}\r\n\r\n// \r\ninterface IKeep3rV1Helper {\r\n    function getQuoteLimit(uint256 gasUsed) external view returns (uint256);\r\n}\r\n\r\n// \r\ninterface IUniswapV2SlidingOracle {\r\n    function current(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        address tokenOut\r\n    ) external view returns (uint256);\r\n    \r\n    function pairs() external view returns (address[] memory);\r\n}\r\n\r\n// \r\ninterface IStrategy {\r\n    function rewards() external view returns (address);\r\n\r\n    function gauge() external view returns (address);\r\n\r\n    function want() external view returns (address);\r\n\r\n    function timelock() external view returns (address);\r\n\r\n    function deposit() external;\r\n\r\n    function withdraw(address) external;\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function skim() external;\r\n\r\n    function withdrawAll() external returns (uint256);\r\n\r\n    function balanceOf() external view returns (uint256);\r\n\r\n    function harvest() external;\r\n\r\n    function setTimelock(address) external;\r\n\r\n    function setController(address _controller) external;\r\n\r\n    function execute(address _target, bytes calldata _data)\r\n        external\r\n        payable\r\n        returns (bytes memory response);\r\n\r\n    function execute(bytes calldata _data)\r\n        external\r\n        payable\r\n        returns (bytes memory response);\r\n}\r\n\r\n// \r\ninterface ICrvStrategy is IStrategy {\r\n    function getHarvestable() external returns (uint256);\r\n}\r\n\r\n// \r\ninterface ICompStrategy is IStrategy {\r\n    function getCompAccrued() external returns (uint256);\r\n}\r\n\r\n// \r\n// inspired by & thanks to https://macarse.medium.com/the-keep3r-network-experiment-bb1c5182bda3\r\ncontract GenericKeep3rV2 is Keep3r, IMMStrategyHarvestKp3r {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    EnumerableSet.AddressSet internal availableStrategies;\r\n    // required gas cost on harvest\r\n    mapping(address => uint256) public requiredHarvest;\r\n\t// last harvest timestamp for strategy\r\n    mapping(address => uint256) public strategyLastHarvest;\r\n    address public keep3rHelper;\r\n    address public slidingOracle;\r\n\r\n    address public constant KP3R = address(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\r\n    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\r\n    address public constant COMP = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\r\n\r\n    // for curve strategy\r\n    address public constant THREE_CRV_STRATEGY = address(0x1f11055EB66F2bBa647FB1ADc64B0DD4E0018dE7);\r\n    address public constant RENBTC_CRV_STRATEGY = address(0x5A709Dfa094273795B787CaAfC6855a120B2bEbd);\r\n\r\n\t// for compound strategy\r\n    address public constant DAI_STRATEGY = address(0xf0BA303fd2CE5eBbb22d0d6590463D7549A08388);\r\n    address public constant USDC_STRATEGY = address(0x8F288A56A6c06ffc75994a2d46E84F8bDa1a0744);\r\n\r\n    // The minimum number of seconds between harvest calls, once half a day\r\n    uint256 public minHarvestInterval = 43200;\r\n\r\n    // The minimum multiple that `callCost` must be above the profit to be \"justifiable\"\r\n    uint256 public profitFactor = 88;\r\n\r\n    address public governor;\r\n\r\n    constructor(\r\n        address _keep3r,\r\n        address _keep3rHelper,\r\n        address _slidingOracle\r\n    ) public Keep3r(_keep3r) {\r\n        keep3rHelper = _keep3rHelper;\r\n        slidingOracle = _slidingOracle;\r\n        governor = msg.sender;\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor, \"governable::only-governor\");\r\n        _;\r\n    }\r\n\r\n    function _setGovernor(address _governor) external onlyGovernor {\r\n        require(_governor != address(0), \"governable::governor-should-not-be-zero-addres\");\r\n        governor = _governor;\r\n    }\r\n\r\n    // Unique method to add a strategy with specified gas cost to the system\r\n    function addStrategy(address _strategy, uint256 _requiredHarvest) external override onlyGovernor {\r\n        _addHarvestStrategy(_strategy, _requiredHarvest);\r\n        availableStrategies.add(_strategy);\r\n    }\r\n\r\n    function _addHarvestStrategy(address _strategy, uint256 _requiredHarvest) internal {\r\n        require(requiredHarvest[_strategy] == 0, \"generic-keep3r-v2::add-harvest-strategy:strategy-already-added\");\r\n        _setRequiredHarvest(_strategy, _requiredHarvest);\r\n        emit HarvestStrategyAdded(_strategy, _requiredHarvest);\r\n    }\r\n\r\n    // Unique method to update a strategy with specified gas cost\r\n    function updateRequiredHarvestAmount(address _strategy, uint256 _requiredHarvest) external override onlyGovernor {\r\n        require(requiredHarvest[_strategy] > 0, \"generic-keep3r-v2::update-required-harvest:strategy-not-added\");\r\n        _setRequiredHarvest(_strategy, _requiredHarvest);\r\n        emit HarvestStrategyModified(_strategy, _requiredHarvest);\r\n    }\r\n\r\n    function removeHarvestStrategy(address _strategy) external override onlyGovernor {\r\n        require(requiredHarvest[_strategy] > 0, \"generic-keep3r-v2::remove-harvest-strategy:strategy-not-added\");\r\n        requiredHarvest[_strategy] = 0;\r\n        emit HarvestStrategyRemoved(_strategy);\r\n    }\r\n\r\n    function setMinHarvestInterval(uint256 _interval) external override onlyGovernor {\r\n        require(_interval > 0, \"!_interval\");\r\n        minHarvestInterval = _interval;\r\n    }\r\n\r\n    function setProfitFactor(uint256 _profitFactor) external override onlyGovernor {\r\n        require(_profitFactor > 0, \"!_profitFactor\");\r\n        profitFactor = _profitFactor;\r\n    }\r\n\r\n    function setKeep3r(address _keep3r) external override onlyGovernor {\r\n        _setKeep3r(_keep3r);\r\n        emit Keep3rSet(_keep3r);\r\n    }\r\n\r\n    function setKeep3rHelper(address _keep3rHelper) external override onlyGovernor {\r\n        keep3rHelper = _keep3rHelper;\r\n        emit Keep3rHelperSet(_keep3rHelper);\r\n    }\r\n\r\n    function setSlidingOracle(address _slidingOracle) external override onlyGovernor {\r\n        slidingOracle = _slidingOracle;\r\n        emit SlidingOracleSet(_slidingOracle);\r\n    }\r\n\r\n    function _setRequiredHarvest(address _strategy, uint256 _requiredHarvest) internal {\r\n        require(_requiredHarvest > 0, \"generic-keep3r-v2::set-required-harvest:should-not-be-zero\");\r\n        requiredHarvest[_strategy] = _requiredHarvest;\r\n    }\r\n\r\n    // Getters\r\n    function name() external pure override returns (string memory) {\r\n        return \"Generic Strategy Keep3r for Mushrooms harvest\";\r\n    }\r\n\r\n    function strategies() public view override returns (address[] memory _strategies) {\r\n        _strategies = new address[](availableStrategies.length());\r\n        for (uint256 i; i < availableStrategies.length(); i++) {\r\n            _strategies[i] = availableStrategies.at(i);\r\n        }\r\n    }\r\n\r\n    // this method is not specified as view since some strategy maybe not able to return accurate underlying profit in snapshot,\r\n\t// please use something similar to below tool to query\r\n\t// https://docs.ethers.io/v5/api/contract/contract/#contract-callStatic\r\n    function harvestable(address _strategy) public override returns (bool) {\r\n        require(requiredHarvest[_strategy] > 0, \"generic-keep3r-v2::harvestable:strategy-not-added\");\r\n\r\n        // Should not trigger if had been called recently\r\n        if (strategyLastHarvest[_strategy] > 0 && block.timestamp.sub(strategyLastHarvest[_strategy]) <= minHarvestInterval){\r\n            return false;\r\n        }\r\n\r\n        // quote from keep3r network for specified workload\r\n        uint256 kp3rCallCost = IKeep3rV1Helper(keep3rHelper).getQuoteLimit(requiredHarvest[_strategy]);\r\n        // get ETH gas cost by querying uniswap sliding oracle\r\n        uint256 ethCallCost = IUniswapV2SlidingOracle(slidingOracle).current(KP3R, kp3rCallCost, WETH);\r\n\r\n        // estimate yield profit to harvest\r\n        uint256 profitInEther = 0;\r\n        uint256 profitTokenAmount = 0;\r\n        if(_strategy == DAI_STRATEGY || _strategy == USDC_STRATEGY){\r\n            profitTokenAmount = ICompStrategy(_strategy).getCompAccrued();\r\n            profitInEther = IUniswapV2SlidingOracle(slidingOracle).current(COMP, profitTokenAmount, WETH);\r\n        }else{\r\n            profitTokenAmount = ICrvStrategy(_strategy).getHarvestable();\r\n            profitInEther = IUniswapV2SlidingOracle(slidingOracle).current(CRV, profitTokenAmount, WETH);\r\n        }\r\n\t\t\r\n        emit HarvestableCheck(_strategy, profitTokenAmount, profitFactor, profitInEther, ethCallCost);\r\n\r\n        // Only trigger if it \"makes sense\" economically (gas cost * profitFactor no bigger than profit to be harvested)\r\n        return (profitInEther >= profitFactor.mul(ethCallCost));\r\n    }\r\n\r\n    // harvest actions for Keep3r\r\n    function harvest(address _strategy) external override paysKeeper {\r\n        require(harvestable(_strategy), \"generic-keep3r-v2::harvest:not-workable\");\r\n        _harvest(_strategy);\r\n        emit HarvestedByKeeper(_strategy);\r\n    }\r\n\r\n    // harvest actions for free\r\n    function harvestForFree(address _strategy) external override {\r\n        require(harvestable(_strategy), \"generic-keep3r-v2::harvest:not-workable\");\r\n        _harvest(_strategy);\r\n    }\r\n\r\n    function _harvest(address _strategy) internal {\r\n        IStrategy(_strategy).harvest();\r\n        strategyLastHarvest[_strategy] = block.timestamp;\r\n    }\r\n}"}}}