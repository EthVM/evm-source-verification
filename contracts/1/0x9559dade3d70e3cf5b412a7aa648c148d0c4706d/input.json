{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"ERC20Crowdsale.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\n\r\ncontract ERC20Crowdsale is Ownable {\r\n    bool public isEnabled = false;\r\n\r\n    // ERC20 Token address => price mapping\r\n    mapping(address => uint256) public basePrice;\r\n\r\n    uint256 public maxSupply;\r\n    uint256 public totalSupply;\r\n\r\n    address public WETH;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // wallet addresses for beneficiary parties\r\n    address payable public charitiesBeneficiary;\r\n    address payable public carbonOffsetBeneficiary;\r\n    address payable public ccFundBeneficiary;\r\n    address payable public metaCarbonBeneficiary;\r\n    address payable public extraBeneficiary;\r\n\r\n    // distribution Percentile for beneficiary parties\r\n    uint8 public charitiesPercentile;\r\n    uint8 public carbonOffsetPercentile;\r\n    uint8 public ccFundPercentile;\r\n    uint8 public metaCarbonPercentile;\r\n    uint8 public extraPercentile;\r\n\r\n    /**\r\n     * @dev Emitted when token is purchased by `to` in `token` for `price`.\r\n     */\r\n    event Purchased(\r\n        address indexed to,\r\n        address indexed token,\r\n        uint256 indexed price\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when token is purchased by `to` in `token` for `price`.\r\n     */\r\n    event PurchasedWithBidPrice(\r\n        address indexed to,\r\n        address indexed token,\r\n        uint256 totalPrice,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    // have to provide WETH token address and price in\r\n    constructor(address wethAddress, uint256 priceInEth) {\r\n        WETH = wethAddress;\r\n        basePrice[WETH] = priceInEth;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: balance query for the zero address\"\r\n        );\r\n        return _balances[owner];\r\n    }\r\n\r\n    function setBasePriceInToken(address token, uint256 price)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(token != address(0), \"zero address cannot be used\");\r\n        basePrice[token] = price;\r\n    }\r\n\r\n    function removeToken(address token) external onlyOwner {\r\n        delete basePrice[token];\r\n    }\r\n\r\n    /*\r\n     * Pause sale if active, make active if paused\r\n     */\r\n    function setSaleStatus(bool status) public onlyOwner {\r\n        isEnabled = status;\r\n    }\r\n\r\n    function setCharitiesBeneficiary(address payable account)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(account != address(0), \"zero address cannot be used\");\r\n        charitiesBeneficiary = account;\r\n    }\r\n\r\n    function setCarbonOffsetBeneficiary(address payable account)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(account != address(0), \"zero address cannot be used\");\r\n        carbonOffsetBeneficiary = account;\r\n    }\r\n\r\n    function setCCFundBeneficiary(address payable account) external onlyOwner {\r\n        require(account != address(0), \"zero address cannot be used\");\r\n        ccFundBeneficiary = account;\r\n    }\r\n\r\n    function setMetaCarbonBeneficiary(address payable account)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(account != address(0), \"zero address cannot be used\");\r\n        metaCarbonBeneficiary = account;\r\n    }\r\n\r\n    function setExtraBeneficiary(address payable account) external onlyOwner {\r\n        require(account != address(0), \"zero address cannot be used\");\r\n        extraBeneficiary = account;\r\n    }\r\n\r\n    function setDistributionPercentile(\r\n        uint8 charities,\r\n        uint8 carbonOffset,\r\n        uint8 ccFund,\r\n        uint8 metaCarbon,\r\n        uint8 extra\r\n    ) external onlyOwner {\r\n        require(\r\n            charities + carbonOffset + ccFund + metaCarbon + extra == 100,\r\n            \"Sum of percentile should be 100\"\r\n        );\r\n        charitiesPercentile = charities;\r\n        carbonOffsetPercentile = carbonOffset;\r\n        ccFundPercentile = ccFund;\r\n        metaCarbonPercentile = metaCarbon;\r\n        extraPercentile = extra;\r\n    }\r\n\r\n    function setMaxSupply(uint256 supply) public onlyOwner {\r\n        require(supply > 0, \"amount should be greater than 0\");\r\n        maxSupply = supply;\r\n        totalSupply = 0;\r\n    }\r\n\r\n    function buyWithToken(address token, uint256 amount) public {\r\n        require(isEnabled, \"Sale is disabled\");\r\n        require(amount > 0, \"You need to buy at least 1 token\");\r\n        require(basePrice[token] > 0, \"Price in this token was not set\");\r\n        uint256 value = amount * basePrice[token];\r\n        uint256 allowance = IERC20(token).allowance(msg.sender, address(this));\r\n        require(allowance >= value, \"token allowance is not enough\");\r\n\r\n        TransferHelper.safeTransferFrom(\r\n            token,\r\n            msg.sender,\r\n            address(this),\r\n            value\r\n        );\r\n\r\n        _balances[msg.sender] += amount;\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            emit Purchased(msg.sender, token, basePrice[token]);\r\n        }\r\n    }\r\n\r\n    function buyWithTokenBidPrice(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 totalPrice\r\n    ) public {\r\n        require(isEnabled, \"Sale is disabled\");\r\n        require(amount > 0, \"need to buy at least 1 token\");\r\n        require(basePrice[token] > 0, \"Price in this token was not set\");\r\n\r\n        uint256 value = amount * basePrice[token];\r\n        require(\r\n            totalPrice >= value,\r\n            \"bid price should be greater than base price\"\r\n        );\r\n\r\n        uint256 allowance = IERC20(token).allowance(msg.sender, address(this));\r\n        require(allowance >= totalPrice, \"token allowance is not enough\");\r\n\r\n        TransferHelper.safeTransferFrom(\r\n            token,\r\n            msg.sender,\r\n            address(this),\r\n            totalPrice\r\n        );\r\n\r\n        _balances[msg.sender] += amount;\r\n        totalSupply += amount;\r\n        emit PurchasedWithBidPrice(msg.sender, token, totalPrice, amount);\r\n    }\r\n\r\n    /**\r\n     * Fallback function is called when msg.data is empty\r\n     */\r\n    receive() external payable {\r\n        buyWithEth();\r\n    }\r\n\r\n    /**\r\n     * paid mint for sale.\r\n     */\r\n    function buyWithEth() public payable {\r\n        require(isEnabled, \"Sale is disabled\");\r\n        require(totalSupply < maxSupply, \"Total Supply is already reached\");\r\n        require(msg.value >= basePrice[WETH], \"Not enough ETH sent\");\r\n\r\n        _balances[msg.sender] += 1;\r\n        totalSupply++;\r\n\r\n        uint256 remaining = msg.value - basePrice[WETH];\r\n\r\n        // _forwardFunds(basePrice[WETH]);\r\n\r\n        if (remaining > 0) {\r\n            TransferHelper.safeTransferETH(msg.sender, remaining);\r\n        }\r\n\r\n        emit Purchased(msg.sender, WETH, basePrice[WETH]);\r\n    }\r\n\r\n    function buyWithEthBidPrice(uint256 amount) public payable {\r\n        require(amount > 0, \"need to buy at least 1 token\");\r\n        require(isEnabled, \"Sale is disabled\");\r\n        require(totalSupply < maxSupply, \"Total Supply is already reached\");\r\n        require(msg.value >= basePrice[WETH] * amount, \"Not enough ETH sent\");\r\n\r\n        _balances[msg.sender] += amount;\r\n        totalSupply += amount;\r\n\r\n        emit PurchasedWithBidPrice(msg.sender, WETH, msg.value, amount);\r\n    }\r\n\r\n    function _forwardToken(address token, uint256 amount) private {\r\n        require(\r\n            charitiesPercentile +\r\n                carbonOffsetPercentile +\r\n                ccFundPercentile +\r\n                metaCarbonPercentile +\r\n                extraPercentile ==\r\n                100,\r\n            \"Sum of percentile should be 100\"\r\n        );\r\n        require(amount > 0, \"amount should be greater than zero\");\r\n        uint256 value = (amount * charitiesPercentile) / 100;\r\n        uint256 remaining = amount - value;\r\n        if (value > 0) {\r\n            require(\r\n                charitiesBeneficiary != address(0),\r\n                \"Charities wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransfer(token, charitiesBeneficiary, value);\r\n        }\r\n\r\n        value = (amount * carbonOffsetPercentile) / 100;\r\n        if (value > 0) {\r\n            require(\r\n                carbonOffsetBeneficiary != address(0),\r\n                \"CarbonOffset wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransfer(token, carbonOffsetBeneficiary, value);\r\n            remaining -= value;\r\n        }\r\n\r\n        value = (amount * ccFundPercentile) / 100;\r\n        if (value > 0) {\r\n            require(\r\n                ccFundBeneficiary != address(0),\r\n                \"ccFund wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransfer(token, ccFundBeneficiary, value);\r\n            remaining -= value;\r\n        }\r\n\r\n        value = (amount * extraPercentile) / 100;\r\n        if (value > 0) {\r\n            require(extraBeneficiary != address(0), \"extra wallet is not set\");\r\n            TransferHelper.safeTransfer(token, extraBeneficiary, value);\r\n            remaining -= value;\r\n        }\r\n\r\n        // no need to calculate, just send all remaining funds to extra\r\n        if (remaining > 0) {\r\n            require(\r\n                metaCarbonBeneficiary != address(0),\r\n                \"metaCarbon wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransfer(\r\n                token,\r\n                metaCarbonBeneficiary,\r\n                remaining\r\n            );\r\n        }\r\n    }\r\n\r\n    function _forwardETH(uint256 amount) private {\r\n        require(amount > 0, \"balance is not enough\");\r\n        uint256 value = (amount * charitiesPercentile) / 100;\r\n        uint256 remaining = amount - value;\r\n        if (value > 0) {\r\n            require(\r\n                charitiesBeneficiary != address(0),\r\n                \"Charities wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransferETH(charitiesBeneficiary, value);\r\n        }\r\n\r\n        value = (amount * carbonOffsetPercentile) / 100;\r\n        if (value > 0) {\r\n            require(\r\n                carbonOffsetBeneficiary != address(0),\r\n                \"CarbonOffset wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransferETH(carbonOffsetBeneficiary, value);\r\n            remaining -= value;\r\n        }\r\n\r\n        value = (amount * ccFundPercentile) / 100;\r\n        if (value > 0) {\r\n            require(\r\n                ccFundBeneficiary != address(0),\r\n                \"ccFund wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransferETH(ccFundBeneficiary, value);\r\n            remaining -= value;\r\n        }\r\n\r\n        value = (amount * extraPercentile) / 100;\r\n        if (value > 0) {\r\n            require(extraBeneficiary != address(0), \"extra wallet is not set\");\r\n            TransferHelper.safeTransferETH(extraBeneficiary, value);\r\n            remaining -= value;\r\n        }\r\n\r\n        // no need to calculate, just send all remaining funds to extra\r\n        if (remaining > 0) {\r\n            require(\r\n                metaCarbonBeneficiary != address(0),\r\n                \"metaCarbon wallet is not set\"\r\n            );\r\n            TransferHelper.safeTransferETH(metaCarbonBeneficiary, remaining);\r\n        }\r\n    }\r\n\r\n    function withdrawEth() external onlyOwner {\r\n        _forwardETH(address(this).balance);\r\n    }\r\n\r\n    function withdrawToken(address token) external onlyOwner {\r\n        _forwardToken(token, IERC20(token).balanceOf(address(this)));\r\n    }\r\n}\r\n"},"libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.6.0;\r\n\r\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}"}}}