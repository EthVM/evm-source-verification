{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Distributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// File: interfaces/IOlympusAuthority.sol\r\n\r\n\r\npragma solidity =0.7.5;\r\n\r\ninterface IOlympusAuthority {\r\n    /* ========== EVENTS ========== */\r\n    \r\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n\r\n    event GovernorPulled(address indexed from, address indexed to);\r\n    event GuardianPulled(address indexed from, address indexed to);\r\n    event PolicyPulled(address indexed from, address indexed to);\r\n    event VaultPulled(address indexed from, address indexed to);\r\n\r\n    /* ========== VIEW ========== */\r\n    \r\n    function governor() external view returns (address);\r\n    function guardian() external view returns (address);\r\n    function policy() external view returns (address);\r\n    function vault() external view returns (address);\r\n}\r\n// File: types/OlympusAccessControlled.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\nabstract contract OlympusAccessControlled {\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\r\n\r\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IOlympusAuthority public authority;\r\n\r\n\r\n    /* ========== Constructor ========== */\r\n\r\n    constructor(IOlympusAuthority _authority) {\r\n        authority = _authority;\r\n        emit AuthorityUpdated(_authority);\r\n    }\r\n    \r\n\r\n    /* ========== MODIFIERS ========== */\r\n    \r\n    modifier onlyGovernor() {\r\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyGuardian() {\r\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPolicy() {\r\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVault() {\r\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    /* ========== GOV ONLY ========== */\r\n    \r\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n}\r\n\r\n// File: interfaces/IDistributor.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IDistributor {\r\n    function distribute() external;\r\n    function bounty() external view returns (uint256);\r\n    function nextRewardAt(uint256 _rate) external view returns (uint256);\r\n    function nextRewardFor(address _recipient) external view returns (uint256);\r\n    function setBounty(uint256 _bounty) external;\r\n    function addRecipient(address _recipient, uint256 _rewardRate) external;\r\n    function removeRecipient(uint256 _index) external;\r\n    function setAdjustment(\r\n        uint256 _index,\r\n        bool _add,\r\n        uint256 _rate,\r\n        uint256 _target\r\n    ) external;\r\n}\r\n// File: interfaces/ITreasury.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface ITreasury {\r\n    function deposit(\r\n        uint256 _amount,\r\n        address _token,\r\n        uint256 _profit\r\n    ) external returns (uint256);\r\n\r\n    function withdraw(uint256 _amount, address _token) external;\r\n\r\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\r\n\r\n    function mint(address _recipient, uint256 _amount) external;\r\n\r\n    function manage(address _token, uint256 _amount) external;\r\n\r\n    function incurDebt(uint256 amount_, address token_) external;\r\n\r\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\r\n\r\n    function excessReserves() external view returns (uint256);\r\n\r\n    function baseSupply() external view returns (uint256);\r\n}\r\n\r\n// File: libraries/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    // Only used in the  BondingCalculator.sol\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n\r\n}\r\n// File: interfaces/IERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: libraries/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\r\n/// Taken from Solmate\r\nlibrary SafeERC20 {\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        (bool success, ) = to.call{value: amount}(new bytes(0));\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n// File: StakingDistributor.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Distributor is IDistributor, OlympusAccessControlled {\r\n    /* ========== DEPENDENCIES ========== */\r\n\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ====== VARIABLES ====== */\r\n\r\n    IERC20 private immutable ohm;\r\n    ITreasury private immutable treasury;\r\n    address private immutable staking;\r\n\r\n    mapping(uint256 => Adjust) public adjustments;\r\n    uint256 public override bounty;\r\n\r\n    uint256 private immutable rateDenominator = 1_000_000;\r\n\r\n    /* ====== STRUCTS ====== */\r\n\r\n    struct Info {\r\n        uint256 rate; // in ten-thousandths ( 5000 = 0.5% )\r\n        address recipient;\r\n    }\r\n    Info[] public info;\r\n\r\n    struct Adjust {\r\n        bool add;\r\n        uint256 rate;\r\n        uint256 target;\r\n    }\r\n\r\n    /* ====== CONSTRUCTOR ====== */\r\n\r\n    constructor(\r\n        address _treasury,\r\n        address _ohm,\r\n        address _staking, \r\n        address _authority\r\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\r\n        require(_treasury != address(0), \"Zero address: Treasury\");\r\n        treasury = ITreasury(_treasury);\r\n        require(_ohm != address(0), \"Zero address: OHM\");\r\n        ohm = IERC20(_ohm);\r\n        require(_staking != address(0), \"Zero address: Staking\");\r\n        staking = _staking;\r\n    }\r\n\r\n    /* ====== PUBLIC FUNCTIONS ====== */\r\n\r\n    /**\r\n        @notice send epoch reward to staking contract\r\n     */\r\n    function distribute() external override {\r\n        require(msg.sender == staking, \"Only staking\");\r\n        // distribute rewards to each recipient\r\n        for (uint256 i = 0; i < info.length; i++) {\r\n            if (info[i].rate > 0) {\r\n                if (info[i].recipient == staking) {\r\n                    treasury.mint(info[i].recipient, nextRewardAt(info[i].rate).add(bounty)); // mint and send with bounty\r\n                } else {\r\n                    treasury.mint(info[i].recipient, nextRewardAt(info[i].rate)); // mint and send tokens\r\n                }\r\n                adjust(i); // check for adjustment\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ====== INTERNAL FUNCTIONS ====== */\r\n\r\n    /**\r\n        @notice increment reward rate for collector\r\n     */\r\n    function adjust(uint256 _index) internal {\r\n        Adjust memory adjustment = adjustments[_index];\r\n        if (adjustment.rate != 0) {\r\n            if (adjustment.add) {\r\n                // if rate should increase\r\n                info[_index].rate = info[_index].rate.add(adjustment.rate); // raise rate\r\n                if (info[_index].rate >= adjustment.target) {\r\n                    // if target met\r\n                    adjustments[_index].rate = 0; // turn off adjustment\r\n                    info[_index].rate = adjustment.target; // set to target\r\n                }\r\n            } else {\r\n                // if rate should decrease\r\n                if (info[_index].rate > adjustment.rate) { // protect from underflow\r\n                    info[_index].rate = info[_index].rate.sub(adjustment.rate); // lower rate\r\n                } else {\r\n                    info[_index].rate = 0;\r\n                }\r\n                \r\n                if (info[_index].rate <= adjustment.target) {\r\n                    // if target met\r\n                    adjustments[_index].rate = 0; // turn off adjustment\r\n                    info[_index].rate = adjustment.target; // set to target\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ====== VIEW FUNCTIONS ====== */\r\n\r\n    /**\r\n        @notice view function for next reward at given rate\r\n        @param _rate uint\r\n        @return uint\r\n     */\r\n    function nextRewardAt(uint256 _rate) public view override returns (uint256) {\r\n        return ohm.totalSupply().mul(_rate).div(rateDenominator);\r\n    }\r\n\r\n    /**\r\n        @notice view function for next reward for specified address\r\n        @param _recipient address\r\n        @return uint\r\n     */\r\n    function nextRewardFor(address _recipient) public view override returns (uint256) {\r\n        uint256 reward;\r\n        for (uint256 i = 0; i < info.length; i++) {\r\n            if (info[i].recipient == _recipient) {\r\n                reward = reward.add(nextRewardAt(info[i].rate));\r\n            }\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    /* ====== POLICY FUNCTIONS ====== */\r\n\r\n    /**\r\n     * @notice set bounty to incentivize keepers\r\n     * @param _bounty uint256\r\n     */\r\n    function setBounty(uint256 _bounty) external override onlyGovernor {\r\n        require(_bounty <= 2e9, \"Too much\");\r\n        bounty = _bounty;\r\n    }\r\n\r\n    /**\r\n        @notice adds recipient for distributions\r\n        @param _recipient address\r\n        @param _rewardRate uint\r\n     */\r\n    function addRecipient(address _recipient, uint256 _rewardRate) external override onlyGovernor {\r\n        require(_recipient != address(0), \"Zero address: Recipient\");\r\n        require(_rewardRate <= rateDenominator, \"Rate cannot exceed denominator\");\r\n        info.push(Info({recipient: _recipient, rate: _rewardRate}));\r\n    }\r\n\r\n    /**\r\n        @notice removes recipient for distributions\r\n        @param _index uint\r\n     */\r\n    function removeRecipient(uint256 _index) external override {\r\n        require(msg.sender == authority.governor() || msg.sender == authority.guardian(), \"Caller is not governor or guardian\");\r\n        require(info[_index].recipient != address(0), \"Recipient does not exist\");\r\n        info[_index].recipient = address(0);\r\n        info[_index].rate = 0;\r\n    }\r\n\r\n    /**\r\n        @notice set adjustment info for a collector's reward rate\r\n        @param _index uint\r\n        @param _add bool\r\n        @param _rate uint\r\n        @param _target uint\r\n     */\r\n    function setAdjustment(\r\n        uint256 _index,\r\n        bool _add,\r\n        uint256 _rate,\r\n        uint256 _target\r\n    ) external override {\r\n        require(msg.sender == authority.governor() || msg.sender == authority.guardian(), \"Caller is not governor or guardian\");\r\n        require(info[_index].recipient != address(0), \"Recipient does not exist\");\r\n\r\n        if (msg.sender == authority.guardian()) {\r\n            require(_rate <= info[_index].rate.mul(25).div(1000), \"Limiter: cannot adjust by >2.5%\");\r\n        }\r\n\r\n        if (!_add) {\r\n            require(_rate <= info[_index].rate, \"Cannot decrease rate by more than it already is\");\r\n        }\r\n\r\n        adjustments[_index] = Adjust({add: _add, rate: _rate, target: _target});\r\n    }\r\n}"
    }
  }
}