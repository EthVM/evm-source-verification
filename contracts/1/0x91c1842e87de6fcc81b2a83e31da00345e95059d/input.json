{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/ABDKMath64x64.sol": {
      "content": "/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.5.0 || ^0.6.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /**\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /**\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n    return int128 (x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    return int64 (x >> 64);\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    require (x <= 0x7FFFFFFFFFFFFFFF);\n    return int128 (x << 64);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    require (x >= 0);\n    return uint64 (x >> 64);\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    int256 result = x >> 64;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    return int256 (x) << 64;\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) + y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) - y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    int256 result = int256(x) * y >> 64;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    if (x == MIN_64x64) {\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n        y <= 0x1000000000000000000000000000000000000000000000000);\n      return -y << 63;\n    } else {\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x;\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint256 absoluteResult = mulu (x, uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <=\n          0x8000000000000000000000000000000000000000000000000000000000000000);\n        return -int256 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <=\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int256 (absoluteResult);\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    if (y == 0) return 0;\n\n    require (x >= 0);\n\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n    uint256 hi = uint256 (x) * (y >> 128);\n\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    hi <<= 64;\n\n    require (hi <=\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n    return hi + lo;\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    require (y != 0);\n    int256 result = (int256 (x) << 64) / y;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    require (y != 0);\n\n    bool negativeResult = false;\n    if (x < 0) {\n      x = -x; // We rely on overflow behavior here\n      negativeResult = true;\n    }\n    if (y < 0) {\n      y = -y; // We rely on overflow behavior here\n      negativeResult = !negativeResult;\n    }\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n    if (negativeResult) {\n      require (absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128 (absoluteResult); // We rely on overflow behavior here\n    } else {\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128 (absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    require (y != 0);\n    uint128 result = divuu (x, y);\n    require (result <= uint128 (MAX_64x64));\n    return int128 (result);\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    require (x != MIN_64x64);\n    return -x;\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    require (x != MIN_64x64);\n    return x < 0 ? -x : x;\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    require (x != 0);\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\n    require (result >= MIN_64x64 && result <= MAX_64x64);\n    return int128 (result);\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    return int128 ((int256 (x) + int256 (y)) >> 1);\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    int256 m = int256 (x) * int256 (y);\n    require (m >= 0);\n    require (m <\n        0x4000000000000000000000000000000000000000000000000000000000000000);\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    uint256 absoluteResult;\n    bool negativeResult = false;\n    if (x >= 0) {\n      absoluteResult = powu (uint256 (x) << 63, y);\n    } else {\n      // We rely on overflow behavior here\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\n      negativeResult = y & 1 > 0;\n    }\n\n    absoluteResult >>= 63;\n\n    if (negativeResult) {\n      require (absoluteResult <= 0x80000000000000000000000000000000);\n      return -int128 (absoluteResult); // We rely on overflow behavior here\n    } else {\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return int128 (absoluteResult); // We rely on overflow behavior here\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    require (x >= 0);\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    require (x > 0);\n\n    int256 msb = 0;\n    int256 xc = x;\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n    int256 result = msb - 64 << 64;\n    uint256 ux = uint256 (x) << 127 - msb;\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n      ux *= ux;\n      uint256 b = ux >> 255;\n      ux >>= 127 + b;\n      result += bit * int256 (b);\n    }\n\n    return int128 (result);\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    require (x > 0);\n\n    return int128 (\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    require (x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    uint256 result = 0x80000000000000000000000000000000;\n\n    if (x & 0x8000000000000000 > 0)\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n    if (x & 0x4000000000000000 > 0)\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n    if (x & 0x2000000000000000 > 0)\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n    if (x & 0x1000000000000000 > 0)\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n    if (x & 0x800000000000000 > 0)\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n    if (x & 0x400000000000000 > 0)\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n    if (x & 0x200000000000000 > 0)\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n    if (x & 0x100000000000000 > 0)\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n    if (x & 0x80000000000000 > 0)\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n    if (x & 0x40000000000000 > 0)\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n    if (x & 0x20000000000000 > 0)\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n    if (x & 0x10000000000000 > 0)\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n    if (x & 0x8000000000000 > 0)\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n    if (x & 0x4000000000000 > 0)\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n    if (x & 0x2000000000000 > 0)\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n    if (x & 0x1000000000000 > 0)\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n    if (x & 0x800000000000 > 0)\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n    if (x & 0x400000000000 > 0)\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n    if (x & 0x200000000000 > 0)\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n    if (x & 0x100000000000 > 0)\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n    if (x & 0x80000000000 > 0)\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n    if (x & 0x40000000000 > 0)\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n    if (x & 0x20000000000 > 0)\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n    if (x & 0x10000000000 > 0)\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n    if (x & 0x8000000000 > 0)\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n    if (x & 0x4000000000 > 0)\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n    if (x & 0x2000000000 > 0)\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n    if (x & 0x1000000000 > 0)\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n    if (x & 0x800000000 > 0)\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n    if (x & 0x400000000 > 0)\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n    if (x & 0x200000000 > 0)\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n    if (x & 0x100000000 > 0)\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n    if (x & 0x80000000 > 0)\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n    if (x & 0x40000000 > 0)\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n    if (x & 0x20000000 > 0)\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n    if (x & 0x10000000 > 0)\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n    if (x & 0x8000000 > 0)\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n    if (x & 0x4000000 > 0)\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n    if (x & 0x2000000 > 0)\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n    if (x & 0x1000000 > 0)\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n    if (x & 0x800000 > 0)\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n    if (x & 0x400000 > 0)\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n    if (x & 0x200000 > 0)\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n    if (x & 0x100000 > 0)\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n    if (x & 0x80000 > 0)\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n    if (x & 0x40000 > 0)\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n    if (x & 0x20000 > 0)\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n    if (x & 0x10000 > 0)\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n    if (x & 0x8000 > 0)\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n    if (x & 0x4000 > 0)\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n    if (x & 0x2000 > 0)\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n    if (x & 0x1000 > 0)\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n    if (x & 0x800 > 0)\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n    if (x & 0x400 > 0)\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n    if (x & 0x200 > 0)\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n    if (x & 0x100 > 0)\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n    if (x & 0x80 > 0)\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n    if (x & 0x40 > 0)\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n    if (x & 0x20 > 0)\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n    if (x & 0x10 > 0)\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n    if (x & 0x8 > 0)\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n    if (x & 0x4 > 0)\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n    if (x & 0x2 > 0)\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n    if (x & 0x1 > 0)\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n    result >>= 63 - (x >> 64);\n    require (result <= uint256 (MAX_64x64));\n\n    return int128 (result);\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    require (x < 0x400000000000000000); // Overflow\n\n    if (x < -0x400000000000000000) return 0; // Underflow\n\n    return exp_2 (\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    require (y != 0);\n\n    uint256 result;\n\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      result = (x << 64) / y;\n    else {\n      uint256 msb = 192;\n      uint256 xc = x >> 192;\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 hi = result * (y >> 128);\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n      uint256 xh = x >> 192;\n      uint256 xl = x << 64;\n\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n      lo = hi << 128;\n      if (xl < lo) xh -= 1;\n      xl -= lo; // We rely on overflow behavior here\n\n      assert (xh == hi >> 128);\n\n      result += xl / y;\n    }\n\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n    return uint128 (result);\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x unsigned 129.127-bit fixed point number\n   * @param y uint256 value\n   * @return unsigned 129.127-bit fixed point number\n   */\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\n    if (y == 0) return 0x80000000000000000000000000000000;\n    else if (x == 0) return 0;\n    else {\n      int256 msb = 0;\n      uint256 xc = x;\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 xe = msb - 127;\n      if (xe > 0) x >>= xe;\n      else x <<= -xe;\n\n      uint256 result = 0x80000000000000000000000000000000;\n      int256 re = 0;\n\n      while (y > 0) {\n        if (y & 1 > 0) {\n          result = result * x;\n          y -= 1;\n          re += xe;\n          if (result >=\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\n            result >>= 128;\n            re += 1;\n          } else result >>= 127;\n          if (re < -127) return 0; // Underflow\n          require (re < 128); // Overflow\n        } else {\n          x = x * x;\n          y >>= 1;\n          xe <<= 1;\n          if (x >=\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\n            x >>= 128;\n            xe += 1;\n          } else x >>= 127;\n          if (xe < -127) return 0; // Underflow\n          require (xe < 128); // Overflow\n        }\n      }\n\n      if (re > 0) result <<= re;\n      else if (re < 0) result >>= -re;\n\n      return result;\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\n    if (x == 0) return 0;\n    else {\n      require (r > 0);\n      while (true) {\n        uint256 rr = x / r;\n        if (r == rr || r + 1 == rr) return uint128 (r);\n        else if (r == rr + 1) return uint128 (rr);\n        r = r + rr + 1 >> 1;\n      }\n    }\n  }\n}"
    },
    "contracts/PartyBidRA.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\n// ============ Imports ============\n\nimport \"./ABDKMath64x64.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport { ReserveAuctionV3, IMarket, IMediaModified, Decimal } from \"./ReserveAuctionV3_flat.sol\";\n\n// ============ Interface declarations ============\n\n// Wrapped Ether\ninterface IWETH {\n  function deposit() external payable;\n  function approve(address guy, uint wad) external returns (bool);\n  function balanceOf(address src) external view returns (uint256);\n  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n}\n\n// ERC721\ninterface IERC721 {\n  function ownerOf(uint256 tokenId) external view returns (address);\n  function transferFrom(address from, address to, uint256 tokenId) external view;\n}\n\n// IMedia (with bid acceptance extension)\ninterface IMediaExtended {\n  function acceptBid(uint256 tokenId, IMarket.Bid calldata bid) external;\n}\n\n// @dev: Must use wETH for all outgoing transactions, since returned capital from contract will\n//       always be wETH (due to hard 30,000 imposed gas limitation at ETH transfer layer).\ncontract PartyBid {\n  // Use OpenZeppelin library for SafeMath\n  using SafeMath for uint256;\n\n  // ============ Immutable storage ============\n\n  // Address of the Reserve Auction contract to place bid on\n  address public immutable ReserveAuctionV3Address;\n  // Address of the wETH contract\n  address public immutable wETHAddress;\n  // Address of the NFT contract\n  address public immutable NFTAddress;\n\n  // ============ Mutable storage ============\n\n  // ReserveAuctionV3 auctionID to bid on\n  uint256 public auctionID;\n  // Amount that DAO will bid for on ReserveAuctionV3 item\n  uint256 public bidAmount;\n  // Current amount raised to bid on ReserveAuctionV3 item\n  uint256 public currentRaisedAmount;\n  // Maximum time to wait for dao members to fill contract before enabling exit\n  uint256 public exitTimeout; \n  // Value received from accepted bid\n  uint256 public NFTResoldValue;\n  // Toggled when DAO places bid to purchase a ReserveAuctionV3 item\n  bool public bidPlaced;\n  // Toggled when DAO has resold won ReserveAuctionV3 item (to enable exit liquidity)\n  bool public NFTResold;\n  // Stakes of individual dao members\n  mapping (address => uint256) public daoStakes;\n  // List of active proposals to accept bids\n  BidProposal[] public BidProposals;\n  // List of supporters for each active bid proposal\n  mapping (uint256 => mapping (address => bool)) BidProposalSupporters;\n\n  // ============ Structs ============\n\n  // Individual bid proposals\n  struct BidProposal {\n    address proposer; // Proposing DAO member\n    address bidder; // Proposed bidder to accept bid from\n    uint256 amount; // Proposed bid amount\n    uint256 aggregateSupport; // sum(balance(voting_addresses_in_favor))\n  }\n\n  // ============ Modifiers ============\n  \n  // Reverts if the DAO has not won the NFT\n  modifier onlyIfAuctionWon() {\n    // Ensure that owner of NFT(auctionId) is contract address\n    require(IERC721(NFTAddress).ownerOf(auctionID) == address(this), \"PartyBid: DAO has not won auction.\");\n    _;\n  }\n\n  // ============ Events ============\n\n  // Address of a new DAO member and their entry share\n  event PartyJoined(address indexed member, uint256 value);\n  // Value of newly placed bid on ReserveAuctionV3 item\n  event PartyBidPlaced(uint256 auctionID, uint256 value);\n  // Address and exit share of DAO member, along with reason for exit\n  event PartyMemberExited(address indexed member, uint256 value, bool postFailure);\n  // Value of new proposal ID, proposer, Zora bidder, and Zora bidder bid amount\n  event PartyProposeNewZoraBid(uint256 indexed proposalId, address proposer, address bidder, uint256 amount);\n  // Value of proposal ID, and voter\n  event PartyProposalVote(uint256 indexed proposalId, address voter);\n  // Value of executed sale amount\n  event PartyExecuteSale(uint256 amount);\n\n  // ============ Constructor ============\n\n  constructor(\n    address _ReserveAuctionV3Address,\n    uint256 _auctionID,\n    uint256 _bidAmount,\n    uint256 _exitTimeout\n  ) public {\n    // Initialize immutable memory\n    ReserveAuctionV3Address = _ReserveAuctionV3Address;\n    wETHAddress = ReserveAuctionV3(_ReserveAuctionV3Address).wethAddress();\n    NFTAddress = ReserveAuctionV3(_ReserveAuctionV3Address).nftContract();\n\n    // Initialize mutable memory\n    auctionID = _auctionID;\n    bidAmount = _bidAmount;\n    currentRaisedAmount = 0;\n    exitTimeout = _exitTimeout;\n    bidPlaced = false;\n    NFTResold = false;\n  }\n\n  // ============ Join the DAO ============\n\n  /**\n   * Join the DAO by sending ETH\n   * Requires bidding to be enabled, forced matching of deposit value to sent eth, and there to be capacity in DAO\n   */\n  function join(uint256 _value) external payable {\n    // Dont allow joining once the bid has already been placed\n    require(bidPlaced == false, \"PartyBid: Cannot join since bid has been placed.\");\n    // Ensure matching of deposited value to ETH sent to contract\n    require(msg.value == _value, \"PartyBid: Deposit amount does not match spent ETH.\");\n    // Ensure sum(eth sent, current raised) <= required bid amount\n    require(_value.add(currentRaisedAmount) <= bidAmount, \"PartyBid: DAO does not have capacity.\");\n\n    currentRaisedAmount = currentRaisedAmount.add(_value); // Increment raised amount\n    daoStakes[msg.sender] = daoStakes[msg.sender].add(_value); // Track DAO member contribution\n\n    emit PartyJoined(msg.sender, _value); // Emit new DAO member\n  }\n\n  // ============ Place a bid from DAO ============\n\n  /**\n   * Execute bid placement, as DAO member, so long as required conditions are met\n   */\n  function placeBid() external {\n    // Dont allow placing a bid if already placed\n    require(bidPlaced == false, \"PartyBid: Bid has already been placed.\");\n    // Ensure that required bidAmount is matched with currently raised amount\n    require(bidAmount == currentRaisedAmount, \"PartyBid: Insufficient raised capital to place bid.\");\n    // Ensure that caller is a DAO member\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must be DAO member to initiate placing bid.\");\n\n    // Setup auction contract, place bid, toggle bidding status\n    ReserveAuctionV3 auction_contract = ReserveAuctionV3(ReserveAuctionV3Address);\n    auction_contract.createBid{value: bidAmount}(auctionID, bidAmount);\n    bidPlaced = true;\n\n    emit PartyBidPlaced(auctionID, bidAmount); // Emit bid placed\n  }\n\n  // ============ ReserveAuctionV3 NFT re-auctioning via Zora Market ============\n\n  /**\n   * Returns boolean status of if DAO has won NFT\n   */\n  function NFTWon() public view returns (bool) {\n    // Check if owner of NFT(auctionID) is contract address\n    return IERC721(NFTAddress).ownerOf(auctionID) == address(this);\n  }\n\n  /**\n   * Propose a new Zora bid for acceptance to the DAO\n   */\n  function DAOProposeZoraBid(address _bidder) external onlyIfAuctionWon() returns (uint256) {\n    // Collect Zora Bid\n    IMarket.Bid memory bid = IMarket(\n      // Collect Zora Market contract from IMedia storage\n      IMediaModified(NFTAddress).marketContract()\n    // Collect bid by bidder address\n    ).bidForTokenBidder(auctionID, _bidder);\n    \n    // Ensure that bid from bidder exists\n    require(bid.bidder == _bidder, \"PartyBid: Bidder does not have an active bid on NFT.\");\n    // Ensure that bid currency is Wrapped Ether\n    require(bid.currency == wETHAddress, \"PartyBid: Bidder has bid in a non-wETH token.\");\n    // Ensure that caller is a DAO member\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must be a DAO member to propose a new Zora bid.\");\n\n    // Collect proposalId from proposals array length\n    uint256 proposalId = BidProposals.length;\n\n    BidProposals.push(BidProposal(\n      msg.sender,\n      _bidder,\n      bid.amount,\n      // Existing aggregate support starts at power(proposer)\n      daoStakes[msg.sender]\n    ));\n\n    // Update supporters mapping\n    BidProposalSupporters[proposalId][msg.sender] = true;\n\n    emit PartyProposeNewZoraBid(proposalId, msg.sender, _bidder, bid.amount); // Emit new bid proposal\n    emit PartyProposalVote(proposalId, msg.sender); // Emit new vote for proposal (from proposal proposer themselves)\n\n    return proposalId;\n  }\n\n  /**\n   * Vote for a new Zora bid proposal if you have not already\n   */\n  function DAOVoteForZoraBidProposal(uint256 _proposalId) external onlyIfAuctionWon() {\n    // Ensure that caller is a DAO member\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must be a DAO member to vote for bid proposal.\");\n    // Ensure that caller has not already voted in favor of proposal\n    require(BidProposalSupporters[_proposalId][msg.sender] != true, \"PartyBid: Cannot vote for a proposal twice.\");\n\n    // Increment aggregate support with power(voter)\n    BidProposals[_proposalId].aggregateSupport = BidProposals[_proposalId].aggregateSupport.add(daoStakes[msg.sender]);\n\n    // Update supporters mapping\n    BidProposalSupporters[_proposalId][msg.sender] = true;\n\n    emit PartyProposalVote(_proposalId, msg.sender); // Emit new vote for proposal\n  }\n  \n  /**\n   * Execute a Zora bid proposal assuming it still exists and matches amount in storage\n   */\n  function DAOExecuteZoraBid(uint256 _proposalId) external onlyIfAuctionWon() {\n    // Ensure that caller is a DAO member\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must first be a DAO member to execute bid proposal.\");\n    // Ensure that the proposal being enacted has > 50% of supporting DAO vote\n    require(BidProposals[_proposalId].aggregateSupport > currentRaisedAmount.div(2), \"PartyBid: Insufficient support to accept Zora bid.\");\n\n    // Collect Bid from IMedia\n    IMarket.Bid memory bid = IMarket(IMediaModified(NFTAddress).marketContract()).bidForTokenBidder(auctionID, BidProposals[_proposalId].bidder);\n    \n    // Ensure that bid amount has not changed \n    require(BidProposals[_proposalId].amount == bid.amount, \"PartyBid: Bid amount has changed during proposal voting.\");\n\n    // Collect bidshares to calculate NFTResoldValue\n    IMarket.BidShares memory bidShares = IMarket(IMediaModified(NFTAddress).marketContract()).bidSharesForToken(auctionID);\n\n    // Accept bid from Imedia\n    IMediaExtended(NFTAddress).acceptBid(auctionID, bid);\n\n    // Update NFT price \n    NFTResold = true;\n    NFTResoldValue = ABDKMath64x64.mulu(\n      // Multiply the (bidShare of owner / total bidShare)\n      ABDKMath64x64.divu(bidShares.owner.value, 100000000000000000000),\n      // By the amount received through the bid\n      bid.amount\n    );\n\n    // Nullify proposal aggregate support to prevent resetting price via same proposal in future\n    BidProposals[_proposalId].aggregateSupport = 0;\n\n    emit PartyExecuteSale(NFTResoldValue); // Emit NFT sale price\n  }\n\n  // ============ Exit the DAO ============\n\n  /**\n   * Exit DAO if bid was won, and NFT was resold for NFTResoldValue\n   */\n  function _exitPostSale() internal {\n    // Require NFT to have already have been resold\n    require(NFTResold = true, \"PartyBid: NFT has not yet been resold.\");\n    // Failsafe: Ensure contract has non-zero funds to payout DAO members\n    require(IWETH(wETHAddress).balanceOf(address(this)) > 0, \"PartyBid: DAO is insolvent.\");\n    \n    // Send calculated share of NFTSalePrice based on DAO membership share\n    IWETH(wETHAddress).transferFrom(address(this), msg.sender,\n      // Multiply final NFT sale price\n      ABDKMath64x64.mulu(\n          // Multiply (dao_share / total)\n          ABDKMath64x64.divu(daoStakes[msg.sender], currentRaisedAmount),\n          // by final NFT sale price\n            NFTResoldValue)\n    );\n    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], false); // Emit exit event\n\n    // Nullify member DAO share\n    daoStakes[msg.sender] = 0;\n  }\n  \n  /**\n   * Exit DAO if bid was beaten\n   * @dev Capital returned in form of wETH due to 30,000 gas transfer limit imposed by ReserveAuctionV3\n   */\n  function _exitIfBidFailed() internal {\n    // Dont allow exiting via this function if bid hasn't been placed\n    require(bidPlaced == true, \"PartyBid: Bid must be placed to exit via failure.\");\n    // Ensure that contract wETH balance is > 0 (implying that either funds have been returned or wETH airdropped)\n    require(IWETH(wETHAddress).balanceOf(address(this)) > 0, \"PartyBid: DAO bid has not been beaten or refunded yet.\");\n\n    // Transfer wETH from contract to DAO member and emit event\n    IWETH(wETHAddress).transferFrom(address(this), msg.sender, daoStakes[msg.sender]);\n    currentRaisedAmount = currentRaisedAmount.sub(daoStakes[msg.sender]);\n    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], true); // Emit exit event\n\n    // Nullify member DAO share\n    daoStakes[msg.sender] = 0;\n  }\n\n  /**\n   * Exit DAO if deposit timeout has passed\n   */\n  function _exitIfTimeoutPassed() internal {\n    // Dont allow exiting via this function if bid has been placed\n    require(bidPlaced == false, \"PartyBid: Bid must be pending to exit via timeout.\");\n    // Ensure that current time > deposit timeout\n    require(block.timestamp >= exitTimeout, \"PartyBid: Exit timeout not met.\");\n\n    // Transfer ETH from contract to DAO member and emit event\n    payable(msg.sender).transfer(daoStakes[msg.sender]);\n    currentRaisedAmount = currentRaisedAmount.sub(daoStakes[msg.sender]);\n    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], false); // Emit exit event\n\n    // Nullify member DAO share\n    daoStakes[msg.sender] = 0;\n  }\n\n  /**\n   * Public utility function to call internal exit functions based on bid state\n   */\n  function exit() external payable {\n    // Ensure that caller is a DAO member\n    require(daoStakes[msg.sender] > 0, \"PartyBid: Must first be a DAO member to exit DAO.\");\n\n    if (NFTResold) {\n      // If NFT has already been resold, allow post-sale exit\n      _exitPostSale();\n    } else {\n      if (bidPlaced) {\n        // If bid has been placed, allow exit on bid failure\n        _exitIfBidFailed();\n      } else {\n        // Else, allow exit when exit timeout window has passed\n        _exitIfTimeoutPassed();\n      }\n    }\n  }\n}"
    },
    "contracts/ReserveAuctionV3_flat.sol": {
      "content": "\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n// File: interfaces/IMarket.sol\n\n\n/**\n * @title Math\n *\n * Library for non-standard Math functions\n * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract.\n * It was forked from https://github.com/dydxprotocol/solo at commit\n * 2d8454e02702fe5bc455b848556660629c3cad36. It has not been modified other than to use a\n * newer solidity in the pragma to match the rest of the contract suite of this project.\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        return target.mul(numerator).div(denominator);\n    }\n\n    /*\n     * Return target * (numerator / denominator), but rounded up.\n     */\n    function getPartialRoundUp(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (uint256) {\n        if (target == 0 || numerator == 0) {\n            // SafeMath will check for zero denominator\n            return SafeMath.div(0, denominator);\n        }\n        return target.mul(numerator).sub(1).div(denominator).add(1);\n    }\n\n    function to128(uint256 number) internal pure returns (uint128) {\n        uint128 result = uint128(number);\n        require(result == number, \"Math: Unsafe cast to uint128\");\n        return result;\n    }\n\n    function to96(uint256 number) internal pure returns (uint96) {\n        uint96 result = uint96(number);\n        require(result == number, \"Math: Unsafe cast to uint96\");\n        return result;\n    }\n\n    function to32(uint256 number) internal pure returns (uint32) {\n        uint32 result = uint32(number);\n        require(result == number, \"Math: Unsafe cast to uint32\");\n        return result;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n\n/**\n * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract. It was forked from https://github.com/dydxprotocol/solo\n * at commit 2d8454e02702fe5bc455b848556660629c3cad36\n *\n * It has not been modified other than to use a newer solidity in the pragma to match the rest of the contract suite of this project\n */\n/*\n * @title Decimal\n *\n * Library that defines a fixed-point number with 18 decimal places.\n */\nlibrary Decimal {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE_POW = 18;\n    uint256 constant BASE = 10**BASE_POW;\n\n    // ============ Structs ============\n\n    struct D256 {\n        uint256 value;\n    }\n\n    // ============ Functions ============\n\n    function one() internal pure returns (D256 memory) {\n        return D256({value: BASE});\n    }\n\n    function onePlus(D256 memory d) internal pure returns (D256 memory) {\n        return D256({value: d.value.add(BASE)});\n    }\n\n    function mul(uint256 target, D256 memory d)\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, d.value, BASE);\n    }\n\n    function div(uint256 target, D256 memory d)\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(target, BASE, d.value);\n    }\n}\n\n/**\n * @title Interface for Zora Protocol's Market\n */\ninterface IMarket {\n    struct Bid {\n        // Amount of the currency being bid\n        uint256 amount;\n        // Address to the ERC20 token being used to bid\n        address currency;\n        // Address of the bidder\n        address bidder;\n        // Address of the recipient\n        address recipient;\n        // % of the next sale to award the current owner\n        Decimal.D256 sellOnShare;\n    }\n\n    struct Ask {\n        // Amount of the currency being asked\n        uint256 amount;\n        // Address to the ERC20 token being asked\n        address currency;\n    }\n\n    struct BidShares {\n        // % of sale value that goes to the _previous_ owner of the nft\n        Decimal.D256 prevOwner;\n        // % of sale value that goes to the original creator of the nft\n        Decimal.D256 creator;\n        // % of sale value that goes to the seller (current owner) of the nft\n        Decimal.D256 owner;\n    }\n\n    event BidCreated(uint256 indexed tokenId, Bid bid);\n    event BidRemoved(uint256 indexed tokenId, Bid bid);\n    event BidFinalized(uint256 indexed tokenId, Bid bid);\n    event AskCreated(uint256 indexed tokenId, Ask ask);\n    event AskRemoved(uint256 indexed tokenId, Ask ask);\n    event BidShareUpdated(uint256 indexed tokenId, BidShares bidShares);\n\n    function bidForTokenBidder(uint256 tokenId, address bidder)\n        external\n        view\n        returns (Bid memory);\n\n    function currentAskForToken(uint256 tokenId)\n        external\n        view\n        returns (Ask memory);\n\n    function bidSharesForToken(uint256 tokenId)\n        external\n        view\n        returns (BidShares memory);\n\n    function isValidBid(uint256 tokenId, uint256 bidAmount)\n        external\n        view\n        returns (bool);\n\n    function isValidBidShares(BidShares calldata bidShares)\n        external\n        pure\n        returns (bool);\n\n    function splitShare(Decimal.D256 calldata sharePercentage, uint256 amount)\n        external\n        pure\n        returns (uint256);\n\n    function configure(address mediaContractAddress) external;\n\n    function setBidShares(uint256 tokenId, BidShares calldata bidShares)\n        external;\n\n    function setAsk(uint256 tokenId, Ask calldata ask) external;\n\n    function removeAsk(uint256 tokenId) external;\n\n    function setBid(\n        uint256 tokenId,\n        Bid calldata bid,\n        address spender\n    ) external;\n\n    function removeBid(uint256 tokenId, address bidder) external;\n\n    function acceptBid(uint256 tokenId, Bid calldata expectedBid) external;\n}\n\n// File: contracts/ReentrancyGuard.sol\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2Ï.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /// @dev counter to allow mutex lock with only one SSTORE operation\n  uint256 private _guardCounter = 1;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * If you mark a function `nonReentrant`, you should also\n   * mark it `external`. Calling one `nonReentrant` function from\n   * another is not supported. Instead, you can implement a\n   * `private` function doing the actual work, and an `external`\n   * wrapper marked as `nonReentrant`.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}\n// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/ReserveAuctionV3.sol\n\n// OpenZeppelin library for performing math operations without overflows.\n\n// OpenZeppelin security library for preventing reentrancy attacks.\n\n// For interacting with Zora's Market contract.\n\n// For checking `supportsInterface`.\n\n// For interacting with NFT tokens.\n\n\ncontract IMediaModified {\n    mapping(uint256 => address) public tokenCreators;\n    address public marketContract;\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract ReserveAuctionV3 is ReentrancyGuard {\n    // Use OpenZeppelin's SafeMath library to prevent overflows.\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    // The minimum amount of time left in an auction after a new bid is created; 15 min.\n    uint16 public constant TIME_BUFFER = 900;\n    // The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\n    uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\n    // Interface constant for ERC721, to check values in constructor.\n    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\n    // Allows external read `getVersion()` to return a version for the auction.\n    uint256 private constant RESERVE_AUCTION_VERSION = 1;\n\n    // ============ Immutable Storage ============\n\n    // The address of the ERC721 contract for tokens auctioned via this contract.\n    address public immutable nftContract;\n    // The address of the WETH contract, so that ETH can be transferred via\n    // WETH if native ETH transfers fail.\n    address public immutable wethAddress;\n    // The address that initially is able to recover assets.\n    address public immutable adminRecoveryAddress;\n\n    // ============ Mutable Storage ============\n\n    /**\n     * To start, there will be an admin account that can recover funds\n     * if anything goes wrong. Later, this public flag will be irrevocably\n     * set to false, removing any admin privileges forever.\n     *\n     * To check if admin recovery is enabled, call the public function `adminRecoveryEnabled()`.\n     */\n    bool private _adminRecoveryEnabled;\n    /**\n     * The account `adminRecoveryAddress` can also pause the contracts\n     * while _adminRecoveryEnabled is enabled. This prevents people from using\n     * the contract if there is a known problem with it.\n     */\n    bool private _paused;\n\n    // A mapping of all of the auctions currently running.\n    mapping(uint256 => Auction) public auctions;\n\n    // ============ Structs ============\n\n    struct Auction {\n        // The value of the current highest bid.\n        uint256 amount;\n        // The amount of time that the auction should run for,\n        // after the first bid was made.\n        uint256 duration;\n        // The time of the first bid.\n        uint256 firstBidTime;\n        // The minimum price of the first bid.\n        uint256 reservePrice;\n        uint8 curatorFeePercent;\n        // The address of the auction's curator. The curator\n        // can cancel the auction if it hasn't had a bid yet.\n        address curator;\n        // The address of the current highest bid.\n        address payable bidder;\n        // The address that should receive funds once the NFT is sold.\n        address payable fundsRecipient;\n    }\n\n    // ============ Events ============\n\n    // All of the details of a new auction,\n    // with an index created for the tokenId.\n    event AuctionCreated(\n        uint256 indexed tokenId,\n        address nftContractAddress,\n        uint256 duration,\n        uint256 reservePrice,\n        uint8 curatorFeePercent,\n        address curator,\n        address fundsRecipient\n    );\n\n    // All of the details of a new bid,\n    // with an index created for the tokenId.\n    event AuctionBid(\n        uint256 indexed tokenId,\n        address nftContractAddress,\n        address sender,\n        uint256 value\n    );\n\n    // All of the details of an auction's cancelation,\n    // with an index created for the tokenId.\n    event AuctionCanceled(\n        uint256 indexed tokenId,\n        address nftContractAddress,\n        address curator\n    );\n\n    // All of the details of an auction's close,\n    // with an index created for the tokenId.\n    event AuctionEnded(\n        uint256 indexed tokenId,\n        address nftContractAddress,\n        address curator,\n        address winner,\n        uint256 amount,\n        address nftCreator,\n        address payable fundsRecipient\n    );\n\n    // When the curator recevies fees, emit the details including the amount,\n    // with an index created for the tokenId.\n    event CuratorFeePercentTransfer(\n        uint256 indexed tokenId,\n        address curator,\n        uint256 amount\n    );\n\n    // Emitted in the case that the contract is paused.\n    event Paused(address account);\n    // Emitted when the contract is unpaused.\n    event Unpaused(address account);\n\n    // ============ Modifiers ============\n\n    // Reverts if the sender is not admin, or admin\n    // functionality has been turned off.\n    modifier onlyAdminRecovery() {\n        require(\n            // The sender must be the admin address, and\n            // adminRecovery must be set to true.\n            adminRecoveryAddress == msg.sender && adminRecoveryEnabled(),\n            \"Caller does not have admin privileges\"\n        );\n        _;\n    }\n\n    // Reverts if the sender is not the auction's curator.\n    modifier onlyCurator(uint256 tokenId) {\n        require(\n            auctions[tokenId].curator == msg.sender,\n            \"Can only be called by auction curator\"\n        );\n        _;\n    }\n\n    // Reverts if the contract is paused.\n    modifier whenNotPaused() {\n        require(!paused(), \"Contract is paused\");\n        _;\n    }\n\n    // Reverts if the auction does not exist.\n    modifier auctionExists(uint256 tokenId) {\n        // The auction exists if the curator is not null.\n        require(!auctionCuratorIsNull(tokenId), \"Auction doesn't exist\");\n        _;\n    }\n\n    // Reverts if the auction exists.\n    modifier auctionNonExistant(uint256 tokenId) {\n        // The auction does not exist if the curator is null.\n        require(auctionCuratorIsNull(tokenId), \"Auction already exists\");\n        _;\n    }\n\n    // Reverts if the auction is expired.\n    modifier auctionNotExpired(uint256 tokenId) {\n        require(\n            // Auction is not expired if there's never been a bid, or if the\n            // current time is less than the time at which the auction ends.\n            auctions[tokenId].firstBidTime == 0 ||\n                block.timestamp < auctionEnds(tokenId),\n            \"Auction expired\"\n        );\n        _;\n    }\n\n    // Reverts if the auction is not complete.\n    // Auction is complete if there was a bid, and the time has run out.\n    modifier auctionComplete(uint256 tokenId) {\n        require(\n            // Auction is complete if there has been a bid, and the current time\n            // is greater than the auction's end time.\n            auctions[tokenId].firstBidTime > 0 &&\n                block.timestamp >= auctionEnds(tokenId),\n            \"Auction hasn't completed\"\n        );\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(\n        address nftContract_,\n        address wethAddress_,\n        address adminRecoveryAddress_\n    ) public {\n        require(\n            IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID),\n            \"Contract at nftContract_ address does not support NFT interface\"\n        );\n        // Initialize immutable memory.\n        nftContract = nftContract_;\n        wethAddress = wethAddress_;\n        adminRecoveryAddress = adminRecoveryAddress_;\n        // Initialize mutable memory.\n        _paused = false;\n        _adminRecoveryEnabled = true;\n    }\n\n    // ============ Create Auction ============\n\n    function createAuction(\n        uint256 tokenId,\n        uint256 duration,\n        uint256 reservePrice,\n        uint8 curatorFeePercent,\n        address curator,\n        address payable fundsRecipient\n    ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {\n        // Check basic input requirements are reasonable.\n        require(curator != address(0));\n        require(fundsRecipient != address(0));\n        require(curatorFeePercent < 100, \"Curator fee should be < 100\");\n        // Initialize the auction details, including null values.\n        auctions[tokenId] = Auction({\n            duration: duration,\n            reservePrice: reservePrice,\n            curatorFeePercent: curatorFeePercent,\n            curator: curator,\n            fundsRecipient: fundsRecipient,\n            amount: 0,\n            firstBidTime: 0,\n            bidder: address(0)\n        });\n        // Transfer the NFT into this auction contract, from whoever owns it.\n        IERC721(nftContract).transferFrom(\n            IERC721(nftContract).ownerOf(tokenId),\n            address(this),\n            tokenId\n        );\n        // Emit an event describing the new auction.\n        emit AuctionCreated(\n            tokenId,\n            nftContract,\n            duration,\n            reservePrice,\n            curatorFeePercent,\n            curator,\n            fundsRecipient\n        );\n    }\n\n    // ============ Create Bid ============\n\n    function createBid(uint256 tokenId, uint256 amount)\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        auctionExists(tokenId)\n        auctionNotExpired(tokenId)\n    {\n        // Validate that the user's expected bid value matches the ETH deposit.\n        require(amount == msg.value, \"Amount doesn't equal msg.value\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Check if the current bid amount is 0.\n        if (auctions[tokenId].amount == 0) {\n            // If so, it is the first bid.\n            auctions[tokenId].firstBidTime = block.timestamp;\n            // We only need to check if the bid matches reserve bid for the first bid,\n            // since future checks will need to be higher than any previous bid.\n            require(\n                amount >= auctions[tokenId].reservePrice,\n                \"Must bid reservePrice or more\"\n            );\n        } else {\n            // Check that the new bid is sufficiently higher than the previous bid, by\n            // the percentage defined as MIN_BID_INCREMENT_PERCENT.\n            require(\n                amount >=\n                    auctions[tokenId].amount.add(\n                        // Add 10% of the current bid to the current bid.\n                        auctions[tokenId]\n                            .amount\n                            .mul(MIN_BID_INCREMENT_PERCENT)\n                            .div(100)\n                    ),\n                \"Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount\"\n            );\n\n            // Refund the previous bidder.\n            transferETHOrWETH(\n                auctions[tokenId].bidder,\n                auctions[tokenId].amount\n            );\n        }\n        // Update the current auction.\n        auctions[tokenId].amount = amount;\n        auctions[tokenId].bidder = msg.sender;\n        // Compare the auction's end time with the current time plus the 15 minute extension,\n        // to see whether we're near the auctions end and should extend the auction.\n        if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\n            // We add onto the duration whenever time increment is required, so\n            // that the auctionEnds at the current time plus the buffer.\n            auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\n                auctionEnds(tokenId)\n            );\n        }\n        // Emit the event that a bid has been made.\n        emit AuctionBid(tokenId, nftContract, msg.sender, amount);\n    }\n\n    // ============ End Auction ============\n\n    function endAuction(uint256 tokenId)\n        external\n        nonReentrant\n        whenNotPaused\n        auctionComplete(tokenId)\n    {\n        // Store relevant auction data in memory for the life of this function.\n        address winner = auctions[tokenId].bidder;\n        uint256 amount = auctions[tokenId].amount;\n        address curator = auctions[tokenId].curator;\n        uint8 curatorFeePercent = auctions[tokenId].curatorFeePercent;\n        address payable fundsRecipient = auctions[tokenId].fundsRecipient;\n        // Remove all auction data for this token from storage.\n        delete auctions[tokenId];\n        // We don't use safeTransferFrom, to prevent reverts at this point,\n        // which would break the auction.\n        IERC721(nftContract).transferFrom(address(this), winner, tokenId);\n        // First handle the curator's fee.\n        if (curatorFeePercent > 0) {\n            // Determine the curator amount, which is some percent of the total.\n            uint256 curatorAmount = amount.mul(curatorFeePercent).div(100);\n            // Send it to the curator.\n            transferETHOrWETH(curator, curatorAmount);\n            // Subtract the curator amount from the total funds available\n            // to send to the funds recipient and original NFT creator.\n            amount = amount.sub(curatorAmount);\n            // Emit the details of the transfer as an event.\n            emit CuratorFeePercentTransfer(tokenId, curator, curatorAmount);\n        }\n        // Get the address of the original creator, so that we can split shares\n        // if appropriate.\n        address payable nftCreator =\n            payable(\n                address(IMediaModified(nftContract).tokenCreators(tokenId))\n            );\n        // If the creator and the recipient of the funds are the same\n        // (and we expect this to be common), we can just do one transaction.\n        if (nftCreator == fundsRecipient) {\n            transferETHOrWETH(nftCreator, amount);\n        } else {\n            // Otherwise, we should determine the percent that goes to the creator.\n            // Collect share data from Zora.\n            uint256 creatorAmount =\n                // Call the splitShare function on the market contract, which\n                // takes in a Decimal and an amount.\n                IMarket(IMediaModified(nftContract).marketContract())\n                    .splitShare(\n                    // Fetch the decimal from the BidShares data on the market.\n                    IMarket(IMediaModified(nftContract).marketContract())\n                        .bidSharesForToken(tokenId)\n                        .creator,\n                    // Specify the amount.\n                    amount\n                );\n            // Send the creator's share to the creator.\n            transferETHOrWETH(nftCreator, creatorAmount);\n            // Send the remainder of the amount to the funds recipient.\n            transferETHOrWETH(fundsRecipient, amount.sub(creatorAmount));\n        }\n        // Emit an event describing the end of the auction.\n        emit AuctionEnded(\n            tokenId,\n            nftContract,\n            curator,\n            winner,\n            amount,\n            nftCreator,\n            fundsRecipient\n        );\n    }\n\n    // ============ Cancel Auction ============\n\n    function cancelAuction(uint256 tokenId)\n        external\n        nonReentrant\n        auctionExists(tokenId)\n        onlyCurator(tokenId)\n    {\n        // Check that there hasn't already been a bid for this NFT.\n        require(\n            uint256(auctions[tokenId].firstBidTime) == 0,\n            \"Auction already started\"\n        );\n        // Pull the creator address before removing the auction.\n        address curator = auctions[tokenId].curator;\n        // Remove all data about the auction.\n        delete auctions[tokenId];\n        // Transfer the NFT back to the curator.\n        IERC721(nftContract).transferFrom(address(this), curator, tokenId);\n        // Emit an event describing that the auction has been canceled.\n        emit AuctionCanceled(tokenId, nftContract, curator);\n    }\n\n    // ============ Admin Functions ============\n\n    // Irrevocably turns off admin recovery.\n    function turnOffAdminRecovery() external onlyAdminRecovery {\n        _adminRecoveryEnabled = false;\n    }\n\n    function pauseContract() external onlyAdminRecovery {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpauseContract() external onlyAdminRecovery {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    // Allows the admin to transfer any NFT from this contract\n    // to the recovery address.\n    function recoverNFT(uint256 tokenId) external onlyAdminRecovery {\n        IERC721(nftContract).transferFrom(\n            // From the auction contract.\n            address(this),\n            // To the recovery account.\n            adminRecoveryAddress,\n            // For the specified token.\n            tokenId\n        );\n    }\n\n    // Allows the admin to transfer any ETH from this contract to the recovery address.\n    function recoverETH(uint256 amount)\n        external\n        onlyAdminRecovery\n        returns (bool success)\n    {\n        // Attempt an ETH transfer to the recovery account, and return true if it succeeds.\n        success = attemptETHTransfer(adminRecoveryAddress, amount);\n    }\n\n    // ============ Miscellaneous Public and External ============\n\n    // Returns true if the contract is paused.\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    // Returns true if admin recovery is enabled.\n    function adminRecoveryEnabled() public view returns (bool) {\n        return _adminRecoveryEnabled;\n    }\n\n    // Returns the version of the deployed contract.\n    function getVersion() external pure returns (uint256 version) {\n        version = RESERVE_AUCTION_VERSION;\n    }\n\n    // ============ Private Functions ============\n\n    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\n    function transferETHOrWETH(address to, uint256 value) private {\n        // Try to transfer ETH to the given recipient.\n        if (!attemptETHTransfer(to, value)) {\n            // If the transfer fails, wrap and send as WETH, so that\n            // the auction is not impeded and the recipient still\n            // can claim ETH via the WETH contract (similar to escrow).\n            IWETH(wethAddress).deposit{value: value}();\n            IWETH(wethAddress).transfer(to, value);\n            // At this point, the recipient can unwrap WETH.\n        }\n    }\n\n    // Sending ETH is not guaranteed complete, and the method used here will return false if\n    // it fails. For example, a contract can block ETH transfer, or might use\n    // an excessive amount of gas, thereby griefing a new bidder.\n    // We should limit the gas used in transfers, and handle failure cases.\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // Returns true if the auction's curator is set to the null address.\n    function auctionCuratorIsNull(uint256 tokenId) private view returns (bool) {\n        // The auction does not exist if the curator is the null address,\n        // since the NFT would not have been transferred in `createAuction`.\n        return auctions[tokenId].curator == address(0);\n    }\n\n    // Returns the timestamp at which an auction will finish.\n    function auctionEnds(uint256 tokenId) private view returns (uint256) {\n        // Derived by adding the auction's duration to the time of the first bid.\n        // NOTE: duration can be extended conditionally after each new bid is added.\n        return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);\n    }\n}"
    }
  }
}