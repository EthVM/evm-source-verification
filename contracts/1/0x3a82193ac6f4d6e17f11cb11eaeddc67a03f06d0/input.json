{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"gist-325f23652d7c46a1121c62539ea948ec/AntiBot_public/SOUTHPARKTHUGS.sol":{"content":"/**\nSouthParkThugs! We will rob you if you sell!\nTelegram: https://t.me/SouthParkThugs\nTwitter: https://twitter.com/SouthParkThugs\nWebsite: https://SouthParkThugs.com\n- 100% Tokens of unburned tokens to Liquidity\n- 50% Token Burn\n- 0% Buy taxes\n- 10% Sell taxes. Dont let the Thugs of SouthPark rob you!\n- Launch with .5% of Supply Tx Limit (manually lifted after 15 minutes)\n- Launch with 2.5% Soft Wallet Cap\nAs the OG Thugs of SouthPark we wont let anyone snipe on us. Antisniper randomized launch timer.\nStay loyal to the Thugs and Thugs will stay loyal to you. Thugs out!\n**/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\ncontract Ownable is Context {\n    address private m_Owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () {\n        address msgSender = _msgSender();\n        m_Owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view returns (address) {\n        return m_Owner;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(m_Owner, address(0));\n        m_Owner = address(0);\n    }\n    modifier onlyOwner() {\n        require(_msgSender() == m_Owner, \"Ownable: caller is not the owner\");\n        _;\n    }                                                                                           \n}\ncontract Taxable is Ownable {\n    using SafeMath for uint256;\n    uint256[] m_TaxAlloc;\n    address payable[] m_TaxAddresses;\n    mapping (address => uint256) private m_TaxIdx;\n    uint256 public m_TotalAlloc;\n\n    function initTax() internal virtual {\n        m_TaxAlloc = new uint24[](0);\n        m_TaxAddresses = new address payable[](0);\n        m_TaxAlloc.push(0);\n        m_TaxAddresses.push(payable(address(0)));\n    }\n    function payTaxes(uint256 _eth, uint256 _d) internal virtual {\n        for (uint i = 1; i < m_TaxAlloc.length; i++) {\n            uint256 _alloc = m_TaxAlloc[i];\n            address payable _address = m_TaxAddresses[i];\n            uint256 _amount = _eth.mul(_alloc).div(_d);\n            if (_amount > 1){\n                _address.transfer(_amount);\n            }\n        }\n    }\n    function setTaxAlloc(address payable _address, uint256 _alloc) internal virtual onlyOwner() {\n        uint _idx = m_TaxIdx[_address];\n        if (_idx == 0) {\n            require(m_TotalAlloc.add(_alloc) <= 10500);\n            m_TaxAlloc.push(_alloc);\n            m_TaxAddresses.push(_address);\n            m_TaxIdx[_address] = m_TaxAlloc.length - 1;\n            m_TotalAlloc = m_TotalAlloc.add(_alloc);\n        } else { // update alloc for this address\n            uint256 _priorAlloc =  m_TaxAlloc[_idx];\n            require(m_TotalAlloc.add(_alloc).sub(_priorAlloc) <= 10500);  \n            m_TaxAlloc[_idx] = _alloc;\n            m_TotalAlloc = m_TotalAlloc.add(_alloc).sub(_priorAlloc);\n        }\n    }\n    function totalTaxAlloc() internal virtual view returns (uint256) {\n        return m_TotalAlloc;\n    }\n}                                                                                    \ninterface IUniswapV2Factory {                                                         \n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\ninterface IUniswapV2Router02 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\ninterface FTPAntiBot {\n    function scanAddress(address _address, address _safeAddress, address _origin) external returns (bool);\n    function registerBlock(address _recipient, address _sender, address _origin) external;\n}\ncontract SOUTHPARKTHUGS is Context, IERC20, Taxable {\n    using SafeMath for uint256;\n    // TOKEN\n    uint256 private constant TOTAL_SUPPLY = 100000000000 * 10**9;\n    string private m_Name = \"SOUTHPARK THUGS\";\n    string private m_Symbol = \"SPTHU\";\n    uint8 private m_Decimals = 9;\n    // EXCHANGES\n    address private m_UniswapV2Pair;\n    IUniswapV2Router02 private m_UniswapV2Router;\n    // TRANSACTIONS\n    uint256 private m_WalletLimit = TOTAL_SUPPLY.div(40); // 2.5% supply\n    uint256 private m_TxLimit = TOTAL_SUPPLY.div(200); // .5% supply\n    bool private m_Liquidity = false;\n    // ANTIBOT\n    FTPAntiBot private AntiBot;\n    address private m_AntibotSvcAddress = 0xCD5312d086f078D1554e8813C27Cf6C9D1C3D9b3;\n    bool private m_AntiBot = true;\n    // MISC\n    mapping (address => bool) private m_Blacklist;\n    mapping (address => bool) private m_ExcludedAddresses;\n    mapping (address => uint256) private m_Balances;\n    mapping (address => mapping (address => uint256)) private m_Allowances;\n    uint256 private m_LastEthBal = 0;\n    uint256 private m_Launched = 1753633194;\n    bool private m_IsSwap = false;\n    bool private _limitTX = true;\n    uint256 private pMax = 100000; // max alloc percentage\n\n    modifier lockTheSwap {\n        m_IsSwap = true;\n        _;\n        m_IsSwap = false;\n    }\n    \n    receive() external payable {}\n\n    constructor () {\n        AntiBot = FTPAntiBot(m_AntibotSvcAddress);\n        initTax();\n        m_Balances[address(this)] = TOTAL_SUPPLY;\n        m_ExcludedAddresses[owner()] = true;\n        m_ExcludedAddresses[address(this)] = true;\n        setTaxAlloc(payable(msg.sender), 10000);\n        emit Transfer(address(0), address(this), TOTAL_SUPPLY);\n    }\n    function name() public view returns (string memory) {\n        return m_Name;\n    }\n    function symbol() public view returns (string memory) {\n        return m_Symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return m_Decimals;\n    }\n    function totalSupply() public pure override returns (uint256) {\n        return TOTAL_SUPPLY;\n    }\n    function balanceOf(address _account) public view override returns (uint256) {\n        return m_Balances[_account];\n    }\n    function transfer(address _recipient, uint256 _amount) public override returns (bool) {\n        _transfer(_msgSender(), _recipient, _amount);\n        return true;\n    }\n    function allowance(address _owner, address _spender) public view override returns (uint256) {\n        return m_Allowances[_owner][_spender];\n    }\n    function approve(address _spender, uint256 _amount) public override returns (bool) {\n        _approve(_msgSender(), _spender, _amount);\n        return true;\n    }\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public override returns (bool) {\n        _transfer(_sender, _recipient, _amount);\n        _approve(_sender, _msgSender(), m_Allowances[_sender][_msgSender()].sub(_amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    function _isBuy(address _sender) private view returns (bool) {\n        return _sender == m_UniswapV2Pair;\n    }\n    function _trader(address _sender, address _recipient) private view returns (bool) {\n        return !(m_ExcludedAddresses[_sender] || m_ExcludedAddresses[_recipient]);\n    }\n    function _txRestricted(address _sender, address _recipient) private view returns (bool) {\n        return _sender == m_UniswapV2Pair && _recipient != address(m_UniswapV2Router) && !m_ExcludedAddresses[_recipient];\n    }\n    function _walletCapped(address _recipient) private view returns (bool) {\n        return _recipient != m_UniswapV2Pair && _recipient != address(m_UniswapV2Router);\n    }\n    function _checkTX() private view returns (uint256){\n        return m_TxLimit;\n    }\n    function _isExchangeTransfer(address _sender, address _recipient) private view returns (bool) {\n        return _sender == m_UniswapV2Pair || _recipient == m_UniswapV2Pair;\n    }\n    function setTxLimit(uint24 limit) external onlyOwner() {\n        require(limit <= 200, \"You cannot set the tx limit to less than .5% of total supply. Nice try!\");\n        m_TxLimit = TOTAL_SUPPLY.div(limit);\n    }\n    function setWalletLimit(uint24 limit) external onlyOwner() {\n        require(limit <= 40, \"You cannot set the wallet limit to less than 2.5% of total supply. Nice try!\");\n        m_WalletLimit = TOTAL_SUPPLY.div(limit);\n    }\n    function CurrentTxLimit() public view returns (uint256) {\n        return m_TxLimit;\n    }\n    function CurrentWalletLimit() public view returns (uint256) {\n        return m_WalletLimit;\n    }\n    function _approve(address _owner, address _spender, uint256 _amount) private {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n        m_Allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n    function _transfer(address _sender, address _recipient, uint256 _amount) private {\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\n        require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_amount > 0, \"Transfer amount must be greater than zero\");\n        require(!m_Blacklist[_sender] && !m_Blacklist[_recipient] && !m_Blacklist[tx.origin]);\n        \n        if(m_AntiBot) {\n            if(_isExchangeTransfer(_sender, _recipient) && block.timestamp >= m_Launched) {\n                require(!AntiBot.scanAddress(_recipient, m_UniswapV2Pair, tx.origin), \"Beep Beep Boop, You're a piece of poop\");                                          \n                require(!AntiBot.scanAddress(_sender, m_UniswapV2Pair, tx.origin),  \"Beep Beep Boop, You're a piece of poop\");\n                AntiBot.registerBlock(_sender, _recipient, tx.origin);\n            }\n        }\n        \n        if(_walletCapped(_recipient))\n            require(balanceOf(_recipient) < m_WalletLimit);\n            \n        uint256 _taxes = 0;\n        if (_trader(_sender, _recipient)) {\n            require(block.timestamp >= m_Launched);\n            if (_txRestricted(_sender, _recipient)) \n                require(_amount <= _checkTX());\n                \n            _taxes = _getTaxes(_sender, _recipient, _amount);\n            if (!_isBuy(_sender))\n                _tax();\n        }\n        \n        _updateBalances(_sender, _recipient, _amount, _taxes);\n    }\n    function _updateBalances(address _sender, address _recipient, uint256 _amount, uint256 _taxes) private {\n        uint256 _netAmount = _amount.sub(_taxes);\n        m_Balances[_sender] = m_Balances[_sender].sub(_amount);\n        m_Balances[_recipient] = m_Balances[_recipient].add(_netAmount);\n        m_Balances[address(this)] = m_Balances[address(this)].add(_taxes);\n        emit Transfer(_sender, _recipient, _netAmount);\n    }\n    function _getTaxes(address _sender, address _recipient, uint256 _amount) private view returns (uint256) {\n        uint256 _ret = 0;\n        if (m_ExcludedAddresses[_sender] || m_ExcludedAddresses[_recipient] || _isBuy(_sender)) {\n            return _ret;\n        }\n        _ret = _ret.add(_amount.div(pMax).mul(totalTaxAlloc()));\n        return _ret;\n    }\n    function _tax() private {\n        if (!m_IsSwap) {\n            uint256 _tokenBalance = balanceOf(address(this));\n            if (_tokenBalance > 0) {\n                _swapTokensForETH(_tokenBalance);\n                _disperseEth();\n            }\n        }\n    }\n    function _swapTokensForETH(uint256 _amount) private lockTheSwap {\n        address[] memory _path = new address[](2);\n        _path[0] = address(this);\n        _path[1] = m_UniswapV2Router.WETH();\n        _approve(address(this), address(m_UniswapV2Router), _amount);\n        m_UniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            _amount,\n            0,\n            _path,\n            address(this),\n            block.timestamp\n        );\n    }\n    function _getTaxDenominator() private view returns (uint) {\n        uint _ret = 0;\n        _ret = _ret.add(totalTaxAlloc());\n        return _ret;\n    }\n    function _disperseEth() private {\n        uint256 _eth = address(this).balance;\n        if (_eth <= m_LastEthBal)\n            return;\n            \n        uint256 _newEth = _eth.sub(m_LastEthBal);\n        uint _d = _getTaxDenominator();\n        if (_d < 1)\n            return;\n\n        payTaxes(_newEth, _d);\n\n        m_LastEthBal = address(this).balance;\n    }\n    function checkIfThugt(address _address) external view returns (bool) {\n        return m_Blacklist[_address];\n    }\n    function thuglist(address _a) external onlyOwner() {\n        m_Blacklist[_a] = true;\n    }\n    function rmBlacklist(address _a) external onlyOwner() {\n        m_Blacklist[_a] = false;\n    }\n    function updateTaxAlloc(address payable _address, uint _alloc) external onlyOwner() {\n        setTaxAlloc(_address, _alloc);\n        if (_alloc > 0) {\n            m_ExcludedAddresses[_address] = true;\n        }\n    }\n    function addLiquidity() external onlyOwner() {\n        require(!m_Liquidity,\"Liquidity already added.\");\n        uint256 _ethBalance = address(this).balance;\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        m_UniswapV2Router = _uniswapV2Router;\n        _approve(address(this), address(0x000000000000000000000000000000000000dEaD), TOTAL_SUPPLY);\n        _transfer(address(this),address(0x000000000000000000000000000000000000dEaD), TOTAL_SUPPLY.div(2));\n        _approve(address(this), address(m_UniswapV2Router), TOTAL_SUPPLY);\n        m_UniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        m_UniswapV2Router.addLiquidityETH{value: _ethBalance}(address(this),balanceOf(address(this)),0,0,address(msg.sender),block.timestamp);\n        IERC20(m_UniswapV2Pair).approve(address(m_UniswapV2Router), type(uint).max);\n        m_Liquidity = true;\n    }\n    function launch(uint256 _timer) external onlyOwner() {\n        m_Launched = block.timestamp.add(_timer);\n    }\n    function toggleAntiBot(bool _toggle) external onlyOwner() returns (bool){\n         m_AntiBot = _toggle;\n         return m_AntiBot;\n    }\n}"}}}