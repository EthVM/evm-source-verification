{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ClaimManager.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\ninterface IArmorMaster {\r\n    function registerModule(bytes32 _key, address _module) external;\r\n    function getModule(bytes32 _key) external view returns(address);\r\n    function keep() external;\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * \r\n * @dev Completely default OpenZeppelin.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initializeOwnable() internal {\r\n        require(_owner == address(0), \"already initialized\");\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"msg.sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    function receiveOwnership() public {\r\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\r\n        _transferOwnership(_pendingOwner);\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\nlibrary Bytes32 {\r\n    function toString(bytes32 x) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\r\n**/\r\ncontract ArmorModule {\r\n    IArmorMaster internal _master;\r\n\r\n    using Bytes32 for bytes32;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == Ownable(address(_master)).owner(), \"only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier doKeep() {\r\n        _master.keep();\r\n        _;\r\n    }\r\n\r\n    modifier onlyModule(bytes32 _module) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _module.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_module), message);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Used when multiple can call.\r\n    **/\r\n    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _moduleOne.toString(),\" or \", _moduleTwo.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\r\n        _;\r\n    }\r\n\r\n    function initializeModule(address _armorMaster) internal {\r\n        require(address(_master) == address(0), \"already initialized\");\r\n        require(_armorMaster != address(0), \"master cannot be zero address\");\r\n        _master = IArmorMaster(_armorMaster);\r\n    }\r\n\r\n    function changeMaster(address _newMaster) external onlyOwner {\r\n        _master = IArmorMaster(_newMaster);\r\n    }\r\n\r\n    function getModule(bytes32 _key) internal view returns(address) {\r\n        return _master.getModule(_key);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IarNFT is IERC721 {\r\n    function getToken(uint256 _tokenId) external returns (uint256, uint8, uint256, uint16, uint256, address, bytes4, uint256, uint256, uint256);\r\n    function submitClaim(uint256 _tokenId) external;\r\n    function redeemClaim(uint256 _tokenId) external;\r\n}\r\n\r\ninterface IPlanManager {\r\n  // Event to notify frontend of plan update.\r\n  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\r\n  function initialize(address _armorManager) external;\r\n  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\r\n  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\r\n  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\r\n  function coverageLeft(address _protocol) external view returns(uint256);\r\n  function getCurrentPlan(address _user) external view returns(uint128 start, uint128 end);\r\n  function updateExpireTime(address _user) external;\r\n  function planRedeemed(address _useer, uint256 _planIndex, address _protocol) external;\r\n}\r\n\r\ninterface IStakeManager {\r\n    function totalStakedAmount(address protocol) external view returns(uint256);\r\n    function protocolAddress(uint64 id) external view returns(address);\r\n    function protocolId(address protocol) external view returns(uint64);\r\n    function initialize(address _armorMaster) external;\r\n    function allowedCover(address _newProtocol, uint256 _newTotalCover) external view returns (bool);\r\n    function subtractTotal(uint256 _nftId, address _protocol, uint256 _subtractAmount) external;\r\n}\r\n// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\r\n\r\ninterface IClaimManager {\r\n    function initialize(address _armorMaster) external;\r\n    function transferNft(address _to, uint256 _nftId) external;\r\n}\r\n/**\r\n * @dev This contract holds all NFTs. The only time it does something is if a user requests a claim.\r\n * @notice We need to make sure a user can only claim when they have balance.\r\n**/\r\ncontract ClaimManager is ArmorModule, IClaimManager {\r\n    bytes4 public constant ETH_SIG = bytes4(0x45544800);\r\n\r\n    // Mapping of hacks that we have confirmed to have happened. (keccak256(protocol ID, timestamp) => didithappen).\r\n    mapping (bytes32 => bool) confirmedHacks;\r\n    \r\n    // Emitted when a new hack has been recorded.\r\n    event ConfirmedHack(bytes32 indexed hackId, address indexed protocol, uint256 timestamp);\r\n    \r\n    // Emitted when a user successfully receives a payout.\r\n    event ClaimPayout(bytes32 indexed hackId, address indexed user, uint256 amount);\r\n\r\n    // for receiving redeemed ether\r\n    receive() external payable {\r\n    }\r\n    \r\n    /**\r\n     * @dev Start the contract off by giving it the address of Nexus Mutual to submit a claim.\r\n    **/\r\n    function initialize(address _armorMaster)\r\n      public\r\n      override\r\n    {\r\n        initializeModule(_armorMaster);\r\n    }\r\n    \r\n    /**\r\n     * @dev User requests claim based on a loss.\r\n     *      Do we want this to be callable by anyone or only the person requesting?\r\n     *      Proof-of-Loss must be implemented here.\r\n     * @param _hackTime The given timestamp for when the hack occurred.\r\n     * @notice Make sure this cannot be done twice. I also think this protocol interaction can be simplified.\r\n    **/\r\n    function redeemClaim(address _protocol, uint256 _hackTime, uint256 _amount)\r\n      external\r\n      doKeep\r\n    {\r\n        bytes32 hackId = keccak256(abi.encodePacked(_protocol, _hackTime));\r\n        require(confirmedHacks[hackId], \"No hack with these parameters has been confirmed.\");\r\n        \r\n        // Gets the coverage amount of the user at the time the hack happened.\r\n        // TODO check if plan is not active now => to prevent users paying more than needed\r\n        (uint256 planIndex, bool covered) = IPlanManager(getModule(\"PLAN\")).checkCoverage(msg.sender, _protocol, _hackTime, _amount);\r\n        require(covered, \"User does not have valid amount, check path and amount\");\r\n        \r\n        IPlanManager(getModule(\"PLAN\")).planRedeemed(msg.sender, planIndex, _protocol);\r\n        msg.sender.transfer(_amount);\r\n        \r\n        emit ClaimPayout(hackId, msg.sender, _amount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Submit any NFT that was active at the time of a hack on its protocol.\r\n     * @param _nftId ID of the NFT to submit.\r\n     * @param _hackTime The timestamp of the hack that occurred. Hacktime is the START of the hack if not a single tx.\r\n    **/\r\n    function submitNft(uint256 _nftId,uint256 _hackTime)\r\n      external\r\n      doKeep\r\n    {\r\n        (/*cid*/, uint8 status, uint256 sumAssured, uint16 coverPeriod, uint256 validUntil, address scAddress,\r\n        bytes4 currencyCode, /*premiumNXM*/, /*coverPrice*/, /*claimId*/) = IarNFT(getModule(\"ARNFT\")).getToken(_nftId);\r\n        bytes32 hackId = keccak256(abi.encodePacked(scAddress, _hackTime));\r\n        \r\n        require(confirmedHacks[hackId], \"No hack with these parameters has been confirmed.\");\r\n        require(currencyCode == ETH_SIG, \"Only ETH nft can be submitted\");\r\n        \r\n        // Make sure arNFT was active at the time\r\n        require(validUntil >= _hackTime, \"arNFT was not valid at time of hack.\");\r\n        \r\n        // Make sure NFT was purchased before hack.\r\n        uint256 generationTime = validUntil - (uint256(coverPeriod) * 1 days);\r\n        require(generationTime <= _hackTime, \"arNFT had not been purchased before hack.\");\r\n\r\n        // Subtract amount it was protecting from total staked for the protocol if it is not expired (in which case it already has been subtracted).\r\n        uint256 weiSumAssured = sumAssured * (1e18);\r\n        if (status != 3) IStakeManager(getModule(\"STAKE\")).subtractTotal(_nftId, scAddress, weiSumAssured);\r\n        // subtract balance here\r\n\r\n        IarNFT(getModule(\"ARNFT\")).submitClaim(_nftId);\r\n    }\r\n    \r\n    /**\r\n     * @dev Calls the arNFT contract to redeem a claim (receive funds) if it has been accepted.\r\n     *      This is callable by anyone without any checks--either we receive money or it reverts.\r\n     * @param _nftId The ID of the yNft token.\r\n    **/\r\n    function redeemNft(uint256 _nftId)\r\n      external\r\n      doKeep\r\n    {\r\n        IarNFT(getModule(\"ARNFT\")).redeemClaim(_nftId);\r\n    }\r\n    \r\n    /**\r\n     * @dev Used by StakeManager in case a user wants to withdraw their NFT.\r\n     * @param _to Address to send the NFT to.\r\n     * @param _nftId ID of the NFT to be withdrawn.\r\n    **/\r\n    function transferNft(address _to, uint256 _nftId)\r\n      external\r\n      override\r\n      onlyModule(\"STAKE\")\r\n    {\r\n        IarNFT(getModule(\"ARNFT\")).safeTransferFrom(address(this), _to, _nftId);\r\n    }\r\n    \r\n    /**\r\n     * @dev Called by Armor for now--we confirm a hack happened and give a timestamp for what time it was.\r\n     * @param _protocol The address of the protocol that has been hacked (address that would be on yNFT).\r\n     * @param _hackTime The timestamp of the time the hack occurred.\r\n    **/\r\n    function confirmHack(address _protocol, uint256 _hackTime)\r\n      external\r\n      onlyOwner\r\n    {\r\n        require(_hackTime < now, \"Cannot confirm future\");\r\n        bytes32 hackId = keccak256(abi.encodePacked(_protocol, _hackTime));\r\n        confirmedHacks[hackId] = true;\r\n        emit ConfirmedHack(hackId, _protocol, _hackTime);\r\n    }\r\n}"}}}