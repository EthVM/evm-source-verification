{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DCLRent.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.00\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\r\n//\r\n// GNU Lesser General Public License 3.0\r\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n   \r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        uint year;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        uint year;\r\n        uint month;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n   \r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n   \r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n        function add(Role storage role, address account) internal {\r\n            require(!has(role, account), \"Roles: account already has role\");\r\n            role.bearer[account] = true;\r\n        }\r\n        function remove(Role storage role, address account) internal {\r\n            require(has(role, account), \"Roles: account does not have role\");\r\n            role.bearer[account] = false;\r\n        }\r\n        function has(Role storage role, address account) internal view returns (bool) {\r\n            require(account != address(0), \"Roles: account is the zero address\");\r\n            return role.bearer[account];\r\n        }\r\n    }\r\n   \r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}  \r\n\r\ninterface IERC721{\r\n   \r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner); // from ERC721\r\n    function setUpdateOperator(uint256 assetId,address operator) external;\r\n    function exists(uint256 assetId) external view returns (bool);\r\n    function isAuthorized(address operator, uint256 assetId) external view returns (bool);\r\n    function updateOperator(uint256 assetId) external view returns (bool);\r\n    function balanceOf(address _owner) external view returns (uint256 _balance);\r\n    function tokenOfOwnerByIndex(address,uint256) external view returns (uint256 _etateTokenId);\r\n    function isApprovedForAll(address, address) external view returns (bool auth);\r\n}\r\n\r\nstruct Lease{\r\n    address lessor;\r\n    address lessee;\r\n    uint256 assetId;\r\n    string nftType;\r\n   \r\n}\r\n\r\nstruct LeaseDetail{\r\n    uint256 rentAmount;\r\n    uint256 deposit;\r\n    uint monthsPaid;\r\n    uint gracePeriod;\r\n    uint leaseLength;\r\n    uint dateSigned;\r\n    string rentToken;\r\n    bool isOpen;\r\n    bool isLeased;\r\n    bool autoPay;\r\n    bool autoRegenerate;\r\n}\r\n   \r\nstruct Acceptedtoken{\r\n    string tokenSymbol;\r\n    address tokenAddress;\r\n    bool added;\r\n}\r\n\r\ncontract DCLRentStorage{\r\n   \r\n    using Roles for Roles.Role;\r\n    using BokkyPooBahsDateTimeLibrary for uint;\r\n    Roles.Role _platformAdmins;\r\n   \r\n    address[] _platformAdminsArr;\r\n    address dclLandProxy;\r\n    address dclEstateProxy;\r\n    address _owner;\r\n   \r\n    uint _adminCount = 0;\r\n    uint public leaseCount = 0;\r\n    uint256 platformFee = 5;\r\n    uint256 public minERCRent = 100000000000000000000;\r\n    uint256 public minETHRent = 20000000000000000;\r\n    uint256 public maliciousLimit = 2;\r\n   \r\n    mapping(string => mapping(uint256 => Lease)) public leaseByNftTypeAssetId;\r\n    mapping(string => mapping(uint256 => LeaseDetail)) public leaseDetailByNftTypeAssetId;\r\n    mapping(string => mapping(uint256 => uint256)) public leaseIndexByNftByAssetId;\r\n    mapping(string => Acceptedtoken) public acceptedTokensBySymbol;\r\n    mapping(string => uint256) public depositsByTokenSymbol;\r\n    mapping(string => address) public nftRegistryByType;\r\n    mapping(address => uint256) public landlordMaliciousCount;\r\n\r\n    Lease[] public allLeases;\r\n    bytes32[] public acceptedTokenSymbols;\r\n   \r\n    Lease stubLease = Lease(address(0), address(0), 0, \"\");\r\n    LeaseDetail stubLeaseDetail = LeaseDetail(0,0,0,0,0,0,\"\",false, false, false, false);\r\n   \r\n    event RentPaid(string nftType, uint256 assetId, address lessee, address lessor, uint256 amount, string rentToken);\r\n    event LeaseCreated(string nftType, uint256 assetId, address lessor, uint256 rentAmount, uint leaseLength, uint gracePeriod, string rentToken);\r\n    event LeaseUpdated(string nftType, uint256 assetId, address lessor, uint256 rentAmount, uint leaseLength, uint gracePeriod, string rentToken);\r\n    event LeaseCanceled(string nftType, uint256 assetId, address lessor, address depositTo);\r\n    event LeaseRemoved(string nftType, uint256 assetId);\r\n    event LeaseAccepted(string nftType, uint256 assetId, address lessee);\r\n    event LeaseCompleted(string nftType, uint256 assetId);\r\n    event LeaseTerminated(string nftType, uint256 assetId, address lessor);\r\n}\r\n\r\ncontract DCLRent is DCLRentStorage {\r\n   \r\n    constructor() public{\r\n        _owner = msg.sender;\r\n        allLeases.push(stubLease);\r\n        leaseCount++;\r\n    }\r\n   \r\n    function addAdmin(address newAdmin) public{\r\n        require(_owner == msg.sender || _platformAdmins.has(msg.sender));\r\n        _platformAdminsArr.push(newAdmin);\r\n        _platformAdmins.add(newAdmin);\r\n        _adminCount++;\r\n    }\r\n   \r\n    function addNFTType(string memory nftType, address nftRegistry) public{\r\n        require(_platformAdmins.has(msg.sender));\r\n        nftRegistryByType[nftType] = nftRegistry;\r\n    }\r\n   \r\n    function getAcceptedTokenSymbols()public view returns(bytes32[] memory tokenSymbols){\r\n        return acceptedTokenSymbols;\r\n    }\r\n   \r\n    function updatePlatformFee(uint256 newFee) public{\r\n        require(_platformAdmins.has(msg.sender));\r\n        platformFee = newFee;\r\n    }\r\n   \r\n    function addSupportedToken(string memory symbol, address token) public{\r\n        require(_platformAdmins.has(msg.sender));\r\n        if(!acceptedTokensBySymbol[symbol].added){\r\n            acceptedTokensBySymbol[symbol] = Acceptedtoken(symbol, token, true);\r\n            acceptedTokenSymbols.push(stringToBytes32(symbol));\r\n        }\r\n    }\r\n   \r\n    function changeMaliciousLimit(uint256 newLimit) public{\r\n        require(_platformAdmins.has(msg.sender));\r\n        maliciousLimit = newLimit;\r\n    }\r\n   \r\n    function changeMalLandlordCount(address landlord, uint8 count) public{\r\n        require(_platformAdmins.has(msg.sender));\r\n        landlordMaliciousCount[landlord] = count;\r\n    }\r\n   \r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n        if (bytes(source).length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n   \r\n    function isLeasedByAssetId(string memory _nftType, uint256 _assetId) public view returns(bool isLeased){\r\n        return leaseDetailByNftTypeAssetId[_nftType][_assetId].isLeased;\r\n    }\r\n   \r\n    function acceptLease(string memory _nftType, uint256 _assetId, bool _autoPay) public payable{\r\n        require(!isLeasedByAssetId(_nftType, _assetId));\r\n        require(leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen);\r\n        require(IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).ownerOf(_assetId) != msg.sender);\r\n       \r\n        uint256 balance;\r\n        if(keccak256(abi.encodePacked(leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken)) == (keccak256(abi.encodePacked(\"ETH\")))){\r\n            balance = msg.sender.balance;\r\n            require(msg.value >= leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount + leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit);\r\n        }\r\n        else{\r\n            balance = IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).balanceOf(msg.sender);\r\n        }\r\n        require(balance >= (leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount + leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit));\r\n        leaseByNftTypeAssetId[_nftType][_assetId].lessee = msg.sender;\r\n        leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen = false;\r\n        leaseDetailByNftTypeAssetId[_nftType][_assetId].isLeased = true;\r\n        leaseDetailByNftTypeAssetId[_nftType][_assetId].isLeased = true;\r\n        leaseDetailByNftTypeAssetId[_nftType][_assetId].autoPay = _autoPay;\r\n        leaseDetailByNftTypeAssetId[_nftType][_assetId].dateSigned = now;\r\n        IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).setUpdateOperator(_assetId, msg.sender);\r\n        allLeases[leaseIndexByNftByAssetId[_nftType][_assetId]] = leaseByNftTypeAssetId[_nftType][_assetId];\r\n        require(_tenantMakeDeposit(_nftType, _assetId));\r\n        require(_payRent(_nftType, _assetId));\r\n        emit LeaseAccepted(_nftType, _assetId, msg.sender);\r\n    }\r\n   \r\n    function createLease(Lease memory newLease, LeaseDetail memory newLeaseDetail, bool isUpdate) public{\r\n        require(acceptedTokensBySymbol[newLeaseDetail.rentToken].added || (keccak256(abi.encodePacked(newLeaseDetail.rentToken)) == (keccak256(abi.encodePacked(\"ETH\")))));\r\n        require(!isLeasedByAssetId(newLease.nftType, newLease.assetId));\r\n        if(isUpdate){\r\n        require(!leaseDetailByNftTypeAssetId[newLease.nftType][newLease.assetId].isOpen);\r\n        }\r\n        require(IERC721(nftRegistryByType[newLease.nftType]).exists(newLease.assetId));\r\n        require(IERC721(nftRegistryByType[newLease.nftType]).ownerOf(newLease.assetId) == msg.sender || _platformAdmins.has(msg.sender));\r\n        require(IERC721(nftRegistryByType[newLease.nftType]).isApprovedForAll(msg.sender, address(this)));\r\n        require(landlordMaliciousCount[msg.sender] <= maliciousLimit);\r\n        require(_createLease(newLease, newLeaseDetail));\r\n        if(isUpdate){\r\n            emit LeaseUpdated(newLease.nftType, newLease.assetId, msg.sender, newLeaseDetail.rentAmount, newLeaseDetail.leaseLength, newLeaseDetail.gracePeriod, newLeaseDetail.rentToken);\r\n        }\r\n        else{\r\n            emit LeaseCreated(newLease.nftType, newLease.assetId, msg.sender, newLeaseDetail.rentAmount, newLeaseDetail.leaseLength, newLeaseDetail.gracePeriod, newLeaseDetail.rentToken);\r\n        }\r\n    }\r\n   \r\n    function _createLease(Lease memory newLease, LeaseDetail memory newLeaseDetail) internal returns(bool){\r\n        if((keccak256(abi.encodePacked(newLeaseDetail.rentToken)) != (keccak256(abi.encodePacked(\"ETH\"))))){\r\n            if(newLeaseDetail.rentAmount < minERCRent){\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            if(newLeaseDetail.rentAmount < minETHRent){\r\n                return false;\r\n            }\r\n        }\r\n \r\n        leaseDetailByNftTypeAssetId[newLease.nftType][newLease.assetId] = newLeaseDetail;\r\n        leaseByNftTypeAssetId[newLease.nftType][newLease.assetId] = newLease;\r\n       \r\n        if(leaseIndexByNftByAssetId[newLease.nftType][newLease.assetId] == 0){\r\n            allLeases.push(newLease);\r\n            leaseIndexByNftByAssetId[newLease.nftType][newLease.assetId] = leaseCount;\r\n            leaseCount++;\r\n        }\r\n        else{\r\n            allLeases[leaseIndexByNftByAssetId[newLease.nftType][newLease.assetId]] = newLease;\r\n        }\r\n        return true;\r\n    }\r\n   \r\n    function _eraseLease(string memory _nftType, uint256 _assetId, bool checkRegen, bool malicious) internal returns(bool){\r\n        //rentHeldByNftTypeAssetId[_nftType][_assetId] = 0;\r\n        address landlord = leaseByNftTypeAssetId[_nftType][_assetId].lessor;\r\n        if(checkRegen){\r\n            if(leaseDetailByNftTypeAssetId[_nftType][_assetId].autoRegenerate){\r\n                leaseByNftTypeAssetId[_nftType][_assetId].lessee = address(0);\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId].dateSigned = 0;\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen = true;\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId].isLeased = false;\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid = 0;\r\n            }\r\n            else{\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId] = stubLeaseDetail;        \r\n                leaseByNftTypeAssetId[_nftType][_assetId] = stubLease;  \r\n            }\r\n        }\r\n        else{\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId] = stubLeaseDetail;        \r\n                leaseByNftTypeAssetId[_nftType][_assetId] = stubLease;            \r\n        }\r\n        if(malicious){\r\n            if(isPlatformAuthorized(_nftType)){\r\n                IERC721(nftRegistryByType[_nftType]).setUpdateOperator(_assetId, address(this));\r\n            }\r\n            landlordMaliciousCount[landlord] = landlordMaliciousCount[landlord] + 1;\r\n        }\r\n        allLeases[leaseIndexByNftByAssetId[_nftType][_assetId]] = leaseByNftTypeAssetId[_nftType][_assetId];\r\n        return true;\r\n    }\r\n   \r\n    function _checkLease(string memory _nftType, uint256 _assetId)internal view returns(bool){\r\n        if(isLeasedByAssetId(_nftType, _assetId) &&\r\n        !leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen && isLeasedByAssetId(_nftType, _assetId)){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n   \r\n    function isRentDue(string memory _nftType, uint256 _assetId) public view returns (bool rentDue){\r\n        uint today = now;\r\n        if(_checkLease(_nftType,_assetId))\r\n        {\r\n            if(isRentOverDue(_nftType, _assetId)){\r\n                return true;\r\n            }\r\n            else{\r\n                if(today >\r\n                BokkyPooBahsDateTimeLibrary.addMonths(leaseDetailByNftTypeAssetId[_nftType][_assetId].dateSigned,\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid)){\r\n                    return true;\r\n                }\r\n                else{\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n   \r\n    function isRentOverDue(string memory _nftType, uint256 _assetId) public view returns (bool){\r\n        uint today = now;\r\n        if(_checkLease(_nftType, _assetId))\r\n        {\r\n            if(leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid >= leaseDetailByNftTypeAssetId[_nftType][_assetId].leaseLength){\r\n                return false;\r\n            }\r\n            else{\r\n                if(today > BokkyPooBahsDateTimeLibrary.addDays(\r\n                BokkyPooBahsDateTimeLibrary.addMonths(leaseDetailByNftTypeAssetId[_nftType][_assetId].dateSigned, leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid),\r\n                leaseDetailByNftTypeAssetId[_nftType][_assetId].gracePeriod)){\r\n                    return true;\r\n                }\r\n                else{\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n   \r\n    function landlordCancelLease(string memory _nftType, uint256 _assetId) public{\r\n        require(isLeasedByAssetId(_nftType, _assetId));\r\n        require(!leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen);\r\n        require(IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).exists(_assetId));\r\n        require(IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).ownerOf(_assetId) == msg.sender);\r\n        require( _transferTenantDeposit(_nftType, _assetId, leaseByNftTypeAssetId[_nftType][_assetId].lessee));\r\n        require(_eraseLease(_nftType, _assetId, false, true));\r\n        emit LeaseCanceled(leaseByNftTypeAssetId[_nftType][_assetId].nftType, leaseByNftTypeAssetId[_nftType][_assetId].assetId, leaseByNftTypeAssetId[_nftType][_assetId].lessor, leaseByNftTypeAssetId[_nftType][_assetId].lessee);\r\n    }\r\n   \r\n    function landlordRemoveLease(string memory _nftType, uint256 _assetId) public{\r\n        require(!isLeasedByAssetId(_nftType, _assetId));\r\n        require(!isLeaseCompleted(_nftType, _assetId));\r\n        require(leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen);\r\n        require(IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).exists(_assetId));\r\n        require(IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).ownerOf(_assetId) == msg.sender);\r\n        require(_eraseLease(_nftType,_assetId, false, false));\r\n        emit LeaseRemoved(_nftType, _assetId);\r\n    }\r\n   \r\n    function landlordTerminateLease(string memory _nftType, uint256 _assetId) public{\r\n        require(isLeasedByAssetId(_nftType, _assetId));\r\n        require(isRentOverDue(_nftType, _assetId));\r\n        require(!isLeaseCompleted(_nftType, _assetId));\r\n        require(IERC721(nftRegistryByType[leaseByNftTypeAssetId[_nftType][_assetId].nftType]).ownerOf(_assetId) == msg.sender);\r\n        require(_transferTenantDeposit(_nftType, _assetId, leaseByNftTypeAssetId[_nftType][_assetId].lessor));\r\n        address lessor =leaseByNftTypeAssetId[_nftType][_assetId].lessor;\r\n        require(_eraseLease(_nftType, _assetId, true, false));\r\n        emit LeaseTerminated(_nftType, _assetId, lessor);\r\n    }\r\n   \r\n    function tenantCancelLease(string memory _nftType, uint256 _assetId) public{\r\n        require(isLeasedByAssetId(_nftType, _assetId));\r\n        require(!isLeaseCompleted(_nftType, _assetId));\r\n        require(leaseByNftTypeAssetId[_nftType][_assetId].lessee == msg.sender);\r\n        require(_transferTenantDeposit(_nftType, _assetId, leaseByNftTypeAssetId[_nftType][_assetId].lessor));\r\n        require(_eraseLease(_nftType, _assetId, true, false));\r\n        emit LeaseCanceled(_nftType, _assetId, leaseByNftTypeAssetId[_nftType][_assetId].lessor, leaseByNftTypeAssetId[_nftType][_assetId].lessor);\r\n    }\r\n   \r\n    function _tenantMakeDeposit(string memory _nftType, uint256 _assetId) internal returns (bool){\r\n        uint256 deposit = leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit;\r\n        if(deposit > 0){\r\n            if((keccak256(abi.encodePacked(leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken)) != (keccak256(abi.encodePacked(\"ETH\"))))){\r\n            uint256 lesseeBalance = IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).balanceOf(msg.sender);\r\n            require(lesseeBalance >= deposit);\r\n            IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).transferFrom(leaseByNftTypeAssetId[_nftType][_assetId].lessee, address(this), deposit);\r\n            }\r\n            depositsByTokenSymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken] += deposit;\r\n        }\r\n        return true;\r\n    }\r\n   \r\n    function _transferTenantDeposit(string memory _nftType, uint256 _assetId, address _sendDepositTo) internal returns (bool){\r\n        require(leaseByNftTypeAssetId[_nftType][_assetId].lessor == IERC721(nftRegistryByType[_nftType]).ownerOf(_assetId));\r\n       \r\n        if(leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit > 0){    \r\n            if((keccak256(abi.encodePacked(leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken)) == (keccak256(abi.encodePacked(\"ETH\"))))){\r\n                address payable depositReceiver = payable(_sendDepositTo);\r\n                depositReceiver.transfer(leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit);\r\n            }\r\n            else{\r\n                IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).transfer(_sendDepositTo, leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit);\r\n            }\r\n            depositsByTokenSymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken] -= leaseDetailByNftTypeAssetId[_nftType][_assetId].deposit;\r\n        }\r\n        return true;\r\n    }\r\n   \r\n    function adminTerminateLease(string memory _nftType, uint256 _assetId, address _sendDepositTo, bool malicious) public {\r\n        require(isLeasedByAssetId(_nftType, _assetId));\r\n        require(_platformAdmins.has(msg.sender));\r\n        require(_transferTenantDeposit(_nftType, _assetId, _sendDepositTo));\r\n        address lessor = leaseByNftTypeAssetId[_nftType][_assetId].lessor;\r\n        if(malicious){\r\n            require(_eraseLease(_nftType, _assetId, false, true));\r\n        }\r\n        else{\r\n            require(_eraseLease(_nftType, _assetId, true, false));\r\n        }\r\n        emit LeaseTerminated(_nftType, _assetId, lessor);\r\n    }\r\n   \r\n    function adminRemoveLease(string memory _nftType, uint256 _assetId) public {\r\n        require(!isLeasedByAssetId(_nftType, _assetId));\r\n        require(leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen);\r\n        require(_platformAdmins.has(msg.sender));\r\n        require(_eraseLease(_nftType, _assetId, false, false));\r\n        emit LeaseRemoved(_nftType, _assetId);\r\n    }\r\n   \r\n    function adminWithdraw(string memory token)public{\r\n        require(_platformAdmins.has(msg.sender));\r\n        require(acceptedTokensBySymbol[token].added);\r\n        if((keccak256(abi.encodePacked(token)) == (keccak256(abi.encodePacked(\"ETH\"))))){\r\n            uint256 platformBalance = address(this).balance;\r\n            platformBalance -= depositsByTokenSymbol[token];\r\n            uint256 platformAdminSplit = platformBalance / _adminCount;\r\n            for(uint256 i = 0; i < _adminCount; i++){\r\n                address payable admin = payable(_platformAdminsArr[i]);\r\n                admin.transfer(platformAdminSplit);\r\n            }  \r\n        }\r\n        else{\r\n            require(IERC20(acceptedTokensBySymbol[token].tokenAddress).balanceOf(address(this)) > 1000000000000000000);\r\n            uint256 platformBalance = IERC20(acceptedTokensBySymbol[token].tokenAddress).balanceOf(address(this));\r\n            platformBalance -= depositsByTokenSymbol[token];\r\n            uint256 platformAdminSplit = platformBalance / _adminCount;\r\n            for(uint256 i = 0; i < _adminCount; i++){\r\n                IERC20(acceptedTokensBySymbol[token].tokenAddress).transfer(_platformAdminsArr[i], platformAdminSplit);\r\n            }  \r\n        }\r\n    }\r\n   \r\n    function isLeaseCompleted(string memory _nftType, uint256 _assetId) public view returns(bool){\r\n        if(isLeasedByAssetId(_nftType, _assetId)){\r\n        if(leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid >= leaseDetailByNftTypeAssetId[_nftType][_assetId].leaseLength){\r\n            if(now > BokkyPooBahsDateTimeLibrary.addMonths(leaseDetailByNftTypeAssetId[_nftType][_assetId].dateSigned, leaseDetailByNftTypeAssetId[_nftType][_assetId].leaseLength)){\r\n                return true;\r\n            }\r\n            else{\r\n                return false;\r\n            }\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n   \r\n    function _payRent(string memory _nftType, uint256 _assetId) internal returns(bool){\r\n        uint256 platformCut =  leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount * platformFee / 100;\r\n        uint256 monthlyRent = leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount - platformCut;// - rentHeld;\r\n        uint256 lesseeBalance;\r\n       \r\n        if((keccak256(abi.encodePacked(leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken)) == (keccak256(abi.encodePacked(\"ETH\"))))){\r\n            lesseeBalance = leaseByNftTypeAssetId[_nftType][_assetId].lessee.balance;\r\n            require(lesseeBalance >= leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount);\r\n            require(msg.value >= leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount);\r\n            address payable landlord = payable(leaseByNftTypeAssetId[_nftType][_assetId].lessor);\r\n            uint256 rentPaid = msg.value;\r\n            require(rentPaid >= monthlyRent);\r\n            landlord.transfer(monthlyRent);\r\n        }\r\n        else{\r\n            lesseeBalance = IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).balanceOf(leaseByNftTypeAssetId[_nftType][_assetId].lessee);\r\n            require(lesseeBalance >= leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount);\r\n            IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).transferFrom(leaseByNftTypeAssetId[_nftType][_assetId].lessee, leaseByNftTypeAssetId[_nftType][_assetId].lessor, monthlyRent);\r\n            IERC20(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].tokenAddress).transferFrom(leaseByNftTypeAssetId[_nftType][_assetId].lessee, address(this), platformCut);\r\n\r\n        }\r\n        leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid += 1;\r\n        allLeases[leaseIndexByNftByAssetId[_nftType][_assetId]] = leaseByNftTypeAssetId[_nftType][_assetId];\r\n        emit RentPaid(_nftType, _assetId, leaseByNftTypeAssetId[_nftType][_assetId].lessee, leaseByNftTypeAssetId[_nftType][_assetId].lessor, leaseDetailByNftTypeAssetId[_nftType][_assetId].rentAmount, leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken);\r\n        return true;\r\n    }\r\n   \r\n    function payRent(string memory _nftType, uint256 _assetId) public payable{\r\n        require(acceptedTokensBySymbol[leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken].added || (keccak256(abi.encodePacked(leaseDetailByNftTypeAssetId[_nftType][_assetId].rentToken))) == (keccak256(abi.encodePacked(\"ETH\"))), \"Token not supported\");\r\n        require(isLeasedByAssetId(_nftType, _assetId));\r\n        require(!leaseDetailByNftTypeAssetId[_nftType][_assetId].isOpen);\r\n        require(msg.sender == leaseByNftTypeAssetId[_nftType][_assetId].lessee || _platformAdmins.has(msg.sender));\r\n        require(IERC721(nftRegistryByType[_nftType]).exists(_assetId));\r\n        require(leaseDetailByNftTypeAssetId[_nftType][_assetId].monthsPaid < leaseDetailByNftTypeAssetId[_nftType][_assetId].leaseLength);\r\n        require(leaseByNftTypeAssetId[_nftType][_assetId].lessor == IERC721(nftRegistryByType[_nftType]).ownerOf(_assetId));\r\n        require(isRentDue(_nftType, _assetId));\r\n        require(_payRent(_nftType, _assetId));\r\n    }\r\n   \r\n    function isAdmin(address adminAddress) public view returns(bool){\r\n        return _platformAdmins.has(adminAddress);\r\n    }\r\n\r\n    function isPlatformAuthorized(string memory _nftType) public view returns (bool){\r\n        return IERC721(nftRegistryByType[_nftType]).isApprovedForAll(msg.sender, address(this));\r\n    }\r\n}"}}}