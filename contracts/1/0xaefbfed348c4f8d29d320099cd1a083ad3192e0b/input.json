{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LeveragedYieldFarm.sol": {
      "content": "pragma solidity ^0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface Erc20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transfer(address, uint256) external returns (bool);\r\n}\r\n\r\ninterface CErc20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function mint(uint256) external returns (uint256);\r\n    function redeem(uint) external returns (uint);\r\n    function redeemUnderlying(uint) external returns (uint);\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n}\r\n\r\ninterface Comptroller {\r\n    function enterMarkets(address[] calldata)\r\n        external\r\n        returns (uint256[] memory);\r\n\r\n    function claimComp(address holder) external;\r\n\r\n}\r\n\r\ninterface Structs {\r\n    struct Val {\r\n        uint256 value;\r\n    }\r\n\r\n    enum ActionType {\r\n      Deposit,   // supply tokens\r\n      Withdraw,  // borrow tokens\r\n      Transfer,  // transfer balance between accounts\r\n      Buy,       // buy an amount of some token (externally)\r\n      Sell,      // sell an amount of some token (externally)\r\n      Trade,     // trade tokens against another account\r\n      Liquidate, // liquidate an undercollateralized or expiring account\r\n      Vaporize,  // use excess tokens to zero-out a completely negative account\r\n      Call       // send arbitrary data to an address\r\n    }\r\n\r\n    enum AssetDenomination {\r\n        Wei // the amount is denominated in wei\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta // the amount is given as a delta from the current value\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct Info {\r\n        address owner;  // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n}\r\n\r\ncontract DyDxPool is Structs {\r\n    function getAccountWei(Info memory account, uint256 marketId) public view returns (Wei memory);\r\n    function operate(Info[] memory, ActionArgs[] memory) public;\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\ncontract DyDxFlashLoan is Structs {\r\n    DyDxPool pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\r\n\r\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\r\n    address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    mapping(address => uint256) public currencies;\r\n\r\n    constructor() public {\r\n        currencies[WETH] = 1;\r\n        currencies[SAI] = 2;\r\n        currencies[USDC] = 3;\r\n        currencies[DAI] = 4;\r\n    }\r\n\r\n    modifier onlyPool() {\r\n        require(\r\n            msg.sender == address(pool),\r\n            \"FlashLoan: could be called by DyDx pool only\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function tokenToMarketId(address token) public view returns (uint256) {\r\n        uint256 marketId = currencies[token];\r\n        require(marketId != 0, \"FlashLoan: Unsupported token\");\r\n        return marketId - 1;\r\n    }\r\n\r\n    // the DyDx will call `callFunction(address sender, Info memory accountInfo, bytes memory data) public` after during `operate` call\r\n    function flashloan(address token, uint256 amount, bytes memory data)\r\n        internal\r\n    {\r\n        IERC20(token).approve(address(pool), amount + 1);\r\n        Info[] memory infos = new Info[](1);\r\n        ActionArgs[] memory args = new ActionArgs[](3);\r\n\r\n        infos[0] = Info(address(this), 0);\r\n\r\n        AssetAmount memory wamt = AssetAmount(\r\n            false,\r\n            AssetDenomination.Wei,\r\n            AssetReference.Delta,\r\n            amount\r\n        );\r\n        ActionArgs memory withdraw;\r\n        withdraw.actionType = ActionType.Withdraw;\r\n        withdraw.accountId = 0;\r\n        withdraw.amount = wamt;\r\n        withdraw.primaryMarketId = tokenToMarketId(token);\r\n        withdraw.otherAddress = address(this);\r\n\r\n        args[0] = withdraw;\r\n\r\n        ActionArgs memory call;\r\n        call.actionType = ActionType.Call;\r\n        call.accountId = 0;\r\n        call.otherAddress = address(this);\r\n        call.data = data;\r\n\r\n        args[1] = call;\r\n\r\n        ActionArgs memory deposit;\r\n        AssetAmount memory damt = AssetAmount(\r\n            true,\r\n            AssetDenomination.Wei,\r\n            AssetReference.Delta,\r\n            amount + 1\r\n        );\r\n        deposit.actionType = ActionType.Deposit;\r\n        deposit.accountId = 0;\r\n        deposit.amount = damt;\r\n        deposit.primaryMarketId = tokenToMarketId(token);\r\n        deposit.otherAddress = address(this);\r\n\r\n        args[2] = deposit;\r\n\r\n        pool.operate(infos, args);\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.0;\r\n\r\ncontract LeveragedYieldFarm is DyDxFlashLoan  {\r\n    // Mainnet Dai\r\n    // https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#readContract\r\n    address daiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    Erc20 dai = Erc20(daiAddress);\r\n\r\n    // Mainnet cDai\r\n    // https://etherscan.io/address/0x5d3a536e4d6dbd6114cc1ead35777bab948e3643#readProxyContract\r\n    address cDaiAddress = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\r\n    CErc20 cDai = CErc20(cDaiAddress);\r\n\r\n    // Mainnet Comptroller\r\n    // https://etherscan.io/address/0x3d9819210a31b4961b30ef54be2aed79b9c9cd3b#readProxyContract\r\n    address comptrollerAddress = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    Comptroller comptroller = Comptroller(comptrollerAddress);\r\n\r\n    // COMP ERC-20 token\r\n    // https://etherscan.io/token/0xc00e94cb662c3520282e6f5717214004a7f26888\r\n    Erc20 compToken = Erc20(0xc00e94Cb662C3520282E6f5717214004A7f26888);\r\n\r\n    // Deposit/Withdraw values\r\n    bytes32 DEPOSIT = keccak256(\"DEPOSIT\");\r\n    bytes32 WITHDRAW = keccak256(\"WITHDRAW\");\r\n\r\n    // Contract owner\r\n    address payable owner;\r\n\r\n    event FlashLoan(address indexed _from, bytes32 indexed _id, uint _value);\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not the owner!\");\r\n        _;\r\n    }\r\n\r\n    // Don't allow contract to receive Ether by mistake\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    constructor() public {\r\n        // Track the contract owner\r\n        owner = msg.sender;\r\n\r\n        // Enter the cDai market so you can borrow another type of asset\r\n        address[] memory cTokens = new address[](1);\r\n        cTokens[0] = cDaiAddress;\r\n        uint256[] memory errors = comptroller.enterMarkets(cTokens);\r\n        if (errors[0] != 0) {\r\n            revert(\"Comptroller.enterMarkets failed.\");\r\n        }\r\n    }\r\n\r\n    // Do not deposit all your DAI because you must pay flash loan fees\r\n    // Always keep at least 1 DAI in the contract\r\n    function depositDai(uint256 initialAmount) external onlyOwner returns (bool){\r\n        // Total deposit: 30% initial amount, 70% flash loan\r\n        uint256 totalAmount = (initialAmount * 10) / 3;\r\n\r\n        // loan is 70% of total deposit\r\n        uint256 flashLoanAmount = totalAmount - initialAmount;\r\n\r\n        // Get DAI Flash Loan for \"DEPOSIT\"\r\n        bytes memory data = abi.encode(totalAmount, flashLoanAmount, DEPOSIT);\r\n        flashloan(daiAddress, flashLoanAmount, data); // execution goes to `callFunction`\r\n\r\n        // Handle remaining execution inside handleDeposit() function\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // You must have some Dai in your contract still to pay flash loan fee!\r\n    // Always keep at least 1 DAI in the contract\r\n    function withdrawDai(uint256 initialAmount) external onlyOwner returns (bool){\r\n        // Total deposit: 30% initial amount, 70% flash loan\r\n        uint256 totalAmount = (initialAmount * 10) / 3;\r\n\r\n        // loan is 70% of total deposit\r\n        uint256 flashLoanAmount = totalAmount - initialAmount;\r\n\r\n        // Use flash loan to payback borrowed amount\r\n        bytes memory data = abi.encode(totalAmount, flashLoanAmount, WITHDRAW);\r\n        flashloan(daiAddress, flashLoanAmount, data); // execution goes to `callFunction`\r\n\r\n        // Handle repayment inside handleWithdraw() function\r\n\r\n        // Claim COMP tokens\r\n        comptroller.claimComp(address(this));\r\n\r\n        // Withdraw COMP tokens\r\n        compToken.transfer(owner, compToken.balanceOf(address(this)));\r\n\r\n        // Withdraw Dai to the wallet\r\n        dai.transfer(owner, dai.balanceOf(address(this)));\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function callFunction(\r\n        address, /* sender */\r\n        Info calldata, /* accountInfo */\r\n        bytes calldata data\r\n    ) external onlyPool {\r\n        (uint256 totalAmount, uint256 flashLoanAmount, bytes32 operation) = abi\r\n            .decode(data, (uint256, uint256, bytes32));\r\n\r\n        if(operation == DEPOSIT) {\r\n            handleDeposit(totalAmount, flashLoanAmount);\r\n        }\r\n\r\n        if(operation == WITHDRAW) {\r\n            handleWithdraw();\r\n        }\r\n    }\r\n\r\n    // You must first send DAI to this contract before you can call this function\r\n    function handleDeposit(uint256 totalAmount, uint256 flashLoanAmount) internal returns (bool) {\r\n        // Approve Dai tokens as collateral\r\n        dai.approve(cDaiAddress, totalAmount);\r\n\r\n        // Provide collateral by minting cDai tokens\r\n        cDai.mint(totalAmount);\r\n\r\n        // Borrow Dai\r\n        cDai.borrow(flashLoanAmount);\r\n\r\n        // Start earning COMP tokens, yay!\r\n        return true;\r\n    }\r\n\r\n    function handleWithdraw() internal returns (bool) {\r\n        uint256 balance;\r\n\r\n        // Get curent borrow Balance\r\n        balance = cDai.borrowBalanceCurrent(address(this));\r\n\r\n        // Approve tokens for repayment\r\n        dai.approve(address(cDai), balance);\r\n\r\n        // Repay tokens\r\n        cDai.repayBorrow(balance);\r\n\r\n        // Get cDai balance\r\n        balance = cDai.balanceOf(address(this));\r\n\r\n        // Redeem cDai\r\n        cDai.redeem(balance);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Fallback in case any other tokens are sent to this contract\r\n    function withdrawToken(address _tokenAddress) public onlyOwner {\r\n        uint256 balance = Erc20(_tokenAddress).balanceOf(address(this));\r\n        Erc20(_tokenAddress).transfer(owner, balance);\r\n    }\r\n\r\n}"
    }
  }
}