{"language":"Solidity","settings":{"evmVersion":"byzantium","libraries":{"Pool.sol":{"FixidityLib":"0x4804b8bc5112fd4216824c2673ee792f180a1c1e","SortitionSumTreeFactory":"0xe48cc097c45339c94e272e04ca55790ee63d16f1"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Pool.sol":{"content":"pragma solidity 0.5.0;\r\n\r\nlibrary UniformRandomNumber {\r\n  /// @author Brendan Asselstine\r\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\r\n  /// @param _entropy The seed for randomness\r\n  /// @param _upperBound The upper bound of the desired number\r\n  /// @return A random number less than the _upperBound\r\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\r\n    uint256 min = -_upperBound % _upperBound;\r\n    uint256 random = _entropy;\r\n    while (true) {\r\n      if (random >= min) {\r\n        break;\r\n      }\r\n      random = uint256(keccak256(abi.encodePacked(random)));\r\n    }\r\n    return random % _upperBound;\r\n  }\r\n}\r\n\r\ncontract ICErc20 {\r\n    address public underlying;\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n    function balanceOfUnderlying(address owner) external returns (uint);\r\n    function getCash() external view returns (uint);\r\n    function supplyRatePerBlock() external view returns (uint);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\r\n *  @auditors: []\r\n *  @bounties: [<14 days 10 ETH max payout>]\r\n *  @deployments: []\r\n */\r\n\r\n\r\n\r\n/**\r\n *  @title SortitionSumTreeFactory\r\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\r\n *  @dev A factory of trees that keep track of staked values for sortition.\r\n */\r\nlibrary SortitionSumTreeFactory {\r\n    /* Structs */\r\n\r\n    struct SortitionSumTree {\r\n        uint K; // The maximum number of childs per node.\r\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\r\n        uint[] stack;\r\n        uint[] nodes;\r\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\r\n        mapping(bytes32 => uint) IDsToNodeIndexes;\r\n        mapping(uint => bytes32) nodeIndexesToIDs;\r\n    }\r\n\r\n    /* Storage */\r\n\r\n    struct SortitionSumTrees {\r\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\r\n    }\r\n\r\n    /* Public */\r\n\r\n    /**\r\n     *  @dev Create a sortition sum tree at the specified key.\r\n     *  @param _key The key of the new tree.\r\n     *  @param _K The number of children each node in the tree should have.\r\n     */\r\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) public {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        require(tree.K == 0, \"Tree already exists.\");\r\n        require(_K > 1, \"K must be greater than one.\");\r\n        tree.K = _K;\r\n        tree.stack.length = 0;\r\n        tree.nodes.length = 0;\r\n        tree.nodes.push(0);\r\n    }\r\n\r\n    /**\r\n     *  @dev Set a value of a tree.\r\n     *  @param _key The key of the tree.\r\n     *  @param _value The new value.\r\n     *  @param _ID The ID of the value.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) public {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) { // No existing node.\r\n            if (_value != 0) { // Non zero value.\r\n                // Append.\r\n                // Add node.\r\n                if (tree.stack.length == 0) { // No vacant spots.\r\n                    // Get the index and append the value.\r\n                    treeIndex = tree.nodes.length;\r\n                    tree.nodes.push(_value);\r\n\r\n                    // Potentially append a new node and make the parent a sum node.\r\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\r\n                        uint parentIndex = treeIndex / tree.K;\r\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\r\n                        uint newIndex = treeIndex + 1;\r\n                        tree.nodes.push(tree.nodes[parentIndex]);\r\n                        delete tree.nodeIndexesToIDs[parentIndex];\r\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\r\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\r\n                    }\r\n                } else { // Some vacant spot.\r\n                    // Pop the stack and append the value.\r\n                    treeIndex = tree.stack[tree.stack.length - 1];\r\n                    tree.stack.length--;\r\n                    tree.nodes[treeIndex] = _value;\r\n                }\r\n\r\n                // Add label.\r\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\r\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\r\n\r\n                updateParents(self, _key, treeIndex, true, _value);\r\n            }\r\n        } else { // Existing node.\r\n            if (_value == 0) { // Zero value.\r\n                // Remove.\r\n                // Remember value and set to 0.\r\n                uint value = tree.nodes[treeIndex];\r\n                tree.nodes[treeIndex] = 0;\r\n\r\n                // Push to stack.\r\n                tree.stack.push(treeIndex);\r\n\r\n                // Clear label.\r\n                delete tree.IDsToNodeIndexes[_ID];\r\n                delete tree.nodeIndexesToIDs[treeIndex];\r\n\r\n                updateParents(self, _key, treeIndex, false, value);\r\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\r\n                // Set.\r\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\r\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\r\n                tree.nodes[treeIndex] = _value;\r\n\r\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* Public Views */\r\n\r\n    /**\r\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\r\n     *  @param _key The key of the tree to get the leaves from.\r\n     *  @param _cursor The pagination cursor.\r\n     *  @param _count The number of items to return.\r\n     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\r\n     *  `O(n)` where\r\n     *  `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function queryLeafs(\r\n        SortitionSumTrees storage self,\r\n        bytes32 _key,\r\n        uint _cursor,\r\n        uint _count\r\n    ) public view returns(uint startIndex, uint[] memory values, bool hasMore) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        // Find the start index.\r\n        for (uint i = 0; i < tree.nodes.length; i++) {\r\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\r\n                startIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the values.\r\n        uint loopStartIndex = startIndex + _cursor;\r\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\r\n        uint valuesIndex = 0;\r\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\r\n            if (valuesIndex < _count) {\r\n                values[valuesIndex] = tree.nodes[j];\r\n                valuesIndex++;\r\n            } else {\r\n                hasMore = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\r\n     *  @param _key The key of the tree.\r\n     *  @param _drawnNumber The drawn number.\r\n     *  @return The drawn ID.\r\n     *  `O(k * log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) public view returns(bytes32 ID) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = 0;\r\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\r\n\r\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\r\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\r\n                uint nodeIndex = (tree.K * treeIndex) + i;\r\n                uint nodeValue = tree.nodes[nodeIndex];\r\n\r\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\r\n                else { // Pick this child.\r\n                    treeIndex = nodeIndex;\r\n                    break;\r\n                }\r\n            }\r\n        \r\n        ID = tree.nodeIndexesToIDs[treeIndex];\r\n    }\r\n\r\n    /** @dev Gets a specified ID's associated value.\r\n     *  @param _key The key of the tree.\r\n     *  @param _ID The ID of the value.\r\n     *  @return The associated value.\r\n     */\r\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) public view returns(uint value) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) value = 0;\r\n        else value = tree.nodes[treeIndex];\r\n    }\r\n\r\n    /* Private */\r\n\r\n    /**\r\n     *  @dev Update all the parents of a node.\r\n     *  @param _key The key of the tree to update.\r\n     *  @param _treeIndex The index of the node to start from.\r\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\r\n     *  @param _value The value to add or substract.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        uint parentIndex = _treeIndex;\r\n        while (parentIndex != 0) {\r\n            parentIndex = (parentIndex - 1) / tree.K;\r\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title FixidityLib\r\n * @author Gadi Guy, Alberto Cuesta Canada\r\n * @notice This library provides fixed point arithmetic with protection against\r\n * overflow. \r\n * All operations are done with int256 and the operands must have been created \r\n * with any of the newFrom* functions, which shift the comma digits() to the \r\n * right and check for limits.\r\n * When using this library be sure of using maxNewFixed() as the upper limit for\r\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\r\n * maxFixedAdd() if you want to be certain that those operations don't \r\n * overflow.\r\n */\r\nlibrary FixidityLib {\r\n\r\n    /**\r\n     * @notice Number of positions that the comma is shifted to the right.\r\n     */\r\n    function digits() public pure returns(uint8) {\r\n        return 24;\r\n    }\r\n    \r\n    /**\r\n     * @notice This is 1 in the fixed point units used in this library.\r\n     * @dev Test fixed1() equals 10^digits()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function fixed1() public pure returns(int256) {\r\n        return 1000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice The amount of decimals lost on each multiplication operand.\r\n     * @dev Test mulPrecision() equals sqrt(fixed1)\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function mulPrecision() public pure returns(int256) {\r\n        return 1000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be represented in an int256\r\n     * @dev Test maxInt256() equals 2^255 -1\r\n     */\r\n    function maxInt256() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\r\n    }\r\n\r\n    /**\r\n     * @notice Minimum value that can be represented in an int256\r\n     * @dev Test minInt256 equals (2^255) * (-1)\r\n     */\r\n    function minInt256() public pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * @dev deployment. \r\n     * Test maxNewFixed() equals maxInt256() / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxNewFixed() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * deployment. \r\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function minNewFixed() public pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as an addition operator.\r\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\r\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \r\n     */\r\n    function maxFixedAdd() public pure returns(int256) {\r\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum negative value that can be safely in a subtraction.\r\n     * @dev Test maxFixedSub() equals minInt256() / 2\r\n     */\r\n    function maxFixedSub() public pure returns(int256) {\r\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a multiplication operator.\r\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \r\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\r\n     * that would give the exact square root of maxInt256*fixed1 so this number\r\n     * is below the real number by no more than 3*10**28. It is safe to use as\r\n     * a limit for your multiplications, although powers of two of numbers over\r\n     * this value might still work.\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \r\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\r\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedMul() public pure returns(int256) {\r\n        return 240615969168004498257251713877715648331380787511296;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a dividend.\r\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\r\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\r\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDiv() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a divisor.\r\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDivisor() public pure returns(int256) {\r\n        return 1000000000000000000000000000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\r\n     * by 10^digits().\r\n     * @dev Test newFixed(0) returns 0\r\n     * Test newFixed(1) returns fixed1()\r\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\r\n     * Test newFixed(maxNewFixed()+1) fails\r\n     */\r\n    function newFixed(int256 x)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(x <= maxNewFixed());\r\n        assert(x >= minNewFixed());\r\n        return x * fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a non decimal. All decimal digits will be truncated.\r\n     */\r\n    function fromFixed(int256 x)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return x / fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to a different fixed precision representation.\r\n     * Both the origin and destination precisions must be 38 or less digits.\r\n     * Origin values with a precision higher than the destination precision\r\n     * will be truncated accordingly.\r\n     * @dev \r\n     * Test convertFixed(1,0,0) returns 1;\r\n     * Test convertFixed(1,1,1) returns 1;\r\n     * Test convertFixed(1,1,0) returns 0;\r\n     * Test convertFixed(1,0,1) returns 10;\r\n     * Test convertFixed(10,1,0) returns 1;\r\n     * Test convertFixed(10,0,1) returns 100;\r\n     * Test convertFixed(100,1,0) returns 10;\r\n     * Test convertFixed(100,0,1) returns 1000;\r\n     * Test convertFixed(1000,2,0) returns 10;\r\n     * Test convertFixed(1000,0,2) returns 100000;\r\n     * Test convertFixed(1000,2,1) returns 100;\r\n     * Test convertFixed(1000,1,2) returns 10000;\r\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\r\n     * Test convertFixed(maxInt256,0,1) throws\r\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\r\n     * Test convertFixed(1,0,38) returns 10**38;\r\n     * Test convertFixed(maxInt256,39,0) throws\r\n     * Test convertFixed(1,0,39) throws\r\n     */\r\n    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(_originDigits <= 38 && _destinationDigits <= 38);\r\n        \r\n        uint8 decimalDifference;\r\n        if ( _originDigits > _destinationDigits ){\r\n            decimalDifference = _originDigits - _destinationDigits;\r\n            return x/(uint128(10)**uint128(decimalDifference));\r\n        }\r\n        else if ( _originDigits < _destinationDigits ){\r\n            decimalDifference = _destinationDigits - _originDigits;\r\n            // Cast uint8 -> uint128 is safe\r\n            // Exponentiation is safe:\r\n            //     _originDigits and _destinationDigits limited to 38 or less\r\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\r\n            //     decimalDifference < 38\r\n            //     10**38 < 2**128-1\r\n            assert(x <= maxInt256()/uint128(10)**uint128(decimalDifference));\r\n            assert(x >= minInt256()/uint128(10)**uint128(decimalDifference));\r\n            return x*(uint128(10)**uint128(decimalDifference));\r\n        }\r\n        // _originDigits == digits()) \r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to that of this library. The _originDigits parameter is the\r\n     * precision of x. Values with a precision higher than FixidityLib.digits()\r\n     * will be truncated accordingly.\r\n     */\r\n    function newFixed(int256 x, uint8 _originDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, _originDigits, digits());\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a different representation. The _destinationDigits parameter is the\r\n     * precision of the output x. Values with a precision below than \r\n     * FixidityLib.digits() will be truncated accordingly.\r\n     */\r\n    function fromFixed(int256 x, uint8 _destinationDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, digits(), _destinationDigits);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts two int256 representing a fraction to fixed point units,\r\n     * equivalent to multiplying dividend and divisor by 10^digits().\r\n     * @dev \r\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\r\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\r\n     * Test newFixedFraction(1,0) fails     \r\n     * Test newFixedFraction(0,1) returns 0\r\n     * Test newFixedFraction(1,1) returns fixed1()\r\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\r\n     * Test newFixedFraction(1,fixed1()) returns 1\r\n     * Test newFixedFraction(1,fixed1()-1) returns 0\r\n     */\r\n    function newFixedFraction(\r\n        int256 numerator, \r\n        int256 denominator\r\n        )\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(numerator <= maxNewFixed());\r\n        assert(denominator <= maxNewFixed());\r\n        assert(denominator != 0);\r\n        int256 convertedNumerator = newFixed(numerator);\r\n        int256 convertedDenominator = newFixed(denominator);\r\n        return divide(convertedNumerator, convertedDenominator);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the integer part of a fixed point number.\r\n     * @dev \r\n     * Test integer(0) returns 0\r\n     * Test integer(fixed1()) returns fixed1()\r\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test integer(-fixed1()) returns -fixed1()\r\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\r\n     */\r\n    function integer(int256 x) public pure returns (int256) {\r\n        return (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the fractional part of a fixed point number. \r\n     * In the case of a negative number the fractional is also negative.\r\n     * @dev \r\n     * Test fractional(0) returns 0\r\n     * Test fractional(fixed1()) returns 0\r\n     * Test fractional(fixed1()-1) returns 10^24-1\r\n     * Test fractional(-fixed1()) returns 0\r\n     * Test fractional(-fixed1()+1) returns -10^24-1\r\n     */\r\n    function fractional(int256 x) public pure returns (int256) {\r\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Converts to positive if negative.\r\n     * Due to int256 having one more negative number than positive numbers \r\n     * abs(minInt256) reverts.\r\n     * @dev \r\n     * Test abs(0) returns 0\r\n     * Test abs(fixed1()) returns -fixed1()\r\n     * Test abs(-fixed1()) returns fixed1()\r\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\r\n     */\r\n    function abs(int256 x) public pure returns (int256) {\r\n        if (x >= 0) {\r\n            return x;\r\n        } else {\r\n            int256 result = -x;\r\n            assert (result > 0);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \r\n     * might overflow.\r\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\r\n     * @dev \r\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\r\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\r\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\r\n     * Test add(maxInt256(),maxInt256()) fails\r\n     * Test add(minInt256(),minInt256()) fails\r\n     */\r\n    function add(int256 x, int256 y) public pure returns (int256) {\r\n        int256 z = x + y;\r\n        if (x > 0 && y > 0) assert(z > x && z > y);\r\n        if (x < 0 && y < 0) assert(z < x && z < y);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @notice x-y. You can use add(x,-y) instead. \r\n     * @dev Tests covered by add(x,y)\r\n     */\r\n    function subtract(int256 x, int256 y) public pure returns (int256) {\r\n        return add(x,-y);\r\n    }\r\n\r\n    /**\r\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \r\n     * might overflow.\r\n     * @dev \r\n     * Test multiply(0,0) returns 0\r\n     * Test multiply(maxFixedMul(),0) returns 0\r\n     * Test multiply(0,maxFixedMul()) returns 0\r\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\r\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\r\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\r\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\r\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\r\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\r\n     */\r\n    function multiply(int256 x, int256 y) public pure returns (int256) {\r\n        if (x == 0 || y == 0) return 0;\r\n        if (y == fixed1()) return x;\r\n        if (x == fixed1()) return y;\r\n\r\n        // Separate into integer and fractional parts\r\n        // x = x1 + x2, y = y1 + y2\r\n        int256 x1 = integer(x) / fixed1();\r\n        int256 x2 = fractional(x);\r\n        int256 y1 = integer(y) / fixed1();\r\n        int256 y2 = fractional(y);\r\n        \r\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\r\n        int256 x1y1 = x1 * y1;\r\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\r\n        \r\n        // x1y1 needs to be multiplied back by fixed1\r\n        // solium-disable-next-line mixedcase\r\n        int256 fixed_x1y1 = x1y1 * fixed1();\r\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\r\n        x1y1 = fixed_x1y1;\r\n\r\n        int256 x2y1 = x2 * y1;\r\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\r\n\r\n        int256 x1y2 = x1 * y2;\r\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\r\n\r\n        x2 = x2 / mulPrecision();\r\n        y2 = y2 / mulPrecision();\r\n        int256 x2y2 = x2 * y2;\r\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\r\n\r\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\r\n        int256 result = x1y1;\r\n        result = add(result, x2y1); // Add checks for overflow\r\n        result = add(result, x1y2); // Add checks for overflow\r\n        result = add(result, x2y2); // Add checks for overflow\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @notice 1/x\r\n     * @dev \r\n     * Test reciprocal(0) fails\r\n     * Test reciprocal(fixed1()) returns fixed1()\r\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\r\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\r\n     */\r\n    function reciprocal(int256 x) public pure returns (int256) {\r\n        assert(x != 0);\r\n        return (fixed1()*fixed1()) / x; // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \r\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\r\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\r\n     * @dev \r\n     * Test divide(fixed1(),0) fails\r\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,1) throws\r\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\r\n     */\r\n    function divide(int256 x, int256 y) public pure returns (int256) {\r\n        if (y == fixed1()) return x;\r\n        assert(y != 0);\r\n        assert(y <= maxFixedDivisor());\r\n        return multiply(x, reciprocal(y));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title The Pool contract for PoolTogether\r\n * @author Brendan Asselstine\r\n * @notice This contract implements a \"lossless pool\".  The pool exists in three states: open, locked, and complete.\r\n * The pool begins in the open state during which users can buy any number of tickets.  The more tickets they purchase, the greater their chances of winning.\r\n * After the lockStartBlock the owner may lock the pool.  The pool transfers the pool of ticket money into the Compound Finance money market and no more tickets are sold.\r\n * After the lockEndBlock the owner may unlock the pool.  The pool will withdraw the ticket money from the money market, plus earned interest, back into the contract.  The fee will be sent to\r\n * the owner, and users will be able to withdraw their ticket money and winnings, if any.\r\n * @dev All monetary values are stored internally as fixed point 24.\r\n */\r\ncontract Pool is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * Emitted when \"tickets\" have been purchased.\r\n   * @param sender The purchaser of the tickets\r\n   * @param count The number of tickets purchased\r\n   * @param totalPrice The total cost of the tickets\r\n   */\r\n  event BoughtTickets(address indexed sender, int256 count, uint256 totalPrice);\r\n\r\n  /**\r\n   * Emitted when a user withdraws from the pool.\r\n   * @param sender The user that is withdrawing from the pool\r\n   * @param amount The amount that the user withdrew\r\n   */\r\n  event Withdrawn(address indexed sender, int256 amount);\r\n\r\n  /**\r\n   * Emitted when the pool is locked.\r\n   */\r\n  event PoolLocked();\r\n\r\n  /**\r\n   * Emitted when the pool is unlocked.\r\n   */\r\n  event PoolUnlocked();\r\n\r\n  /**\r\n   * Emitted when the pool is complete\r\n   */\r\n  event PoolComplete(address indexed winner);\r\n\r\n  enum State {\r\n    OPEN,\r\n    LOCKED,\r\n    UNLOCKED,\r\n    COMPLETE\r\n  }\r\n\r\n  struct Entry {\r\n    address addr;\r\n    int256 amount;\r\n    uint256 ticketCount;\r\n    int256 withdrawnNonFixed;\r\n  }\r\n\r\n  bytes32 public constant SUM_TREE_KEY = \"PoolPool\";\r\n\r\n  int256 private totalAmount; // fixed point 24\r\n  uint256 private lockStartBlock;\r\n  uint256 private lockEndBlock;\r\n  bytes32 private secretHash;\r\n  bytes32 private secret;\r\n  State public state;\r\n  int256 private finalAmount; //fixed point 24\r\n  mapping (address => Entry) private entries;\r\n  uint256 public entryCount;\r\n  ICErc20 public moneyMarket;\r\n  IERC20 public token;\r\n  int256 private ticketPrice; //fixed point 24\r\n  int256 private feeFraction; //fixed point 24\r\n  bool private ownerHasWithdrawn;\r\n  bool public allowLockAnytime;\r\n\r\n  using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\r\n  SortitionSumTreeFactory.SortitionSumTrees internal sortitionSumTrees;\r\n\r\n  /**\r\n   * @notice Creates a new Pool.\r\n   * @param _moneyMarket The Compound money market to supply tokens to.\r\n   * @param _token The ERC20 token to be used.\r\n   * @param _lockStartBlock The block number on or after which the deposit can be made to Compound\r\n   * @param _lockEndBlock The block number on or after which the Compound supply can be withdrawn\r\n   * @param _ticketPrice The price of each ticket (fixed point 18)\r\n   * @param _feeFractionFixedPoint18 The fraction of the winnings going to the owner (fixed point 18)\r\n   */\r\n  constructor (\r\n    ICErc20 _moneyMarket,\r\n    IERC20 _token,\r\n    uint256 _lockStartBlock,\r\n    uint256 _lockEndBlock,\r\n    int256 _ticketPrice,\r\n    int256 _feeFractionFixedPoint18,\r\n    bool _allowLockAnytime\r\n  ) public {\r\n    require(_lockEndBlock > _lockStartBlock, \"lock end block is not after start block\");\r\n    require(address(_moneyMarket) != address(0), \"money market address cannot be zero\");\r\n    require(address(_token) != address(0), \"token address cannot be zero\");\r\n    require(_ticketPrice > 0, \"ticket price must be greater than zero\");\r\n    require(_feeFractionFixedPoint18 >= 0, \"fee must be zero or greater\");\r\n    require(_feeFractionFixedPoint18 <= 1000000000000000000, \"fee fraction must be less than 1\");\r\n    feeFraction = FixidityLib.newFixed(_feeFractionFixedPoint18, uint8(18));\r\n    ticketPrice = FixidityLib.newFixed(_ticketPrice);\r\n    sortitionSumTrees.createTree(SUM_TREE_KEY, 4);\r\n\r\n    state = State.OPEN;\r\n    moneyMarket = _moneyMarket;\r\n    token = _token;\r\n    lockStartBlock = _lockStartBlock;\r\n    lockEndBlock = _lockEndBlock;\r\n    allowLockAnytime = _allowLockAnytime;\r\n  }\r\n\r\n  /**\r\n   * @notice Buys a pool ticket.  Only possible while the Pool is in the \"open\" state.  The\r\n   * user can buy any number of tickets.  Each ticket is a chance at winning.\r\n   * @param _countNonFixed The number of tickets the user wishes to buy.\r\n   */\r\n  function buyTickets (int256 _countNonFixed) public requireOpen {\r\n    require(_countNonFixed > 0, \"number of tickets is less than or equal to zero\");\r\n    int256 count = FixidityLib.newFixed(_countNonFixed);\r\n    int256 totalDeposit = FixidityLib.multiply(ticketPrice, count);\r\n    uint256 totalDepositNonFixed = uint256(FixidityLib.fromFixed(totalDeposit));\r\n    require(token.transferFrom(msg.sender, address(this), totalDepositNonFixed), \"token transfer failed\");\r\n\r\n    if (_hasEntry(msg.sender)) {\r\n      entries[msg.sender].amount = FixidityLib.add(entries[msg.sender].amount, totalDeposit);\r\n      entries[msg.sender].ticketCount = entries[msg.sender].ticketCount.add(uint256(_countNonFixed));\r\n    } else {\r\n      entries[msg.sender] = Entry(\r\n        msg.sender,\r\n        totalDeposit,\r\n        uint256(_countNonFixed),\r\n        0\r\n      );\r\n      entryCount = entryCount.add(1);\r\n    }\r\n\r\n    int256 amountNonFixed = FixidityLib.fromFixed(entries[msg.sender].amount);\r\n    sortitionSumTrees.set(SUM_TREE_KEY, uint256(amountNonFixed), bytes32(uint256(msg.sender)));\r\n\r\n    totalAmount = FixidityLib.add(totalAmount, totalDeposit);\r\n\r\n    // the total amount cannot exceed the max pool size\r\n    require(totalAmount <= maxPoolSizeFixedPoint24(FixidityLib.maxFixedDiv()), \"pool size exceeds maximum\");\r\n\r\n    emit BoughtTickets(msg.sender, _countNonFixed, totalDepositNonFixed);\r\n  }\r\n\r\n  /**\r\n   * @notice Pools the deposits and supplies them to Compound.\r\n   * Can only be called by the owner when the pool is open.\r\n   * Fires the PoolLocked event.\r\n   */\r\n  function lock(bytes32 _secretHash) external requireOpen onlyOwner {\r\n    if (allowLockAnytime) {\r\n      lockStartBlock = block.number;\r\n    } else {\r\n      require(block.number >= lockStartBlock, \"pool can only be locked on or after lock start block\");\r\n    }\r\n    require(_secretHash != 0, \"secret hash must be defined\");\r\n    secretHash = _secretHash;\r\n    state = State.LOCKED;\r\n\r\n    if (totalAmount > 0) {\r\n      uint256 totalAmountNonFixed = uint256(FixidityLib.fromFixed(totalAmount));\r\n      require(token.approve(address(moneyMarket), totalAmountNonFixed), \"could not approve money market spend\");\r\n      require(moneyMarket.mint(totalAmountNonFixed) == 0, \"could not supply money market\");\r\n    }\r\n\r\n    emit PoolLocked();\r\n  }\r\n\r\n  function unlock() public requireLocked {\r\n    if (allowLockAnytime && msg.sender == owner()) {\r\n      lockEndBlock = block.number;\r\n    } else {\r\n      require(lockEndBlock < block.number, \"pool cannot be unlocked yet\");\r\n    }\r\n\r\n    uint256 balance = moneyMarket.balanceOfUnderlying(address(this));\r\n\r\n    if (balance > 0) {\r\n      require(moneyMarket.redeemUnderlying(balance) == 0, \"could not redeem from compound\");\r\n      finalAmount = FixidityLib.newFixed(int256(balance));\r\n    }\r\n\r\n    state = State.UNLOCKED;\r\n\r\n    emit PoolUnlocked();\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraws the deposit from Compound and selects a winner.\r\n   * Can only be called by the owner after the lock end block.\r\n   * Fires the PoolUnlocked event.\r\n   */\r\n  function complete(bytes32 _secret) public onlyOwner {\r\n    if (state == State.LOCKED) {\r\n      unlock();\r\n    }\r\n    require(state == State.UNLOCKED, \"state must be unlocked\");\r\n    require(keccak256(abi.encodePacked(_secret)) == secretHash, \"secret does not match\");\r\n    secret = _secret;\r\n    state = State.COMPLETE;\r\n\r\n    uint256 fee = feeAmount();\r\n    if (fee > 0) {\r\n      require(token.transfer(owner(), fee), \"could not transfer winnings\");\r\n    }\r\n\r\n    emit PoolComplete(winnerAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers a users deposit, and potential winnings, back to them.\r\n   * The Pool must be unlocked.\r\n   * The user must have deposited funds.  Fires the Withdrawn event.\r\n   */\r\n  function withdraw() public {\r\n    require(_hasEntry(msg.sender), \"entrant exists\");\r\n    require(state == State.UNLOCKED || state == State.COMPLETE, \"pool has not been unlocked\");\r\n    Entry storage entry = entries[msg.sender];\r\n    int256 remainingBalanceNonFixed = balanceOf(msg.sender);\r\n    require(remainingBalanceNonFixed > 0, \"entrant has already withdrawn\");\r\n    entry.withdrawnNonFixed = entry.withdrawnNonFixed + remainingBalanceNonFixed;\r\n\r\n    emit Withdrawn(msg.sender, remainingBalanceNonFixed);\r\n\r\n    require(token.transfer(msg.sender, uint256(remainingBalanceNonFixed)), \"could not transfer winnings\");\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates a user's winnings.  This is their deposit plus their winnings, if any.\r\n   * @param _addr The address of the user\r\n   */\r\n  function winnings(address _addr) public view returns (int256) {\r\n    Entry storage entry = entries[_addr];\r\n    if (entry.addr == address(0)) { //if does not have an entry\r\n      return 0;\r\n    }\r\n    int256 winningTotal = entry.amount;\r\n    if (state == State.COMPLETE && _addr == winnerAddress()) {\r\n      winningTotal = FixidityLib.add(winningTotal, netWinningsFixedPoint24());\r\n    }\r\n    return FixidityLib.fromFixed(winningTotal);\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates a user's remaining balance.  This is their winnings less how much they've withdrawn.\r\n   * @return The users's current balance.\r\n   */\r\n  function balanceOf(address _addr) public view returns (int256) {\r\n    Entry storage entry = entries[_addr];\r\n    int256 winningTotalNonFixed = winnings(_addr);\r\n    return winningTotalNonFixed - entry.withdrawnNonFixed;\r\n  }\r\n\r\n  /**\r\n   * @notice Selects and returns the winner's address\r\n   * @return The winner's address\r\n   */\r\n  function winnerAddress() public view returns (address) {\r\n    if (totalAmount > 0) {\r\n      return address(uint256(sortitionSumTrees.draw(SUM_TREE_KEY, randomToken())));\r\n    } else {\r\n      return address(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the total interest on the pool less the fee as a whole number\r\n   * @return The total interest on the pool less the fee as a whole number\r\n   */\r\n  function netWinnings() public view returns (int256) {\r\n    return FixidityLib.fromFixed(netWinningsFixedPoint24());\r\n  }\r\n\r\n  /**\r\n   * @notice Computes the total interest earned on the pool less the fee as a fixed point 24.\r\n   * @return The total interest earned on the pool less the fee as a fixed point 24.\r\n   */\r\n  function netWinningsFixedPoint24() internal view returns (int256) {\r\n    return grossWinningsFixedPoint24() - feeAmountFixedPoint24();\r\n  }\r\n\r\n  /**\r\n   * @notice Computes the total interest earned on the pool as a fixed point 24.\r\n   * This is what the winner will earn once the pool is unlocked.\r\n   * @return The total interest earned on the pool as a fixed point 24.\r\n   */\r\n  function grossWinningsFixedPoint24() internal view returns (int256) {\r\n    return FixidityLib.subtract(finalAmount, totalAmount);\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the size of the fee based on the gross winnings\r\n   * @return The fee for the pool to be transferred to the owner\r\n   */\r\n  function feeAmount() public view returns (uint256) {\r\n    return uint256(FixidityLib.fromFixed(feeAmountFixedPoint24()));\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the fee for the pool by multiplying the gross winnings by the fee fraction.\r\n   * @return The fee for the pool as a fixed point 24\r\n   */\r\n  function feeAmountFixedPoint24() internal view returns (int256) {\r\n    return FixidityLib.multiply(grossWinningsFixedPoint24(), feeFraction);\r\n  }\r\n\r\n  /**\r\n   * @notice Selects a random number in the range from [0, total tokens deposited)\r\n   * @return If the current block is before the end it returns 0, otherwise it returns the random number.\r\n   */\r\n  function randomToken() public view returns (uint256) {\r\n    if (block.number <= lockEndBlock) {\r\n      return 0;\r\n    } else {\r\n      return _selectRandom(uint256(FixidityLib.fromFixed(totalAmount)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Selects a random number in the range [0, total)\r\n   * @param total The upper bound for the random number\r\n   * @return The random number\r\n   */\r\n  function _selectRandom(uint256 total) internal view returns (uint256) {\r\n    return UniformRandomNumber.uniform(_entropy(), total);\r\n  }\r\n\r\n  /**\r\n   * @notice Computes the entropy used to generate the random number.\r\n   * The blockhash of the lock end block is XOR'd with the secret revealed by the owner.\r\n   * @return The computed entropy value\r\n   */\r\n  function _entropy() internal view returns (uint256) {\r\n    return uint256(blockhash(lockEndBlock) ^ secret);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves information about the pool.\r\n   * @return A tuple containing:\r\n   *    entryTotal (the total of all deposits)\r\n   *    startBlock (the block after which the pool can be locked)\r\n   *    endBlock (the block after which the pool can be unlocked)\r\n   *    poolState (either OPEN, LOCKED, COMPLETE)\r\n   *    winner (the address of the winner)\r\n   *    supplyBalanceTotal (the total deposits plus any interest from Compound)\r\n   *    ticketCost (the cost of each ticket in DAI)\r\n   *    participantCount (the number of unique purchasers of tickets)\r\n   *    maxPoolSize (the maximum theoretical size of the pool to prevent overflow)\r\n   *    estimatedInterestFixedPoint18 (the estimated total interest percent for this pool)\r\n   *    hashOfSecret (the hash of the secret the owner submitted upon locking)\r\n   */\r\n  function getInfo() public view returns (\r\n    int256 entryTotal,\r\n    uint256 startBlock,\r\n    uint256 endBlock,\r\n    State poolState,\r\n    address winner,\r\n    int256 supplyBalanceTotal,\r\n    int256 ticketCost,\r\n    uint256 participantCount,\r\n    int256 maxPoolSize,\r\n    int256 estimatedInterestFixedPoint18,\r\n    bytes32 hashOfSecret\r\n  ) {\r\n    address winAddr = address(0);\r\n    if (state == State.COMPLETE) {\r\n      winAddr = winnerAddress();\r\n    }\r\n    return (\r\n      FixidityLib.fromFixed(totalAmount),\r\n      lockStartBlock,\r\n      lockEndBlock,\r\n      state,\r\n      winAddr,\r\n      FixidityLib.fromFixed(finalAmount),\r\n      FixidityLib.fromFixed(ticketPrice),\r\n      entryCount,\r\n      FixidityLib.fromFixed(maxPoolSizeFixedPoint24(FixidityLib.maxFixedDiv())),\r\n      FixidityLib.fromFixed(currentInterestFractionFixedPoint24(), uint8(18)),\r\n      secretHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves information about a user's entry in the Pool.\r\n   * @return Returns a tuple containing:\r\n   *    addr (the address of the user)\r\n   *    amount (the amount they deposited)\r\n   *    ticketCount (the number of tickets they have bought)\r\n   *    withdrawn (the amount they have withdrawn)\r\n   */\r\n  function getEntry(address _addr) public view returns (\r\n    address addr,\r\n    int256 amount,\r\n    uint256 ticketCount,\r\n    int256 withdrawn\r\n  ) {\r\n    Entry storage entry = entries[_addr];\r\n    return (\r\n      entry.addr,\r\n      FixidityLib.fromFixed(entry.amount),\r\n      entry.ticketCount,\r\n      entry.withdrawnNonFixed\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Calculates the maximum pool size so that it doesn't overflow after earning interest\r\n   * @dev poolSize = totalDeposits + totalDeposits * interest => totalDeposits = poolSize / (1 + interest)\r\n   * @return The maximum size of the pool to be deposited into the money market\r\n   */\r\n  function maxPoolSizeFixedPoint24(int256 _maxValueFixedPoint24) public view returns (int256) {\r\n    /// Double the interest rate in case it increases over the lock period.  Somewhat arbitrarily.\r\n    int256 interestFraction = FixidityLib.multiply(currentInterestFractionFixedPoint24(), FixidityLib.newFixed(2));\r\n    return FixidityLib.divide(_maxValueFixedPoint24, FixidityLib.add(interestFraction, FixidityLib.newFixed(1)));\r\n  }\r\n\r\n  /**\r\n   * @notice Estimates the current effective interest rate using the money market's current supplyRateMantissa and the lock duration in blocks.\r\n   * @return The current estimated effective interest rate\r\n   */\r\n  function currentInterestFractionFixedPoint24() public view returns (int256) {\r\n    int256 blockDuration = int256(lockEndBlock - lockStartBlock);\r\n    int256 supplyRateMantissaFixedPoint24 = FixidityLib.newFixed(int256(supplyRateMantissa()), uint8(18));\r\n    return FixidityLib.multiply(supplyRateMantissaFixedPoint24, FixidityLib.newFixed(blockDuration));\r\n  }\r\n\r\n  /**\r\n   * @notice Extracts the supplyRateMantissa value from the money market contract\r\n   * @return The money market supply rate per block\r\n   */\r\n  function supplyRateMantissa() public view returns (uint256) {\r\n    return moneyMarket.supplyRatePerBlock();\r\n  }\r\n\r\n  /**\r\n   * @notice Determines whether a given address has bought tickets\r\n   * @param _addr The given address\r\n   * @return Returns true if the given address bought tickets, false otherwise.\r\n   */\r\n  function _hasEntry(address _addr) internal view returns (bool) {\r\n    return entries[_addr].addr == _addr;\r\n  }\r\n\r\n  modifier requireOpen() {\r\n    require(state == State.OPEN, \"state is not open\");\r\n    _;\r\n  }\r\n\r\n  modifier requireLocked() {\r\n    require(state == State.LOCKED, \"state is not locked\");\r\n    _;\r\n  }\r\n\r\n  modifier requireComplete() {\r\n    require(state == State.COMPLETE, \"pool is not complete\");\r\n    require(block.number > lockEndBlock, \"block is before lock end period\");\r\n    _;\r\n  }\r\n}"}}}