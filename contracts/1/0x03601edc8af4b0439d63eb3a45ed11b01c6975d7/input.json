{
  "language": "Solidity",
  "sources": {
    "contracts/modules/DToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"../BaseLogic.sol\";\n\n\n/// @notice Tokenised representation of debts\ncontract DToken is BaseLogic {\n    constructor(bytes32 moduleGitCommit_) BaseLogic(MODULEID__DTOKEN, moduleGitCommit_) {}\n\n    function CALLER() private view returns (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) {\n        (msgSender, proxyAddr) = unpackTrailingParams();\n        address eTokenAddress = dTokenLookup[proxyAddr];\n        require(eTokenAddress != address(0), \"e/unrecognized-dtoken-caller\");\n        assetStorage = eTokenLookup[eTokenAddress];\n        underlying = assetStorage.underlying;\n    }\n\n\n    // Events\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\n    // External methods\n\n    /// @notice Debt token name, ie \"Euler Debt: DAI\"\n    function name() external view returns (string memory) {\n        (address underlying,,,) = CALLER();\n        return string(abi.encodePacked(\"Euler Debt: \", IERC20(underlying).name()));\n    }\n\n    /// @notice Debt token symbol, ie \"dDAI\"\n    function symbol() external view returns (string memory) {\n        (address underlying,,,) = CALLER();\n        return string(abi.encodePacked(\"d\", IERC20(underlying).symbol()));\n    }\n\n    /// @notice Decimals, always normalised to 18.\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\n    function totalSupply() external view returns (uint) {\n        (address underlying, AssetStorage storage assetStorage,,) = CALLER();\n        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);\n\n        return assetCache.totalBorrows / INTERNAL_DEBT_PRECISION / assetCache.underlyingDecimalsScaler;\n    }\n\n    /// @notice Sum of all outstanding debts, in underlying units with extra precision (increases as interest is accrued)\n    function totalSupplyExact() external view returns (uint) {\n        (address underlying, AssetStorage storage assetStorage,,) = CALLER();\n        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);\n\n        return assetCache.totalBorrows;\n    }\n\n\n    /// @notice Debt owed by a particular account, in underlying units\n    function balanceOf(address account) external view returns (uint) {\n        (address underlying, AssetStorage storage assetStorage,,) = CALLER();\n        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);\n\n        return getCurrentOwed(assetStorage, assetCache, account) / assetCache.underlyingDecimalsScaler;\n    }\n\n    /// @notice Debt owed by a particular account, in underlying units with extra precision\n    function balanceOfExact(address account) external view returns (uint) {\n        (address underlying, AssetStorage storage assetStorage,,) = CALLER();\n        AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);\n\n        return getCurrentOwedExact(assetStorage, assetCache, account, assetStorage.users[account].owed);\n    }\n\n\n    /// @notice Transfer underlying tokens from the Euler pool to the sender, and increase sender's dTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for all available tokens)\n    function borrow(uint subAccountId, uint amount) external nonReentrant {\n        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();\n        address account = getSubAccount(msgSender, subAccountId);\n\n        updateAverageLiquidity(account);\n        emit RequestBorrow(account, amount);\n\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\n\n        if (amount == type(uint).max) {\n            amount = assetCache.poolSize;\n        } else {\n            amount = decodeExternalAmount(assetCache, amount);\n        }\n\n        require(amount <= assetCache.poolSize, \"e/insufficient-tokens-available\");\n\n        pushTokens(assetCache, msgSender, amount);\n\n        increaseBorrow(assetStorage, assetCache, proxyAddr, account, amount);\n\n        checkLiquidity(account);\n        logAssetStatus(assetCache);\n    }\n\n    /// @notice Transfer underlying tokens from the sender to the Euler pool, and decrease sender's dTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full debt owed)\n    function repay(uint subAccountId, uint amount) external nonReentrant {\n        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();\n        address account = getSubAccount(msgSender, subAccountId);\n\n        updateAverageLiquidity(account);\n        emit RequestRepay(account, amount);\n\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\n\n        if (amount != type(uint).max) {\n            amount = decodeExternalAmount(assetCache, amount);\n        }\n\n        uint owed = getCurrentOwed(assetStorage, assetCache, account);\n        if (owed == 0) return;\n        if (amount > owed) amount = owed;\n\n        amount = pullTokens(assetCache, msgSender, amount);\n\n        decreaseBorrow(assetStorage, assetCache, proxyAddr, account, amount);\n\n        logAssetStatus(assetCache);\n    }\n\n\n    /// @notice Allow spender to send an amount of dTokens to a particular sub-account\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param spender Trusted address\n    /// @param amount Use max uint256 for \"infinite\" allowance\n    function approveDebt(uint subAccountId, address spender, uint amount) public reentrantOK returns (bool) {\n        (, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();\n        address account = getSubAccount(msgSender, subAccountId);\n\n        require(!isSubAccountOf(spender, account), \"e/self-approval\");\n\n        assetStorage.dTokenAllowance[account][spender] = amount;\n        emitViaProxy_Approval(proxyAddr, account, spender, amount);\n\n        return true;\n    }\n\n    /// @notice Retrieve the current debt allowance\n    /// @param holder Xor with the desired sub-account ID (if applicable)\n    /// @param spender Trusted address\n    function debtAllowance(address holder, address spender) external view returns (uint) {\n        (, AssetStorage storage assetStorage,,) = CALLER();\n\n        return assetStorage.dTokenAllowance[holder][spender];\n    }\n\n\n\n    /// @notice Transfer dTokens to another address (from sub-account 0)\n    /// @param to Xor with the desired sub-account ID (if applicable)\n    /// @param amount In underlying units. Use max uint256 for full balance.\n    function transfer(address to, uint amount) external returns (bool) {\n        return transferFrom(address(0), to, amount);\n    }\n\n    /// @notice Transfer dTokens from one address to another\n    /// @param from Xor with the desired sub-account ID (if applicable)\n    /// @param to This address must've approved the from address, or be a sub-account of msg.sender\n    /// @param amount In underlying. Use max uint256 for full balance.\n    function transferFrom(address from, address to, uint amount) public nonReentrant returns (bool) {\n        (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();\n        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);\n\n        if (from == address(0)) from = msgSender;\n        require(from != to, \"e/self-transfer\");\n\n        updateAverageLiquidity(from);\n        updateAverageLiquidity(to);\n        emit RequestTransferDToken(from, to, amount);\n\n        if (amount == type(uint).max) amount = getCurrentOwed(assetStorage, assetCache, from);\n        else amount = decodeExternalAmount(assetCache, amount);\n\n        if (amount == 0) return true;\n\n        if (!isSubAccountOf(msgSender, to) && assetStorage.dTokenAllowance[to][msgSender] != type(uint).max) {\n            require(assetStorage.dTokenAllowance[to][msgSender] >= amount, \"e/insufficient-debt-allowance\");\n            unchecked { assetStorage.dTokenAllowance[to][msgSender] -= amount; }\n            emitViaProxy_Approval(proxyAddr, to, msgSender, assetStorage.dTokenAllowance[to][msgSender]);\n        }\n\n        transferBorrow(assetStorage, assetCache, proxyAddr, from, to, amount);\n\n        checkLiquidity(to);\n        logAssetStatus(assetCache);\n\n        return true;\n    }\n}\n"
    },
    "contracts/BaseLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./BaseModule.sol\";\nimport \"./BaseIRM.sol\";\nimport \"./Interfaces.sol\";\nimport \"./Utils.sol\";\nimport \"./vendor/RPow.sol\";\nimport \"./IRiskManager.sol\";\n\n\nabstract contract BaseLogic is BaseModule {\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\n\n\n    // Account auth\n\n    function getSubAccount(address primary, uint subAccountId) internal pure returns (address) {\n        require(subAccountId < 256, \"e/sub-account-id-too-big\");\n        return address(uint160(primary) ^ uint160(subAccountId));\n    }\n\n    function isSubAccountOf(address primary, address subAccount) internal pure returns (bool) {\n        return (uint160(primary) | 0xFF) == (uint160(subAccount) | 0xFF);\n    }\n\n\n\n    // Entered markets array\n\n    function getEnteredMarketsArray(address account) internal view returns (address[] memory) {\n        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;\n        address firstMarketEntered = accountLookup[account].firstMarketEntered;\n\n        address[] memory output = new address[](numMarketsEntered);\n        if (numMarketsEntered == 0) return output;\n\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\n\n        output[0] = firstMarketEntered;\n\n        for (uint i = 1; i < numMarketsEntered; ++i) {\n            output[i] = markets[i];\n        }\n\n        return output;\n    }\n\n    function isEnteredInMarket(address account, address underlying) internal view returns (bool) {\n        uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;\n        address firstMarketEntered = accountLookup[account].firstMarketEntered;\n\n        if (numMarketsEntered == 0) return false;\n        if (firstMarketEntered == underlying) return true;\n\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\n\n        for (uint i = 1; i < numMarketsEntered; ++i) {\n            if (markets[i] == underlying) return true;\n        }\n\n        return false;\n    }\n\n    function doEnterMarket(address account, address underlying) internal {\n        AccountStorage storage accountStorage = accountLookup[account];\n\n        uint32 numMarketsEntered = accountStorage.numMarketsEntered;\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\n\n        if (numMarketsEntered != 0) {\n            if (accountStorage.firstMarketEntered == underlying) return; // already entered\n            for (uint i = 1; i < numMarketsEntered; i++) {\n                if (markets[i] == underlying) return; // already entered\n            }\n        }\n\n        require(numMarketsEntered < MAX_ENTERED_MARKETS, \"e/too-many-entered-markets\");\n\n        if (numMarketsEntered == 0) accountStorage.firstMarketEntered = underlying;\n        else markets[numMarketsEntered] = underlying;\n\n        accountStorage.numMarketsEntered = numMarketsEntered + 1;\n\n        emit EnterMarket(underlying, account);\n    }\n\n    // Liquidity check must be done by caller after calling this\n\n    function doExitMarket(address account, address underlying) internal {\n        AccountStorage storage accountStorage = accountLookup[account];\n\n        uint32 numMarketsEntered = accountStorage.numMarketsEntered;\n        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];\n        uint searchIndex = type(uint).max;\n\n        if (numMarketsEntered == 0) return; // already exited\n\n        if (accountStorage.firstMarketEntered == underlying) {\n            searchIndex = 0;\n        } else {\n            for (uint i = 1; i < numMarketsEntered; i++) {\n                if (markets[i] == underlying) {\n                    searchIndex = i;\n                    break;\n                }\n            }\n\n            if (searchIndex == type(uint).max) return; // already exited\n        }\n\n        uint lastMarketIndex = numMarketsEntered - 1;\n\n        if (searchIndex != lastMarketIndex) {\n            if (searchIndex == 0) accountStorage.firstMarketEntered = markets[lastMarketIndex];\n            else markets[searchIndex] = markets[lastMarketIndex];\n        }\n\n        accountStorage.numMarketsEntered = uint32(lastMarketIndex);\n\n        if (lastMarketIndex != 0) markets[lastMarketIndex] = address(0); // zero out for storage refund\n\n        emit ExitMarket(underlying, account);\n    }\n\n\n\n    // AssetConfig\n\n    function resolveAssetConfig(address underlying) internal view returns (AssetConfig memory) {\n        AssetConfig memory config = underlyingLookup[underlying];\n        require(config.eTokenAddress != address(0), \"e/market-not-activated\");\n\n        if (config.borrowFactor == type(uint32).max) config.borrowFactor = DEFAULT_BORROW_FACTOR;\n        if (config.twapWindow == type(uint24).max) config.twapWindow = DEFAULT_TWAP_WINDOW_SECONDS;\n\n        return config;\n    }\n\n\n    // AssetCache\n\n    struct AssetCache {\n        address underlying;\n\n        uint112 totalBalances;\n        uint144 totalBorrows;\n\n        uint96 reserveBalance;\n\n        uint interestAccumulator;\n\n        uint40 lastInterestAccumulatorUpdate;\n        uint8 underlyingDecimals;\n        uint32 interestRateModel;\n        int96 interestRate;\n        uint32 reserveFee;\n        uint16 pricingType;\n        uint32 pricingParameters;\n\n        uint poolSize; // result of calling balanceOf on underlying (in external units)\n\n        uint underlyingDecimalsScaler;\n        uint maxExternalAmount;\n    }\n\n    function initAssetCache(address underlying, AssetStorage storage assetStorage, AssetCache memory assetCache) internal view returns (bool dirty) {\n        dirty = false;\n\n        assetCache.underlying = underlying;\n\n        // Storage loads\n\n        assetCache.lastInterestAccumulatorUpdate = assetStorage.lastInterestAccumulatorUpdate;\n        uint8 underlyingDecimals = assetCache.underlyingDecimals = assetStorage.underlyingDecimals;\n        assetCache.interestRateModel = assetStorage.interestRateModel;\n        assetCache.interestRate = assetStorage.interestRate;\n        assetCache.reserveFee = assetStorage.reserveFee;\n        assetCache.pricingType = assetStorage.pricingType;\n        assetCache.pricingParameters = assetStorage.pricingParameters;\n\n        assetCache.reserveBalance = assetStorage.reserveBalance;\n\n        assetCache.totalBalances = assetStorage.totalBalances;\n        assetCache.totalBorrows = assetStorage.totalBorrows;\n\n        assetCache.interestAccumulator = assetStorage.interestAccumulator;\n\n        // Derived state\n\n        unchecked {\n            assetCache.underlyingDecimalsScaler = 10**(18 - underlyingDecimals);\n            assetCache.maxExternalAmount = MAX_SANE_AMOUNT / assetCache.underlyingDecimalsScaler;\n        }\n\n        uint poolSize = callBalanceOf(assetCache, address(this));\n        if (poolSize <= assetCache.maxExternalAmount) {\n            unchecked { assetCache.poolSize = poolSize * assetCache.underlyingDecimalsScaler; }\n        } else {\n            assetCache.poolSize = 0;\n        }\n\n        // Update interest accumulator and reserves\n\n        if (block.timestamp != assetCache.lastInterestAccumulatorUpdate) {\n            dirty = true;\n\n            uint deltaT = block.timestamp - assetCache.lastInterestAccumulatorUpdate;\n\n            // Compute new values\n\n            uint newInterestAccumulator = (RPow.rpow(uint(int(assetCache.interestRate) + 1e27), deltaT, 1e27) * assetCache.interestAccumulator) / 1e27;\n\n            uint newTotalBorrows = assetCache.totalBorrows * newInterestAccumulator / assetCache.interestAccumulator;\n\n            uint newReserveBalance = assetCache.reserveBalance;\n            uint newTotalBalances = assetCache.totalBalances;\n\n            uint feeAmount = (newTotalBorrows - assetCache.totalBorrows)\n                               * (assetCache.reserveFee == type(uint32).max ? DEFAULT_RESERVE_FEE : assetCache.reserveFee)\n                               / (RESERVE_FEE_SCALE * INTERNAL_DEBT_PRECISION);\n\n            if (feeAmount != 0) {\n                uint poolAssets = assetCache.poolSize + (newTotalBorrows / INTERNAL_DEBT_PRECISION);\n                newTotalBalances = poolAssets * newTotalBalances / (poolAssets - feeAmount);\n                newReserveBalance += newTotalBalances - assetCache.totalBalances;\n            }\n\n            // Store new values in assetCache, only if no overflows will occur\n\n            if (newTotalBalances <= MAX_SANE_AMOUNT && newTotalBorrows <= MAX_SANE_DEBT_AMOUNT) {\n                assetCache.totalBorrows = encodeDebtAmount(newTotalBorrows);\n                assetCache.interestAccumulator = newInterestAccumulator;\n                assetCache.lastInterestAccumulatorUpdate = uint40(block.timestamp);\n\n                if (newTotalBalances != assetCache.totalBalances) {\n                    assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);\n                    assetCache.totalBalances = encodeAmount(newTotalBalances);\n                }\n            }\n        }\n    }\n\n    function loadAssetCache(address underlying, AssetStorage storage assetStorage) internal returns (AssetCache memory assetCache) {\n        if (initAssetCache(underlying, assetStorage, assetCache)) {\n            assetStorage.lastInterestAccumulatorUpdate = assetCache.lastInterestAccumulatorUpdate;\n\n            assetStorage.underlying = assetCache.underlying; // avoid an SLOAD of this slot\n            assetStorage.reserveBalance = assetCache.reserveBalance;\n\n            assetStorage.totalBalances = assetCache.totalBalances;\n            assetStorage.totalBorrows = assetCache.totalBorrows;\n\n            assetStorage.interestAccumulator = assetCache.interestAccumulator;\n        }\n    }\n\n    function loadAssetCacheRO(address underlying, AssetStorage storage assetStorage) internal view returns (AssetCache memory assetCache) {\n        initAssetCache(underlying, assetStorage, assetCache);\n    }\n\n\n\n    // Utils\n\n    function decodeExternalAmount(AssetCache memory assetCache, uint externalAmount) internal pure returns (uint scaledAmount) {\n        require(externalAmount <= assetCache.maxExternalAmount, \"e/amount-too-large\");\n        unchecked { scaledAmount = externalAmount * assetCache.underlyingDecimalsScaler; }\n    }\n\n    function encodeAmount(uint amount) internal pure returns (uint112) {\n        require(amount <= MAX_SANE_AMOUNT, \"e/amount-too-large-to-encode\");\n        return uint112(amount);\n    }\n\n    function encodeSmallAmount(uint amount) internal pure returns (uint96) {\n        require(amount <= MAX_SANE_SMALL_AMOUNT, \"e/small-amount-too-large-to-encode\");\n        return uint96(amount);\n    }\n\n    function encodeDebtAmount(uint amount) internal pure returns (uint144) {\n        require(amount <= MAX_SANE_DEBT_AMOUNT, \"e/debt-amount-too-large-to-encode\");\n        return uint144(amount);\n    }\n\n    function computeExchangeRate(AssetCache memory assetCache) private pure returns (uint) {\n        if (assetCache.totalBalances == 0) return 1e18;\n        return (assetCache.poolSize + (assetCache.totalBorrows / INTERNAL_DEBT_PRECISION)) * 1e18 / assetCache.totalBalances;\n    }\n\n    function underlyingAmountToBalance(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\n        uint exchangeRate = computeExchangeRate(assetCache);\n        return amount * 1e18 / exchangeRate;\n    }\n\n    function underlyingAmountToBalanceRoundUp(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\n        uint exchangeRate = computeExchangeRate(assetCache);\n        return (amount * 1e18 + (exchangeRate - 1)) / exchangeRate;\n    }\n\n    function balanceToUnderlyingAmount(AssetCache memory assetCache, uint amount) internal pure returns (uint) {\n        uint exchangeRate = computeExchangeRate(assetCache);\n        return amount * exchangeRate / 1e18;\n    }\n\n    function callBalanceOf(AssetCache memory assetCache, address account) internal view FREEMEM returns (uint) {\n        // We set a gas limit so that a malicious token can't eat up all gas and cause a liquidity check to fail.\n\n        (bool success, bytes memory data) = assetCache.underlying.staticcall{gas: 20000}(abi.encodeWithSelector(IERC20.balanceOf.selector, account));\n\n        // If token's balanceOf() call fails for any reason, return 0. This prevents malicious tokens from causing liquidity checks to fail.\n        // If the contract doesn't exist (maybe because selfdestructed), then data.length will be 0 and we will return 0.\n        // Data length > 32 is allowed because some legitimate tokens append extra data that can be safely ignored.\n\n        if (!success || data.length < 32) return 0;\n\n        return abi.decode(data, (uint256));\n    }\n\n    function updateInterestRate(AssetStorage storage assetStorage, AssetCache memory assetCache) internal {\n        uint32 utilisation;\n\n        {\n            uint totalBorrows = assetCache.totalBorrows / INTERNAL_DEBT_PRECISION;\n            uint poolAssets = assetCache.poolSize + totalBorrows;\n            if (poolAssets == 0) utilisation = 0; // empty pool arbitrarily given utilisation of 0\n            else utilisation = uint32(totalBorrows * (uint(type(uint32).max) * 1e18) / poolAssets / 1e18);\n        }\n\n        bytes memory result = callInternalModule(assetCache.interestRateModel,\n                                                 abi.encodeWithSelector(BaseIRM.computeInterestRate.selector, assetCache.underlying, utilisation));\n\n        (int96 newInterestRate) = abi.decode(result, (int96));\n\n        assetStorage.interestRate = assetCache.interestRate = newInterestRate;\n    }\n\n    function logAssetStatus(AssetCache memory a) internal {\n        emit AssetStatus(a.underlying, a.totalBalances, a.totalBorrows / INTERNAL_DEBT_PRECISION, a.reserveBalance, a.poolSize, a.interestAccumulator, a.interestRate, block.timestamp);\n    }\n\n\n\n    // Balances\n\n    function increaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {\n        assetStorage.users[account].balance = encodeAmount(assetStorage.users[account].balance + amount);\n\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(uint(assetCache.totalBalances) + amount);\n\n        updateInterestRate(assetStorage, assetCache);\n\n        emit Deposit(assetCache.underlying, account, amount);\n        emitViaProxy_Transfer(eTokenAddress, address(0), account, amount);\n    }\n\n    function decreaseBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address account, uint amount) internal {\n        uint origBalance = assetStorage.users[account].balance;\n        require(origBalance >= amount, \"e/insufficient-balance\");\n        assetStorage.users[account].balance = encodeAmount(origBalance - amount);\n\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances - amount);\n\n        updateInterestRate(assetStorage, assetCache);\n\n        emit Withdraw(assetCache.underlying, account, amount);\n        emitViaProxy_Transfer(eTokenAddress, account, address(0), amount);\n    }\n\n    function transferBalance(AssetStorage storage assetStorage, AssetCache memory assetCache, address eTokenAddress, address from, address to, uint amount) internal {\n        uint origFromBalance = assetStorage.users[from].balance;\n        require(origFromBalance >= amount, \"e/insufficient-balance\");\n        uint newFromBalance;\n        unchecked { newFromBalance = origFromBalance - amount; }\n\n        assetStorage.users[from].balance = encodeAmount(newFromBalance);\n        assetStorage.users[to].balance = encodeAmount(assetStorage.users[to].balance + amount);\n\n        emit Withdraw(assetCache.underlying, from, amount);\n        emit Deposit(assetCache.underlying, to, amount);\n        emitViaProxy_Transfer(eTokenAddress, from, to, amount);\n    }\n\n    function withdrawAmounts(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint amount) internal view returns (uint, uint) {\n        uint amountInternal;\n        if (amount == type(uint).max) {\n            amountInternal = assetStorage.users[account].balance;\n            amount = balanceToUnderlyingAmount(assetCache, amountInternal);\n        } else {\n            amount = decodeExternalAmount(assetCache, amount);\n            amountInternal = underlyingAmountToBalanceRoundUp(assetCache, amount);\n        }\n\n        return (amount, amountInternal);\n    }\n\n    // Borrows\n\n    // Returns internal precision\n\n    function getCurrentOwedExact(AssetStorage storage assetStorage, AssetCache memory assetCache, address account, uint owed) internal view returns (uint) {\n        // Don't bother loading the user's accumulator\n        if (owed == 0) return 0;\n\n        // Can't divide by 0 here: If owed is non-zero, we must've initialised the user's interestAccumulator\n        return owed * assetCache.interestAccumulator / assetStorage.users[account].interestAccumulator;\n    }\n\n    // When non-zero, we round *up* to the smallest external unit so that outstanding dust in a loan can be repaid.\n    // unchecked is OK here since owed is always loaded from storage, so we know it fits into a uint144 (pre-interest accural)\n    // Takes and returns 27 decimals precision.\n\n    function roundUpOwed(AssetCache memory assetCache, uint owed) private pure returns (uint) {\n        if (owed == 0) return 0;\n\n        unchecked {\n            uint scale = INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler;\n            return (owed + scale - 1) / scale * scale;\n        }\n    }\n\n    // Returns 18-decimals precision (debt amount is rounded up)\n\n    function getCurrentOwed(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) internal view returns (uint) {\n        return roundUpOwed(assetCache, getCurrentOwedExact(assetStorage, assetCache, account, assetStorage.users[account].owed)) / INTERNAL_DEBT_PRECISION;\n    }\n\n    function updateUserBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address account) private returns (uint newOwedExact, uint prevOwedExact) {\n        prevOwedExact = assetStorage.users[account].owed;\n\n        newOwedExact = getCurrentOwedExact(assetStorage, assetCache, account, prevOwedExact);\n\n        assetStorage.users[account].owed = encodeDebtAmount(newOwedExact);\n        assetStorage.users[account].interestAccumulator = assetCache.interestAccumulator;\n    }\n\n    function logBorrowChange(AssetCache memory assetCache, address dTokenAddress, address account, uint prevOwed, uint owed) private {\n        prevOwed = roundUpOwed(assetCache, prevOwed) / INTERNAL_DEBT_PRECISION;\n        owed = roundUpOwed(assetCache, owed) / INTERNAL_DEBT_PRECISION;\n\n        if (owed > prevOwed) {\n            uint change = owed - prevOwed;\n            emit Borrow(assetCache.underlying, account, change);\n            emitViaProxy_Transfer(dTokenAddress, address(0), account, change);\n        } else if (prevOwed > owed) {\n            uint change = prevOwed - owed;\n            emit Repay(assetCache.underlying, account, change);\n            emitViaProxy_Transfer(dTokenAddress, account, address(0), change);\n        }\n    }\n\n    function increaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint amount) internal {\n        amount *= INTERNAL_DEBT_PRECISION;\n\n        require(assetCache.pricingType != PRICINGTYPE__FORWARDED || pTokenLookup[assetCache.underlying] == address(0), \"e/borrow-not-supported\");\n\n        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);\n\n        if (owed == 0) doEnterMarket(account, assetCache.underlying);\n\n        owed += amount;\n\n        assetStorage.users[account].owed = encodeDebtAmount(owed);\n        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows + amount);\n\n        updateInterestRate(assetStorage, assetCache);\n\n        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owed);\n    }\n\n    function decreaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint origAmount) internal {\n        uint amount = origAmount * INTERNAL_DEBT_PRECISION;\n\n        (uint owed, uint prevOwed) = updateUserBorrow(assetStorage, assetCache, account);\n        uint owedRoundedUp = roundUpOwed(assetCache, owed);\n\n        require(amount <= owedRoundedUp, \"e/repay-too-much\");\n        uint owedRemaining;\n        unchecked { owedRemaining = owedRoundedUp - amount; }\n\n        if (owed > assetCache.totalBorrows) owed = assetCache.totalBorrows;\n\n        assetStorage.users[account].owed = encodeDebtAmount(owedRemaining);\n        assetStorage.totalBorrows = assetCache.totalBorrows = encodeDebtAmount(assetCache.totalBorrows - owed + owedRemaining);\n\n        updateInterestRate(assetStorage, assetCache);\n\n        logBorrowChange(assetCache, dTokenAddress, account, prevOwed, owedRemaining);\n    }\n\n    function transferBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address from, address to, uint origAmount) internal {\n        uint amount = origAmount * INTERNAL_DEBT_PRECISION;\n\n        (uint fromOwed, uint fromOwedPrev) = updateUserBorrow(assetStorage, assetCache, from);\n        (uint toOwed, uint toOwedPrev) = updateUserBorrow(assetStorage, assetCache, to);\n\n        if (toOwed == 0) doEnterMarket(to, assetCache.underlying);\n\n        // If amount was rounded up, transfer exact amount owed\n        if (amount > fromOwed && amount - fromOwed < INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler) amount = fromOwed;\n\n        require(fromOwed >= amount, \"e/insufficient-balance\");\n        unchecked { fromOwed -= amount; }\n\n        // Transfer any residual dust\n        if (fromOwed < INTERNAL_DEBT_PRECISION) {\n            amount += fromOwed;\n            fromOwed = 0;\n        }\n\n        toOwed += amount;\n\n        assetStorage.users[from].owed = encodeDebtAmount(fromOwed);\n        assetStorage.users[to].owed = encodeDebtAmount(toOwed);\n\n        logBorrowChange(assetCache, dTokenAddress, from, fromOwedPrev, fromOwed);\n        logBorrowChange(assetCache, dTokenAddress, to, toOwedPrev, toOwed);\n    }\n\n\n\n    // Reserves\n\n    function increaseReserves(AssetStorage storage assetStorage, AssetCache memory assetCache, uint amount) internal {\n        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);\n        assetStorage.totalBalances = assetCache.totalBalances = encodeAmount(assetCache.totalBalances + amount);\n    }\n\n\n\n    // Token asset transfers\n\n    // amounts are in underlying units\n\n    function pullTokens(AssetCache memory assetCache, address from, uint amount) internal returns (uint amountTransferred) {\n        uint poolSizeBefore = assetCache.poolSize;\n\n        Utils.safeTransferFrom(assetCache.underlying, from, address(this), amount / assetCache.underlyingDecimalsScaler);\n        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));\n\n        require(poolSizeAfter >= poolSizeBefore, \"e/negative-transfer-amount\");\n        unchecked { amountTransferred = poolSizeAfter - poolSizeBefore; }\n    }\n\n    function pushTokens(AssetCache memory assetCache, address to, uint amount) internal returns (uint amountTransferred) {\n        uint poolSizeBefore = assetCache.poolSize;\n\n        Utils.safeTransfer(assetCache.underlying, to, amount / assetCache.underlyingDecimalsScaler);\n        uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));\n\n        require(poolSizeBefore >= poolSizeAfter, \"e/negative-transfer-amount\");\n        unchecked { amountTransferred = poolSizeBefore - poolSizeAfter; }\n    }\n\n\n\n\n    // Liquidity\n\n    function getAssetPrice(address asset) internal returns (uint) {\n        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.getPrice.selector, asset));\n        return abi.decode(result, (uint));\n    }\n\n    function getAccountLiquidity(address account) internal returns (uint collateralValue, uint liabilityValue) {\n        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));\n        (IRiskManager.LiquidityStatus memory status) = abi.decode(result, (IRiskManager.LiquidityStatus));\n\n        collateralValue = status.collateralValue;\n        liabilityValue = status.liabilityValue;\n    }\n\n    function checkLiquidity(address account) internal {\n        uint8 status = accountLookup[account].deferLiquidityStatus;\n\n        if (status == DEFERLIQUIDITY__NONE) {\n            callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.requireLiquidity.selector, account));\n        } else if (status == DEFERLIQUIDITY__CLEAN) {\n            accountLookup[account].deferLiquidityStatus = DEFERLIQUIDITY__DIRTY;\n        }\n    }\n\n\n\n    // Optional average liquidity tracking\n\n    function computeNewAverageLiquidity(address account, uint deltaT) private returns (uint) {\n        uint currDuration = deltaT >= AVERAGE_LIQUIDITY_PERIOD ? AVERAGE_LIQUIDITY_PERIOD : deltaT;\n        uint prevDuration = AVERAGE_LIQUIDITY_PERIOD - currDuration;\n\n        uint currAverageLiquidity;\n\n        {\n            (uint collateralValue, uint liabilityValue) = getAccountLiquidity(account);\n            currAverageLiquidity = collateralValue > liabilityValue ? collateralValue - liabilityValue : 0;\n        }\n\n        return (accountLookup[account].averageLiquidity * prevDuration / AVERAGE_LIQUIDITY_PERIOD) +\n               (currAverageLiquidity * currDuration / AVERAGE_LIQUIDITY_PERIOD);\n    }\n\n    function getUpdatedAverageLiquidity(address account) internal returns (uint) {\n        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;\n        if (lastAverageLiquidityUpdate == 0) return 0;\n\n        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;\n        if (deltaT == 0) return accountLookup[account].averageLiquidity;\n\n        return computeNewAverageLiquidity(account, deltaT);\n    }\n\n    function getUpdatedAverageLiquidityWithDelegate(address account) internal returns (uint) {\n        address delegate = accountLookup[account].averageLiquidityDelegate;\n\n        return delegate != address(0) && accountLookup[delegate].averageLiquidityDelegate == account\n            ? getUpdatedAverageLiquidity(delegate)\n            : getUpdatedAverageLiquidity(account);\n    }\n\n    function updateAverageLiquidity(address account) internal {\n        uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;\n        if (lastAverageLiquidityUpdate == 0) return;\n\n        uint deltaT = block.timestamp - lastAverageLiquidityUpdate;\n        if (deltaT == 0) return;\n\n        accountLookup[account].lastAverageLiquidityUpdate = uint40(block.timestamp);\n        accountLookup[account].averageLiquidity = computeNewAverageLiquidity(account, deltaT);\n    }\n}\n"
    },
    "contracts/BaseModule.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Base.sol\";\n\n\nabstract contract BaseModule is Base {\n    // Construction\n\n    // public accessors common to all modules\n\n    uint immutable public moduleId;\n    bytes32 immutable public moduleGitCommit;\n\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) {\n        moduleId = moduleId_;\n        moduleGitCommit = moduleGitCommit_;\n    }\n\n\n    // Accessing parameters\n\n    function unpackTrailingParamMsgSender() internal pure returns (address msgSender) {\n        assembly {\n            mstore(0, 0)\n\n            calldatacopy(12, sub(calldatasize(), 40), 20)\n            msgSender := mload(0)\n        }\n    }\n\n    function unpackTrailingParams() internal pure returns (address msgSender, address proxyAddr) {\n        assembly {\n            mstore(0, 0)\n\n            calldatacopy(12, sub(calldatasize(), 40), 20)\n            msgSender := mload(0)\n\n            calldatacopy(12, sub(calldatasize(), 20), 20)\n            proxyAddr := mload(0)\n        }\n    }\n\n\n    // Emit logs via proxies\n\n    function emitViaProxy_Transfer(address proxyAddr, address from, address to, uint value) internal FREEMEM {\n        (bool success,) = proxyAddr.call(abi.encodePacked(\n                               uint8(3),\n                               keccak256(bytes('Transfer(address,address,uint256)')),\n                               bytes32(uint(uint160(from))),\n                               bytes32(uint(uint160(to))),\n                               value\n                          ));\n        require(success, \"e/log-proxy-fail\");\n    }\n\n    function emitViaProxy_Approval(address proxyAddr, address owner, address spender, uint value) internal FREEMEM {\n        (bool success,) = proxyAddr.call(abi.encodePacked(\n                               uint8(3),\n                               keccak256(bytes('Approval(address,address,uint256)')),\n                               bytes32(uint(uint160(owner))),\n                               bytes32(uint(uint160(spender))),\n                               value\n                          ));\n        require(success, \"e/log-proxy-fail\");\n    }\n}\n"
    },
    "contracts/BaseIRM.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./BaseModule.sol\";\n\nabstract contract BaseIRM is BaseModule {\n    constructor(uint moduleId_, bytes32 moduleGitCommit_) BaseModule(moduleId_, moduleGitCommit_) {}\n\n    int96 internal constant MAX_ALLOWED_INTEREST_RATE = int96(int(uint(5 * 1e27) / SECONDS_PER_YEAR)); // 500% APR\n    int96 internal constant MIN_ALLOWED_INTEREST_RATE = 0;\n\n    function computeInterestRateImpl(address, uint32) internal virtual returns (int96);\n\n    function computeInterestRate(address underlying, uint32 utilisation) external returns (int96) {\n        int96 rate = computeInterestRateImpl(underlying, utilisation);\n\n        if (rate > MAX_ALLOWED_INTEREST_RATE) rate = MAX_ALLOWED_INTEREST_RATE;\n        else if (rate < MIN_ALLOWED_INTEREST_RATE) rate = MIN_ALLOWED_INTEREST_RATE;\n\n        return rate;\n    }\n\n    function reset(address underlying, bytes calldata resetParams) external virtual {}\n}\n"
    },
    "contracts/Interfaces.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IERC3156FlashBorrower {\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32);\n}\n\ninterface IERC3156FlashLender {\n    function maxFlashLoan(address token) external view returns (uint256);\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data) external returns (bool);\n}\n"
    },
    "contracts/Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Interfaces.sol\";\n\nlibrary Utils {\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\n    }\n\n    function safeApprove(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), string(data));\n    }\n}\n"
    },
    "contracts/vendor/RPow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n// From MakerDAO DSS\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nlibrary RPow {\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/IRiskManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Storage.sol\";\n\n// This interface is used to avoid a circular dependency between BaseLogic and RiskManager\n\ninterface IRiskManager {\n    struct NewMarketParameters {\n        uint16 pricingType;\n        uint32 pricingParameters;\n\n        Storage.AssetConfig config;\n    }\n\n    struct LiquidityStatus {\n        uint collateralValue;\n        uint liabilityValue;\n        uint numBorrows;\n        bool borrowIsolated;\n    }\n\n    struct AssetLiquidity {\n        address underlying;\n        LiquidityStatus status;\n    }\n\n    function getNewMarketParameters(address underlying) external returns (NewMarketParameters memory);\n\n    function requireLiquidity(address account) external;\n    function computeLiquidity(address account) external returns (LiquidityStatus memory status);\n    function computeAssetLiquidities(address account) external returns (AssetLiquidity[] memory assets);\n\n    function getPrice(address underlying) external returns (uint twap, uint twapPeriod);\n    function getPriceFull(address underlying) external returns (uint twap, uint twapPeriod, uint currPrice);\n}\n"
    },
    "contracts/Base.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n//import \"hardhat/console.sol\"; // DEV_MODE\n\nimport \"./Storage.sol\";\nimport \"./Events.sol\";\nimport \"./Proxy.sol\";\n\nabstract contract Base is Storage, Events {\n    // Modules\n\n    function _createProxy(uint proxyModuleId) internal returns (address) {\n        require(proxyModuleId != 0, \"e/create-proxy/invalid-module\");\n        require(proxyModuleId <= MAX_EXTERNAL_MODULEID, \"e/create-proxy/internal-module\");\n\n        // If we've already created a proxy for a single-proxy module, just return it:\n\n        if (proxyLookup[proxyModuleId] != address(0)) return proxyLookup[proxyModuleId];\n\n        // Otherwise create a proxy:\n\n        address proxyAddr = address(new Proxy());\n\n        if (proxyModuleId <= MAX_EXTERNAL_SINGLE_PROXY_MODULEID) proxyLookup[proxyModuleId] = proxyAddr;\n\n        trustedSenders[proxyAddr] = TrustedSenderInfo({ moduleId: uint32(proxyModuleId), moduleImpl: address(0) });\n\n        emit ProxyCreated(proxyAddr, proxyModuleId);\n\n        return proxyAddr;\n    }\n\n    function callInternalModule(uint moduleId, bytes memory input) internal returns (bytes memory) {\n        (bool success, bytes memory result) = moduleLookup[moduleId].delegatecall(input);\n        if (!success) revertBytes(result);\n        return result;\n    }\n\n\n\n    // Modifiers\n\n    modifier nonReentrant() {\n        require(reentrancyLock == REENTRANCYLOCK__UNLOCKED, \"e/reentrancy\");\n\n        reentrancyLock = REENTRANCYLOCK__LOCKED;\n        _;\n        reentrancyLock = REENTRANCYLOCK__UNLOCKED;\n    }\n\n    modifier reentrantOK() { // documentation only\n        _;\n    }\n\n    // WARNING: Must be very careful with this modifier. It resets the free memory pointer\n    // to the value it was when the function started. This saves gas if more memory will\n    // be allocated in the future. However, if the memory will be later referenced\n    // (for example because the function has returned a pointer to it) then you cannot\n    // use this modifier.\n\n    modifier FREEMEM() {\n        uint origFreeMemPtr;\n\n        assembly {\n            origFreeMemPtr := mload(0x40)\n        }\n\n        _;\n\n        /*\n        assembly { // DEV_MODE: overwrite the freed memory with garbage to detect bugs\n            let garbage := 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF\n            for { let i := origFreeMemPtr } lt(i, mload(0x40)) { i := add(i, 32) } { mstore(i, garbage) }\n        }\n        */\n\n        assembly {\n            mstore(0x40, origFreeMemPtr)\n        }\n    }\n\n\n\n    // Error handling\n\n    function revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n\n        revert(\"e/empty-error\");\n    }\n}\n"
    },
    "contracts/Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Constants.sol\";\n\nabstract contract Storage is Constants {\n    // Dispatcher and upgrades\n\n    uint reentrancyLock;\n\n    address upgradeAdmin;\n    address governorAdmin;\n\n    mapping(uint => address) moduleLookup; // moduleId => module implementation\n    mapping(uint => address) proxyLookup; // moduleId => proxy address (only for single-proxy modules)\n\n    struct TrustedSenderInfo {\n        uint32 moduleId; // 0 = un-trusted\n        address moduleImpl; // only non-zero for external single-proxy modules\n    }\n\n    mapping(address => TrustedSenderInfo) trustedSenders; // sender address => moduleId (0 = un-trusted)\n\n\n\n    // Account-level state\n    // Sub-accounts are considered distinct accounts\n\n    struct AccountStorage {\n        // Packed slot: 1 + 5 + 4 + 20 = 30\n        uint8 deferLiquidityStatus;\n        uint40 lastAverageLiquidityUpdate;\n        uint32 numMarketsEntered;\n        address firstMarketEntered;\n\n        uint averageLiquidity;\n        address averageLiquidityDelegate;\n    }\n\n    mapping(address => AccountStorage) accountLookup;\n    mapping(address => address[MAX_POSSIBLE_ENTERED_MARKETS]) marketsEntered;\n\n\n\n    // Markets and assets\n\n    struct AssetConfig {\n        // Packed slot: 20 + 1 + 4 + 4 + 3 = 32\n        address eTokenAddress;\n        bool borrowIsolated;\n        uint32 collateralFactor;\n        uint32 borrowFactor;\n        uint24 twapWindow;\n    }\n\n    struct UserAsset {\n        uint112 balance;\n        uint144 owed;\n\n        uint interestAccumulator;\n    }\n\n    struct AssetStorage {\n        // Packed slot: 5 + 1 + 4 + 12 + 4 + 2 + 4 = 32\n        uint40 lastInterestAccumulatorUpdate;\n        uint8 underlyingDecimals; // Not dynamic, but put here to live in same storage slot\n        uint32 interestRateModel;\n        int96 interestRate;\n        uint32 reserveFee;\n        uint16 pricingType;\n        uint32 pricingParameters;\n\n        address underlying;\n        uint96 reserveBalance;\n\n        address dTokenAddress;\n\n        uint112 totalBalances;\n        uint144 totalBorrows;\n\n        uint interestAccumulator;\n\n        mapping(address => UserAsset) users;\n\n        mapping(address => mapping(address => uint)) eTokenAllowance;\n        mapping(address => mapping(address => uint)) dTokenAllowance;\n    }\n\n    mapping(address => AssetConfig) internal underlyingLookup; // underlying => AssetConfig\n    mapping(address => AssetStorage) internal eTokenLookup; // EToken => AssetStorage\n    mapping(address => address) internal dTokenLookup; // DToken => EToken\n    mapping(address => address) internal pTokenLookup; // PToken => underlying\n    mapping(address => address) internal reversePTokenLookup; // underlying => PToken\n}\n"
    },
    "contracts/Events.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./Storage.sol\";\n\nabstract contract Events {\n    event Genesis();\n\n\n    event ProxyCreated(address indexed proxy, uint moduleId);\n    event MarketActivated(address indexed underlying, address indexed eToken, address indexed dToken);\n    event PTokenActivated(address indexed underlying, address indexed pToken);\n\n    event EnterMarket(address indexed underlying, address indexed account);\n    event ExitMarket(address indexed underlying, address indexed account);\n\n    event Deposit(address indexed underlying, address indexed account, uint amount);\n    event Withdraw(address indexed underlying, address indexed account, uint amount);\n    event Borrow(address indexed underlying, address indexed account, uint amount);\n    event Repay(address indexed underlying, address indexed account, uint amount);\n\n    event Liquidation(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint yield, uint healthScore, uint baseDiscount, uint discount);\n\n    event TrackAverageLiquidity(address indexed account);\n    event UnTrackAverageLiquidity(address indexed account);\n    event DelegateAverageLiquidity(address indexed account, address indexed delegate);\n\n    event PTokenWrap(address indexed underlying, address indexed account, uint amount);\n    event PTokenUnWrap(address indexed underlying, address indexed account, uint amount);\n\n    event AssetStatus(address indexed underlying, uint totalBalances, uint totalBorrows, uint96 reserveBalance, uint poolSize, uint interestAccumulator, int96 interestRate, uint timestamp);\n\n\n    event RequestDeposit(address indexed account, uint amount);\n    event RequestWithdraw(address indexed account, uint amount);\n    event RequestMint(address indexed account, uint amount);\n    event RequestBurn(address indexed account, uint amount);\n    event RequestTransferEToken(address indexed from, address indexed to, uint amount);\n\n    event RequestBorrow(address indexed account, uint amount);\n    event RequestRepay(address indexed account, uint amount);\n    event RequestTransferDToken(address indexed from, address indexed to, uint amount);\n\n    event RequestLiquidate(address indexed liquidator, address indexed violator, address indexed underlying, address collateral, uint repay, uint minYield);\n\n\n    event InstallerSetUpgradeAdmin(address indexed newUpgradeAdmin);\n    event InstallerSetGovernorAdmin(address indexed newGovernorAdmin);\n    event InstallerInstallModule(uint indexed moduleId, address indexed moduleImpl, bytes32 moduleGitCommit);\n\n\n    event GovSetAssetConfig(address indexed underlying, Storage.AssetConfig newConfig);\n    event GovSetIRM(address indexed underlying, uint interestRateModel, bytes resetParams);\n    event GovSetPricingConfig(address indexed underlying, uint16 newPricingType, uint32 newPricingParameter);\n    event GovSetReserveFee(address indexed underlying, uint32 newReserveFee);\n    event GovConvertReserves(address indexed underlying, address indexed recipient, uint amount);\n\n    event RequestSwap(address indexed accountIn, address indexed accountOut, address indexed underlyingIn, address underlyingOut, uint amount, uint swapType);\n}\n"
    },
    "contracts/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ncontract Proxy {\n    address immutable creator;\n\n    constructor() {\n        creator = msg.sender;\n    }\n\n    // External interface\n\n    fallback() external {\n        address creator_ = creator;\n\n        if (msg.sender == creator_) {\n            assembly {\n                mstore(0, 0)\n                calldatacopy(31, 0, calldatasize())\n\n                switch mload(0) // numTopics\n                    case 0 { log0(32,  sub(calldatasize(), 1)) }\n                    case 1 { log1(64,  sub(calldatasize(), 33),  mload(32)) }\n                    case 2 { log2(96,  sub(calldatasize(), 65),  mload(32), mload(64)) }\n                    case 3 { log3(128, sub(calldatasize(), 97),  mload(32), mload(64), mload(96)) }\n                    case 4 { log4(160, sub(calldatasize(), 129), mload(32), mload(64), mload(96), mload(128)) }\n                    default { revert(0, 0) }\n\n                return(0, 0)\n            }\n        } else {\n            assembly {\n                mstore(0, 0xe9c4a3ac00000000000000000000000000000000000000000000000000000000) // dispatch() selector\n                calldatacopy(4, 0, calldatasize())\n                mstore(add(4, calldatasize()), shl(96, caller()))\n\n                let result := call(gas(), creator_, 0, 0, add(24, calldatasize()), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n\n                switch result\n                    case 0 { revert(0, returndatasize()) }\n                    default { return(0, returndatasize()) }\n            }\n        }\n    }\n}\n"
    },
    "contracts/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nabstract contract Constants {\n    // Universal\n\n    uint internal constant SECONDS_PER_YEAR = 365.2425 * 86400; // Gregorian calendar\n\n\n    // Protocol parameters\n\n    uint internal constant MAX_SANE_AMOUNT = type(uint112).max;\n    uint internal constant MAX_SANE_SMALL_AMOUNT = type(uint96).max;\n    uint internal constant MAX_SANE_DEBT_AMOUNT = type(uint144).max;\n    uint internal constant INTERNAL_DEBT_PRECISION = 1e9;\n    uint internal constant MAX_ENTERED_MARKETS = 10; // per sub-account\n    uint internal constant MAX_POSSIBLE_ENTERED_MARKETS = 2**32; // limited by size of AccountStorage.numMarketsEntered\n    uint internal constant CONFIG_FACTOR_SCALE = 4_000_000_000; // must fit into a uint32\n    uint internal constant RESERVE_FEE_SCALE = 4_000_000_000; // must fit into a uint32\n    uint32 internal constant DEFAULT_RESERVE_FEE = uint32(0.23 * 4_000_000_000);\n    uint internal constant INITIAL_INTEREST_ACCUMULATOR = 1e27;\n    uint internal constant AVERAGE_LIQUIDITY_PERIOD = 24 * 60 * 60;\n    uint16 internal constant MIN_UNISWAP3_OBSERVATION_CARDINALITY = 10;\n    uint24 internal constant DEFAULT_TWAP_WINDOW_SECONDS = 30 * 60;\n    uint32 internal constant DEFAULT_BORROW_FACTOR = uint32(0.28 * 4_000_000_000);\n\n\n    // Implementation internals\n\n    uint internal constant REENTRANCYLOCK__UNLOCKED = 1;\n    uint internal constant REENTRANCYLOCK__LOCKED = 2;\n\n    uint8 internal constant DEFERLIQUIDITY__NONE = 0;\n    uint8 internal constant DEFERLIQUIDITY__CLEAN = 1;\n    uint8 internal constant DEFERLIQUIDITY__DIRTY = 2;\n\n\n    // Pricing types\n\n    uint16 internal constant PRICINGTYPE__PEGGED = 1;\n    uint16 internal constant PRICINGTYPE__UNISWAP3_TWAP = 2;\n    uint16 internal constant PRICINGTYPE__FORWARDED = 3;\n\n\n    // Modules\n\n    // Public single-proxy modules\n    uint internal constant MODULEID__INSTALLER = 1;\n    uint internal constant MODULEID__MARKETS = 2;\n    uint internal constant MODULEID__LIQUIDATION = 3;\n    uint internal constant MODULEID__GOVERNANCE = 4;\n    uint internal constant MODULEID__EXEC = 5;\n    uint internal constant MODULEID__SWAP = 6;\n\n    uint internal constant MAX_EXTERNAL_SINGLE_PROXY_MODULEID = 499_999;\n\n    // Public multi-proxy modules\n    uint internal constant MODULEID__ETOKEN = 500_000;\n    uint internal constant MODULEID__DTOKEN = 500_001;\n\n    uint internal constant MAX_EXTERNAL_MODULEID = 999_999;\n\n    // Internal modules\n    uint internal constant MODULEID__RISK_MANAGER = 1_000_000;\n\n    // Interest rate models\n    //   Default for new markets\n    uint internal constant MODULEID__IRM_DEFAULT = 2_000_000;\n    //   Testing-only\n    uint internal constant MODULEID__IRM_ZERO = 2_000_001;\n    uint internal constant MODULEID__IRM_FIXED = 2_000_002;\n    uint internal constant MODULEID__IRM_LINEAR = 2_000_100;\n    //   Classes\n    uint internal constant MODULEID__IRM_CLASS__STABLE = 2_000_500;\n    uint internal constant MODULEID__IRM_CLASS__MAJOR = 2_000_501;\n    uint internal constant MODULEID__IRM_CLASS__MIDCAP = 2_000_502;\n\n    // Swap types\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT_SINGLE = 1;\n    uint internal constant SWAP_TYPE__UNI_EXACT_INPUT = 2;\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE = 3;\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT = 4;\n    uint internal constant SWAP_TYPE__1INCH = 5;\n\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_SINGLE_REPAY = 6;\n    uint internal constant SWAP_TYPE__UNI_EXACT_OUTPUT_REPAY = 7;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}