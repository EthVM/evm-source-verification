{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Mute.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract MuteGovernance {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => address) internal _delegates;\r\n\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint256 votes;\r\n    }\r\n\r\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\r\n\r\n    mapping (address => uint32) public numCheckpoints;\r\n\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n\r\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\r\n\r\n    mapping (address => uint) public nonces;\r\n\r\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\r\n\r\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\r\n\r\n    function delegates(address delegator) external view returns (address) {\r\n        return _delegates[delegator];\r\n    }\r\n\r\n    function getCurrentVotes(address account) external view returns (uint256) {\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\r\n    }\r\n\r\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256) {\r\n        require(blockNumber < block.number, \"Gov::getPriorVotes: not yet determined\");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; \r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\r\n\r\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\r\n        if (srcRep != dstRep && amount > 0) {\r\n            if (srcRep != address(0)) {\r\n                uint32 srcRepNum = numCheckpoints[srcRep];\r\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\r\n                uint256 srcRepNew = srcRepOld.sub(amount);\r\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\r\n            }\r\n\r\n            if (dstRep != address(0)) {\r\n                uint32 dstRepNum = numCheckpoints[dstRep];\r\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\r\n                uint256 dstRepNew = dstRepOld.add(amount);\r\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint256 oldVotes, uint256 newVotes) internal {\r\n        uint32 blockNumber = safe32(block.number, \"Gov::_writeCheckpoint: block number exceeds 32 bits\");\r\n\r\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\r\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\r\n        } else {\r\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\r\n            numCheckpoints[delegatee] = nCheckpoints + 1;\r\n        }\r\n\r\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\r\n    }\r\n\r\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\r\n        require(n < 2**32, errorMessage);\r\n        return uint32(n);\r\n    }\r\n\r\n    function getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n\r\ncontract Mute is MuteGovernance {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    uint16 public TAX_FRACTION;\r\n    address public taxReceiveAddress;\r\n\r\n    bool public isTaxEnabled;\r\n    mapping(address => bool) public nonTaxedAddresses;\r\n\r\n    address private _owner = address(0);\r\n    mapping (address => bool) private _minters;\r\n\r\n    uint256 public vaultThreshold = 10000e18; \r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Mute::OnlyOwner: Not the owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(_minters[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    function initialize() external {\r\n        require(_owner == address(0), \"Mute::Initialize: Contract has already been initialized\");\r\n        _owner = msg.sender;\r\n        _name = \"Mute.io\";\r\n        _symbol = \"MUTE\";\r\n        _decimals = 18;\r\n    }\r\n\r\n    function addMinter(address account) external onlyOwner {\r\n        require(account != address(0));\r\n        _minters[account] = true;\r\n    }\r\n\r\n    function removeMinter(address account) external onlyOwner {\r\n        require(account != address(0));\r\n        _minters[account] = false;\r\n    }\r\n\r\n    function setTaxReceiveAddress(address _taxReceiveAddress) external onlyOwner {\r\n        taxReceiveAddress = _taxReceiveAddress;\r\n    }\r\n\r\n    function setAddressTax(address _address, bool ignoreTax) external onlyOwner {\r\n        nonTaxedAddresses[_address] = ignoreTax;\r\n    }\r\n\r\n    function setTaxFraction(uint16 _tax_fraction) external onlyOwner {\r\n        TAX_FRACTION = _tax_fraction;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner_, address spender) public view returns (uint256) {\r\n        return _allowances[owner_][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"Mute: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"Mute: transfer from the zero address\");\r\n        require(recipient != address(0), \"Mute: transfer to the zero address\");\r\n\r\n        if(nonTaxedAddresses[sender] == true || TAX_FRACTION == 0 || balanceOf(taxReceiveAddress) > vaultThreshold){\r\n          _balances[sender] = _balances[sender].sub(amount, \"Mute: transfer amount exceeds balance\");\r\n          _balances[recipient] = _balances[recipient].add(amount);\r\n\r\n          _moveDelegates(_delegates[sender], _delegates[recipient], amount);\r\n\r\n          emit Transfer(sender, recipient, amount);\r\n\r\n          if(balanceOf(taxReceiveAddress) > vaultThreshold){\r\n              IMuteVault(taxReceiveAddress).reward();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        uint256 feeAmount = amount.div(TAX_FRACTION);\r\n        uint256 newAmount = amount.sub(feeAmount);\r\n\r\n        require(amount == feeAmount.add(newAmount), \"Mute: math is broken\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"Mute: transfer amount exceeds balance\");\r\n\r\n        _balances[recipient] = _balances[recipient].add(newAmount);\r\n        _moveDelegates(_delegates[sender], _delegates[recipient], newAmount);\r\n        _balances[taxReceiveAddress] = _balances[taxReceiveAddress].add(feeAmount);\r\n        _moveDelegates(_delegates[sender], _delegates[taxReceiveAddress], feeAmount);\r\n\r\n        emit Transfer(sender, recipient, newAmount);\r\n        emit Transfer(sender, taxReceiveAddress, feeAmount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"Mute: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner_, address spender, uint256 amount) internal {\r\n        require(owner_ != address(0), \"Mute: approve from the zero address\");\r\n        require(spender != address(0), \"Mute: approve to the zero address\");\r\n\r\n        _allowances[owner_][spender] = amount;\r\n        emit Approval(owner_, spender, amount);\r\n    }\r\n\r\n    function Burn(uint256 amount) external returns (bool) {\r\n        require(msg.sender != address(0), \"Mute: burn from the zero address\");\r\n\r\n        _moveDelegates(_delegates[msg.sender], address(0), amount);\r\n\r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount, \"Mute: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(msg.sender, address(0), amount);\r\n        return true;\r\n    }\r\n\r\n    function Mint(address account, uint256 amount) external onlyMinter returns (bool) {\r\n        require(account != address(0), \"Mute: mint to the zero address\");\r\n\r\n        _moveDelegates(address(0), _delegates[account], amount);\r\n\r\n        _balances[account] = _balances[account].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n        return true;\r\n    }\r\n\r\n    function delegate(address delegatee) external {\r\n        return _delegate(msg.sender, delegatee);\r\n    }\r\n\r\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"Mute::delegateBySig: invalid signature\");\r\n        require(nonce == nonces[signatory]++, \"Mute::delegateBySig: invalid nonce\");\r\n        require(now <= expiry, \"Mute::delegateBySig: signature expired\");\r\n        return _delegate(signatory, delegatee);\r\n    }\r\n\r\n    function _delegate(address delegator, address delegatee) internal {\r\n        address currentDelegate = _delegates[delegator];\r\n        uint256 delegatorBalance = balanceOf(delegator);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n}\r\n\r\ninterface IMuteVault {\r\n    function reward() external returns (bool);\r\n}"}}}