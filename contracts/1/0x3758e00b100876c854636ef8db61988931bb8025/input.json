{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.2;\r\n\r\n// Contracts interaction interface\r\nabstract contract IContract {\r\n    function balanceOf(address owner) external virtual returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external virtual;\r\n}\r\n\r\n// https://eips.ethereum.org/EIPS/eip-20\r\ncontract UniqToken {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    mapping(address => uint256) private balances;\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n    uint256 public totalSupply;\r\n    address public owner;\r\n    address constant ZERO = address(0);\r\n\r\n    modifier notZeroAddress(address a) {\r\n        require(a != ZERO, \"Address 0x0 not allowed\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customize the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public constant name = \"Uniqly\"; // Token name\r\n    string public constant symbol = \"UNIQ\"; // Token symbol\r\n    uint8 public constant decimals = 18; // Token decimals\r\n\r\n    constructor(uint256 _initialAmount) {\r\n        balances[msg.sender] = _initialAmount; // Give the creator all initial tokens\r\n        totalSupply = _initialAmount; // Update total supply\r\n        owner = msg.sender; // Set owner\r\n        emit Transfer(ZERO, msg.sender, _initialAmount); // Emit event\r\n    }\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value)\r\n        external\r\n        notZeroAddress(_to)\r\n        returns (bool)\r\n    {\r\n        require(\r\n            balances[msg.sender] >= _value,\r\n            \"ERC20 transfer: token balance too low\"\r\n        );\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return success Whether the transfer was successful or not\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external notZeroAddress(_to) returns (bool) {\r\n        uint256 _allowance = allowed[_from][msg.sender];\r\n        require(\r\n            balances[_from] >= _value && _allowance >= _value,\r\n            \"ERC20 transferFrom: token balance or allowance too low\"\r\n        );\r\n        balances[_from] -= _value;\r\n        if (_allowance < (2**256 - 1)) {\r\n            _approve(_from, msg.sender, _allowance - _value);\r\n        }\r\n        balances[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return balance the balance\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return success Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value)\r\n        external\r\n        notZeroAddress(_spender)\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        allowed[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return remaining Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {_burn}.\r\n     */\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {_burn} and {allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) external {\r\n        uint256 currentAllowance = allowed[account][msg.sender];\r\n        require(\r\n            currentAllowance >= amount,\r\n            \"ERC20: burn amount exceeds allowance\"\r\n        );\r\n        _approve(account, msg.sender, currentAllowance - amount);\r\n        _burn(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount)\r\n        internal\r\n        notZeroAddress(account)\r\n    {\r\n        require(\r\n            balances[account] >= amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        balances[account] -= amount;\r\n        totalSupply -= amount;\r\n\r\n        emit Transfer(account, ZERO, amount);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only for Owner\");\r\n        _;\r\n    }\r\n\r\n    // change ownership in two steps to be sure about owner address\r\n    address public newOwner;\r\n\r\n    // only current owner can delegate new one\r\n    function giveOwnership(address _newOwner) external onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    // new owner need to accept ownership\r\n    function acceptOwnership() external {\r\n        require(msg.sender == newOwner, \"You are not New Owner\");\r\n        newOwner = address(0);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    @dev Function to recover accidentally send ERC20 tokens\r\n    @param _token ERC20 token address\r\n    */\r\n    function rescueERC20(address _token) external onlyOwner {\r\n        uint256 amt = IContract(_token).balanceOf(address(this));\r\n        require(amt > 0, \"Nothing to rescue\");\r\n        IContract(_token).transfer(owner, amt);\r\n    }\r\n\r\n    /**\r\n    @dev Function to recover any ETH send to contract\r\n    */\r\n    function rescueETH() external onlyOwner {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n}\r\n"
    }
  }
}