{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "EverRiseStaked.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n    function latestRoundData() external view \r\n    returns (\r\n        uint80 roundId, \r\n        int256 answer, \r\n        uint256 startedAt, \r\n        uint256 updatedAt, \r\n        uint80 answeredInRound\r\n    );\r\n}\r\n\r\ninterface IEverRise {\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function totalBuyVolume() external view returns (uint256);\r\n    function totalSellVolume() external view returns (uint256);\r\n    function totalVolume() external view returns (uint256);\r\n    function getTotalAmountStaked() external view returns (uint256);\r\n    function getTotalRewardsDistributed() external view returns (uint256);\r\n    function holders() external view returns (uint256);\r\n    function uniswapV2Pair() external view returns (address);\r\n}\r\ninterface IEverStakeFactory is IERC20 {\r\n    function getDepositorAddrss(address stakingAddress) external view returns (address);\r\n}\r\n\r\ninterface IEverStake {\r\n    function getStakeName() external view returns (string memory);\r\n    function getAltOwner() external view returns (address payable);\r\n    function getRemainingAmountStaked() external view returns (uint256);\r\n    function getWithdrawAmount() external view returns (uint256);\r\n    function getMaxAmountAllowedToWithdraw() external view returns (uint256);\r\n    function getDepositorAddress() external view returns (address payable);\r\n    function getDepositTokens() external view returns (uint256);\r\n    function getLockTime() external view returns (uint256);\r\n    function getDepositTime() external view returns (uint256);\r\n    function getNumOfMonths() external view returns (uint256);\r\n    function getStatus() external view returns (bool);\r\n    function getCurrentBalance() external view returns (uint256);\r\n    function getReflectionsBalance() external view returns (uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) external virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n}\r\n\r\ncontract EverRiseStaked is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event UsdOracleAddressUpdated(address prevValue, address newValue);\r\n    event EverRiseAddressUpdated(address prevValue, address newValue);\r\n    event EverBridgeVaultAddressUpdated(address prevValue, address newValue);\r\n    event CoinStablePairAddressUpdated(address prevValue, address newValue);\r\n    event EverStakeAddressUpdated(address prevValue, address newValue);\r\n\r\n    mapping (address => address[]) public registeredContractList;\r\n    mapping (address => mapping (address => bool)) public registeredContracts;\r\n    address[] public allConfirmedContracts;\r\n    mapping (address => bool) public confirmedContracts;\r\n\r\n    uint256 public tokenDivisor;\r\n    uint256 public coinDivisor;\r\n\r\n    address public everRiseAddress = 0x0cD022ddE27169b20895e0e2B2B8A33B25e63579;\r\n    IEverRise private everRise = IEverRise(everRiseAddress);\r\n\r\n    address public everStakeAddress = 0x1490EaA0De0b2D4F9fE0E354A7D99d6C6532be84;\r\n    IEverStakeFactory private everStake = IEverStakeFactory(everStakeAddress);\r\n\r\n    address public everBridgeVaultAddress = 0x7D92730C33032e2770966C4912b3c9917995dC4E;\r\n\r\n    address public pairAddress;\r\n    IUniswapV2Pair private pair;\r\n    address public usdOracleAddress;\r\n    AggregatorV3Interface private usdOracle;\r\n\r\n    address public coinStablePairAddress;\r\n    IUniswapV2Pair private coinStablePair;\r\n    address public wrappedCoinAddress;\r\n    IERC20 private wrappedCoin;\r\n    address public stableAddress;\r\n    IERC20 private stableToken;\r\n    uint8 private tokenDecimals;\r\n    uint8 private coinDecimals;\r\n\r\n    // BSC\r\n    //     usdOracleAddress = 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE; Chainlink: BNB/USD Price Feed\r\n    //     coinStablePairAddress = 0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16;  WBNB/BUSD\r\n    // Eth\r\n    //     usdOracleAddress = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; Chainlink: ETH/USD Price Feed\r\n    //     coinStablePairAddress = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc;  WETH/USDC\r\n    // Poly\r\n    //     usdOracleAddress = 0xAB594600376Ec9fD91F8e885dADF0CE036862dE0; Chainlink: MATIC/USD Price Feed\r\n    //     coinStablePairAddress = 0x6e7a5FAFcec6BB1e78bAE2A1F0B612012BF14827;  WMATIC/USDC\r\n    // AVAX\r\n    //     usdOracleAddress = 0x0A77230d17318075983913bC2145DB16C7366156; Chainlink: AVAX/USD Price Feed\r\n    //     coinStablePairAddress = 0xA389f9430876455C36478DeEa9769B7Ca4E3DDB1;  AVAX/USDC\r\n\r\n    constructor(address _usdOracleAddress, address _coinStablePairAddress) {\r\n        require(\r\n            _coinStablePairAddress != address(0),\r\n            \"_coinStablePairAddress should not be the zero address\"\r\n        );\r\n        require(\r\n            _usdOracleAddress != address(0),\r\n            \"_usdOracleAddress should not be the zero address\"\r\n        );\r\n\r\n        usdOracleAddress = _usdOracleAddress;\r\n        usdOracle = AggregatorV3Interface(_usdOracleAddress);\r\n\r\n        coinStablePairAddress = _coinStablePairAddress;\r\n        coinStablePair = IUniswapV2Pair(_coinStablePairAddress);\r\n\r\n        init();\r\n    }\r\n\r\n    function init() private {\r\n        pairAddress = everRise.uniswapV2Pair();\r\n        pair = IUniswapV2Pair(pairAddress);\r\n        wrappedCoinAddress = pair.token0();\r\n        if (wrappedCoinAddress == everRiseAddress){\r\n            wrappedCoinAddress = pair.token1();\r\n        }\r\n\r\n        wrappedCoin = IERC20(wrappedCoinAddress);\r\n\r\n        stableAddress = coinStablePair.token0();\r\n        if (stableAddress == wrappedCoinAddress){\r\n            stableAddress = coinStablePair.token1();\r\n        }\r\n        \r\n        stableToken = IERC20(stableAddress);\r\n\r\n        tokenDecimals = everRise.decimals();\r\n        tokenDivisor = 10 ** uint256(tokenDecimals);\r\n        coinDecimals = wrappedCoin.decimals();\r\n        coinDivisor = 10 ** uint256(coinDecimals);\r\n    }\r\n\r\n    function name() external pure returns (string memory) {\r\n        return \"EverRise Staked\";\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        return \"RISESTAKE\";\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return everRise.totalSupply();\r\n    }\r\n\r\n    function allConfirmedContractsLength() external view returns (uint256){\r\n        return allConfirmedContracts.length;\r\n    }\r\n    \r\n    function transfer(address to, uint256 value) external pure returns (bool) {\r\n        require(to != address(0), \"to should not be the zero address\");\r\n        require(value != 0, \"value should not be zero\");\r\n        \r\n        require(false, \"This is a virtual token and cannot be transferred\");\r\n\r\n        return false;\r\n    }\r\n\r\n    function stakingContractsRegister(address[] calldata contractAddresses) external {\r\n        for (uint256 i = 0; i < contractAddresses.length; i++) {\r\n            address contractAddress = contractAddresses[i];\r\n            _stakingContractRegister(_msgSender(), contractAddress, false);\r\n        }\r\n    }\r\n\r\n    function stakingContractsRegister(address[] calldata ownerAddresses, address[] calldata contractAddresses)\r\n        external\r\n        onlyOwner {\r\n        require(ownerAddresses.length != contractAddresses.length, \"ownerAddresses and contractAddresses should be same length\");\r\n\r\n        for (uint256 i = 0; i < contractAddresses.length; i++) {\r\n            address contractAddress = contractAddresses[i];\r\n            address ownerAddress = ownerAddresses[i];\r\n            _stakingContractRegister(ownerAddress, contractAddress, true);\r\n        }\r\n    }\r\n\r\n    function stakingContractsUnregister(address[] calldata contractAddresses) external {\r\n        for (uint256 i = 0; i < contractAddresses.length; i++) {\r\n            address contractAddress = contractAddresses[i];\r\n            stakingContractUnregister(contractAddress);\r\n        }\r\n    }\r\n\r\n    function stakingContractRegister(address contractAddress) external {\r\n        _stakingContractRegister(_msgSender(), contractAddress, false);\r\n    }\r\n\r\n    function setStakingContract(address ownerAddress, address contractAddress)\r\n        external\r\n        onlyOwner {\r\n        _stakingContractRegister(ownerAddress, contractAddress, true);\r\n    }\r\n    \r\n    function _stakingContractRegister(address ownerAddress, address contractAddress, bool isConfirmed) private {\r\n        require(ownerAddress != address(0), \"contractAddress should not be the zero address\");\r\n        require(contractAddress != address(0), \"contractAddress should not be the zero address\");\r\n        require(contractAddress != address(this), \"contractAddress not be this contract\");\r\n        \r\n        address depositor = everStake.getDepositorAddrss(contractAddress);\r\n        if (!registeredContracts[depositor][contractAddress]) {\r\n            require(depositor == ownerAddress, \"ownerAddress is not the depositor of this stake\");\r\n\r\n            registeredContracts[depositor][contractAddress] = true;\r\n            registeredContractList[depositor].push(contractAddress);\r\n        }\r\n\r\n        if (isConfirmed && !confirmedContracts[contractAddress]) {\r\n            allConfirmedContracts.push(contractAddress);\r\n            confirmedContracts[contractAddress] = true;\r\n        }\r\n    }\r\n\r\n    function stakingContractUnregister(address contractAddress) public {\r\n        require(\r\n            registeredContracts[_msgSender()][contractAddress],\r\n            \"contractAddress is not registered staking contract\"\r\n        );\r\n\r\n        _stakingContractUnregister(_msgSender(), contractAddress, false);\r\n    }\r\n\r\n    function unsetStakingContract(address ownerAddress, address contractAddress)\r\n        external\r\n        onlyOwner {\r\n        _stakingContractUnregister(ownerAddress, contractAddress, true);\r\n    }\r\n    \r\n    function _stakingContractUnregister(address ownerAddress, address contractAddress, bool isUnconfirmed) private {\r\n        if (registeredContracts[ownerAddress][contractAddress]){\r\n            registeredContracts[ownerAddress][contractAddress] = false;\r\n            address[] storage stakedList = registeredContractList[ownerAddress];\r\n\r\n            for (uint256 i = 0; i < stakedList.length; i++) {\r\n                if (stakedList[i] == contractAddress) {\r\n                    stakedList[i] = stakedList[stakedList.length - 1];\r\n                    stakedList.pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isUnconfirmed && confirmedContracts[contractAddress]) {\r\n            confirmedContracts[contractAddress] = false;\r\n            for (uint256 i = 0; i < allConfirmedContracts.length; i++) {\r\n                if (allConfirmedContracts[i] == contractAddress) {\r\n                    allConfirmedContracts[i] = allConfirmedContracts[allConfirmedContracts.length - 1];\r\n                    allConfirmedContracts.pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    struct Stats {\r\n        uint256 reservesBalance;\r\n        uint256 liquidityToken;\r\n        uint256 liquidityCoin;\r\n        uint256 staked;\r\n        uint256 aveMultiplier;\r\n        uint256 rewards;\r\n        uint256 volumeTransfers;\r\n        uint256 volumeBuy;\r\n        uint256 volumeSell;\r\n        uint256 volumeTrade;\r\n        uint256 bridgeVault;\r\n        uint256 tokenPriceCoin;\r\n        uint256 coinPriceStable;\r\n        uint256 tokenPriceStable;\r\n        uint256 marketCap;\r\n        uint128 blockNumber;\r\n        uint32 holders;\r\n        uint8 tokenDecimals;\r\n        uint8 coinDecimals;\r\n        uint8 stableDecimals;\r\n        uint8 multiplierDecimals;\r\n    }\r\n\r\n    function getStats() external view returns (Stats memory stats) {\r\n        (uint256 liquidityToken,\r\n        uint256 liquidityCoin,\r\n        uint256 coinPriceStable,\r\n        uint8 stableDecimals,\r\n        uint256 tokenPriceCoin,\r\n        uint256 tokenPriceStable) = getTokenPrices();\r\n\r\n        uint256 buyVolume = everRise.totalBuyVolume();\r\n        uint256 sellVolume = everRise.totalSellVolume();\r\n        uint256 tradeVolume = buyVolume.add(sellVolume);\r\n\r\n        uint256 totalAmountStaked = everRise.getTotalAmountStaked();\r\n        uint256 aveMultiplier = everStake\r\n            .totalSupply()\r\n            .sub(everStake.balanceOf(everStakeAddress))\r\n            .mul(10 ** 8)\r\n            .div(totalAmountStaked);\r\n\r\n        uint256 marketCap = tokenPriceStable.mul(everRise.totalSupply()).div(tokenDivisor);\r\n\r\n        stats = Stats(\r\n            everRiseAddress.balance,\r\n            liquidityToken,\r\n            liquidityCoin,\r\n            totalAmountStaked,\r\n            aveMultiplier,\r\n            everRise.getTotalRewardsDistributed(),\r\n            everRise.totalVolume(),\r\n            buyVolume,\r\n            sellVolume,\r\n            tradeVolume,\r\n            everRise.balanceOf(everBridgeVaultAddress),\r\n            tokenPriceCoin,\r\n            coinPriceStable,\r\n            tokenPriceStable,\r\n            marketCap,\r\n            uint128(block.number),\r\n            uint32(everRise.holders()),\r\n            tokenDecimals,\r\n            coinDecimals,\r\n            stableDecimals,\r\n            8\r\n        );\r\n\r\n        return stats;\r\n    }\r\n\r\n    function getTokenPrices() public view returns (\r\n        uint256 liquidityToken,\r\n        uint256 liquidityCoin,\r\n        uint256 coinPriceStable,\r\n        uint8 stableDecimals,\r\n        uint256 tokenPriceCoin,\r\n        uint256 tokenPriceStable) {\r\n        liquidityToken = everRise.balanceOf(pairAddress);\r\n        liquidityCoin = wrappedCoin.balanceOf(pairAddress);\r\n\r\n        (coinPriceStable, stableDecimals) = getCoinPrice();\r\n        tokenPriceCoin = liquidityCoin.mul(tokenDivisor).div(liquidityToken);\r\n\r\n        tokenPriceStable = tokenPriceCoin.mul(coinPriceStable).div(coinDivisor);\r\n    }\r\n    \r\n    function getListOfRegisteredStakes(address forAddress) external view returns (address[] memory) {\r\n        return registeredContractList[forAddress];\r\n    }\r\n\r\n    struct StakeDetails {\r\n        string stakeName;\r\n        uint256 remainingAmountStaked;\r\n        uint256 withdrawAmount;\r\n        uint256 maxAmountAllowedToWithdraw;\r\n        uint256 depositTokens;\r\n        uint256 lockTime;\r\n        uint256 depositTime;\r\n        uint256 numOfMonths;\r\n        uint256 currentBalance;\r\n        uint256 currentBalanceStable;\r\n        uint256 reflectionsBalance;\r\n        address depositorAddress;\r\n        address altOwner;\r\n        uint8 stableDecimals;\r\n        bool status;\r\n        bool registration;\r\n    }\r\n\r\n    function getStakeDetails(address stakingAddress) external view returns (StakeDetails memory stakeDetails)\r\n    {\r\n        IEverStake stake = IEverStake(stakingAddress);\r\n\r\n        (,,,uint8 stableDecimals,, uint256 tokenPriceStable) = getTokenPrices();\r\n        uint256 currentBalance = stake.getCurrentBalance();\r\n        uint256 currentBalanceStable = currentBalance.mul(tokenPriceStable).div(tokenDivisor);\r\n\r\n        stakeDetails = StakeDetails(\r\n            stake.getStakeName(),\r\n            stake.getRemainingAmountStaked(),\r\n            stake.getWithdrawAmount(),\r\n            stake.getMaxAmountAllowedToWithdraw(),\r\n            stake.getDepositTokens(),\r\n            stake.getLockTime(),\r\n            stake.getDepositTime(),\r\n            stake.getNumOfMonths(),\r\n            currentBalance,\r\n            currentBalanceStable,\r\n            stake.getReflectionsBalance(),\r\n            stake.getDepositorAddress(),\r\n            stake.getAltOwner(),\r\n            stableDecimals,\r\n            stake.getStatus(),\r\n            isRegistered(_msgSender(), stakingAddress)\r\n        );\r\n\r\n        return stakeDetails;\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256){\r\n        address[] storage stakedList = registeredContractList[account];\r\n        \r\n        uint256 balance = 0;\r\n        for (uint256 i = 0; i < stakedList.length; i++) {\r\n            balance = balance.add(IEverStake(stakedList[i]).getCurrentBalance());\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    function isRegistered(address account, address contractAddress) public view returns (bool) {\r\n        return registeredContracts[account][contractAddress];\r\n    }\r\n\r\n    function setEverBridgeVaultAddress(address _everBridgeVaultAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _everBridgeVaultAddress != address(0),\r\n            \"_everBridgeVaultAddress should not be the zero address\"\r\n        );\r\n        \r\n        emit EverBridgeVaultAddressUpdated(everBridgeVaultAddress, _everBridgeVaultAddress);\r\n\r\n        everBridgeVaultAddress = _everBridgeVaultAddress;\r\n    }\r\n\r\n    function setEverRiseAddress(address _everRiseAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _everRiseAddress != address(0),\r\n            \"_everRiseAddress should not be the zero address\"\r\n        );\r\n\r\n        emit EverRiseAddressUpdated(everRiseAddress, _everRiseAddress);\r\n\r\n        everRiseAddress = _everRiseAddress;\r\n        everRise = IEverRise(_everRiseAddress);\r\n        \r\n        init();\r\n    }\r\n\r\n    function setUsdOracleAddress(address _usdOracleAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _usdOracleAddress != address(0),\r\n            \"_usdOracleAddress should not be the zero address\"\r\n        );\r\n\r\n        emit UsdOracleAddressUpdated(usdOracleAddress, _usdOracleAddress);\r\n\r\n        usdOracleAddress = _usdOracleAddress;\r\n        usdOracle = AggregatorV3Interface(_usdOracleAddress);\r\n    }\r\n\r\n    function setCoinStablePairAddress(address _coinStablePairAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _coinStablePairAddress != address(0),\r\n            \"_coinStablePairAddress should not be the zero address\"\r\n        );\r\n\r\n        emit CoinStablePairAddressUpdated(coinStablePairAddress, _coinStablePairAddress);\r\n\r\n        coinStablePairAddress = _coinStablePairAddress;\r\n        coinStablePair = IUniswapV2Pair(_coinStablePairAddress);\r\n        \r\n        init();\r\n    }\r\n\r\n    function setEverStakeAddress(address _everStakeAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _everStakeAddress != address(0),\r\n            \"_everStakeAddress should not be the zero address\"\r\n        );\r\n\r\n        emit EverStakeAddressUpdated(everStakeAddress, _everStakeAddress);\r\n\r\n        everStakeAddress = _everStakeAddress;\r\n        everStake = IEverStakeFactory(_everStakeAddress);\r\n    }\r\n\r\n    function getCoinPrice() public view returns (uint256 coinPrice, uint8 usdDecimals) {\r\n        try usdOracle.latestRoundData() returns (\r\n            uint80,         // roundID\r\n            int256 price,   // price\r\n            uint256,        // startedAt\r\n            uint256,        // timestamp\r\n            uint80          // answeredInRound\r\n        ) {\r\n            coinPrice = uint256(price);\r\n            usdDecimals = usdOracle.decimals();\r\n        } catch Error(string memory) {\r\n            (coinPrice, usdDecimals) = getCoinPriceFallback();\r\n        }\r\n    }\r\n\r\n    function getCoinPriceFallback() public view returns (uint256 coinPrice, uint8 usdDecimals) {\r\n        coinPrice = stableToken\r\n            .balanceOf(coinStablePairAddress)\r\n            .mul(coinDivisor)\r\n            .div(wrappedCoin.balanceOf(coinStablePairAddress));\r\n        usdDecimals = stableToken.decimals();\r\n    }\r\n\r\n    // Function to receive ETH when msg.data is be empty\r\n    // Receives ETH from uniswapV2Router when swapping\r\n    receive() external payable {}\r\n\r\n    // Fallback function to receive ETH when msg.data is not empty\r\n    fallback() external payable {}\r\n \r\n    function transferExternalTokens(address tokenAddress, address toAddress) external onlyOwner {\r\n        require(tokenAddress != address(0), \"Token Address can not be a zero address\");\r\n        require(toAddress != address(0), \"To Address can not be a zero address\");\r\n        require(IERC20(tokenAddress).balanceOf(address(this)) > 0, \"Balance is zero\");\r\n        IERC20(tokenAddress).transfer(toAddress, IERC20(tokenAddress).balanceOf(address(this)));\r\n    }\r\n\r\n    function transferToAddressETH(address payable recipient) external onlyOwner {\r\n        recipient.transfer(address(this).balance);\r\n    }\r\n}"
    }
  }
}