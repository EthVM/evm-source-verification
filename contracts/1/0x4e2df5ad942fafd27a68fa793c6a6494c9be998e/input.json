{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RealNFT.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Access control contract.\r\n/// @author Adapted from https://github.com/sushiswap/trident/blob/master/contracts/utils/TridentOwnable.sol.\r\nabstract contract LexOwnable {\r\n    address public owner;\r\n    address public pendingOwner;\r\n\r\n    event TransferOwner(address indexed sender, address indexed recipient);\r\n    event TransferOwnerClaim(address indexed sender, address indexed recipient);\r\n\r\n    /// @notice Initialize and grant deployer account (`msg.sender`) `owner` access role.\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit TransferOwner(address(0), msg.sender);\r\n    }\r\n\r\n    /// @notice Access control modifier that conditions modified function to be called by `owner` account.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /// @notice `pendingOwner` can claim `owner` account.\r\n    function claimOwner() external {\r\n        require(msg.sender == pendingOwner, \"NOT_PENDING_OWNER\");\r\n        emit TransferOwner(owner, msg.sender);\r\n        owner = msg.sender;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /// @notice Transfer `owner` account.\r\n    /// @param recipient Account granted `owner` access control.\r\n    /// @param direct If 'true', ownership is directly transferred.\r\n    function transferOwner(address recipient, bool direct) external onlyOwner {\r\n        require(recipient != address(0), \"ZERO_ADDRESS\");\r\n        if (direct) {\r\n            owner = recipient;\r\n            emit TransferOwner(msg.sender, recipient);\r\n        } else {\r\n            pendingOwner = recipient;\r\n            emit TransferOwnerClaim(msg.sender, recipient);\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Function pausing contract.\r\nabstract contract LexPausable is LexOwnable {\r\n    event SetPause(bool indexed paused);\r\n    \r\n    bool public paused;\r\n    \r\n    /// @notice Initialize contract with `paused` status.\r\n    constructor(bool _paused) {\r\n        paused = _paused;\r\n        emit SetPause(_paused);\r\n    }\r\n    \r\n    /// @notice Function pausability modifier.\r\n    modifier notPaused() {\r\n        require(!paused, \"PAUSED\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice Sets function pausing status.\r\n    /// @param _paused If 'true', modified functions are paused.\r\n    function setPause(bool _paused) external onlyOwner {\r\n        paused = _paused;\r\n        emit SetPause(_paused);\r\n    }\r\n}\r\n\r\n/// @notice Function whitelisting contract.\r\nabstract contract LexWhitelistable is LexOwnable {\r\n    event ToggleWhiteList(bool indexed whitelistEnabled);\r\n    event UpdateWhitelist(address indexed account, bool indexed whitelisted);\r\n    \r\n    bool public whitelistEnabled; \r\n    mapping(address => bool) public whitelisted; \r\n    \r\n    /// @notice Initialize contract with `whitelistEnabled` status.\r\n    constructor(bool _whitelistEnabled) {\r\n        whitelistEnabled = _whitelistEnabled;\r\n        emit ToggleWhiteList(_whitelistEnabled);\r\n    }\r\n    \r\n    /// @notice Whitelisting modifier that conditions modified function to be called between `whitelisted` accounts.\r\n    modifier onlyWhitelisted(address from, address to) {\r\n        if (whitelistEnabled) \r\n        require(whitelisted[from] && whitelisted[to], \"NOT_WHITELISTED\");\r\n        _;\r\n    }\r\n    \r\n    /// @notice Update account `whitelisted` status.\r\n    /// @param account Account to update.\r\n    /// @param _whitelisted If 'true', `account` is `whitelisted`.\r\n    function updateWhitelist(address account, bool _whitelisted) external onlyOwner {\r\n        whitelisted[account] = _whitelisted;\r\n        emit UpdateWhitelist(account, _whitelisted);\r\n    }\r\n    \r\n    /// @notice Toggle `whitelisted` conditions on/off.\r\n    /// @param _whitelistEnabled If 'true', `whitelisted` conditions are on.\r\n    function toggleWhitelist(bool _whitelistEnabled) external onlyOwner {\r\n        whitelistEnabled = _whitelistEnabled;\r\n        emit ToggleWhiteList(_whitelistEnabled);\r\n    }\r\n}\r\n\r\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation\r\n// - Designed for tokenizing realness by RealDAO with ownership, pausing, and whitelisting.\r\ncontract RealNFT is LexOwnable, LexPausable, LexWhitelistable {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    string public constant name = \"RealNFT\";\r\n    string public constant symbol = \"REAL\";\r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(uint256 => address) public ownerOf;\r\n    mapping(uint256 => string) public tokenURI;\r\n    mapping(uint256 => address) public getApproved;\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n    \r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_ALL_TYPEHASH = \r\n        keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\r\n    \r\n    uint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;\r\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\r\n\r\n    mapping(uint256 => uint256) public nonces;\r\n    mapping(address => uint256) public noncesForAll;\r\n    \r\n    constructor() LexPausable(false) LexWhitelistable(true) {\r\n        DOMAIN_SEPARATOR_CHAIN_ID = block.chainid;\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator();\r\n    }\r\n    \r\n    function _calculateDomainSeparator() internal view returns (bytes32 domainSeperator) {\r\n        domainSeperator = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                block.chainid,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n    \r\n    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {\r\n        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator();\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\r\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\r\n    }\r\n    \r\n    function approve(address spender, uint256 tokenId) external {\r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_APPROVED\");\r\n        \r\n        getApproved[tokenId] = spender;\r\n        \r\n        emit Approval(owner, spender, tokenId); \r\n    }\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        \r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n    \r\n    function transfer(address to, uint256 tokenId) external notPaused onlyWhitelisted(msg.sender, to) {\r\n        require(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\r\n        /// @dev This is safe because ownership is checked\r\n        // against decrement, and sum of all user\r\n        // balances can't exceed 'type(uint256).max'.\r\n        unchecked {\r\n            balanceOf[msg.sender]--; \r\n        \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        emit Transfer(msg.sender, to, tokenId); \r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public notPaused onlyWhitelisted(from, to) {\r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(from == owner, \"FROM_NOT_OWNER\");\r\n        require(\r\n            msg.sender == owner \r\n            || msg.sender == getApproved[tokenId]\r\n            || isApprovedForAll[owner][msg.sender], \r\n            \"NOT_APPROVED\"\r\n        );\r\n        /// @dev This is safe because ownership is checked\r\n        // against decrement, and sum of all user\r\n        // balances can't exceed 'type(uint256).max'.\r\n        unchecked { \r\n            balanceOf[owner]--; \r\n        \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        emit Transfer(owner, to, tokenId); \r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\r\n        transferFrom(from, to, tokenId); \r\n        \r\n        if (to.code.length != 0) {\r\n            /// @dev selector = `onERC721Received(address,address,uint,bytes)`.\r\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\r\n                msg.sender, from, tokenId, data));\r\n                \r\n            bytes4 selector = abi.decode(returned, (bytes4));\r\n            \r\n            require(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\r\n        }\r\n    }\r\n    \r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n        \r\n        address owner = ownerOf[tokenId];\r\n        /// @dev This is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(recoveredAddress != address(0), \"INVALID_PERMIT_SIGNATURE\");\r\n            require(recoveredAddress == owner || isApprovedForAll[owner][recoveredAddress], \"INVALID_SIGNER\");\r\n        }\r\n        \r\n        getApproved[tokenId] = spender;\r\n\r\n        emit Approval(owner, spender, tokenId);\r\n    }\r\n    \r\n    function permitAll(\r\n        address owner,\r\n        address operator,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n        /// @dev This is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n            require(\r\n                (recoveredAddress != address(0) && recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress],\r\n                \"INVALID_PERMIT_SIGNATURE\"\r\n            );\r\n        }\r\n        \r\n        isApprovedForAll[owner][operator] = true;\r\n\r\n        emit ApprovalForAll(owner, operator, true);\r\n    }\r\n    \r\n    function mint(address to, uint256 tokenId, string memory _tokenURI) external onlyOwner { \r\n        require(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\r\n        /// @dev This is reasonably safe from overflow because incrementing `nonces` beyond\r\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits,\r\n        // and because the sum of all user balances can't exceed 'type(uint256).max'.\r\n        unchecked {\r\n            totalSupply++;\r\n            \r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        ownerOf[tokenId] = to;\r\n        \r\n        tokenURI[tokenId] = _tokenURI;\r\n        \r\n        emit Transfer(address(0), to, tokenId); \r\n    }\r\n    \r\n    function burn(uint256 tokenId) external onlyOwner { \r\n        address owner = ownerOf[tokenId];\r\n        \r\n        require(ownerOf[tokenId] != address(0), \"NOT_MINTED\");\r\n        /// @dev This is safe because a user won't ever\r\n        // have a balance larger than totalSupply.\r\n        unchecked {\r\n            totalSupply--;\r\n        \r\n            balanceOf[owner]--;\r\n        }\r\n        \r\n        delete ownerOf[tokenId];\r\n        \r\n        delete tokenURI[tokenId];\r\n        \r\n        emit Transfer(owner, address(0), tokenId); \r\n    }\r\n}"}}}