{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "/*\r\n██╗     ███████╗██╗  ██╗    \r\n██║     ██╔════╝╚██╗██╔╝    \r\n██║     █████╗   ╚███╔╝     \r\n██║     ██╔══╝   ██╔██╗     \r\n███████╗███████╗██╔╝ ██╗    \r\n╚══════╝╚══════╝╚═╝  ╚═╝                                                                             \r\n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗     \r\n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    \r\n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝    \r\n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    \r\n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    \r\n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\r\nDEAR MSG.SENDER(S):\r\n/ LXL is a project in beta\r\n// Please audit & use at your own risk\r\n/// Entry into LXL shall not create an attorney/client relationship\r\n//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel\r\n///// STEAL THIS C0D3SL4W \r\n~presented by LexDAO LLC \\+|+/ \r\n*/\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.7.5;\r\n\r\ninterface IERC20 { // brief interface for erc20 token tx\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\r\n    using Address for address;\r\n    \r\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\r\n    }\r\n    \r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returnData) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returnData.length > 0) { // return data is optional\r\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath { // arithmetic wrapper for unit under/overflow check\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Context { // describe current contract execution context (metaTX support) - see openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard { // call wrapper for reentrancy check - see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @title LexLocker.\r\n * @author LexDAO LLC.\r\n * @notice Token locker registry with embedded terms and resolution protocol. \r\n */\r\ncontract LexLocker is Context, ReentrancyGuard { \r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /*$<⚖️️> LXL <⚔️>$*/\r\n    address public manager; // account managing LXL settings - see 'Manager Functions' - updateable by manager\r\n    address public swiftResolverToken; // token required to participate as swift resolver - updateable by manager\r\n    address public userRewardToken; // token for LXL user rewards - updateable by manager\r\n    address public wETH; // ether token wrapper contract reference - updateable by manager\r\n    uint256 public lockerCount; // lockers counted into LXL registry\r\n    uint256 public MAX_DURATION; // time limit in seconds on token lockup - default 63113904 (2-year) - updateable by manager\r\n    uint256 public resolutionRate; // rate to determine resolution fee for disputed locker (e.g., 20 = 5% of remainder) - updateable by manager\r\n    uint256 public swiftResolverTokenBalance; // balance required in `swiftResolverToken` to participate as swift resolver - updateable by manager\r\n    uint256 public userReward; // reward amount granted to LXL users in `userRewardToken`- updateable by manager\r\n    string public lockerTerms; // general terms wrapping LXL - updateable by manager\r\n    string[] public marketTerms; // embedded market LXL terms - attach to locker `details` (e.g., \"MT:1\") - updateable by manager\r\n    string[] public resolutions; // locker resolutions stamped by LXL resolvers\r\n    \r\n    mapping(address => uint256[]) private registrations; // tracks registered lockers per account (client/provider)\r\n    mapping(address => bool) public swiftResolverRegistrations; // tracks registered swift resolvers\r\n    mapping(uint256 => ADR) public adrs; // tracks ADR details for registered lockers\r\n    mapping(uint256 => Locker) public lockers; // tracks registered lockers details\r\n    \r\n    event DepositLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\r\n    event RegisterLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\r\n    event ConfirmLocker(address token, uint256 registration, uint256 sum); \r\n    event RequestLockerResolution(address indexed client, address indexed counterparty, address indexed resolver, address token, uint256 registration, uint256 sum, string details, bool swiftResolver); \r\n    event Release(uint256 milestone, uint256 payment, uint256 registration); \r\n    event Withdraw(address indexed client, uint256 registration);\r\n    event AssignClientOracle(address indexed clientOracle, uint256 registration);\r\n    event ClientProposeResolver(address indexed proposedResolver, uint256 registration, string details);\r\n    event ProviderProposeResolver(address indexed proposedResolver, uint256 registration, string details);\r\n    event UpdateSwiftResolverStatus(address indexed swiftResolver, string details, bool registered);\r\n    event Lock(address indexed caller, uint256 registration, string details);\r\n    event Resolve(address indexed resolver, uint256 clientAward, uint256 providerAward, uint256 registration, uint256 resolutionFee, string resolution); \r\n    event AddMarketTerms(uint256 index, string terms);\r\n    event AmendMarketTerms(uint256 index, string terms);\r\n    event UpdateLockerSettings(address indexed manager, address swiftResolverToken, address userRewardToken, address wETH, uint256 MAX_DURATION, uint256 resolutionRate, uint256 swiftResolverTokenBalance, uint256 userReward, string lockerTerms);\r\n    event TributeToManager(address indexed caller, uint256 amount, string details);\r\n\r\n    struct ADR {  \r\n        address proposedResolver;\r\n        address resolver;\r\n        uint8 clientProposedResolver;\r\n        uint8 providerProposedResolver;\r\n        uint256 clientAward;\r\n        uint256 providerAward;\r\n\t    uint256 resolutionRate;\r\n\t    string resolution;\r\n\t    bool swiftResolver;\r\n    }\r\n    \r\n    struct Locker {  \r\n        address client; \r\n        address clientOracle;\r\n        address provider;\r\n        address token;\r\n        uint8 confirmed;\r\n        uint8 locked;\r\n        uint256[] amount;\r\n        uint256 currentMilestone;\r\n        uint256 milestones;\r\n        uint256 released;\r\n        uint256 sum;\r\n        uint256 termination;\r\n        string details; \r\n    }\r\n    \r\n    constructor(\r\n        address _manager, \r\n        address _swiftResolverToken,\r\n        address _userRewardToken,\r\n        address _wETH,\r\n        uint256 _MAX_DURATION,\r\n        uint256 _resolutionRate, \r\n        uint256 _swiftResolverTokenBalance, \r\n        uint256 _userReward,\r\n        string memory _lockerTerms\r\n    ) {\r\n        manager = _manager;\r\n        swiftResolverToken = _swiftResolverToken;\r\n        userRewardToken = _userRewardToken;\r\n        wETH = _wETH;\r\n        MAX_DURATION = _MAX_DURATION;\r\n        resolutionRate = _resolutionRate;\r\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\r\n        userReward = _userReward;\r\n        lockerTerms = _lockerTerms;\r\n    }\r\n\r\n    /***************\r\n    LOCKER FUNCTIONS\r\n    ***************/\r\n    // ************\r\n    // REGISTRATION\r\n    // ************\r\n    /**\r\n     * @notice LXL can be registered as deposit from `client` for benefit of `provider`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param provider Account to receive registered `amount`s.\r\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\r\n     * @param token Token address for `amount` deposit.\r\n     * @param amount Array of milestone `amount`s to be sent to `provider` on call of `release()`.\r\n     * @param termination Exact `termination` date in seconds since epoch.\r\n     * @param details Context re: LXL.\r\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function depositLocker( // CLIENT-TRACK\r\n        address clientOracle, \r\n        address provider,\r\n        address resolver,\r\n        address token,\r\n        uint256[] memory amount, \r\n        uint256 termination, \r\n        string memory details,\r\n        bool swiftResolver \r\n    ) external nonReentrant payable returns (uint256) {\r\n        require(_msgSender() != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\r\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\r\n        \r\n        uint256 sum;\r\n        for (uint256 i = 0; i < amount.length; i++) {\r\n            sum = sum.add(amount[i]);\r\n        }\r\n\r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).safeTransfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\r\n        }\r\n        \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[_msgSender()].push(registration);\r\n        registrations[provider].push(registration);\r\n        \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n\r\n        lockers[registration] = Locker( \r\n            _msgSender(), \r\n            clientOracle,\r\n            provider,\r\n            token,\r\n            1,\r\n            0,\r\n            amount,\r\n            1,\r\n            amount.length,\r\n            0,\r\n            sum,\r\n            termination,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).safeTransfer(_msgSender(), userReward);} // grant user reward\r\n\r\n        emit DepositLocker(_msgSender(), clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL can be registered as single deposit (lump sum) from `client` for benefit of `provider`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param provider Account to receive registered `amount`s.\r\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\r\n     * @param token Token address for `amount` deposit.\r\n     * @param sum Lump `sum` to be sent to `provider` on call of `release()`.\r\n     * @param termination Exact `termination` date in seconds since epoch.\r\n     * @param details Context re: LXL.\r\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function depositLockerSingleMilestone( // CLIENT-TRACK\r\n        address clientOracle, \r\n        address provider,\r\n        address resolver,\r\n        address token,\r\n        uint256 sum, \r\n        uint256 termination, \r\n        string calldata details,\r\n        bool swiftResolver \r\n    ) external nonReentrant payable returns (uint256) {\r\n        require(_msgSender() != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\r\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\r\n        \r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).safeTransfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\r\n        }\r\n        \r\n        uint256[] memory amount = new uint256[](1);\r\n        amount[0] = sum;\r\n        \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[_msgSender()].push(registration);\r\n        registrations[provider].push(registration);\r\n        \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n\r\n        lockers[registration] = Locker( \r\n            _msgSender(), \r\n            clientOracle,\r\n            provider,\r\n            token,\r\n            1,\r\n            0,\r\n            amount,\r\n            1,\r\n            1,\r\n            0,\r\n            sum,\r\n            termination,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).safeTransfer(_msgSender(), userReward);} // grant user reward\r\n\r\n        emit DepositLocker(_msgSender(), clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL can be registered as `provider` request for `client` deposit (by calling `confirmLocker()`).\r\n     * @param client Account to provide `sum` deposit and call `release()` of registered `amount`s.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param provider Account to receive registered `amount`s.\r\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\r\n     * @param token Token address for `amount` deposit.\r\n     * @param amount Array of milestone `amount`s to be sent to `provider` on call of `release()`.\r\n     * @param termination Exact `termination` date in seconds since epoch.\r\n     * @param details Context re: LXL.\r\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function registerLocker( // PROVIDER-TRACK\r\n        address client,\r\n        address clientOracle, \r\n        address provider,\r\n        address resolver,\r\n        address token,\r\n        uint256[] memory amount, \r\n        uint256 termination, \r\n        string memory details,\r\n        bool swiftResolver \r\n    ) external nonReentrant returns (uint256) {\r\n        require(client != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\r\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\r\n        \r\n        uint256 sum;\r\n        for (uint256 i = 0; i < amount.length; i++) {\r\n            sum = sum.add(amount[i]);\r\n        }\r\n \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[client].push(registration);\r\n        registrations[provider].push(registration);\r\n       \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n\r\n        lockers[registration] = Locker( \r\n            client, \r\n            clientOracle,\r\n            provider,\r\n            token,\r\n            0,\r\n            0,\r\n            amount,\r\n            1,\r\n            amount.length,\r\n            0,\r\n            sum,\r\n            termination,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).safeTransfer(_msgSender(), userReward);} // grant user reward\r\n\r\n        emit RegisterLocker(client, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL `client` can confirm after `registerLocker()` is called to deposit `sum` for `provider`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\r\n     * @param registration Registered LXL number.\r\n     */\r\n    function confirmLocker(uint256 registration) external nonReentrant payable { // PROVIDER-TRACK\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        require(_msgSender() == locker.client, \"!client\");\r\n        require(locker.confirmed == 0, \"confirmed\");\r\n        \r\n        address token = locker.token;\r\n        uint256 sum = locker.sum;\r\n        \r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).safeTransfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\r\n        }\r\n        \r\n        locker.confirmed = 1;\r\n        \r\n        emit ConfirmLocker(token, registration, sum); \r\n    }\r\n    \r\n    /**\r\n     * @notice LXL depositor (`client`) can request direct resolution between selected `counterparty` over `sum`. E.g., staked wager to benefit charity as `counterparty`.\r\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call. \r\n     * @param counterparty Other account (`provider`) that can receive award from `resolver`.\r\n     * @param resolver Account that can call `resolve()` to award `sum` between LXL parties.\r\n     * @param token Token address for `sum`.\r\n     * @param sum Lump `sum` amount for resolution.\r\n     * @param details Context re: resolution request.\r\n     * @param swiftResolver If `true`, `sum` can be resolved by holders of `swiftResolverToken`.\r\n     */\r\n    function requestLockerResolution(address counterparty, address resolver, address token, uint256 sum, string calldata details, bool swiftResolver) external nonReentrant payable returns (uint256) {\r\n        require(_msgSender() != resolver && counterparty != resolver, \"client/counterparty = resolver\");\r\n        \r\n        if (msg.value > 0) {\r\n            address weth = wETH;\r\n            require(token == weth && msg.value == sum, \"!ethBalance\");\r\n            (bool success, ) = weth.call{value: msg.value}(\"\");\r\n            require(success, \"!ethCall\");\r\n            IERC20(weth).safeTransfer(address(this), msg.value);\r\n        } else {\r\n            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\r\n        }\r\n        \r\n        uint256[] memory amount = new uint256[](1);\r\n        amount[0] = sum;\r\n        \r\n        lockerCount++;\r\n        uint256 registration = lockerCount;\r\n        \r\n        registrations[_msgSender()].push(registration);\r\n        registrations[counterparty].push(registration);\r\n        \r\n        adrs[registration] = ADR( \r\n            address(0),\r\n            resolver,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n\t        resolutionRate, \r\n\t        \"\",\r\n\t        swiftResolver);\r\n     \r\n        lockers[registration] = Locker( \r\n            _msgSender(), \r\n            address(0),\r\n            counterparty,\r\n            token,\r\n            1,\r\n            1,\r\n            amount,\r\n            0,\r\n            0,\r\n            0,\r\n            sum,\r\n            0,\r\n            details);\r\n        \r\n        if (userReward > 0) {IERC20(userRewardToken).safeTransfer(_msgSender(), userReward);} // grant user reward\r\n\r\n        emit RequestLockerResolution(_msgSender(), counterparty, resolver, token, registration, sum, details, swiftResolver); \r\n        \r\n\t    return registration;\r\n    }\r\n    \r\n    // ***********\r\n    // CLIENT MGMT\r\n    // ***********\r\n    /**\r\n     * @notice LXL `client` can assign account as `clientOracle` to help call `release()` and `withdraw()`.\r\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\r\n     * @param registration Registered LXL number.\r\n     */\r\n    function assignClientOracle(address clientOracle, uint256 registration) external nonReentrant {\r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        require(_msgSender() == locker.client, \"!client\");\r\n        require(clientOracle != adr.resolver, \"clientOracle = resolver\");\r\n        require(locker.locked == 0, \"locked\");\r\n\t    require(locker.released < locker.sum, \"released\");\r\n        \r\n        locker.clientOracle = clientOracle;\r\n        \r\n        emit AssignClientOracle(clientOracle, registration);\r\n    }\r\n    \r\n    /**\r\n     * @notice LXL `client` or `clientOracle` can release milestone `amount` to `provider`. \r\n     * @param registration Registered LXL number.\r\n     */\r\n    function release(uint256 registration) external nonReentrant {\r\n    \tLocker storage locker = lockers[registration];\r\n    \t\r\n    \tuint256 milestone = locker.currentMilestone-1;\r\n        uint256 payment = locker.amount[milestone];\r\n        uint256 released = locker.released;\r\n        uint256 sum = locker.sum;\r\n\t    \r\n\t    require(_msgSender() == locker.client || _msgSender() == locker.clientOracle, \"!client/oracle\");\r\n\t    require(locker.confirmed == 1, \"!confirmed\");\r\n\t    require(locker.locked == 0, \"locked\");\r\n\t    require(released < sum, \"released\");\r\n\r\n        IERC20(locker.token).safeTransfer(locker.provider, payment);\r\n        locker.released = released.add(payment);\r\n        \r\n        if (locker.released < sum) {locker.currentMilestone++;}\r\n        \r\n\t    emit Release(milestone+1, payment, registration); \r\n    }\r\n    \r\n    /**\r\n     * @notice LXL `client` or `clientOracle` can withdraw `sum` remainder after `termination`. \r\n     * @dev `release()` can still be called by `client` or `clientOracle` after `termination` to preserve extension option. \r\n     * @param registration Registered LXL number.\r\n     */\r\n    function withdraw(uint256 registration) external nonReentrant {\r\n    \tLocker storage locker = lockers[registration];\r\n    \t\r\n    \taddress client = locker.client;\r\n    \tuint256 released = locker.released;\r\n    \tuint256 sum = locker.sum;\r\n        \r\n        require(_msgSender() == client || _msgSender() == locker.clientOracle, \"!client/oracle\");\r\n        require(locker.confirmed == 1, \"!confirmed\");\r\n        require(locker.locked == 0, \"locked\");\r\n        require(released < sum, \"released\");\r\n        require(locker.termination < block.timestamp, \"!terminated\");\r\n        \r\n        IERC20(locker.token).safeTransfer(client, sum.sub(released));\r\n        locker.released = sum; \r\n        \r\n\t    emit Withdraw(client, registration); \r\n    }\r\n    \r\n    // **********\r\n    // RESOLUTION\r\n    // **********\r\n    /**\r\n     * @notice LXL `client` or `provider` can lock to freeze release and withdrawal of `sum` remainder until `resolver` calls `resolve()`. \r\n     * @dev `lock()` can be called repeatedly to allow LXL parties to continue to provide context until resolution. \r\n     * @param registration Registered LXL number.\r\n     * @param details Context re: lock / dispute.\r\n     */\r\n    function lock(uint256 registration, string calldata details) external nonReentrant {\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(_msgSender() == locker.client || _msgSender() == locker.provider, \"!party\"); \r\n        require(locker.confirmed == 1, \"!confirmed\");\r\n        require(locker.released < locker.sum, \"released\");\r\n\r\n\t    locker.locked = 1; \r\n\t    \r\n\t    emit Lock(_msgSender(), registration, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice After LXL is locked, selected `resolver` awards `sum` remainder between `client` and `provider` minus fee.\r\n     * @param clientAward Remainder awarded to `client`.\r\n     * @param providerAward Remainder awarded to `provider`.\r\n     * @param registration Registered LXL number.\r\n     * @param resolution Context re: resolution.\r\n     */\r\n    function resolve(uint256 clientAward, uint256 providerAward, uint256 registration, string calldata resolution) external nonReentrant {\r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration];\r\n        \r\n        address token = locker.token;\r\n        uint256 released = locker.released;\r\n\t    uint256 sum = locker.sum;\r\n\t    // calculate resolution fee as set on registration:\r\n\t    uint256 remainder = sum.sub(released); \r\n\t    uint256 resolutionFee = remainder.div(adr.resolutionRate); \r\n\t    \r\n\t    require(locker.locked == 1, \"!locked\"); \r\n\t    require(released < sum, \"released\");\r\n\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), \"awards != remainder - fee\");\r\n\t    \r\n\t    if (adr.swiftResolver) {\r\n\t        require(_msgSender() != locker.client && _msgSender() != locker.provider, \"client/provider = swiftResolver\");\r\n\t        require(IERC20(swiftResolverToken).balanceOf(_msgSender()) >= swiftResolverTokenBalance && swiftResolverRegistrations[_msgSender()], \"!swiftResolverTokenBalance/registered\");\r\n        } else {\r\n            require(_msgSender() == adr.resolver, \"!resolver\");\r\n        }\r\n        \r\n        IERC20(token).safeTransfer(_msgSender(), resolutionFee);\r\n        IERC20(token).safeTransfer(locker.client, clientAward);\r\n        IERC20(token).safeTransfer(locker.provider, providerAward);\r\n        \r\n        adr.clientAward = clientAward;\r\n\t    adr.providerAward = providerAward;\r\n\t    adr.resolution = resolution;\r\n\t    locker.released = sum; \r\n\t    resolutions.push(resolution);\r\n\t    \r\n\t    emit Resolve(_msgSender(), clientAward, providerAward, registration, resolutionFee, resolution);\r\n    }\r\n    \r\n    /**\r\n     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\r\n     * @dev LXL `client` calls to update `resolver` selection - if matches `provider` suggestion or confirmed, `resolver` updates. \r\n     * @param proposedResolver Proposed account to resolve LXL.\r\n     * @param registration Registered LXL number.\r\n     * @param details Context re: proposed `resolver`.\r\n     */\r\n    function clientProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(_msgSender() == locker.client, \"!client\"); \r\n        require(_msgSender() != proposedResolver && locker.clientOracle != proposedResolver && locker.provider != proposedResolver, \"client/clientOracle/provider = proposedResolver\");\r\n        require(adr.clientProposedResolver == 0, \"pending\");\r\n\t    require(locker.released < locker.sum, \"released\");\r\n        \r\n        if (adr.proposedResolver == proposedResolver) {\r\n            adr.resolver = proposedResolver;\r\n        } \r\n\r\n\t    adr.proposedResolver = proposedResolver; \r\n\t    adr.clientProposedResolver = 1;\r\n\t    adr.providerProposedResolver = 0;\r\n\t    \r\n\t    emit ClientProposeResolver(proposedResolver, registration, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\r\n     * @dev LXL `provider` calls to update `resolver` selection - if matches `client` suggestion or confirmed, `resolver` updates. \r\n     * @param proposedResolver Proposed account to resolve LXL.\r\n     * @param registration Registered LXL number.\r\n     * @param details Context re: proposed `resolver`.\r\n     */\r\n    function providerProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \r\n        ADR storage adr = adrs[registration];\r\n        Locker storage locker = lockers[registration]; \r\n        \r\n        require(_msgSender() == locker.provider, \"!provider\"); \r\n        require(locker.client != proposedResolver && locker.clientOracle != proposedResolver && _msgSender() != proposedResolver, \"client/clientOracle/provider = proposedResolver\");\r\n        require(adr.providerProposedResolver == 0, \"pending\");\r\n\t    require(locker.released < locker.sum, \"released\");\r\n\r\n\t    if (adr.proposedResolver == proposedResolver) {\r\n            adr.resolver = proposedResolver;\r\n        } \r\n\t    \r\n\t    adr.proposedResolver = proposedResolver;\r\n\t    adr.clientProposedResolver = 0;\r\n\t    adr.providerProposedResolver = 1;\r\n\t    \r\n\t    emit ProviderProposeResolver(proposedResolver, registration, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice Swift resolvers call to update LXL service status.\r\n     * @dev Swift resolvers must first confirm to participate and can continue with details / cancel LXL service.  \r\n     * @param details Context re: status update.\r\n     * @param registered If `true`, swift resolver can participate in LXL resolution.\r\n     */\r\n    function updateSwiftResolverStatus(string calldata details, bool registered) external nonReentrant {\r\n        require(IERC20(swiftResolverToken).balanceOf(_msgSender()) >= swiftResolverTokenBalance, \"!swiftResolverTokenBalance\");\r\n        swiftResolverRegistrations[_msgSender()] = registered;\r\n        emit UpdateSwiftResolverStatus(_msgSender(), details, registered);\r\n    }\r\n    \r\n    // *******\r\n    // GETTERS\r\n    // *******\r\n    function latestLockerRegistration(address account) external view returns (uint256 latest) { // get latest registered locker per account\r\n        uint256[] memory registered = registrations[account];\r\n        if (registered.length == 0) {return 0;} else {return registered[registered.length-1];}\r\n    }\r\n    \r\n    function lockerRegistrations(address account) external view returns (uint256[] memory registered) { // get registered lockers per account\r\n        return registrations[account];\r\n    }\r\n    \r\n    function marketTermsCount() external view returns (uint256 count) { // get total market terms stamped by `manager`\r\n        return marketTerms.length;\r\n    }\r\n    \r\n    function providerAmounts(uint256 registration) external view returns (address token, uint256[] memory amount) { // get `token` and milestone `amount`s for `provider`\r\n        return (lockers[registration].token, lockers[registration].amount);\r\n    }\r\n    \r\n    function resolutionsCount() external view returns (uint256 count) { // get total resolutions passed by LXL `resolver`s\r\n        return resolutions.length;\r\n    }\r\n   \r\n    /****************\r\n    MANAGER FUNCTIONS\r\n    ****************/\r\n    /**\r\n     * @dev Throws if caller is not LXL `manager`.\r\n     */\r\n    modifier onlyManager {\r\n        require(_msgSender() == manager, \"!manager\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates LXL with new market `terms`. \r\n     * @param terms New `terms` to add to LXL market. \r\n     */\r\n    function addMarketTerms(string calldata terms) external nonReentrant onlyManager {\r\n        marketTerms.push(terms);\r\n        emit AddMarketTerms(marketTerms.length-1, terms);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates LXL with amended market `terms`. \r\n     * @param index Targeted location in `marketTerms` array.\r\n     * @param terms Amended `terms` to add to LXL market. \r\n     */\r\n    function amendMarketTerms(uint256 index, string calldata terms) external nonReentrant onlyManager {\r\n        marketTerms[index] = terms;\r\n        emit AmendMarketTerms(index, terms);\r\n    }\r\n    \r\n    /**\r\n     * @notice General ether payment function for `manager` of LXL contract. \r\n     * @param details Describes context for ether transfer.\r\n     */\r\n    function tributeToManager(string calldata details) external nonReentrant payable { \r\n        (bool success, ) = manager.call{value: msg.value}(\"\");\r\n        require(success, \"!ethCall\");\r\n        emit TributeToManager(_msgSender(), msg.value, details);\r\n    }\r\n    \r\n    /**\r\n     * @notice Updates LXL management settings.\r\n     * @param _manager Account that governs LXL contract settings.\r\n     * @param _swiftResolverToken Token to mark participants in swift resolution.\r\n     * @param _userRewardToken Token for LXL user rewards.\r\n     * @param _wETH Standard contract reference to wrap ether. \r\n     * @param _MAX_DURATION Time limit in seconds on token lockup - default 63113904 (2-year).\r\n     * @param _resolutionRate Rate to determine resolution fee for locker (e.g., 20 = 5% of remainder).\r\n     * @param _swiftResolverTokenBalance Token balance required to perform swift resolution. \r\n     * @param _userReward Reward amount granted to LXL users in `userRewardToken`.\r\n     * @param _lockerTerms General terms wrapping LXL.  \r\n     */\r\n    function updateLockerSettings(\r\n        address _manager, \r\n        address _swiftResolverToken, \r\n        address _userRewardToken,\r\n        address _wETH, \r\n        uint256 _MAX_DURATION, \r\n        uint256 _resolutionRate, \r\n        uint256 _swiftResolverTokenBalance,\r\n        uint256 _userReward,\r\n        string calldata _lockerTerms\r\n    ) external nonReentrant onlyManager { \r\n        manager = _manager;\r\n        swiftResolverToken = _swiftResolverToken;\r\n        userRewardToken = _userRewardToken;\r\n        wETH = _wETH;\r\n        MAX_DURATION = _MAX_DURATION;\r\n        resolutionRate = _resolutionRate;\r\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\r\n        userReward = _userReward;\r\n        lockerTerms = _lockerTerms;\r\n\t    \r\n\t    emit UpdateLockerSettings(_manager, _swiftResolverToken, _userRewardToken, _wETH, _MAX_DURATION, _resolutionRate, _swiftResolverTokenBalance, _userReward, _lockerTerms);\r\n    }\r\n}"
    }
  }
}