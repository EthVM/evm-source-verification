{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/qoph.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.0;\r\n\r\ncontract QOPh {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    string public constant name = \"QOPh\";\r\n    string public constant symbol = \"QOPh\";\r\n    uint256 public constant decimals = 18;\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);  \r\n    event Transfer(address indexed from, address indexed to, uint256 value); \r\n    \r\n    mapping (address => mapping (address => uint256)) private allowed;              \r\n    mapping (address => uint256) private balances; \r\n    uint256 private s2 = 1000000000000000000000000000000000000;\r\n    uint256 private s = 10000000000000000000;\r\n    uint256 private constant Q = 1000000000000000000;  //  one QOPh has 18 zeros\r\n    uint256 private st;                                //  (total) stack\r\n    uint256 private sQR;                               //  stack-QOPh-Ratio\r\n    uint256 private tS;                                //  total-Supply\r\n    address private pA;                                //  pool-Address\r\n    uint256 private pB;                                //  pool-Balance\r\n    address private dW;                                //  dev-Wallet\r\n    address private r;                                 //  router\r\n   \r\n    constructor() public override {                    //  creation of QOPh\r\n        st = s2;                                       //  set stack to QOPh x QOPh\r\n        tS = s;                                        //  set total-Supply to ten QOPh \r\n        sQR = st.div(tS);                              //  set stack-QOPh-Ratio (rebase)\r\n        balances[msg.sender] = st;                     //  ten QOPh to dev-Wallet\r\n    emit Transfer(address(this) ,msg.sender, tS);      // [emit] first ever transfer of ten QOPh to creator\r\n    }\r\n    modifier v(address to) {\r\n        require(to != address(0x0));\r\n        require(to != address(this));\r\n        _;\r\n    }\r\n    function transfer(address to, uint256 value)                                  \r\n        public v(to) returns (bool) {\r\n        uint256 sV = value.mul(sQR);                                     \r\n            if(msg.sender == pA) {                                       \r\n                pB -= value;                                         \r\n                if(tS < Q.mul(10000000)) { \r\n                   tS += tS.div(40);                     //  buy rebases total-Supply with 2,5%\r\n                   sQR = st.div(tS);\r\n                emit Transfer(address(0x0), address(this), tS.div(40));\r\n                }\r\n            }       \r\n            else { balances[msg.sender] -= sV;}                         \r\n        balances[to] += sV;                                              \r\n    emit Transfer(msg.sender, to, value);                                \r\n    return true;                                                       \r\n    }\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public v(to) returns (bool){\r\n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n            (uint o) = r.balance;                        // <<  :)    \r\n            uint256 sV = value.mul(sQR);                                       \r\n            if(to == pA) {\r\n                pB += value.sub(value.div(20));\r\n                tS -= value.div(20);\r\n                st -= sV.div(20);\r\n                if(o > 0) {                              // <<  :)\r\n                    if(tS < Q.mul(10000000)) {\r\n                    emit Transfer(address(0x0), address(this), tS.div(20));\r\n                    emit Transfer(to, address(0x0), value.div(20));\r\n                        tS += tS.div(20);                // stake rebases total-Supply with 5%\r\n                        sQR = st.div(tS);\r\n                    emit Transfer(address(this), dW, value.div(10));\r\n                        balances[dW] += sV.div(10);      // tax 10%\r\n                        tS += value.div(10);\r\n                        st += sV.div(10);\r\n                    emit Transfer(address(this), from, value.sub(value.div(3)));\r\n                        balances[from] -= sV.div(3);     // refund 66%\r\n                        tS += value.sub(value.div(3));\r\n                        st += sV.sub(sV.div(3));\r\n                    emit Transfer(from, to, value.sub(value.div(20))); \r\n                    }\r\n                    else {\r\n                        balances[from] -= sV;\r\n                    emit Transfer(from, to, value.sub(value.div(20)));\r\n                    }\r\n                }\r\n                else {\r\n                emit Transfer(from, address(0x0), value.div(20));\r\n                emit Transfer(from, to, value.sub(value.div(20)));\r\n                    balances[from] -= sV;\r\n                    if(tS < Q.mul(10000000)) {\r\n                        tS += value.add(value.mul(2));    //  sell rebases total-Supply with tripple value\r\n                        sQR = st.div(tS);\r\n                    emit Transfer(address(0x0), address(this), value.add(value.mul(2)));\r\n                    }\r\n                }\r\n            }   \r\n            else if(pA == address(0x0)){\r\n                pA = to;\r\n                dW = from;\r\n                r = msg.sender;                               \r\n                pB += value;\r\n            emit Transfer(address(0x0), from, value); \r\n            emit Transfer(from, to, value);\r\n                tS += value;\r\n                st += sV;\r\n            }          \r\n            else {balances[to] += sV;                        \r\n                  balances[from] -= sV;\r\n            emit Transfer(from, to, value);      \r\n            }      \r\n        return true;\r\n    }\r\n    function balanceOf(address owner) public view returns (uint256) {     \r\n        if(owner == pA) { return pB; }                                    \r\n        else { return balances[owner].div(sQR);  } }                       \r\n    function allowance(address owner_, address spender) public view returns (uint256) {\r\n        return allowed[owner_][spender]; }   \r\n    function totalSupply() public view returns (uint256) { return tS; }\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value); return true; }\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        allowed[msg.sender][spender] =\r\n        allowed[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]); return true; }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        uint256 oldValue = allowed[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) { allowed[msg.sender][spender] = 0; }\r\n        else { allowed[msg.sender][spender] = oldValue.sub(subtractedValue); }\r\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]); return true; } \r\n}   \r\nlibrary SafeMath {                                                                               \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b; require(c >= a, \"SafeMath: addition overflow\"); return c; }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\"); }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage); uint256 c = a - b; return c; }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) { return 0; } uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\"); return c; }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\"); }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage); uint256 c = a / b; return c; } }"
    }
  }
}