{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ACOFactory.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./IACOToken.sol\";\r\n\r\n/**\r\n * @title ACOFactory\r\n * @dev The contract is the implementation for the ACOProxy.\r\n */\r\ncontract ACOFactory {\r\n    \r\n    /**\r\n     * @dev Emitted when the factory admin address has been changed.\r\n     * @param previousFactoryAdmin Address of the previous factory admin.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    event SetFactoryAdmin(address indexed previousFactoryAdmin, address indexed newFactoryAdmin);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO token implementation has been changed.\r\n     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\r\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\r\n     */\r\n    event SetAcoTokenImplementation(address indexed previousAcoTokenImplementation, address indexed newAcoTokenImplementation);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO fee has been changed.\r\n     * @param previousAcoFee Value of the previous ACO fee.\r\n     * @param newAcoFee Value of the new ACO fee.\r\n     */\r\n    event SetAcoFee(uint256 indexed previousAcoFee, uint256 indexed newAcoFee);\r\n    \r\n    /**\r\n     * @dev Emitted when the ACO fee destination address has been changed.\r\n     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\r\n     * @param newAcoFeeDestination Address of the new ACO fee destination.\r\n     */\r\n    event SetAcoFeeDestination(address indexed previousAcoFeeDestination, address indexed newAcoFeeDestination);\r\n    \r\n    /**\r\n     * @dev Emitted when a new ACO token has been created.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param acoToken Address of the new ACO token created.\r\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\r\n     */\r\n    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\r\n    \r\n    /**\r\n     * @dev The ACO fee value. \r\n     * It is a percentage value (100000 is 100%).\r\n     */\r\n    uint256 public acoFee;\r\n    \r\n    /**\r\n     * @dev The factory admin address.\r\n     */\r\n    address public factoryAdmin;\r\n    \r\n    /**\r\n     * @dev The ACO token implementation address.\r\n     */\r\n    address public acoTokenImplementation;\r\n    \r\n    /**\r\n     * @dev The ACO fee destination address.\r\n     */\r\n    address public acoFeeDestination;\r\n    \r\n    /**\r\n     * @dev Modifier to check if the `msg.sender` is the factory admin.\r\n     * Only factory admin address can execute.\r\n     */\r\n    modifier onlyFactoryAdmin() {\r\n        require(msg.sender == factoryAdmin, \"ACOFactory::onlyFactoryAdmin\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to initialize the contract.\r\n     * It should be called through the `data` argument when creating the proxy.\r\n     * It must be called only once. The `assert` is to guarantee that behavior.\r\n     * @param _factoryAdmin Address of the factory admin.\r\n     * @param _acoTokenImplementation Address of the ACO token implementation.\r\n     * @param _acoFee Value of the ACO fee.\r\n     * @param _acoFeeDestination Address of the ACO fee destination.\r\n     */\r\n    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\r\n        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), \"ACOFactory::init: Contract already initialized.\");\r\n        \r\n        _setFactoryAdmin(_factoryAdmin);\r\n        _setAcoTokenImplementation(_acoTokenImplementation);\r\n        _setAcoFee(_acoFee);\r\n        _setAcoFeeDestination(_acoFeeDestination);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to guarantee that the contract will not receive ether.\r\n     */\r\n    receive() external payable virtual {\r\n        revert();\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     */\r\n    function createAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime,\r\n        uint256 maxExercisedAccounts\r\n    ) onlyFactoryAdmin external virtual returns(address) {\r\n        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\r\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);\r\n        return acoToken;\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the factory admin address.\r\n     * Only can be called by the factory admin.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\r\n        _setFactoryAdmin(newFactoryAdmin);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO token implementation address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\r\n     */\r\n    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\r\n        _setAcoTokenImplementation(newAcoTokenImplementation);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO fee.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\r\n     */\r\n    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\r\n        _setAcoFee(newAcoFee);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the ACO destination address.\r\n     * Only can be called by the factory admin.\r\n     * @param newAcoFeeDestination Address of the new ACO destination.\r\n     */\r\n    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\r\n        _setAcoFeeDestination(newAcoFeeDestination);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the factory admin address.\r\n     * @param newFactoryAdmin Address of the new factory admin.\r\n     */\r\n    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\r\n        require(newFactoryAdmin != address(0), \"ACOFactory::_setFactoryAdmin: Invalid factory admin\");\r\n        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\r\n        factoryAdmin = newFactoryAdmin;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO token implementation address.\r\n     * @param newAcoTokenImplementation Address of the new ACO token implementation.\r\n     */\r\n    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\r\n        require(Address.isContract(newAcoTokenImplementation), \"ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation\");\r\n        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\r\n        acoTokenImplementation = newAcoTokenImplementation;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO fee.\r\n     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\r\n     */\r\n    function _setAcoFee(uint256 newAcoFee) internal virtual {\r\n        emit SetAcoFee(acoFee, newAcoFee);\r\n        acoFee = newAcoFee;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the ACO destination address.\r\n     * @param newAcoFeeDestination Address of the new ACO destination.\r\n     */\r\n    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\r\n        require(newAcoFeeDestination != address(0), \"ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination\");\r\n        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\r\n        acoFeeDestination = newAcoFeeDestination;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     * @return Address of the new minimal proxy deployed for the ACO token.\r\n     */\r\n    function _deployAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime,\r\n        uint256 maxExercisedAccounts\r\n    ) internal virtual returns(address) {\r\n        bytes20 implentationBytes = bytes20(acoTokenImplementation);\r\n        address proxy;\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), implentationBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            proxy := create(0, clone, 0x37)\r\n        }\r\n        IACOToken(proxy).init(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoFee, payable(acoFeeDestination), maxExercisedAccounts);\r\n        return proxy;\r\n    }\r\n}\r\n\r\ncontract ACOFactoryV2 is ACOFactory {\r\n\t\r\n\t/**\r\n     * @dev Struct to store the ACO Token basic data.\r\n     */\r\n    struct ACOTokenData {\r\n        /**\r\n         * @dev Address of the underlying asset (0x0 for Ethereum).\r\n         */\r\n        address underlying;\r\n        \r\n        /**\r\n         * @dev Address of the strike asset (0x0 for Ethereum).\r\n         */\r\n        address strikeAsset;\r\n        \r\n        /**\r\n         * @dev True if the type is CALL, false for PUT.\r\n         */\r\n        bool isCall;\r\n        \r\n        /**\r\n         * @dev The strike price with the strike asset precision.\r\n         */\r\n        uint256 strikePrice;\r\n        \r\n        /**\r\n         * @dev The UNIX time for the ACO token expiration.\r\n         */\r\n        uint256 expiryTime;\r\n    }\r\n\t\r\n    /**\r\n     * @dev The ACO token basic data.\r\n     */\r\n    mapping(address => ACOTokenData) public acoTokenData;\r\n\r\n    /**\r\n     * @dev Function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     * @return The created ACO token address.\r\n     */\r\n    function createAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime,\r\n        uint256 maxExercisedAccounts\r\n    ) onlyFactoryAdmin external override virtual returns(address) {\r\n        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\r\n        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\r\n        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);\r\n        return acoToken;\r\n    }\r\n}\r\n\r\ncontract ACOFactoryV3 is ACOFactoryV2 {\r\n\r\n    /**\r\n     * @dev Emitted when the operator address permission has been changed.\r\n     * @param operator Address of the operator.\r\n     * @param previousPermission Whether the operator was authorized.\r\n     * @param newPermission Whether the operator will be authorized.\r\n     */\r\n    event SetOperator(address indexed operator, bool indexed previousPermission, bool indexed newPermission);\r\n\r\n    /**\r\n     * @dev Emitted when a new ACO token has been created.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall True if the type is CALL, false for PUT.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param acoToken Address of the new ACO token created.\r\n     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\r\n     * @param creator Address of the ACO creator.\r\n     */\r\n    event NewAcoTokenData(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation, address creator);\r\n    \r\n    /**\r\n     * @dev A map to register the ACO Factory operators permissions.\r\n     */\r\n    mapping(address => bool) public operators;\r\n    \r\n    /**\r\n     * @dev A map to register the ACO creator.\r\n     */\r\n    mapping(address => address) public creators;\r\n\r\n    /**\r\n     * @dev Function to set the operator permission.\r\n     * @param operator Address of the operator.\r\n     * @param newPermission Whether the operator will be authorized.\r\n     */\r\n    function setOperator(address operator, bool newPermission) onlyFactoryAdmin external virtual {\r\n        _setOperator(operator, newPermission);\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     * @return The created ACO token address.\r\n     */\r\n    function createAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime,\r\n        uint256 maxExercisedAccounts\r\n    ) external override virtual returns(address) {\r\n        require(operators[msg.sender], \"ACOFactory::createAcoToken: Only authorized operators\");\r\n        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\r\n        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\r\n        creators[acoToken] = msg.sender;\r\n        emit NewAcoTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation, msg.sender);\r\n        return acoToken;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the operator permission.\r\n     * @param operator Address of the operator.\r\n     * @param newPermission Whether the operator will be authorized.\r\n     */\r\n    function _setOperator(address operator, bool newPermission) internal virtual {\r\n        emit SetOperator(operator, operators[operator], newPermission);\r\n        operators[operator] = newPermission;\r\n    }\r\n}\r\n\r\ncontract ACOFactoryV4 is ACOFactoryV3 {\r\n\r\n    uint256 public constant MAX_EXPIRATION = 157852800;\r\n    uint256 public constant DEFAULT_MAX_EXERCISED_ACCOUNTS = 100;\r\n    uint256 public constant DEFAULT_MAX_SIGNIFICANT_DIGITS = 3;\r\n\r\n    struct AssetData {\r\n        /*\r\n         * The maximum significant digits on the strike to ACO creation.\r\n         */\r\n        uint256 maxSignificantDigits;\r\n        \r\n        /*\r\n         * The maximum number of accounts that can be exercised by transaction.\r\n         */\r\n        uint256 maxExercisedAccounts;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when the strike asset address permission has been changed.\r\n     * @param strikeAsset Address of the strike asset.\r\n     * @param previousPermission Whether the strike asset was authorized.\r\n     * @param newPermission Whether the strike asset will be authorized.\r\n     */\r\n    event SetStrikeAssetPermission(address indexed strikeAsset, bool indexed previousPermission, bool indexed newPermission);\r\n\r\n    /**\r\n     * @dev Emitted when the asset specific data has been changed.\r\n     * @param asset Address of the asset.\r\n     * @param previousMaxSignificantDigits Previous value of the maximum significant digits on the strike to ACO creation.\r\n     * @param previousMaxExercisedAccounts Previous value of the maximum number of accounts that can be exercised by transaction.\r\n     * @param newMaxSignificantDigits New value of the maximum significant digits on the strike to ACO creation.\r\n     * @param newMaxExercisedAccounts New value of the maximum number of accounts that can be exercised by transaction.\r\n     */\r\n    event SetAssetSpecificData(address indexed asset, uint256 previousMaxSignificantDigits, uint256 previousMaxExercisedAccounts, uint256 newMaxSignificantDigits, uint256 newMaxExercisedAccounts);\r\n    \r\n    /**\r\n     * @dev A map to register the strike assets permissions.\r\n     */\r\n    mapping(address => bool) public strikeAssets;\r\n    \r\n    /**\r\n     * @dev A map to register the ACOs by their hash.\r\n     */\r\n    mapping(bytes32 => address) public acoHashes;\r\n    \r\n    /**\r\n     * @dev A map to register the assets specific data.\r\n     */\r\n    mapping(address => AssetData) public assetsSpecificData;\r\n\r\n    /**\r\n     * @dev Function to set the strike asset permission.\r\n     * @param strikeAsset Address of the strike asset.\r\n     * @param newPermission Whether the strike asset will be authorized.\r\n     */\r\n    function setStrikeAssetPermission(address strikeAsset, bool newPermission) onlyFactoryAdmin external virtual {\r\n        _setStrikeAssetPermission(strikeAsset, newPermission);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to set the asset specific data.\r\n     * @param asset Address of the asset.\r\n     * @param maxSignificantDigits The maximum significant digits on the strike to create an ACO.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     */\r\n    function setAssetSpecificData(\r\n        address asset, \r\n        uint256 maxSignificantDigits,\r\n        uint256 maxExercisedAccounts\r\n    ) onlyFactoryAdmin external virtual {\r\n        _setAssetSpecificData(asset, maxSignificantDigits, maxExercisedAccounts);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to get the ACO token by the parameters.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @return The ACO address or 0x0 if it does not exist.\r\n     */\r\n    function getAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime\r\n    ) external virtual view returns(address) {\r\n        bytes32 acoHash = _getAcoHash(underlying, strikeAsset, isCall, strikePrice, expiryTime);\r\n        return acoHashes[acoHash];\r\n    }\r\n\r\n\t/**\r\n     * @dev Function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     * @return The created ACO token address.\r\n     */\r\n    function createAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime,\r\n        uint256 maxExercisedAccounts\r\n    ) external override virtual returns(address) {\r\n        require(operators[msg.sender], \"ACOFactory::createAcoToken: Only authorized operators\");\r\n        return _createAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\r\n    }\r\n    \r\n    /**\r\n     * @dev Function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @return The created ACO token address.\r\n     */\r\n    function newAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime\r\n    ) external virtual returns(address) {\r\n        require(strikeAssets[strikeAsset], \"ACOFactory::newAcoToken: Invalid strike asset\");\r\n        require(_isValidTime(expiryTime), \"ACOFactory::newAcoToken: Invalid expiry time\");\r\n        \r\n        AssetData storage strikeAssetData = assetsSpecificData[strikeAsset];\r\n        uint256 maxSignificantDigits = _getMaxSignificantDigits(strikeAssetData);\r\n        require(_isValidStrikePrice(strikePrice, maxSignificantDigits), \"ACOFactory::newAcoToken: Invalid strike price\");\r\n        \r\n        uint256 maxExercisedAccounts = _getMaxExercisedAccounts(underlying, isCall, strikeAssetData);\r\n        return _createAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to create a new ACO token.\r\n     * It deploys a minimal proxy for the ACO token implementation address. \r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     * @return The created ACO token address.\r\n     */\r\n    function _createAcoToken(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime,\r\n        uint256 maxExercisedAccounts\r\n    ) internal virtual returns(address) {\r\n        require(expiryTime <= (block.timestamp + MAX_EXPIRATION), \"ACOFactory::_createAcoToken: Invalid expiry time\");\r\n        \r\n        bytes32 acoHash = _getAcoHash(underlying, strikeAsset, isCall, strikePrice, expiryTime);\r\n        require(acoHashes[acoHash] == address(0), \"ACOFactory::_createAcoToken: ACO already exists\");\r\n        \r\n        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\r\n        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\r\n        creators[acoToken] = msg.sender;\r\n        acoHashes[acoHash] = acoToken;\r\n        emit NewAcoTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation, msg.sender);\r\n        return acoToken;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the ACO hash.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @return The ACO hash.\r\n     */\r\n    function _getAcoHash(\r\n        address underlying, \r\n        address strikeAsset, \r\n        bool isCall,\r\n        uint256 strikePrice, \r\n        uint256 expiryTime\r\n    ) internal pure virtual returns(bytes32) {\r\n        return keccak256(abi.encodePacked(underlying, strikeAsset, isCall, strikePrice, expiryTime));\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the maximum number of accounts that can be exercised by transaction for an ACO creation.\r\n     * @param underlying Address of the underlying asset (0x0 for Ethereum).\r\n     * @param isCall Whether the ACO token is the Call type.\r\n     * @param strikeAssetData The strike asset specific data.\r\n     * @return The maximum number of accounts that can be exercised by transaction for an ACO creation.\r\n     */\r\n    function _getMaxExercisedAccounts(\r\n        address underlying, \r\n        bool isCall,\r\n        AssetData storage strikeAssetData\r\n    ) internal view virtual returns(uint256) {\r\n        if (isCall) {\r\n            AssetData storage underlyingData = assetsSpecificData[underlying];\r\n            if (underlyingData.maxExercisedAccounts > 0) {\r\n                return underlyingData.maxExercisedAccounts;\r\n            }\r\n        } else if (strikeAssetData.maxExercisedAccounts > 0) {\r\n            return strikeAssetData.maxExercisedAccounts;\r\n        }\r\n        return DEFAULT_MAX_EXERCISED_ACCOUNTS;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to get the maximum significant digits on the strike to ACO creation.\r\n     * @param strikeAssetData The strike asset specific data.\r\n     * @return The maximum significant digits on the strike to ACO creation.\r\n     */\r\n    function _getMaxSignificantDigits(AssetData storage strikeAssetData) internal view virtual returns(uint256) {\r\n        if (strikeAssetData.maxSignificantDigits > 0) {\r\n            return strikeAssetData.maxSignificantDigits;\r\n        }\r\n        return DEFAULT_MAX_SIGNIFICANT_DIGITS;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to check if the expiry time is 8:00 AM.\r\n     * @param expiryTime The UNIX time for the ACO token expiration.\r\n     * @return TRUE if it is 8:00 AM else FALSE.\r\n     */\r\n    function _isValidTime(uint256 expiryTime) internal pure virtual returns(bool) {\r\n        return ((expiryTime % 60) == 0 && ((expiryTime % 3600) / 60) == 0 && ((expiryTime % 86400) / 3600) == 8);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to check if the strike price respect the maximum significant digits allowed.\r\n     * @param strikePrice The strike price with the strike asset precision.\r\n     * @param maxSignificantDigits The maximum significant digits on the strike to ACO creation.\r\n     * @return TRUE if it is valid else FALSE.\r\n     */\r\n    function _isValidStrikePrice(uint256 strikePrice, uint256 maxSignificantDigits) internal pure virtual returns(bool) {\r\n        uint256 i = strikePrice;\r\n        uint256 len;\r\n        while (i != 0) {\r\n            len++;\r\n            i /= 10;\r\n        }\r\n        if (len <= maxSignificantDigits) {\r\n            return true;\r\n        }\r\n        uint256 diff = len - maxSignificantDigits;\r\n        if (diff < 78) {\r\n            uint256 nonSignificant = 10 ** diff;\r\n            return ((strikePrice / nonSignificant) * nonSignificant) == strikePrice;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to set the strike asset permission.\r\n     * @param strikeAsset Address of the strike asset.\r\n     * @param newPermission Whether the strike asset will be authorized.\r\n     */\r\n    function _setStrikeAssetPermission(address strikeAsset, bool newPermission) internal virtual {\r\n        emit SetStrikeAssetPermission(strikeAsset, strikeAssets[strikeAsset], newPermission);\r\n        strikeAssets[strikeAsset] = newPermission;\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function to set the asset specific data.\r\n     * @param asset Address of the asset.\r\n     * @param maxSignificantDigits The maximum significant digits on the strike to ACO creation.\r\n     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\r\n     */\r\n    function _setAssetSpecificData(\r\n        address asset, \r\n        uint256 maxSignificantDigits,\r\n        uint256 maxExercisedAccounts\r\n    ) internal virtual {\r\n        AssetData storage previousData = assetsSpecificData[asset];\r\n        emit SetAssetSpecificData(asset, previousData.maxSignificantDigits, previousData.maxExercisedAccounts, maxSignificantDigits, maxExercisedAccounts);\r\n        assetsSpecificData[asset] = AssetData(maxSignificantDigits, maxExercisedAccounts);\r\n    }\r\n}"},"browser/Address.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n"},"browser/IACOToken.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IACOToken is IERC20 {\r\n\tfunction init(address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime, uint256 _acoFee, address payable _feeDestination, uint256 _maxExercisedAccounts) external;\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint8);\r\n    function underlying() external view returns (address);\r\n    function strikeAsset() external view returns (address);\r\n    function feeDestination() external view returns (address);\r\n    function isCall() external view returns (bool);\r\n    function strikePrice() external view returns (uint256);\r\n    function expiryTime() external view returns (uint256);\r\n    function totalCollateral() external view returns (uint256);\r\n    function acoFee() external view returns (uint256);\r\n\tfunction maxExercisedAccounts() external view returns (uint256);\r\n    function underlyingSymbol() external view returns (string memory);\r\n    function strikeAssetSymbol() external view returns (string memory);\r\n    function underlyingDecimals() external view returns (uint8);\r\n    function strikeAssetDecimals() external view returns (uint8);\r\n    function currentCollateral(address account) external view returns(uint256);\r\n    function unassignableCollateral(address account) external view returns(uint256);\r\n    function assignableCollateral(address account) external view returns(uint256);\r\n    function currentCollateralizedTokens(address account) external view returns(uint256);\r\n    function unassignableTokens(address account) external view returns(uint256);\r\n    function assignableTokens(address account) external view returns(uint256);\r\n    function getCollateralAmount(uint256 tokenAmount) external view returns(uint256);\r\n    function getTokenAmount(uint256 collateralAmount) external view returns(uint256);\r\n    function getBaseExerciseData(uint256 tokenAmount) external view returns(address, uint256);\r\n    function numberOfAccountsWithCollateral() external view returns(uint256);\r\n    function getCollateralOnExercise(uint256 tokenAmount) external view returns(uint256, uint256);\r\n    function collateral() external view returns(address);\r\n    function mintPayable() external payable returns(uint256);\r\n    function mintToPayable(address account) external payable returns(uint256);\r\n    function mint(uint256 collateralAmount) external returns(uint256);\r\n    function mintTo(address account, uint256 collateralAmount) external returns(uint256);\r\n    function burn(uint256 tokenAmount) external returns(uint256);\r\n    function burnFrom(address account, uint256 tokenAmount) external returns(uint256);\r\n    function redeem() external returns(uint256);\r\n    function redeemFrom(address account) external returns(uint256);\r\n    function exercise(uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseFrom(address account, uint256 tokenAmount, uint256 salt) external payable returns(uint256);\r\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable returns(uint256);\r\n    function transferCollateralOwnership(address recipient, uint256 tokenCollateralizedAmount) external;\r\n}"},"browser/IERC20.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// Contract on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"}}}