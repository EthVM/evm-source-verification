{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"IERC20.sol":{"content":"pragma solidity >= 0.6.4;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  function mint(address account, uint256 amount) external;\n  function burn(uint256 amount) external;\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SignedSafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"},"ownable.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Owned is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"priceAggregatorInterface.sol":{"content":"pragma solidity >= 0.6.6;\n\ninterface priceAggregatorInterface {\n  function registerVaultAggregator(address oracle) external;\n  function priceRequest(\n    address vault,\n    uint256 lastUpdated\n  )\n  external\n  view\n  returns(int256[] memory, uint256);\n  function roundIdCheck(address vault) external view returns(bool);\n}\n"},"priceCalculator.sol":{"content":"//////////////////////////////////////////////////\n//SYNLEV Price Calculator Contract V 1.2\n//////////////////////////\n\npragma solidity >= 0.6.6;\n\nimport './ownable.sol';\nimport './SafeMath.sol';\nimport './SignedSafeMath.sol';\nimport './IERC20.sol';\nimport './vaultInterface.sol';\nimport './priceAggregatorInterface.sol';\n\ncontract priceCalculator is Owned {\n  using SafeMath for uint256;\n  using SignedSafeMath for int256;\n\n  constructor() public {\n    lossLimit = 9 * 10**8;\n    kControl = 15 * 10**8;\n    proposeDelay = 1;\n    priceAggregator = priceAggregatorInterface(0x7196545d854D03D9c87B7588F6D9e1e42D876E95);\n  }\n\n  uint256 public constant uSmallFactor = 10**9;\n  int256 public constant smallFactor = 10**9;\n\n  uint256 public lossLimit;\n  uint256 public kControl;\n  priceAggregatorInterface public priceAggregator;\n  address public priceAggregatorPropose;\n  uint256 public priceAggregatorProposeTimestamp;\n\n  uint256 public proposeDelay;\n  uint256 public proposeDelayPropose;\n  uint256 public proposeDelayTimestamp;\n\n  /*\n   * @notice Calculates the most recent price data.\n   * @dev If there is no new price data it returns current price/equity data.\n   * Safety checks are done by SynLev price aggregator. All calcualtions done\n   * via equity in ETH, not price to avoid rounding errors. Caculates price\n   * based on the \"losing side\", then subracts from the other. Mitigates a\n   * prefrence in rounding error to either bull or bear tokens.\n   */\n  function getUpdatedPrice(address vault, uint256 latestRoundId)\n  public\n  view\n  returns(\n    uint256[6] memory latestPrice,\n    uint256 rRoundId,\n    bool updated\n  ) {\n    //Requests price data from price aggregator proxy\n    (\n      int256[] memory priceData,\n      uint256 roundId\n    ) = priceAggregator.priceRequest(vault, latestRoundId);\n    vaultInterface ivault = vaultInterface(vault);\n    address bull = ivault.getBullToken();\n    address bear = ivault.getBearToken();\n    uint256 bullEquity = ivault.getTokenEquity(bull);\n    uint256 bearEquity = ivault.getTokenEquity(bear);\n    //Only update if price data if price array contains 2 or more values\n    //If there is no new price data pricedate array will have 0 length\n    if(priceData.length > 0 && bullEquity != 0 && bearEquity != 0) {\n      (uint256 rBullEquity, uint256 rBearEquity) = priceCalcLoop(priceData, bullEquity, bearEquity, ivault);\n      uint256[6] memory data = equityToReturnData(bull, bear, rBullEquity, rBearEquity, ivault);\n      return(data, roundId, true);\n    }\n    else {\n      return(\n        [ivault.getPrice(bull),\n        ivault.getPrice(bear),\n        ivault.getLiqEquity(bull),\n        ivault.getLiqEquity(bear),\n        ivault.getEquity(bull),\n        ivault.getEquity(bear)],\n        roundId,\n        false\n      );\n    }\n  }\n\n  function priceCalcLoop(\n    int256[] memory priceData,\n    uint256 bullEquity,\n    uint256 bearEquity,\n    vaultInterface ivault\n    )\n    public\n    view\n    returns(uint256 rBullEquity, uint256 rBearEquity)\n    {\n      uint256 multiplier = ivault.getMultiplier();\n      uint256 totalEquity = ivault.getTotalEquity();\n      uint256 movement;\n      uint256 bearKFactor;\n      uint256 bullKFactor;\n      int256  signedPriceDelta;\n      uint256 pricedelta;\n      for (uint i = 1; i < priceData.length; i++) {\n        //Grab k factor based on running equity\n        bullKFactor = getKFactor(bullEquity, bullEquity, bearEquity, totalEquity);\n        bearKFactor = getKFactor(bearEquity, bullEquity, bearEquity, totalEquity);\n        if(priceData[i-1] != priceData[i]) {\n          //Bearish movement, calc equity from the perspective of bull\n          if(priceData[i-1] > priceData[i]) {\n            //Treats 0 price value as 1, 0 causes divides by 0 error\n            if(priceData[i-1] == 0) priceData[i-1] = 1;\n            //Gets price change in absolute terms.\n\n            signedPriceDelta = priceData[i-1].sub(priceData[i]);\n            signedPriceDelta = signedPriceDelta.mul(smallFactor);\n            signedPriceDelta = signedPriceDelta.div(priceData[i-1]);\n            pricedelta = uint256(signedPriceDelta);\n\n            //Converts price change to be in terms of bull equity change\n            //As a percentage\n            pricedelta = pricedelta.mul(multiplier.mul(bullKFactor)).div(uSmallFactor);\n            //Dont allow loss to be greater than set loss limit\n            pricedelta = pricedelta < lossLimit ? pricedelta : lossLimit;\n            //Calculate equity loss of bull equity\n            movement = bullEquity.mul(pricedelta);\n            movement = movement.div(uSmallFactor);\n            //Adds equity movement to running bear euqity and removes that\n            //Loss from running bull equity\n            bearEquity = bearEquity.add(movement);\n            bullEquity = totalEquity.sub(bearEquity);\n          }\n          //Bullish movement, calc equity from the perspective of bear\n          //Same process as above. only from bear perspective\n          else if(priceData[i-1] < priceData[i]) {\n            if(priceData[i-1] == 0) priceData[i-1] = 1;\n\n            signedPriceDelta = priceData[i].sub(priceData[i-1]);\n            signedPriceDelta = signedPriceDelta.mul(smallFactor);\n            signedPriceDelta = signedPriceDelta.div(priceData[i-1]);\n            pricedelta = uint256(signedPriceDelta);\n\n            pricedelta = pricedelta.mul(multiplier.mul(bearKFactor)).div(uSmallFactor);\n            pricedelta = pricedelta < lossLimit ? pricedelta : lossLimit;\n            movement = bearEquity.mul(pricedelta);\n            movement = movement.div(uSmallFactor);\n            bullEquity = bullEquity.add(movement);\n            bearEquity = totalEquity.sub(bullEquity);\n          }\n        }\n      }\n      return(bullEquity, bearEquity);\n  }\n\n  function equityToReturnData(\n    address bull,\n    address bear,\n    uint256 bullEquity,\n    uint256 bearEquity,\n    vaultInterface ivault\n    )\n    public\n    view\n    returns(uint256[6] memory)\n  {\n      uint256 bullPrice =\n        bullEquity\n        .mul(1 ether)\n        .div(IERC20(bull).totalSupply().add(ivault.getLiqTokens(bull)));\n      uint256 bearPrice =\n        bearEquity\n        .mul(1 ether)\n        .div(IERC20(bear).totalSupply().add(ivault.getLiqTokens(bear)));\n      uint256 bullLiqEquity =\n        bullPrice\n        .mul(ivault.getLiqTokens(bull))\n        .div(1 ether);\n      uint256 bearLiqEquity =\n        bearPrice\n        .mul(ivault.getLiqTokens(bear))\n        .div(1 ether);\n\n      return([\n        bullPrice,\n        bearPrice,\n        bullLiqEquity,\n        bearLiqEquity,\n        bullEquity.sub(bullLiqEquity),\n        bearEquity.sub(bearLiqEquity)\n      ]);\n  }\n\n\n  /*\n   * @notice Calculates k factor of selected token. K factor is the multiplier\n   * that adjusts the leverage level to maintain 100% liquidty at all times.\n   * @dev K factor is scaled 10^9. A K factor of 1 represents a 1:1 ratio of\n   * bull and bear equity.\n   * @param targetEquity The total euqity of the target bull token\n   * @param bullEquity The total equity bull tokens\n   * @param bearEquity The total equity bear tokens\n   * @param totalEquity The total equity of bull and bear tokens\n   * @return K factor\n   */\n  function getKFactor(\n    uint256 targetEquity,\n    uint256 bullEquity,\n    uint256 bearEquity,\n    uint256 totalEquity\n  )\n  public\n  view\n  returns(uint256) {\n    //If either token has 0 equity k value is 0\n    if(bullEquity  == 0 || bearEquity == 0) {\n      return(0);\n    }\n    else {\n      //Avoids divides by 0 error\n      targetEquity = targetEquity > 0 ? targetEquity : 1;\n      uint256 kFactor =\n        totalEquity.mul(10**9).div(targetEquity.mul(2)) < kControl ?\n        totalEquity.mul(10**9).div(targetEquity.mul(2)): kControl;\n      return(kFactor);\n    }\n  }\n\n  ///////////////////\n  //ADMIN FUNCTIONS//\n  ///////////////////\n  function setLossLimit(uint256 amount) public onlyOwner() {\n    lossLimit = amount;\n  }\n  function setkControl(uint256 amount) public onlyOwner() {\n    kControl = amount;\n  }\n  function proposeVaultPriceAggregator(address account) public onlyOwner() {\n    priceAggregatorPropose = account;\n    priceAggregatorProposeTimestamp = block.timestamp;\n  }\n  function updateVaultPriceAggregator() public onlyOwner() {\n    require(priceAggregatorPropose != address(0));\n    require(priceAggregatorProposeTimestamp + proposeDelay <= block.timestamp);\n    priceAggregator = priceAggregatorInterface(priceAggregatorPropose);\n    priceAggregatorPropose = address(0);\n  }\n\n  function proposeProposeDelay(uint256 delay) public onlyOwner() {\n    proposeDelayPropose = delay;\n    proposeDelayTimestamp = block.timestamp;\n  }\n  function updateProposeDelay() public onlyOwner() {\n    require(proposeDelayPropose != 0);\n    require(proposeDelayTimestamp + proposeDelay <= block.timestamp);\n    proposeDelay = proposeDelayPropose;\n    proposeDelayPropose = 0;\n  }\n}\n"},"vaultInterface.sol":{"content":"pragma solidity >= 0.6.6;\n\ninterface vaultInterface {\n  function tokenBuy(address token, address account) external;\n  function tokenSell(address token, address payable account) external;\n  function addLiquidity(address account) external;\n  function removeLiquidity(uint256 shares) external;\n  function updatePrice() external;\n\n  function getActive() external view returns(bool);\n  function getMultiplier() external view returns(uint256);\n  function getBullToken() external view returns(address);\n  function getBearToken() external view returns(address);\n  function getLatestRoundId() external view returns(uint256);\n  function getPrice(address token) external view returns(uint256);\n  function getEquity(address token) external view returns(uint256);\n  function getBuyFee() external view returns(uint256);\n  function getSellFee() external view returns(uint256);\n  function getTotalLiqShares() external view returns(uint256);\n  function getLiqFees() external view returns(uint256);\n  function getBalanceEquity() external view returns(uint256);\n  function getLiqTokens(address token) external view returns(uint256);\n  function getLiqEquity(address token) external view returns(uint256);\n  function getUserShares(address account) external view returns(uint256);\n\n  function getTotalEquity() external view returns(uint256);\n  function getTokenEquity(address token) external view returns(uint256);\n  function getTotalLiqEquity() external view returns(uint256);\n  function getDepositEquity() external view returns(uint256);\n}\n"}}}