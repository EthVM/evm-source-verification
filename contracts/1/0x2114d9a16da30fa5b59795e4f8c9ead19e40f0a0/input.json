{
  "language": "Solidity",
  "settings": {
    "libraries": {
      "StrategiesHelper.sol": {
        "String": "0xb7326bb9a7e7073725c3d8245ca931ad8b1a2204"
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "StrategiesHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\ninterface IV2Strategy {\n    function name() external view returns (string memory);\n\n    function apiVersion() external view returns (string memory);\n\n    function strategist() external view returns (address);\n\n    function rewards() external view returns (address);\n\n    function vault() external view returns (address);\n\n    function keeper() external view returns (address);\n\n    function want() external view returns (address);\n\n    function emergencyExit() external view returns (bool);\n\n    function isActive() external view returns (bool);\n\n    function delegatedAssets() external view returns (uint256);\n\n    function estimatedTotalAssets() external view returns (uint256);\n    \n    function doHealthCheck() external view returns (bool);\n    \n    function healthCheck() external view returns (address);\n}\n\ninterface IAddressesGenerator {\n    function assetsAddresses() external view returns (address[] memory);\n}\n\ninterface IV2Vault {\n    function withdrawalQueue(uint256 arg0) external view returns (address);\n}\n\ninterface IAddressMergeHelper {\n    function mergeAddresses(address[][] memory addressesSets)\n        external\n        view\n        returns (address[] memory);\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n    \n    function symbol() external view returns (string memory);\n}\n\ninterface IOracle {\n    function getNormalizedValueUsdc(\n        address tokenAddress,\n        uint256 amount,\n        uint256 priceUsdc\n    ) external view returns (uint256);\n    \n    function getPriceUsdcRecommended(\n        address tokenAddress\n    ) external view returns (uint256);\n}\n\ncontract StrategiesHelper {\n    address public addressesGeneratorAddress;\n    address public addressesMergeHelperAddress;\n    address public oracleAddress;\n    address public ownerAddress;\n\n    struct StrategyMetadata {\n        string name;\n        address id;\n        string apiVersion;\n        address strategist;\n        address rewards;\n        address vault;\n        address keeper;\n        address want;\n        uint256 wantPriceUsdc;\n        uint8 wantDecimals;\n        string wantSymbol;\n        bool emergencyExit;\n        bool isActive;\n        uint256 delegatedAssets;\n        uint256 estimatedTotalAssets;\n        uint256 estimatedTotalAssetsUsdc;\n        bool doHealthCheck;\n        address healthCheckAddress;\n    }\n\n    constructor(address _addressesGeneratorAddress, address _addressesMergeHelperAddress, address _oracleAddress) {\n        addressesGeneratorAddress = _addressesGeneratorAddress;\n        addressesMergeHelperAddress = _addressesMergeHelperAddress;\n        oracleAddress = _oracleAddress;\n        ownerAddress = msg.sender;\n    }\n\n    /**\n     * Fetch the number of strategies for a vault\n     */\n    function assetStrategiesLength(address assetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        IV2Vault vault = IV2Vault(assetAddress);\n        uint256 strategyIdx;\n        while (true) {\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n            if (strategyAddress == address(0)) {\n                break;\n            }\n            strategyIdx++;\n        }\n        return strategyIdx;\n    }\n\n    /**\n     * Fetch the total number of strategies for all vaults\n     */\n    function assetsStrategiesLength() public view returns (uint256) {\n        return assetsStrategiesAddresses().length;\n    }\n\n    /**\n     * Fetch strategy addresses given a vault address\n     */\n    function assetStrategiesAddresses(address assetAddress)\n        public\n        view\n        returns (address[] memory)\n    {\n        IV2Vault vault = IV2Vault(assetAddress);\n        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n        address[] memory _strategiesAddresses =\n            new address[](numberOfStrategies);\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n            _strategiesAddresses[strategyIdx] = strategyAddress;\n        }\n        return _strategiesAddresses;\n    }\n\n    /**\n     * Fetch all strategy addresses for all vaults\n     */\n     function assetsStrategiesAddresses() public view returns (address[] memory) {\n        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n        return assetsStrategiesAddresses(_assetsAddresses);\n     }\n     \n    /**\n     * Convert an ASCII string to a number given a string and a base\n     */\n    function atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\n        require(base == 2 || base == 8 || base == 10 || base == 16);\n        bytes memory buf = bytes(a);\n        for (uint256 p = 0; p < buf.length; p++) {\n            uint8 digit = uint8(buf[p]) - 0x30;\n            if (digit > 10) {\n                digit -= 7;\n            }\n            require(digit < base);\n            i *= base;\n            i += digit;\n        }\n        return i;\n    }\n    \n    /**\n     * Check to see if two strings are exactly equal\n     */\n    function stringsEqual(string memory input1, string memory input2) internal pure returns (bool) {\n        bytes32 input1Bytes32;\n        bytes32 input2Bytes32;\n        assembly {\n            input1Bytes32 := mload(add(input1, 32))\n            input2Bytes32 := mload(add(input2, 32))\n        }\n        return input1Bytes32 == input2Bytes32;\n    }\n\n    /**\n     * Fetch strategy addresses by filter\n     */\n     function assetsStrategiesAddressesByFilter(string[][] memory filter) public view returns (address[] memory) {\n        address[] memory _assetsStrategiesAddresses =\n            assetsStrategiesAddresses();\n        return assetsStrategiesAddressesByFilter(_assetsStrategiesAddresses, filter);\n    }\n    \n    /**\n     * Fetch strategy addresses by filter\n     */\n    function assetsStrategiesAddressesByFilter(address[] memory _strategiesAddresses, string[][] memory filter) public view returns (address[] memory) {\n        uint256 numberOfStrategies = _strategiesAddresses.length;\n        uint256 numberOfFilteredStrategies;\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = _strategiesAddresses[strategyIdx];\n            if (strategyPassesFilter(strategyAddress, filter)) {\n                _strategiesAddresses[numberOfFilteredStrategies] = strategyAddress;\n                numberOfFilteredStrategies++;\n            }\n        }\n        bytes memory encodedAddresses = abi.encode(_strategiesAddresses);\n        assembly {\n            mstore(add(encodedAddresses, 0x40), numberOfFilteredStrategies)\n        }\n        address[] memory filteredAddresses =\n            abi.decode(encodedAddresses, (address[]));\n        return filteredAddresses;\n     }\n\n    /**\n     * Fetch all strategy addresses given an array of vaults\n     */\n    function assetsStrategiesAddresses(address[] memory _assetsAddresses)\n        public\n        view\n        returns (address[] memory)\n    {\n        uint256 numberOfAssets = _assetsAddresses.length;\n        address[][] memory _strategiesForAssets =\n            new address[][](numberOfAssets);\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n            address assetAddress = _assetsAddresses[assetIdx];\n            address[] memory _assetStrategiessAddresses =\n                assetStrategiesAddresses(assetAddress);\n            _strategiesForAssets[assetIdx] = _assetStrategiessAddresses;\n        }\n        address[] memory mergedAddresses =\n            IAddressMergeHelper(addressesMergeHelperAddress).mergeAddresses(_strategiesForAssets);\n        return mergedAddresses;\n    }\n\n    /**\n     * Fetch total delegated balance for all strategies\n     */\n    function assetsStrategiesDelegatedBalance()\n        external\n        view\n        returns (uint256)\n    {\n        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n        uint256 numberOfAssets = _assetsAddresses.length;\n        uint256 assetsDelegatedBalance;\n        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n            address assetAddress = _assetsAddresses[assetIdx];\n            uint256 assetDelegatedBalance =\n                assetStrategiesDelegatedBalance(assetAddress);\n            assetsDelegatedBalance += assetDelegatedBalance;\n        }\n        return assetsDelegatedBalance;\n    }\n\n    /**\n     * Fetch delegated balance for all of a vault's strategies\n     */\n    function assetStrategiesDelegatedBalance(address assetAddress)\n        public\n        view\n        returns (uint256)\n    {\n        address[] memory _assetStrategiesAddresses =\n            assetStrategiesAddresses(assetAddress);\n        uint256 numberOfStrategies = _assetStrategiesAddresses.length;\n        uint256 strategiesDelegatedBalance;\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = _assetStrategiesAddresses[strategyIdx];\n            IV2Strategy _strategy = IV2Strategy(strategyAddress);\n            uint256 strategyDelegatedBalance = _strategy.delegatedAssets();\n            strategiesDelegatedBalance += strategyDelegatedBalance;\n        }\n        return strategiesDelegatedBalance;\n    }\n\n    /**\n     * Fetch metadata for all strategies scoped to a vault\n     */\n    function assetStrategies(address assetAddress)\n        external\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        IV2Vault vault = IV2Vault(assetAddress);\n        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n        StrategyMetadata[] memory _strategies =\n            new StrategyMetadata[](numberOfStrategies);\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n            StrategyMetadata memory _strategy = strategy(strategyAddress);\n            _strategies[strategyIdx] = _strategy;\n        }\n        return _strategies;\n    }\n\n    /**\n     * Fetch metadata for all strategies\n     */\n    function assetsStrategies()\n        external\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        address[] memory _assetsStrategiesAddresses =\n            assetsStrategiesAddresses();\n        return strategies(_assetsStrategiesAddresses);\n    }\n    \n    /**\n     * Fetch metadata for all strategies\n     */\n    function assetsStrategiesByFilter(string[][] memory _filter)\n        external\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        address[] memory _assetsStrategiesAddresses =\n            assetsStrategiesAddressesByFilter(_filter);\n        return strategies(_assetsStrategiesAddresses);\n    }\n    \n    /**\n     * Fetch metadata for strategies given an array of vault addresses\n     */\n    function assetsStrategies(address[] memory _assetsAddresses)\n        public\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        return strategies(assetsStrategiesAddresses(_assetsAddresses));\n    }\n    \n    /**\n     * Fetch metadata for strategies given an array of vault addresses and a filter\n     */\n    function assetsStrategiesByFilter(address[] memory _assetsAddresses, string[][] memory _filter)\n        public\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        return strategies(assetsStrategiesAddressesByFilter(_assetsAddresses, _filter));\n    }\n    \n    /**\n     * Fetch metadata for a strategy given a strategy address\n     */\n    function strategy(address strategyAddress)\n        public\n        view\n        returns (StrategyMetadata memory)\n    {\n        IV2Strategy _strategy = IV2Strategy(strategyAddress);\n        IOracle _oracle = IOracle(oracleAddress);\n        bool _doHealthCheck;\n        address _healthCheckAddress;\n        address _wantAddress = _strategy.want();\n        IERC20 _want = IERC20(_wantAddress);\n        uint256 _wantPriceUsdc = _oracle.getPriceUsdcRecommended(_wantAddress);\n        uint256 _estimatedTotalAssets = _strategy.estimatedTotalAssets();\n        try _strategy.doHealthCheck() {\n            _doHealthCheck = _strategy.doHealthCheck();\n        } catch {}\n        try _strategy.healthCheck() {\n             _healthCheckAddress = _strategy.healthCheck();\n        } catch {}\n        return\n            StrategyMetadata({\n                name: _strategy.name(),\n                id: strategyAddress,\n                apiVersion: _strategy.apiVersion(),\n                strategist: _strategy.strategist(),\n                rewards: _strategy.rewards(),\n                vault: _strategy.vault(),\n                keeper: _strategy.keeper(),\n                want: _wantAddress,\n                wantPriceUsdc: _wantPriceUsdc,\n                wantDecimals: _want.decimals(),\n                wantSymbol: _want.symbol(),\n                emergencyExit: _strategy.emergencyExit(),\n                isActive: _strategy.isActive(),\n                delegatedAssets: _strategy.delegatedAssets(),\n                estimatedTotalAssets: _estimatedTotalAssets,\n                estimatedTotalAssetsUsdc: _oracle.getNormalizedValueUsdc(_wantAddress, _estimatedTotalAssets, _wantPriceUsdc),\n                doHealthCheck: _doHealthCheck,\n                healthCheckAddress: _healthCheckAddress\n            });\n    }\n\n    /**\n     * Fetch metadata for strategies given an array of strategy addresses\n     */\n    function strategies(address[] memory _strategiesAddresses)\n        public\n        view\n        returns (StrategyMetadata[] memory)\n    {\n        uint256 numberOfStrategies = _strategiesAddresses.length;\n        StrategyMetadata[] memory _strategies =\n            new StrategyMetadata[](numberOfStrategies);\n        for (\n            uint256 strategyIdx = 0;\n            strategyIdx < numberOfStrategies;\n            strategyIdx++\n        ) {\n            address strategyAddress = _strategiesAddresses[strategyIdx];\n            StrategyMetadata memory _strategy = strategy(strategyAddress);\n            _strategies[strategyIdx] = _strategy;\n        }\n        return _strategies;\n    }\n    \n    /**\n     * Filter a strategy using a reverse polish notation (RPM) query language\n     *\n     * Each instruction is a tuple of either two or three strings.\n     *\n     * Argument 0 - Operand type\n     * -------------------------\n     * KEY      - Denotes a value should be fetched using a function sighash derived from argument 1\n     * VALUE    - A value to be added directly to the stack\n     * OPERATOR - The name of the instruction to execute\n     *\n     * Argument 1 - Key/Value or operator\n     * ----------------------------------\n     * Data     - If KEY or VALUE are specified in argument 0, argument 1 represents either the key\n     *            to fetch data with or the value to be added to the stack\n     * Operator - If OPERATOR is specified in argument 0, argument 1 represents the operator to execute.\n     *            Valid operators are: EQ, GT, GTE, LT, LTE, OR, AND, NE and LIKE\n     *\n     * Argument 2 - Value type\n     * -----------------------\n     * For key/value operands argument 2 describes how to parse a value to be placed on the stack.\n     * Valid options are: STRING, HEX, DECIMAL\n     *\n     * Note: The stack size is 32 bytes. Any values beyond this will be truncated.\n     *\n     * Example Filter\n     * ==============\n     * Description: Find all strategies whose apiVersion is like 0.3.5 or 0.3.3\n     *              where strategist address is C3D6880fD95E06C816cB030fAc45b3ffe3651Cb0\n     * filter = [\n     *     [\"KEY\",        \"apiVersion\", \"STRING\"],\n     *     [\"VALUE\",      \"0.3.5\", \"STRING\"],\n     *     [\"OPERATOR\",   \"LIKE\"],\n     *     [\"KEY\",        \"apiVersion\", \"STRING\"],\n     *     [\"VALUE\",      \"0.3.3\", \"STRING\"],\n     *     [\"OPERATOR\",   \"LIKE\"],\n     *     [\"OPERATOR\",   \"OR\"],\n     *     [\"KEY\",        \"strategist\", \"HEX\"],\n     *     [\"VALUE\",      \"C3D6880fD95E06C816cB030fAc45b3ffe3651Cb0\", \"HEX\"],\n     *     [\"OPERATOR\",   \"EQ\"],\n     *     [\"OPERATOR\",   \"AND\"]\n     * ];\n     */\n    function strategyPassesFilter(address strategyAddress, string[][] memory instructions) public view returns (bool) {\n        bytes32[] memory stack = new bytes32[](instructions.length * 3);\n        uint256 stackLength;\n        for (uint256 instructionsIdx; instructionsIdx < instructions.length; instructionsIdx++) {\n            string[] memory instruction = instructions[instructionsIdx];\n            string memory instructionPart1 = instruction[1];\n            bool operandIsOperator = stringsEqual(instruction[0], \"OPERATOR\");\n            if (operandIsOperator) {\n                bool result;\n                bytes32 operandTwo = stack[stackLength - 1];\n                bytes32 operandOne = stack[stackLength - 2];\n                if (stringsEqual(instruction[1], \"EQ\")) {\n                    result = uint256(operandTwo) == uint256(operandOne);\n                }\n                if (stringsEqual(instruction[1], \"NE\")) {\n                    result = uint256(operandTwo) != uint256(operandOne);\n                }\n                if (stringsEqual(instruction[1], \"GT\")) {\n                    result = uint256(operandTwo) > uint256(operandOne);\n                }\n                if (stringsEqual(instruction[1], \"GTE\")) {\n                    result = uint256(operandTwo) >= uint256(operandOne);\n                }\n                if (stringsEqual(instruction[1], \"LT\")) {\n                    result = uint256(operandTwo) < uint256(operandOne);\n                }\n                if (stringsEqual(instruction[1], \"LTE\")) {\n                    result = uint256(operandTwo) <= uint256(operandOne);\n                }\n                if (stringsEqual(instruction[1], \"AND\")) {\n                    result = uint256(operandTwo & operandOne) == 1;\n                }\n                if (stringsEqual(instruction[1], \"OR\")) {\n                    result = uint256(operandTwo | operandOne) == 1;\n                }\n                if (stringsEqual(instruction[1], \"LIKE\")) {\n                    string memory haystack = String.bytes32ToString(operandOne);\n                    string memory needle = String.bytes32ToString(operandTwo);\n                    result = String.contains(haystack, needle);\n                }\n                if (result) {\n                    stack[stackLength - 2] = bytes32(uint256(1));\n                } else {\n                    stack[stackLength - 2] = bytes32(uint256(0));\n                }\n                stackLength--;\n            } else {\n                bytes32 stackItem;\n                bool operandIsKey = stringsEqual(instruction[0], \"KEY\");\n                bytes memory data;\n                if (operandIsKey) {\n                    (, bytes memory matchBytes) =\n                        address(strategyAddress).staticcall(abi.encodeWithSignature(string(abi.encodePacked(instruction[1], \"()\"))));\n                    data = matchBytes;\n                }\n                if (stringsEqual(instruction[2], \"HEX\")) {\n                    if (operandIsKey == true) {\n                        assembly {\n                            stackItem := mload(add(data, 0x20))\n                        }\n                    } else {\n                        stackItem = bytes32(atoi(String.uppercase(instruction[1]), 16));\n                    }\n                } else if (stringsEqual(instruction[2], \"STRING\")) {\n                    if (operandIsKey == true) {\n                        assembly {\n                            stackItem := mload(add(data, 0x60))\n                        }\n                    } else {\n                        assembly {\n                            stackItem := mload(add(instructionPart1, 0x20))\n                        }                        \n                    }\n                } else if (stringsEqual(instruction[2], \"DECIMAL\")) {\n                    if (operandIsKey == true) {\n                        assembly {\n                            stackItem := mload(add(data, 0x20))\n                        }\n                    } else {\n                        stackItem = bytes32(atoi(instruction[1], 10));\n                    }\n                }\n                stack[stackLength] = stackItem;\n                stackLength++;\n            }\n        }\n        if (uint256(stack[0]) == 1) {\n            return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Allow storage slots to be manually updated\n     */\n    function updateSlot(bytes32 slot, bytes32 value) external {\n        require(msg.sender == ownerAddress, \"Caller is not the owner\");\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}\n\nlibrary String {\n    /**\n     * Convert a string to lowercase\n     */\n    function lowercase(string memory input) internal pure returns (string memory) {\n        bytes memory _input = bytes(input);\n        for (uint inputIdx = 0; inputIdx < _input.length; inputIdx++) {\n            uint8 character = uint8(_input[inputIdx]);\n            if (character >= 65 && character <= 90) {\n                character += 0x20;\n                _input[inputIdx] = bytes1(character);\n            }\n        }\n        return string(_input);\n    }\n\n    /**\n     * Convert a string to uppercase\n     */\n    function uppercase(string memory input) internal pure returns (string memory) {\n        bytes memory _input = bytes(input);\n        for (uint inputIdx = 0; inputIdx < _input.length; inputIdx++) {\n            uint8 character = uint8(_input[inputIdx]);\n            if (character >= 97 && character <= 122) {\n                character -= 0x20;\n                _input[inputIdx] = bytes1(character);\n            }\n        }\n        return string(_input);\n    }\n\n    /**\n     * Search for a needle in a haystack\n     */\n    function contains(string memory haystack, string memory needle) internal pure returns (bool) {\n        return indexOf(needle, haystack) >= 0;\n    }\n    \n    /**\n     * Convert bytes32 to string and remove padding\n     */\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n    /**\n     * Case insensitive string search\n     *\n     * @param needle The string to search for\n     * @param haystack The string to search in\n     * @return Returns -1 if no match is found, otherwise returns the index of the match \n     */\n    function indexOf(string memory needle, string memory haystack) internal pure returns (int256) {\n        bytes memory _needle = bytes(lowercase(needle));\n        bytes memory _haystack = bytes(lowercase(haystack));\n        if (_haystack.length < _needle.length) {\n            return -1;\n        }\n        bool _match;\n        for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\n            for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\n                uint8 needleChar = uint8(_needle[needleIdx]);\n                if (haystackIdx + needleIdx >= _haystack.length) {\n                    return -1;\n                }\n                uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\n                if (needleChar == haystackChar) {\n                    _match = true;\n                    if (needleIdx == _needle.length - 1) {\n                        return int(haystackIdx);\n                    }\n                } else {\n                    _match = false;\n                    break;\n                }\n            }\n        }\n        return -1;\n    }\n}\n"
    }
  }
}