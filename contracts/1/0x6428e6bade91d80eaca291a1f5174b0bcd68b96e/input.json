{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Context {\n    /**\n     * @return Address of the transaction message sender {msg.sender}\n     * Returns the msg.sender\n     */\n    function _msgSender() internal view returns (address) {\n        return msg.sender;\n    }\n}\n\ncontract Ownable is Context {\n    address public _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @param tokenOwner address of the token owner\n     * Transfers ownership to tokenOwner\n     */\n    constructor(address tokenOwner) {\n        _transferOwnership(tokenOwner);\n    }\n\n    /**\n     * @return Address of the owner of the contract\n     * Returns the owner address\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * Modifier that checks if the msg.sender is the owner\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @return Boolean value true if flow was successful\n     * Only owner can call the function\n     * Releases ownership to address 0x0\n     */\n    function renounceOwnership() public onlyOwner returns(bool) {\n        _transferOwnership(address(0));\n        return true;\n    }\n    \n    /**\n     * @return Boolean value true if flow was successful\n     * Only owner can call the function\n     * Releases ownership to address newOwner\n     */\n    function transferOwnership(address newOwner) public onlyOwner returns(bool){\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n        return true;\n    }\n\n    /**\n     * Sets newOwner as the owner and emits the OwnershipTransferred event\n     */\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\n\nimport \"./IERC20.sol\";\nimport \"./Ownable.sol\";\npragma solidity ^0.8.9;\n\ncontract Token is IERC20, Ownable {\n\n    string private _name;\n    string private _symbol;\n\n    uint8 private _decimals;\n    uint8 constant MAX_TAX_FEE_RATE = 6;\n    uint8[4] private taxPercentages;\n    uint8 public taxFee;\n    uint256 public _totalSupply;\n    uint256 public whaleAmount;\n    uint256 public totalVestings;\n\n\n    bool public antiWhale;\n    bool public _enableTax;\n\n    address[4] public taxAddresses;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _isExcludedFromFee;\n    mapping(uint256 => VestingDetails) public vestingID;\n    mapping(address => uint256[]) receiverIDs;\n    mapping(address => bool) isWhitelistedFromWhaleAmount;\n\n    enum taxAddressType {\n        taxAddressNewMovies,\n        taxAddressProfit,\n        taxAddressDevelopment,\n        taxAddressUserCredit\n    }\n\n    event whaleAmountUpdated(\n        uint256 oldAmount,\n        uint256 newAmount,\n        uint256 time\n    );\n    event antiWhaleUpdated(bool status, uint256 time);\n    event taxAddressUpdated(address taxAddress, uint256 time, string info);\n    event UpdatedWhitelistedAddress(address _address, bool isWhitelisted);\n    event TaxTransfer(\n        address indexed from,\n        address[4] indexed to,\n        uint256[4] indexed value\n    );\n\n    struct VestingDetails {\n        address receiver;\n        uint256 amount;\n        uint256 release;\n        bool expired;\n    }\n\n    /**\n     * @dev Constructor.\n     * @param __name name of the token\n     * @param __symbol symbol of the token, 3-4 chars is recommended\n     * @param __decimals number of decimal places of one token unit, 18 is widely used\n     * @param _taxPercent will be the tax percentage, example: 6%\n     * @param __totalSupply total supply of tokens in lowest units (depending on decimals)\n     * @param _antiWhale to enable the antiwhale feature on/off, by default value is false.\n     * @param _whaleAmount whale amount of tokens in lowest units (depending on decimals)\n     * @param owner address that gets 100% of token supply\n     * @param _taxAddresses will be the 4 addresses to which the tax fees will be sent in each token transfer when tax is applicable\n     * @param _taxPercentages are the ratios of the tax percentage divided between the 4 _taxAddresses for example => [ 10%, 20%, 30%, 40% ]\n     */\n    constructor(\n        string memory __name,\n        string memory __symbol,\n        uint8 __decimals,\n        uint8 _taxPercent,\n        uint256 __totalSupply,\n        bool _antiWhale,\n        uint256 _whaleAmount,\n        address owner,\n        address[4] memory _taxAddresses,\n        uint8[4] memory _taxPercentages\n    ) Ownable(owner) {\n        require(owner != address(0), \"Owner can't be zero address\");\n        require(\n            _taxAddresses[0] != address(0) &&\n                _taxAddresses[1] != address(0) &&\n                _taxAddresses[2] != address(0) &&\n                _taxAddresses[3] != address(0),\n            \"Tax addresses cannot be zero address\"\n        );\n        require(_taxPercent <= MAX_TAX_FEE_RATE, \"Exceeded max tax rate limit\");\n        require(\n            _taxPercentages[0] +\n                _taxPercentages[1] +\n                _taxPercentages[2] +\n                _taxPercentages[3] ==\n                100,\n            \"Total percentages must equal 100\"\n        );\n        require(_whaleAmount < __totalSupply, \"Whale amount must be lower than total supply\");\n\n        _name = __name;\n        _symbol = __symbol;\n        _decimals = __decimals;\n        _owner = owner;\n        whaleAmount = _whaleAmount * 10**__decimals;\n        antiWhale = _antiWhale;\n        _totalSupply = __totalSupply * 10**__decimals;\n        taxFee = _taxPercent;\n        _enableTax = true;\n\n        // set tokenOwnerAddress as owner of all tokens and the owner has the control of antiWhale feature if enabled.\n        _balances[_owner] = _totalSupply;\n\n        // Mapping tax address\n        taxAddresses[uint256(taxAddressType.taxAddressDevelopment)] = _taxAddresses[uint256(taxAddressType.taxAddressDevelopment)];\n        taxAddresses[uint256(taxAddressType.taxAddressNewMovies)] = _taxAddresses[uint256(taxAddressType.taxAddressNewMovies)];\n        taxAddresses[uint256(taxAddressType.taxAddressProfit)] = _taxAddresses[uint256(taxAddressType.taxAddressProfit)];\n        taxAddresses[uint256(taxAddressType.taxAddressUserCredit)] = _taxAddresses[uint256(taxAddressType.taxAddressUserCredit)];\n\n        // Mapping tax percentages\n        taxPercentages[uint256(taxAddressType.taxAddressDevelopment)] = _taxPercentages[uint256(taxAddressType.taxAddressDevelopment)];\n        taxPercentages[uint256(taxAddressType.taxAddressNewMovies)] = _taxPercentages[uint256(taxAddressType.taxAddressNewMovies)];\n        taxPercentages[uint256(taxAddressType.taxAddressProfit)] = _taxPercentages[uint256(taxAddressType.taxAddressProfit)];\n        taxPercentages[uint256(taxAddressType.taxAddressUserCredit)] = _taxPercentages[uint256(taxAddressType.taxAddressUserCredit)];\n\n        // Owner and taxAddresses are excluded from transfer tax fees\n        _isExcludedFromFee[_owner] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressDevelopment)]] = true;\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressNewMovies)]] = true;\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressProfit)]] = true;\n        _isExcludedFromFee[taxAddresses[uint256(taxAddressType.taxAddressUserCredit)]] = true;\n\n        isWhitelistedFromWhaleAmount[_owner] = true;\n        isWhitelistedFromWhaleAmount[address(this)] = true;\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressDevelopment)]] = true;\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressNewMovies)]] = true;\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressProfit)]] = true;\n        isWhitelistedFromWhaleAmount[taxAddresses[uint256(taxAddressType.taxAddressUserCredit)]] = true;\n\n\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @return the number of decimals of the token.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @return the total supply of tokens\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Allows the owner to change the whale amount per transaction\n     * @param _amount The amount of lowest token units to be set as whaleAmount\n     * @return _success true (bool) if the flow was successful\n     */\n    function updateWhaleAmount(uint256 _amount)\n        external\n        onlyOwner\n        returns (bool _success)\n    {\n        require(antiWhale, \"Anti whale is turned off\");\n        uint256 oldAmount = whaleAmount;\n        whaleAmount = _amount;\n        emit whaleAmountUpdated(oldAmount, whaleAmount, block.timestamp);\n        return true;    \n    }\n\n    /**\n     * @dev Allows the owner to turn the anti whale feature on/off.\n     * @param status disable (false) / enable (enable) bool value\n     * @return _success true (bool) if the flow was successful\n     */\n    function updateAntiWhale(bool status) external onlyOwner returns (bool _success) {\n        antiWhale = status;\n        emit antiWhaleUpdated(antiWhale, block.timestamp);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * @param spender Address of spender\n     * @param value uint amount that spender is approved by msg.sender to spend\n     * @return _success bool (true) if flow was successful\n     *\n     * Approves spender to spend value tokens from msg.sender\n     */\n    function approve(address spender, uint256 value) public returns (bool _success) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n        /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * @param owner Address of owner of token who sets allowance for spender to use the owner's tokens\n     * @param spender Address of spender whose allowance is being set by msg.sender\n     * @param value Value by which spender's allowance is being reduced\n     * @return _success bool value => true if flow was successful\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal returns (bool _success) {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n        return true;\n    }\n\n        /**\n     * @dev See `IERC20.allowance`.\n     * @param owner Address of the owner of the tokens\n     * @param spender Address of the spender of the owners's tokens\n     * @return the amount of token set by owner for spender to spend\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n        /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * @param spender Address of spender whose allowance is being increased by msg.sender\n     * @param addedValue Value by which spender's allowance is being increased\n     * @return _success bool value => true if flow was successful\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        returns (bool _success)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * @param spender Address of spender whose allowance is being increased by msg.sender\n     * @param subtractedValue Value by which spender's allowance is being reduced\n     * @return _success bool value => true if flow was successful \n     *   \n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        returns (bool _success)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] - subtractedValue\n        );\n        return true;\n    }\n\n    /**\n     * @param _address Address of the user\n     * @param _isWhitelisted boolean (true or false), whether the address must be enabled/disabled from whitelist\n     * @return success Boolean value => true if flow was successful\n     * Updates an account's status in the whitelistFromWhaleAmount (enable/disable)\n     */\n    function updateWhitelistedAddressFromWhale(address _address, bool _isWhitelisted) public onlyOwner\n    returns(bool success){\n        isWhitelistedFromWhaleAmount[_address] = _isWhitelisted;\n        emit UpdatedWhitelistedAddress(_address, _isWhitelisted);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * @param sender Address of sender whose is transferring amount to the recipient\n     * @param recipient Address of the receiver of tokens from the sender\n     * @param amount Amount of tokens being transferred by sender to the recipient\n     * @return _success Boolean value => true if flow was successful\n     *\n     *Transfers {amount} token from sender to recipient\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool _success) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     * @param recipient Address of the receiver of tokens from the sender\n     * @param amount Amount of tokens being transferred by sender to the recipient\n     * @return _success Boolean value true if the flow is successful\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool _success) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n        /**\n     * @dev Allows the caller to airdrop tokens.\n     * @param users Addresses of the users.\n     * @param amounts Token values to the corresponding users.\n     * @param totalSum Total sum of the tokens to be airdropped to all users.\n     * @return _success true (bool) if the flow was successful\n     */\n    function multiSend(\n        address[] memory users,\n        uint256[] memory amounts,\n        uint256 totalSum\n    ) external returns (bool _success) {\n        require(users.length == amounts.length, \"Length mismatch\");\n        require(totalSum <= balanceOf(msg.sender), \"Not enough balance\");\n\n        for (uint256 i = 0; i < users.length; i++) {\n            _transfer(msg.sender, users[i], amounts[i]);\n        }\n        return true;\n    }\n\n    /**\n     * @param from Address of sender whose is transferring amount to the recipient\n     * @param to Address of the receiver of tokens from the sender\n     * @param amount Amount of tokens being transferred by sender to the recipient\n     * @return _success Boolean value => true if flow was successful\n     * Transfers amount from {from} to {to}\n     * Checks for antiWhale\n     * Checks for tax applicability\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool _success) {\n        \n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        // Transfer will be taxed if both sender and receiver are not excluded from fee\n        bool isTaxed = _enableTax &&\n            (!(_isExcludedFromFee[from] || _isExcludedFromFee[to]));\n\n        // Checking for anti-whale\n        if (antiWhale) {\n            uint256 tax_amount = 0;\n            if (isTaxed) tax_amount = (amount * taxFee) / 10**2;\n            require(\n                (amount - tax_amount) <= whaleAmount,\n                \"Transfer amount exceeds max amount\"\n            );\n            //If account is not whitelisted from whale amount, then checking if total balance will be greater than whale amount \n            if(!isWhitelistedFromWhaleAmount[to]){\n                require(\n                    balanceOf(to) + amount - tax_amount <= whaleAmount,\n                    \"Recipient amount exceeds max amount\"\n                );\n            }\n        }\n        unchecked {\n            require(balanceOf(from) >= amount, \"Amount exceeds balance\");\n            _balances[from] = _balances[from] - amount;\n        }\n\n        // If any account belongs to _isExcludedFromFee account then no tax will be applied\n        if (!isTaxed) {\n            // No tax\n            // SafeMath for addition overflow built-in\n            _balances[to] += amount;\n            emit Transfer(from, to, amount);\n        } else {\n            // Calculation of Tax amount\n            uint256 tax_amount = (amount * taxFee) / (10**2);\n\n            _transferFee(tax_amount);\n\n            // Subtracting tax from transfer amount to receiver\n            _balances[to] += amount - tax_amount;\n            emit Transfer(from, to, amount - tax_amount);\n        }\n        return true;\n    }\n\n    /**\n     * @param tax Amount of tokens to be divided between the 4 tax addresses\n     * @return _success Boolean value => true if flow was successful\n     * Transfers the tax fee to the tax addresses divided between them in the ratio provided in taxRatios\n     */\n    function _transferFee(uint256 tax) private returns (bool _success) {\n        uint8[4] storage taxRatios = taxPercentages;\n        address[4] storage _taxAddresses = taxAddresses;\n        // Transfers the tax fee to the tax addresses : taxAddressDevelopment, taxAddressNewMovies, taxAddressProfit\n        uint256 taxAmountDevelopment = (tax * taxRatios[uint256(taxAddressType.taxAddressDevelopment)]) / (100);\n        uint256 taxAmountNewMovies = (tax * taxRatios[uint256(taxAddressType.taxAddressNewMovies)]) / (100);\n        uint256 taxAmountProfit = (tax * taxRatios[uint256(taxAddressType.taxAddressProfit)]) / (100);\n        uint256 taxAmountUserCredit = (tax * taxRatios[uint256(taxAddressType.taxAddressUserCredit)]) / (100);\n\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressDevelopment)]] += taxAmountDevelopment ;\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressNewMovies)]] += taxAmountNewMovies;\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressProfit)]] += taxAmountProfit;\n\n        uint256 totalDivided = taxAmountDevelopment + taxAmountNewMovies + taxAmountProfit + taxAmountUserCredit;\n\n        _balances[_taxAddresses[uint256(taxAddressType.taxAddressUserCredit)]] += taxAmountUserCredit + tax - (totalDivided);\n\n        return true;\n    }\n\n    /**\n     * @param account Address of the account to be checked if its excluded from tax fees\n     * @return _success Boolean value => true if flow was successful\n     * Checks if account is excluded from tax fee\n     */\n    function isExcludedFromFee(address account) public view returns (bool _success) {\n        return _isExcludedFromFee[account];\n    }\n\n        /** \n    * @param applicable Boolean to set the tax applicability as true or false\n    * @return _success boolean (true) if flow was successful\n    Changes the tax applicability as provided in the input\n    */\n    function isTaxApplicable(bool applicable)\n        external\n        onlyOwner\n        returns (bool _success)\n    {\n        if (_enableTax != applicable) {\n            _enableTax = applicable;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @param newAddress Address of the new taxAddress of type {_type}\n     * @param _type Tax address type, one of the 4 types : \n        taxAddressNewMovies,\n        taxAddressProfit,\n        taxAddressDevelopment,\n        taxAddressUserCredit\n     * @return _success Boolean value => true if flow was successful\n     * Changes tax address of type {_type}\n     * Includes the previous address in tax fee\n     * Excludes the new address from tax fee\n     * Exclude old address from whitelist, and includes the new address\n     */\n    function changeTaxAddress(address newAddress, taxAddressType _type)\n        external\n        onlyOwner\n        returns (bool _success)\n    {   \n        includeInFee(taxAddresses[uint256(_type)]);\n        updateWhitelistedAddressFromWhale(taxAddresses[uint256(_type)], false);\n        updateWhitelistedAddressFromWhale(newAddress, true);\n        excludeFromFee(newAddress);\n        taxAddresses[uint256(_type)] = newAddress;\n        \n        return true;\n\n    }\n\n    /**\n     * @param _taxPercentages The ratios of the division of the tax fees between the 4 tax addresses\n     * @return _success Boolean value => true if flow was successful\n     * Changes the ratio of tax division between the 4 tax addresses: \n        taxAddressNewMovies,\n        taxAddressProfit,\n        taxAddressDevelopment,\n        taxAddressUserCredit\n     */\n    function changeTaxPercentages(uint8[4] calldata _taxPercentages)\n        external\n        onlyOwner\n        returns (bool _success)\n    {\n        require(\n            _taxPercentages[0] +\n                _taxPercentages[1] +\n                _taxPercentages[2] +\n                _taxPercentages[3] ==\n                100,\n            \"Total percentages must equal 100\"\n        );\n        taxPercentages[uint256(taxAddressType.taxAddressDevelopment)] = _taxPercentages[uint256(taxAddressType.taxAddressDevelopment)];\n        taxPercentages[uint256(taxAddressType.taxAddressNewMovies)] = _taxPercentages[uint256(taxAddressType.taxAddressNewMovies)];\n        taxPercentages[uint256(taxAddressType.taxAddressProfit)] = _taxPercentages[uint256(taxAddressType.taxAddressProfit)];\n        taxPercentages[uint256(taxAddressType.taxAddressUserCredit)] = _taxPercentages[uint256(taxAddressType.taxAddressUserCredit)];\n        return true;\n    }\n\n    /**\n     * @param _taxFee Tax rate in percentage to be set by owner\n     * @return _success Boolean value => true if flow was successful\n     * Owner can set the tax rate, maximum upto 6%\n     */\n    function changeTaxFeePercent(uint8 _taxFee) external onlyOwner returns (bool _success) {\n        require(_taxFee <= MAX_TAX_FEE_RATE, \"Exceeded max tax rate\");\n        taxFee = _taxFee;\n        return true;\n    }\n\n    /**\n     * @param account Address of account to be evicted from taxes during each transfer\n     * @return _success Boolean value => true if flow was successful\n     * Account will be evicted from taxes for each transfer\n     */\n    function excludeFromFee(address account) public onlyOwner returns (bool _success) {\n        _isExcludedFromFee[account] = true;\n        return true;\n    }\n\n    /**\n     * @param account Address of account to be applicable to pay taxes during each transfer\n     * @return _success Boolean value => true if flow was successful\n     * Account will be applicable to pay taxes for each transfer\n     */\n    function includeInFee(address account) public onlyOwner returns (bool _success) {\n        _isExcludedFromFee[account] = false;\n        return true;\n    }\n\n    /**\n     * @param account Address of account\n     * @return Number of tokens owned by the account\n     * Returns the balance of tokens of the account\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n    * @param _receiver Address of the receiver of the vesting\n    * @param _amount Amount of tokens to be locked up for vesting\n    * @param _release Timestamp of the release time\n    * @return _success Boolean value true if flow is successful\n    * Creates a new vesting\n    */\n    function createVesting(\n        address _receiver,\n        uint256 _amount,\n        uint256 _release\n    ) public returns (bool _success) {\n        require(_receiver != address(0), \"Zero receiver address\");\n        require(_amount > 0, \"Zero amount\");\n        require(_release > block.timestamp, \"Incorrect release time\");\n\n        totalVestings++;\n        vestingID[totalVestings] = VestingDetails(\n            _receiver,\n            _amount,\n            _release,\n            false\n        );\n        // Adds the vesting id corresponding to the receiver\n        receiverIDs[_receiver].push(totalVestings);\n        require(_transfer(msg.sender, address(this), _amount));\n        return true;\n    }\n\n        /**\n    * @param _receivers Arrays of address of receiver of vesting amount\n    * @param _amounts Array of amounts corresponding to each vesting\n    * @param _releases Array of release timestamps corresponding to each vesting\n    * @return _success Boolean value true if flow is successful\n    * Creates multiple vesting, calls createVesting for each corresponding entry in {_receivers} {_amounts} {_releases}\n    */\n    function createMultipleVesting(\n        address[] memory _receivers,\n        uint256[] memory _amounts,\n        uint256[] memory _releases\n    ) external returns (bool _success) {\n        require(\n            _receivers.length == _amounts.length &&\n                _amounts.length == _releases.length,\n            \"Invalid data\"\n        );\n        for (uint256 i = 0; i < _receivers.length; i++) {\n            bool success = createVesting(\n                _receivers[i],\n                _amounts[i],\n                _releases[i]\n            );\n            require(success, \"Creation of vesting failed\");\n        }\n        return true;\n    }\n\n        /**\n    * @param id Id of the vesting\n    * @return Boolean value true if flow is successful\n    * Returns the release timestamp of the the vesting\n    */\n    function getReleaseTime(uint256 id) public view returns(uint256){\n        require(id > 0 && id <= totalVestings, \"Id out of bounds\");\n        VestingDetails storage vestingDetail = vestingID[id];\n        require(!vestingDetail.expired, \"ID expired\");\n        return vestingDetail.release;\n    }\n\n    /**\n    * @param id Id of the vesting\n    * @return _success Boolean value true if flow is successful\n    * The receiver of the vesting can claim their vesting if the vesting ID corresponds to their address \n    * and hasn't expired\n    */\n    function claim(uint256 id) external returns (bool _success) {\n        require(id > 0 && id <= totalVestings, \"Id out of bounds\");\n        VestingDetails storage vestingDetail = vestingID[id];\n        require(msg.sender == vestingDetail.receiver, \"Caller is not the receiver\");\n        require(!vestingDetail.expired, \"ID expired\");\n        require(\n            block.timestamp >= vestingDetail.release,\n            \"Release time not reached\"\n        );\n        vestingID[id].expired = true;\n        require(_transfer(\n            address(this),\n            vestingDetail.receiver,\n            vestingDetail.amount\n        ));\n        return true;\n    }\n\n    /**\n    * @param user Address of receiver of vesting amount\n    * @return Array of IDs corresponding to vesting assigned to the user\n    * Returns the IDs of the vestings , the user corresponds to\n    */\n    function getReceiverIDs(address user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return receiverIDs[user];\n    }\n}"}}}