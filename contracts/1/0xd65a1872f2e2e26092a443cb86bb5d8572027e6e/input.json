{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n// File: contracts\\ozeppelin\\utils\\Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: contracts\\ozeppelin\\utils\\Strings.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant ALPHABET = \"0123456789abcdef\";\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return \"0\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return \"0x00\";\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = \"0\";\r\n    buffer[1] = \"x\";\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = ALPHABET[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, \"Strings: hex length insufficient\");\r\n    return string(buffer);\r\n  }\r\n}\r\n\r\n// File: contracts\\ozeppelin\\utils\\introspection\\IERC165.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @dev Returns true if this contract implements the interface defined by\r\n   * `interfaceId`. See the corresponding\r\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n   * to learn more about how these ids are created.\r\n   *\r\n   * This function call must use less than 30 000 gas.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts\\ozeppelin\\utils\\introspection\\ERC165.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return interfaceId == type(IERC165).interfaceId;\r\n  }\r\n}\r\n\r\n// File: contracts\\ozeppelin\\access\\AccessControl.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n  function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n  function grantRole(bytes32 role, address account) external;\r\n\r\n  function revokeRole(bytes32 role, address account) external;\r\n\r\n  function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n  struct RoleData {\r\n    mapping(address => bool) members;\r\n    bytes32 adminRole;\r\n  }\r\n\r\n  mapping(bytes32 => RoleData) private _roles;\r\n\r\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n  /**\r\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n   *\r\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n   * {RoleAdminChanged} not being emitted signaling this.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  event RoleAdminChanged(\r\n    bytes32 indexed role,\r\n    bytes32 indexed previousAdminRole,\r\n    bytes32 indexed newAdminRole\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is granted `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call, an admin role\r\n   * bearer except when using {_setupRole}.\r\n   */\r\n  event RoleGranted(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when `account` is revoked `role`.\r\n   *\r\n   * `sender` is the account that originated the contract call:\r\n   *   - if using `revokeRole`, it is the admin role bearer\r\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n   */\r\n  event RoleRevoked(\r\n    bytes32 indexed role,\r\n    address indexed account,\r\n    address indexed sender\r\n  );\r\n\r\n  /**\r\n   * @dev Modifier that checks that an account has a specific role. Reverts\r\n   * with a standardized message including the required role.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\r\n   *\r\n   * _Available since v4.1._\r\n   */\r\n  modifier onlyRole(bytes32 role) {\r\n    _checkRole(role, _msgSender());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC165-supportsInterface}.\r\n   */\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == type(IAccessControl).interfaceId ||\r\n      super.supportsInterface(interfaceId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns `true` if `account` has been granted `role`.\r\n   */\r\n  function hasRole(bytes32 role, address account)\r\n    public\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    return _roles[role].members[account];\r\n  }\r\n\r\n  /**\r\n   * @dev Revert with a standard message if `account` is missing `role`.\r\n   *\r\n   * The format of the revert reason is given by the following regular expression:\r\n   *\r\n   *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\r\n   */\r\n  function _checkRole(bytes32 role, address account) internal view {\r\n    if (!hasRole(role, account)) {\r\n      revert(\r\n        string(\r\n          abi.encodePacked(\r\n            \"AccessControl: account \",\r\n            Strings.toHexString(uint160(account), 20),\r\n            \" is missing role \",\r\n            Strings.toHexString(uint256(role), 32)\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n   * {revokeRole}.\r\n   *\r\n   * To change a role's admin, use {_setRoleAdmin}.\r\n   */\r\n  function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\r\n    return _roles[role].adminRole;\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function grantRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from `account`.\r\n   *\r\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must have ``role``'s admin role.\r\n   */\r\n  function revokeRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Revokes `role` from the calling account.\r\n   *\r\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n   * purpose is to provide a mechanism for accounts to lose their privileges\r\n   * if they are compromised (such as when a trusted device is misplaced).\r\n   *\r\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n   * event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the caller must be `account`.\r\n   */\r\n  function renounceRole(bytes32 role, address account) public virtual override {\r\n    require(\r\n      account == _msgSender(),\r\n      \"AccessControl: can only renounce roles for self\"\r\n    );\r\n\r\n    _revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants `role` to `account`.\r\n   *\r\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n   * event. Note that unlike {grantRole}, this function doesn't perform any\r\n   * checks on the calling account.\r\n   *\r\n   * [WARNING]\r\n   * ====\r\n   * This function should only be called from the constructor when setting\r\n   * up the initial roles for the system.\r\n   *\r\n   * Using this function in any other way is effectively circumventing the admin\r\n   * system imposed by {AccessControl}.\r\n   * ====\r\n   */\r\n  function _setupRole(bytes32 role, address account) internal virtual {\r\n    _grantRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `adminRole` as ``role``'s admin role.\r\n   *\r\n   * Emits a {RoleAdminChanged} event.\r\n   */\r\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\r\n    _roles[role].adminRole = adminRole;\r\n  }\r\n\r\n  function _grantRole(bytes32 role, address account) private {\r\n    if (!hasRole(role, account)) {\r\n      _roles[role].members[account] = true;\r\n      emit RoleGranted(role, account, _msgSender());\r\n    }\r\n  }\r\n\r\n  function _revokeRole(bytes32 role, address account) private {\r\n    if (hasRole(role, account)) {\r\n      _roles[role].members[account] = false;\r\n      emit RoleRevoked(role, account, _msgSender());\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts\\ozeppelin\\security\\Pausable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n  /**\r\n   * @dev Emitted when the pause is triggered by `account`.\r\n   */\r\n  event Paused(address account);\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted by `account`.\r\n   */\r\n  event Unpaused(address account);\r\n\r\n  bool private _paused;\r\n\r\n  /**\r\n   * @dev Initializes the contract in unpaused state.\r\n   */\r\n  constructor() {\r\n    _paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the contract is paused, and false otherwise.\r\n   */\r\n  function paused() public view virtual returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused(), \"Pausable: paused\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused(), \"Pausable: not paused\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Triggers stopped state.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   */\r\n  function _pause() internal virtual whenNotPaused {\r\n    _paused = true;\r\n    emit Paused(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns to normal state.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  function _unpause() internal virtual whenPaused {\r\n    _paused = false;\r\n    emit Unpaused(_msgSender());\r\n  }\r\n}\r\n\r\n// File: contracts\\ozeppelin\\token\\ERC20\\IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts\\IBridge.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n// IERC20.sol :  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\ninterface IBridge {\r\n  function version() external pure returns (string memory);\r\n\r\n  function getMinBRZFee(string calldata blockchainName)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function getMinGasPrice(string calldata blockchainName)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function getMinTokenAmount(string calldata blockchainName)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function getTokenBalance() external view returns (uint256);\r\n\r\n  function receiveTokens(\r\n    uint256 amount,\r\n    uint256[2] calldata transactionFee,\r\n    string calldata toBlockchain,\r\n    string calldata toAddress\r\n  ) external returns (bool);\r\n\r\n  function acceptTransfer(\r\n    address receiver,\r\n    uint256 amount,\r\n    string calldata fromBlockchain,\r\n    bytes32[2] calldata hashes, //blockHash, transactionHash\r\n    uint32 logIndex\r\n  ) external returns (bool);\r\n\r\n  function getTransactionId(\r\n    bytes32[2] calldata hashes, //blockHash, transactionHash\r\n    address receiver,\r\n    uint256 amount,\r\n    uint32 logIndex\r\n  ) external returns (bytes32);\r\n\r\n  function existsBlockchain(string calldata name) external view returns (bool);\r\n\r\n  function listBlockchain() external view returns (string[] memory);\r\n\r\n  event CrossRequest(\r\n    address from,\r\n    uint256 amount,\r\n    uint256 toFee,\r\n    string toAddress,\r\n    string toBlockchain\r\n  );\r\n  event FeePercentageBridgeChanged(uint256 oldFee, uint256 newFee);\r\n  event GasAcceptTransferChanged(uint256 oldValue, uint256 newValue);\r\n  event QuoteETH_BRZChanged(uint256 oldValue, uint256 newValue);\r\n  event TokenChanged(address tokenAddress);\r\n  event MinBRZFeeChanged(string blockchainName, uint256 oldFee, uint256 newFee);\r\n  event MinGasPriceChanged(\r\n    string blockchainName,\r\n    uint256 oldFee,\r\n    uint256 newFee\r\n  );\r\n  event MinTokenAmountChanged(\r\n    string blockchainName,\r\n    uint256 oldAmount,\r\n    uint256 newAmount\r\n  );\r\n}\r\n\r\n// File: contracts\\Bridge.sol\r\n\r\npragma solidity 0.8.4;\r\n\r\n/// @title BRZ token Bridge\r\n/// @author Solange Gueiros\r\n\r\n// Inpired on\r\n// https://github.com/rsksmart/tokenbridge/blob/master/bridge/contracts/Bridge.sol\r\n// https://github.com/DistributedCollective/Bridge-SC/blob/master/sovryn-token-bridge/bridge/contracts/Bridge_v3.sol\r\n\r\n// AccessControl.sol :  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/access/AccessControl.sol\r\n// Pausable.sol :       https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/security/Pausable.sol\r\n\r\n\r\n\r\n\r\nstruct BlockchainStruct {\r\n  uint256 minTokenAmount;\r\n  uint256 minBRZFee; // quoteETH_BRZ * gasAcceptTransfer * minGasPrice\r\n  uint256 minGasPrice; // in Wei\r\n  bool checkAddress; // to verify is an address is EVM compatible is this blockchain\r\n}\r\n\r\n/**\r\n * @dev BRZ token Bridge\r\n *\r\n * Author: Solange Gueiros\r\n *\r\n * Smart contract to cross the BRZ token between EVM compatible blockchains.\r\n *\r\n * The tokens are crossed by TransferoSwiss, the company that controls the issuance of BRZs.\r\n *\r\n * It uses [Open Zeppelin Contracts]\r\n * (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/)\r\n *\r\n */\r\ncontract Bridge is AccessControl, IBridge, Pausable {\r\n  address private constant ZERO_ADDRESS = address(0);\r\n  bytes32 private constant NULL_HASH = bytes32(0);\r\n  bytes32 public constant MONITOR_ROLE = keccak256(\"MONITOR_ROLE\");\r\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\r\n\r\n  /**\r\n   * @dev DECIMALPERCENT is the representation of 100% using (2) decimal places\r\n   * 100.00 = percentage accuracy (2) to 100%\r\n   */\r\n  uint256 public constant DECIMALPERCENT = 10000;\r\n\r\n  IERC20 public token;\r\n  uint256 public totalFeeReceivedBridge; // fee received per Bridge, not for transaction in other blockchain\r\n\r\n  /**\r\n   * @dev Fee percentage bridge.\r\n   *\r\n   * For each amount received in the bridge, a fee percentage is discounted.\r\n   * This function returns this fee percentage bridge.\r\n   * Include 2 decimal places.\r\n   */\r\n  uint256 public feePercentageBridge;\r\n\r\n  /**\r\n   * Estimative for function acceptTransfer: 100000 wei, it can change in EVM cost updates\r\n   *\r\n   * It is used to calculate minBRZFee in destination,\r\n   * which can not accept a BRZ fee less than minBRZFee (per blockchain).\r\n   */\r\n  uint256 public gasAcceptTransfer;\r\n\r\n  /**\r\n   * @dev the quote of pair ETH / BRZ.\r\n   *\r\n   * (1 ETH = the amount of BRZ returned)\r\n   *\r\n   * in BRZ in minor unit (4 decimal places).\r\n   *\r\n   * It is used to calculate minBRZFee in destination\r\n   * which can not accept a BRZ fee less than minBRZFee (per blockchain).\r\n   *\r\n   */\r\n  uint256 public quoteETH_BRZ;\r\n\r\n  mapping(bytes32 => bool) public processed;\r\n  mapping(string => uint256) private blockchainIndex;\r\n  BlockchainStruct[] private blockchainInfo;\r\n  string[] public blockchain;\r\n\r\n  /**\r\n   * @dev Function called only when the smart contract is deployed.\r\n   *\r\n   * Parameters:\r\n   * - address tokenAddress - address of BRZ token used in this blockchain network\r\n   *\r\n   * Actions:\r\n   * - the transaction's sender will be added in the DEFAULT_ADMIN_ROLE.\r\n   * - the token will be defined by the parameter tokenAddress\r\n   * - the feePercentageBridge default value is be setted in 10, which means 0.1%\r\n   */\r\n  constructor(address tokenAddress) {\r\n    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n    token = IERC20(tokenAddress);\r\n    feePercentageBridge = 10; //0.1%\r\n    gasAcceptTransfer = 100000; //Estimative function acceptTransfer: 100000 wei\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier which verifies if the caller is an owner,\r\n   * it means he has the role `DEFAULT_ADMIN_ROLE`.\r\n   *\r\n   * The role `DEFAULT_ADMIN_ROLE` is defined by Open Zeppelin's AccessControl smart contract.\r\n   *\r\n   * By default (setted in the constructor) the account which deployed this smart contract is in this role.\r\n   *\r\n   * This owner can add / remove other owners.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"not owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier which verifies if the caller is a monitor,\r\n   * it means he has the role `MONITOR_ROLE`.\r\n   *\r\n   * Role MONITOR are referred to its `bytes32` identifier,\r\n   * defined in the `public constant` called MONITOR_ROLE.\r\n   * It should be exposed in the external API and be unique.\r\n   *\r\n   * Role MONITOR is used to manage the permissions of monitor's addresses.\r\n   */\r\n  modifier onlyMonitor() {\r\n    require(hasRole(MONITOR_ROLE, _msgSender()), \"not monitor\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier which verifies if the caller is a monitor,\r\n   * it means he has the role `ADMIN_ROLE`.\r\n   *\r\n   * Role ADMIN are referred to its `bytes32` identifier,\r\n   * defined in the `public constant` called ADMIN_ROLE.\r\n   * It should be exposed in the external API and be unique.\r\n   *\r\n   * Role ADMIN is used to manage the permissions for update minimum fee per blockchain.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(hasRole(ADMIN_ROLE, _msgSender()), \"not admin\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function which returns the bridge's version.\r\n   *\r\n   * This is a fixed value define in source code.\r\n   *\r\n   * Parameters: none\r\n   *\r\n   * Returns: string\r\n   */\r\n  function version() external pure override returns (string memory) {\r\n    return \"v0\";\r\n  }\r\n\r\n  /**\r\n   * @dev Private function to compare two strings\r\n   * and returns `true` if the strings are equal,\r\n   * otherwise it returns false.\r\n   *\r\n   * Parameters: stringA, stringB\r\n   *\r\n   * Returns: bool\r\n   */\r\n  function compareStrings(string memory a, string memory b)\r\n    private\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return (keccak256(abi.encodePacked((a))) ==\r\n      keccak256(abi.encodePacked((b))));\r\n  }\r\n\r\n  /**\r\n   * @dev This function starts the process of crossing tokens in the Bridge.\r\n   *\r\n   * > Any account / person can call it!\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters:\r\n   * - amount - gross amount of tokens to be crossed.\r\n   *   - The Bridge fee will be deducted from this amount.\r\n   * - transactionFee - array with the fees:\r\n   *   - transactionFee[0] - fee in BRL - this fee will be added to amount transfered from caller's account.\r\n   *   - transactionFee[1] - gas price for fee in destiny currency(minor unit) - this information will be\r\n   *      used in the destination Blockchain,\r\n   *      by the monitor who will create the transaction and send using this fee defined here.\r\n   * - toBlockchain - the amount will be sent to this blockchain.\r\n   * - toAddress - the amount will be sent to this address. It can be diferent from caller's address.\r\n   * This is a string because some blockchain could not have the same pattern from Ethereum / RSK / BSC.\r\n   *\r\n   * Returns: bool - true if it is sucessful.\r\n   *\r\n   * > Before call this function, the caller MUST have called function `approve` in BRZ token,\r\n   * > allowing the bridge's smart contract address to use the BRZ tokens,\r\n   * > calling the function `transferFrom`.\r\n   *\r\n   * References:\r\n   *\r\n   * ERC-20 tokens approve and transferFrom pattern:\r\n   * [eip-20#transferfrom](https://eips.ethereum.org/EIPS/eip-20#transferfrom)\r\n   *\r\n   * Requirements:\r\n   * - fee in BRZ (transactionFee[0]) must be at least (BRZFactorFee[blockchainName] * minGasPrice[toBlockchain]).\r\n   * - gasPrice (transactionFee[1]) in destiny blockchain (minor unit) greater than minGasPrice in toBlockchain.\r\n   * - toBlockchain exists.\r\n   * - toAddress is not an empty string.\r\n   * - amount must be greater than minTokenAmount in toBlockchain.\r\n   * - amount greater than zero.\r\n   *\r\n   * Actions:\r\n   * - add the blockchain fee in BRZ to amount in BRZ, in totalAmount.\r\n   * - calculate bridge's fee using the original amount to be sent.\r\n   * - discount bridge's fee from the original amount, in amountMinusFees.\r\n   * - add bridge's fee to `totalFeeReceivedBridge`, a variable to store all the fees received by the bridge.\r\n   * - BRZ transfer totalAmount from the caller's address to bridge address.\r\n   * - emit `CrossRequest` event, with the parameters:\r\n   *   - from - address of the caller's function.\r\n   *   - amount - the net amount to be transfered in the destination blockchain.\r\n   *   - toFee - the gas price fee, which must be used to send the transfer transaction in the destination blockchain.\r\n   *   - toAddress - string representing the address which will receive the tokens.\r\n   *   - toBlockchain - the destination blockchain.\r\n   *\r\n   * > The `CrossRequest` event is very important because it must be listened by the monitor,\r\n   * an external program which will\r\n   * send the transaction on the destination blockchain.\r\n   *\r\n   * #### More info about fees\r\n   *\r\n   * - Blockchain / transaction fee in BRL (transactionFee[0])\r\n   * It will be transfered from user's account,\r\n   * along with the amount he would like to receive in the account.\r\n   *\r\n   * This will be spent in `toBlockchain`.\r\n   * Does not depend of amount, but of destination blockchain.\r\n   *\r\n   * It must be at least the minBRZFee per blockchain.\r\n   *\r\n   * It is used in the function acceptTransfer,\r\n   * which can not accept a BRZ fee less than minBRZFee (per blockchain).\r\n   *\r\n   * - gas price (transactionFee[1])\r\n   * It must be at least the minGasPrice per blockchain.\r\n   *\r\n   * - Bridge Fee - it is deducted from the requested amount.\r\n   * It is a percentage of the requested amount.\r\n   * Cannot include the transaction fee in order to be calculated.\r\n   *\r\n   */\r\n  function receiveTokens(\r\n    uint256 amount,\r\n    uint256[2] memory transactionFee,\r\n    string memory toBlockchain,\r\n    string memory toAddress\r\n  ) external override whenNotPaused returns (bool) {\r\n    require(existsBlockchain(toBlockchain), \"toBlockchain not exists\");\r\n    require(!compareStrings(toAddress, \"\"), \"toAddress is null\");\r\n\r\n    uint256 index = blockchainIndex[toBlockchain] - 1;\r\n    require(\r\n      transactionFee[0] >= blockchainInfo[index].minBRZFee,\r\n      \"feeBRZ is less than minimum\"\r\n    );\r\n    require(\r\n      transactionFee[1] >= blockchainInfo[index].minGasPrice,\r\n      \"gasPrice is less than minimum\"\r\n    );\r\n    require(amount > 0, \"amount is 0\");\r\n    require(\r\n      amount >= blockchainInfo[index].minTokenAmount,\r\n      \"amount is less than minimum\"\r\n    );\r\n    if (blockchainInfo[index].checkAddress) {\r\n      require(bytes(toAddress).length == 42, \"invalid destination address\");\r\n    }\r\n\r\n    //The total amount is the amount desired plus the blockchain fee to destination, in the token unit\r\n    uint256 totalAmount = amount + transactionFee[0];\r\n\r\n    //Bridge fee or service fee\r\n    uint256 bridgeFee = (amount * feePercentageBridge) / DECIMALPERCENT;\r\n    uint256 amountMinusFees = amount - bridgeFee;\r\n    totalFeeReceivedBridge += bridgeFee;\r\n\r\n    //This is the message for Monitor off-chain manage the transaction and send the tokens on the other Blockchain\r\n    emit CrossRequest(\r\n      _msgSender(),\r\n      amountMinusFees,\r\n      transactionFee[1],\r\n      toAddress,\r\n      toBlockchain\r\n    );\r\n\r\n    //Transfer the tokens on IERC20, they should be already approved for the bridge Address to use them\r\n    token.transferFrom(_msgSender(), address(this), totalAmount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function calculate a transaction id hash.\r\n   *\r\n   * Any person can call it.\r\n   *\r\n   * Parameters:\r\n   * - hashes - from transaction in the origin blockchain:\r\n   *   - blockHash - hash of the block where was the transaction `receiveTokens`\r\n   *   - transactionHash - hash of the transaction `receiveTokens` with the event `CrossRequest`.\r\n   * - receiver - the address which will receive the tokens.\r\n   * - amount - the net amount to be transfered.\r\n   * - logIndex - the index of the event `CrossRequest` in the logs of transaction.\r\n   * - sender - address who sent the transaction `receiveTokens`, it is a string to be compatible with any blockchain.\r\n   *\r\n   * Returns: a bytes32 hash of all the information sent.\r\n   *\r\n   * Notes:\r\n   * It did not use origin blockchain and sender address\r\n   * because the possibility of having the same origin transaction from different blockchain source is minimal.\r\n   *\r\n   * It is a point to be evaluated in an audit.\r\n   *\r\n   */\r\n  function getTransactionId(\r\n    bytes32[2] calldata hashes, //blockHash, transactionHash\r\n    address receiver,\r\n    uint256 amount,\r\n    uint32 logIndex\r\n  ) public pure override returns (bytes32) {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(hashes[0], hashes[1], receiver, amount, logIndex)\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the variable processed for a transaction\r\n   *\r\n   * > Only monitor can call it!\r\n   *\r\n   * This variable is a public mapping.\r\n   *\r\n   * Each bytes32 which represents a Transaction Id has his boolen value stored.\r\n   *\r\n   */\r\n  function _processTransaction(\r\n    bytes32[2] calldata hashes, //blockHash, transactionHash\r\n    address receiver,\r\n    uint256 amount,\r\n    uint32 logIndex\r\n  ) private {\r\n    bytes32 transactionId = getTransactionId(\r\n      hashes,\r\n      receiver,\r\n      amount,\r\n      logIndex\r\n    );\r\n    require(!processed[transactionId], \"processed\");\r\n    processed[transactionId] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function transfer tokens from the the internal balance of bridge smart contract\r\n   * to the internal balance of the destination address.\r\n   *\r\n   * The token.balanceOf(bridgeAddress) must always be greather than or equal the total amount to be claimed by users,\r\n   * as there may be tokens not yet claimed.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * > Only monitor can call it!\r\n   *\r\n   */\r\n  function _sendToken(address to, uint256 amount) private returns (bool) {\r\n    require(token.balanceOf(address(this)) >= amount, \"insufficient balance\");\r\n    token.transfer(to, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function accept the cross of token,\r\n   * which means it is called in the destination blockchain,\r\n   * who will send the tokens accepted to be crossed.\r\n   *\r\n   * > Only monitor can call it!\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters:\r\n   * - receiver - the address which will receive the tokens.\r\n   * - amount - the net amount to be transfered.\r\n   * - sender - string representing the address of the token's sender.\r\n   * - fromBlockchain - the origin blockchain.\r\n   * - hashes - from transaction in the origin blockchain:\r\n   *   - blockHash - hash of the block where was the transaction `receiveTokens`.\r\n   *   - transactionHash - hash of the transaction `receiveTokens` with the event `CrossRequest`.\r\n   * - logIndex - the index of the event `CrossRequest` in the transaction logs.\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Requirements:\r\n   * - receiver is not a zero address.\r\n   * - amount greater than zero.\r\n   * - sender is not an empty string.\r\n   * - fromBlockchain exists.\r\n   * - blockHash is not null hash.\r\n   * - transactionHash is not hash.\r\n   *\r\n   * Actions:\r\n   * - processTransaction:\r\n   *   - getTransactionId\r\n   *   - verify if the transactionId was already processed\r\n   *   - update the status processed for transactionId\r\n   * - sendToken:\r\n   *   - check if the bridge has in his balance at least the amount required to do the transfer\r\n   *   - transfer the amount tokens to destination address\r\n   *\r\n   */\r\n  function acceptTransfer(\r\n    address receiver,\r\n    uint256 amount,\r\n    string calldata fromBlockchain,\r\n    bytes32[2] calldata hashes, //blockHash, transactionHash\r\n    uint32 logIndex\r\n  ) external override onlyMonitor whenNotPaused returns (bool) {\r\n    require(receiver != ZERO_ADDRESS, \"receiver is zero\");\r\n    require(amount > 0, \"amount is 0\");\r\n    require(existsBlockchain(fromBlockchain), \"fromBlockchain not exists\");\r\n    require(hashes[0] != NULL_HASH, \"blockHash is null\");\r\n    require(hashes[1] != NULL_HASH, \"transactionHash is null\");\r\n\r\n    _processTransaction(hashes, receiver, amount, logIndex);\r\n    _sendToken(receiver, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns token balance in bridge.\r\n   *\r\n   * Parameters: none\r\n   *\r\n   * Returns: integer amount of tokens in bridge\r\n   *\r\n   */\r\n  function getTokenBalance() external view override returns (uint256) {\r\n    return token.balanceOf(address(this));\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw tokens from bridge\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can be called even if the Bridge is paused,\r\n   * because can happens a problem and it is necessary to withdraw tokens,\r\n   * maybe to create a new version of bridge, for example.\r\n   *\r\n   * The tokens only can be sent to the caller's function.\r\n   *\r\n   * Parameters: integer amount of tokens\r\n   *\r\n   * Returns: true if it is successful\r\n   *\r\n   * Requirements:\r\n   * - amount less or equal balance of tokens in bridge.\r\n   *\r\n   */\r\n  function withdrawToken(uint256 amount) external onlyOwner returns (bool) {\r\n    require(amount <= token.balanceOf(address(this)), \"insuficient balance\");\r\n    token.transfer(_msgSender(), amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function add an address in the `MONITOR_ROLE`.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: address of monitor to be added\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   */\r\n  function addMonitor(address account)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(!hasRole(ADMIN_ROLE, account), \"is admin\");\r\n    grantRole(MONITOR_ROLE, account);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function excludes an address in the `MONITOR_ROLE`.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: address of monitor to be excluded\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   */\r\n  function delMonitor(address account)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    //Can be called only by the account defined in constructor: DEFAULT_ADMIN_ROLE\r\n    revokeRole(MONITOR_ROLE, account);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function add an address in the `ADMIN_ROLE`.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: address of admin to be added\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   */\r\n  function addAdmin(address account)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(!hasRole(MONITOR_ROLE, account), \"is monitor\");\r\n    grantRole(ADMIN_ROLE, account);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function excludes an address in the `ADMIN_ROLE`.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: address of admin to be excluded\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   */\r\n  function delAdmin(address account)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    //Can be called only by the account defined in constructor: DEFAULT_ADMIN_ROLE\r\n    revokeRole(ADMIN_ROLE, account);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function allows a user to renounce a role\r\n   *\r\n   * Parameters: bytes32 role, address account\r\n   *\r\n   * Returns: none\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - An owner can not renounce the role DEFAULT_ADMIN_ROLE.\r\n   * - Can only renounce roles for your own account.\r\n   *\r\n   */\r\n  function renounceRole(bytes32 role, address account) public virtual override {\r\n    require(role != DEFAULT_ADMIN_ROLE, \"can not renounce role owner\");\r\n    require(account == _msgSender(), \"can only renounce roles for self\");\r\n    super.renounceRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev This function allows to revoke a role\r\n   *\r\n   * Parameters: bytes32 role, address account\r\n   *\r\n   * Returns: none\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - An owner can not revoke yourself in the role DEFAULT_ADMIN_ROLE.\r\n   *\r\n   */\r\n  function revokeRole(bytes32 role, address account)\r\n    public\r\n    virtual\r\n    override\r\n    onlyRole(getRoleAdmin(role))\r\n  {\r\n    if (role == DEFAULT_ADMIN_ROLE) {\r\n      require(account != _msgSender(), \"can not revoke yourself in role owner\");\r\n    }\r\n    super.revokeRole(role, account);\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the minimum blockchain fee - gas price - in the minor unit.\r\n   *\r\n   * It is an internal function, called when quoteETH_BRZ, gasAcceptTransfer\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Emit the event `MinBRZFeeChanged(blockchain, oldFee, newFee)`.\r\n   *\r\n   */\r\n  function _updateMinBRZFee() internal returns (bool) {\r\n    for (uint8 i = 0; i < blockchainInfo.length; i++) {\r\n      if (blockchainInfo[i].minGasPrice > 0) {\r\n        uint256 newFee = (gasAcceptTransfer *\r\n          blockchainInfo[i].minGasPrice *\r\n          quoteETH_BRZ) / (1 ether);\r\n        emit MinBRZFeeChanged(\r\n          blockchain[i],\r\n          blockchainInfo[i].minBRZFee,\r\n          newFee\r\n        );\r\n        blockchainInfo[i].minBRZFee = newFee;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function update quote of pair ETH / BRZ.\r\n   *\r\n   * (1 ETH = the amount of BRZ defined)\r\n   *\r\n   * Only admin can call it.\r\n   *\r\n   * Each time quoteETH_BRZ is updated, the MinBRZFee is updated too.\r\n   *\r\n   * Parameters: integer, the new quote\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Emit the event `QuoteETH_BRZChanged(oldValue, newValue)`.\r\n   *\r\n   */\r\n  function setQuoteETH_BRZ(uint256 newValue) public onlyAdmin returns (bool) {\r\n    emit QuoteETH_BRZChanged(quoteETH_BRZ, newValue);\r\n    quoteETH_BRZ = newValue;\r\n    require(_updateMinBRZFee(), \"updateMinBRZFee error\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum gas price to cross tokens.\r\n   *\r\n   * The function acceptTransfer can not accept less than the minimum gas price per blockchain.\r\n   *\r\n   * Parameters: string, blockchain name\r\n   *\r\n   * Returns: integer\r\n   *\r\n   */\r\n  function getMinGasPrice(string memory blockchainName)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return blockchainInfo[blockchainIndex[blockchainName] - 1].minGasPrice;\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the minimum blockchain fee - gas price - in the minor unit.\r\n   *\r\n   * Each time setMinGasPrice is updated, the MinBRZFee is updated too.\r\n   *\r\n   * Only admin can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: integer, the new fee\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Requirements:\r\n   * - blockchain must exists.\r\n   *\r\n   * Emit the event `MinGasPriceChanged(blockchain, oldFee, newFee)`.\r\n   *\r\n   */\r\n  function setMinGasPrice(string memory blockchainName, uint256 newFee)\r\n    public\r\n    onlyAdmin\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(existsBlockchain(blockchainName), \"blockchain not exists\");\r\n    uint256 index = blockchainIndex[blockchainName] - 1;\r\n    emit MinGasPriceChanged(\r\n      blockchainName,\r\n      blockchainInfo[index].minGasPrice,\r\n      newFee\r\n    );\r\n    blockchainInfo[index].minGasPrice = newFee;\r\n    blockchainInfo[index].minBRZFee =\r\n      (gasAcceptTransfer * newFee * quoteETH_BRZ) /\r\n      (1 ether);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum destination blockchain fee in BRZ,\r\n   * in minor unit (4 decimal places)\r\n   *\r\n   * It is updated when one of these itens be updated:\r\n   *  - gasAcceptTransfer\r\n   *  - quoteETH_BRZ\r\n   *  - minGasPrice per Blockchain\r\n   *\r\n   * It is used in the function acceptTransfer,\r\n   * which can not accept a BRZ fee less than minBRZFee (per blockchain).\r\n   *\r\n   * Parameters: string, blockchain name\r\n   *\r\n   * Returns: integer\r\n   *\r\n   */\r\n  function getMinBRZFee(string memory blockchainName)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return blockchainInfo[blockchainIndex[blockchainName] - 1].minBRZFee;\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the estimative of the gas amount used in function AcceptTransfer.\r\n   *\r\n   * It will only change if happen some EVM cost update.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Each time gasAcceptTransfer is updated, the MinBRZFee is updated too.\r\n   *\r\n   * Parameters: integer, the new gas amount\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Emit the event `GasAcceptTransferChanged(oldValue, newValue)`.\r\n   *\r\n   */\r\n  function setGasAcceptTransfer(uint256 newValue)\r\n    public\r\n    onlyOwner\r\n    returns (bool)\r\n  {\r\n    emit GasAcceptTransferChanged(gasAcceptTransfer, newValue);\r\n    gasAcceptTransfer = newValue;\r\n    require(_updateMinBRZFee(), \"updateMinBRZFee error\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the minimum token amount to cross.\r\n   *\r\n   * The function acceptTransfer can not accpept less than the minimum per blockchain.\r\n   *\r\n   * Parameters: string, blockchain name\r\n   *\r\n   * Returns: integer\r\n   *\r\n   */\r\n  function getMinTokenAmount(string memory blockchainName)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return blockchainInfo[blockchainIndex[blockchainName] - 1].minTokenAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the minimum token's amount to be crossed.\r\n   *\r\n   * Only admin can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: integer, the new amount\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Requirements:\r\n   * - blockchain must exists.\r\n   *\r\n   * Emit the event `MinTokenAmountChanged(blockchain, oldMinimumAmount, newMinimumAmount)`.\r\n   *\r\n   */\r\n  function setMinTokenAmount(string memory blockchainName, uint256 newAmount)\r\n    public\r\n    onlyAdmin\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(existsBlockchain(blockchainName), \"blockchain not exists\");\r\n    uint256 index = blockchainIndex[blockchainName] - 1;\r\n    emit MinTokenAmountChanged(\r\n      blockchainName,\r\n      blockchainInfo[index].minTokenAmount,\r\n      newAmount\r\n    );\r\n    blockchainInfo[index].minTokenAmount = newAmount;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the fee percentage bridge.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: integer, the new fee\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Requirements:\r\n   * - The new fee must be lower than 10% .\r\n   *\r\n   * Emit the event `FeePercentageBridgeChanged(oldFee, newFee)`.\r\n   *\r\n   */\r\n  function setFeePercentageBridge(uint256 newFee)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(newFee < (DECIMALPERCENT / 10), \"bigger than 10%\");\r\n    emit FeePercentageBridgeChanged(feePercentageBridge, newFee);\r\n    feePercentageBridge = newFee;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function update the BRZ token.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: address of new BRZ token\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Requirements:\r\n   * - The token address must not be a zero address.\r\n   *\r\n   * Emit the event `TokenChanged(tokenAddress)`.\r\n   *\r\n   */\r\n  function setToken(address tokenAddress)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(tokenAddress != ZERO_ADDRESS, \"zero address\");\r\n    emit TokenChanged(tokenAddress);\r\n    token = IERC20(tokenAddress);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns if a blockchain is in the list of allowed blockchains to cross tokens using the bridge.\r\n   *\r\n   * Parameters: string name of blockchain\r\n   *\r\n   * Returns: boolean true if it is in the list\r\n   *\r\n   */\r\n  function existsBlockchain(string memory name)\r\n    public\r\n    view\r\n    override\r\n    returns (bool)\r\n  {\r\n    if (blockchainIndex[name] == 0) return false;\r\n    else return true;\r\n  }\r\n\r\n  /**\r\n   * @dev List of blockchains allowed to cross tokens using the bridge.\r\n   *\r\n   * Parameters: none\r\n   *\r\n   * Returns: an array of strings containing the blockchain list\r\n   *\r\n   */\r\n  function listBlockchain() external view override returns (string[] memory) {\r\n    return blockchain;\r\n  }\r\n\r\n  /**\r\n   * @dev This function include a new blockchain in the list of allowed blockchains used in the bridge.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters:\r\n   * - string name of blockchain to be added\r\n   * - minGasPrice\r\n   * - minTokenAmount\r\n   * - check address EVM compatible\r\n   *\r\n   * Returns: index of blockchain.\r\n   *\r\n   * Important:\r\n   * - index start in 1, not 0.\r\n   * - index 0 means that the blockchain does no exist.\r\n   * - index 1 means that it is the position 0 in the array.\r\n   *\r\n   * Requirements:\r\n   * - blockchain not exists.\r\n   * - onlyOwner\r\n   * - whenNotPaused\r\n   */\r\n  function addBlockchain(\r\n    string memory name,\r\n    uint256 minGasPrice,\r\n    uint256 minTokenAmount,\r\n    bool checkAddress\r\n  ) external onlyOwner whenNotPaused returns (uint256) {\r\n    require(!existsBlockchain(name), \"blockchain exists\");\r\n\r\n    BlockchainStruct memory b;\r\n    b.minGasPrice = minGasPrice;\r\n    b.minTokenAmount = minTokenAmount;\r\n    b.minBRZFee = (gasAcceptTransfer * minGasPrice * quoteETH_BRZ) / (1 ether);\r\n    b.checkAddress = checkAddress;\r\n    blockchainInfo.push(b);\r\n    blockchain.push(name);\r\n    uint256 index = blockchainInfo.length;\r\n    blockchainIndex[name] = index;\r\n    return (index);\r\n  }\r\n\r\n  /**\r\n   * @dev This function exclude a blockchain in the list of allowed blockchains used in the bridge.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Can not be called if the Bridge is paused.\r\n   *\r\n   * Parameters: string name of blockchain to be excluded\r\n   *\r\n   * Returns: bool - true if it is sucessful\r\n   *\r\n   * Requirements:\r\n   * - blockchain exists.\r\n   * - there must be at least one blockchain left.\r\n   *\r\n   */\r\n  function delBlockchain(string memory name)\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    require(existsBlockchain(name), \"blockchain not exists\");\r\n    require(blockchainInfo.length > 1, \"requires at least 1 blockchain\");\r\n\r\n    uint256 indexToDelete = blockchainIndex[name] - 1;\r\n    uint256 indexToMove = blockchainInfo.length - 1;\r\n    //string memory keyToMove = blockchainInfo[indexToMove].name;\r\n    string memory keyToMove = blockchain[indexToMove];\r\n\r\n    blockchainInfo[indexToDelete] = blockchainInfo[indexToMove];\r\n    blockchain[indexToDelete] = blockchain[indexToMove];\r\n    blockchainIndex[keyToMove] = indexToDelete + 1;\r\n\r\n    delete blockchainIndex[name];\r\n    blockchainInfo.pop();\r\n    blockchain.pop();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev This function pauses the bridge.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Parameters: none\r\n   *\r\n   * Returns: none\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must not be paused.\r\n   *\r\n   */\r\n  function pause() external onlyOwner {\r\n    /**\r\n     * @dev See {Pausable-_pause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    _pause();\r\n  }\r\n\r\n  /**\r\n   * @dev This function unpauses the bridge.\r\n   *\r\n   * Only owner can call it.\r\n   *\r\n   * Parameters: none\r\n   *\r\n   * Returns: none\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The contract must be paused.\r\n   */\r\n  function unpause() external onlyOwner {\r\n    /**\r\n     * @dev See {Pausable-_unpause}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    _unpause();\r\n  }\r\n}"
    }
  }
}