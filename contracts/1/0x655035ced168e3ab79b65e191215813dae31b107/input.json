{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/mUSDT.sol":{"content":"pragma solidity ^0.8.4;\r\n//SPDX-License-Identifier: MIT\r\n\r\n\r\nabstract contract ERC20 {\r\n    function balanceOf(address _owner) virtual public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _amount) virtual public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) virtual public returns (bool success); \r\n}\r\n\r\n\r\nabstract contract StoreHubInterface {\r\n    mapping(address => bool) public isValidStore;\r\n}\r\n\r\n\r\ninterface StoreInterface {\r\n    function getExtensionStake(uint _option) external view returns(uint256, address);\r\n    function getExtensionCollateral(uint _option) external view returns(uint256, address);\r\n    function updateCollateral(uint256 _amount, uint256 _option) external;\r\n}\r\n\r\n\r\ninterface StoreExtension {\r\n    function processPayment(address _customer, uint256 _tokenID, uint256 _amount) external;\r\n}\r\n\r\n\r\ncontract StoreHub {\r\n    event CollateralTransfer(address indexed store, address to, uint256 amount, uint256 rate, bool didTrade);\r\n    event CollateralReliefUpdated(address indexed store, uint256 amount, uint256 rate, bool didAdd);\r\n    event AtokenTransfer(address indexed store, address to, uint256 amount);\r\n    event CollateralUpdated(address indexed store, uint256 collateral);\r\n    event StakeUpdated(address indexed store, uint256 stake);\r\n    \r\n    ERC20 public usdtContract;\r\n    address public usdcStoreHub;\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public storeBalance;\r\n    \r\n    \r\n    function initUSDCHub(address _usdcStoreHub) external {\r\n        require(usdcStoreHub == address(0));\r\n        usdcStoreHub = _usdcStoreHub;\r\n    }\r\n    \r\n    function withdraw(uint256 _collateral) external {\r\n        require(StoreHubInterface(usdcStoreHub).isValidStore(msg.sender) == true);\r\n        uint256 balance = storeBalance[msg.sender] - 1;\r\n        storeBalance[msg.sender] = 1;\r\n        totalSupply += _collateral;\r\n        usdtContract.transfer(msg.sender, balance);\r\n        emit CollateralTransfer(address(0), msg.sender, _collateral, 0, false);\r\n    }\r\n    \r\n    function initBalance(address _store) external {\r\n        require(usdcStoreHub != address(0));\r\n        require(msg.sender == usdcStoreHub);\r\n        storeBalance[_store] = 1;\r\n    }\r\n    \r\n    function callEvent(\r\n        address _value1,\r\n        uint256 _value2, \r\n        uint256 _value3, \r\n        bool _value4,\r\n        uint _option\r\n    ) external {\r\n        require(StoreHubInterface(usdcStoreHub).isValidStore(msg.sender) == true);\r\n        _value1;\r\n        \r\n        if(_option == 0) {\r\n            emit StakeUpdated(msg.sender, _value2);\r\n        }\r\n        else if(_option == 1) {\r\n            emit CollateralReliefUpdated(msg.sender, _value2, _value3, _value4);\r\n        }\r\n        else if(_option == 2) {\r\n            emit CollateralTransfer(msg.sender, _value1, _value2, _value3, _value4);\r\n        }\r\n        else if(_option == 3) {\r\n            emit AtokenTransfer(msg.sender, _value1, _value2);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract mUSDT is StoreHub {\r\n    \r\n    string public name = \"Malus USDT Token\";\r\n    string public symbol = \"mUSDT\";\r\n    uint public decimals = 6;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n    \r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    constructor(address _usdtContract) {\r\n        usdtContract = ERC20(_usdtContract);\r\n    }\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(balances[msg.sender] >= _amount);\r\n        \r\n        if(StoreHubInterface(usdcStoreHub).isValidStore(_to) == true) {\r\n            StoreInterface store = StoreInterface(_to);\r\n            burn(store, msg.sender, 0, _amount); \r\n            return true;\r\n        }\r\n        \r\n        balances[_to] += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        require(balances[_from] >= _amount);\r\n        \r\n        if(StoreHubInterface(usdcStoreHub).isValidStore(_to) == true) {\r\n            StoreInterface store = StoreInterface(_to);\r\n            burn(store, _from, 0, _amount); \r\n            return true;\r\n        }\r\n        \r\n        if (_from != msg.sender && allowed[_from][msg.sender] < (2**256 - 1)) {\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        \r\n        balances[_to] += _amount;\r\n        balances[_from] -= _amount;\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n   \r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function mint(StoreInterface _store, uint256 _tokenID, uint256 _amount) external {\r\n        (uint256 stake, address extensionAddress) = _store.getExtensionStake(1);\r\n        uint256 cashbackAmount = ((_amount * 700) / 10000);\r\n        uint256 prevStoreBalance = (storeBalance[address(_store)] += _amount) - _amount;\r\n        require(cashbackAmount >= 1);\r\n        require((stake - (((prevStoreBalance - 1) * 700) / 10000)) >= cashbackAmount); \r\n        balances[msg.sender] += cashbackAmount;\r\n        usdtContract.transferFrom(msg.sender, address(this), _amount);\r\n        \r\n        if(extensionAddress != address(0)) {\r\n            StoreExtension(extensionAddress).processPayment(msg.sender, _tokenID, _amount);\r\n        }\r\n        emit Transfer(address(_store), msg.sender, cashbackAmount);\r\n    }\r\n    \r\n    function burn(StoreInterface _store, address _from, uint256 _tokenID, uint256 _amount) public {\r\n        (uint256 collateral, address extensionAddress) = _store.getExtensionCollateral(1);\r\n        require(StoreHubInterface(usdcStoreHub).isValidStore(address(_store)) == true);\r\n        require(collateral >= _amount);\r\n        require(balances[_from] >= _amount);\r\n        \r\n        if (_from != msg.sender && allowed[_from][msg.sender] < (2**256 - 1)) {\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        \r\n        _store.updateCollateral(_amount, 1);\r\n        balances[_from] -= _amount; \r\n        totalSupply -= _amount;\r\n        \r\n        if(extensionAddress != address(0)) {\r\n            StoreExtension(extensionAddress).processPayment(msg.sender, _tokenID, _amount);\r\n        }\r\n        emit Transfer(msg.sender, address(_store), _amount);\r\n    }\r\n}\r\n"}}}