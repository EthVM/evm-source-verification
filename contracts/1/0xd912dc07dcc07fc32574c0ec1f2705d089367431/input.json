{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"./contracts/global/SynthRegistryV2.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from \"../lib/Ownable.sol\";\n\nimport {ISyntheticToken} from \"../token/ISyntheticToken.sol\";\nimport {IERC20} from \"../token/IERC20.sol\";\n\ncontract SynthRegistryV2 is Ownable {\n\n    // Available cores which can be used with the system\n    address[] public availableCores;\n\n    // Synth address (proxy) to synthetic token\n    mapping(address => address) public synths;\n\n    /* ========== Events ========== */\n\n    event SynthAdded(address proxy, address synth);\n    event SynthRemoved(address proxy, address synth);\n\n    /* ========== View Functions ========== */\n\n    function getAllCores()\n        public\n        view\n        returns (address[] memory)\n    {\n        return availableCores;\n    }\n\n    /* ========== Mutative Functions ========== */\n\n    /**\n     * @dev Add a new synth to the registry.\n     *\n     * @param core The address of the core proxy contract\n     * @param synthetic The address of the synthetic token proxy address\n     */\n    function addSynth(\n        address core,\n        address synthetic\n    )\n        external\n        onlyOwner\n    {\n        require(\n            synths[core] == address(0),\n            \"Synth already exists\"\n        );\n\n        availableCores.push(core);\n        synths[core] = synthetic;\n\n        emit SynthAdded(core, synthetic);\n    }\n\n\n    /**\n     * @dev Remove a new synth from registry.\n     *\n     * @param core The address of the core proxy contract\n     */\n    function removeSynth(\n        address core\n    )\n        external\n        onlyOwner\n    {\n        require(\n            address(synths[core]) != address(0),\n            \"Synth does not exist\"\n        );\n\n        // Save the address we're removing for emitting the event at the end.\n        address syntheticToRemove = synths[core];\n\n        // Remove the synth from the availableCores array.\n        for (uint i = 0; i < availableCores.length; i++) {\n            if (address(availableCores[i]) == core) {\n                delete availableCores[i];\n                availableCores[i] = availableCores[availableCores.length - 1];\n                availableCores.length--;\n\n                break;\n            }\n        }\n\n        // And remove it from the synths mapping\n        delete synths[core];\n\n        emit SynthRemoved(core, syntheticToRemove);\n    }\n}\n"},"./contracts/lib/Amount.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {Math} from \"../lib/Math.sol\";\n\nlibrary Amount {\n\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    uint256 constant BASE = 10**18;\n\n    // A Principal Amount is an amount that's been adjusted by an index\n\n    struct Principal {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    function zero()\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: false,\n            value: 0\n        });\n    }\n\n    function sub(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return add(a, negative(b));\n    }\n\n    function add(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        Principal memory result;\n\n        if (a.sign == b.sign) {\n            result.sign = a.sign;\n            result.value = SafeMath.add(a.value, b.value);\n        } else {\n            if (a.value >= b.value) {\n                result.sign = a.sign;\n                result.value = SafeMath.sub(a.value, b.value);\n            } else {\n                result.sign = b.sign;\n                result.value = SafeMath.sub(b.value, a.value);\n            }\n        }\n        return result;\n    }\n\n    function equals(\n        Principal memory a,\n        Principal memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.value == b.value) {\n            if (a.value == 0) {\n                return true;\n            }\n            return a.sign == b.sign;\n        }\n        return false;\n    }\n\n    function negative(\n        Principal memory a\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: !a.sign,\n            value: a.value\n        });\n    }\n\n    function calculateAdjusted(\n        Principal memory a,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return Math.getPartial(a.value, index, BASE);\n    }\n\n    function calculatePrincipal(\n        uint256 value,\n        uint256 index,\n        bool sign\n    )\n        internal\n        pure\n        returns (Principal memory)\n    {\n        return Principal({\n            sign: sign,\n            value: Math.getPartial(value, BASE, index)\n        });\n    }\n\n}\n"},"./contracts/lib/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./SafeMath.sol\";\n\n/**\n * @title Math\n *\n * Library for non-standard Math functions\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        require(\n            result == number,\n            \"Math: Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n"},"./contracts/lib/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"./contracts/lib/SafeMath.sol":{"content":"\npragma solidity ^0.5.16;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"},"./contracts/token/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"./contracts/token/ISyntheticToken.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport {Amount} from \"../lib/Amount.sol\";\n\ninterface ISyntheticToken {\n\n    function symbolKey()\n        external\n        view\n        returns (bytes32);\n\n    function mint(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function burn(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function transferCollateral(\n        address token,\n        address to,\n        uint256 value\n    )\n        external\n        returns (bool);\n\n    function getMinterIssued(\n        address _minter\n    )\n        external\n        view\n        returns (Amount.Principal memory);\n\n    function getMinterLimit(\n        address _minter\n    )\n        external\n        view\n        returns (uint256);\n\n}\n"}}}