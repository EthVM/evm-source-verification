{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TellorSender.sol":{"content":"// File: usingtellor/Interface/ITellor.sol\r\n// File: contracts/IStateSender.sol\r\n\r\n/**\r\nThe sender address from Ethereum and receiver address deployed in Matic must\r\nbe registered in Matic's sender contact on Ethereum\r\n*/\r\ncontract IStateSender {\r\n  function syncState(address receiver, bytes calldata data) external;\r\n  function register(address sender, address receiver) public;\r\n}\r\n\r\n\r\npragma solidity 0.5.16;\r\n\r\ninterface ITellor {\r\n\r\n    /**\r\n    * @dev Helps initialize a dispute by assigning it a disputeId\r\n    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\r\n    * invalidated value information to POS voting\r\n    * @param _requestId being disputed\r\n    * @param _timestamp being disputed\r\n    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\r\n    * requires 5 miners to submit a value.\r\n    */\r\n    function beginDispute(uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) external;\r\n   \r\n    /**\r\n    * @dev Allows token holders to vote\r\n    * @param _disputeId is the dispute id\r\n    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\r\n    */\r\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\r\n\r\n    /**\r\n    * @dev tallies the votes.\r\n    * @param _disputeId is the dispute id\r\n    */\r\n    function tallyVotes(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @dev Allows for a fork to be proposedx\r\n    * @param _propNewTellorAddress address for new proposed Tellor\r\n    */\r\n    function proposeFork(address _propNewTellorAddress) external;\r\n\r\n    /**\r\n    * @dev Add tip to Request value from oracle\r\n    * @param _requestId being requested to be mined\r\n    * @param _tip amount the requester is willing to pay to be get on queue. Miners\r\n    * mine the onDeckQueryHash, or the api with the highest payout pool\r\n    */\r\n    function addTip(uint256 _requestId, uint256 _tip) external;\r\n\r\n    /**\r\n    * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\r\n    * @param _nonce uint submitted by miner\r\n    * @param _requestId the apiId being mined\r\n    * @param _value of api query\r\n    *\r\n    */\r\n    function submitMiningSolution(string calldata _nonce, uint256 _requestId, uint256 _value) external;\r\n\r\n    /**\r\n    * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\r\n    * @param _nonce uint submitted by miner\r\n    * @param _requestId is the array of the 5 PSR's being mined\r\n    * @param _value is an array of 5 values\r\n    */\r\n    function submitMiningSolution(string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value) external;\r\n\r\n    /**\r\n    * @dev Allows the current owner to propose transfer control of the contract to a\r\n    * newOwner and the ownership is pending until the new owner calls the claimOwnership\r\n    * function\r\n    * @param _pendingOwner The address to transfer ownership to.\r\n    */\r\n    function proposeOwnership(address payable _pendingOwner) external;\r\n\r\n    /**\r\n    * @dev Allows the new owner to claim control of the contract\r\n    */\r\n    function claimOwnership() external;\r\n\r\n    /**\r\n    * @dev This function allows miners to deposit their stake.\r\n    */\r\n    function depositStake() external;\r\n\r\n    /**\r\n    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\r\n    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\r\n    * can withdraw the stake\r\n    */\r\n    function requestStakingWithdraw() external;\r\n\r\n    /**\r\n    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\r\n    */\r\n    function withdrawStake() external;\r\n\r\n    /**\r\n    * @dev This function approves a _spender an _amount of tokens to use\r\n    * @param _spender address\r\n    * @param _amount amount the spender is being approved for\r\n    * @return true if spender appproved successfully\r\n    */\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Allows for a transfer of tokens to _to\r\n    * @param _to The address to send tokens to\r\n    * @param _amount The amount of tokens to send\r\n    * @return true if transfer is successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Sends _amount tokens to _to from _from on the condition it\r\n    * is approved by _from\r\n    * @param _from The address holding the tokens being transferred\r\n    * @param _to The address of the recipient\r\n    * @param _amount The amount of tokens to be transferred\r\n    * @return True if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Allows users to access the token's name\r\n    */\r\n    function name() external pure returns (string memory);\r\n\r\n    /**\r\n    * @dev Allows users to access the token's symbol\r\n    */\r\n    function symbol() external pure returns (string memory);\r\n\r\n    /**\r\n    * @dev Allows users to access the number of decimals\r\n    */\r\n    function decimals() external pure returns (uint8);\r\n\r\n    /**\r\n    * @dev Getter for the current variables that include the 5 requests Id's\r\n    * @return _challenge _requestIds _difficultky _tip the challenge, 5 requestsId, difficulty and tip\r\n    */\r\n    function getNewCurrentVariables() external view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficutly, uint256 _tip);\r\n\r\n    /**\r\n    * @dev Getter for the top tipped 5 requests Id's\r\n    * @return _requestIds the 5 requestsId\r\n    */\r\n    function getTopRequestIDs() external view returns(uint256[5] memory _requestIds);\r\n\r\n    /**\r\n    * @dev Getter for the 5 requests Id's next in line to get mined\r\n    * @return idsOnDeck tipsOnDeck  the 5 requestsId\r\n    */\r\n    function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\r\n\r\n    /**\r\n    * @dev Updates the Tellor address after a proposed fork has\r\n    * passed the vote and day has gone by without a dispute\r\n    * @param _disputeId the disputeId for the proposed fork\r\n    */\r\n     function updateTellor(uint _disputeId) external;\r\n\r\n    /**\r\n    * @dev Allows disputer to unlock the dispute fee\r\n    * @param _disputeId to unlock fee from\r\n    */\r\n    function unlockDisputeFee (uint _disputeId) external;\r\n   \r\n    /**\r\n    * @param _user address\r\n    * @param _spender address\r\n    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\r\n    */\r\n    function allowance(address _user, address _spender) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev This function returns whether or not a given user is allowed to trade a given amount\r\n    * @param _user address\r\n    * @param _amount uint of amount\r\n    * @return true if the user is alloed to trade the amount specified\r\n    */\r\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Gets balance of owner specified\r\n    * @param _user is the owner address used to look up the balance\r\n    * @return Returns the balance associated with the passed in _user\r\n    */\r\n    function balanceOf(address _user) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Queries the balance of _user at a specific _blockNumber\r\n    * @param _user The address from which the balance will be retrieved\r\n    * @param _blockNumber The block number when the balance is queried\r\n    * @return The balance at _blockNumber\r\n    */\r\n    function balanceOfAt(address _user, uint256 _blockNumber) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev This function tells you if a given challenge has been completed by a given miner\r\n    * @param _challenge the challenge to search for\r\n    * @param _miner address that you want to know if they solved the challenge\r\n    * @return true if the _miner address provided solved the\r\n    */\r\n    function didMine(bytes32 _challenge, address _miner) external view returns (bool);\r\n   \r\n    /**\r\n    * @dev Checks if an address voted in a given dispute\r\n    * @param _disputeId to look up\r\n    * @param _address to look up\r\n    * @return bool of whether or not party voted\r\n    */\r\n    function didVote(uint256 _disputeId, address _address) external view returns (bool);\r\n   \r\n    /**\r\n    * @dev allows Tellor to read data from the addressVars mapping\r\n    * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\r\n    * These are examples of how the variables are saved within other functions:\r\n    * addressVars[keccak256(\"_owner\")]\r\n    * addressVars[keccak256(\"tellorContract\")]\r\n    * return address\r\n    */\r\n    function getAddressVars(bytes32 _data) external view returns (address);\r\n\r\n    /**\r\n    * @dev Gets all dispute variables\r\n    * @param _disputeId to look up\r\n    * @return bytes32 hash of dispute\r\n    * @return bool executed where true if it has been voted on\r\n    * @return bool disputeVotePassed\r\n    * @return bool isPropFork true if the dispute is a proposed fork\r\n    * @return address of reportedMiner\r\n    * @return address of reportingParty\r\n    * @return address of proposedForkAddress\r\n    *    uint of requestId\r\n    *    uint of timestamp\r\n    *    uint of value\r\n    *    uint of minExecutionDate\r\n    *    uint of numberOfVotes\r\n    *    uint of blocknumber\r\n    *    uint of minerSlot\r\n    *    uint of quorum\r\n    *    uint of fee\r\n    * @return int count of the current tally\r\n    */\r\n    function getAllDisputeVars(uint256 _disputeId)\r\n        external\r\n        view\r\n        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256);\r\n   \r\n    /**\r\n    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\r\n    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\r\n    */\r\n    function getCurrentVariables() external view returns (bytes32, uint256, uint256, string memory, uint256, uint256);\r\n   \r\n    /**\r\n    * @dev Checks if a given hash of miner,requestId has been disputed\r\n    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\r\n    * @return uint disputeId\r\n    */\r\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256);\r\n   \r\n    /**\r\n    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\r\n    * @param _disputeId is the dispute id;\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the disputeUintVars under the Dispute struct\r\n    * @return uint value for the bytes32 data submitted\r\n    */\r\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @return value for timestamp of last proof of work submited\r\n    * @return true if the is a timestamp for the lastNewValue\r\n    */\r\n    function getLastNewValue() external view returns (uint256, bool);\r\n\r\n    /**\r\n    * @dev Gets the a value for the latest timestamp available\r\n    * @param _requestId being requested\r\n    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\r\n    */\r\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool);\r\n\r\n    /**\r\n    * @dev Gets blocknumber for mined timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up blocknumber\r\n    * @return uint of the blocknumber which the dispute was mined\r\n    */\r\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return the 5 miners' addresses\r\n    */\r\n    function getMinersByRequestIdAndTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (address[5] memory);\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request\r\n    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\r\n    * request so far\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter function for the specified requestQ index\r\n    * @param _index to look up in the requestQ array\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByRequestQIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on timestamp\r\n    * @param _timestamp to check requestId\r\n    * @return uint of reqeuestId\r\n    */\r\n    function getRequestIdByTimestamp(uint256 _timestamp) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter function for requestId based on the queryHash\r\n    * @param _request is the hash(of string api and granularity) to check if a request already exists\r\n    * @return uint requestId\r\n    */\r\n    function getRequestIdByQueryHash(bytes32 _request) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter function for the requestQ array\r\n    * @return the requestQ arrray\r\n    */\r\n    function getRequestQ() external view returns (uint256[51] memory);\r\n\r\n    /**\r\n    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\r\n    * for the requestId specified\r\n    * @param _requestId to look up\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the apiUintVars under the requestDetails struct\r\n    * @return uint value of the apiUintVars specified in _data for the requestId specified\r\n    */\r\n    function getRequestUintVars(uint256 _requestId, bytes32 _data) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the API struct variables that are not mappings\r\n    * @param _requestId to look up\r\n    * @return string of api to query\r\n    * @return string of symbol of api to query\r\n    * @return bytes32 hash of string\r\n    * @return bytes32 of the granularity(decimal places) requested\r\n    * @return uint of index in requestQ array\r\n    * @return uint of current payout/tip for this requestId\r\n    */\r\n    function getRequestVars(uint256 _requestId) external view returns (string memory, string memory, bytes32, uint256, uint256, uint256);\r\n\r\n    /**\r\n    * @dev This function allows users to retireve all information about a staker\r\n    * @param _staker address of staker inquiring about\r\n    * @return uint current state of staker\r\n    * @return uint startDate of staking\r\n    */\r\n    function getStakerInfo(address _staker) external view returns (uint256, uint256);\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestampt to look up miners for\r\n    * @return address[5] array of 5 addresses ofminers that mined the requestId\r\n    */\r\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp) external view returns (uint256[5] memory);\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestID is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\r\n    * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\r\n    * the variables/strings used to save the data in the mapping. The variables names are\r\n    * commented out under the uintVars under the TellorStorageStruct struct\r\n    * This is an example of how data is saved into the mapping within other functions:\r\n    * self.uintVars[keccak256(\"stakerCount\")]\r\n    * @return uint of specified variable\r\n    */\r\n    function getUintVar(bytes32 _data) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\r\n    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\r\n    */\r\n    function getVariablesOnDeck() external view returns (uint256, uint256, string memory);\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to look up\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(uint256 _requestId, uint256 _timestamp) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Retreive value from oracle based on timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return value for timestamp submitted\r\n    */\r\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Getter for the total_supply of oracle tokens\r\n    * @return uint total supply\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n// File: usingtellor/contracts/UsingTellor.sol\r\n\r\n\r\n\r\n/**\r\n* @title UserContract\r\n* This contracts creates for easy integration to the Tellor System\r\n* by allowing smart contracts to read data off Tellor\r\n*/\r\ncontract UsingTellor{\r\n    ITellor tellor;\r\n    /*Constructor*/\r\n    /**\r\n    * @dev the constructor sets the storage address and owner\r\n    * @param _tellor is the TellorMaster address\r\n    */\r\n    constructor(address payable _tellor) public {\r\n        tellor = ITellor(_tellor);\r\n    }\r\n\r\n     /**\r\n    * @dev Retreive value from oracle based on requestId/timestamp\r\n    * @param _requestId being requested\r\n    * @param _timestamp to retreive data/value from\r\n    * @return uint value for requestId/timestamp submitted\r\n    */\r\n    function retrieveData(uint256 _requestId, uint256 _timestamp) public view returns(uint256){\r\n        return tellor.retrieveData(_requestId,_timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\r\n    * @param _requestId to looku p\r\n    * @param _timestamp is the timestamp to look up miners for\r\n    * @return bool true if requestId/timestamp is under dispute\r\n    */\r\n    function isInDispute(uint256 _requestId, uint256 _timestamp) public view returns(bool){\r\n        return tellor.isInDispute(_requestId, _timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev Counts the number of values that have been submited for the request\r\n    * @param _requestId the requestId to look up\r\n    * @return uint count of the number of values received for the requestId\r\n    */\r\n    function getNewValueCountbyRequestId(uint256 _requestId) public view returns(uint) {\r\n        return tellor.getNewValueCountbyRequestId(_requestId);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the timestamp for the value based on their index\r\n    * @param _requestId is the requestId to look up\r\n    * @param _index is the value index to look up\r\n    * @return uint timestamp\r\n    */\r\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index) public view returns(uint256) {\r\n        return tellor.getTimestampbyRequestIDandIndex( _requestId,_index);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the user to get the latest value for the requestId specified\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @return ifRetrieve bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    * @return value the value retrieved\r\n    * @return _timestampRetrieved the value's timestamp\r\n    */\r\n    function getCurrentValue(uint256 _requestId) public view returns (bool ifRetrieve, uint256 value, uint256 _timestampRetrieved) {\r\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\r\n        uint _time = tellor.getTimestampbyRequestIDandIndex(_requestId, _count - 1);\r\n        uint _value = tellor.retrieveData(_requestId, _time);\r\n        if(_value > 0) return (true, _value, _time);\r\n        return (false, 0 , _time);\r\n    }\r\n   \r\n    function getIndexForDataBefore(uint _requestId, uint256 _timestamp) public view returns (bool found, uint256 index){\r\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);  \r\n        if (_count > 0) {\r\n            uint middle;\r\n            uint start = 0;\r\n            uint end = _count - 1;\r\n            uint _time;\r\n\r\n            //Checking Boundaries to short-circuit the algorithm\r\n            _time = tellor.getTimestampbyRequestIDandIndex(_requestId, start);\r\n            if(_time >= _timestamp) return (false, 0);\r\n            _time = tellor.getTimestampbyRequestIDandIndex(_requestId, end);\r\n            if(_time < _timestamp) return (true, end);\r\n\r\n            //Since the value is within our boundaries, do a binary search\r\n            while(true) {\r\n                middle = (end - start) / 2 + 1 + start;\r\n                _time = tellor.getTimestampbyRequestIDandIndex(_requestId, middle);\r\n                if(_time < _timestamp){\r\n                    //get imeadiate next value\r\n                    uint _nextTime = tellor.getTimestampbyRequestIDandIndex(_requestId, middle + 1);\r\n                    if(_nextTime >= _timestamp){\r\n                        //_time is correct\r\n                        return (true, middle);\r\n                    } else  {\r\n                        //look from middle + 1(next value) to end\r\n                        start = middle + 1;\r\n                    }\r\n                } else {\r\n                    uint _prevTime = tellor.getTimestampbyRequestIDandIndex(_requestId, middle - 1);\r\n                    if(_prevTime < _timestamp){\r\n                        // _prevtime is correct\r\n                        return(true, middle - 1);\r\n                    } else {\r\n                        //look from start to middle -1(prev value)\r\n                        end = middle -1;\r\n                    }\r\n                }\r\n                //We couldn't found a value\r\n                //if(middle - 1 == start || middle == _count) return (false, 0);\r\n            }\r\n        }\r\n        return (false, 0);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Allows the user to get the first value for the requestId before the specified timestamp\r\n    * @param _requestId is the requestId to look up the value for\r\n    * @param _timestamp before which to search for first verified value\r\n    * @return _ifRetrieve bool true if it is able to retreive a value, the value, and the value's timestamp\r\n    * @return _value the value retrieved\r\n    * @return _timestampRetrieved the value's timestamp\r\n    */\r\n    function getDataBefore(uint256 _requestId, uint256 _timestamp)\r\n        public\r\n        returns (bool _ifRetrieve, uint256 _value, uint256 _timestampRetrieved)\r\n    {\r\n       \r\n        (bool _found, uint _index) = getIndexForDataBefore(_requestId,_timestamp);\r\n        if(!_found) return (false, 0, 0);\r\n        uint256 _time = tellor.getTimestampbyRequestIDandIndex(_requestId, _index);\r\n        _value = tellor.retrieveData(_requestId, _time);\r\n        //If value is diputed it'll return zero\r\n        if (_value > 0) return (true, _value, _time);\r\n        return (false, 0, 0);\r\n    }\r\n}\r\n\r\n\r\n// File: contracts/TellorSender.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n\r\n\r\n/**\r\n@title Sender\r\nThis contract helps send Tellor's data on Ethereum to Matic's Network\r\n*/\r\ncontract TellorSender is UsingTellor {\r\n    IStateSender public stateSender;\r\n    event DataSent(uint _requestId, uint _timestamp, uint _value, address _sender);    \r\n    address public receiver;\r\n\r\n    /**\r\n    @dev\r\n    @param _tellorAddress is the tellor master address\r\n    @param _stateSender is the Matic's state sender address --- they need to add the sender and receiver address\r\n    @param _receiver is the contract receiver address in Matic\r\n    */\r\n    constructor(address payable _tellorAddress, address _stateSender, address _receiver) UsingTellor(_tellorAddress) public {\r\n      stateSender = IStateSender(_stateSender);\r\n      receiver = _receiver;\r\n    }\r\n\r\n    /**\r\n    @dev This function gets the value for the specified request Id and timestamp from UsingTellor\r\n    @param _requestId is Tellor's requestId to retreive\r\n    @param _timestamp is Tellor's requestId timestamp to retreive\r\n    */\r\n    function retrieveDataAndSend(uint256 _requestId, uint256 _timestamp) public {\r\n        uint256 value = retrieveData(_requestId, _timestamp);\r\n        require(value > 0);\r\n        stateSender.syncState(receiver, abi.encode(_requestId, _timestamp, value, msg.sender));\r\n        emit DataSent(_requestId, _timestamp, value, msg.sender);\r\n    }\r\n\r\n    /**\r\n    @dev This function gets the current value for the specified request Id from UsingTellor\r\n    @param _requestId is Tellor's requestId to retreive the latest curent value for it\r\n    */\r\n    function getCurrentValueAndSend(uint256 _requestId) public {\r\n      (bool ifRetrieve, uint256 value, uint256 timestamp) = getCurrentValue(_requestId);\r\n      require(ifRetrieve);\r\n      stateSender.syncState(receiver, abi.encode(_requestId, timestamp, value, msg.sender));\r\n      emit DataSent(_requestId, timestamp, value, msg.sender);\r\n    }\r\n}"}}}