{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/1_Storage.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-03-10\n*/\n\n// Sources flattened with hardhat v2.1.1 https://hardhat.org\n\n// File contracts/erc20/ERC20.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\nabstract contract ERC20 {\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /*\n   * Internal Functions for ERC20 standard logics\n   */\n\n    function _transfer(address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        _balances[from] = _balances[from] - amount;\n        _balances[to] = _balances[to] + amount;\n        emit Transfer(from, to, amount);\n        success = true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n        success = true;\n    }\n\n    function _mint(address recipient, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        _totalSupply = _totalSupply + amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(address(0), recipient, amount);\n        success = true;\n    }\n\n    function _burn(address burned, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        _balances[burned] = _balances[burned] - amount;\n        _totalSupply = _totalSupply - amount;\n        emit Transfer(burned, address(0), amount);\n        success = true;\n    }\n\n    /*\n   * public view functions to view common data\n   */\n\n    function totalSupply() external view returns (uint256 total) {\n        total = _totalSupply;\n    }\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        balance = _balances[owner];\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256 remaining)\n    {\n        remaining = _allowances[owner][spender];\n    }\n\n    /*\n   * External view Function Interface to implement on final contract\n   */\n    function name() virtual external view returns (string memory tokenName);\n    function symbol() virtual external view returns (string memory tokenSymbol);\n    function decimals() virtual external view returns (uint8 tokenDecimals);\n\n    /*\n   * External Function Interface to implement on final contract\n   */\n    function transfer(address to, uint256 amount)\n        virtual\n        external\n        returns (bool success);\n    function transferFrom(address from, address to, uint256 amount)\n        virtual\n        external\n        returns (bool success);\n    function approve(address spender, uint256 amount)\n        virtual\n        external\n        returns (bool success);\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(\n        address indexed currentOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == _owner,\n            \"Ownable : Function called by unauthorized user.\"\n        );\n        _;\n    }\n\n    function owner() external view returns (address ownerAddress) {\n        ownerAddress = _owner;\n    }\n\n    function transferOwnership(address newOwner)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        require(newOwner != address(0), \"Ownable/transferOwnership : cannot transfer ownership to zero address\");\n        success = _transferOwnership(newOwner);\n    }\n\n    function renounceOwnership() external onlyOwner returns (bool success) {\n        success = _transferOwnership(address(0));\n    }\n\n    function _transferOwnership(address newOwner) internal returns (bool success) {\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n        success = true;\n    }\n}\n\n\nabstract contract ERC20Lockable is ERC20, Ownable {\n    struct LockInfo {\n        uint256 amount;\n        uint256 due;\n    }\n\n    mapping(address => LockInfo[]) internal _locks;\n    mapping(address => uint256) internal _totalLocked;\n\n    event Lock(address indexed from, uint256 amount, uint256 due);\n    event Unlock(address indexed from, uint256 amount);\n\n    modifier checkLock(address from, uint256 amount) {\n        require(_balances[from] >= _totalLocked[from] + amount, \"ERC20Lockable/Cannot send more than unlocked amount\");\n        _;\n    }\n\n    function _lock(address from, uint256 amount, uint256 due)\n    internal\n    returns (bool success)\n    {\n        require(due > block.timestamp, \"ERC20Lockable/lock : Cannot set due to past\");\n        require(\n            _balances[from] >= amount + _totalLocked[from],\n            \"ERC20Lockable/lock : locked total should be smaller than balance\"\n        );\n        _totalLocked[from] = _totalLocked[from] + amount;\n        _locks[from].push(LockInfo(amount, due));\n        emit Lock(from, amount, due);\n        success = true;\n    }\n\n    function _unlock(address from, uint256 index) internal returns (bool success) {\n        LockInfo storage lock = _locks[from][index];\n        _totalLocked[from] = _totalLocked[from] - lock.amount;\n        emit Unlock(from, lock.amount);\n        _locks[from][index] = _locks[from][_locks[from].length - 1];\n        _locks[from].pop();\n        success = true;\n    }\n\n    function unlock(address from, uint256 idx) external returns(bool success){\n        require(_locks[from][idx].due < block.timestamp,\"ERC20Lockable/unlock: cannot unlock before due\");\n        return _unlock(from, idx);\n    }\n\n    function unlockAll(address from) external returns (bool success) {\n        for(uint256 i = 0; i < _locks[from].length;){\n            i++;\n            if(_locks[from][i - 1].due < block.timestamp){\n                if(_unlock(from, i - 1)){\n                    i--;\n                }\n            }\n        }\n        success = true;\n    }\n\n    function releaseLock(address from)\n    external\n    onlyOwner\n    returns (bool success)\n    {\n        for(uint256 i = 0; i < _locks[from].length;){\n            i++;\n            if(_unlock(from, i - 1)){\n                i--;\n            }\n        }\n        success = true;\n    }\n\n    function transferWithLockUp(address recipient, uint256 amount, uint256 due)\n    external\n    onlyOwner\n    returns (bool success)\n    {\n        require(\n            recipient != address(0),\n            \"ERC20Lockable/transferWithLockUp : Cannot send to zero address\"\n        );\n        _transfer(msg.sender, recipient, amount);\n        _lock(recipient, amount, due);\n        success = true;\n    }\n\n    function lockInfo(address locked, uint256 index)\n    external\n    view\n    returns (uint256 amount, uint256 due)\n    {\n        LockInfo memory lock = _locks[locked][index];\n        amount = lock.amount;\n        due = lock.due;\n    }\n\n    function totalLocked(address locked) external view returns(uint256 amount, uint256 length){\n        amount = _totalLocked[locked];\n        length = _locks[locked].length;\n    }\n}\n\nabstract contract ERC20Burnable is ERC20 {\n    event Burn(address indexed burned, uint256 amount);\n\n    function burn(uint256 amount) \n    external\n    returns (bool success)\n    {\n        success = _burn(msg.sender, amount);\n        emit Burn(msg.sender, amount);\n        success = true;\n    }\n\n    function burnFrom(address burned, uint256 amount) \n    external\n    returns (bool success)\n    {\n        _burn(burned, amount);\n        emit Burn(burned, amount);\n        success = _approve(\n            burned,\n            msg.sender,\n            _allowances[burned][msg.sender] - amount\n        );\n    }\n}\n\ncontract ONSTON is\n    ERC20Lockable,\n    ERC20Burnable\n{\n    string constant private _name = \"ONSTON\";\n    string constant private _symbol = \"ONSTON\";\n    uint8 constant private _decimals = 18;\n    uint256 constant private _initial_supply = 1_000_000_000;\n\n    constructor(address _owner) Ownable() {\n        _mint(_owner, _initial_supply * (10**uint256(_decimals)));\n        _transferOwnership(_owner);\n    }\n\n    function transfer(address to, uint256 amount)\n        override\n        external\n        checkLock(msg.sender, amount)\n        returns (bool success)\n    {\n        require(\n            to != address(0),\n            \"ONSTON/transfer : Should not send to zero address\"\n        );\n        _transfer(msg.sender, to, amount);\n        success = true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount)\n        override\n        external\n        checkLock(from, amount)\n        returns (bool success)\n    {\n        require(\n            to != address(0),\n            \"ONSTON/transferFrom : Should not send to zero address\"\n        );\n        _transfer(from, to, amount);\n        _approve(\n            from,\n            msg.sender,\n            _allowances[from][msg.sender] - amount\n        );\n        success = true;\n    }\n\n    function approve(address spender, uint256 amount)\n        override\n        external\n        returns (bool success)\n    {\n        require(\n            spender != address(0),\n            \"ONSTON/approve : Should not approve zero address\"\n        );\n        _approve(msg.sender, spender, amount);\n        success = true;\n    }\n\n    function name() override external pure returns (string memory tokenName) {\n        tokenName = _name;\n    }\n\n    function symbol() override external pure returns (string memory tokenSymbol) {\n        tokenSymbol = _symbol;\n    }\n\n    function decimals() override external pure returns (uint8 tokenDecimals) {\n        tokenDecimals = _decimals;\n    }\n}"
    }
  }
}