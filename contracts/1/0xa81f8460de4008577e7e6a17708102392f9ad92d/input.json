{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "3XBTCUSDVault.sol": {
      "content": "//////////////////////////////////////////////////\n//SYNLEV VAULT CONTRACT V 1.0.0\n//////////////////////////\n\npragma solidity >= 0.6.6;\n\nimport './ownable.sol';\nimport './SafeMath.sol';\nimport './IERC20.sol';\nimport './priceCalculatorInterface.sol';\nimport './vaultHelperInterface.sol';\nimport './priceAggregatorInterface.sol';\n\n/*\n * @title SynLev vault contract.\n * @author Icarus\n */\ncontract vault is Owned {\n  using SafeMath for uint256;\n\n  constructor() public {\n    priceAggregatorInterface(0x7196545d854D03D9c87B7588F6D9e1e42D876E95).registerVaultAggregator(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n    priceAggregator = priceAggregatorInterface(0xb658E8680c1E1f148fb09cDbB3Bd0d58F9c14c00);\n    priceCalculator = priceCalculatorInterface(0x80D129A01879422EB102c47Ed32DC6E8B123D05f);\n    vaultHelper = vaultHelperInterface(0x70873daAa742bEA6D0EDf03f4f85c615983C01D7);\n    synStakingProxy = 0x0070F3e1147c03a1Bb0caF80035B7c362D312119;\n    buyFee = 10**7;\n    sellFee = 10**7;\n  }\n\n  /////////////////////\n  //EVENTS/////////////\n  /////////////////////\n  event PriceUpdate(\n    uint256 bullPrice,\n    uint256 bearPrice,\n    uint256 bullLiqEquity,\n    uint256 bearLiqEquity,\n    uint256 bullEquity,\n    uint256 bearEquity,\n    uint256 roundId,\n    bool updated\n  );\n  event TokenBuy(\n    address account,\n    address token,\n    uint256 tokensMinted,\n    uint256 ethin,\n    uint256 fees,\n    uint256 bonus\n  );\n  event TokenSell(\n    address account,\n    address token,\n    uint256 tokensBurned,\n    uint256 ethout,\n    uint256 fees,\n    uint256 penalty\n  );\n  event LiquidityAdd(\n    address account,\n    uint256 eth,\n    uint256 shares,\n    uint256 shareprice\n  );\n  event LiquidityRemove(\n    address account,\n    uint256 eth,\n    uint256 shares,\n    uint256 shareprice\n  );\n\n  modifier isActive() {\n    require(active == true);\n    if(active == true && !priceAggregator.roundIdCheck(address(this))) {\n      updatePrice();\n    }\n    _;\n  }\n\n  modifier updateIfActive() {\n    if(active == true && !priceAggregator.roundIdCheck(address(this))) {\n      updatePrice();\n    }\n    _;\n  }\n\n  /////////////////////\n  //GLOBAL VARIBLES\n  /////////////////////\n\n  bool private active;\n  uint256 constant private multiplier = 3;\n  address private bull;\n  address private bear;\n  uint256 private latestRoundId;\n  mapping(address => uint256) private price;\n  mapping(address => uint256) private equity;\n  uint256 private buyFee;\n  uint256 private sellFee;\n  uint256 private totalLiqShares;\n  uint256 private liqFees;\n  uint256 private balanceEquity;\n  mapping(address => uint256) private liqTokens;\n  mapping(address => uint256) private liqEquity;\n  mapping(address => uint256) private userShares;\n\n  priceAggregatorInterface  public priceAggregator;\n  priceCalculatorInterface public priceCalculator;\n  vaultHelperInterface public vaultHelper;\n  address payable public synStakingProxy;\n\n  //Fallback function\n  receive() external payable {}\n\n  ////////////////////////////////////\n  //LOW LEVEL BUY AND SELL FUNCTIONS//\n  //        NO SAFETY CHECK         //\n  //SHOULD ONLY BE CALLED BY OTHER  //\n  //          CONTRACTS             //\n  ////////////////////////////////////\n\n  /*\n   * @notice Buys bull or bear token and updates price before token buy.\n   * @param token bull or bear token address\n   * @param account Recipient of newly minted tokens\n   * @dev Should only be called by a router contract. Checks the excess ETH in\n   * contract by calling getDepositEquity(). Can't 0 ETH buy. Calculates\n   * resulting tokens and fees. Sends fees and mints tokens.\n   *\n   */\n  function tokenBuy(address token, address account)\n  public\n  virtual\n  isActive()\n  {\n    uint256 ethin = getDepositEquity();\n    require(ethin > 0);\n    require(token == bull || token == bear);\n    IERC20 itkn = IERC20(token);\n    uint256 fees = ethin.mul(buyFee).div(10**9);\n    uint256 buyeth = ethin.sub(fees);\n    uint256 bonus = vaultHelper.getBonus(address(this), token, buyeth);\n    uint256 tokensToMint = buyeth.add(bonus).mul(10**18).div(price[token]);\n    equity[token] = equity[token].add(buyeth).add(bonus);\n    if(bonus != 0) balanceEquity = balanceEquity.sub(bonus);\n    payFees(fees);\n    itkn.mint(account, tokensToMint);\n\n    emit TokenBuy(account, token, tokensToMint, ethin, fees, bonus);\n  }\n\n  /*\n   * @notice Sells bull or bear token and updates price before token sell.\n   * @param token bull or bear token address\n   * @param account Recipient of resulting eth from burned tokens\n   * @dev Should only be called by a router contract that simultaneously sends\n   * tokens using transferFrom() and calls this function. Looks at the current\n   * balance of the contract of the selected token. Can't 0 token sell.\n   * Calculates resulting ETH from burned tokens. Pays fees, burns tokens, and\n   * sends ETH.\n   */\n  function tokenSell(address token, address payable account)\n  public\n  virtual\n  isActive()\n  {\n    IERC20 itkn = IERC20(token);\n    uint256 tokensToBurn = itkn.balanceOf(address(this));\n    require(tokensToBurn > 0);\n    require(token == bull || token == bear);\n    uint256 selleth = tokensToBurn.mul(price[token]).div(10**18);\n    uint256 penalty = vaultHelper.getPenalty(address(this), token, selleth);\n    uint256 fees = sellFee.mul(selleth.sub(penalty)).div(10**9);\n    uint256 ethout = selleth.sub(penalty).sub(fees);\n    equity[token] = equity[token].sub(selleth);\n    if(penalty != 0) balanceEquity = balanceEquity.add(penalty);\n    payFees(fees);\n    itkn.burn(tokensToBurn);\n    account.transfer(ethout);\n\n    emit TokenSell(account, token, tokensToBurn, ethout, fees, penalty);\n  }\n\n  /*\n   * @notice Adds liquidty to the contract and gives LP shares. Minimum LP add\n   * is 1 wei. Virtually mints bear/bull tokens to be held in the vault.\n   * @param account Recipient of LP shares\n   * @dev Can be called by router but there is benefit to doing so. All\n   * calculations are done with respect to equity and supply. Doing by price\n   * creates rounding error. Calls updatePrice() then calls getLiqAddTokens()\n   * to determine how many bull/bear to create.\n   */\n  function addLiquidity(address account)\n  public\n  payable\n  virtual\n  updateIfActive()\n  {\n    uint256 ethin = getDepositEquity();\n    (\n      uint256 bullEquity,\n      uint256 bearEquity,\n      uint256 bullTokens,\n      uint256 bearTokens\n    ) = vaultHelper.getLiqAddTokens(address(this), ethin);\n    uint256 sharePrice = vaultHelper.getSharePrice(address(this));\n    uint256 resultingShares = ethin.mul(10**18).div(sharePrice);\n    liqEquity[bull] = liqEquity[bull].add(bullEquity);\n    liqEquity[bear] = liqEquity[bear].add(bearEquity);\n    liqTokens[bull] = liqTokens[bull].add(bullTokens);\n    liqTokens[bear] = liqTokens[bear].add(bearTokens);\n    userShares[account] = userShares[account].add(resultingShares);\n    totalLiqShares = totalLiqShares.add(resultingShares);\n\n    emit LiquidityAdd(account, ethin, resultingShares, sharePrice);\n  }\n\n  /*\n   * @notice Removes liquidty to the contract and gives LP shares. Virtually\n   * burns bear/bull tokens to be held in the vault. Cannot be called if user\n   * has 0 shares\n   * @param _shares How many shares to burn\n   * @dev Cannot be called by a router as LP shares are not currently tokenized.\n   * Calls updatePrice() then calls getLiqRemoveTokens() to determine how many\n   * bull/bear tokens to remove.\n   */\n  function removeLiquidity(uint256 shares)\n  public\n  virtual\n  updateIfActive()\n  {\n    require(shares <= userShares[msg.sender]);\n    (\n      uint256 bullEquity,\n      uint256 bearEquity,\n      uint256 bullTokens,\n      uint256 bearTokens,\n      uint256 feesPaid\n    ) = vaultHelper.getLiqRemoveTokens(address(this), shares);\n    uint256 sharePrice = vaultHelper.getSharePrice(address(this));\n    uint256 resultingEth = bullEquity.add(bearEquity).add(feesPaid);\n    liqEquity[bull] = liqEquity[bull].sub(bullEquity);\n    liqEquity[bear] = liqEquity[bear].sub(bearEquity);\n    liqTokens[bull] = liqTokens[bull].sub(bullTokens);\n    liqTokens[bear] = liqTokens[bear].sub(bearTokens);\n    userShares[msg.sender] = userShares[msg.sender].sub(shares);\n    totalLiqShares = totalLiqShares.sub(shares);\n    liqFees = liqFees.sub(feesPaid);\n    msg.sender.transfer(resultingEth);\n\n    emit LiquidityRemove(msg.sender, resultingEth, shares, sharePrice);\n  }\n\n  /*\n   * @notice Updates price from chainlink oracles.\n   * @param _shares How many shares to burn\n   * @dev Calls getUpdatedPrice() function and sets new price, equity, liquidity\n   * equity, and latestRoundId; only if there is new price data\n   * @return bool if price was updated\n   */\n  function updatePrice()\n  public\n  {\n    require(active == true);\n    (\n      uint256[6] memory priceArray,\n      uint256 roundId,\n      bool updated\n    ) = priceCalculator.getUpdatedPrice(address(this), latestRoundId);\n    if(updated == true) {\n      (\n        price[bull],\n        price[bear],\n        liqEquity[bull],\n        liqEquity[bear],\n        equity[bull],\n        equity[bear],\n        latestRoundId\n      ) =\n      (\n        priceArray[0],\n        priceArray[1],\n        priceArray[2],\n        priceArray[3],\n        priceArray[4],\n        priceArray[5],\n        roundId\n      );\n    }\n    emit PriceUpdate(\n      price[bull],\n      price[bear],\n      liqEquity[bull],\n      liqEquity[bear],\n      equity[bull],\n      equity[bear],\n      latestRoundId,\n      updated\n    );\n  }\n\n  ///////////////////////\n  //INTERNAL FUNCTIONS///\n  ///////////////////////\n\n  /*\n   * @notice Pays half fees to SYN stakers and half to LP\n   * @param _amount Fees to be paid in ETH\n   * @dev Only called by tokenBuy() and tokenSell()\n   */\n  function payFees(uint256 amount) internal {\n    synStakingProxy.transfer(amount.div(2));\n    liqFees += amount.sub(amount.div(2));\n  }\n\n  ///////////////////\n  ///VIEW FUNCTIONS//\n  ///////////////////\n  function getActive() public view returns(bool) {return(active);}\n  function getMultiplier() public pure returns(uint256) {return(multiplier);}\n  function getBullToken() public view returns(address) {return(bull);}\n  function getBearToken() public view returns(address) {return(bear);}\n  function getLatestRoundId() public view returns(uint256) {return(latestRoundId);}\n  function getPrice(address token) public view returns(uint256) {return(price[token]);}\n  function getEquity(address token) public view returns(uint256) {return(equity[token]);}\n  function getBuyFee() public view returns(uint256) {return(buyFee);}\n  function getSellFee() public view returns(uint256) {return(sellFee);}\n  function getTotalLiqShares() public view returns(uint256) {return(totalLiqShares);}\n  function getLiqFees() public view returns(uint256) {return(liqFees);}\n  function getBalanceEquity() public view returns(uint256) {return(balanceEquity);}\n  function getLiqTokens(address token) public view returns(uint256) {return(liqTokens[token]);}\n  function getLiqEquity(address token) public view returns(uint256) {return(liqEquity[token]);}\n  function getUserShares(address account) public view returns(uint256) {return(userShares[account]);}\n\n  function getTotalEquity() public view returns(uint256) {\n    return(getTokenEquity(bear).add(getTokenEquity(bull)));\n  }\n\n  function getTokenEquity(address token) public view returns(uint256) {\n    return(equity[token].add(liqEquity[token]));\n  }\n  function getTokenLiqEquity(address token) public view returns(uint256) {\n    return(liqTokens[token].mul(price[token]).div(10**18));\n  }\n  function getDepositEquity() public view returns(uint256) {\n    return(address(this).balance.sub(liqFees.add(balanceEquity).add(getTotalEquity())));\n  }\n  ///////////////////\n  //ADMIN FUNCTIONS//\n  ///////////////////\n\n  //One time use function to set token addresses. this can never be changed once set.\n  //Cannot be included in constructor as vault must be deployed before tokens.\n  function setTokens(address bearAddress, address bullAddress) public onlyOwner() {\n    require(bear == address(0) || bull == address(0));\n    (bull, bear) = (bullAddress, bearAddress);\n    //Set initial price to .01 eth\n    (price[bull], price[bear]) = (10**16, 10**16);\n  }\n  function setActive(bool state, uint256 roundId) public onlyOwner() {\n    if(roundId != 0) {\n      advanceRoundId(roundId);\n    }\n    active = state;\n  }\n  function advanceRoundId(uint256 roundId) public onlyOwner() {\n    require(active == false);\n    require(roundId > latestRoundId);\n    ( , uint256 lastRoundId) = priceAggregator.priceRequest(address(this), latestRoundId);\n    latestRoundId = lastRoundId >= roundId ? roundId : lastRoundId;\n  }\n  //Fees in the form of 1 / 10^8\n  function setBuyFee(uint256 amount) public onlyOwner() {\n    require(amount <= 10**9);\n    buyFee = amount;\n  }\n  //Sell fees limited to a maximum of 1%\n  function setSellFee(uint256 amount) public onlyOwner() {\n    require(amount <= 10**7);\n    sellFee = amount;\n  }\n\n}\n"
    },
    "IERC20.sol": {
      "content": "pragma solidity >= 0.6.4;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  function mint(address account, uint256 amount) external;\n  function burn(uint256 amount) external;\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "ownable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Owned is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "priceAggregatorInterface.sol": {
      "content": "pragma solidity >= 0.6.6;\n\ninterface priceAggregatorInterface {\n  function registerVaultAggregator(address oracle) external;\n  function priceRequest(\n    address vault,\n    uint256 lastUpdated\n  )\n  external\n  view\n  returns(int256[] memory, uint256);\n  function roundIdCheck(address vault) external view returns(bool);\n}\n"
    },
    "priceCalculatorInterface.sol": {
      "content": "pragma solidity >= 0.6.6;\n\ninterface priceCalculatorInterface {\n  function getUpdatedPrice(\n    address vault,\n    uint256 latestRoundId\n  )\n    external\n    view\n    returns(\n      uint256[6] memory latestPrice,\n      uint256 rRoundId,\n      bool updated\n  );\n  function getKFactor(\n    uint256 targetEquity,\n    uint256 bullEquity,\n    uint256 bearEquity,\n    uint256 totalEquity\n  )\n  external\n  view\n  returns(uint256 kFactor);\n}\n"
    },
    "vaultHelperInterface.sol": {
      "content": "pragma solidity >= 0.6.6;\n\ninterface vaultHelperInterface {\n  function getBonus(address vault, address token, uint256 eth)\n  external\n  view\n  returns(uint256 bonus);\n\n  function getPenalty(address vault, address token, uint256 eth)\n  external\n  view\n  returns(uint256 penalty);\n\n  function getSharePrice(address vault)\n  external\n  view\n  returns(uint256 sharePrice);\n\n  function getLiqAddTokens(address vault, uint256 eth)\n  external\n  view\n  returns(\n    uint256 bullEquity,\n    uint256 bearEquity,\n    uint256 bullTokens,\n    uint256 bearTokens\n  );\n\n  function getLiqRemoveTokens(address vault, uint256 eth)\n  external\n  view\n  returns(\n    uint256 bullEquity,\n    uint256 bearEquity,\n    uint256 bullTokens,\n    uint256 bearTokens,\n    uint256 feesPaid\n  );\n}\n"
    }
  }
}