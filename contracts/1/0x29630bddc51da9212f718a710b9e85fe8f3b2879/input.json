{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"StakeLevel.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n  * @title ArtDeco Finance\r\n  *\r\n  * @notice StakeLevel contract : Three segment for average reward\r\n  * \r\n  */\r\n\r\n/***\r\n* \r\n* MIT License\r\n* ===========\r\n* Original work Copyright(c) 2020 dego\r\n* Modified work Copyright 2020 ArtDeco\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\ninterface IStakeLevel {\r\n    \r\n    function supplyLP(address sender, uint256 amount) external;\r\n    function withdrawLP(address sender, uint256 amount) external;\r\n    function getSupplyWeight(address sender) view  external returns (uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Governance {\r\n\r\n    address public _governance;\r\n\r\n    constructor() public {\r\n        _governance = tx.origin;\r\n    }\r\n\r\n    event GovernanceTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyGovernance {\r\n        require(msg.sender == _governance, \"not governance\");\r\n        _;\r\n    }\r\n\r\n    function setGovernance(address governance)  public  onlyGovernance\r\n    {\r\n        require(governance != address(0), \"new governance the zero address\");\r\n        emit GovernanceTransferred(_governance, governance);\r\n        _governance = governance;\r\n    }\r\n}\r\n\r\ncontract StakeLevel is IStakeLevel, Governance {\r\n    using SafeMath for uint256;\r\n    \r\n    struct stakeArea {\r\n        uint256 min;\r\n        uint256 max;\r\n    }\r\n    struct joincountSeg {\r\n        uint32 length;\r\n        uint32 curCount;\r\n    }\r\n    struct playerInfo {\r\n        uint256 amount;\r\n        uint8 segIndex;\r\n        uint32 playerId;\r\n        uint32 offset;\r\n    }\r\n\r\n    // for APWR-ETH pair\r\n    uint256 constant public  _stakeamountMaxValue = 3 * (10**18);\r\n    // Low level : 0.0 ~ 0.9  ( 30 % )\r\n    // Mid level : 0.9 ~ 1.2  ( 10 % )\r\n    // High level: 1.2 ~ 3.0  ( 60 % )\r\n    uint8[3] public _ruler = [3, 1, 6];\r\n    uint8[3] public _weight_factor = [3, 5, 1];\r\n\r\n    uint8 public _low = 1;\r\n    uint8 public _mid = 2;\r\n    uint8 public _high = 3;\r\n   \r\n    uint32 constant public _highMax = 50;\r\n    uint32 constant public _midMax = 50;    \r\n    uint32 public _base = 100;\r\n    uint32 public _anchor = _base;\r\n    uint32 public _grouthCondition = 100;\r\n    uint32 public _grouthStep = 10;\r\n    \r\n    uint32 public _playerId = 0;\r\n\r\n    address public _contractCaller = address(0x0);\r\n    mapping(address => uint32) public _addressXId;\r\n    mapping(uint8 => stakeArea) public _stakeArea;\r\n    mapping(uint8 => joincountSeg) public _joincountSeg;\r\n    mapping(uint8 => mapping(uint32 => uint32)) public _playerIds;\r\n    mapping(uint32 => playerInfo) public _playerMap;\r\n    \r\n    /**\r\n     * check Is pool invalid or not \r\n     */\r\n    modifier isInvalidPool(){\r\n        require( msg.sender==_contractCaller,\"invalid pool address!\");\r\n        _;\r\n    }\r\n\r\n    constructor() public \r\n    { \r\n        initialoneTime();\r\n    }\r\n\r\n    function initialoneTime() internal\r\n    {\r\n        _playerId = 0;\r\n        init_JoinCount_Seg();\r\n        update_stakeArea_min_max_Ruler(_stakeamountMaxValue);\r\n    }\r\n    \r\n    function supplyLP(address sender, uint256 amount) \r\n    isInvalidPool()\r\n    external {\r\n\r\n        uint32 playerId = _addressXId[sender];\r\n        if ( playerId > 0 ) {\r\n            _playerMap[playerId].amount = _playerMap[playerId].amount.add(amount);\r\n        } else {\r\n            //new addr\r\n            _playerId = _playerId+1;\r\n            _addressXId[sender] = _playerId;\r\n\r\n            playerId = _playerId;\r\n            _playerMap[playerId].playerId = playerId;\r\n            _playerMap[playerId].amount = amount;\r\n            _playerMap[playerId].segIndex = 0;\r\n            _playerMap[playerId].offset =  0;\r\n\r\n            //To Update join counting segment\r\n            update_joincount_Segment();\r\n        }\r\n\r\n        settleJoinArea(playerId);\r\n    }\r\n\r\n\r\n    function withdrawLP(address sender, uint256 amount) \r\n    isInvalidPool()\r\n    external{\r\n        uint32 playerId = _addressXId[sender];\r\n        if ( playerId > 0 ) {\r\n            _playerMap[playerId].amount = _playerMap[playerId].amount.sub(amount);\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        settleJoinArea(playerId);\r\n    }\r\n\r\n\r\n    function getSupplyWeight(address sender) \r\n    view external\r\n    returns (uint256) {\r\n\r\n        uint32 playerId = _addressXId[sender];\r\n        if ( playerId > 0 ) {\r\n            uint8 segment = _playerMap[playerId].segIndex;\r\n            if(segment>0){\r\n                return uint256(_weight_factor[segment-1]).mul(_playerMap[playerId].amount);\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n\r\n    function setCaller( address caller ) public  onlyGovernance{\r\n        _contractCaller = caller;\r\n    }\r\n\r\n    function update_stakeArea_min_max_Ruler( uint256 maxCount ) internal{\r\n\r\n        uint256 lastBegin = 0;\r\n        uint256 lastEnd = 0;\r\n        uint256 splitPoint = 0;\r\n        for (uint8 i = 1; i <= _ruler.length; i++) {\r\n            splitPoint = maxCount * _ruler[i - 1]/10;\r\n            if (splitPoint <= 0) {\r\n                splitPoint = 1;\r\n            }\r\n            lastEnd = lastBegin + splitPoint;\r\n            if (i == _ruler.length) {\r\n                lastEnd = maxCount;\r\n            }\r\n            _stakeArea[i].min = lastBegin + 1;\r\n            _stakeArea[i].max = lastEnd;\r\n            lastBegin = lastEnd;\r\n        }\r\n    }\r\n\r\n    function init_JoinCount_Seg() internal {    \r\n\r\n       _joincountSeg[_low].curCount = 0;\r\n       _joincountSeg[_mid].curCount = 0;\r\n       _joincountSeg[_high].curCount = 0;\r\n       \r\n       _joincountSeg[_low].length = 80;\r\n       _joincountSeg[_mid].length = 10;\r\n       _joincountSeg[_high].length = 10;\r\n    }\r\n\r\n    function update_joincount_Segment( ) internal {\r\n\r\n        if (_playerId >= _grouthCondition+_anchor ) {\r\n            if (_joincountSeg[_high].length + _grouthStep > _highMax) {\r\n                _joincountSeg[_high].length = _highMax;\r\n            } else {\r\n                _joincountSeg[_high].length = _joincountSeg[_high].length+_grouthStep;\r\n            }\r\n\r\n            if (_joincountSeg[_mid].length + _grouthStep > _midMax) {\r\n                _joincountSeg[_mid].length = _midMax;\r\n            } else {\r\n                _joincountSeg[_mid].length = _joincountSeg[_mid].length+_grouthStep;\r\n            }\r\n            _anchor = _playerId;\r\n        }\r\n    }\r\n\r\n    function hasCountSegmentSlot(uint8 segIndex) internal view returns (bool){\r\n        uint32 value = _joincountSeg[segIndex].length-_joincountSeg[segIndex].curCount;\r\n        if (value > 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function findSegmentMinPlayer(uint8 segIndex) internal view returns (uint32,uint256){\r\n        uint256 firstMinAmount = _stakeArea[segIndex].max;\r\n        uint256 secondMinAmount = _stakeArea[segIndex].max;\r\n        uint32 minPlayerOffset = 0;\r\n        for (uint8 i = 0; i < _joincountSeg[segIndex].curCount; i++) {\r\n            uint32 playerId = _playerIds[segIndex][i];\r\n            if( playerId==0 ){\r\n                continue;\r\n            }\r\n            uint256 amount = _playerMap[playerId].amount;\r\n\r\n            //find min amount;\r\n            if ( amount < firstMinAmount) {\r\n                if (firstMinAmount < secondMinAmount) {\r\n                    secondMinAmount = firstMinAmount;\r\n                }\r\n                firstMinAmount = amount;\r\n                minPlayerOffset = i;\r\n            }else{\r\n                //find second min amount\r\n                if(amount < secondMinAmount ){\r\n                    secondMinAmount = amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (minPlayerOffset,secondMinAmount);\r\n    }\r\n\r\n    function JoinsegmentSwap(uint32 playerId, uint8 segIndex) internal {\r\n\r\n        uint8 oldSegIndex = _playerMap[playerId].segIndex;\r\n\r\n        uint32 oldOffset = _playerMap[playerId].offset;\r\n        uint32 tail = _joincountSeg[segIndex].curCount;\r\n\r\n        _playerMap[playerId].segIndex = segIndex;\r\n        _playerMap[playerId].offset = tail;\r\n\r\n        _joincountSeg[segIndex].curCount = _joincountSeg[segIndex].curCount+1;\r\n        _playerIds[segIndex][tail] = playerId;\r\n\r\n        if (oldSegIndex>0 && segIndex != oldSegIndex && _playerIds[oldSegIndex][oldOffset] > 0) {\r\n\r\n            uint32 originTail = _joincountSeg[oldSegIndex].curCount-1;\r\n            uint32 originTailPlayer = _playerIds[oldSegIndex][originTail];\r\n\r\n            if(originTailPlayer != playerId){\r\n\r\n                _playerMap[originTailPlayer].segIndex = oldSegIndex;\r\n                _playerMap[originTailPlayer].offset = oldOffset;\r\n                _playerIds[oldSegIndex][oldOffset] = originTailPlayer;\r\n            }\r\n\r\n            _playerIds[oldSegIndex][originTail] = 0;\r\n            _joincountSeg[oldSegIndex].curCount = _joincountSeg[oldSegIndex].curCount-1;\r\n        }\r\n    }\r\n\r\n    // find the tail id of player, for swap to another area \r\n    function tail_findID_Seg( uint8 segIndex) internal returns (uint32){\r\n\r\n        uint32 minPlayerOffset;\r\n        uint256 secondMinAmount;\r\n        (minPlayerOffset,secondMinAmount) = findSegmentMinPlayer(segIndex);\r\n        _stakeArea[segIndex].min = secondMinAmount;\r\n\r\n        uint32 leftPlayerId = _playerIds[segIndex][minPlayerOffset];\r\n\r\n        //segment reset\r\n        uint32 tail = _joincountSeg[segIndex].curCount - 1;\r\n        uint32 tailPlayerId = _playerIds[segIndex][tail];\r\n        _playerIds[segIndex][minPlayerOffset] = tailPlayerId;\r\n\r\n        _playerMap[tailPlayerId].offset = minPlayerOffset;\r\n\r\n        return leftPlayerId;\r\n    }\r\n\r\n    function joinHigh(uint32 playerId) internal {\r\n        uint8 segIndex = _high;\r\n        if (hasCountSegmentSlot(segIndex)) {\r\n            JoinsegmentSwap(playerId, segIndex);\r\n        } else {\r\n            uint32 leftPlayerId = tail_findID_Seg(segIndex);\r\n            joinMid(leftPlayerId);\r\n            JoinsegmentSwap(playerId, segIndex);\r\n\r\n        }\r\n    }\r\n\r\n    function joinMid(uint32 playerId) internal {\r\n        uint8 segIndex = _mid;\r\n        if (hasCountSegmentSlot(segIndex)) {\r\n            JoinsegmentSwap(playerId, segIndex);\r\n        } else {\r\n            uint32 leftPlayerId = tail_findID_Seg(segIndex);\r\n            joinLow(leftPlayerId);\r\n            JoinsegmentSwap(playerId, segIndex);\r\n        }\r\n        _stakeArea[segIndex].max = _stakeArea[segIndex + 1].min;\r\n    }\r\n\r\n    function joinLow(uint32 playerId) internal {\r\n\r\n        uint8 segIndex = _low;\r\n        JoinsegmentSwap(playerId, segIndex);\r\n        _stakeArea[segIndex].max = _stakeArea[segIndex + 1].min;\r\n        //_low segment length update\r\n        if( _joincountSeg[segIndex].curCount > _joincountSeg[segIndex].length){\r\n            _joincountSeg[segIndex].length = _joincountSeg[segIndex].curCount;\r\n        }\r\n    }\r\n\r\n    function settleJoinArea(uint32 playerId) internal {\r\n\r\n        uint256 amount = _playerMap[playerId].amount;\r\n        uint8 segIndex = 0;\r\n        for (uint8 i = 1; i <= _high; i++) {\r\n            if (amount < _stakeArea[i].max) {\r\n                segIndex = i;\r\n                break;\r\n            }\r\n        }\r\n        if (segIndex == 0) {\r\n            _stakeArea[_high].max = amount;\r\n            segIndex = _high;\r\n        }\r\n\r\n        if (_playerMap[playerId].segIndex == segIndex) {\r\n            return;\r\n        }\r\n\r\n        if (segIndex == _high) {\r\n            joinHigh(playerId);\r\n        } else if (segIndex == _mid) {\r\n            joinMid(playerId);\r\n        } else {\r\n            joinLow(playerId);\r\n        }\r\n    }\r\n\r\n}"}}}