{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/VanillaICO.sol":{"content":"pragma solidity ^0.6.0;\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\nabstract contract IERC20 {\r\n    function transfer(address to, uint256 tokens) external virtual returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external virtual returns (bool success);\r\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    \r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256 r) {\r\n        require(m != 0, \"SafeMath: to ceil number shall not be zero\");\r\n        return (a + m - 1) / m * m;\r\n    }\r\n}\r\n\r\ncontract Vanilla_ICO is Owned{\r\n    \r\n    using SafeMath for uint256;\r\n    address constant private MYX = 0x2129fF6000b95A973236020BCd2b2006B0D8E019;\r\n    address private VANILLA = address(0);\r\n    \r\n    uint256 private SWAP_END;\r\n    \r\n    event TokensSwapped(address indexed _purchaser, uint256 indexed myx, uint256 indexed vanilla);\r\n    event TokensPurchased(address indexed _purchaser, uint256 indexed weis, uint256 indexed vanilla);\r\n    \r\n    \r\n    address payable constant private assetsReceivingWallet1 = 0xE88820E7b990e25E3265833AB29D00fA6B0593E4;\r\n    address payable constant private assetsReceivingWallet2 = 0x6753bbB687a04AA0eCB59ACB4cdf957432EF82dA;\r\n    address payable constant private assetsReceivingWallet3 = 0xa763502F386D8226a59206a2A6F6393e0D88228f;\r\n    address payable constant private assetsReceivingWallet4 = 0xf37DBd0508bD06Ef9b4701d50b7DA7a9C8369B14;\r\n    \r\n    \r\n    uint256 public ethsReceived;\r\n    uint256 public myxReceived;\r\n    uint256 public vanillaDistributed;\r\n    \r\n    modifier swappingOpen{\r\n        require(block.timestamp <= SWAP_END, \"Swap sale is close\");\r\n        _;\r\n    }\r\n    \r\n    constructor() public {\r\n        owner = 0xFa50b82cbf2942008A097B6289F39b1bb797C5Cd;\r\n        SWAP_END = 1605182399; // 12 november, 2020 23:59:59 GMT\r\n    }\r\n    \r\n    function MYX_VANILLA(uint256 tokens) external swappingOpen{\r\n       require(tokens > 0, \"myx should not be zero\");\r\n       uint256 myxInContract_before = IERC20(MYX).balanceOf(address(this));\r\n       require(IERC20(MYX).transferFrom(msg.sender, address(this), tokens), \"Insufficient tokens in user wallet\");\r\n       uint256 myxInContract_after = IERC20(MYX).balanceOf(address(this));\r\n       \r\n       uint256 vanilla = tokens.mul(10 ** (18)); // tokens actually sent will used to calculate vanilla in swap\r\n       vanilla = vanilla.div(500);\r\n       vanilla = vanilla.div(10 ** 18);\r\n       \r\n       \r\n       myxInContract_after = myxInContract_after.sub(myxInContract_before);\r\n       \r\n       myxReceived = myxReceived.add(tokens);\r\n       \r\n       vanillaDistributed = vanillaDistributed.add(vanilla);\r\n       \r\n       require(IERC20(VANILLA).transfer(msg.sender, vanilla), \"All tokens sold\");\r\n       \r\n       // send the received funds to the 4 owner wallets\r\n       distributeReceivedAssets(true, myxInContract_after);\r\n       \r\n       emit TokensSwapped(msg.sender, tokens, vanilla);\r\n    }\r\n    \r\n    receive() external payable{\r\n       ETH_VANILLA(); \r\n    }\r\n    \r\n    function ETH_VANILLA() public payable swappingOpen{\r\n       require(msg.value > 0, \"investment should be greater than zero\");\r\n       uint256 vanilla = msg.value.mul(2750); // 1 ether = 2750 vanilla\r\n       \r\n       ethsReceived = ethsReceived.add(msg.value);\r\n       vanillaDistributed = vanillaDistributed.add(vanilla);\r\n       \r\n       require(IERC20(VANILLA).transfer(msg.sender, vanilla), \"All tokens sold\");\r\n       \r\n       // send the received funds to the 4 owner wallets\r\n       distributeReceivedAssets(false, msg.value);\r\n       \r\n       emit TokensPurchased(msg.sender, msg.value, vanilla);\r\n    }\r\n    \r\n    function getUnSoldTokens() external onlyOwner{\r\n        require(block.timestamp > SWAP_END, \"ICO is not over\");\r\n        \r\n        require(IERC20(VANILLA).transfer(owner, IERC20(VANILLA).balanceOf(address(this))), \"No tokens in contract\");\r\n    }\r\n    \r\n    function setVanillaAddress(address _vanillaContract) external onlyOwner{\r\n        require(VANILLA == address(0), \"address already linked\");\r\n        VANILLA = _vanillaContract;\r\n    }\r\n    \r\n    function distributeReceivedAssets(bool myx, uint256 amount) private{\r\n        if(myx){\r\n            if(divideAssetByFour(amount) > 0){\r\n                // send the received funds to the 4 owner wallets\r\n                IERC20(MYX).transfer(assetsReceivingWallet1, divideAssetByFour(amount));\r\n                IERC20(MYX).transfer(assetsReceivingWallet2, divideAssetByFour(amount));\r\n                IERC20(MYX).transfer(assetsReceivingWallet3, divideAssetByFour(amount));\r\n                \r\n            }\r\n            IERC20(MYX).transfer(assetsReceivingWallet4, divideAssetByFour(amount).add(getRemainings(amount)));\r\n        }\r\n        else{\r\n            if(divideAssetByFour(amount) > 0){\r\n                // send the received funds to the 4 owner wallets\r\n                assetsReceivingWallet1.transfer(divideAssetByFour(amount));\r\n                assetsReceivingWallet2.transfer(divideAssetByFour(amount));\r\n                assetsReceivingWallet3.transfer(divideAssetByFour(amount));\r\n            }\r\n            assetsReceivingWallet4.transfer(divideAssetByFour(amount).add(getRemainings(amount)));\r\n        }\r\n    }\r\n    \r\n    function divideAssetByFour(uint256 amount) public pure returns(uint256){\r\n        return amount.div(4);\r\n    }\r\n    \r\n    function getRemainings(uint256 amount) public pure returns(uint256){\r\n        return amount.mod(4);\r\n    }\r\n}"}}}