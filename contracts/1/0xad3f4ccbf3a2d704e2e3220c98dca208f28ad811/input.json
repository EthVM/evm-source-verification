{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/corgi-token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/**\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n pragma solidity ^0.8.4;\n\n/**\n * Lib: Safe Math\n */\ncontract SafeMath {\n  function safeAdd(uint a, uint b) public pure returns (uint c) {\n    c = a + b;\n    require(c >= a);\n  }\n\n  function safeSub(uint a, uint b) public pure returns (uint c) {\n    require(b <= a);\n    c = a - b;\n  }\n\n  function safeMul(uint a, uint b) public pure returns (uint c) {\n    c = a * b;\n    require(a == 0 || c / a == b);\n  }\n\n  function safeDiv(uint a, uint b) public pure returns (uint c) {\n    require(b > 0);\n    c = a / b;\n  }\n}\n\n/**\n * ERC Token Standard #20 Interface.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\nabstract contract ERC20Interface {\n  function totalSupply() virtual public view returns (uint);\n  function balanceOf(address tokenOwner) virtual public view returns (uint balance);\n  function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n  function transfer(address to, uint tokens) virtual public returns (bool success);\n  function approve(address spender, uint tokens) virtual public returns (bool success);\n  function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n/**\n * Contract function to receive approval and execute function in one call.\n */\nabstract contract ApproveAndCallFallBack {\n  function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\n}\n\n/**\n * Owned contract.\n */ \ncontract Owned {\n  address public owner;\n  address public newOwner;\n\n  event OwnershipTransferred(address indexed _from, address indexed _to);\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address _newOwner) public onlyOwner {\n    newOwner = _newOwner;\n  }\n\n  function acceptOwnership() public {\n    require(msg.sender == newOwner);\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n    newOwner = address(0);\n  }\n}\n\n/**\n * ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers.\n */\ncontract CorgiToken is ERC20Interface, SafeMath, Owned {\n  string public _symbol;\n  string public _name;\n  uint8 public _decimals;\n  uint public _totalSupply;\n\n  mapping(address => uint) balances;\n  mapping(address => mapping(address => uint)) allowed;\n\n  constructor() {\n    _symbol = \"CORGI\";\n    _name = \"Corgi Token\";\n    _decimals = 4;\n    _totalSupply = 10000000000000000;\n    balances[0xB4b8ba3D4e4384749A131786c59B4AD3C58625C9] = _totalSupply;\n    emit Transfer(address(0), 0xB4b8ba3D4e4384749A131786c59B4AD3C58625C9, _totalSupply);\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public override view  returns (uint) {\n    return _totalSupply - balances[address(0)];\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\n    return balances[tokenOwner];\n  }\n\n  function transfer(address to, uint tokens) public override returns (bool success) {\n    require(tokens > 100);\n    balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n    balances[to] = safeAdd(balances[to], tokens);\n    emit Transfer(msg.sender, to, tokens);\n    return true;\n  }\n\n  function approve(address spender, uint tokens) public override returns (bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n    require(tokens > 100);\n    require(tokens <= balances[msg.sender]);\n    balances[from] = safeSub(balances[from], tokens);\n    allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n    balances[to] = safeAdd(balances[to], tokens);\n    emit Transfer(from, to, tokens);\n    return true;\n  }\n\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n    return allowed[tokenOwner][spender];\n  }\n\n  function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n    return true;\n  }\n\n  // Owner can transfer out any accidentally sent ERC20 tokens.\n  function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n    return ERC20Interface(tokenAddress).transfer(owner, tokens);\n  }\n}\n"
    }
  }
}