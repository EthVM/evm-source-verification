{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "GraToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title SafeMath \r\n * @dev Unsigned math operations with safety checks that revert on error.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplie two unsigned integers, revert on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, revert on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtract two unsigned integers, revert on underflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Add two unsigned integers, revert on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool); \r\n\r\n    function approve(address spender, uint256 value) external returns (bool); \r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool); \r\n\r\n    function totalSupply() external view returns (uint256); \r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256); \r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value); \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value); \r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implementation of the basic standard token.\r\n */\r\ncontract StandardToken is IERC20, Context {\r\n    using SafeMath for uint256; \r\n    \r\n    mapping (address => uint256) internal _balances; \r\n    mapping (address => mapping (address => uint256)) internal _allowed; \r\n    \r\n    uint256 internal _totalSupply; \r\n    \r\n    /**\r\n     * @dev Total number of tokens in existence.\r\n     */\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply; \r\n    }\r\n\r\n    /**\r\n     * @dev Get the balance of the specified address.\r\n     * @param owner The address to query the balance of.\r\n     * @return A uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) public override view  returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner The address which owns the funds.\r\n     * @param spender The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        _approve(_msgSender(), spender, value); \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from The address which you want to send tokens from.\r\n     * @param to The address which you want to transfer to.\r\n     * @param value The amount of tokens to be transferred.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public virtual override returns (bool) {\r\n        _transfer(from, to, value); \r\n        _approve(from, _msgSender(), _allowed[from][_msgSender()].sub(value)); \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowed[_msgSender()][spender].add(addedValue)); \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * Emits an Approval event.\r\n     * @param spender The address which will spend the funds.\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowed[_msgSender()][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens for a specified address.\r\n     * @param from The address to transfer from.\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(to != address(0), \"Cannot transfer to the zero address\"); \r\n        _balances[from] = _balances[from].sub(value); \r\n        _balances[to] = _balances[to].add(value); \r\n        emit Transfer(from, to, value); \r\n    }\r\n\r\n    /**\r\n     * @dev Approve an address to spend another addresses' tokens.\r\n     * @param owner The address that owns the tokens.\r\n     * @param spender The address that will spend the tokens.\r\n     * @param value The number of tokens that can be spent.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(spender != address(0), \"Cannot approve to the zero address\"); \r\n        require(owner != address(0), \"Setter cannot be the zero address\"); \r\n\t    _allowed[owner][spender] = value;\r\n        emit Approval(owner, spender, value); \r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal virtual {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowed[account][_msgSender()].sub(amount));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract WhiteList is Ownable {\r\n\r\n    mapping(address => uint256) public whiter;\r\n\r\n    event AppendWhiter(address adder);\r\n    event RemoveWhiter(address remover);\r\n\r\n    /**\r\n     * @notice Only onwer can append address into whitelist\r\n     * @param account The address not added, can added to the whitelist\r\n     */\r\n    function appendWhiter(address account) public onlyOwner {\r\n        require(account != address(0), \"WhiteList: address not zero\");\r\n        require(\r\n            isNotWhiter(account),\r\n            \"WhiteListe: the account exsit whilteList yet\"\r\n        );\r\n        whiter[account] = 1;\r\n        emit AppendWhiter(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Only onwer can remove address into whitelist\r\n     * @param account The address in whitelist yet\r\n     */\r\n    function removeWhiter(address account) public onlyOwner {\r\n        require(\r\n            isWhiter(account),\r\n            \"WhiteListe: the account not exist whilteList\"\r\n        );\r\n        delete whiter[account];\r\n        emit RemoveWhiter(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether acccount in whitelist\r\n     * @param account Any address\r\n     */\r\n    function isWhiter(address account) public view returns (bool) {\r\n        return whiter[account] == 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether acccount not in whitelist\r\n     * @param account Any address\r\n     */\r\n    function isNotWhiter(address account) public view returns (bool) {\r\n        return whiter[account] != 1;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract GraToken is StandardToken, Ownable, WhiteList {\r\n\r\n//---------------Token Info---------------//    \r\n    string public constant name = \"Gra\";\r\n    string public constant symbol = \"Gra\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 82680000 * 10 ** 18;\r\n\r\n    address public constant tokenWallet = 0xa19c059c61605ba41EFC407dF5F27DAfAf6d5C58; // token owner\r\n    address public swapGovContract;\r\n    // bool setGovFlag = false;\r\n\r\n//---------------Lock Info---------------//\r\n    uint256 public techReleaseByDay = 6040 * 10 ** 18; \r\n    uint256 public capitalReleaseByDay =64 * 10 ** 18;\r\n    uint256 public nodeReleaseByDay = 44 * 10 ** 18;\r\n    // uint256 public lockedAmount;\r\n    \r\n\r\n    struct LockInfo {\r\n        uint256 initLock;\r\n        uint256 lockedAmount;\r\n        uint256 lastUnlockTs;\r\n        uint256 releaseType;\r\n    }\r\n\r\n    mapping(address => LockInfo) public lockedUser;\r\n\r\n    event Lock(address account, uint256 startTime, uint256 amount, uint256 releaseType);\r\n    event UnLock(address account, uint256 unlockTime, uint256 amount);\r\n//---------------Blacklist module---------------// \r\n    mapping(address => bool) private _isBlackListed;\r\n    event AddedBlackLists(address[]);\r\n    event RemovedBlackLists(address[]);\r\n\r\n//---------------Burn fee module---------------// \r\n    uint256 public feeRate; \r\n\r\n    constructor() public {\r\n        feeRate = 200; // default as 2%\r\n        _totalSupply = INITIAL_SUPPLY;\r\n        _balances[tokenWallet] = _totalSupply;\r\n        emit Transfer(address(0), tokenWallet, INITIAL_SUPPLY);\r\n\r\n        _owner = tokenWallet;\r\n        emit OwnershipTransferred(address(0), tokenWallet);\r\n        appendWhiter(_owner);\r\n\r\n    }\r\n\r\n    function getFee(uint256 amount) public view returns (uint256)  {\r\n        uint256 fee = amount.mul(feeRate).div(10000); \r\n\t\treturn fee;\r\n    }\r\n\r\n    function isBlackListed(address user) public view returns (bool) {\r\n        return _isBlackListed[user];\r\n    }\r\n\r\n    function addBlackLists(address[] calldata _evilUser) public onlyOwner {\r\n        for (uint i = 0; i < _evilUser.length; i++) {\r\n            _isBlackListed[_evilUser[i]] = true;\r\n        }\r\n        emit AddedBlackLists(_evilUser);\r\n    }\r\n\r\n    function removeBlackLists(address[] calldata _clearedUser) public onlyOwner {\r\n        for (uint i = 0; i < _clearedUser.length; i++) {\r\n            delete _isBlackListed[_clearedUser[i]];\r\n        }\r\n        emit RemovedBlackLists(_clearedUser);\r\n    }\r\n    \r\n    \r\n    // function lockToGov() public onlyOwner {\r\n    //     _transfer(_owner, swapGovContract, MINEREWARD); // transfer/freeze to swapGovContract\r\n    //     lockedAmount = lockedAmount.add(MINEREWARD);\r\n    // }\r\n    function lock(address _account, uint256 _amount, uint256 _type) public onlyOwner {\r\n        require(_account != address(0), \"Cannot transfer to the zero address\");\r\n        require(lockedUser[_account].lockedAmount == 0, \"exist locked token\");\r\n        require(_account != swapGovContract, \"equal to swapGovContract\");\r\n        lockedUser[_account].initLock = _amount;\r\n        lockedUser[_account].lockedAmount = _amount;\r\n        lockedUser[_account].lastUnlockTs = block.timestamp;\r\n        lockedUser[_account].releaseType = _type;\r\n        _balances[_msgSender()] = _balances[_msgSender()].sub(_amount);\r\n        _balances[_account] = _balances[_account].add(_amount);\r\n        emit Lock(_account, block.timestamp, _amount, _type);\r\n        emit Transfer(_msgSender(), _account, _amount);\r\n    }\r\n\r\n    function unlock() public {\r\n        uint256 amount = getAvailablelockAmount(_msgSender(), lockedUser[_msgSender()].releaseType);\r\n        require(amount > 0, \"amount equal 0\");\r\n        lockedUser[_msgSender()].lockedAmount = lockedUser[_msgSender()].lockedAmount.sub(amount);\r\n        lockedUser[_msgSender()].lastUnlockTs = block.timestamp;\r\n        emit UnLock(_msgSender(), block.timestamp, amount);\r\n    }\r\n\r\n    function getAvailablelockAmount(address account, uint256 releaseType) public view returns (uint256) {\r\n        if(lockedUser[account].lockedAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if(block.timestamp <= lockedUser[account].lastUnlockTs) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 _days = block.timestamp.sub(lockedUser[account].lastUnlockTs).div(86400);\r\n        if(_days > 0 && releaseType == 1) {\r\n            uint256 _releaseAmount = _days.mul(techReleaseByDay);\r\n            return lockedUser[account].lockedAmount > _releaseAmount ? _releaseAmount : lockedUser[account].lockedAmount;\r\n        }\r\n\r\n        if(_days > 0 && releaseType == 2) {\r\n            uint256 _releaseAmount = _days.mul(capitalReleaseByDay);\r\n            return lockedUser[account].lockedAmount > _releaseAmount ? _releaseAmount : lockedUser[account].lockedAmount;\r\n        }\r\n\r\n        if(_days > 0 && releaseType == 3) {\r\n            uint256 _releaseAmount = _days.mul(nodeReleaseByDay);\r\n            return lockedUser[account].lockedAmount > _releaseAmount ? _releaseAmount : lockedUser[account].lockedAmount;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool) {\r\n        require(!isBlackListed(_msgSender()));\r\n        require(!isBlackListed(_to));\r\n        require(_balances[_msgSender()].sub(lockedUser[_msgSender()].lockedAmount) >= _value);\r\n        if (isNotWhiter(_msgSender())) { // fee burning whitelist\r\n            uint256 fee = getFee(_value);\r\n            _burn(_msgSender(), fee);\r\n            _value = _value.sub(fee);\r\n        }\r\n\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\r\n        require(!isBlackListed(_msgSender()));\r\n        require(!isBlackListed(_from));\r\n        require(!isBlackListed(_to));\r\n        require(_balances[_from].sub(lockedUser[_msgSender()].lockedAmount) >= _value);\r\n        if (isNotWhiter(_from)) { // fee burning whitelist\r\n    \t    uint256 fee = getFee(_value);\r\n            _burnFrom(_from, fee);\r\n            _value = _value.sub(fee);\r\n        }\r\n\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to multiple addresses.\r\n     */\r\n    function batchTransfer(address[] memory addressList, uint256[] memory amountList) public onlyOwner returns (bool) {\r\n        uint256 length = addressList.length;\r\n        require(addressList.length == amountList.length, \"Inconsistent array length\");\r\n        require(length > 0 && length <= 150, \"Invalid number of transfer objects\");\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            require(amountList[i] > 0, \"The transfer amount cannot be 0\");\r\n            require(addressList[i] != address(0), \"Cannot transfer to the zero address\");\r\n            require(!isBlackListed(addressList[i]));\r\n            amount = amount.add(amountList[i]);\r\n            _balances[addressList[i]] = _balances[addressList[i]].add(amountList[i]);\r\n            emit Transfer(_msgSender(), addressList[i], amountList[i]);\r\n        }\r\n        require(_balances[_msgSender()] >= amount, \"Not enough tokens to transfer\");\r\n        _balances[_msgSender()] = _balances[_msgSender()].sub(amount);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _burnFrom(account, amount);\r\n    }\r\n\r\n    function setFeeRate(uint256 newFeeRate) public onlyOwner {\r\n\t    require (newFeeRate <= 500); \r\n\t    feeRate = newFeeRate; \r\n    } \r\n    \r\n    function setGovAddr(address _swapGovContract) public onlyOwner {\r\n        // require(!setGovFlag); // only once\r\n        swapGovContract = _swapGovContract;\r\n        // setGovFlag = true;\r\n    }\r\n    function setReleaseByDay(uint256 _techReleaseByDay, uint256 _capitalReleaseByDay, uint256  _nodeReleaseByDay) public onlyOwner {\r\n        require(_techReleaseByDay > 0, \" must be great 0\");\r\n        require(_capitalReleaseByDay > 0, \" must be great 0\");\r\n        require(_nodeReleaseByDay > 0, \" must be great 0\");\r\n        techReleaseByDay = _techReleaseByDay;\r\n        capitalReleaseByDay = _capitalReleaseByDay;\r\n        nodeReleaseByDay = _nodeReleaseByDay;\r\n    }\r\n}"
    }
  }
}