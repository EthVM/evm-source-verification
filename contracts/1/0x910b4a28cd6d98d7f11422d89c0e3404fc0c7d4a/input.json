{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/aston.sol":{"content":"pragma solidity ^0.6.1;\r\n\r\n/**\r\n\r\n _____  _____   ______  ______\r\n\\    \\ \\          \\    \\     \\   \\-      \\\r\n\\----\\ \\_____     \\    \\     \\   \\  -    \\\r\n\\    \\      \\     \\    \\     \\   \\    -  \\\r\n\\    \\  ____\\     \\    \\_____\\   \\      -\\\r\n\r\n    WEBSITE: aston.run\r\n   \r\n   \r\n  * aston.run - fair games that pay Ether. \r\n* Ethereum smart contract, deployed.\r\n\r\n * Uses hybrid commit-reveal + block hash random number generation that is immune\r\n   to tampering by players, house and miners. Apart from being fully transparent,\r\n   this also allows arbitrarily input.\r\n\r\n * Refer to https://aston.run for detailed description and proofs.\r\n  \r\n */\r\n//Library for safe math\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n    \r\n    //Mian Business contract is drived from owner contract\r\n        contract Generation{\r\n                address payable public owner;// owner address\r\n        // for partners to share commission\r\n        address payable creator1;\r\n        address payable creator2;\r\n        address payable creator3;\r\n        address payable creator4;\r\n        \r\n        // owner contract modifier\r\n            using SafeMath for uint256;\r\n                uint256 commission;\r\n                string public session;\r\n        //struct for user    \r\n        struct user\r\n        {\r\n        bool isExist;         //for user existance\r\n        bool isRecomended;    //for checking is Recommended or not\r\n        uint256 earning;      //earnings from investments\r\n        uint256 id;           // user id\r\n       uint256 recomendation; //for recomendation counter\r\n       uint256 creationTime;  //creationTime counter\r\n       uint256 total_Days;    //total_Days counter\r\n       uint256 total_Amount;  //total_Amount counter earnings\r\n       uint256 level;         //level counter  // ref_Income earn by levels \r\n       uint256 referBy;       //refferer address\r\n       bool expirePeriod;    //session expired\r\n       uint256 visit;         //number of customer invested in this program\r\n       uint256 ref_Income; \r\n       address[] reffrals;    //number of reffrals by You\r\n       uint256 total_Withdraw;\r\n    }\r\n    user[] userList;          //List of all users\r\n    //mappings\r\n    mapping(address=>user)public users; //enter address to get user\r\n    mapping(address=>address payable)public recomendators;//number of people come through one person\r\n    mapping(address=>uint256)private invested;           //how much user invested\r\n    mapping(address=>bool)public isInvested;            //check user invested or not\r\n    mapping(uint256=>address payable)public userAddress;  //enter use id and get address\r\n    //Events\r\n    // for registration\r\n    event RegUser(bool isExist,uint256 earning,uint256 recomendation, uint256 creationTime,uint256 total_Days,bool isRecomended,uint256 id);\r\n    //for invest event\r\n    event Invest(address _user,uint256 _value);\r\n    //for Recommend event\r\n   event Recommend(address _user,address _refference,uint256 referBy);\r\n        // For WithDrawl event\r\n    event    WithDrawl(address user,uint256 earning);\r\n    \r\n    //constructor\r\n        constructor() payable public{\r\n            owner=msg.sender;\r\n            creator1=0xF161abA3a2cc544133C41d28D35c6d20B7f5754B;\r\n            creator2=0x77dC753d9c15Fae33eC91422342130D79ff3F84b;\r\n            creator3=0xf242aA1C641591DDe68c598A3C9eAa285794ae80;\r\n            creator4=0xa5a625D3CC186Fa68aa4EeCa7D29b1b6154f4201;\r\n            \r\n        }\r\n\r\n    //modifier\r\n       modifier onlyOwner(){\r\n        require(msg.sender==owner,\"only owner can run this\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAmount(){\r\n            bool u=false;\r\n            if(users[msg.sender].visit==0){\r\n                require(msg.value==0.25 ether,\"you are new one ans start with 0.25 ether\");\r\n            }\r\n        if(msg.value==0.25 ether || msg.value==0.50 ether && users[msg.sender].visit==1){\r\n            u=true;\r\n        }\r\n        if(msg.value==0.25 ether || msg.value==0.50 ether||msg.value==0.75 ether&& users[msg.sender].visit>1){\r\n            u=true;\r\n        }\r\n    require(u==true,\"you have to enter right amount\");\r\n         _;\r\n    }\r\n    modifier onlyFirst(uint256 _refference){ //for Recommend functions\r\n    address a=userAddress[_refference];\r\n        require(users[a].isExist==true); //to check reference should exist before \r\n        require(users[a].recomendation<10,\"refferer already have 10 reference\");\r\n        require(a!=msg.sender);   //to check investor should not be refferer\r\n        \r\n        _;\r\n    }\r\n    modifier firstExist(){   // for in function\r\n        require(users[msg.sender].isExist==true);   //investor should be registered before investments\r\n        \r\n        _;\r\n    }\r\n    modifier reinvest(){\r\n            user memory obj=users[msg.sender];\r\n        require(obj.visit>0,\"visit should be above 0\");\r\n        require(obj.earning==0,\"You have to withdraw all your money\");\r\n        _;\r\n    }\r\n    // public functions\r\n    //invest function\r\n    function regUser()public returns(bool){\r\n        uint256 _id=userList.length+1;\r\n        require(users[msg.sender].isExist==false);\r\n        user memory obj =user({isExist:true,earning:0,recomendation:0,creationTime:0,total_Days:0,isRecomended:false,id:_id,\r\n     total_Amount:0,level:0,referBy:0,expirePeriod:true,visit:0,ref_Income:0,total_Withdraw:0,reffrals:new address[](0)});\r\n     userList.push(obj);\r\n     users[msg.sender]= obj;\r\n      userAddress[_id]=msg.sender;\r\n     emit RegUser(obj.isExist,obj.earning,obj.recomendation,obj.creationTime,obj.total_Days,obj.isRecomended,obj.id);\r\n    return true;\r\n    }\r\n    function invest()public payable onlyAmount() firstExist  returns(bool){\r\n        require(users[msg.sender].expirePeriod==true,\"your session should be new\");\r\n     require(isInvested[msg.sender]==false);    //investor should not invested before\r\n    invested[msg.sender]= msg.value;\r\n     isInvested[msg.sender]=true;\r\n     users[msg.sender].creationTime=now;\r\n     users[msg.sender].expirePeriod=false;\r\n     users[msg.sender].visit+=1;\r\n     users[msg.sender].total_Withdraw=0;\r\n      commission=(msg.value.mul(10)).div(100);\r\n     forCreators(commission);\r\n    emit Invest(msg.sender,msg.value);\r\n     return true;\r\n    }\r\n    \r\n    function ReInvest()public  payable reinvest returns(bool){\r\n            invest();\r\n            return true;\r\n        \r\n    }\r\n    //recommend function\r\n    function recommend(uint256 _refference)public payable  onlyAmount  onlyFirst(_refference) firstExist\r\n    returns(bool){\r\n        require(users[msg.sender].visit==0,\"you are already investor\");\r\n    invest();\r\n    address payable a=userAddress[_refference];\r\n    require(isInvested[a]==true);\r\n        recomendators[msg.sender]=a;\r\n        users[a].reffrals.push(msg.sender);\r\n        users[a].recomendation+=1;\r\n        if(users[a].level<1){\r\n        users[a].level=1;\r\n        }\r\n        users[msg.sender].referBy=_refference;\r\n        users[msg.sender].isRecomended=true;\r\n        \r\n        \r\n        emit Recommend(msg.sender,a,_refference);\r\n        return true;\r\n    }\r\n    // Add_daily_Income function\r\n    function Add_daily_Income()public firstExist  returns(bool){\r\n        uint256 d;\r\n        \r\n        user memory obj=users[msg.sender];\r\n      uint256  t=obj.total_Days;\r\n      uint256  p=obj.total_Amount;\r\n        require(obj.expirePeriod==false,\"your seesion has expired\");\r\n        uint256 time=now - obj.creationTime;\r\n      uint256 daysCount=time.div(86400);\r\n      users[msg.sender].total_Days+=daysCount;\r\n      t+=daysCount;\r\n      \r\n          require(isInvested[msg.sender]==true);\r\n          \r\n        uint256  c=(invested[msg.sender].mul(1)).div(100);\r\n       d=c.mul(daysCount);\r\n        users[msg.sender].total_Amount+=d;\r\n        p+=d;\r\n        if(t>=401 || p>=invested[msg.sender].mul(4)){\r\n            // users[msg.sender].expirePeriod=true;\r\n           session = expire();\r\n            return true;\r\n        }\r\n        else{\r\n        users[msg.sender].earning+=d;\r\n        assert(obj.total_Amount<=invested[msg.sender].mul(4));\r\n         if(obj.isRecomended==true){\r\n             user memory obj1;\r\n            address payable m=recomendators[msg.sender];\r\n            obj1= users[m];\r\n            \r\n            uint256 f=(d.mul(10)).div(100);\r\n            if(obj1.expirePeriod==false){\r\n            users[m].earning+=f;\r\n            users[m].total_Amount+=f;\r\n            users[m].ref_Income+=f;}\r\n            if(obj1.isRecomended==true){\r\n                uint256 depth=1;\r\n             distribute(m,depth,f);\r\n            }\r\n        }\r\n        if(daysCount>0){\r\n        users[msg.sender].creationTime=now;\r\n        }\r\n        }\r\n        return true;\r\n    }\r\n    //distribute function\r\n    function distribute(address payable add,uint256 _depth,uint256 _f)private  returns (bool){\r\n        _depth++;\r\n         user memory obj1=users[add];\r\n         if(obj1.isRecomended==true){\r\n             address payable add1=recomendators[add];\r\n             user memory obj2=users[add1];\r\n             if(obj2.recomendation>=_depth){\r\n                 if(obj2.expirePeriod==false){\r\n                 users[add1].earning+=_f;\r\n                 users[add1].total_Amount+=_f;\r\n                 users[add1].ref_Income+=_f;}\r\n                 if(obj2.level<_depth){\r\n                 users[add1].level=_depth;\r\n                 }\r\n             }\r\n                 distribute(add1,_depth,_f);\r\n             }\r\n             \r\n         \r\n        return true;\r\n    }\r\n    //withDrawl function\r\n    function withDrawl(uint256 _value)public payable firstExist returns(string memory){\r\n        address payable r=msg.sender;\r\n        user memory obj=users[r];\r\n        require(obj.earning>=_value,\"you are trying to withdraw amount higher than your earnings\");\r\n        require(obj.earning>0,\"your earning is 0\");\r\n        require(address(this).balance>_value,\"contract has less amount\");\r\n        require(obj.total_Withdraw<invested[msg.sender].mul(4) ,\"you are already withdraw all amount\");\r\n         \r\n                  if(obj.earning.add(obj.total_Withdraw)>invested[msg.sender].mul(4)){\r\n                      uint256 h=obj.earning;\r\n                     uint256 x=(invested[msg.sender].mul(4)).sub(obj.total_Withdraw);\r\n                     uint256 a=obj.earning.sub(x);\r\n                     \r\n                     h=h.sub(a);\r\n                      r.transfer(h);\r\n                  users[msg.sender].earning=0;\r\n                  users[msg.sender].total_Withdraw=obj.total_Withdraw.add(h);\r\n                //   users[msg.sender].expirePeriod=true;\r\n                session=expire();\r\n                  return \"you have WithDraw all your profit\";\r\n                  }\r\n                  else{\r\n                        users[msg.sender].total_Withdraw=obj.total_Withdraw.add(_value);\r\n                        users[msg.sender].earning=obj.earning.sub(_value);\r\n                        r.transfer(_value);   \r\n                        return \"you have succesfully WithDrawl your money\";\r\n                  }\r\n               \r\n                      }\r\n        receive () external payable{\r\n        }\r\n        \r\n    // private functions\r\n    // expire function\r\n    function expire()private firstExist  returns(string memory){ //to invest again you have to expire first\r\n     users[msg.sender].total_Days=0;\r\n     users[msg.sender].total_Amount=0; \r\n     users[msg.sender].expirePeriod=true;\r\n     users[msg.sender].ref_Income=0;\r\n     isInvested[msg.sender]=false;\r\n        return \"your session has expired\";\r\n    }\r\n    // forCreators function\r\n    function forCreators(uint256 _value)private returns(bool ){\r\n        uint256 p=_value.div(4);\r\n        creator1.transfer(p);\r\n        creator2.transfer(p);\r\n        creator3.transfer(p);\r\n        creator4.transfer(p);\r\n        return true;\r\n    }\r\n    //Owner functions\r\n       function changeOwnership(address payable newOwner)public onlyOwner returns(bool){\r\n        owner=newOwner;\r\n        return true;\r\n    }    \r\n    function deleteParticipent()public onlyOwner returns (bool){\r\n        owner.transfer(address(this).balance);\r\n        return true;\r\n    }\r\n    function tree(address wallet)public view returns(address[] memory){\r\n        user memory obj=users[wallet];\r\n        return obj.reffrals;\r\n    }\r\n    function chnagePart(address payable _newAddress,address _oldAddress)public onlyOwner returns(string memory){\r\n        if(creator1==_oldAddress){\r\n            creator1=_newAddress;\r\n        }\r\n        else if(creator2==_oldAddress){\r\n            creator2=_newAddress;\r\n        }\r\n        else if(creator3==_oldAddress){\r\n            creator3=_newAddress;\r\n        }\r\n        else if(creator4==_oldAddress){\r\n            creator4=_newAddress;\r\n        }\r\n        else{\r\n            return \"your address does not found\";\r\n        }\r\n        return \"your address succesfuly changed\";\r\n    }\r\n \r\n}"}}}