{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ttt.sol":{"content":"// SPDX-License-Identifier: GPL\r\npragma solidity 0.6.12;\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath256 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/*\r\nThis library defines a decimal floating point number. It has 8 decimal significant digits. Its maximum value is 9.9999999e+15.\r\nAnd its minimum value is 1.0e-16. The following golang code explains its detail implementation.\r\n\r\nfunc buildPrice(significant int, exponent int) uint32 {\r\n\tif !(10000000 <= significant && significant <= 99999999) {\r\n\t\tpanic(\"Invalid significant\")\r\n\t}\r\n\tif !(-16 <= exponent && exponent <= 15) {\r\n\t\tpanic(\"Invalid exponent\")\r\n\t}\r\n\treturn uint32(((exponent+16)<<27)|significant);\r\n}\r\n\r\nfunc priceToFloat(price uint32) float64 {\r\n\texponent := int(price>>27)\r\n\tsignificant := float64(price&((1<<27)-1))\r\n\treturn significant * math.Pow10(exponent-23)\r\n}\r\n\r\n*/\r\n\r\n// A price presented as a rational number\r\nstruct RatPrice {\r\n    uint numerator;   // at most 54bits\r\n    uint denominator; // at most 76bits\r\n}\r\n\r\nlibrary DecFloat32 {\r\n    uint32 public constant MANTISSA_MASK = (1<<27) - 1;\r\n    uint32 public constant MAX_MANTISSA = 9999_9999;\r\n    uint32 public constant MIN_MANTISSA = 1000_0000;\r\n    uint32 public constant MIN_PRICE = MIN_MANTISSA;\r\n    uint32 public constant MAX_PRICE = (31<<27)|MAX_MANTISSA;\r\n\r\n    // 10 ** (i + 1)\r\n    function powSmall(uint32 i) internal pure returns (uint) {\r\n        uint x = 2695994666777834996822029817977685892750687677375768584125520488993233305610;\r\n        return (x >> (32*i)) & ((1<<32)-1);\r\n    }\r\n\r\n    // 10 ** (i * 8)\r\n    function powBig(uint32 i) internal pure returns (uint) {\r\n        uint y = 3402823669209384634633746076162356521930955161600000001;\r\n        return (y >> (64*i)) & ((1<<64)-1);\r\n    }\r\n\r\n    // if price32=( 0<<27)|12345678 then numerator=12345678 denominator=100000000000000000000000\r\n    // if price32=( 1<<27)|12345678 then numerator=12345678 denominator=10000000000000000000000\r\n    // if price32=( 2<<27)|12345678 then numerator=12345678 denominator=1000000000000000000000\r\n    // if price32=( 3<<27)|12345678 then numerator=12345678 denominator=100000000000000000000\r\n    // if price32=( 4<<27)|12345678 then numerator=12345678 denominator=10000000000000000000\r\n    // if price32=( 5<<27)|12345678 then numerator=12345678 denominator=1000000000000000000\r\n    // if price32=( 6<<27)|12345678 then numerator=12345678 denominator=100000000000000000\r\n    // if price32=( 7<<27)|12345678 then numerator=12345678 denominator=10000000000000000\r\n    // if price32=( 8<<27)|12345678 then numerator=12345678 denominator=1000000000000000\r\n    // if price32=( 9<<27)|12345678 then numerator=12345678 denominator=100000000000000\r\n    // if price32=(10<<27)|12345678 then numerator=12345678 denominator=10000000000000\r\n    // if price32=(11<<27)|12345678 then numerator=12345678 denominator=1000000000000\r\n    // if price32=(12<<27)|12345678 then numerator=12345678 denominator=100000000000\r\n    // if price32=(13<<27)|12345678 then numerator=12345678 denominator=10000000000\r\n    // if price32=(14<<27)|12345678 then numerator=12345678 denominator=1000000000\r\n    // if price32=(15<<27)|12345678 then numerator=12345678 denominator=100000000\r\n    // if price32=(16<<27)|12345678 then numerator=12345678 denominator=10000000\r\n    // if price32=(17<<27)|12345678 then numerator=12345678 denominator=1000000\r\n    // if price32=(18<<27)|12345678 then numerator=12345678 denominator=100000\r\n    // if price32=(19<<27)|12345678 then numerator=12345678 denominator=10000\r\n    // if price32=(20<<27)|12345678 then numerator=12345678 denominator=1000\r\n    // if price32=(21<<27)|12345678 then numerator=12345678 denominator=100\r\n    // if price32=(22<<27)|12345678 then numerator=12345678 denominator=10\r\n    // if price32=(23<<27)|12345678 then numerator=12345678 denominator=1\r\n    // if price32=(24<<27)|12345678 then numerator=123456780 denominator=1\r\n    // if price32=(25<<27)|12345678 then numerator=1234567800 denominator=1\r\n    // if price32=(26<<27)|12345678 then numerator=12345678000 denominator=1\r\n    // if price32=(27<<27)|12345678 then numerator=123456780000 denominator=1\r\n    // if price32=(28<<27)|12345678 then numerator=1234567800000 denominator=1\r\n    // if price32=(29<<27)|12345678 then numerator=12345678000000 denominator=1\r\n    // if price32=(30<<27)|12345678 then numerator=123456780000000 denominator=1\r\n    // if price32=(31<<27)|12345678 then numerator=1234567800000000 denominator=1\r\n    function expandPrice(uint32 price32) internal pure returns (RatPrice memory) {\r\n        uint s = price32&((1<<27)-1);\r\n        uint32 a = price32 >> 27;\r\n        RatPrice memory price;\r\n        if(a >= 24) {\r\n            uint32 b = a - 24;\r\n            price.numerator = s * powSmall(b);\r\n            price.denominator = 1;\r\n        } else if(a == 23) {\r\n            price.numerator = s;\r\n            price.denominator = 1;\r\n        } else {\r\n            uint32 b = 22 - a;\r\n            price.numerator = s;\r\n            price.denominator = powSmall(b&0x7) * powBig(b>>3);\r\n        }\r\n        return price;\r\n    }\r\n\r\n    function getExpandPrice(uint price) internal pure returns(uint numerator, uint denominator) {\r\n        uint32 m = uint32(price) & MANTISSA_MASK;\r\n        require(MIN_MANTISSA <= m && m <= MAX_MANTISSA, \"Invalid Price\");\r\n        RatPrice memory actualPrice = expandPrice(uint32(price));\r\n        return (actualPrice.numerator, actualPrice.denominator);\r\n    }\r\n\r\n}\r\n\r\nlibrary ProxyData {\r\n    uint public constant COUNT = 5;\r\n    uint public constant INDEX_FACTORY = 0;\r\n    uint public constant INDEX_MONEY_TOKEN = 1;\r\n    uint public constant INDEX_STOCK_TOKEN = 2;\r\n    uint public constant INDEX_GRA = 3;\r\n    uint public constant INDEX_OTHER = 4;\r\n    uint public constant OFFSET_PRICE_DIV = 0;\r\n    uint public constant OFFSET_PRICE_MUL = 64;\r\n    uint public constant OFFSET_STOCK_UNIT = 64+64;\r\n    uint public constant OFFSET_IS_ONLY_SWAP = 64+64+64;\r\n\r\n    function factory(uint[5] memory proxyData) internal pure returns (address) {\r\n         return address(proxyData[INDEX_FACTORY]);\r\n    }\r\n\r\n    function money(uint[5] memory proxyData) internal pure returns (address) {\r\n         return address(proxyData[INDEX_MONEY_TOKEN]);\r\n    }\r\n\r\n    function stock(uint[5] memory proxyData) internal pure returns (address) {\r\n         return address(proxyData[INDEX_STOCK_TOKEN]);\r\n    }\r\n\r\n    function graContract(uint[5] memory proxyData) internal pure returns (address) {\r\n         return address(proxyData[INDEX_GRA]);\r\n    }\r\n\r\n    function priceMul(uint[5] memory proxyData) internal pure returns (uint64) {\r\n        return uint64(proxyData[INDEX_OTHER]>>OFFSET_PRICE_MUL);\r\n    }\r\n\r\n    function priceDiv(uint[5] memory proxyData) internal pure returns (uint64) {\r\n        return uint64(proxyData[INDEX_OTHER]>>OFFSET_PRICE_DIV);\r\n    }\r\n\r\n    function stockUnit(uint[5] memory proxyData) internal pure returns (uint64) {\r\n        return uint64(proxyData[INDEX_OTHER]>>OFFSET_STOCK_UNIT);\r\n    }\r\n\r\n    function isOnlySwap(uint[5] memory proxyData) internal pure returns (bool) {\r\n        return uint8(proxyData[INDEX_OTHER]>>OFFSET_IS_ONLY_SWAP) != 0;\r\n    }\r\n\r\n    function fill(uint[5] memory proxyData, uint expectedCallDataSize) internal pure {\r\n        uint size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := calldatasize()\r\n        }\r\n        require(size == expectedCallDataSize, \"INVALID_CALLDATASIZE\");\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let offset := sub(size, 160)\r\n            calldatacopy(proxyData, offset, 160)\r\n        }\r\n    }\r\n}\r\n\r\ninterface IGraSwapFactory {\r\n    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\r\n\r\n    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\r\n    function setFeeToAddresses(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setFeeBPS(uint32 bps) external;\r\n    function setPairLogic(address implLogic) external;\r\n\r\n    function allPairsLength() external view returns (uint);\r\n    function feeTo_1() external view returns (address);\r\n    function feeTo_2() external view returns (address);\r\n    function feeToPrivate() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function feeBPS() external view returns (uint32);\r\n    function pairLogic() external returns (address);\r\n    function getTokensFromPair(address pair) external view returns (address stock, address money);\r\n    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IGraSwapBlackList {\r\n    // event OwnerChanged(address);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event AddedBlackLists(address[]);\r\n    event RemovedBlackLists(address[]);\r\n\r\n    function owner()external view returns (address);\r\n    // function newOwner()external view returns (address);\r\n    function isBlackListed(address)external view returns (bool);\r\n\r\n    // function changeOwner(address ownerToSet) external;\r\n    // function updateOwner() external;\r\n    function transferOwnership(address newOwner) external;\r\n    function addBlackLists(address[] calldata  accounts)external;\r\n    function removeBlackLists(address[] calldata  accounts)external;\r\n}\r\n\r\ninterface IGraWhiteList {\r\n    event AppendWhiter(address adder);\r\n    event RemoveWhiter(address remover);\r\n    \r\n    function appendWhiter(address account) external;\r\n    function removeWhiter(address account) external;\r\n    function isWhiter(address account) external;\r\n    function isNotWhiter(address account) external;\r\n}\r\n\r\ninterface IGraSwapToken is IERC20, IGraSwapBlackList{\r\n    function burn(uint256 amount) external;\r\n    function burnFrom(address account, uint256 amount) external;\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    // function multiTransfer(uint256[] calldata mixedAddrVal) external returns (bool);\r\n    function batchTransfer(address[] memory addressList, uint256[] memory amountList) external returns (bool);\r\n}\r\n\r\ninterface IGraSwapERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IGraSwapPool {\r\n    // more liquidity was minted\r\n    event Mint(address indexed sender, uint stockAndMoneyAmount, address indexed to);\r\n    // liquidity was burned\r\n    event Burn(address indexed sender, uint stockAndMoneyAmount, address indexed to);\r\n    // amounts of reserved stock and money in this pair changed\r\n    event Sync(uint reserveStockAndMoney);\r\n\r\n    function internalStatus() external view returns(uint[3] memory res);\r\n    function getReserves() external view returns (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID);\r\n    function getBooked() external view returns (uint112 bookedStock, uint112 bookedMoney, uint32 firstBuyID);\r\n    function stock() external returns (address);\r\n    function money() external returns (address);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint stockAmount, uint moneyAmount);\r\n    function skim(address to) external;\r\n    function sync() external;\r\n}\r\n\r\ninterface IGraSwapPair {\r\n    event NewLimitOrder(uint data); // new limit order was sent by an account\r\n    event NewMarketOrder(uint data); // new market order was sent by an account\r\n    event OrderChanged(uint data); // old orders in orderbook changed\r\n    event DealWithPool(uint data); // new order deal with the AMM pool\r\n    event RemoveOrder(uint data); // an order was removed from the orderbook\r\n    \r\n    // Return three prices in rational number form, i.e., numerator/denominator.\r\n    // They are: the first sell order's price; the first buy order's price; the current price of the AMM pool.\r\n    function getPrices() external returns (\r\n        uint firstSellPriceNumerator,\r\n        uint firstSellPriceDenominator,\r\n        uint firstBuyPriceNumerator,\r\n        uint firstBuyPriceDenominator,\r\n        uint poolPriceNumerator,\r\n        uint poolPriceDenominator);\r\n\r\n    // This function queries a list of orders in orderbook. It starts from 'id' and iterates the single-linked list, util it reaches the end, \r\n    // or until it has found 'maxCount' orders. If 'id' is 0, it starts from the beginning of the single-linked list.\r\n    // It may cost a lot of gas. So you'd not to call in on chain. It is mainly for off-chain query.\r\n    // The first uint256 returned by this function is special: the lowest 24 bits is the first order's id and the the higher bits is block height.\r\n    // THe other uint256s are all corresponding to an order record of the single-linked list.\r\n    function getOrderList(bool isBuy, uint32 id, uint32 maxCount) external view returns (uint[] memory);\r\n\r\n    // remove an order from orderbook and return its booked (i.e. frozen) money to maker\r\n    // 'id' points to the order to be removed\r\n    // prevKey points to 3 previous orders in the single-linked list\r\n    function removeOrder(bool isBuy, uint32 id, uint72 positionID) external;\r\n\r\n    function removeOrders(uint[] calldata rmList) external;\r\n\r\n    // Try to deal a new limit order or insert it into orderbook\r\n    // its suggested order id is 'id' and suggested positions are in 'prevKey'\r\n    // prevKey points to 3 existing orders in the single-linked list\r\n    // the order's sender is 'sender'. the order's amount is amount*stockUnit, which is the stock amount to be sold or bought.\r\n    // the order's price is 'price32', which is decimal floating point value.\r\n    function addLimitOrder(bool isBuy, address sender, uint64 amount, uint32 price32, uint32 id, uint72 prevKey) external payable;\r\n\r\n    // Try to deal a new market order. 'sender' pays 'inAmount' of 'inputToken', in exchange of the other token kept by this pair\r\n    function addMarketOrder(address inputToken, address sender, uint112 inAmount) external payable returns (uint);\r\n\r\n    // Given the 'amount' of stock and decimal floating point price 'price32', calculate the 'stockAmount' and 'moneyAmount' to be traded\r\n    function calcStockAndMoney(uint64 amount, uint32 price32) external pure returns (uint stockAmount, uint moneyAmount);\r\n}\r\n\r\nabstract contract GraSwapERC20 is IGraSwapERC20 {\r\n    using SafeMath256 for uint;\r\n\r\n    uint internal _unusedVar0;\r\n    uint internal _unusedVar1;\r\n    uint internal _unusedVar2;\r\n    uint internal _unusedVar3;\r\n    uint internal _unusedVar4;\r\n    uint internal _unusedVar5;\r\n    uint internal _unusedVar6;\r\n    uint internal _unusedVar7;\r\n    uint internal _unusedVar8;\r\n    uint internal _unusedVar9;\r\n    uint internal _unlocked = 1;\r\n\r\n    modifier lock() {\r\n        require(_unlocked == 1, \"GraSwap: LOCKED\");\r\n        _unlocked = 0;\r\n        _;\r\n        _unlocked = 1;\r\n    }\r\n\r\n    string private constant _NAME = \"GraSwap-Share\";\r\n    uint8 private constant _DECIMALS = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    function symbol() virtual external override returns (string memory);\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _NAME;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return _DECIMALS;\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != uint(- 1)) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n}\r\n\r\n// An order can be compressed into 256 bits and saved using one SSTORE instruction\r\n// The orders form a single-linked list. The preceding order points to the following order with nextID\r\nstruct Order { //total 256 bits\r\n    address sender; //160 bits, sender creates this order\r\n    uint32 price; // 32-bit decimal floating point number\r\n    uint64 amount; // 42 bits are used, the stock amount to be sold or bought\r\n    uint32 nextID; // 22 bits are used\r\n}\r\n\r\n// When the match engine of orderbook runs, it uses follow context to cache data in memory\r\nstruct Context {\r\n    // this order is a limit order\r\n    bool isLimitOrder;\r\n    // the new order's id, it is only used when a limit order is not fully dealt\r\n    uint32 newOrderID;\r\n    // for buy-order, it's remained money amount; for sell-order, it's remained stock amount\r\n    uint remainAmount;\r\n    // it points to the first order in the opposite order book against current order\r\n    uint32 firstID;\r\n    // it points to the first order in the buy-order book\r\n    uint32 firstBuyID;\r\n    // it points to the first order in the sell-order book\r\n    uint32 firstSellID;\r\n    // the amount goes into the pool, for buy-order, it's money amount; for sell-order, it's stock amount\r\n    uint amountIntoPool;\r\n    // the total dealt money and stock in the order book\r\n    uint dealMoneyInBook;\r\n    uint dealStockInBook;\r\n    // cache these values from storage to memory\r\n    uint reserveMoney;\r\n    uint reserveStock;\r\n    uint bookedMoney;\r\n    uint bookedStock;\r\n    // reserveMoney or reserveStock is changed\r\n    bool reserveChanged;\r\n    // the taker has dealt in the orderbook\r\n    bool hasDealtInOrderBook;\r\n    // the current taker order\r\n    Order order;\r\n    // the following data come from proxy\r\n    uint64 stockUnit;\r\n    uint64 priceMul;\r\n    uint64 priceDiv;\r\n    address stockToken;\r\n    address moneyToken;\r\n    address graContract;\r\n    address factory;\r\n}\r\n\r\n// GraSwapPair combines a Uniswap-like AMM and an orderbook\r\nabstract contract GraSwapPool is GraSwapERC20, IGraSwapPool {\r\n    using SafeMath256 for uint;\r\n\r\n    uint private constant _MINIMUM_LIQUIDITY = 10 ** 3;\r\n    bytes4 internal constant _SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n\r\n    // reserveMoney and reserveStock are both uint112, id is 22 bits; they are compressed into a uint256 word\r\n    uint internal _reserveStockAndMoneyAndFirstSellID;\r\n    // bookedMoney and bookedStock are both uint112, id is 22 bits; they are compressed into a uint256 word\r\n    uint internal _bookedStockAndMoneyAndFirstBuyID;\r\n\r\n    uint private _kLast;\r\n\r\n    uint32 private constant _OS = 2; // owner's share\r\n    uint32 private constant _LS = 3; // liquidity-provider's share\r\n\r\n    function internalStatus() external override view returns(uint[3] memory res) {\r\n        res[0] = _reserveStockAndMoneyAndFirstSellID;\r\n        res[1] = _bookedStockAndMoneyAndFirstBuyID;\r\n        res[2] = _kLast;\r\n    }\r\n\r\n    function stock() external override returns (address) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\r\n        return ProxyData.stock(proxyData);\r\n    }\r\n\r\n    function money() external override returns (address) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\r\n        return ProxyData.money(proxyData);\r\n    }\r\n\r\n    // the following 4 functions load&store compressed storage\r\n    function getReserves() public override view returns (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) {\r\n        uint temp = _reserveStockAndMoneyAndFirstSellID;\r\n        reserveStock = uint112(temp);\r\n        reserveMoney = uint112(temp>>112);\r\n        firstSellID = uint32(temp>>224);\r\n    }\r\n    function _setReserves(uint stockAmount, uint moneyAmount, uint32 firstSellID) internal {\r\n        require(stockAmount < uint(1<<112) && moneyAmount < uint(1<<112), \"GraSwap: OVERFLOW\");\r\n        uint temp = (moneyAmount<<112)|stockAmount;\r\n        emit Sync(temp);\r\n        temp = (uint(firstSellID)<<224)| temp;\r\n        _reserveStockAndMoneyAndFirstSellID = temp;\r\n    }\r\n    function getBooked() public override view returns (uint112 bookedStock, uint112 bookedMoney, uint32 firstBuyID) {\r\n        uint temp = _bookedStockAndMoneyAndFirstBuyID;\r\n        bookedStock = uint112(temp);\r\n        bookedMoney = uint112(temp>>112);\r\n        firstBuyID = uint32(temp>>224);\r\n    }\r\n    function _setBooked(uint stockAmount, uint moneyAmount, uint32 firstBuyID) internal {\r\n        require(stockAmount < uint(1<<112) && moneyAmount < uint(1<<112), \"GraSwap: OVERFLOW\");\r\n        _bookedStockAndMoneyAndFirstBuyID = (uint(firstBuyID)<<224)|(moneyAmount<<112)|stockAmount;\r\n    }\r\n\r\n    function _myBalance(address token) internal view returns (uint) {\r\n        if(token==address(0)) {\r\n            return address(this).balance;\r\n        } else {\r\n            return IERC20(token).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    // safely transfer ERC20 tokens, or ETH (when token==0)\r\n    function _safeTransfer(address token, address to, uint value, address graContract) internal {\r\n        if(value==0) {return;}\r\n        if(token==address(0)) {\r\n            // limit gas to 9000 to prevent gastoken attacks\r\n            // solhint-disable-next-line avoid-low-level-calls \r\n            to.call{value: value, gas: 9000}(new bytes(0)); //we ignore its return value purposely\r\n            return;\r\n        }\r\n        // solhint-disable-next-line avoid-low-level-calls \r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR, to, value));\r\n        success = success && (data.length == 0 || abi.decode(data, (bool)));\r\n        if(!success) { // for failsafe\r\n            address graContractOwner = IGraSwapToken(graContract).owner();\r\n            // solhint-disable-next-line avoid-low-level-calls \r\n            (success, data) = token.call(abi.encodeWithSelector(_SELECTOR, graContractOwner, value));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), \"GraSwap: TRANSFER_FAILED\");\r\n        }\r\n    }\r\n\r\n    // Give feeToAddresses some liquidity tokens if K got increased since last liquidity-changing\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1, uint[5] memory proxyData) private returns (bool feeOn) {\r\n        address feeTo_1 = IGraSwapFactory(ProxyData.factory(proxyData)).feeTo_1();\r\n        address feeTo_2 = IGraSwapFactory(ProxyData.factory(proxyData)).feeTo_2();\r\n        address feeToPrivate = IGraSwapFactory(ProxyData.factory(proxyData)).feeToPrivate();\r\n        feeOn = (feeTo_1 != address(0) && feeTo_2 != address(0) && feeToPrivate != address(0));\r\n        uint kLast = _kLast;\r\n        // gas savings to use cached kLast\r\n        if (feeOn) {\r\n            if (kLast != 0) {\r\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\r\n                uint rootKLast = Math.sqrt(kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast)).mul(_OS);\r\n                    uint denominator = rootK.mul(_LS).add(rootKLast.mul(_OS));\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) {\r\n                        uint liquidity_p1 = liquidity.div(4); // 10%  \r\n                        uint liquidity_p2 = liquidity.div(8); // 5%\r\n                        uint liquidity_p3 = liquidity.mul(5).div(8); // 25%\r\n                        if (liquidity_p1 > 0) {\r\n                            _mint(feeTo_1, liquidity_p1);\r\n                        }\r\n                        if (liquidity_p2 > 0) {\r\n                            _mint(feeTo_2, liquidity_p2);\r\n                        }\r\n                        if (liquidity_p2 > 0) {\r\n                            _mint(feeToPrivate, liquidity_p3);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (kLast != 0) {\r\n            _kLast = 0;\r\n        }\r\n    }\r\n\r\n    // mint new liquidity tokens to 'to'\r\n    function mint(address to) external override lock returns (uint liquidity) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+1));\r\n        (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) = getReserves();\r\n        (uint112 bookedStock, uint112 bookedMoney, ) = getBooked();\r\n        uint stockBalance = _myBalance(ProxyData.stock(proxyData));\r\n        uint moneyBalance = _myBalance(ProxyData.money(proxyData));\r\n        require(stockBalance >= uint(bookedStock) + uint(reserveStock) &&\r\n                moneyBalance >= uint(bookedMoney) + uint(reserveMoney), \"GraSwap: INVALID_BALANCE\");\r\n        stockBalance -= uint(bookedStock);\r\n        moneyBalance -= uint(bookedMoney);\r\n        uint stockAmount = stockBalance - uint(reserveStock);\r\n        uint moneyAmount = moneyBalance - uint(reserveMoney);\r\n\r\n        bool feeOn = _mintFee(reserveStock, reserveMoney, proxyData);\r\n        uint _totalSupply = totalSupply;\r\n        // gas savings by caching totalSupply in memory,\r\n        // must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(stockAmount.mul(moneyAmount)).sub(_MINIMUM_LIQUIDITY);\r\n            _mint(address(0), _MINIMUM_LIQUIDITY);\r\n            // permanently lock the first _MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(stockAmount.mul(_totalSupply) / uint(reserveStock),\r\n                                 moneyAmount.mul(_totalSupply) / uint(reserveMoney));\r\n        }\r\n        require(liquidity > 0, \"GraSwap: INSUFFICIENT_MINTED\");\r\n        _mint(to, liquidity);\r\n\r\n        _setReserves(stockBalance, moneyBalance, firstSellID);\r\n        if (feeOn) _kLast = stockBalance.mul(moneyBalance);\r\n        emit Mint(msg.sender, (moneyAmount<<112)|stockAmount, to);\r\n    }\r\n\r\n    // burn liquidity tokens and send stock&money to 'to'\r\n    function burn(address to) external override lock returns (uint stockAmount, uint moneyAmount) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+1));\r\n        (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) = getReserves();\r\n        (uint bookedStock, uint bookedMoney, ) = getBooked();\r\n        uint stockBalance = _myBalance(ProxyData.stock(proxyData)).sub(bookedStock);\r\n        uint moneyBalance = _myBalance(ProxyData.money(proxyData)).sub(bookedMoney);\r\n        require(stockBalance >= uint(reserveStock) && moneyBalance >= uint(reserveMoney), \"GraSwap: INVALID_BALANCE\");\r\n\r\n        bool feeOn = _mintFee(reserveStock, reserveMoney, proxyData);\r\n        {\r\n            uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n            uint liquidity = balanceOf[address(this)]; // we're sure liquidity < totalSupply\r\n            stockAmount = liquidity.mul(stockBalance) / _totalSupply;\r\n            moneyAmount = liquidity.mul(moneyBalance) / _totalSupply;\r\n            require(stockAmount > 0 && moneyAmount > 0, \"GraSwap: INSUFFICIENT_BURNED\");\r\n\r\n            //_burn(address(this), liquidity);\r\n            balanceOf[address(this)] = 0;\r\n            totalSupply = totalSupply.sub(liquidity);\r\n            emit Transfer(address(this), address(0), liquidity);\r\n        }\r\n\r\n        address graContract = ProxyData.graContract(proxyData);\r\n        _safeTransfer(ProxyData.stock(proxyData), to, stockAmount, graContract);\r\n        _safeTransfer(ProxyData.money(proxyData), to, moneyAmount, graContract);\r\n\r\n        stockBalance = stockBalance - stockAmount;\r\n        moneyBalance = moneyBalance - moneyAmount;\r\n\r\n        _setReserves(stockBalance, moneyBalance, firstSellID);\r\n        if (feeOn) _kLast = stockBalance.mul(moneyBalance);\r\n        emit Burn(msg.sender, (moneyAmount<<112)|stockAmount, to);\r\n    }\r\n\r\n    // take the extra money&stock in this pair to 'to'\r\n    function skim(address to) external override lock {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+1));\r\n        address stockToken = ProxyData.stock(proxyData);\r\n        address moneyToken = ProxyData.money(proxyData);\r\n        (uint112 reserveStock, uint112 reserveMoney, ) = getReserves();\r\n        (uint bookedStock, uint bookedMoney, ) = getBooked();\r\n        uint balanceStock = _myBalance(stockToken);\r\n        uint balanceMoney = _myBalance(moneyToken);\r\n        require(balanceStock >= uint(bookedStock) + uint(reserveStock) &&\r\n                balanceMoney >= uint(bookedMoney) + uint(reserveMoney), \"GraSwap: INVALID_BALANCE\");\r\n        address graContract = ProxyData.graContract(proxyData);\r\n        _safeTransfer(stockToken, to, balanceStock-reserveStock-bookedStock, graContract);\r\n        _safeTransfer(moneyToken, to, balanceMoney-reserveMoney-bookedMoney, graContract);\r\n    }\r\n\r\n    // sync-up reserve stock&money in pool according to real balance\r\n    function sync() external override lock {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\r\n        (, , uint32 firstSellID) = getReserves();\r\n        (uint bookedStock, uint bookedMoney, ) = getBooked();\r\n        uint balanceStock = _myBalance(ProxyData.stock(proxyData));\r\n        uint balanceMoney = _myBalance(ProxyData.money(proxyData));\r\n        require(balanceStock >= bookedStock && balanceMoney >= bookedMoney, \"GraSwap: INVALID_BALANCE\");\r\n        _setReserves(balanceStock-bookedStock, balanceMoney-bookedMoney, firstSellID);\r\n    }\r\n\r\n}\r\n\r\ncontract GraSwapPair is GraSwapPool, IGraSwapPair {\r\n    // the orderbooks. Gas is saved when using array to store them instead of mapping\r\n    uint[1<<22] private _sellOrders;\r\n    uint[1<<22] private _buyOrders;\r\n\r\n    uint32 private constant _MAX_ID = (1<<22)-1; // the maximum value of an order ID\r\n\r\n    function _expandPrice(uint32 price32, uint[5] memory proxyData) private pure returns (RatPrice memory price) {\r\n        price = DecFloat32.expandPrice(price32);\r\n        price.numerator *= ProxyData.priceMul(proxyData);\r\n        price.denominator *= ProxyData.priceDiv(proxyData);\r\n    }\r\n\r\n    function _expandPrice(Context memory ctx, uint32 price32) private pure returns (RatPrice memory price) {\r\n        price = DecFloat32.expandPrice(price32);\r\n        price.numerator *= ctx.priceMul;\r\n        price.denominator *= ctx.priceDiv;\r\n    }\r\n\r\n    function symbol() external override returns (string memory) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\r\n        string memory s = \"ETH\";\r\n        address stock = ProxyData.stock(proxyData);\r\n        if(stock != address(0)) {\r\n            s = IERC20(stock).symbol();\r\n        }\r\n        string memory m = \"ETH\";\r\n        address money = ProxyData.money(proxyData);\r\n        if(money != address(0)) {\r\n            m = IERC20(money).symbol();\r\n        }\r\n        return string(abi.encodePacked(s, \"/\", m));  //to concat strings\r\n    }\r\n\r\n    // when emitting events, solidity's ABI pads each entry to uint256, which is so wasteful\r\n    // we compress the entries into one uint256 to save gas\r\n    function _emitNewLimitOrder(\r\n        uint64 addressLow, /*255~192*/\r\n        uint64 totalStockAmount, /*191~128*/\r\n        uint64 remainedStockAmount, /*127~64*/\r\n        uint32 price, /*63~32*/\r\n        uint32 orderID, /*31~8*/\r\n        bool isBuy /*7~0*/) private {\r\n        uint data = uint(addressLow);\r\n        data = (data<<64) | uint(totalStockAmount);\r\n        data = (data<<64) | uint(remainedStockAmount);\r\n        data = (data<<32) | uint(price);\r\n        data = (data<<32) | uint(orderID<<8);\r\n        if(isBuy) {\r\n            data = data | 1;\r\n        }\r\n        emit NewLimitOrder(data);\r\n    }\r\n    function _emitNewMarketOrder(\r\n        uint136 addressLow, /*255~120*/\r\n        uint112 amount, /*119~8*/\r\n        bool isBuy /*7~0*/) private {\r\n        uint data = uint(addressLow);\r\n        data = (data<<112) | uint(amount);\r\n        data = data<<8;\r\n        if(isBuy) {\r\n            data = data | 1;\r\n        }\r\n        emit NewMarketOrder(data);\r\n    }\r\n    function _emitOrderChanged(\r\n        uint64 makerLastAmount, /*159~96*/\r\n        uint64 makerDealAmount, /*95~32*/\r\n        uint32 makerOrderID, /*31~8*/\r\n        bool isBuy /*7~0*/) private {\r\n        uint data = uint(makerLastAmount);\r\n        data = (data<<64) | uint(makerDealAmount);\r\n        data = (data<<32) | uint(makerOrderID<<8);\r\n        if(isBuy) {\r\n            data = data | 1;\r\n        }\r\n        emit OrderChanged(data);\r\n    }\r\n    function _emitDealWithPool(\r\n        uint112 inAmount, /*131~120*/\r\n        uint112 outAmount,/*119~8*/\r\n        bool isBuy/*7~0*/) private {\r\n        uint data = uint(inAmount);\r\n        data = (data<<112) | uint(outAmount);\r\n        data = data<<8;\r\n        if(isBuy) {\r\n            data = data | 1;\r\n        }\r\n        emit DealWithPool(data);\r\n    }\r\n    function _emitRemoveOrder(\r\n        uint64 remainStockAmount, /*95~32*/\r\n        uint32 orderID, /*31~8*/\r\n        bool isBuy /*7~0*/) private {\r\n        uint data = uint(remainStockAmount);\r\n        data = (data<<32) | uint(orderID<<8);\r\n        if(isBuy) {\r\n            data = data | 1;\r\n        }\r\n        emit RemoveOrder(data);\r\n    }\r\n\r\n    // compress an order into a 256b integer\r\n    function _order2uint(Order memory order) internal pure returns (uint) {\r\n        uint n = uint(order.sender);\r\n        n = (n<<32) | order.price;\r\n        n = (n<<42) | order.amount;\r\n        n = (n<<22) | order.nextID;\r\n        return n;\r\n    }\r\n\r\n    // extract an order from a 256b integer\r\n    function _uint2order(uint n) internal pure returns (Order memory) {\r\n        Order memory order;\r\n        order.nextID = uint32(n & ((1<<22)-1));\r\n        n = n >> 22;\r\n        order.amount = uint64(n & ((1<<42)-1));\r\n        n = n >> 42;\r\n        order.price = uint32(n & ((1<<32)-1));\r\n        n = n >> 32;\r\n        order.sender = address(n);\r\n        return order;\r\n    }\r\n\r\n    // returns true if this order exists\r\n    function _hasOrder(bool isBuy, uint32 id) internal view returns (bool) {\r\n        if(isBuy) {\r\n            return _buyOrders[id] != 0;\r\n        } else {\r\n            return _sellOrders[id] != 0;\r\n        }\r\n    }\r\n\r\n    // load an order from storage, converting its compressed form into an Order struct\r\n    function _getOrder(bool isBuy, uint32 id) internal view returns (Order memory order, bool findIt) {\r\n        if(isBuy) {\r\n            order = _uint2order(_buyOrders[id]);\r\n            return (order, order.price != 0);\r\n        } else {\r\n            order = _uint2order(_sellOrders[id]);\r\n            return (order, order.price != 0);\r\n        }\r\n    }\r\n\r\n    // save an order to storage, converting it into compressed form\r\n    function _setOrder(bool isBuy, uint32 id, Order memory order) internal {\r\n        if(isBuy) {\r\n            _buyOrders[id] = _order2uint(order);\r\n        } else {\r\n            _sellOrders[id] = _order2uint(order);\r\n        }\r\n    }\r\n\r\n    // delete an order from storage\r\n    function _deleteOrder(bool isBuy, uint32 id) internal {\r\n        if(isBuy) {\r\n            delete _buyOrders[id];\r\n        } else {\r\n            delete _sellOrders[id];\r\n        }\r\n    }\r\n\r\n    function _getFirstOrderID(Context memory ctx, bool isBuy) internal pure returns (uint32) {\r\n        if(isBuy) {\r\n            return ctx.firstBuyID;\r\n        }\r\n        return ctx.firstSellID;\r\n    }\r\n\r\n    function _setFirstOrderID(Context memory ctx, bool isBuy, uint32 id) internal pure {\r\n        if(isBuy) {\r\n            ctx.firstBuyID = id;\r\n        } else {\r\n            ctx.firstSellID = id;\r\n        }\r\n    }\r\n\r\n    function removeOrders(uint[] calldata rmList) external override lock {\r\n        uint[5] memory proxyData;\r\n        uint expectedCallDataSize = 4+32*(ProxyData.COUNT+2+rmList.length);\r\n        ProxyData.fill(proxyData, expectedCallDataSize);\r\n        for(uint i = 0; i < rmList.length; i++) {\r\n            uint rmInfo = rmList[i];\r\n            bool isBuy = uint8(rmInfo) != 0;\r\n            uint32 id = uint32(rmInfo>>8);\r\n            uint72 prevKey = uint72(rmInfo>>40);\r\n            _removeOrder(isBuy, id, prevKey, proxyData);\r\n        }\r\n    }\r\n\r\n    function removeOrder(bool isBuy, uint32 id, uint72 prevKey) external override lock {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+3));\r\n        _removeOrder(isBuy, id, prevKey, proxyData);\r\n    }\r\n\r\n    function _removeOrder(bool isBuy, uint32 id, uint72 prevKey, uint[5] memory proxyData) private {\r\n        Context memory ctx;\r\n        (ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID) = getBooked();\r\n        if(!isBuy) {\r\n            (ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID) = getReserves();\r\n        }\r\n        Order memory order = _removeOrderFromBook(ctx, isBuy, id, prevKey); // this is the removed order\r\n        require(msg.sender == order.sender, \"GraSwap: NOT_OWNER\");\r\n        uint64 stockUnit = ProxyData.stockUnit(proxyData);\r\n        uint stockAmount = uint(order.amount)/*42bits*/ * uint(stockUnit);\r\n        address graContract = ProxyData.graContract(proxyData);\r\n        if(isBuy) {\r\n            RatPrice memory price = _expandPrice(order.price, proxyData);\r\n            uint moneyAmount = stockAmount * price.numerator/*54+64bits*/ / price.denominator;\r\n            ctx.bookedMoney -= moneyAmount;\r\n            _safeTransfer(ProxyData.money(proxyData), order.sender, moneyAmount, graContract);\r\n        } else {\r\n            ctx.bookedStock -= stockAmount;\r\n            _safeTransfer(ProxyData.stock(proxyData), order.sender, stockAmount, graContract);\r\n        }\r\n        _setBooked(ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID);\r\n    }\r\n\r\n    // remove an order from orderbook and return it\r\n    function _removeOrderFromBook(Context memory ctx, bool isBuy,\r\n                                 uint32 id, uint72 prevKey) internal returns (Order memory) {\r\n        (Order memory order, bool ok) = _getOrder(isBuy, id);\r\n        require(ok, \"GraSwap: NO_SUCH_ORDER\");\r\n        if(prevKey == 0) {\r\n            uint32 firstID = _getFirstOrderID(ctx, isBuy);\r\n            require(id == firstID, \"GraSwap: NOT_FIRST\");\r\n            _setFirstOrderID(ctx, isBuy, order.nextID);\r\n            if(!isBuy) {\r\n                _setReserves(ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID);\r\n            }\r\n        } else {\r\n            (uint32 currID, Order memory prevOrder, bool findIt) = _getOrder3Times(isBuy, prevKey);\r\n            require(findIt, \"GraSwap: INVALID_POSITION\");\r\n            while(prevOrder.nextID != id) {\r\n                currID = prevOrder.nextID;\r\n                require(currID != 0, \"GraSwap: REACH_END\");\r\n                (prevOrder, ) = _getOrder(isBuy, currID);\r\n            }\r\n            prevOrder.nextID = order.nextID;\r\n            _setOrder(isBuy, currID, prevOrder);\r\n        }\r\n        _emitRemoveOrder(order.amount, id, isBuy);\r\n        _deleteOrder(isBuy, id);\r\n        return order;\r\n    }\r\n\r\n    // insert an order at the head of single-linked list\r\n    // this function does not check price, use it carefully\r\n    function _insertOrderAtHead(Context memory ctx, bool isBuy, Order memory order, uint32 id) private {\r\n        order.nextID = _getFirstOrderID(ctx, isBuy);\r\n        _setOrder(isBuy, id, order);\r\n        _setFirstOrderID(ctx, isBuy, id);\r\n    }\r\n\r\n    // prevKey contains 3 orders. try to get the first existing order\r\n    function _getOrder3Times(bool isBuy, uint72 prevKey) private view returns (\r\n        uint32 currID, Order memory prevOrder, bool findIt) {\r\n        currID = uint32(prevKey&_MAX_ID);\r\n        (prevOrder, findIt) = _getOrder(isBuy, currID);\r\n        if(!findIt) {\r\n            currID = uint32((prevKey>>24)&_MAX_ID);\r\n            (prevOrder, findIt) = _getOrder(isBuy, currID);\r\n            if(!findIt) {\r\n                currID = uint32((prevKey>>48)&_MAX_ID);\r\n                (prevOrder, findIt) = _getOrder(isBuy, currID);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Given a valid start position, find a proper position to insert order\r\n    // prevKey contains three suggested order IDs, each takes 24 bits.\r\n    // We try them one by one to find a valid start position\r\n    // can not use this function to insert at head! if prevKey is all zero, it will return false\r\n    function _insertOrderFromGivenPos(bool isBuy, Order memory order,\r\n                                     uint32 id, uint72 prevKey) private returns (bool inserted) {\r\n        (uint32 currID, Order memory prevOrder, bool findIt) = _getOrder3Times(isBuy, prevKey);\r\n        if(!findIt) {\r\n            return false;\r\n        }\r\n        return _insertOrder(isBuy, order, prevOrder, id, currID);\r\n    }\r\n    \r\n    // Starting from the head of orderbook, find a proper position to insert order\r\n    function _insertOrderFromHead(Context memory ctx, bool isBuy, Order memory order,\r\n                                 uint32 id) private returns (bool inserted) {\r\n        uint32 firstID = _getFirstOrderID(ctx, isBuy);\r\n        bool canBeFirst = (firstID == 0);\r\n        Order memory firstOrder;\r\n        if(!canBeFirst) {\r\n            (firstOrder, ) = _getOrder(isBuy, firstID);\r\n            canBeFirst = (isBuy && (firstOrder.price < order.price)) ||\r\n                (!isBuy && (firstOrder.price > order.price));\r\n        }\r\n        if(canBeFirst) {\r\n            order.nextID = firstID;\r\n            _setOrder(isBuy, id, order);\r\n            _setFirstOrderID(ctx, isBuy, id);\r\n            return true;\r\n        }\r\n        return _insertOrder(isBuy, order, firstOrder, id, firstID);\r\n    }\r\n\r\n    // starting from 'prevOrder', whose id is 'currID', find a proper position to insert order\r\n    function _insertOrder(bool isBuy, Order memory order, Order memory prevOrder,\r\n                         uint32 id, uint32 currID) private returns (bool inserted) {\r\n        while(currID != 0) {\r\n            bool canFollow = (isBuy && (order.price <= prevOrder.price)) ||\r\n                (!isBuy && (order.price >= prevOrder.price));\r\n            if(!canFollow) {break;} \r\n            Order memory nextOrder;\r\n            if(prevOrder.nextID != 0) {\r\n                (nextOrder, ) = _getOrder(isBuy, prevOrder.nextID);\r\n                bool canPrecede = (isBuy && (nextOrder.price < order.price)) ||\r\n                    (!isBuy && (nextOrder.price > order.price));\r\n                canFollow = canFollow && canPrecede;\r\n            }\r\n            if(canFollow) {\r\n                order.nextID = prevOrder.nextID;\r\n                _setOrder(isBuy, id, order);\r\n                prevOrder.nextID = id;\r\n                _setOrder(isBuy, currID, prevOrder);\r\n                return true;\r\n            }\r\n            currID = prevOrder.nextID;\r\n            prevOrder = nextOrder;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // to query the first sell price, the first buy price and the price of pool\r\n    function getPrices() external override returns (\r\n        uint firstSellPriceNumerator,\r\n        uint firstSellPriceDenominator,\r\n        uint firstBuyPriceNumerator,\r\n        uint firstBuyPriceDenominator,\r\n        uint poolPriceNumerator,\r\n        uint poolPriceDenominator) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\r\n        (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) = getReserves();\r\n        poolPriceNumerator = uint(reserveMoney);\r\n        poolPriceDenominator = uint(reserveStock);\r\n        firstSellPriceNumerator = 0;\r\n        firstSellPriceDenominator = 0;\r\n        firstBuyPriceNumerator = 0;\r\n        firstBuyPriceDenominator = 0;\r\n        if(firstSellID!=0) {\r\n            uint order = _sellOrders[firstSellID];\r\n            RatPrice memory price = _expandPrice(uint32(order>>64), proxyData);\r\n            firstSellPriceNumerator = price.numerator;\r\n            firstSellPriceDenominator = price.denominator;\r\n        }\r\n        uint32 id = uint32(_bookedStockAndMoneyAndFirstBuyID>>224);\r\n        if(id!=0) {\r\n            uint order = _buyOrders[id];\r\n            RatPrice memory price = _expandPrice(uint32(order>>64), proxyData);\r\n            firstBuyPriceNumerator = price.numerator;\r\n            firstBuyPriceDenominator = price.denominator;\r\n        }\r\n    }\r\n\r\n    // Get the orderbook's content, starting from id, to get no more than maxCount orders\r\n    function getOrderList(bool isBuy, uint32 id, uint32 maxCount) external override view returns (uint[] memory) {\r\n        if(id == 0) {\r\n            if(isBuy) {\r\n                id = uint32(_bookedStockAndMoneyAndFirstBuyID>>224);\r\n            } else {\r\n                id = uint32(_reserveStockAndMoneyAndFirstSellID>>224);\r\n            }\r\n        }\r\n        uint[1<<22] storage orderbook;\r\n        if(isBuy) {\r\n            orderbook = _buyOrders;\r\n        } else {\r\n            orderbook = _sellOrders;\r\n        }\r\n        //record block height at the first entry\r\n        uint order = (block.number<<24) | id;\r\n        uint addrOrig; // start of returned data\r\n        uint addrLen; // the slice's length is written at this address\r\n        uint addrStart; // the address of the first entry of returned slice\r\n        uint addrEnd; // ending address to write the next order\r\n        uint count = 0; // the slice's length\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            addrOrig := mload(0x40) // There is a free memory pointer at address 0x40 in memory\r\n            mstore(addrOrig, 32) //the meaningful data start after offset 32\r\n        }\r\n        addrLen = addrOrig + 32;\r\n        addrStart = addrLen + 32;\r\n        addrEnd = addrStart;\r\n        while(count < maxCount) {\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                mstore(addrEnd, order) //write the order\r\n            }\r\n            addrEnd += 32;\r\n            count++;\r\n            if(id == 0) {break;}\r\n            order = orderbook[id];\r\n            require(order!=0, \"GraSwap: INCONSISTENT_BOOK\");\r\n            id = uint32(order&_MAX_ID);\r\n        }\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            mstore(addrLen, count) // record the returned slice's length\r\n            let byteCount := sub(addrEnd, addrOrig)\r\n            return(addrOrig, byteCount)\r\n        }\r\n    }\r\n\r\n    // Get an unused id to be used with new order\r\n    function _getUnusedOrderID(bool isBuy, uint32 id) internal view returns (uint32) {\r\n        if(id == 0) { // 0 is reserved\r\n            // solhint-disable-next-line avoid-tx-origin\r\n            id = uint32(uint(blockhash(block.number-1))^uint(tx.origin)) & _MAX_ID; //get a pseudo random number\r\n        }\r\n        for(uint32 i = 0; i < 100 && id <= _MAX_ID; i++) { //try 100 times\r\n            if(!_hasOrder(isBuy, id)) {\r\n                return id;\r\n            }\r\n            id++;\r\n        }\r\n        require(false, \"GraSwap: CANNOT_FIND_VALID_ID\");\r\n        return 0;\r\n    }\r\n\r\n    function calcStockAndMoney(uint64 amount, uint32 price32) external pure override returns (uint stockAmount, uint moneyAmount) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+2));\r\n        (stockAmount, moneyAmount, ) = _calcStockAndMoney(amount, price32, proxyData);\r\n    }\r\n\r\n    function _calcStockAndMoney(uint64 amount, uint32 price32, uint[5] memory proxyData) private pure returns (uint stockAmount, uint moneyAmount, RatPrice memory price) {\r\n        price = _expandPrice(price32, proxyData);\r\n        uint64 stockUnit = ProxyData.stockUnit(proxyData);\r\n        stockAmount = uint(amount)/*42bits*/ * uint(stockUnit);\r\n        moneyAmount = stockAmount * price.numerator/*54+64bits*/ /price.denominator;\r\n    }\r\n\r\n    function addLimitOrder(bool isBuy, address sender, uint64 amount, uint32 price32,\r\n                           uint32 id, uint72 prevKey) external payable override lock {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+6));\r\n        require(ProxyData.isOnlySwap(proxyData)==false, \"GraSwap: LIMIT_ORDER_NOT_SUPPORTED\");\r\n        Context memory ctx;\r\n        ctx.stockUnit = ProxyData.stockUnit(proxyData);\r\n        ctx.graContract = ProxyData.graContract(proxyData);\r\n        ctx.factory = ProxyData.factory(proxyData);\r\n        ctx.stockToken = ProxyData.stock(proxyData);\r\n        ctx.moneyToken = ProxyData.money(proxyData);\r\n        ctx.priceMul = ProxyData.priceMul(proxyData);\r\n        ctx.priceDiv = ProxyData.priceDiv(proxyData);\r\n        ctx.hasDealtInOrderBook = false;\r\n        ctx.isLimitOrder = true;\r\n        ctx.order.sender = sender;\r\n        ctx.order.amount = amount;\r\n        ctx.order.price = price32;\r\n\r\n        ctx.newOrderID = _getUnusedOrderID(isBuy, id);\r\n        RatPrice memory price;\r\n    \r\n        {// to prevent \"CompilerError: Stack too deep, try removing local variables.\"\r\n            require((amount >> 42) == 0, \"GraSwap: INVALID_AMOUNT\");\r\n            uint32 m = price32 & DecFloat32.MANTISSA_MASK;\r\n            require(DecFloat32.MIN_MANTISSA <= m && m <= DecFloat32.MAX_MANTISSA, \"GraSwap: INVALID_PRICE\");\r\n\r\n            uint stockAmount;\r\n            uint moneyAmount;\r\n            (stockAmount, moneyAmount, price) = _calcStockAndMoney(amount, price32, proxyData);\r\n            if(isBuy) {\r\n                ctx.remainAmount = moneyAmount;\r\n            } else {\r\n                ctx.remainAmount = stockAmount;\r\n            }\r\n        }\r\n\r\n        require(ctx.remainAmount < uint(1<<112), \"GraSwap: OVERFLOW\");\r\n        (ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID) = getReserves();\r\n        (ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID) = getBooked();\r\n        _checkRemainAmount(ctx, isBuy);\r\n        if(prevKey != 0) { // try to insert it\r\n            bool inserted = _insertOrderFromGivenPos(isBuy, ctx.order, ctx.newOrderID, prevKey);\r\n            if(inserted) { //  if inserted successfully, record the booked tokens\r\n                _emitNewLimitOrder(uint64(ctx.order.sender), amount, amount, price32, ctx.newOrderID, isBuy);\r\n                if(isBuy) {\r\n                    ctx.bookedMoney += ctx.remainAmount;\r\n                } else {\r\n                    ctx.bookedStock += ctx.remainAmount;\r\n                }\r\n                _setBooked(ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID);\r\n                if(ctx.reserveChanged) {\r\n                    _setReserves(ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID);\r\n                }\r\n                return;\r\n            }\r\n            // if insertion failed, we try to match this order and make it deal\r\n        }\r\n        _addOrder(ctx, isBuy, price);\r\n    }\r\n\r\n    function addMarketOrder(address inputToken, address sender,\r\n                            uint112 inAmount) external payable override lock returns (uint) {\r\n        uint[5] memory proxyData;\r\n        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+3));\r\n        Context memory ctx;\r\n        ctx.moneyToken = ProxyData.money(proxyData);\r\n        ctx.stockToken = ProxyData.stock(proxyData);\r\n        require(inputToken == ctx.moneyToken || inputToken == ctx.stockToken, \"GraSwap: INVALID_TOKEN\");\r\n        bool isBuy = inputToken == ctx.moneyToken;\r\n        ctx.stockUnit = ProxyData.stockUnit(proxyData);\r\n        ctx.priceMul = ProxyData.priceMul(proxyData);\r\n        ctx.priceDiv = ProxyData.priceDiv(proxyData);\r\n        ctx.graContract = ProxyData.graContract(proxyData);\r\n        ctx.factory = ProxyData.factory(proxyData);\r\n        ctx.hasDealtInOrderBook = false;\r\n        ctx.isLimitOrder = false;\r\n        ctx.remainAmount = inAmount;\r\n        (ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID) = getReserves();\r\n        (ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID) = getBooked();\r\n        _checkRemainAmount(ctx, isBuy);\r\n        ctx.order.sender = sender;\r\n        if(isBuy) {\r\n            ctx.order.price = DecFloat32.MAX_PRICE;\r\n        } else {\r\n            ctx.order.price = DecFloat32.MIN_PRICE;\r\n        }\r\n\r\n        RatPrice memory price; // leave it to zero, actually it will not be used;\r\n        _emitNewMarketOrder(uint136(ctx.order.sender), inAmount, isBuy);\r\n        return _addOrder(ctx, isBuy, price);\r\n    }\r\n\r\n    // Check router contract did send me enough tokens.\r\n    // If Router sent to much tokens, take them as reserve money&stock\r\n    function _checkRemainAmount(Context memory ctx, bool isBuy) private view {\r\n        ctx.reserveChanged = false;\r\n        uint diff;\r\n        if(isBuy) {\r\n            uint balance = _myBalance(ctx.moneyToken);\r\n            require(balance >= ctx.bookedMoney + ctx.reserveMoney, \"GraSwap: MONEY_MISMATCH\");\r\n            diff = balance - ctx.bookedMoney - ctx.reserveMoney;\r\n            if(ctx.remainAmount < diff) {\r\n                ctx.reserveMoney += (diff - ctx.remainAmount);\r\n                ctx.reserveChanged = true;\r\n            }\r\n        } else {\r\n            uint balance = _myBalance(ctx.stockToken);\r\n            require(balance >= ctx.bookedStock + ctx.reserveStock, \"GraSwap: STOCK_MISMATCH\");\r\n            diff = balance - ctx.bookedStock - ctx.reserveStock;\r\n            if(ctx.remainAmount < diff) {\r\n                ctx.reserveStock += (diff - ctx.remainAmount);\r\n                ctx.reserveChanged = true;\r\n            }\r\n        }\r\n        require(ctx.remainAmount <= diff, \"GraSwap: DEPOSIT_NOT_ENOUGH\");\r\n    }\r\n\r\n    // internal helper function to add new limit order & market order\r\n    // returns the amount of tokens which were sent to the taker (from AMM pool and booked tokens)\r\n    function _addOrder(Context memory ctx, bool isBuy, RatPrice memory price) private returns (uint) {\r\n        (ctx.dealMoneyInBook, ctx.dealStockInBook) = (0, 0);\r\n        ctx.firstID = _getFirstOrderID(ctx, !isBuy);\r\n        uint32 currID = ctx.firstID;\r\n        ctx.amountIntoPool = 0;\r\n        while(currID != 0) { // while not reaching the end of single-linked \r\n            (Order memory orderInBook, ) = _getOrder(!isBuy, currID);\r\n            bool canDealInOrderBook = (isBuy && (orderInBook.price <= ctx.order.price)) ||\r\n                (!isBuy && (orderInBook.price >= ctx.order.price));\r\n            if(!canDealInOrderBook) {break;} // no proper price in orderbook, stop here\r\n\r\n            // Deal in liquid pool\r\n            RatPrice memory priceInBook = _expandPrice(ctx, orderInBook.price);\r\n            bool allDeal = _tryDealInPool(ctx, isBuy, priceInBook);\r\n            if(allDeal) {break;}\r\n\r\n            // Deal in orderbook\r\n            _dealInOrderBook(ctx, isBuy, currID, orderInBook, priceInBook);\r\n\r\n            // if the order in book did NOT fully deal, then this new order DID fully deal, so stop here\r\n            if(orderInBook.amount != 0) {\r\n                _setOrder(!isBuy, currID, orderInBook);\r\n                break;\r\n            }\r\n            // if the order in book DID fully deal, then delete this order from storage and move to the next\r\n            _deleteOrder(!isBuy, currID);\r\n            currID = orderInBook.nextID;\r\n        }\r\n        // Deal in liquid pool\r\n        if(ctx.isLimitOrder) {\r\n            // use current order's price to deal with pool\r\n            _tryDealInPool(ctx, isBuy, price);\r\n            // If a limit order did NOT fully deal, we add it into orderbook\r\n            // Please note a market order always fully deals\r\n            _insertOrderToBook(ctx, isBuy, price);\r\n        } else {\r\n            // the AMM pool can deal with orders with any amount\r\n            ctx.amountIntoPool += ctx.remainAmount; // both of them are less than 112 bits\r\n            ctx.remainAmount = 0;\r\n        }\r\n        uint amountToTaker = _dealWithPoolAndCollectFee(ctx, isBuy);\r\n        if(isBuy) {\r\n            ctx.bookedStock -= ctx.dealStockInBook; //If this subtraction overflows, _setBooked will fail\r\n        } else {\r\n            ctx.bookedMoney -= ctx.dealMoneyInBook; //If this subtraction overflows, _setBooked will fail\r\n        }\r\n        if(ctx.firstID != currID) { //some orders DID fully deal, so the head of single-linked list change\r\n            _setFirstOrderID(ctx, !isBuy, currID);\r\n        }\r\n        // write the cached values to storage\r\n        _setBooked(ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID);\r\n        _setReserves(ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID);\r\n        return amountToTaker;\r\n    }\r\n\r\n    // Given reserveMoney and reserveStock in AMM pool, calculate how much tokens will go into the pool if the\r\n    // final price is 'price'\r\n    function _intopoolAmountTillPrice(bool isBuy, uint reserveMoney, uint reserveStock,\r\n                                     RatPrice memory price) private pure returns (uint result) {\r\n        // sqrt(Pold/Pnew) = sqrt((2**32)*M_old*PnewDenominator / (S_old*PnewNumerator)) / (2**16)\r\n        // sell, stock-into-pool, Pold > Pnew\r\n        uint numerator = reserveMoney/*112bits*/ * price.denominator/*76+64bits*/;\r\n        uint denominator = reserveStock/*112bits*/ * price.numerator/*54+64bits*/;\r\n        if(isBuy) { // buy, money-into-pool, Pold < Pnew\r\n            // sqrt(Pnew/Pold) = sqrt((2**32)*S_old*PnewNumerator / (M_old*PnewDenominator)) / (2**16)\r\n            (numerator, denominator) = (denominator, numerator);\r\n        }\r\n        while(numerator >= (1<<192)) { // can not equal to (1<<192) !!!\r\n            numerator >>= 16;\r\n            denominator >>= 16;\r\n        }\r\n        require(denominator != 0, \"GraSwapPair: DIV_BY_ZERO\");\r\n        numerator = numerator * (1<<64);\r\n        uint quotient = numerator / denominator;\r\n        if(quotient <= (1<<64)) {\r\n            return 0;\r\n        } else if(quotient <= ((1<<64)*5/4)) {\r\n            // Taylor expansion: x/2 - x*x/8 + x*x*x/16\r\n            uint x = quotient - (1<<64);\r\n            uint y = x*x;\r\n            y = x/2 - y/(8*(1<<64)) + y*x/(16*(1<<128));\r\n            if(isBuy) {\r\n                result = reserveMoney * y;\r\n            } else {\r\n                result = reserveStock * y;\r\n            }\r\n            result /= (1<<64);\r\n            return result;\r\n        }\r\n        uint root = Math.sqrt(quotient); //root is at most 110bits\r\n        uint diff =  root - (1<<32);  //at most 110bits\r\n        if(isBuy) {\r\n            result = reserveMoney * diff;\r\n        } else {\r\n            result = reserveStock * diff;\r\n        }\r\n        result /= (1<<32);\r\n        return result;\r\n    }\r\n\r\n    // Current order tries to deal against the AMM pool. Returns whether current order fully deals.\r\n    function _tryDealInPool(Context memory ctx, bool isBuy, RatPrice memory price) private pure returns (bool) {\r\n        uint currTokenCanTrade = _intopoolAmountTillPrice(isBuy, ctx.reserveMoney, ctx.reserveStock, price);\r\n        require(currTokenCanTrade < uint(1<<112), \"GraSwap: CURR_TOKEN_TOO_LARGE\");\r\n        // all the below variables are less than 112 bits\r\n        if(!isBuy) {\r\n            currTokenCanTrade /= ctx.stockUnit; //to round\r\n            currTokenCanTrade *= ctx.stockUnit;\r\n        }\r\n        if(currTokenCanTrade > ctx.amountIntoPool) {\r\n            uint diffTokenCanTrade = currTokenCanTrade - ctx.amountIntoPool;\r\n            bool allDeal = diffTokenCanTrade >= ctx.remainAmount;\r\n            if(allDeal) {\r\n                diffTokenCanTrade = ctx.remainAmount;\r\n            }\r\n            ctx.amountIntoPool += diffTokenCanTrade;\r\n            ctx.remainAmount -= diffTokenCanTrade;\r\n            return allDeal;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Current order tries to deal against the orders in book\r\n    function _dealInOrderBook(Context memory ctx, bool isBuy, uint32 currID,\r\n                             Order memory orderInBook, RatPrice memory priceInBook) internal {\r\n        ctx.hasDealtInOrderBook = true;\r\n        uint stockAmount;\r\n        if(isBuy) {\r\n            uint a = ctx.remainAmount/*112bits*/ * priceInBook.denominator/*76+64bits*/;\r\n            uint b = priceInBook.numerator/*54+64bits*/ * ctx.stockUnit/*64bits*/;\r\n            stockAmount = a/b;\r\n        } else {\r\n            stockAmount = ctx.remainAmount/ctx.stockUnit;\r\n        }\r\n        if(uint(orderInBook.amount) < stockAmount) {\r\n            stockAmount = uint(orderInBook.amount);\r\n        }\r\n        require(stockAmount < (1<<42), \"GraSwap: STOCK_TOO_LARGE\");\r\n        uint stockTrans = stockAmount/*42bits*/ * ctx.stockUnit/*64bits*/;\r\n        uint moneyTrans = stockTrans * priceInBook.numerator/*54+64bits*/ / priceInBook.denominator/*76+64bits*/;\r\n\r\n        _emitOrderChanged(orderInBook.amount, uint64(stockAmount), currID, isBuy);\r\n        orderInBook.amount -= uint64(stockAmount);\r\n        if(isBuy) { //subtraction cannot overflow: moneyTrans and stockTrans are calculated from remainAmount\r\n            ctx.remainAmount -= moneyTrans;\r\n        } else {\r\n            ctx.remainAmount -= stockTrans;\r\n        }\r\n        // following accumulations can not overflow, because stockTrans(moneyTrans) at most 106bits(160bits)\r\n        // we know for sure that dealStockInBook and dealMoneyInBook are less than 192 bits\r\n        ctx.dealStockInBook += stockTrans;\r\n        ctx.dealMoneyInBook += moneyTrans;\r\n        if(isBuy) {\r\n            _safeTransfer(ctx.moneyToken, orderInBook.sender, moneyTrans, ctx.graContract);\r\n        } else {\r\n            _safeTransfer(ctx.stockToken, orderInBook.sender, stockTrans, ctx.graContract);\r\n        }\r\n    }\r\n\r\n    // make real deal with the pool and then collect fee, which will be added to AMM pool\r\n    function _dealWithPoolAndCollectFee(Context memory ctx, bool isBuy) internal returns (uint) {\r\n        (uint outpoolTokenReserve, uint inpoolTokenReserve, uint otherToTaker) = (\r\n              ctx.reserveMoney, ctx.reserveStock, ctx.dealMoneyInBook);\r\n        if(isBuy) {\r\n            (outpoolTokenReserve, inpoolTokenReserve, otherToTaker) = (\r\n                ctx.reserveStock, ctx.reserveMoney, ctx.dealStockInBook);\r\n        }\r\n\r\n        // all these 4 varialbes are less than 112 bits\r\n        // outAmount is sure to less than outpoolTokenReserve (which is ctx.reserveStock or ctx.reserveMoney)\r\n        uint outAmount = (outpoolTokenReserve*ctx.amountIntoPool)/(inpoolTokenReserve+ctx.amountIntoPool);\r\n        if(ctx.amountIntoPool > 0) {\r\n            _emitDealWithPool(uint112(ctx.amountIntoPool), uint112(outAmount), isBuy);\r\n        }\r\n        uint32 feeBPS = IGraSwapFactory(ctx.factory).feeBPS();\r\n        // the token amount that should go to the taker, \r\n        // for buy-order, it's stock amount; for sell-order, it's money amount\r\n        uint amountToTaker = outAmount + otherToTaker;\r\n        require(amountToTaker < uint(1<<112), \"GraSwap: AMOUNT_TOO_LARGE\");\r\n        uint fee = (amountToTaker * feeBPS + 9999) / 10000;\r\n        amountToTaker -= fee;\r\n\r\n        if(isBuy) {\r\n            ctx.reserveMoney = ctx.reserveMoney + ctx.amountIntoPool;\r\n            ctx.reserveStock = ctx.reserveStock - outAmount + fee;\r\n        } else {\r\n            ctx.reserveMoney = ctx.reserveMoney - outAmount + fee;\r\n            ctx.reserveStock = ctx.reserveStock + ctx.amountIntoPool;\r\n        }\r\n\r\n        address token = ctx.moneyToken;\r\n        if(isBuy) {\r\n            token = ctx.stockToken;\r\n        }\r\n        _safeTransfer(token, ctx.order.sender, amountToTaker, ctx.graContract);\r\n        return amountToTaker;\r\n    }\r\n\r\n    // Insert a not-fully-deal limit order into orderbook\r\n    function _insertOrderToBook(Context memory ctx, bool isBuy, RatPrice memory price) internal {\r\n        (uint smallAmount, uint moneyAmount, uint stockAmount) = (0, 0, 0);\r\n        if(isBuy) {\r\n            uint tempAmount1 = ctx.remainAmount /*112bits*/ * price.denominator /*76+64bits*/;\r\n            uint temp = ctx.stockUnit * price.numerator/*54+64bits*/;\r\n            stockAmount = tempAmount1 / temp;\r\n            uint tempAmount2 = stockAmount * temp; // Now tempAmount1 >= tempAmount2\r\n            moneyAmount = (tempAmount2+price.denominator-1)/price.denominator; // round up\r\n            if(ctx.remainAmount > moneyAmount) {\r\n                // smallAmount is the gap where remainAmount can not buy an integer of stocks\r\n                smallAmount = ctx.remainAmount - moneyAmount;\r\n            } else {\r\n                moneyAmount = ctx.remainAmount;\r\n            } //Now ctx.remainAmount >= moneyAmount\r\n        } else {\r\n            // for sell orders, remainAmount were always decreased by integral multiple of StockUnit\r\n            // and we know for sure that ctx.remainAmount % StockUnit == 0\r\n            stockAmount = ctx.remainAmount / ctx.stockUnit;\r\n            smallAmount = ctx.remainAmount - stockAmount * ctx.stockUnit;\r\n        }\r\n        ctx.amountIntoPool += smallAmount; // Deal smallAmount with pool\r\n        //ctx.reserveMoney += smallAmount; // If this addition overflows, _setReserves will fail\r\n        _emitNewLimitOrder(uint64(ctx.order.sender), ctx.order.amount, uint64(stockAmount),\r\n                           ctx.order.price, ctx.newOrderID, isBuy);\r\n        if(stockAmount != 0) {\r\n            ctx.order.amount = uint64(stockAmount);\r\n            if(ctx.hasDealtInOrderBook) {\r\n                // if current order has ever dealt, it has the best price and can be inserted at head\r\n                _insertOrderAtHead(ctx, isBuy, ctx.order, ctx.newOrderID);\r\n            } else {\r\n                // if current order has NEVER dealt, we must find a proper position for it.\r\n                // we may scan a lot of entries in the single-linked list and run out of gas\r\n                _insertOrderFromHead(ctx, isBuy, ctx.order, ctx.newOrderID);\r\n            }\r\n        }\r\n        // Any overflow/underflow in following calculation will be caught by _setBooked\r\n        if(isBuy) {\r\n            ctx.bookedMoney += moneyAmount;\r\n        } else {\r\n            ctx.bookedStock += (ctx.remainAmount - smallAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// solhint-disable-next-line max-states-count\r\ncontract GraSwapPairProxy {\r\n    uint internal _unusedVar0;\r\n    uint internal _unusedVar1;\r\n    uint internal _unusedVar2;\r\n    uint internal _unusedVar3;\r\n    uint internal _unusedVar4;\r\n    uint internal _unusedVar5;\r\n    uint internal _unusedVar6;\r\n    uint internal _unusedVar7;\r\n    uint internal _unusedVar8;\r\n    uint internal _unusedVar9;\r\n    uint internal _unlocked;\r\n\r\n    uint internal immutable _immuFactory;\r\n    uint internal immutable _immuMoneyToken;\r\n    uint internal immutable _immuStockToken;\r\n    uint internal immutable _immuGras;\r\n    uint internal immutable _immuOther;\r\n\r\n    constructor(address stockToken, address moneyToken, bool isOnlySwap, uint64 stockUnit, uint64 priceMul, uint64 priceDiv, address graContract) public {\r\n        _immuFactory = uint(msg.sender);\r\n        _immuMoneyToken = uint(moneyToken);\r\n        _immuStockToken = uint(stockToken);\r\n        _immuGras = uint(graContract);\r\n        uint temp = 0;\r\n        if(isOnlySwap) {\r\n            temp = 1;\r\n        }\r\n        temp = (temp<<64) | stockUnit;\r\n        temp = (temp<<64) | priceMul;\r\n        temp = (temp<<64) | priceDiv;\r\n        _immuOther = temp;\r\n        _unlocked = 1;\r\n    }\r\n\r\n    receive() external payable { }\r\n    // solhint-disable-next-line no-complex-fallback\r\n    fallback() payable external {\r\n        uint factory     = _immuFactory;\r\n        uint moneyToken  = _immuMoneyToken;\r\n        uint stockToken  = _immuStockToken;\r\n        uint graContract        = _immuGras;\r\n        uint other       = _immuOther;\r\n        address impl = IGraSwapFactory(address(_immuFactory)).pairLogic();\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            let size := calldatasize()\r\n            calldatacopy(ptr, 0, size)\r\n            let end := add(ptr, size)\r\n            // append immutable variables to the end of calldata\r\n            mstore(end, factory)\r\n            end := add(end, 32)\r\n            mstore(end, moneyToken)\r\n            end := add(end, 32)\r\n            mstore(end, stockToken)\r\n            end := add(end, 32)\r\n            mstore(end, graContract)\r\n            end := add(end, 32)\r\n            mstore(end, other)\r\n            size := add(size, 160)\r\n            let result := delegatecall(gas(), impl, ptr, size, 0, 0)\r\n            size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n\r\n"}}}