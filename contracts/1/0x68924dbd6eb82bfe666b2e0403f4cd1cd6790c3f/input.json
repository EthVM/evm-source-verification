{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"srv3-1.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\n\r\nlibrary Math {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary PoolAddress {\r\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\r\n\r\n    struct PoolKey {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n    }\r\n\r\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\r\n        require(key.token0 < key.token1);\r\n        pool = address(\r\n            uint160(uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex'ff',\r\n                        factory,\r\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\r\n                        POOL_INIT_CODE_HASH\r\n                    )\r\n                )\r\n            )\r\n        ));\r\n    }\r\n}\r\n\r\ninterface erc20 {\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function balanceOf(address) external view returns (uint);\r\n}\r\n\r\ninterface PositionManagerV3 {\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    function positions(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n    function safeTransferFrom(address from, address to, uint tokenId) external;\r\n\r\n    function ownerOf(uint tokenId) external view returns (address);\r\n    function transferFrom(address from, address to, uint tokenId) external;\r\n    function collect(CollectParams calldata params) external payable returns (uint amount0, uint amount1);\r\n}\r\n\r\ninterface UniV3 {\r\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\r\n        external\r\n        view\r\n        returns (\r\n            int56 tickCumulativeInside,\r\n            uint160 secondsPerLiquidityInsideX128,\r\n            uint32 secondsInside\r\n        );\r\n    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\r\n}\r\n\r\ncontract StakingRewardsV3 {\r\n\r\n    address immutable public reward;\r\n    address immutable public pool;\r\n\r\n    address constant factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\r\n    PositionManagerV3 constant nftManager = PositionManagerV3(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\r\n    uint constant DURATION = 7 days;\r\n    uint constant PRECISION = 10 ** 18;\r\n\r\n    uint rewardRate;\r\n    uint periodFinish;\r\n    uint lastUpdateTime;\r\n    uint rewardPerLiquidityStored;\r\n    uint public forfeit;\r\n\r\n    mapping(uint => uint) public tokenRewardPerLiquidityPaid;\r\n    mapping(uint => uint) public rewards;\r\n\r\n    address public governance;\r\n    address public nextGovernance;\r\n    uint public delayGovernance;\r\n\r\n    address public rewarder;\r\n    \r\n    address public treasury;\r\n    address public nextTreasury;\r\n    uint public delayTreasury;\r\n    \r\n    uint32 constant DELAY = 1 days;\r\n\r\n    struct time {\r\n        uint32 timestamp;\r\n        uint32 secondsInside;\r\n    }\r\n\r\n    mapping(uint => time) public elapsed;\r\n    mapping(uint => address) public owners;\r\n    mapping(address => uint[]) public tokenIds;\r\n    mapping(uint => uint) public liquidityOf;\r\n    uint public totalLiquidity;\r\n\r\n    uint public earned0;\r\n    uint public earned1;\r\n\r\n    event RewardPaid(address indexed sender, uint tokenId, uint reward);\r\n    event RewardAdded(address indexed sender, uint reward);\r\n    event Deposit(address indexed sender, uint tokenId, uint liquidity);\r\n    event Withdraw(address indexed sender, uint tokenId, uint liquidity);\r\n    event Collect(address indexed sender, uint tokenId, uint amount0, uint amount1);\r\n    event Governance(address indexed previous, address indexed current, uint timestamp);\r\n    event Treasury(address indexed previous, address indexed current, uint timestamp);\r\n\r\n    constructor(address _reward, address _pool, address _governance, address _treasury, address _rewarder) {\r\n        reward = _reward;\r\n        pool = _pool;\r\n        governance = _governance;\r\n        treasury = _treasury;\r\n        rewarder = _rewarder;\r\n    }\r\n    \r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyRewarder() {\r\n        require(msg.sender == rewarder);\r\n        _;\r\n    }\r\n\r\n    function setRewarder(address _rewarder) external onlyGovernance {\r\n        rewarder = _rewarder;\r\n    }\r\n\r\n    function setGovernance(address _governance) external onlyGovernance {\r\n        nextGovernance = _governance;\r\n        delayGovernance = block.timestamp + DELAY;\r\n    }\r\n\r\n    function acceptGovernance() external {\r\n        require(msg.sender == nextGovernance && delayGovernance < block.timestamp);\r\n        emit Governance(governance, nextGovernance, block.timestamp);\r\n        governance = nextGovernance;\r\n    }\r\n\r\n    function setTreasury(address _treasury) external onlyGovernance {\r\n        nextTreasury = _treasury;\r\n        delayTreasury = block.timestamp + DELAY;\r\n    }\r\n\r\n    function commitTreasury() external onlyGovernance {\r\n        require(delayTreasury < block.timestamp);\r\n        emit Treasury(treasury, nextTreasury, block.timestamp);\r\n        treasury = nextTreasury;\r\n    }\r\n\r\n    function getTokenIdsLength(address _owner) external view returns (uint) {\r\n        return tokenIds[_owner].length;\r\n    }\r\n\r\n    function getTokenIds(address _owner) external view returns (uint[] memory) {\r\n        return tokenIds[_owner];\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint) {\r\n        return Math.min(block.timestamp, periodFinish);\r\n    }\r\n\r\n    function rewardPerLiquidity() public view returns (uint) {\r\n        if (totalLiquidity == 0) {\r\n            return rewardPerLiquidityStored;\r\n        }\r\n        return rewardPerLiquidityStored + ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * PRECISION / totalLiquidity);\r\n    }\r\n\r\n    function collect(uint[] memory tokenId) external {\r\n        for (uint i = 0; i < tokenId.length; i++) {\r\n            _collect(tokenId[i]);\r\n        }\r\n    }\r\n\r\n    function _collect(uint tokenId) internal {\r\n        if (owners[tokenId] != address(0)) {\r\n            PositionManagerV3.CollectParams memory _claim = PositionManagerV3.CollectParams(tokenId, treasury, type(uint128).max, type(uint128).max);\r\n            (uint amount0, uint amount1) = nftManager.collect(_claim);\r\n            earned0 += amount0;\r\n            earned1 += amount1;\r\n            emit Collect(msg.sender, tokenId, amount0, amount1);\r\n        }\r\n    }\r\n\r\n    function earned(uint tokenId) public view returns (uint claimable, uint32 secondsInside, uint forfeited) {\r\n        (,,,,,int24 _tickLower,int24 _tickUpper,,,,,) = nftManager.positions(tokenId);\r\n        (,,secondsInside) = UniV3(pool).snapshotCumulativesInside(_tickLower, _tickUpper);\r\n\r\n        uint _liquidity = liquidityOf[tokenId];\r\n        time memory _elapsed = elapsed[tokenId];\r\n\r\n        uint _maxSecondsElapsed = lastTimeRewardApplicable() - Math.min(_elapsed.timestamp, periodFinish);\r\n        if (_maxSecondsElapsed > 0) {\r\n            uint _secondsInside = Math.min(_maxSecondsElapsed, (secondsInside - _elapsed.secondsInside));\r\n    \r\n            uint _reward = (_liquidity * (rewardPerLiquidity() - tokenRewardPerLiquidityPaid[tokenId]) / PRECISION);\r\n            uint _earned = _reward * _secondsInside / _maxSecondsElapsed;\r\n            forfeited = _reward - _earned;\r\n            claimable = _earned;\r\n        }\r\n        claimable += rewards[tokenId];\r\n    }\r\n\r\n    function getRewardForDuration() external view returns (uint) {\r\n        return rewardRate * DURATION;\r\n    }\r\n\r\n    function deposit(uint tokenId) external update(tokenId) {\r\n        (,,address token0,address token1,uint24 fee,int24 tickLower,int24 tickUpper,uint128 _liquidity,,,,) = nftManager.positions(tokenId);\r\n        address _pool = PoolAddress.computeAddress(factory,PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee}));\r\n\r\n        require(pool == _pool);\r\n        require(_liquidity > 0);\r\n\r\n        (,int24 _tick,,,,,) = UniV3(_pool).slot0();\r\n        require(tickLower <= _tick && _tick <= tickUpper);\r\n\r\n        nftManager.transferFrom(msg.sender, address(this), tokenId);\r\n        \r\n        owners[tokenId] = msg.sender;\r\n        tokenIds[msg.sender].push(tokenId);\r\n        \r\n        liquidityOf[tokenId] = _liquidity;\r\n        totalLiquidity += _liquidity;\r\n\r\n        emit Deposit(msg.sender, tokenId, _liquidity);\r\n    }\r\n\r\n    function _findIndex(uint[] memory array, uint element) internal pure returns (uint i) {\r\n        for (i = 0; i < array.length; i++) {\r\n            if (array[i] == element) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _remove(uint[] storage array, uint element) internal {\r\n        uint _index = _findIndex(array, element);\r\n        uint _length = array.length;\r\n        if (_index >= _length) return;\r\n        if (_index < _length-1) {\r\n            array[_index] = array[_length-1];\r\n        }\r\n\r\n        array.pop();\r\n    }\r\n\r\n    function withdraw(uint tokenId) public update(tokenId) {\r\n        _collect(tokenId);\r\n        _withdraw(tokenId);\r\n    }\r\n\r\n    function _withdraw(uint tokenId) internal {\r\n        require(owners[tokenId] == msg.sender);\r\n        uint _liquidity = liquidityOf[tokenId];\r\n        liquidityOf[tokenId] = 0;\r\n        totalLiquidity -= _liquidity;\r\n        owners[tokenId] = address(0);\r\n        _remove(tokenIds[msg.sender], tokenId);\r\n        nftManager.transferFrom(address(this), msg.sender, tokenId);\r\n        delete elapsed[tokenId];\r\n        emit Withdraw(msg.sender, tokenId, _liquidity);\r\n    }\r\n\r\n    function getRewards() external {\r\n        uint[] memory _tokens = tokenIds[msg.sender];\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            getReward(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    function getReward(uint tokenId) public update(tokenId) {\r\n        _collect(tokenId);\r\n        uint _reward = rewards[tokenId];\r\n        if (_reward > 0) {\r\n            rewards[tokenId] = 0;\r\n            _safeTransfer(reward, _getRecipient(tokenId), _reward);\r\n\r\n            emit RewardPaid(msg.sender, tokenId, _reward);\r\n        }\r\n    }\r\n\r\n    function _getRecipient(uint tokenId) internal view returns (address) {\r\n        if (owners[tokenId] != address(0)) {\r\n            return owners[tokenId];\r\n        } else {\r\n            return nftManager.ownerOf(tokenId);\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        uint[] memory _tokens = tokenIds[msg.sender];\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            withdraw(_tokens[i]);\r\n        }\r\n    }\r\n\r\n    function deposit_reward_token(address token, uint _reward) external {\r\n        require(token == reward);\r\n        notify(_reward);\r\n    }\r\n\r\n    function notify(uint amount) public onlyRewarder update(0) {\r\n        if (block.timestamp >= periodFinish) {\r\n            rewardRate = amount / DURATION;\r\n        } else {\r\n            uint _remaining = periodFinish - block.timestamp;\r\n            uint _leftover = _remaining * rewardRate;\r\n\r\n            rewardRate = (amount + _leftover) / DURATION;\r\n        }\r\n\r\n        lastUpdateTime = block.timestamp;\r\n        periodFinish = block.timestamp + DURATION;\r\n\r\n        _safeTransferFrom(reward, msg.sender, address(this), amount);\r\n        emit RewardAdded(msg.sender, amount);\r\n    }\r\n\r\n    function refund() external onlyGovernance {\r\n        uint _forfeit = forfeit;\r\n        forfeit = 0;\r\n\r\n        _safeTransfer(reward, treasury, _forfeit);\r\n    }\r\n\r\n    modifier update(uint tokenId) {\r\n        uint _rewardPerLiquidityStored = rewardPerLiquidity();\r\n        uint _lastUpdateTime = lastTimeRewardApplicable();\r\n        rewardPerLiquidityStored = _rewardPerLiquidityStored;\r\n        lastUpdateTime = _lastUpdateTime;\r\n        if (tokenId != 0) {\r\n            (uint _reward, uint32 _secondsInside, uint _forfeited) = earned(tokenId);\r\n            tokenRewardPerLiquidityPaid[tokenId] = _rewardPerLiquidityStored;\r\n            rewards[tokenId] = _reward;\r\n            forfeit += _forfeited;\r\n\r\n            if (elapsed[tokenId].timestamp < _lastUpdateTime) {\r\n                elapsed[tokenId] = time(uint32(_lastUpdateTime), _secondsInside);\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}"}}}