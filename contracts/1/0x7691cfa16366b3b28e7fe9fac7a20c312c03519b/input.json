{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Ethermaze.sol":{"content":"/*\r\n*\r\n*         ███████╗████████╗██╗  ██╗███████╗██████╗ ███╗   ███╗ █████╗ ███████╗███████╗    ██████╗     ██████╗ \r\n*         ██╔════╝╚══██╔══╝██║  ██║██╔════╝██╔══██╗████╗ ████║██╔══██╗╚══███╔╝██╔════╝    ╚════██╗   ██╔═████╗\r\n*         █████╗     ██║   ███████║█████╗  ██████╔╝██╔████╔██║███████║  ███╔╝ █████╗       █████╔╝   ██║██╔██║\r\n*         ██╔══╝     ██║   ██╔══██║██╔══╝  ██╔══██╗██║╚██╔╝██║██╔══██║ ███╔╝  ██╔══╝      ██╔═══╝    ████╔╝██║\r\n*         ███████╗   ██║   ██║  ██║███████╗██║  ██║██║ ╚═╝ ██║██║  ██║███████╗███████╗    ███████╗██╗╚██████╔╝\r\n*         ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝    ╚══════╝╚═╝ ╚═════╝ \r\n* \r\n*                                                           888                                   888            d8b          \r\n*                                                           888                                   888            Y8P          \r\n*                                                           888                                   888                         \r\n* 888  888  .d88b.  888  888 888d888       88888b.   .d88b.  888888 888  888  888  .d88b.  888d888 888  888       888 .d8888b  \r\n* 888  888 d88\"\"88b 888  888 888P\"         888 \"88b d8P  Y8b 888    888  888  888 d88\"\"88b 888P\"   888 .88P       888 88K      \r\n* 888  888 888  888 888  888 888           888  888 88888888 888    888  888  888 888  888 888     888888K        888 \"Y8888b. \r\n* Y88b 888 Y88..88P Y88b 888 888           888  888 Y8b.     Y88b.  Y88b 888 d88P Y88..88P 888     888 \"88b       888      X88 \r\n*  \"Y88888  \"Y88P\"   \"Y88888 888           888  888  \"Y8888   \"Y888  \"Y8888888P\"   \"Y88P\"  888     888  888       888  88888P' \r\n*      888                                                                                                                     \r\n* Y8b d88P                                                                                                                     \r\n*  \"Y88P\"                                                                                                                      \r\n*                                                           888                                         888    888      \r\n*                                                           888                                         888    888      \r\n*                                                           888                                         888    888      \r\n* 888  888  .d88b.  888  888 888d888       88888b.   .d88b.  888888       888  888  888  .d88b.  888d888 888888 88888b.  \r\n* 888  888 d88\"\"88b 888  888 888P\"         888 \"88b d8P  Y8b 888          888  888  888 d88\"\"88b 888P\"   888    888 \"88b \r\n* 888  888 888  888 888  888 888           888  888 88888888 888          888  888  888 888  888 888     888    888  888 \r\n* Y88b 888 Y88..88P Y88b 888 888           888  888 Y8b.     Y88b.        Y88b 888 d88P Y88..88P 888     Y88b.  888  888 \r\n*  \"Y88888  \"Y88P\"   \"Y88888 888           888  888  \"Y8888   \"Y888        \"Y8888888P\"   \"Y88P\"  888      \"Y888 888  888 \r\n*      888                                                                                                               \r\n* Y8b d88P                                                                                                               \r\n*  \"Y88P\"                                                                                                                \r\n*\r\n*/\r\n\r\npragma solidity 0.5.14;\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract Ethermaze {\r\n    using SafeMath for uint256;\r\n\r\n    struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint referrerID;\r\n        uint currentLevel;\r\n        uint totalEarningEth;\r\n        address[] referral;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n    \r\n    Ethermaze public oldETHMaze;\r\n    uint oldETHMazeId = 1;\r\n    address public ownerAddress;\r\n    uint public adminFee = 5 ether;\r\n    uint public currentId = 0;\r\n    uint public PERIOD_LENGTH = 100 days;\r\n    uint referrer1Limit = 2;\r\n    bool public lockStatus;\r\n    \r\n    mapping (uint => uint) public LEVEL_PRICE;\r\n    mapping (address => UserStruct) public users;\r\n    mapping (uint => address) public userList;\r\n    mapping (address => mapping (uint => uint)) public EarnedEth;\r\n    mapping (address => uint) public loopCheck;\r\n    mapping (address => uint) public createdDate;\r\n    \r\n    event regLevelEvent(address indexed UserAddress, address indexed ReferrerAddress, uint Time);\r\n    event buyLevelEvent(address indexed UserAddress, uint Levelno, uint Time);\r\n    event getMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint LevelPrice, uint Time);\r\n    event lostMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint LevelPrice, uint Time);    \r\n    \r\n    constructor() public {\r\n        ownerAddress = msg.sender;\r\n        \r\n        oldETHMaze = Ethermaze(0x1d1E3f003735f7C8ef242Bb0DBf17c573b2eB960);\r\n        \r\n        LEVEL_PRICE[1] = 0.06 ether;\r\n        LEVEL_PRICE[2] = 0.1 ether;\r\n        LEVEL_PRICE[3] = 0.3 ether;\r\n        LEVEL_PRICE[4] = 0.5 ether;\r\n        LEVEL_PRICE[5] = 1 ether;\r\n        LEVEL_PRICE[6] = 3 ether;\r\n        LEVEL_PRICE[7] = 7 ether;\r\n        LEVEL_PRICE[8] = 10 ether;\r\n        LEVEL_PRICE[9] = 15 ether;\r\n        LEVEL_PRICE[10] = 25 ether;\r\n        LEVEL_PRICE[11] = 31 ether;\r\n        LEVEL_PRICE[12] = 40 ether;\r\n        \r\n        UserStruct memory userStruct;\r\n        currentId = currentId.add(1);\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currentId,\r\n            referrerID: 0,\r\n            currentLevel:1,\r\n            totalEarningEth:0,\r\n            referral: new address[](0)\r\n        });\r\n        users[ownerAddress] = userStruct;\r\n        userList[currentId] = ownerAddress;\r\n\r\n        for(uint i = 1; i <= 12; i++) {\r\n            users[ownerAddress].currentLevel = i;\r\n            users[ownerAddress].levelExpired[i] = 55555555555;\r\n        }\r\n    } \r\n\r\n    /**\r\n     * @dev User registration\r\n     */ \r\n    function regUser(uint _referrerID) external payable {\r\n        require(lockStatus == false, \"Contract Locked\");\r\n        require(users[msg.sender].isExist == false, \"User exist\");\r\n        require(_referrerID > 0 && _referrerID <= currentId, \"Incorrect referrer Id\");\r\n        require(msg.value == LEVEL_PRICE[1], \"Incorrect Value\");\r\n        \r\n        if (users[userList[_referrerID]].referral.length >= referrer1Limit) \r\n            _referrerID = users[findFreeReferrer(userList[_referrerID])].id;\r\n\r\n        UserStruct memory userStruct;\r\n        currentId++;\r\n        \r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currentId,\r\n            referrerID: _referrerID,\r\n            currentLevel: 1,\r\n            totalEarningEth:0,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        users[msg.sender] = userStruct;\r\n        userList[currentId] = msg.sender;\r\n        users[msg.sender].levelExpired[1] = block.timestamp.add(PERIOD_LENGTH);\r\n        users[userList[_referrerID]].referral.push(msg.sender);\r\n        loopCheck[msg.sender] = 0;\r\n        createdDate[msg.sender] = block.timestamp;\r\n\r\n        payForLevel(0, 1, msg.sender, ((LEVEL_PRICE[1].mul(adminFee)).div(10**20)), msg.value);\r\n\r\n        emit regLevelEvent(msg.sender, userList[_referrerID], block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev To buy the next level by User\r\n     */ \r\n    function buyLevel(uint256 _level) external payable {\r\n        require(lockStatus == false, \"Contract Locked\");\r\n        require(users[msg.sender].isExist, \"User not exist\"); \r\n        require(_level > 0 && _level <= 12, \"Incorrect level\");\r\n\r\n        if (_level == 1) {\r\n            require(msg.value == LEVEL_PRICE[1], \"Incorrect Value\");\r\n            users[msg.sender].levelExpired[1] = users[msg.sender].levelExpired[1].add(PERIOD_LENGTH);\r\n            users[msg.sender].currentLevel = 1;\r\n        } else {\r\n            require(msg.value == LEVEL_PRICE[_level], \"Incorrect Value\");\r\n            users[msg.sender].currentLevel = _level;\r\n            /*for (uint i = _level - 1; i > 0; i--) */\r\n            require(users[msg.sender].levelExpired[_level - 1] >= block.timestamp, \"Buy the previous level\");\r\n            \r\n            if (users[msg.sender].levelExpired[_level] == 0)\r\n                users[msg.sender].levelExpired[_level] = block.timestamp.add(PERIOD_LENGTH);\r\n            else \r\n                users[msg.sender].levelExpired[_level] = users[msg.sender].levelExpired[_level].add(PERIOD_LENGTH);\r\n        }\r\n        loopCheck[msg.sender] = 0;\r\n       \r\n        payForLevel(0, _level, msg.sender, ((LEVEL_PRICE[_level].mul(adminFee)).div(10**20)), msg.value);\r\n\r\n        emit buyLevelEvent(msg.sender, _level, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function for payment\r\n     */ \r\n     \r\n    function payForLevel(uint _flag, uint _level, address _userAddress, uint _adminPrice, uint256 _amt) internal {\r\n        address[6] memory referer;\r\n        \r\n        if (_flag == 0) {\r\n            if (_level == 1 || _level == 7) {\r\n                referer[0] = userList[users[_userAddress].referrerID];\r\n            } else if (_level == 2 || _level == 8) {\r\n                referer[1] = userList[users[_userAddress].referrerID];\r\n                referer[0] = userList[users[referer[1]].referrerID];\r\n            } else if (_level == 3 || _level == 9) {\r\n                referer[1] = userList[users[_userAddress].referrerID];\r\n                referer[2] = userList[users[referer[1]].referrerID];\r\n                referer[0] = userList[users[referer[2]].referrerID];\r\n            } else if (_level == 4 || _level == 10) {\r\n                referer[1] = userList[users[_userAddress].referrerID];\r\n                referer[2] = userList[users[referer[1]].referrerID];\r\n                referer[3] = userList[users[referer[2]].referrerID];\r\n                referer[0] = userList[users[referer[3]].referrerID];\r\n            } else if (_level == 5 || _level == 11) {\r\n                referer[1] = userList[users[_userAddress].referrerID];\r\n                referer[2] = userList[users[referer[1]].referrerID];\r\n                referer[3] = userList[users[referer[2]].referrerID];\r\n                referer[4] = userList[users[referer[3]].referrerID];\r\n                referer[0] = userList[users[referer[4]].referrerID];\r\n            } else if (_level == 6 || _level == 12) {\r\n                referer[1] = userList[users[_userAddress].referrerID];\r\n                referer[2] = userList[users[referer[1]].referrerID];\r\n                referer[3] = userList[users[referer[2]].referrerID];\r\n                referer[4] = userList[users[referer[3]].referrerID];\r\n                referer[5] = userList[users[referer[4]].referrerID];\r\n                referer[0] = userList[users[referer[5]].referrerID];\r\n            }\r\n        } else if (_flag == 1) {\r\n            referer[0] = userList[users[_userAddress].referrerID];\r\n        }\r\n        if (!users[referer[0]].isExist) referer[0] = userList[1];\r\n        \r\n        if (loopCheck[msg.sender] >= 12) {\r\n            referer[0] = userList[1];\r\n        }\r\n        if (users[referer[0]].levelExpired[_level] >= block.timestamp) {\r\n          \r\n            // transactions \r\n            require((address(uint160(referer[0])).send(LEVEL_PRICE[_level].sub(_adminPrice))) && \r\n                    (address(uint160(ownerAddress)).send(_adminPrice)), \"Transaction Failure\");\r\n           \r\n            users[referer[0]].totalEarningEth = users[referer[0]].totalEarningEth.add(LEVEL_PRICE[_level].sub(_adminPrice));\r\n            EarnedEth[referer[0]][_level] = EarnedEth[referer[0]][_level].add(LEVEL_PRICE[_level].sub(_adminPrice));\r\n          \r\n            emit getMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer[0], users[referer[0]].id, _level, LEVEL_PRICE[_level].sub(_adminPrice), block.timestamp);\r\n        } else {\r\n            if (loopCheck[msg.sender] < 12) {\r\n                loopCheck[msg.sender] = loopCheck[msg.sender].add(1);\r\n\r\n            emit lostMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer[0], users[referer[0]].id, _level, LEVEL_PRICE[_level].sub(_adminPrice),block.timestamp);\r\n                \r\n            payForLevel(1, _level, referer[0], _adminPrice, _amt);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update old contract data\r\n     */ \r\n    function oldETHMazeSync(uint limit) public {\r\n        require(address(oldETHMaze) != address(0), \"Initialize closed\");\r\n        require(msg.sender == ownerAddress, \"Access denied\");\r\n        \r\n        for (uint i = 0; i <= limit; i++) {\r\n            UserStruct  memory olduser;\r\n            address oldusers = oldETHMaze.userList(oldETHMazeId);\r\n            (olduser.isExist, \r\n            olduser.id, \r\n            olduser.referrerID, \r\n            olduser.currentLevel,  \r\n            olduser.totalEarningEth) = oldETHMaze.users(oldusers);\r\n            address ref = oldETHMaze.userList(olduser.referrerID);\r\n\r\n            if (olduser.isExist) {\r\n                if (!users[oldusers].isExist) {\r\n                    users[oldusers].isExist = true;\r\n                    users[oldusers].id = oldETHMazeId;\r\n                    users[oldusers].referrerID = olduser.referrerID;\r\n                    users[oldusers].currentLevel = olduser.currentLevel;\r\n                    users[oldusers].totalEarningEth = olduser.totalEarningEth;\r\n                    userList[oldETHMazeId] = oldusers;\r\n                    users[ref].referral.push(oldusers);\r\n                    createdDate[oldusers] = block.timestamp;\r\n                    \r\n                    emit regLevelEvent(oldusers, ref, block.timestamp);\r\n                    \r\n                    for (uint j = 1; j <= 12; j++) {\r\n                        \r\n                        if (oldETHMaze.viewUserLevelExpired(oldusers, j) == 12960000){\r\n                            users[oldusers].levelExpired[j] = 1613994853;\r\n                            EarnedEth[oldusers][j] = oldETHMaze.EarnedEth(oldusers, j);\r\n                        } else {\r\n                            if (oldETHMaze.viewUserLevelExpired(oldusers, j) == 4320000){\r\n                                users[oldusers].levelExpired[j] = 0;\r\n                                EarnedEth[oldusers][j] = 0;\r\n                            } else {\r\n                                users[oldusers].levelExpired[j] = oldETHMaze.viewUserLevelExpired(oldusers, j);\r\n                                EarnedEth[oldusers][j] = oldETHMaze.EarnedEth(oldusers, j);\r\n                            }\r\n                        }\r\n                    } \r\n                }\r\n                oldETHMazeId++;\r\n            } else {\r\n                currentId = oldETHMazeId.sub(1);\r\n                break;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @dev Close old contract interaction\r\n     */ \r\n    function oldETHMazeSyncClosed() external {\r\n        require(address(oldETHMaze) != address(0), \"Initialize already closed\");\r\n        require(msg.sender == ownerAddress, \"Access denied\");\r\n\r\n        oldETHMaze = Ethermaze(0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Contract balance withdraw\r\n     */ \r\n    function failSafe(address payable _toUser, uint _amount) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only Owner Wallet\");\r\n        require(_toUser != address(0), \"Invalid Address\");\r\n        require(address(this).balance >= _amount, \"Insufficient balance\");\r\n\r\n        (_toUser).transfer(_amount);\r\n        return true;\r\n    }\r\n            \r\n    /**\r\n     * @dev Update admin fee percentage\r\n     */ \r\n    function updateFeePercentage(uint256 _adminFee) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only OwnerWallet\");\r\n\r\n        adminFee = _adminFee;\r\n        return true;  \r\n    }\r\n    \r\n    /**\r\n     * @dev Update level price\r\n     */ \r\n    function updatePrice(uint _level, uint _price) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only OwnerWallet\");\r\n\r\n        LEVEL_PRICE[_level] = _price;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update contract status\r\n     */ \r\n    function contractLock(bool _lockStatus) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"Invalid User\");\r\n\r\n        lockStatus = _lockStatus;\r\n        return true;\r\n    }\r\n\r\n        \r\n    /**\r\n     * @dev View free Referrer Address\r\n     */ \r\n    function findFreeReferrer(address _userAddress) public view returns (address) {\r\n        if (users[_userAddress].referral.length < referrer1Limit) \r\n            return _userAddress;\r\n\r\n        address[] memory referrals = new address[](254);\r\n        referrals[0] = users[_userAddress].referral[0];\r\n        referrals[1] = users[_userAddress].referral[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for (uint i = 0; i < 254; i++) { \r\n            if (users[referrals[i]].referral.length == referrer1Limit) {\r\n                if (i < 126) {\r\n                    referrals[(i+1)*2] = users[referrals[i]].referral[0];\r\n                    referrals[(i+1)*2+1] = users[referrals[i]].referral[1];\r\n                }\r\n            } else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n        require(!noFreeReferrer, \"No Free Referrer\");\r\n        return freeReferrer;\r\n    }\r\n    \r\n    /**\r\n     * @dev Total earned ETH\r\n     */\r\n    function getTotalEarnedEther() public view returns (uint) {\r\n        uint totalEth;\r\n        for (uint i = 1; i <= currentId; i++) {\r\n            totalEth = totalEth.add(users[userList[i]].totalEarningEth);\r\n        }\r\n        return totalEth;\r\n    }\r\n        \r\n   /**\r\n     * @dev View referrals\r\n     */ \r\n    function viewUserReferral(address _userAddress) external view returns (address[] memory) {\r\n        return users[_userAddress].referral;\r\n    }\r\n    \r\n    /**\r\n     * @dev View level expired time\r\n     */ \r\n    function viewUserLevelExpired(address _userAddress,uint _level) external view returns (uint) {\r\n        return users[_userAddress].levelExpired[_level];\r\n    }\r\n\r\n    // fallback\r\n    function () external payable {\r\n        revert(\"Invalid Transaction\");\r\n    }\r\n}"}}}