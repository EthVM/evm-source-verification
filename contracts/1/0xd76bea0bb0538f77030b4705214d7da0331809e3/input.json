{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BancorChanger.sol": {
      "content": "// File: 22May2017/solidity/contracts/SafeMath.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Overflow protected math functions\n*/\ncontract SafeMath {\n    /**\n        constructor\n    */\n    function SafeMath() {\n    }\n\n    /**\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\n\n        @param _x   value 1\n        @param _y   value 2\n\n        @return sum\n    */\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n        uint256 z = _x + _y;\n        assert(z >= _x);\n        return z;\n    }\n\n    /**\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n\n        @param _x   minuend\n        @param _y   subtrahend\n\n        @return difference\n    */\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n        assert(_x >= _y);\n        return _x - _y;\n    }\n\n    /**\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n\n        @param _x   factor 1\n        @param _y   factor 2\n\n        @return product\n    */\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n        uint256 z = _x * _y;\n        assert(_x == 0 || z / _x == _y);\n        return z;\n    }\n}\n\n// File: 22May2017/solidity/contracts/ITokenChanger.sol\n\npragma solidity ^0.4.11;\n\n/*\n    EIP228 Token Changer interface\n*/\ncontract ITokenChanger {\n    function changeableTokenCount() public constant returns (uint16 count);\n    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress);\n    function getReturn(address _fromToken, address _toToken, uint256 _amount) public constant returns (uint256 amount);\n    function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 amount);\n}\n\n// File: 22May2017/solidity/contracts/IOwned.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Owned contract interface\n*/\ncontract IOwned {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function owner() public constant returns (address owner) { owner; }\n}\n\n// File: 22May2017/solidity/contracts/IERC20Token.sol\n\npragma solidity ^0.4.11;\n\n/*\n    ERC20 Standard Token interface\n*/\ncontract IERC20Token {\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\n    function name() public constant returns (string name) { name; }\n    function symbol() public constant returns (string symbol) { symbol; }\n    function decimals() public constant returns (uint8 decimals) { decimals; }\n    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\n// File: 22May2017/solidity/contracts/ISmartToken.sol\n\npragma solidity ^0.4.11;\n\n\n\n\n/*\n    Smart Token interface\n*/\ncontract ISmartToken is IOwned, IERC20Token {\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n    function changer() public constant returns (ITokenChanger changer) { changer; }\n\n    function disableTransfers(bool _disable) public;\n    function issue(address _to, uint256 _amount) public;\n    function destroy(address _from, uint256 _amount) public;\n    function setChanger(ITokenChanger _changer) public;\n}\n\n// File: 22May2017/solidity/contracts/IBancorFormula.sol\n\npragma solidity ^0.4.11;\n\n/*\n    Bancor Formula interface\n*/\ncontract IBancorFormula {\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint16 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\n}\n\n// File: 22May2017/solidity/contracts/BancorChanger.sol\n\npragma solidity ^0.4.11;\n\n\n\n\n\n/*\n    Open issues:\n    - Add miner front-running attack protection. The issue is somewhat mitigated by the use of _minReturn when changing\n    - Possibly add getters for reserve fields so that the client won't need to rely on the order in the struct\n*/\n\n/*\n    Bancor Changer v0.1\n\n    The Bancor version of the token changer, allows changing between a smart token and other ERC20 tokens and between different ERC20 tokens and themselves\n\n    ERC20 reserve token balance can be virtual, meaning that the calculations are based on the virtual balance instead of relying on\n    the actual reserve balance. This is a security mechanism that prevents the need to keep a very large (and valuable) balance in a single contract\n\n    The changer is upgradable - the token owner can replace it with a new version by calling setTokenChanger (it's also a safety mechanism in case of bugs/exploits)\n*/\ncontract BancorChanger is SafeMath, ITokenChanger {\n    struct Reserve {\n        uint256 virtualBalance;         // virtual balance\n        uint8 ratio;                    // constant reserve ratio (CRR), 1-100\n        bool isVirtualBalanceEnabled;   // true if virtual balance is enabled, false if not\n        bool isPurchaseEnabled;         // is purchase of the smart token enabled with the reserve, can be set by the token owner\n        bool isSet;                     // used to tell if the mapping element is defined\n    }\n\n    string public version = '0.1';\n    string public changerType = 'bancor';\n\n    ISmartToken public token;                       // smart token governed by the changer\n    IBancorFormula public formula;                  // bancor calculation formula contract\n    address[] public reserveTokens;                 // ERC20 standard token addresses\n    mapping (address => Reserve) public reserves;   // reserve token addresses -> reserve data\n    uint8 private totalReserveRatio = 0;            // used to prevent increasing the total reserve ratio above 100% efficiently\n\n    // triggered when a change between two tokens occurs\n    event Change(address indexed _fromToken, address indexed _toToken, address indexed _trader, uint256 _amount, uint256 _return);\n\n    /**\n        @dev constructor\n\n        @param _token      smart token governed by the changer\n        @param _formula    address of a bancor formula contract\n    */\n    function BancorChanger(ISmartToken _token, IBancorFormula _formula, IERC20Token _reserveToken, uint8 _reserveRatio)\n        validAddress(_token)\n        validAddress(_formula)\n    {\n        token = _token;\n        formula = _formula;\n\n        if (address(_reserveToken) != 0x0)\n            addReserve(_reserveToken, _reserveRatio, false);\n    }\n\n    // validates an address - currently only checks that it isn't null\n    modifier validAddress(address _address) {\n        require(_address != 0x0);\n        _;\n    }\n\n    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\n    modifier validReserve(address _address) {\n        require(reserves[_address].isSet);\n        _;\n    }\n\n    // validates a token address - verifies that the address belongs to one of the changeable tokens\n    modifier validToken(address _address) {\n        require(_address == address(token) || reserves[_address].isSet);\n        _;\n    }\n\n    // validates reserve ratio range\n    modifier validReserveRatio(uint8 _ratio) {\n        require(_ratio > 0 && _ratio <= 100);\n        _;\n    }\n\n    // verifies that an amount is greater than zero\n    modifier validAmount(uint256 _amount) {\n        require(_amount > 0);\n        _;\n    }\n\n    // allows execution by the token owner only\n    modifier tokenOwnerOnly {\n        assert(msg.sender == token.owner());\n        _;\n    }\n\n    // ensures that token changing is connected to the smart token\n    modifier active() {\n        assert(token.changer() == this);\n        _;\n    }\n\n    // ensures that token changing is not conneccted to the smart token\n    modifier inactive() {\n        assert(token.changer() != this);\n        _;\n    }\n\n    /**\n        @dev returns the number of reserve tokens defined\n\n        @return number of reserve tokens\n    */\n    function reserveTokenCount() public constant returns (uint16 count) {\n        return uint16(reserveTokens.length);\n    }\n\n    /**\n        @dev returns the number of changeable tokens supported by the contract\n        note that the number of changeable tokens is the number of reserve token, plus 1 (that represents the smart token)\n\n        @return number of changeable tokens\n    */\n    function changeableTokenCount() public constant returns (uint16 count) {\n        return reserveTokenCount() + 1;\n    }\n\n    /**\n        @dev given a changeable token index, returns the changeable token contract address\n\n        @param _tokenIndex  changeable token index\n\n        @return number of changeable tokens\n    */\n    function changeableToken(uint16 _tokenIndex) public constant returns (address tokenAddress) {\n        if (_tokenIndex == 0)\n            return token;\n        return reserveTokens[_tokenIndex - 1];\n    }\n\n    /**\n        @dev defines a new reserve for the token\n        can only be called by the token owner while the changer is inactive\n\n        @param _token                  address of the reserve token\n        @param _ratio                  constant reserve ratio, 1-100\n        @param _enableVirtualBalance   true to enable virtual balance for the reserve, false to disable it\n    */\n    function addReserve(IERC20Token _token, uint8 _ratio, bool _enableVirtualBalance)\n        public\n        tokenOwnerOnly\n        inactive\n        validAddress(_token)\n        validReserveRatio(_ratio)\n    {\n        require(_token != address(this) && _token != address(token) && !reserves[_token].isSet && totalReserveRatio + _ratio <= 100); // validate input\n\n        reserves[_token].virtualBalance = 0;\n        reserves[_token].ratio = _ratio;\n        reserves[_token].isVirtualBalanceEnabled = _enableVirtualBalance;\n        reserves[_token].isPurchaseEnabled = true;\n        reserves[_token].isSet = true;\n        reserveTokens.push(_token);\n        totalReserveRatio += _ratio;\n    }\n\n    /**\n        @dev updates one of the token reserves\n        can only be called by the token owner\n\n        @param _reserveToken           address of the reserve token\n        @param _ratio                  constant reserve ratio, 1-100\n        @param _enableVirtualBalance   true to enable virtual balance for the reserve, false to disable it\n        @param _virtualBalance         new reserve's virtual balance\n    */\n    function updateReserve(IERC20Token _reserveToken, uint8 _ratio, bool _enableVirtualBalance, uint256 _virtualBalance)\n        public\n        tokenOwnerOnly\n        validReserve(_reserveToken)\n        validReserveRatio(_ratio)\n    {\n        Reserve reserve = reserves[_reserveToken];\n        require(totalReserveRatio - reserve.ratio + _ratio <= 100); // validate input\n\n        totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;\n        reserve.ratio = _ratio;\n        reserve.isVirtualBalanceEnabled = _enableVirtualBalance;\n        reserve.virtualBalance = _virtualBalance;\n    }\n\n    /**\n        @dev disables purchasing with the given reserve token in case the reserve token got compromised\n        can only be called by the token owner\n        note that selling is still enabled regardless of this flag and it cannot be disabled by the token owner\n\n        @param _reserveToken    reserve token contract address\n        @param _disable         true to disable the token, false to re-enable it\n    */\n    function disableReservePurchases(IERC20Token _reserveToken, bool _disable)\n        public\n        tokenOwnerOnly\n        validReserve(_reserveToken)\n    {\n        reserves[_reserveToken].isPurchaseEnabled = !_disable;\n    }\n\n    /**\n        @dev returns the reserve's virtual balance if one is defined, otherwise returns the actual balance\n\n        @param _reserveToken    reserve token contract address\n\n        @return reserve balance\n    */\n    function getReserveBalance(IERC20Token _reserveToken)\n        public\n        constant\n        validReserve(_reserveToken)\n        returns (uint256 balance)\n    {\n        Reserve reserve = reserves[_reserveToken];\n        return reserve.isVirtualBalanceEnabled ? reserve.virtualBalance : _reserveToken.balanceOf(this);\n    }\n\n    /**\n        @dev allows the token owner to execute the token's issue function\n\n        @param _to         account to receive the new amount\n        @param _amount     amount to increase the supply by\n    */\n    function issueTokens(address _to, uint256 _amount) public tokenOwnerOnly {\n        token.issue(_to, _amount);\n    }\n\n    /**\n        @dev allows the token owner to execute the token's destroy function\n\n        @param _from       account to remove the new amount from\n        @param _amount     amount to decrease the supply by\n    */\n    function destroyTokens(address _from, uint256 _amount) public tokenOwnerOnly {\n        token.destroy(_from, _amount);\n    }\n\n    /**\n        @dev withdraws tokens from the reserve and sends them to an account\n        can only be called by the token owner\n\n        @param _reserveToken    reserve token contract address\n        @param _to              account to receive the new amount\n        @param _amount          amount to withdraw (in the reserve token)\n    */\n    function withdraw(IERC20Token _reserveToken, address _to, uint256 _amount)\n        public\n        tokenOwnerOnly\n        validReserve(_reserveToken)\n        validAddress(_to)\n        validAmount(_amount)\n    {\n        require(_to != address(this) && _to != address(token)); // validate input\n\n        assert(_reserveToken.transfer(_to, _amount));\n\n        // update virtual balance if relevant\n        Reserve reserve = reserves[_reserveToken];\n        if (reserve.isVirtualBalanceEnabled)\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, _amount);\n    }\n\n    /**\n        @dev sets the smart token's changer address to a different one instead of the current contract address\n        can only be called by the token owner\n        the changer can be set to null to transfer ownership from the changer to the original smart token's owner\n\n        @param _changer    new changer contract address (can also be set to 0x0 to remove the current changer)\n    */\n    function setTokenChanger(ITokenChanger _changer) public tokenOwnerOnly {\n        require(_changer != this && _changer != address(token)); // validate input\n        token.setChanger(_changer);\n    }\n\n    /**\n        @dev returns the expected return for changing a specific amount of _fromToken to _toToken\n\n        @param _fromToken  token to change from\n        @param _toToken    token to change to\n        @param _amount     amount to change, in fromToken\n\n        @return expected change return amount\n    */\n    function getReturn(address _fromToken, address _toToken, uint256 _amount)\n        public\n        constant\n        validToken(_fromToken)\n        validToken(_toToken)\n        returns (uint256 amount)\n    {\n        require(_fromToken != _toToken); // validate input\n        IERC20Token fromToken = IERC20Token(_fromToken);\n        IERC20Token toToken = IERC20Token(_toToken);\n\n        // change between the token and one of its reserves\n        if (toToken == token)\n            return getPurchaseReturn(fromToken, _amount);\n        else if (fromToken == token)\n            return getSaleReturn(toToken, _amount);\n\n        // change between 2 reserves\n        uint256 purchaseReturnAmount = getPurchaseReturn(fromToken, _amount);\n        return getSaleReturn(toToken, purchaseReturnAmount, safeAdd(token.totalSupply(), purchaseReturnAmount));\n    }\n\n    /**\n        @dev returns the expected return for buying the token for a reserve token\n\n        @param _reserveToken   reserve token contract address\n        @param _depositAmount  amount to deposit (in the reserve token)\n\n        @return expected purchase return amount\n    */\n    function getPurchaseReturn(IERC20Token _reserveToken, uint256 _depositAmount)\n        public\n        constant\n        active\n        validReserve(_reserveToken)\n        validAmount(_depositAmount)\n        returns (uint256 amount)\n    {\n        Reserve reserve = reserves[_reserveToken];\n        require(reserve.isPurchaseEnabled); // validate input\n\n        uint256 tokenSupply = token.totalSupply();\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\n        return formula.calculatePurchaseReturn(tokenSupply, reserveBalance, reserve.ratio, _depositAmount);\n    }\n\n    /**\n        @dev returns the expected return for selling the token for one of its reserve tokens\n\n        @param _reserveToken   reserve token contract address\n        @param _sellAmount     amount to sell (in the smart token)\n\n        @return expected sale return amount\n    */\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount) public constant returns (uint256 amount) {\n        return getSaleReturn(_reserveToken, _sellAmount, token.totalSupply());\n    }\n\n    /**\n        @dev changes a specific amount of _fromToken to _toToken\n\n        @param _fromToken  token to change from\n        @param _toToken    token to change to\n        @param _amount     amount to change, in fromToken\n        @param _minReturn  if the change results in an amount smaller than the minimum return, it is cancelled\n\n        @return change return amount\n    */\n    function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn)\n        public\n        validToken(_fromToken)\n        validToken(_toToken)\n        returns (uint256 amount)\n    {\n        require(_fromToken != _toToken); // validate input\n        IERC20Token fromToken = IERC20Token(_fromToken);\n        IERC20Token toToken = IERC20Token(_toToken);\n\n        // change between the token and one of its reserves\n        if (toToken == token)\n            return buy(fromToken, _amount, _minReturn);\n        else if (fromToken == token)\n            return sell(toToken, _amount, _minReturn);\n\n        // change between 2 reserves\n        uint256 purchaseAmount = buy(fromToken, _amount, 0);\n        return sell(toToken, purchaseAmount, _minReturn);\n    }\n\n    /**\n        @dev buys the token by depositing one of its reserve tokens\n\n        @param _reserveToken   reserve token contract address\n        @param _depositAmount  amount to deposit (in the reserve token)\n        @param _minReturn      if the change results in an amount smaller than the minimum return, it is cancelled\n\n        @return buy return amount\n    */\n    function buy(IERC20Token _reserveToken, uint256 _depositAmount, uint256 _minReturn) public returns (uint256 amount) {\n        amount = getPurchaseReturn(_reserveToken, _depositAmount);\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\n\n        // update virtual balance if relevant\n        Reserve reserve = reserves[_reserveToken];\n        if (reserve.isVirtualBalanceEnabled)\n            reserve.virtualBalance = safeAdd(reserve.virtualBalance, _depositAmount);\n\n        assert(_reserveToken.transferFrom(msg.sender, this, _depositAmount)); // transfer _depositAmount funds from the caller in the reserve token\n        token.issue(msg.sender, amount); // issue new funds to the caller in the smart token\n\n        Change(_reserveToken, token, msg.sender, _depositAmount, amount);\n        return amount;\n    }\n\n    /**\n        @dev sells the token by withdrawing from one of its reserve tokens\n\n        @param _reserveToken   reserve token contract address\n        @param _sellAmount     amount to sell (in the smart token)\n        @param _minReturn      if the change results in an amount smaller the minimum return, it is cancelled\n\n        @return sell return amount\n    */\n    function sell(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _minReturn) public returns (uint256 amount) {\n        require(_sellAmount <= token.balanceOf(msg.sender)); // validate input\n\n        amount = getSaleReturn(_reserveToken, _sellAmount);\n        assert(amount != 0 && amount >= _minReturn); // ensure the trade gives something in return and meets the minimum requested amount\n\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\n        assert(amount <= reserveBalance); // ensure that the trade won't result in negative reserve\n\n        uint256 tokenSupply = token.totalSupply();\n        assert(amount < reserveBalance || _sellAmount == tokenSupply); // ensure that the trade will only deplete the reserve if the total supply is depleted as well\n        token.destroy(msg.sender, _sellAmount); // destroy _sellAmount from the caller's balance in the smart token\n        assert(_reserveToken.transfer(msg.sender, amount)); // transfer funds to the caller in the reserve token\n                                                           // note that it might fail if the actual reserve balance is smaller than the virtual balance\n\n        // update virtual balance if relevant\n        Reserve reserve = reserves[_reserveToken];\n        if (reserve.isVirtualBalanceEnabled)\n            reserve.virtualBalance = safeSub(reserve.virtualBalance, amount);\n\n        // if the supply was totally depleted, disconnect from the smart token\n        if (_sellAmount == tokenSupply)\n            token.setChanger(ITokenChanger(0x0));\n\n        Change(token, _reserveToken, msg.sender, _sellAmount, amount);\n        return amount;\n    }\n\n    /**\n        @dev utility, returns the expected return for selling the token for one of its reserve tokens, given a total supply override\n\n        @param _reserveToken   reserve token contract address\n        @param _sellAmount     amount to sell (in the smart token)\n        @param _totalSupply    total token supply, overrides the actual token total supply when calculating the return\n\n        @return sale return amount\n    */\n    function getSaleReturn(IERC20Token _reserveToken, uint256 _sellAmount, uint256 _totalSupply)\n        private\n        constant\n        active\n        validReserve(_reserveToken)\n        validAmount(_sellAmount)\n        validAmount(_totalSupply)\n        returns (uint256 amount)\n    {\n        Reserve reserve = reserves[_reserveToken];\n        uint256 reserveBalance = getReserveBalance(_reserveToken);\n        return formula.calculateSaleReturn(_totalSupply, reserveBalance, reserve.ratio, _sellAmount);\n    }\n\n    // fallback\n    function() {\n        assert(false);\n    }\n}\n"
    }
  }
}