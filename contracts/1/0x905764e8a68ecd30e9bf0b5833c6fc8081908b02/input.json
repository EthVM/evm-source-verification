{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"map.sol":{"content":"pragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n// SPDX-License-Identifier: MIT\n\ninterface IERC20 {\n  function symbol() external view returns (string memory);\n\n  function name() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IMdexPair {\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this;\n    return msg.data;\n  }\n}\n\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  constructor () internal {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n  function owner() public view returns (address) {\n    return _owner;\n  }\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ow1\");\n    _;\n  }\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ow2\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, \"mul e0\");\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"div e0\");\n    uint256 c = a / b;\n    return c;\n  }\n}\n\ncontract Map is Ownable {\n  using SafeMath for uint256;\n  IERC20 private r_fee_token;\n  IERC20 private r_usdt_token;\n  IMdexPair private r_fee_pair;\n  address private r_router_address;\n  uint256 private r_tx_fee_rate;\n  uint256 private r_tx_fee_type;\n  address private r_tx_fee_address;\n\n\n  struct token_info_item {\n    address token_address;\n    string name;\n    string symbol;\n    uint256 decimals;\n    uint256 balance;\n  }\n\n  function getTokenInfo(IERC20 _token, address _user) public view returns (token_info_item memory token_info) {\n    token_info.token_address = address(_token);\n    token_info.name = _token.name();\n    token_info.symbol = _token.symbol();\n    token_info.decimals = _token.decimals();\n    token_info.balance = _token.balanceOf(_user);\n  }\n\n  function set(IERC20 _fee_token, IERC20 _usdt_token, IMdexPair _fee_pair, address _router_address, uint256 _tx_fee_rate, uint256 _tx_fee_type, address _tx_fee_address) public onlyOwner {\n    r_fee_token = _fee_token;\n    r_usdt_token = _usdt_token;\n    r_fee_pair = _fee_pair;\n    r_router_address = _router_address;\n    r_tx_fee_rate = _tx_fee_rate;\n    r_tx_fee_type = _tx_fee_type;\n    r_tx_fee_address = _tx_fee_address;\n  }\n\n  function setTxFeeRate(uint256 _tx_fee_rate) public onlyOwner {\n    r_tx_fee_rate = _tx_fee_rate;\n  }\n\n  function setTxFeeType(uint256 _tx_fee_type) public onlyOwner {\n    r_tx_fee_type = _tx_fee_type;\n  }\n\n  function getPrice() internal view returns (uint256) {\n    if (address(r_fee_pair) == address(0)) {\n      return 0;\n    }\n    address token0_new = IMdexPair(r_fee_pair).token0();\n    address token1_new = IMdexPair(r_fee_pair).token1();\n    (uint256 _reserve0,uint256  _reserve1,) = IMdexPair(r_fee_pair).getReserves();\n    uint256 decimals0 = IERC20(token0_new).decimals();\n    uint256 decimals1 = IERC20(token1_new).decimals();\n    uint256 price1 = _reserve0.mul(10 ** 18).mul(10 ** decimals1).div(_reserve1).div(10 ** decimals0);\n    uint256 price2 = _reserve1.mul(10 ** 18).mul(10 ** decimals0).div(_reserve0).div(10 ** decimals1);\n    uint256 tx_price;\n    if (token0_new == address(r_fee_token))\n      tx_price = price1;\n    else\n      tx_price = price2;\n    return tx_price;\n  }\n\n  function getFeeNum() public view returns (uint256 tx_price, uint256 tx_fee_rate, uint256 tx_fee_type, uint256 fee_token_decimals, uint256 usdt_token_decimals, IERC20 fee_token, IERC20 usdt_token, address tx_fee_address, address router_address) {\n    tx_price = getPrice();\n    tx_fee_rate = r_tx_fee_rate;\n    tx_fee_type = r_tx_fee_type;\n    fee_token_decimals = 18;\n    usdt_token_decimals = 18;\n    if (address(r_fee_token) != address(0)) {\n      fee_token_decimals = r_fee_token.decimals();\n    }\n    if (address(r_usdt_token) != address(0)) {\n      usdt_token_decimals = r_usdt_token.decimals();\n    }\n    fee_token = r_fee_token;\n    usdt_token = r_usdt_token;\n    tx_fee_address = r_tx_fee_address;\n    router_address = r_router_address;\n  }\n\n}"}}}