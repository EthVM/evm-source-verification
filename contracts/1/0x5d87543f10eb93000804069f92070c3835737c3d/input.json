{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "CandorFi 1M(WTA).sol": {
      "content": "pragma solidity ^0.6.9;\n//SPDX-License-Identifier: MIT\n\n\nlibrary SafeMathChainlink {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n\ncontract VRFRequestIDBase {\n\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n    address _requester, uint256 _nonce)\n    internal pure returns (uint256)\n  {\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  function makeRequestId(\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n\n\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n\n  using SafeMathChainlink for uint256;\n\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\n    internal virtual;\n\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\n    internal returns (bytes32 requestId)\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\n\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\n\n    nonces[_keyHash] = nonces[_keyHash].add(1);\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface immutable internal LINK;\n  address immutable private vrfCoordinator;\n\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n  constructor(address _vrfCoordinator, address _link) public {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n\ninterface IERC20 {\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n} \n\ncontract CandorFi is VRFConsumerBase{\n    uint[] private entryArray;\n    address[] public userAddresses;\n    address public owner;\n    uint public totalEntry;\n    uint public round;\n    uint public random;\n    uint public ticketPrice = 10 * 1e6; // 10$ ticket price (18 decimals)\n    uint public poolLimit = 2000000 * 1e6; // 1000000$ pool limit\n    uint public adminFee = 50; //50% admin fee\n    IERC20 public token;\n    \n    bytes32 internal keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\n\tuint internal fee;\n\tuint public randomResult;\n\tuint public oldRandomResult;\n\t\n    struct User{\n        bool isEntered;\n        uint totalEntries;\n    }\n    modifier onlyOwner{\n        require(msg.sender == owner,\"Only owner allowed\");\n        _;\n    }\n    mapping(uint => address) public entryMapping;\n    mapping(uint => mapping(address => User)) public userInfo;\n    \n    event RandomNumberGenerated(bytes32,uint256);\n    event EntryComplete(address,uint,uint);\n    event WinnerPicked(address,uint);\n    \n    function setTicketPrice(uint value) external onlyOwner{\n       ticketPrice = value; \n    }\n    \n    function setPoolLimit(uint value) external onlyOwner{\n        poolLimit = value;\n    }\n    \n    function setAdminFee(uint value) external onlyOwner{\n        adminFee = value;\n    }\n    \n    function withdrawLink(uint value) external onlyOwner {\n    \trequire(LINK.transfer(msg.sender, value), \"Unable to transfer\");\n    }\n    \n    function transferOwnership(address newOwner) external onlyOwner{\n        owner = newOwner;\n    }\n    \n    //Mainnet network\n    constructor() VRFConsumerBase (\n            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,  //VRF Coordinator\n\t        0x514910771AF9Ca656af840dff83E8264EcF986CA   //LINK token\n           ) public {\n        fee = 2000000000000000000; // 2 LINK\n        owner = msg.sender;\n        token = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC contract address\n    }\n    \n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n        randomResult = randomness;\n        emit RandomNumberGenerated(requestId,randomResult);\n    }\n    \n    function getRandomNumber() public onlyOwner returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) > fee, \"Not enough LINK - fill contract with faucet\");\n        return requestRandomness(keyHash, fee, getSeed());\n    }\n    \n    function enterLottery(uint256 amount) external {\n        require(amount >= ticketPrice && amount <= (poolLimit / 4),\"Invalid amount!\");\n        require(!userInfo[round][msg.sender].isEntered,\"Already entered!\");\n        require(token.allowance(msg.sender,address(this)) >= amount,\"Set allowance first!\");\n        bool success = token.transferFrom(msg.sender,address(this),amount);\n        require(success,\"Transfer failed\");\n        require(token.balanceOf(address(this)) <= poolLimit,\"Pool already full\");\n        uint ticketCount = amount.div(ticketPrice);\n        require((totalEntry + ticketCount) <= (poolLimit / ticketPrice),\"Buy lower amount of tickets\");\n        userInfo[round][msg.sender].totalEntries = ticketCount;\n        userInfo[round][msg.sender].isEntered = true;\n        entryArray.push(totalEntry);\n        entryMapping[totalEntry] = msg.sender; \n        totalEntry += ticketCount;\n        userAddresses.push(msg.sender);\n        emit EntryComplete(msg.sender,amount,ticketCount);\n    }\n    \n    function pickWinner() external onlyOwner{\n        require(userAddresses.length >=4,\"Atleast 4 participants\");\n        require(oldRandomResult != randomResult,\"Update random number first!\");\n        oldRandomResult = randomResult;\n        uint totalBalance = token.balanceOf(address(this));\n        uint winner = calculateWinner((randomResult.mod(totalEntry)));\n        address wonUser = entryMapping[winner];\n        token.transfer(owner,(totalBalance * adminFee) / 100);\n        totalBalance -= (totalBalance * adminFee) / 100;\n        token.transfer(wonUser,totalBalance);\n        emit WinnerPicked(wonUser,(randomResult.mod(totalEntry)));\n        totalEntry = 0;\n        entryArray = new uint[](0);\n        userAddresses = new address[](0);\n        round++;\n    }\n    \n    function getSeed() private view returns(uint) {\n\t\treturn uint(keccak256(abi.encodePacked(block.difficulty, now, userAddresses)));\n\t}\n\t\n\tfunction calculateWinner(uint target) internal view returns(uint){\n\t    uint last = entryArray.length; \n\t    uint first = 0;\n\t    uint mid = 0;\n\t    if(target <= entryArray[0]){\n\t        return entryArray[0];\n\t    }\n\t    \n\t    if(target >= entryArray[last-1]){\n\t        return entryArray[last-1];\n\t    }\n\t    \n\t    while(first < last){\n\t        mid = (first + last) / 2;\n\t        \n\t        if(entryArray[mid] == target){\n\t            return entryArray[mid];\n\t        }\n\t        \n\t        if(target < entryArray[mid]){\n\t            if(mid > 0 && target > entryArray[mid - 1]){\n\t                return entryArray[mid - 1];\n\t            }\n\t            \n\t            last = mid;\n\t        }\n\t        else{\n\t            if(mid < last - 1 && target < entryArray[mid + 1]){\n\t                return entryArray[mid];\n\t            }\n\t            \n\t            first = mid + 1;\n\t        }\n\t    }\n\t    return entryArray[mid];\n\t}\n\t\n\tfunction winningAmount() public view returns(uint amount,uint winchance){\n\t    return(\n\t        token.balanceOf(address(this)) * 8 / 10,\n\t        (userInfo[round][msg.sender].totalEntries * 100) / totalEntry);\n\t}\n\t\n\tfunction allUsers() external view returns(address[] memory){\n\t    return userAddresses;\n\t}\n\t\n\tfunction transferAnyERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n\t    require(_tokenAddress != address(token),\"Not USDT\");\n        IERC20(_tokenAddress).transfer(_to, _amount);\n    }\n\t\n}"
    }
  }
}