{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"maker2.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n// P1 - P3: OK\r\npragma solidity 0.6.12;\r\n\r\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \"SafeMath: Add Overflow\");}\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \"SafeMath: Underflow\");}\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \"SafeMath: Mul Overflow\");}\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"SafeMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \"SafeMath: Add Overflow\");}\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \"SafeMath: Underflow\");}\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    // EIP 2612\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeName(IERC20 token) internal view returns(string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeDecimals(IERC20 token) public view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: Transfer failed\");\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setMigrator(address) external;\r\n}\r\n\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\r\n// Edited by BoringCrypto\r\n\r\n// T1 - T4: OK\r\ncontract OwnableData {\r\n    // V1 - V5: OK\r\n    address public owner;\r\n    // V1 - V5: OK\r\n    address public pendingOwner;\r\n}\r\n\r\n// T1 - T4: OK\r\ncontract Ownable is OwnableData {\r\n    // E1: OK\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // C1 - C21: OK\r\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    // F1 - F9: OK\r\n    // C1 - C21: OK\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    // M1 - M5: OK\r\n    // C1 - C21: OK\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\ninterface IBentoBoxWithdraw {\r\n    function withdraw(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\ninterface IKashiWithdrawFee {\r\n    function asset() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function withdrawFees() external;\r\n    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\r\n}\r\n\r\n// SushiMakerKashi is MasterChef's left hand and kinda a wizard. He can cook up Sushi from pretty much anything!\r\n// This contract handles \"serving up\" rewards for xSushi holders by trading tokens collected from Kashi fees for Sushi.\r\ncontract SushiMakerKashi is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IUniswapV2Factory private immutable factory;\r\n    //0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\r\n    address private immutable bar;\r\n    //0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272\r\n    IBentoBoxWithdraw private immutable bentoBox;\r\n    //0xF5BCE5077908a1b7370B9ae04AdC565EBd643966 \r\n    address private immutable sushi;\r\n    //0x6B3595068778DD592e39A122f4f5a5cF09C90fE2\r\n    address private immutable weth;\r\n    //0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\r\n    bytes32 private immutable pairCodeHash;\r\n    //0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\r\n\r\n    mapping(address => address) private _bridges;\r\n\r\n    event LogBridgeSet(address indexed token, address indexed bridge);\r\n    event LogConvert(\r\n        address indexed server,\r\n        address indexed token0,\r\n        uint256 amount0,\r\n        uint256 amountBENTO,\r\n        uint256 amountSUSHI\r\n    );\r\n\r\n    constructor(\r\n        IUniswapV2Factory _factory,\r\n        address _bar,\r\n        IBentoBoxWithdraw _bentoBox,\r\n        address _sushi,\r\n        address _weth,\r\n        bytes32 _pairCodeHash\r\n    ) public {\r\n        factory = _factory;\r\n        bar = _bar;\r\n        bentoBox = _bentoBox;\r\n        sushi = _sushi;\r\n        weth = _weth;\r\n        pairCodeHash = _pairCodeHash;\r\n    }\r\n\r\n    function setBridge(address token, address bridge) external onlyOwner {\r\n        // Checks\r\n        require(\r\n            token != sushi && token != weth && token != bridge,\r\n            \"Maker: Invalid bridge\"\r\n        );\r\n        // Effects\r\n        _bridges[token] = bridge;\r\n        emit LogBridgeSet(token, bridge);\r\n    }\r\n\r\n    modifier onlyEOA() {\r\n        // Try to make flash-loan exploit harder to do by only allowing externally-owned addresses.\r\n        require(msg.sender == tx.origin, \"Maker: Must use EOA\");\r\n        _;\r\n    }\r\n\r\n    function convert(IKashiWithdrawFee kashiPair) external onlyEOA {\r\n        _convert(kashiPair);\r\n    }\r\n\r\n    function convertMultiple(IKashiWithdrawFee[] calldata kashiPair) external onlyEOA {\r\n        for (uint256 i = 0; i < kashiPair.length; i++) {\r\n            _convert(kashiPair[i]);\r\n        }\r\n    }\r\n\r\n    function _convert(IKashiWithdrawFee kashiPair) private {\r\n        // update Kashi fees for this Maker contract (`feeTo`)\r\n        kashiPair.withdrawFees();\r\n\r\n        // convert updated Kashi balance to Bento shares\r\n        uint256 bentoShares = kashiPair.removeAsset(address(this), kashiPair.balanceOf(address(this)));\r\n\r\n        // convert Bento shares to underlying Kashi asset (`token0`) balance (`amount0`) for Maker\r\n        address token0 = kashiPair.asset();\r\n        (uint256 amount0, ) = bentoBox.withdraw(IERC20(token0), address(this), address(this), 0, bentoShares);\r\n\r\n        emit LogConvert(\r\n            msg.sender,\r\n            token0,\r\n            amount0,\r\n            bentoShares,\r\n            _convertStep(token0, amount0)\r\n        );\r\n    }\r\n\r\n    function _convertStep(address token0, uint256 amount0) private returns (uint256 sushiOut) {\r\n        if (token0 == sushi) {\r\n            IERC20(token0).safeTransfer(bar, amount0);\r\n            sushiOut = amount0;\r\n        } else if (token0 == weth) {\r\n            sushiOut = _swap(token0, sushi, amount0, bar);\r\n        } else {\r\n            address bridge = _bridges[token0];\r\n            if (bridge == address(0)) {\r\n                bridge = weth;\r\n            }\r\n            uint256 amountOut = _swap(token0, bridge, amount0, address(this));\r\n            sushiOut = _convertStep(bridge, amountOut);\r\n        }\r\n    }\r\n\r\n    function _swap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 amountIn,\r\n        address to\r\n    ) private returns (uint256 amountOut) {\r\n        (address token0, address token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\r\n        IUniswapV2Pair pair =\r\n            IUniswapV2Pair(\r\n                uint256(\r\n                    keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\r\n                )\r\n            );\r\n        \r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        \r\n        if (toToken > fromToken) {\r\n            amountOut =\r\n                amountInWithFee.mul(reserve1) /\r\n                reserve0.mul(1000).add(amountInWithFee);\r\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\r\n            pair.swap(0, amountOut, to, \"\");\r\n        } else {\r\n            amountOut =\r\n                amountInWithFee.mul(reserve0) /\r\n                reserve1.mul(1000).add(amountInWithFee);\r\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\r\n            pair.swap(amountOut, 0, to, \"\");\r\n        }\r\n    }\r\n}"}}}