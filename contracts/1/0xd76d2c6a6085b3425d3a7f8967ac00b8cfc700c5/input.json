{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LCtoken.sol": {
      "content": "/**\r\n * LiquidCraft Token\r\n *\r\n * author: Solulab Inc. - Parth Kaloliya\r\n *\r\n * This is a rewrite of Safemoon contract in the hope to:\r\n *\r\n * - make it easier to change the tokenomics\r\n * - make it easier to maintain the code and develop it further\r\n * - remove redundant code\r\n * - fix some of the issues reported in the Safemoon audit\r\n *      https://www.certik.org/projects/safemoon\r\n *\r\n * SPDX-License-Identifier: UNLICENSED\r\n */\r\n\r\npragma solidity 0.8.0;\r\n\r\ninterface IBEP20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the token name.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the bep token owner.\r\n   */\r\n  function getOwner() external view returns (address);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address _owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a + b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a * b;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a % b;\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b <= a, errorMessage);\r\n      return a - b;\r\n    }\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(\r\n      success,\r\n      'Address: unable to send value, recipient may have reverted'\r\n    );\r\n  }\r\n\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, 'Address: low-level call failed');\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        'Address: low-level call with value failed'\r\n      );\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      'Address: insufficient balance for call'\r\n    );\r\n    require(isContract(target), 'Address: call to non-contract');\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, 'Address: low-level static call failed');\r\n  }\r\n\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), 'Address: static call to non-contract');\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionDelegateCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionDelegateCall(\r\n        target,\r\n        data,\r\n        'Address: low-level delegate call failed'\r\n      );\r\n  }\r\n\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), 'Address: delegate call to non-contract');\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n  address private _previousOwner;\r\n  uint256 private _lockTime;\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  function getUnlockTime() public view returns (uint256) {\r\n    return _lockTime;\r\n  }\r\n\r\n  function lock(uint256 time) public virtual onlyOwner {\r\n    _previousOwner = _owner;\r\n    _owner = address(0);\r\n    _lockTime = block.timestamp + time;\r\n    emit OwnershipTransferred(_owner, address(0));\r\n  }\r\n\r\n  function unlock() public virtual {\r\n    require(\r\n      _previousOwner == msg.sender,\r\n      'Only the previous owner can unlock onwership'\r\n    );\r\n    require(block.timestamp > _lockTime, 'The contract is still locked');\r\n    emit OwnershipTransferred(_owner, _previousOwner);\r\n    _owner = _previousOwner;\r\n  }\r\n}\r\n\r\nabstract contract Manageable is Context {\r\n  address private _manager;\r\n\r\n  event ManagementTransferred(\r\n    address indexed previousManager,\r\n    address indexed newManager\r\n  );\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _manager = msgSender;\r\n    emit ManagementTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function manager() external view returns (address) {\r\n    return _manager;\r\n  }\r\n\r\n  modifier onlyManager() {\r\n    require(_manager == _msgSender(), 'Manageable: caller is not the manager');\r\n    _;\r\n  }\r\n\r\n  function transferManagement(address newManager) external virtual onlyManager {\r\n    require(newManager != address(0), 'New Manager address should not be zero');\r\n    emit ManagementTransferred(_manager, newManager);\r\n    _manager = newManager;\r\n  }\r\n}\r\n\r\n/**\r\n * ****************************************\r\n *\r\n * Tokenomics:\r\n *\r\n * Token Name   - LiquidCraft Token\r\n * Token Symbol - CRAFT\r\n * Token Supply - 100M (Million)\r\n *\r\n * ****************************************\r\n *\r\n * Transaction Tax\r\n *\r\n * Buyer's Tax Breakdown\r\n *\r\n * Total                       3.0%\r\n *  Rewards                     0.5%\r\n *  Burn                        0.5%\r\n *  MarketingAndOperatingWallet 1.0%\r\n *  SupplierWallet              1.0%\r\n *\r\n * Seller's Tax Breakdown\r\n * Tax varies depending upon the amount of CRAFT tokens held\r\n *\r\n * TokenBalance < 8,000 ---------------- 2.0%\r\n * 8,000 >= TokenBalance < 15,000 ------ 1.5%\r\n * 15,000 >= TokenBalance < 20,000 ----- 1.0%\r\n * 20,000 >= TokenBalance < 100,000 ---- 0.2%\r\n * TokenBalance >= 100,000 -------------- 0%\r\n *\r\n * ****************************************\r\n */\r\n\r\n/**\r\n *\r\n * If you wish to disable a particular tax/fee just set it to zero (or comment it out/remove it).\r\n *\r\n * You can add (in theory) as many custom taxes/fees with dedicated wallet addresses if you want.\r\n * Nevertheless, I do not recommend using more than a few as the contract has not been tested\r\n * for more than the original number of taxes/fees, which is 4 (redistribution, burn,\r\n * company and community). Furthermore, exchanges may impose a limit on the total\r\n * transaction fee (so that, for example, you cannot claim 100%). Usually this is done by limiting the\r\n * max value of slippage, for example, PancakeSwap max slippage is 49.9% and the fees total of more than\r\n * 35% will most likely fail there.\r\n *\r\n * NOTE: You shouldn't really remove the Rfi fee. If you do not wish to use RFI for your token,\r\n * you shouldn't be using this contract at all (you're just wasting gas if you do).\r\n *\r\n */\r\nabstract contract Tokenomics {\r\n  using SafeMath for uint256;\r\n\r\n  // --------------------- Token Settings ------------------- //\r\n\r\n  string internal constant NAME = 'LiquidCraft Token';\r\n  string internal constant SYMBOL = 'CRAFT';\r\n\r\n  uint16 internal constant FEES_DIVISOR = 10**4;\r\n  uint8 internal constant DECIMALS = 18;\r\n  uint256 internal constant ZEROES = 10**DECIMALS;\r\n\r\n  uint256 private constant MAX = ~uint256(0);\r\n  uint256 internal constant TOTAL_SUPPLY = 100 * 10**6 * ZEROES; // 100 Million i.e. 100 * 10**6\r\n  uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\r\n\r\n  // --------------------- Fees Settings ------------------- //\r\n\r\n  /**\r\n   * @dev To add/edit/remove fees scroll down to the `addFees` function below\r\n   */\r\n  address internal constant burnAddress =\r\n    0x000000000000000000000000000000000000dEaD;\r\n  address internal constant marketingAndOperatingWallet =\r\n    0x74A892AA1fc6c8C44018cDd16a597fb7151195d8;\r\n  address internal constant supplierWallet =\r\n    0x841eE81FF407Ba5504e103D15D8028116391810d;\r\n\r\n  enum FeeType {\r\n    Rfi,\r\n    Burn,\r\n    MarketingAndOperating,\r\n    Supplier\r\n  }\r\n\r\n  struct Fee {\r\n    FeeType name;\r\n    uint256 value;\r\n    address recipient;\r\n    uint256 total;\r\n  }\r\n  Fee[] public fees;\r\n\r\n  uint256 private sumOfFees;\r\n\r\n  constructor() {\r\n    _addFees();\r\n  }\r\n\r\n  function _addFee(\r\n    FeeType name,\r\n    uint256 value,\r\n    address recipient\r\n  ) private {\r\n    fees.push(Fee(name, value, recipient, 0));\r\n    sumOfFees += value;\r\n  }\r\n\r\n  function _addFees() private {\r\n    /**\r\n     * The RFI recipient is ignored but we need to give a valid address value\r\n     *\r\n     * CAUTION: If you don't want to use RFI this implementation isn't really for you!\r\n     *      There are much more efficient and cleaner token contracts without RFI\r\n     *      so you should use one of those\r\n     *\r\n     * The value of fees is given in part per 10,000 (based on the value of FEES_DIVISOR),\r\n     * e.g. for 1% use 100, for 0.5% use 50, etc.\r\n     */\r\n    _addFee(FeeType.Rfi, 50, address(this));\r\n\r\n    _addFee(FeeType.Burn, 50, burnAddress);\r\n    _addFee(FeeType.MarketingAndOperating, 100, marketingAndOperatingWallet);\r\n    _addFee(FeeType.Supplier, 100, supplierWallet);\r\n  }\r\n\r\n  function _getFeesCount() internal view returns (uint256) {\r\n    return fees.length;\r\n  }\r\n\r\n  function _getFeeStruct(uint256 index) private view returns (Fee storage) {\r\n    require(\r\n      index >= 0 && index < fees.length,\r\n      'FeesSettings._getFeeStruct: Fee index out of bounds'\r\n    );\r\n    return fees[index];\r\n  }\r\n\r\n  function _getFee(uint256 index)\r\n    internal\r\n    view\r\n    returns (\r\n      FeeType,\r\n      uint256,\r\n      address,\r\n      uint256\r\n    )\r\n  {\r\n    Fee memory fee = _getFeeStruct(index);\r\n    return (fee.name, fee.value, fee.recipient, fee.total);\r\n  }\r\n\r\n  function getFeeTotal() internal view returns (uint256) {\r\n    return sumOfFees;\r\n  }\r\n\r\n  function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\r\n    Fee storage fee = _getFeeStruct(index);\r\n    fee.total = fee.total.add(amount);\r\n  }\r\n\r\n  function getCollectedFeeTotal(uint256 index) internal view returns (uint256) {\r\n    Fee memory fee = _getFeeStruct(index);\r\n    return fee.total;\r\n  }\r\n}\r\n\r\n/**\r\n * The fee tokenomics start after the token auction. To achive this, a \"isInPresale\" flag is used.\r\n * As soon as the auction ends, the contract manager can set this value to false. This will start\r\n * fee deduction as per as per the tokenomics mentioned above.\r\n */\r\nabstract contract Presaleable is Manageable {\r\n  bool public isInPresale = false;\r\n\r\n  function setPresaleableEnabled(bool value) external onlyManager {\r\n    isInPresale = value;\r\n  }\r\n}\r\n\r\n/**\r\n * This is the modified version of Safemoon contract.\r\n * For a modular approach, multiple inheritance is used.\r\n *\r\n * @dev This contract implements only the reflection logic as used in deflationary tokens. You can\r\n * refer to Reflect Finance at 'https://github.com/reflectfinance'. All the other functionalties\r\n * as per the business logic of our application have been implemented in the \"CinemaDraftToken\"\r\n * contract.\r\n */\r\nabstract contract ReflectionToken is IBEP20, Ownable, Presaleable, Tokenomics {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  mapping(address => uint256) internal _reflectedBalances;\r\n  mapping(address => uint256) internal _balances;\r\n  mapping(address => mapping(address => uint256)) internal _allowances;\r\n\r\n  mapping(address => bool) internal _isExcludedFromFee;\r\n  mapping(address => bool) internal _isExcludedFromRewards;\r\n  address[] private _excluded;\r\n\r\n  constructor() {\r\n    _reflectedBalances[owner()] = _reflectedSupply;\r\n\r\n    // exclude owner and this contract from fee\r\n    _isExcludedFromFee[owner()] = true;\r\n    _isExcludedFromFee[address(this)] = true;\r\n\r\n    // exclude the owner and this contract from rewards\r\n    _exclude(owner());\r\n    _exclude(address(this));\r\n\r\n    emit Transfer(address(0), owner(), TOTAL_SUPPLY);\r\n  }\r\n\r\n  /** Functions required by IBEP20 **/\r\n\r\n  function name() external pure override returns (string memory) {\r\n    return NAME;\r\n  }\r\n\r\n  function symbol() external pure override returns (string memory) {\r\n    return SYMBOL;\r\n  }\r\n\r\n  function decimals() external pure override returns (uint8) {\r\n    return DECIMALS;\r\n  }\r\n\r\n  function totalSupply() external pure override returns (uint256) {\r\n    return TOTAL_SUPPLY;\r\n  }\r\n\r\n  function getOwner() external view override returns (address) {\r\n    return owner();\r\n  }\r\n\r\n  function balanceOf(address account) public view override returns (uint256) {\r\n    if (_isExcludedFromRewards[account]) return _balances[account];\r\n    return tokenFromReflection(_reflectedBalances[account]);\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    external\r\n    override\r\n    returns (bool)\r\n  {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount)\r\n    external\r\n    override\r\n    returns (bool)\r\n  {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(\r\n      sender,\r\n      _msgSender(),\r\n      _allowances[sender][_msgSender()].sub(\r\n        amount,\r\n        'ERC20: transfer amount exceeds allowance'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /** Functions required by IBEP20 - END **/\r\n\r\n  /**\r\n   * @dev this is really a \"soft\" burn (total supply is not reduced). RFI holders\r\n   * get two benefits from burning tokens:\r\n   *\r\n   * 1) Tokens in the burn address increase the % of tokens held by holders not\r\n   *    excluded from rewards\r\n   * 2) Tokens in the burn address cannot be sold (which in turn causes deflation)\r\n   *\r\n   *\r\n   * In RFI holders already get % of each transaction so the value of their tokens\r\n   * increases (in a way). Therefore there is really no need to do a \"hard\" burn\r\n   * (reduce the total supply). What matters (in RFI) is to make sure that a large\r\n   * amount of tokens cannot be sold = increasing the intrinsic value of tokens.\r\n   * For this purpose, transfering tokens to a (vanity) burn address is the\r\n   * most appropriate way to \"burn\".\r\n   *\r\n   * There is an extra check placed into the `transfer` function to make sure the\r\n   * burn address cannot withdraw the tokens is has (although the chance of someone\r\n   * having/finding the private key is virtually zero).\r\n   */\r\n  function burn(uint256 amount) external {\r\n    address sender = _msgSender();\r\n    require(\r\n      sender != address(0),\r\n      'ReflectionToken: burn from the zero address'\r\n    );\r\n    require(\r\n      sender != address(burnAddress),\r\n      'ReflectionToken: burn from the burn address'\r\n    );\r\n\r\n    uint256 balance = balanceOf(sender);\r\n    require(balance >= amount, 'ReflectionToken: burn amount exceeds balance');\r\n\r\n    uint256 reflectedAmount = amount.mul(_getCurrentRate());\r\n\r\n    // remove the amount from the sender's balance first\r\n    _reflectedBalances[sender] = _reflectedBalances[sender].sub(\r\n      reflectedAmount\r\n    );\r\n    if (_isExcludedFromRewards[sender])\r\n      _balances[sender] = _balances[sender].sub(amount);\r\n\r\n    _burnTokens(sender, amount, reflectedAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev \"Soft\" burns the specified amount of tokens by sending them\r\n   * to the burn address\r\n   */\r\n  function _burnTokens(\r\n    address sender,\r\n    uint256 tBurn,\r\n    uint256 rBurn\r\n  ) internal {\r\n    /**\r\n     * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\r\n     * tokens to the burn address (which should be excluded from rewards) is sufficient\r\n     * in RFI\r\n     */\r\n    _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(\r\n      rBurn\r\n    );\r\n    if (_isExcludedFromRewards[burnAddress])\r\n      _balances[burnAddress] = _balances[burnAddress].add(tBurn);\r\n\r\n    /**\r\n     * @dev Emit the event so that the burn address balance is updated (on bscscan)\r\n     */\r\n    emit Transfer(sender, burnAddress, tBurn);\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender].add(addedValue)\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender].sub(\r\n        subtractedValue,\r\n        'ERC20: decreased allowance below zero'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates and returns the reflected amount for the given amount with or without\r\n   * the transfer fees (deductTransferFee true/false)\r\n   */\r\n  function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(tAmount <= TOTAL_SUPPLY, 'Amount must be less than supply');\r\n    if (!deductTransferFee) {\r\n      (uint256 rAmount, , , , ) = _getValues(tAmount, 0);\r\n      return rAmount;\r\n    } else {\r\n      (, uint256 rTransferAmount, , , ) = _getValues(tAmount, getFeeTotal());\r\n      return rTransferAmount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\r\n   */\r\n  function tokenFromReflection(uint256 rAmount)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(\r\n      rAmount <= _reflectedSupply,\r\n      'Amount must be less than total reflections'\r\n    );\r\n    uint256 currentRate = _getCurrentRate();\r\n    return rAmount.div(currentRate);\r\n  }\r\n\r\n  function excludeFromReward(address account) external onlyOwner {\r\n    require(\r\n      !_isExcludedFromRewards[account],\r\n      'Account is already excluded from rewards'\r\n    );\r\n    _exclude(account);\r\n  }\r\n\r\n  function _exclude(address account) internal {\r\n    if (_reflectedBalances[account] > 0) {\r\n      _balances[account] = tokenFromReflection(_reflectedBalances[account]);\r\n    }\r\n    _isExcludedFromRewards[account] = true;\r\n    _excluded.push(account);\r\n  }\r\n\r\n  function isExcludedFromReward(address account) external view returns (bool) {\r\n    return _isExcludedFromRewards[account];\r\n  }\r\n\r\n  function includeInReward(address account) external onlyOwner {\r\n    require(\r\n      _isExcludedFromRewards[account],\r\n      'Account is already included in rewards'\r\n    );\r\n    for (uint256 i = 0; i < _excluded.length; i++) {\r\n      if (_excluded[i] == account) {\r\n        _excluded[i] = _excluded[_excluded.length - 1];\r\n        _balances[account] = 0;\r\n        _isExcludedFromRewards[account] = false;\r\n        _excluded.pop();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function setExcludedFromFee(address account, bool value) external onlyOwner {\r\n    _isExcludedFromFee[account] = value;\r\n  }\r\n\r\n  function isExcludedFromFee(address account) external view returns (bool) {\r\n    return _isExcludedFromFee[account];\r\n  }\r\n\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal {\r\n    require(\r\n      owner != address(0),\r\n      'ReflectionToken: approve from the zero address'\r\n    );\r\n    require(\r\n      spender != address(0),\r\n      'ReflectionToken: approve to the zero address'\r\n    );\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function _transfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) private {\r\n    require(\r\n      sender != address(0),\r\n      'ReflectionToken: transfer from the zero address'\r\n    );\r\n    require(\r\n      recipient != address(0),\r\n      'ReflectionToken: transfer to the zero address'\r\n    );\r\n    require(\r\n      sender != address(burnAddress),\r\n      'ReflectionToken: transfer from the burn address'\r\n    );\r\n    require(\r\n      amount > 0,\r\n      'ReflectionToken: Transfer amount must be greater than zero'\r\n    );\r\n\r\n    // indicates whether or not fee should be deducted from the transfer\r\n    bool takeFee = true;\r\n\r\n    // holds the fees value as per recipient address, used for anti-dumping mechanism\r\n    uint256 sumOfFees = getFeeTotal();\r\n\r\n    if (isInPresale) {\r\n      takeFee = false;\r\n    }\r\n\r\n    // if any account belongs to _isExcludedFromFee account then remove the fee\r\n    if (_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\r\n      takeFee = false;\r\n    }\r\n\r\n    _transferTokens(sender, recipient, amount, takeFee, sumOfFees);\r\n  }\r\n\r\n  function _transferTokens(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount,\r\n    bool takeFee,\r\n    uint256 sumOfFees\r\n  ) private {\r\n    // We don't need to know anything about the individual fees here\r\n    // (like Safemoon does with `_getValues`). What is required\r\n    // for transfer is the sum of all fees to calculate the % of the total\r\n    // transaction amount which should be transferred to the recipient.\r\n    //\r\n    // The `_takeFees` call will/should take care of the individual fees\r\n\r\n    // uint256 sumOfFees = getFeeTotal();\r\n    if (!takeFee) {\r\n      sumOfFees = 0;\r\n    }\r\n\r\n    (uint256 rAmount, , uint256 tAmount, , uint256 currentRate) = _getValues(\r\n      amount,\r\n      sumOfFees\r\n    );\r\n\r\n    /**\r\n     * Sender's and Recipient's reflected balances must be always updated regardless of\r\n     * whether they are excluded from rewards or not.\r\n     */\r\n    _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\r\n\r\n    /**\r\n     * Update the true/nominal balances for excluded accounts\r\n     */\r\n    if (_isExcludedFromRewards[sender]) {\r\n      _balances[sender] = _balances[sender].sub(tAmount);\r\n    }\r\n\r\n    // Deduct Seller's tax\r\n    uint256 finalTransferAmount = _takeSellersTax(\r\n      recipient,\r\n      amount,\r\n      currentRate,\r\n      sumOfFees\r\n    );\r\n\r\n    // Deduct Buyer's tax\r\n    _takeBuyersTax(amount, currentRate, sumOfFees);\r\n\r\n    emit Transfer(sender, recipient, finalTransferAmount);\r\n  }\r\n\r\n  function _takeBuyersTax(\r\n    uint256 amount,\r\n    uint256 currentRate,\r\n    uint256 sumOfFees\r\n  ) private {\r\n    if (sumOfFees > 0 && !isInPresale) {\r\n      _takeTransactionFees(amount, currentRate);\r\n    }\r\n  }\r\n\r\n  function _getValues(uint256 tAmount, uint256 feesSum)\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\r\n    uint256 tTransferAmount = tAmount.sub(tTotalFees);\r\n    uint256 currentRate = _getCurrentRate();\r\n    uint256 rAmount = tAmount.mul(currentRate);\r\n    uint256 rTotalFees = tTotalFees.mul(currentRate);\r\n    uint256 rTransferAmount = rAmount.sub(rTotalFees);\r\n\r\n    return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\r\n  }\r\n\r\n  function _getCurrentRate() internal view returns (uint256) {\r\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n    return rSupply.div(tSupply);\r\n  }\r\n\r\n  function _getCurrentSupply() internal view returns (uint256, uint256) {\r\n    uint256 rSupply = _reflectedSupply;\r\n    uint256 tSupply = TOTAL_SUPPLY;\r\n\r\n    /**\r\n     * The code below removes balances of addresses excluded from rewards from\r\n     * rSupply and tSupply, which effectively increases the % of transaction fees\r\n     * delivered to non-excluded holders\r\n     */\r\n    for (uint256 i = 0; i < _excluded.length; i++) {\r\n      if (\r\n        _reflectedBalances[_excluded[i]] > rSupply ||\r\n        _balances[_excluded[i]] > tSupply\r\n      ) return (_reflectedSupply, TOTAL_SUPPLY);\r\n      rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\r\n      tSupply = tSupply.sub(_balances[_excluded[i]]);\r\n    }\r\n    if (tSupply == 0 || rSupply < _reflectedSupply.div(TOTAL_SUPPLY))\r\n      return (_reflectedSupply, TOTAL_SUPPLY);\r\n    return (rSupply, tSupply);\r\n  }\r\n\r\n  /**\r\n   * @dev Redistributes the specified amount among the current holders via the reflect.finance\r\n   * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\r\n   * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`.\r\n   * This is the bit of clever math which allows rfi to redistribute the fee without\r\n   * having to iterate through all holders.\r\n   *\r\n   */\r\n  function _redistribute(\r\n    uint256 amount,\r\n    uint256 currentRate,\r\n    uint256 fee,\r\n    uint256 index\r\n  ) internal {\r\n    uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\r\n    uint256 rFee = tFee.mul(currentRate);\r\n\r\n    _reflectedSupply = _reflectedSupply.sub(rFee);\r\n    _addFeeCollectedAmount(index, tFee);\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before the Seller Tax is charged for the recipient\r\n   */\r\n  function _takeTransactionFees(uint256 amount, uint256 currentRate)\r\n    internal\r\n    virtual;\r\n\r\n  /**\r\n   * @dev Hook that is called before the Transfer event is emitted\r\n   */\r\n  function _takeSellersTax(\r\n    address seller,\r\n    uint256 amount,\r\n    uint256 currentRate,\r\n    uint256 sumOfFees\r\n  ) internal virtual returns (uint256);\r\n}\r\n\r\ncontract LiquidCraftToken is ReflectionToken {\r\n  using SafeMath for uint256;\r\n\r\n  function _takeTransactionFees(uint256 amount, uint256 currentRate)\r\n    internal\r\n    override\r\n  {\r\n    if (isInPresale) {\r\n      return;\r\n    }\r\n\r\n    uint256 feesCount = _getFeesCount();\r\n    for (uint256 index = 0; index < feesCount; index++) {\r\n      (FeeType name, uint256 value, address recipient, ) = _getFee(index);\r\n      // no need to check value < 0 as the value is uint (i.e. from 0 to 2^256-1)\r\n      if (value == 0) continue;\r\n\r\n      if (name == FeeType.Rfi) {\r\n        _redistribute(amount, currentRate, value, index);\r\n      } else if (name == FeeType.Burn) {\r\n        _burn(amount, currentRate, value, index);\r\n      } else if (name == FeeType.MarketingAndOperating) {\r\n        _takeFee(amount, currentRate, value, recipient, index);\r\n      } else {\r\n        _takeFee(amount, currentRate, value, recipient, index);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _takeSellersTax(\r\n    address seller,\r\n    uint256 amount,\r\n    uint256 currentRate,\r\n    uint256 sumOfFees\r\n  ) internal override returns (uint256) {\r\n    if (sumOfFees > 0 && !isInPresale) {\r\n      uint256 sellerTaxRate;\r\n      uint256 sellerBalance = balanceOf(seller);\r\n\r\n      if (sellerBalance < 8000 * ZEROES) {\r\n        sellerTaxRate = 200;\r\n      } else if (\r\n        sellerBalance >= 8000 * ZEROES && sellerBalance < 15000 * ZEROES\r\n      ) {\r\n        sellerTaxRate = 150;\r\n      } else if (\r\n        sellerBalance >= 15000 * ZEROES && sellerBalance < 20000 * ZEROES\r\n      ) {\r\n        sellerTaxRate = 20;\r\n      } else {\r\n        sellerTaxRate = 0;\r\n      }\r\n\r\n      // Distribute seller's tax to Supplier Wallet\r\n      _takeFee(amount, _getCurrentRate(), sellerTaxRate, supplierWallet, 3);\r\n\r\n      // Modify the true/reflected balance of the seller\r\n      uint256 tAmount = amount.sub(amount.mul(sellerTaxRate).div(FEES_DIVISOR));\r\n      tAmount = tAmount.sub(amount.mul(sumOfFees).div(FEES_DIVISOR));\r\n      uint256 rAmount = tAmount.mul(_getCurrentRate());\r\n\r\n      _reflectedBalances[seller] = _reflectedBalances[seller].add(rAmount);\r\n      if (_isExcludedFromRewards[seller]) {\r\n        _balances[seller] = _balances[seller].add(tAmount);\r\n      }\r\n\r\n      return tAmount;\r\n    } else {\r\n      uint256 rTransferAmount = amount.mul(currentRate);\r\n      _reflectedBalances[seller] = _reflectedBalances[seller].add(\r\n        rTransferAmount\r\n      );\r\n\r\n      if (_isExcludedFromRewards[seller]) {\r\n        _balances[seller] = _balances[seller].add(amount);\r\n      }\r\n\r\n      return amount;\r\n    }\r\n  }\r\n\r\n  function _burn(\r\n    uint256 amount,\r\n    uint256 currentRate,\r\n    uint256 fee,\r\n    uint256 index\r\n  ) private {\r\n    uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\r\n    uint256 rBurn = tBurn.mul(currentRate);\r\n\r\n    _burnTokens(address(this), tBurn, rBurn);\r\n    _addFeeCollectedAmount(index, tBurn);\r\n  }\r\n\r\n  function _takeFee(\r\n    uint256 amount,\r\n    uint256 currentRate,\r\n    uint256 fee,\r\n    address recipient,\r\n    uint256 index\r\n  ) private {\r\n    uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\r\n    uint256 rAmount = tAmount.mul(currentRate);\r\n\r\n    _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\r\n    if (_isExcludedFromRewards[recipient])\r\n      _balances[recipient] = _balances[recipient].add(tAmount);\r\n\r\n    _addFeeCollectedAmount(index, tAmount);\r\n\r\n    emit Transfer(address(this), recipient, tAmount);\r\n  }\r\n}\r\n"
    }
  }
}