{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{"NexenStakingPool.sol":{"Date":"0x1e5a9c087675922e0a76dfce6d97b133453d7e4c"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NexenStakingPool.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\nlibrary Date {\r\n    struct _Date {\r\n        uint16 year;\r\n        uint8 month;\r\n        uint8 day;\r\n    }\r\n\r\n    uint constant DAY_IN_SECONDS = 86400;\r\n    uint constant YEAR_IN_SECONDS = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n    uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n    function isLeapYear(uint16 year) public pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n                return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n                return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function leapYearsBefore(uint year) public pure returns (uint) {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                return 31;\r\n        }\r\n        else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                return 30;\r\n        }\r\n        else if (isLeapYear(year)) {\r\n                return 29;\r\n        }\r\n        else {\r\n                return 28;\r\n        }\r\n    }\r\n\r\n    function parseTimestamp(uint timestamp) internal pure returns (_Date memory dt) {\r\n        uint secondsAccountedFor = 0;\r\n        uint buf;\r\n        uint8 i;\r\n\r\n        // Year\r\n        dt.year = getYear(timestamp);\r\n        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n        // Month\r\n        uint secondsInMonth;\r\n        for (i = 1; i <= 12; i++) {\r\n                secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                        dt.month = i;\r\n                        break;\r\n                }\r\n                secondsAccountedFor += secondsInMonth;\r\n        }\r\n\r\n        // Day\r\n        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                        dt.day = i;\r\n                        break;\r\n                }\r\n                secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint16) {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n\r\n        // Year\r\n        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n        while (secondsAccountedFor > timestamp) {\r\n                if (isLeapYear(uint16(year - 1))) {\r\n                        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                }\r\n                else {\r\n                        secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                }\r\n                year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint8) {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n        uint16 i;\r\n\r\n        // Year\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n                if (isLeapYear(i)) {\r\n                        timestamp += LEAP_YEAR_IN_SECONDS;\r\n                }\r\n                else {\r\n                        timestamp += YEAR_IN_SECONDS;\r\n                }\r\n        }\r\n\r\n        // Month\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n                monthDayCounts[1] = 29;\r\n        }\r\n        else {\r\n                monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n\r\n        for (i = 1; i < month; i++) {\r\n                timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n\r\n        // Day\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n        return timestamp;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner || tx.origin == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract NexenStakingPool is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 token;\r\n    uint256 decimals = 18;\r\n    uint256 minimumStakeAmount = 1000;\r\n    address ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\r\n    \r\n    //Stats\r\n    uint256 public totalStakes = 0;\r\n    uint256 public totalStaked = 0;\r\n    uint256 public adminCanWithdraw = 0;\r\n    mapping(uint8 => uint256) public totalByLockup;\r\n\r\n    struct Stake {\r\n        bool exists;\r\n        uint256 createdOn;\r\n        uint256 initialAmount;\r\n        bool compound;\r\n        uint8 lockupPeriod;\r\n        uint256 withdrawn;\r\n        address referrer;\r\n    }\r\n    \r\n    mapping(address => Stake) public stakes;\r\n    \r\n    uint256 DEFAULT_ROI1 = 7; //0.07% daily ROI\r\n    uint256 DEFAULT_ROI2 = 14; //0.14% daily ROI\r\n    uint256 DEFAULT_ROI3 = 19; //0.19% daily ROI\r\n    uint256 DEFAULT_ROI6 = 25; //0.25% daily ROI\r\n    \r\n    bool isValidLockup1 = true;\r\n    bool isValidLockup2 = false;\r\n    bool isValidLockup3 = false;\r\n    bool isValidLockup6 = false;\r\n\r\n    struct ROI {\r\n        bool exists;\r\n        uint256 roi1;\r\n        uint256 roi2;\r\n        uint256 roi3;\r\n        uint256 roi6;\r\n    }\r\n\r\n    //Year to Month to ROI\r\n    mapping (uint256 => mapping (uint256 => ROI)) private rois;\r\n    \r\n    event NewStake(address indexed staker, uint256 totalStaked, uint8 lockupPeriod, bool compound, address referrer);\r\n    event StakeIncreasedForReferral(address indexed staker, uint256 initialAmount, uint256 delta);\r\n    event RewardsWithdrawn(address indexed staker, uint256 total);\r\n    event StakeFinished(address indexed staker, uint256 totalReturned, uint256 totalDeducted);\r\n    event TokensBurnt(address indexed staker, uint256 totalBurnt);\r\n    \r\n    constructor(IERC20 _token) public {\r\n        token = _token;\r\n    }\r\n    \r\n    function createStake(uint256 _amount, uint8 _lockupPeriod, bool _compound, address _referrer) public {\r\n        require(!stakes[msg.sender].exists, \"You already have a stake\");\r\n        require(_isValidLockupPeriod(_lockupPeriod), \"Invalid lockup period\");\r\n        require(_amount >= getMinimumStakeAmount(), \"Invalid minimum\");\r\n        \r\n        require(IERC20(token).transferFrom(msg.sender, address(this), calculateTotalWithDecimals(_amount)), \"Couldn't take the tokens\");\r\n        \r\n        if (_referrer != address(0) && stakes[_referrer].exists) {\r\n            uint256 amountToIncrease = stakes[_referrer].initialAmount.mul(1).div(100);\r\n            emit StakeIncreasedForReferral(_referrer, stakes[_referrer].initialAmount, amountToIncrease);\r\n            stakes[_referrer].initialAmount += amountToIncrease;\r\n            totalStaked = totalStaked.add(amountToIncrease); \r\n        }\r\n        else {\r\n            _referrer = ZERO_ADDRESS;\r\n        }\r\n\r\n        Stake memory stake = Stake({exists:true,\r\n                                    createdOn: now, \r\n                                    initialAmount:_amount, \r\n                                    compound:_compound, \r\n                                    lockupPeriod:_lockupPeriod, \r\n                                    withdrawn:0,\r\n                                    referrer:_referrer\r\n        });\r\n                                    \r\n        stakes[msg.sender] = stake;\r\n        totalStakes = totalStakes.add(1);\r\n        totalStaked = totalStaked.add(_amount);\r\n        totalByLockup[_lockupPeriod] += 1;\r\n        \r\n        emit NewStake(msg.sender, _amount, _lockupPeriod, _compound, _referrer);\r\n    }\r\n    \r\n    function finishStake() public {\r\n        require(stakes[msg.sender].exists, \"Invalid stake\");\r\n        \r\n        Stake memory stake = stakes[msg.sender];\r\n        \r\n        uint256 finishesOn = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\r\n        require(now > finishesOn || !stake.compound, \"Can't be finished yet\");\r\n        \r\n        uint256 totalRewards;\r\n        uint256 totalFees;\r\n        uint256 totalPenalty;\r\n        \r\n        if (stake.compound) {\r\n            totalRewards = getTotalToWidthdrawForCompounders(msg.sender); //This includes the initial amount\r\n            totalRewards = totalRewards.sub(stake.initialAmount);\r\n            totalFees = totalRewards.mul(5).div(100); //Flat fee of 5%\r\n        }\r\n        else {\r\n            if (now > finishesOn) {\r\n                totalRewards = getTotalToWidthdrawForNotCompounders(msg.sender);\r\n            }  \r\n            else {\r\n                totalRewards = getPartialToWidthdrawForNotCompounders(msg.sender, now);\r\n                //As it didn't finish, pay a fee of 10% (before first half) or 5% (after first half)\r\n                uint8 penalty = _isFirstHalf(stake.createdOn, stake.lockupPeriod) ? 10 : 5;\r\n                totalPenalty = totalRewards.mul(penalty).div(100);\r\n            }\r\n            totalFees = totalRewards.mul(2).div(100); //Flat fee of 2%\r\n        }\r\n        \r\n        uint256 totalToDeduct = totalFees.add(totalPenalty);\r\n        uint256 totalToTransfer = totalRewards.add(stake.initialAmount).sub(totalToDeduct);\r\n        \r\n        //10% of the fees are for the Admin.\r\n        adminCanWithdraw = adminCanWithdraw.add(totalToDeduct.div(10));\r\n        //The rest are burnt\r\n        uint256 totalToBurn = totalToDeduct.mul(9).div(10);\r\n        require(IERC20(token).transferFrom(address(this), ZERO_ADDRESS, calculateTotalWithDecimals(totalToBurn)), \"Couldn't burn the tokens\");\r\n        emit TokensBurnt(msg.sender, totalToBurn);\r\n\r\n        totalStakes = totalStakes.sub(1);\r\n        totalStaked = totalStaked.sub(stake.initialAmount);\r\n        totalByLockup[stake.lockupPeriod] = totalByLockup[stake.lockupPeriod].sub(1);\r\n        delete stakes[msg.sender];\r\n\r\n        require(token.transfer(msg.sender, calculateTotalWithDecimals(totalToTransfer)));\r\n        \r\n        emit StakeFinished(msg.sender, totalToTransfer, totalToDeduct);\r\n    }\r\n    \r\n    function calculateTotalWithDecimals(uint256 _amount) internal view returns (uint256) {\r\n        return _amount * 10 ** decimals;\r\n    }\r\n    \r\n    function _isFirstHalf(uint256 _createdOn, uint8 _lockupPeriod) internal view returns (bool) {\r\n        uint256 day = 60 * 60 * 24;\r\n        \r\n        if (_lockupPeriod == 1) {\r\n            return _createdOn + day.mul(15) > now;\r\n        }\r\n        if (_lockupPeriod == 2) {\r\n            return _createdOn + day.mul(30) > now;\r\n        }\r\n        if (_lockupPeriod == 3) {\r\n            return _createdOn + day.mul(45) > now;\r\n        }\r\n        return _createdOn + day.mul(90) > now;\r\n    }\r\n    \r\n    function withdraw() public {\r\n        require(stakes[msg.sender].exists, \"Invalid stake\");\r\n        require(!stakes[msg.sender].compound, \"Compounders can't withdraw before they finish their stake\");\r\n\r\n        Stake storage stake = stakes[msg.sender];\r\n        uint256 total = getPartialToWidthdrawForNotCompounders(msg.sender, now);\r\n        stake.withdrawn += total;\r\n        \r\n        require(token.transfer(msg.sender, calculateTotalWithDecimals(total)));\r\n\r\n        emit RewardsWithdrawn(msg.sender, total);\r\n    }\r\n    \r\n    function calcPartialRewardsForInitialMonth(Stake memory stake, uint8 _todayDay, Date._Date memory _initial, bool compounding) internal view returns (uint256) {\r\n        uint256 roi = getRoi(_initial.month, _initial.year, stake.lockupPeriod);\r\n        uint8 totalDays = _todayDay - _initial.day;\r\n        return calculateRewards(stake.initialAmount, totalDays, roi, compounding);\r\n    }\r\n\r\n    function calcFullRewardsForInitialMonth(Stake memory stake, Date._Date memory _initial, bool compounding) internal view returns (uint256) {\r\n        uint8 totalDays = Date.getDaysInMonth(_initial.month, _initial.year);\r\n        uint256 roi = getRoi(_initial.month, _initial.year, stake.lockupPeriod);\r\n        uint8 countDays = totalDays - _initial.day;\r\n        return calculateRewards(stake.initialAmount, countDays, roi, compounding);\r\n    }\r\n    \r\n    function calcFullRewardsForMonth(uint256 _currentTotal, uint256 _roi, uint16 _year, uint8 _month, bool compounding) internal pure returns (uint256) {\r\n        uint256 totalDays = Date.getDaysInMonth(_month, _year);\r\n        return calculateRewards(_currentTotal, totalDays, _roi, compounding);\r\n    }\r\n    \r\n    function calculateRewards(uint256 currentTotal, uint256 totalDays, uint256 roi, bool compounding) internal pure returns (uint256) {\r\n        if (compounding) {\r\n            while(totalDays > 10) {\r\n                currentTotal = currentTotal * (roi.add(1000)) ** 10 / 1000 ** 10;\r\n                totalDays -= 10;\r\n            }\r\n            return currentTotal * (roi.add(1000)) ** totalDays / 1000 ** totalDays;\r\n        }\r\n        \r\n        //Not compounding\r\n        return currentTotal.mul(totalDays).mul(roi).div(1000);\r\n    }\r\n    \r\n    //This function is meant to be called internally when finishing your stake\r\n    function getTotalToWidthdrawForNotCompounders(address _account) internal view returns (uint256) {\r\n        Stake memory stake = stakes[_account];\r\n        \r\n        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\r\n        \r\n        uint256 total = calcFullRewardsForInitialMonth(stake, initial, false);\r\n        \r\n        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\r\n        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\r\n        \r\n        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\r\n            uint8 currentMonth = initial.month + i;\r\n            uint16 currentYear = initial.year;\r\n            if (currentMonth > 12) {\r\n                currentYear += 1;\r\n                currentMonth = currentMonth % 12;\r\n            }\r\n\r\n            uint256 roi = getRoi(currentMonth, currentYear ,stake.lockupPeriod);\r\n\r\n            //This is the month it finishes on\r\n            if (currentMonth == finishes.month) {\r\n                //Calculates partial rewards for month\r\n                total += calculateRewards(stake.initialAmount, finishes.day, roi, false);\r\n                break;\r\n            }\r\n            \r\n            //This is a complete month I need to add\r\n            total += calcFullRewardsForMonth(stake.initialAmount, roi, currentYear, currentMonth, false);\r\n        }\r\n        \r\n        total = total.sub(stake.withdrawn);\r\n        return total;\r\n    }\r\n    \r\n    //This function is meant to be called internally when withdrawing as much as you can, or by the UI\r\n    function getPartialToWidthdrawForNotCompounders(address _account, uint256 _now) public view returns (uint256) {\r\n        Stake memory stake = stakes[_account];\r\n        \r\n        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\r\n        Date._Date memory today = Date.parseTimestamp(_now);\r\n        \r\n        //I am still in my first month of staking\r\n        if (initial.month == today.month) {\r\n            uint256 total = calcPartialRewardsForInitialMonth(stake, today.day, initial, false);\r\n            total = total.sub(stake.withdrawn);\r\n            return total;\r\n        }\r\n        \r\n        //I am in a month after my first month of staking\r\n        uint256 total = calcFullRewardsForInitialMonth(stake, initial, false);\r\n        \r\n        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\r\n        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\r\n        \r\n        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\r\n            uint8 currentMonth = initial.month + i;\r\n            uint16 currentYear = initial.year;\r\n            if (currentMonth > 12) {\r\n                currentYear += 1;\r\n                currentMonth = currentMonth % 12;\r\n            }\r\n\r\n            uint256 roi = getRoi(currentMonth, currentYear, stake.lockupPeriod);\r\n\r\n            //This is the month it finishes\r\n            if (currentMonth == finishes.month) {\r\n                uint8 upToDay = _getMin(finishes.day, today.day);\r\n                //Calculates partial rewards for month\r\n                total += calculateRewards(stake.initialAmount, upToDay, roi, false);\r\n                break;\r\n            }\r\n            else if (currentMonth == today.month) { // We reached the current month\r\n                //Calculates partial rewards for month\r\n                total += calculateRewards(stake.initialAmount, today.day, roi, false);\r\n                break;\r\n            }\r\n            \r\n            //This is a complete month I need to add\r\n            total += calcFullRewardsForMonth(stake.initialAmount, roi, currentYear, currentMonth, false);\r\n        }\r\n        \r\n        total = total.sub(stake.withdrawn);\r\n        return total;\r\n    }\r\n    \r\n    //This function is meant to be called internally on finishing your stake\r\n    function getTotalToWidthdrawForCompounders(address _account) internal view returns (uint256) {\r\n        Stake memory stake = stakes[_account];\r\n        \r\n        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\r\n        \r\n        uint256 total = calcFullRewardsForInitialMonth(stake, initial, true);\r\n        \r\n        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\r\n        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\r\n        \r\n        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\r\n            uint8 currentMonth = initial.month + i;\r\n            uint16 currentYear = initial.year;\r\n            if (currentMonth > 12) {\r\n                currentYear += 1;\r\n                currentMonth = currentMonth % 12;\r\n            }\r\n\r\n            uint256 roi = getRoi(currentMonth, currentYear, stake.lockupPeriod);\r\n\r\n            //This is the month it finishes on\r\n            if (currentMonth == finishes.month) {\r\n                //Calculates partial rewards for month\r\n                return calculateRewards(total, finishes.day, roi, true);\r\n            }\r\n            \r\n            //This is a complete month I need to add\r\n            total = calcFullRewardsForMonth(total, roi, currentYear, currentMonth, true);\r\n        }\r\n    }\r\n    \r\n    //This function is meant to be called from the UI\r\n    function getPartialRewardsForCompounders(address _account, uint256 _now) public view returns (uint256) {\r\n        Stake memory stake = stakes[_account];\r\n        \r\n        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\r\n        Date._Date memory today = Date.parseTimestamp(_now);\r\n        \r\n        //I am still in my first month of staking\r\n        if (initial.month == today.month) {\r\n            uint256 total = calcPartialRewardsForInitialMonth(stake, today.day, initial, true);\r\n            total = total.sub(stake.withdrawn);\r\n            return total;\r\n        }\r\n        \r\n        //I am in a month after my first month of staking\r\n        uint256 total = calcFullRewardsForInitialMonth(stake, initial, true);\r\n        \r\n        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\r\n        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\r\n        \r\n        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\r\n            uint8 currentMonth = initial.month + i;\r\n            uint16 currentYear = initial.year;\r\n            if (currentMonth > 12) {\r\n                currentYear += 1;\r\n                currentMonth = currentMonth % 12;\r\n            }\r\n\r\n            uint256 roi = getRoi(currentMonth, currentYear, stake.lockupPeriod);\r\n\r\n            //This is the month it finishes\r\n            if (currentMonth == finishes.month) {\r\n                uint8 upToDay = _getMin(finishes.day, today.day);\r\n                //Calculates partial rewards for month\r\n                return calculateRewards(total, upToDay, roi, true);\r\n            }\r\n            else if (currentMonth == today.month) { // We reached the current month\r\n                //Calculates partial rewards for month\r\n                return calculateRewards(total, today.day, roi, true);\r\n            }\r\n            \r\n            //This is a complete month I need to add\r\n            total = calcFullRewardsForMonth(total, roi, currentYear, currentMonth, true);\r\n        }\r\n    }\r\n    \r\n    function _getMin(uint8 num1, uint8 num2) internal pure returns (uint8) {\r\n        if (num1 < num2) {\r\n            return num1;\r\n        }\r\n        \r\n        return num2;\r\n    }\r\n    \r\n    function calculateFinishTimestamp(address account) public view returns (uint256) {\r\n        return _calculateFinishTimestamp(stakes[account].createdOn, stakes[account].lockupPeriod);\r\n    }\r\n    \r\n    function _calculateFinishTimestamp(uint256 _timestamp, uint8 _lockupPeriod) internal pure returns (uint256) {\r\n        uint16 year = Date.getYear(_timestamp);\r\n        uint8 month = Date.getMonth(_timestamp);\r\n        month += _lockupPeriod;\r\n        if (month > 12) {\r\n            year += 1;\r\n            month = month % 12;\r\n        }\r\n        uint8 day = Date.getDay(_timestamp);\r\n        return Date.toTimestamp(year, month, day);\r\n    }\r\n    \r\n    function _isValidLockupPeriod(uint8 n) internal view returns (bool) {\r\n        return (isValidLockup1 && n == 1) || (isValidLockup2 && n == 2) || (isValidLockup3 && n == 3) || (isValidLockup6 && n == 6);\r\n    }\r\n    \r\n    function _setValidLockups(bool _isValidLockup1, bool _isValidLockup2, bool _isValidLockup3, bool _isValidLockup6) public onlyOwner {\r\n        isValidLockup1 = _isValidLockup1;\r\n        isValidLockup2 = _isValidLockup2;\r\n        isValidLockup3 = _isValidLockup3;\r\n        isValidLockup6 = _isValidLockup6;\r\n    }\r\n    \r\n    function _adminWithdraw() public onlyOwner {\r\n        uint256 amount = adminCanWithdraw;\r\n        adminCanWithdraw = 0;\r\n        require(token.transfer(msg.sender, calculateTotalWithDecimals(amount)));\r\n    }\r\n\r\n    function _extractDESTSentByMistake(uint256 amount, address _sendTo) public onlyOwner {\r\n        require(token.transfer(_sendTo, amount));\r\n    }\r\n    \r\n    function _setMinimumStakeAmount(uint256 _minimumStakeAmount) public onlyOwner {\r\n        minimumStakeAmount = _minimumStakeAmount;\r\n    }\r\n\r\n    function getMinimumStakeAmount() public view returns (uint256) {\r\n        return minimumStakeAmount;\r\n    }\r\n    \r\n        function _setRoi(uint256 _month, uint256 _year, uint256 _roi1, uint256 _roi2, uint256 _roi3, uint256 _roi6) public onlyOwner {\r\n        require(!rois[_year][_month].exists, \"Roi already set\");\r\n        \r\n        uint256 today_year = Date.getYear(now);\r\n        uint256 today_month = Date.getMonth(now);\r\n        \r\n        require((_month >= today_month  && _year == today_year) || _year > today_year, \"You can only set it for this month or a future month\");\r\n        \r\n        rois[_year][_month].exists = true;\r\n        rois[_year][_month].roi1 = _roi1;\r\n        rois[_year][_month].roi2 = _roi2;\r\n        rois[_year][_month].roi3 = _roi3;\r\n        rois[_year][_month].roi6 = _roi6;\r\n    }\r\n    \r\n    function _setDefaultRoi(uint256 _roi1, uint256 _roi2, uint256 _roi3, uint256 _roi6) public onlyOwner {\r\n        DEFAULT_ROI1 = _roi1;\r\n        DEFAULT_ROI2 = _roi2;\r\n        DEFAULT_ROI3 = _roi3;\r\n        DEFAULT_ROI6 = _roi6;\r\n    }\r\n    \r\n    function getRoi(uint256 month, uint256 year, uint8 lockupPeriod) public view returns (uint256) {\r\n        if (rois[year][month].exists) {\r\n            if (lockupPeriod == 1) {\r\n                return rois[year][month].roi1;\r\n            }\r\n            else if (lockupPeriod == 2) {\r\n                return rois[year][month].roi2;\r\n            }\r\n            else if (lockupPeriod == 3) {\r\n                return rois[year][month].roi3;\r\n            }\r\n            else if (lockupPeriod == 6) {\r\n                return rois[year][month].roi6;\r\n            }\r\n        }\r\n        \r\n        if (lockupPeriod == 1) {\r\n            return DEFAULT_ROI1;\r\n        }\r\n        else if (lockupPeriod == 2) {\r\n            return DEFAULT_ROI2;\r\n        }\r\n        else if (lockupPeriod == 3) {\r\n            return DEFAULT_ROI3;\r\n        }\r\n        else if (lockupPeriod == 6) {\r\n            return DEFAULT_ROI6;\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n}"}}}