{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "suve.sol": {
      "content": "/// SPDX-License-Identifier: MIT\r\n/*\r\n▄▄█    ▄   ██   █▄▄▄▄ ▄█ \r\n██     █  █ █  █  ▄▀ ██ \r\n██ ██   █ █▄▄█ █▀▀▌  ██ \r\n▐█ █ █  █ █  █ █  █  ▐█ \r\n ▐ █  █ █    █   █    ▐ \r\n   █   ██   █   ▀   \r\n           ▀          */\r\n/// Special thanks to Keno and Boring for reviewing early bridge patterns.\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @notice Interface for depositing into and withdrawing from SushiBar.\r\ninterface ISushiBarBridge { \r\n    function enter(uint256 amount) external;\r\n    function leave(uint256 share) external;\r\n}\r\n\r\n/// @notice Interface for depositing into and withdrawing from Aave lending pool.\r\ninterface IAaveBridge {\r\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n\r\n    function deposit( \r\n        address asset, \r\n        uint256 amount, \r\n        address onBehalfOf, \r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    function withdraw( \r\n        address token, \r\n        uint256 amount, \r\n        address destination\r\n    ) external;\r\n}\r\n\r\n/// @notice Interface for depositing into and withdrawing from BentoBox vault.\r\ninterface IBentoBridge {\r\n    function registerProtocol() external;\r\n\r\n    function deposit( \r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    function withdraw(\r\n        IERC20 token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n}\r\n\r\n/// @notice Interface for depositing into and withdrawing from Compound finance protocol.\r\ninterface ICompoundBridge {\r\n    function underlying() external view returns (address);\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function redeem(uint redeemTokens) external returns (uint);\r\n}\r\n\r\n/// @notice Interface for Dai Stablecoin (DAI) `permit()` primitive.\r\ninterface IDaiPermit {\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\ncontract BaseBoringBatchable {\r\n    /// @dev Helper function to extract a useful revert message from a failed call.\r\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\r\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\r\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\r\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\r\n\r\n        assembly {\r\n            // Slice the sighash.\r\n            _returnData := add(_returnData, 0x04)\r\n        }\r\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\r\n    }\r\n\r\n    /// @notice Allows batched call to self (this contract).\r\n    /// @param calls An array of inputs for each call.\r\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\r\n    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.\r\n    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.\r\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\r\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\r\n    // C3: The length of the loop is fully under user control, so can't be exploited\r\n    // C7: Delegatecall is only used on the same contract, so it's safe\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\r\n        successes = new bool[](calls.length);\r\n        results = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            require(success || !revertOnFail, _getRevertMsg(result));\r\n            successes[i] = success;\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\ncontract BoringBatchable is BaseBoringBatchable {\r\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\r\n    /// Lookup `IERC20.permit`.\r\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\r\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\r\n    function permitToken(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public {\r\n        token.permit(from, to, amount, deadline, v, r, s);\r\n    }\r\n}\r\n\r\n/// @notice Contract that batches SUSHI staking and DeFi strategies.\r\ncontract Inari is BoringBatchable {\r\n    using BoringERC20 for IERC20;\r\n    \r\n    IERC20 constant sushiToken = IERC20(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2); // SUSHI token contract\r\n    address constant sushiBar = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272; // xSUSHI staking contract for SUSHI\r\n    IAaveBridge constant aave = IAaveBridge(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9); // AAVE lending pool contract for xSUSHI staking into aXSUSHI\r\n    IERC20 constant aaveSushiToken = IERC20(0xF256CC7847E919FAc9B808cC216cAc87CCF2f47a); // aXSUSHI staking contract for xSUSHI\r\n    IBentoBridge constant bento = IBentoBridge(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract\r\n    address constant crSushiToken = 0x338286C0BC081891A4Bda39C7667ae150bf5D206; // crSUSHI staking contract for SUSHI\r\n    address constant crXSushiToken = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2; // crXSUSHI staking contract for xSUSHI\r\n    address constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F; // DAI token contract\r\n    \r\n    /// @notice Initialize this Inari contract and core SUSHI strategies.\r\n    constructor() public {\r\n        bento.registerProtocol(); // register this contract with BENTO\r\n        sushiToken.approve(address(sushiBar), type(uint256).max); // max approve `sushiBar` spender to stake SUSHI into xSUSHI from this contract\r\n        sushiToken.approve(crSushiToken, type(uint256).max); // max approve `crSushiToken` spender to stake SUSHI into crSUSHI from this contract\r\n        IERC20(sushiBar).approve(address(aave), type(uint256).max); // max approve `aave` spender to stake xSUSHI into aXSUSHI from this contract\r\n        IERC20(sushiBar).approve(address(bento), type(uint256).max); // max approve `bento` spender to stake xSUSHI into BENTO from this contract\r\n        IERC20(sushiBar).approve(crXSushiToken, type(uint256).max); // max approve `crXSushiToken` spender to stake xSUSHI into crXSUSHI from this contract\r\n        IERC20(dai).approve(address(bento), type(uint256).max); // max approve `bento` spender to pull DAI into BENTO from this contract\r\n    }\r\n    \r\n    /// @notice Helper function to approve this contract to spend and bridge more tokens among DeFi contracts.\r\n    function approveTokenBridge(IERC20[] calldata underlying, address[] calldata cToken) external {\r\n        for (uint256 i = 0; i < underlying.length; i++) {\r\n            underlying[i].approve(address(aave), type(uint256).max); // max approve `aave` spender to pull `underlying` from this contract\r\n            underlying[i].approve(address(bento), type(uint256).max); // max approve `bento` spender to pull `underlying` from this contract\r\n            underlying[i].approve(cToken[i], type(uint256).max); // max approve `cToken` spender to pull `underlying` from this contract\r\n        }\r\n    }\r\n/*\r\n██   ██       ▄   ▄███▄   \r\n█ █  █ █       █  █▀   ▀  \r\n█▄▄█ █▄▄█ █     █ ██▄▄    \r\n█  █ █  █  █    █ █▄   ▄▀ \r\n   █    █   █  █  ▀███▀   \r\n  █    █     █▐           \r\n ▀    ▀      ▐         */\r\n    /**************************\r\n    AAVE -> UNDERLYING -> BENTO \r\n    **************************/\r\n    /// @notice Migrate AAVE `aToken` underlying `amount` into BENTO by batching calls to `aave` and `bento`.\r\n    function aaveToBento(address aToken, uint256 amount) external {\r\n        IERC20(aToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `aToken` `amount` into this contract\r\n        address underlying = IAaveBridge(aToken).UNDERLYING_ASSET_ADDRESS(); // sanity check for `underlying` token\r\n        aave.withdraw(underlying, amount, address(this)); // burn deposited `aToken` from `aave` into `underlying`\r\n        bento.deposit(IERC20(underlying), address(this), msg.sender, amount, 0); // stake `underlying` into BENTO for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Migrate AAVE `aToken` underlying `amount` into BENTO for benefit of `to` by batching calls to `aave` and `bento`.\r\n    function aaveToBentoTo(address aToken, address to, uint256 amount) external {\r\n        IERC20(aToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `aToken` `amount` into this contract\r\n        address underlying = IAaveBridge(aToken).UNDERLYING_ASSET_ADDRESS(); // sanity check for `underlying` token\r\n        aave.withdraw(underlying, amount, address(this)); // burn deposited `aToken` from `aave` into `underlying`\r\n        bento.deposit(IERC20(underlying), address(this), to, amount, 0); // stake `underlying` into BENTO for `to`\r\n    }\r\n    \r\n    /**************************\r\n    BENTO -> UNDERLYING -> AAVE \r\n    **************************/\r\n    /// @notice Migrate `underlying` `amount` from BENTO into AAVE by batching calls to `bento` and `aave`.\r\n    function bentoToAave(IERC20 underlying, uint256 amount) external {\r\n        bento.withdraw(underlying, msg.sender, address(this), amount, 0); // withdraw `amount` of `underlying` from BENTO into this contract\r\n        aave.deposit(address(underlying), amount, msg.sender, 0); // stake `underlying` into `aave` for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Migrate `underlying` `amount` from BENTO into AAVE for benefit of `to` by batching calls to `bento` and `aave`.\r\n    function bentoToAaveTo(IERC20 underlying, address to, uint256 amount) external {\r\n        bento.withdraw(underlying, msg.sender, address(this), amount, 0); // withdraw `amount` of `underlying` from BENTO into this contract\r\n        aave.deposit(address(underlying), amount, to, 0); // stake `underlying` into `aave` for `to`\r\n    }\r\n    \r\n    /**********************\r\n    SUSHI -> XSUSHI -> AAVE \r\n    **********************/\r\n    /// @notice Stake SUSHI `amount` into aXSUSHI by batching calls to `sushiBar` and `aave`.\r\n    function stakeSushiToAave(uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI into `sushiBar` xSUSHI\r\n        aave.deposit(sushiBar, IERC20(sushiBar).balanceOf(address(this)), msg.sender, 0); // stake resulting xSUSHI into `aave` aXSUSHI for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Stake SUSHI `amount` into aXSUSHI for benefit of `to` by batching calls to `sushiBar` and `aave`.\r\n    function stakeSushiToAaveTo(address to, uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI into `sushiBar` xSUSHI\r\n        aave.deposit(sushiBar, IERC20(sushiBar).balanceOf(address(this)), to, 0); // stake resulting xSUSHI into `aave` aXSUSHI for `to`\r\n    }\r\n    \r\n    /**********************\r\n    AAVE -> XSUSHI -> SUSHI \r\n    **********************/\r\n    /// @notice Unstake aXSUSHI `amount` into SUSHI by batching calls to `aave` and `sushiBar`.\r\n    function unstakeSushiFromAave(uint256 amount) external {\r\n        aaveSushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` aXSUSHI `amount` into this contract\r\n        aave.withdraw(sushiBar, amount, address(this)); // burn deposited aXSUSHI from `aave` into xSUSHI\r\n        ISushiBarBridge(sushiBar).leave(amount); // burn resulting xSUSHI from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(msg.sender, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Unstake aXSUSHI `amount` into SUSHI for benefit of `to` by batching calls to `aave` and `sushiBar`.\r\n    function unstakeSushiFromAaveTo(address to, uint256 amount) external {\r\n        aaveSushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` aXSUSHI `amount` into this contract\r\n        aave.withdraw(sushiBar, amount, address(this)); // burn deposited aXSUSHI from `aave` into xSUSHI\r\n        ISushiBarBridge(sushiBar).leave(amount); // burn resulting xSUSHI from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(to, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `to`\r\n    }\r\n/*\r\n███   ▄███▄      ▄     ▄▄▄▄▀ ████▄ \r\n█  █  █▀   ▀      █ ▀▀▀ █    █   █ \r\n█ ▀ ▄ ██▄▄    ██   █    █    █   █ \r\n█  ▄▀ █▄   ▄▀ █ █  █   █     ▀████ \r\n███   ▀███▀   █  █ █  ▀            \r\n              █   ██            */ \r\n    /// @notice Helper function to `permit()` this contract to deposit `dai` into `bento`.\r\n    function daiToBentoWithPermit(\r\n        uint256 amount, uint256 nonce, uint256 deadline,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    ) external {\r\n        IDaiPermit(dai).permit(msg.sender, address(this), nonce, deadline, true, v, r, s); // `permit()` this contract to spend `msg.sender` `dai` `amount`\r\n        IERC20(dai).safeTransferFrom(msg.sender, address(this), amount); // pull `dai` `amount` into this contract\r\n        bento.deposit(IERC20(dai), address(this), msg.sender, amount, 0); // stake `dai` into BENTO for `msg.sender`\r\n    }\r\n\r\n    /***********************\r\n    SUSHI -> XSUSHI -> BENTO \r\n    ***********************/\r\n    /// @notice Stake SUSHI `amount` into BENTO xSUSHI by batching calls to `sushiBar` and `bento`.\r\n    function stakeSushiToBento(uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI into `sushiBar` xSUSHI\r\n        bento.deposit(IERC20(sushiBar), address(this), msg.sender, IERC20(sushiBar).balanceOf(address(this)), 0); // stake resulting xSUSHI into BENTO for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Stake SUSHI `amount` into BENTO xSUSHI for benefit of `to` by batching calls to `sushiBar` and `bento`.\r\n    function stakeSushiToBentoTo(address to, uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI into `sushiBar` xSUSHI\r\n        bento.deposit(IERC20(sushiBar), address(this), to, IERC20(sushiBar).balanceOf(address(this)), 0); // stake resulting xSUSHI into BENTO for `to`\r\n    }\r\n    \r\n    /***********************\r\n    BENTO -> XSUSHI -> SUSHI \r\n    ***********************/\r\n    /// @notice Unstake xSUSHI `amount` from BENTO into SUSHI by batching calls to `bento` and `sushiBar`.\r\n    function unstakeSushiFromBento(uint256 amount) external {\r\n        bento.withdraw(IERC20(sushiBar), msg.sender, address(this), amount, 0); // withdraw `amount` of xSUSHI from BENTO into this contract\r\n        ISushiBarBridge(sushiBar).leave(amount); // burn withdrawn xSUSHI from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(msg.sender, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Unstake xSUSHI `amount` from BENTO into SUSHI for benefit of `to` by batching calls to `bento` and `sushiBar`.\r\n    function unstakeSushiFromBentoTo(address to, uint256 amount) external {\r\n        bento.withdraw(IERC20(sushiBar), msg.sender, address(this), amount, 0); // withdraw `amount` of xSUSHI from BENTO into this contract\r\n        ISushiBarBridge(sushiBar).leave(amount); // burn withdrawn xSUSHI from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(to, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `to`\r\n    }\r\n/*    \r\n▄█▄    █▄▄▄▄ ▄███▄   ██   █▀▄▀█ \r\n█▀ ▀▄  █  ▄▀ █▀   ▀  █ █  █ █ █ \r\n█   ▀  █▀▀▌  ██▄▄    █▄▄█ █ ▄ █ \r\n█▄  ▄▀ █  █  █▄   ▄▀ █  █ █   █ \r\n▀███▀    █   ▀███▀      █    █  \r\n        ▀              █    ▀  \r\n                      ▀      */\r\n// - COMPOUND - //\r\n    /**************************\r\n    COMP -> UNDERLYING -> BENTO \r\n    **************************/\r\n    /// @notice Migrate COMP/CREAM `cToken` underlying `amount` into BENTO by batching calls to `cToken` and `bento`.\r\n    function compoundToBento(address cToken, uint256 cTokenAmount) external {\r\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), cTokenAmount); // deposit `msg.sender` `cToken` `cTokenAmount` into this contract\r\n        ICompoundBridge(cToken).redeem(cTokenAmount); // burn deposited `cToken` into `underlying`\r\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\r\n        bento.deposit(underlying, address(this), msg.sender, underlying.balanceOf(address(this)), 0); // stake resulting `underlying` into BENTO for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Migrate COMP/CREAM `cToken` underlying `amount` into BENTO for benefit of `to` by batching calls to `cToken` and `bento`.\r\n    function compoundToBentoTo(address cToken, address to, uint256 cTokenAmount) external {\r\n        IERC20(cToken).safeTransferFrom(msg.sender, address(this), cTokenAmount); // deposit `msg.sender` `cToken` `cTokenAmount` into this contract\r\n        ICompoundBridge(cToken).redeem(cTokenAmount); // burn deposited `cToken` into `underlying`\r\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\r\n        bento.deposit(underlying, address(this), to, underlying.balanceOf(address(this)), 0); // stake resulting `underlying` into BENTO for `to`\r\n    }\r\n    \r\n    /**************************\r\n    BENTO -> UNDERLYING -> COMP \r\n    **************************/\r\n    /// @notice Migrate `cToken` `underlyingAmount` from BENTO into COMP/CREAM by batching calls to `bento` and `cToken`.\r\n    function bentoToCompound(address cToken, uint256 underlyingAmount) external {\r\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\r\n        bento.withdraw(underlying, msg.sender, address(this), underlyingAmount, 0); // withdraw `underlyingAmount` of `underlying` from BENTO into this contract\r\n        ICompoundBridge(cToken).mint(underlyingAmount); // stake `underlying` into `cToken`\r\n        IERC20(cToken).safeTransfer(msg.sender, IERC20(cToken).balanceOf(address(this))); // transfer resulting `cToken` to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Migrate `cToken` `underlyingAmount` from BENTO into COMP/CREAM for benefit of `to` by batching calls to `bento` and `cToken`.\r\n    function bentoToCompoundTo(address cToken, address to, uint256 underlyingAmount) external {\r\n        IERC20 underlying = IERC20(ICompoundBridge(cToken).underlying()); // sanity check for `underlying` token\r\n        bento.withdraw(underlying, msg.sender, address(this), underlyingAmount, 0); // withdraw `underlyingAmount` of `underlying` from BENTO into this contract\r\n        ICompoundBridge(cToken).mint(underlyingAmount); // stake `underlying` into `cToken`\r\n        IERC20(cToken).safeTransfer(to, IERC20(cToken).balanceOf(address(this))); // transfer resulting `cToken` to `to`\r\n    }\r\n    \r\n    /**********************\r\n    SUSHI -> CREAM -> BENTO \r\n    **********************/\r\n    /// @notice Stake SUSHI `amount` into crSUSHI and BENTO by batching calls to `crSushiToken` and `bento`.\r\n    function sushiToCreamToBento(uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ICompoundBridge(crSushiToken).mint(amount); // stake deposited SUSHI into crSUSHI\r\n        bento.deposit(IERC20(crSushiToken), address(this), msg.sender, IERC20(crSushiToken).balanceOf(address(this)), 0); // stake resulting crSUSHI into BENTO for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Stake SUSHI `amount` into crSUSHI and BENTO for benefit of `to` by batching calls to `crSushiToken` and `bento`.\r\n    function sushiToCreamToBentoTo(address to, uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ICompoundBridge(crSushiToken).mint(amount); // stake deposited SUSHI into crSUSHI\r\n        bento.deposit(IERC20(crSushiToken), address(this), to, IERC20(crSushiToken).balanceOf(address(this)), 0); // stake resulting crSUSHI into BENTO for `to`\r\n    }\r\n    \r\n    /**********************\r\n    BENTO -> CREAM -> SUSHI \r\n    **********************/\r\n    /// @notice Unstake crSUSHI `amount` into SUSHI from BENTO by batching calls to `bento` and `crSushiToken`.\r\n    function sushiFromCreamFromBento(uint256 amount) external {\r\n        bento.withdraw(IERC20(crSushiToken), msg.sender, address(this), amount, 0); // withdraw `amount` of `crSushiToken` from BENTO into this contract\r\n        ICompoundBridge(crSushiToken).redeem(amount); // burn deposited `crSushiToken` into SUSHI\r\n        sushiToken.safeTransfer(msg.sender, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Unstake crSUSHI `amount` into SUSHI from BENTO for benefit of `to` by batching calls to `bento` and `crSushiToken`.\r\n    function sushiFromCreamFromBentoTo(address to, uint256 amount) external {\r\n        bento.withdraw(IERC20(crSushiToken), msg.sender, address(this), amount, 0); // withdraw `amount` of `crSushiToken` from BENTO into this contract\r\n        ICompoundBridge(crSushiToken).redeem(amount); // burn deposited `crSushiToken` into SUSHI\r\n        sushiToken.safeTransfer(to, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `to`\r\n    }\r\n    \r\n    /***********************\r\n    SUSHI -> XSUSHI -> CREAM \r\n    ***********************/\r\n    /// @notice Stake SUSHI `amount` into crXSUSHI by batching calls to `sushiBar` and `crXSushiToken`.\r\n    function stakeSushiToCream(uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI `amount` into `sushiBar` xSUSHI\r\n        ICompoundBridge(crXSushiToken).mint(IERC20(sushiBar).balanceOf(address(this))); // stake resulting xSUSHI into crXSUSHI\r\n        IERC20(crXSushiToken).safeTransfer(msg.sender, IERC20(crXSushiToken).balanceOf(address(this))); // transfer resulting crXSUSHI to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Stake SUSHI `amount` into crXSUSHI for benefit of `to` by batching calls to `sushiBar` and `crXSushiToken`.\r\n    function stakeSushiToCreamTo(address to, uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI `amount` into `sushiBar` xSUSHI\r\n        ICompoundBridge(crXSushiToken).mint(IERC20(sushiBar).balanceOf(address(this))); // stake resulting xSUSHI into crXSUSHI\r\n        IERC20(crXSushiToken).safeTransfer(to, IERC20(crXSushiToken).balanceOf(address(this))); // transfer resulting crXSUSHI to `to`\r\n    }\r\n    \r\n    /***********************\r\n    CREAM -> XSUSHI -> SUSHI \r\n    ***********************/\r\n    /// @notice Unstake crXSUSHI `amount` into SUSHI by batching calls to `crXSushiToken` and `sushiBar`.\r\n    function unstakeSushiFromCream(uint256 amount) external {\r\n        IERC20(crXSushiToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `crXSushiToken` `amount` into this contract\r\n        ICompoundBridge(crXSushiToken).redeem(amount); // burn deposited `crXSushiToken` `amount` into xSUSHI\r\n        ISushiBarBridge(sushiBar).leave(IERC20(sushiBar).balanceOf(address(this))); // burn resulting xSUSHI `amount` from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(msg.sender, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Unstake crXSUSHI `amount` into SUSHI for benefit of `to` by batching calls to `crXSushiToken` and `sushiBar`.\r\n    function unstakeSushiFromCreamTo(address to, uint256 amount) external {\r\n        IERC20(crXSushiToken).safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` `crXSushiToken` `amount` into this contract\r\n        ICompoundBridge(crXSushiToken).redeem(amount); // burn deposited `crXSushiToken` `amount` into xSUSHI\r\n        ISushiBarBridge(sushiBar).leave(IERC20(sushiBar).balanceOf(address(this))); // burn resulting xSUSHI `amount` from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(to, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `to`\r\n    }\r\n    \r\n    /********************************\r\n    SUSHI -> XSUSHI -> CREAM -> BENTO \r\n    ********************************/\r\n    /// @notice Stake SUSHI `amount` into crXSUSHI and BENTO by batching calls to `sushiBar`, `crXSushiToken` and `bento`.\r\n    function stakeSushiToCreamToBento(uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI `amount` into `sushiBar` xSUSHI\r\n        ICompoundBridge(crXSushiToken).mint(IERC20(sushiBar).balanceOf(address(this))); // stake resulting xSUSHI into crXSUSHI\r\n        bento.deposit(IERC20(crXSushiToken), address(this), msg.sender, IERC20(crXSushiToken).balanceOf(address(this)), 0); // stake resulting crXSUSHI into BENTO for `msg.sender`\r\n    }\r\n    \r\n    /// @notice Stake SUSHI `amount` into crXSUSHI and BENTO for benefit of `to` by batching calls to `sushiBar`, `crXSushiToken` and `bento`.\r\n    function stakeSushiToCreamToBentoTo(address to, uint256 amount) external {\r\n        sushiToken.safeTransferFrom(msg.sender, address(this), amount); // deposit `msg.sender` SUSHI `amount` into this contract\r\n        ISushiBarBridge(sushiBar).enter(amount); // stake deposited SUSHI `amount` into `sushiBar` xSUSHI\r\n        ICompoundBridge(crXSushiToken).mint(IERC20(sushiBar).balanceOf(address(this))); // stake resulting xSUSHI into crXSUSHI\r\n        bento.deposit(IERC20(crXSushiToken), address(this), to, IERC20(crXSushiToken).balanceOf(address(this)), 0); // stake resulting crXSUSHI into BENTO for `to`\r\n    }\r\n    \r\n    /********************************\r\n    BENTO -> CREAM -> XSUSHI -> SUSHI \r\n    ********************************/\r\n    /// @notice Unstake crXSUSHI `amount` into SUSHI from BENTO by batching calls to `bento`, `crXSushiToken` and `sushiBar`.\r\n    function unstakeSushiFromCreamFromBento(uint256 amount) external {\r\n        bento.withdraw(IERC20(crXSushiToken), msg.sender, address(this), amount, 0); // withdraw `amount` of `crXSushiToken` from BENTO into this contract\r\n        ICompoundBridge(crXSushiToken).redeem(amount); // burn deposited `crXSushiToken` `amount` into xSUSHI\r\n        ISushiBarBridge(sushiBar).leave(IERC20(sushiBar).balanceOf(address(this))); // burn resulting xSUSHI `amount` from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(msg.sender, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `msg.sender`\r\n    }\r\n    \r\n    /// @notice Unstake crXSUSHI `amount` into SUSHI from BENTO for benefit of `to` by batching calls to `bento`, `crXSushiToken` and `sushiBar`.\r\n    function unstakeSushiFromCreamFromBentoTo(address to, uint256 amount) external {\r\n        bento.withdraw(IERC20(crXSushiToken), msg.sender, address(this), amount, 0); // withdraw `amount` of `crXSushiToken` from BENTO into this contract\r\n        ICompoundBridge(crXSushiToken).redeem(amount); // burn deposited `crXSushiToken` `amount` into xSUSHI\r\n        ISushiBarBridge(sushiBar).leave(IERC20(sushiBar).balanceOf(address(this))); // burn resulting xSUSHI `amount` from `sushiBar` into SUSHI\r\n        sushiToken.safeTransfer(to, sushiToken.balanceOf(address(this))); // transfer resulting SUSHI to `to`\r\n    }\r\n}"
    }
  }
}