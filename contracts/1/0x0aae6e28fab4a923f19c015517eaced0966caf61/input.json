{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DemaxConvert.sol": {
      "content": "// Dependency file: contracts/libraries/TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// pragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n\n// Root file: contracts/DemaxConvert.sol\n\npragma solidity >=0.5.16;\n\n// import 'contracts/libraries/TransferHelper.sol';\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n}\n\ncontract DemaxConvert {\n    event ConvertETHForBNB(address indexed user, uint amount);\n    event ConvertTokenForBNB(address indexed user, address token, uint amount);\n    event CollectETH(uint amount);\n    event CollectToken(address token, uint amount);\n    \n    address public owner;\n    address public wallet;\n    \n    address[] public allTokens;\n    \n    mapping (address => bool) public users;\n    \n    mapping (address => uint) public tokenLimits;\n    \n    constructor (address _wallet) public {\n        owner = msg.sender;\n        wallet = _wallet;\n    }\n    \n    function changeWallet(address _wallet) external {\n        require(msg.sender == owner, \"FORBIDDEN\");\n        wallet = _wallet;\n    }\n    \n    function enableToken(address _token, uint _limit) external{\n        require(msg.sender == owner, \"FORBIDDEN\");    \n        tokenLimits[_token] = _limit;\n        \n        bool isAdd = false;\n        for(uint i = 0;i < allTokens.length;i++) {\n            if(allTokens[i] == _token) {\n                isAdd = true;\n                break;\n            }\n        }\n        \n        if(!isAdd) {\n            allTokens.push(_token);\n        }\n    }\n    \n    function validTokens() external view returns (address[] memory) {\n        uint count;\n        for (uint i; i < allTokens.length; i++) {\n            if (tokenLimits[allTokens[i]] > 0) {\n                count++;\n            }\n        }\n        address[] memory res = new address[](count);\n        uint index = 0;\n        for (uint i; i < allTokens.length; i++) {\n            if (tokenLimits[allTokens[i]] > 0) {\n                res[index] = allTokens[i];\n                index++;\n            }\n        }\n        return res;\n    }\n    \n    function convertETHForBNB() payable external {\n        require(msg.value > 0 && msg.value <= tokenLimits[address(0)], \"INVALID_AMOUNT\");\n        require(users[msg.sender] == false, \"ALREADY_CONVERT\");\n        users[msg.sender] = true;\n        emit ConvertETHForBNB(msg.sender, msg.value);\n    }\n    \n    function convertTokenForBNB(address _token, uint _amount) external {\n        require(_amount > 0 && _amount <= tokenLimits[_token], \"INVALID_AMOUNT\");\n        require(users[msg.sender] == false, \"ALREADY_CONVERT\");\n        users[msg.sender] = true;\n        TransferHelper.safeTransferFrom(_token, msg.sender, address(this), _amount);\n        emit ConvertTokenForBNB(msg.sender, _token, _amount);\n    }\n    \n    function collect() external {\n        require(msg.sender == owner, \"FORBIDDEN\");\n        for(uint i = 0;i < allTokens.length;i++) {\n            uint balance = IERC20(allTokens[i]).balanceOf(address(this));\n            if(balance > 0) {\n                TransferHelper.safeTransfer(allTokens[i], wallet, balance);\n                emit CollectToken(allTokens[i], balance);\n            }\n        }\n        \n        if(address(this).balance > 0) {\n            emit CollectETH(address(this).balance);\n            TransferHelper.safeTransferETH(wallet, address(this).balance);\n        }\n    }\n}"
    }
  }
}