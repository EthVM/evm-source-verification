{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Tranche.sol":{"content":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/lender/tranche.sol\npragma solidity >=0.4.23 >=0.5.15 <0.6.0;\npragma experimental ABIEncoderV2;\n\n////// lib/tinlake-auth/lib/ds-note/src/note.sol\n/// note.sol -- the `note' modifier, for logging calls as events\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.4.23; */\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  guy,\n        bytes32  indexed  foo,\n        bytes32  indexed  bar,\n        uint256           wad,\n        bytes             fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        _;\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n    }\n}\n\n////// lib/tinlake-auth/src/auth.sol\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\n/* import \"ds-note/note.sol\"; */\n\ncontract Auth is DSNote {\n    mapping (address => uint) public wards;\n    function rely(address usr) public auth note { wards[usr] = 1; }\n    function deny(address usr) public auth note { wards[usr] = 0; }\n    modifier auth { require(wards[msg.sender] == 1); _; }\n}\n\n////// lib/tinlake-math/src/math.sol\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\ncontract Math {\n    uint256 constant ONE = 10 ** 27;\n\n    function safeAdd(uint x, uint y) public pure returns (uint z) {\n        require((z = x + y) >= x, \"safe-add-failed\");\n    }\n\n    function safeSub(uint x, uint y) public pure returns (uint z) {\n        require((z = x - y) <= x, \"safe-sub-failed\");\n    }\n\n    function safeMul(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"safe-mul-failed\");\n    }\n\n    function safeDiv(uint x, uint y) public pure returns (uint z) {\n        z = x / y;\n    }\n\n    function rmul(uint x, uint y) public pure returns (uint z) {\n        z = safeMul(x, y) / ONE;\n    }\n\n    function rdiv(uint x, uint y) public pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        z = safeAdd(safeMul(x, ONE), y / 2) / y;\n    }\n\n    function rdivup(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"division by zero\");\n        // always rounds up\n        z = safeAdd(safeMul(x, ONE), safeSub(y, 1)) / y;\n    }\n\n\n}\n\n////// src/fixed_point.sol\n// Copyright (C) 2020 Centrifuge\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n\ncontract FixedPoint {\n    struct Fixed27 {\n        uint value;\n    }\n}\n\n////// src/lender/tranche.sol\n// Copyright (C) 2020 Centrifuge\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.5.15 <0.6.0; */\n/* pragma experimental ABIEncoderV2; */\n\n/* import \"tinlake-auth/auth.sol\"; */\n/* import \"tinlake-math/math.sol\"; */\n/* import \"./../fixed_point.sol\"; */\n\ninterface ERC20Like_3 {\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address, address, uint) external returns (bool);\n    function mint(address, uint) external;\n    function burn(address, uint) external;\n    function totalSupply() external view returns (uint);\n    function approve(address usr, uint amount) external;\n}\n\ninterface ReserveLike_4 {\n    function deposit(uint amount) external;\n    function payout(uint amount) external;\n    function totalBalance() external returns (uint);\n}\n\ninterface EpochTickerLike {\n    function currentEpoch() external view returns (uint);\n    function lastEpochExecuted() external view returns(uint);\n}\n\ncontract Tranche is Math, Auth, FixedPoint {\n    mapping(uint => Epoch) public epochs;\n\n    struct Epoch {\n        // denominated in 10^27\n        // percentage ONE == 100%\n        Fixed27 redeemFulfillment;\n        // denominated in 10^27\n        // percentage ONE == 100%\n        Fixed27 supplyFulfillment;\n        // tokenPrice after end of epoch\n        Fixed27 tokenPrice;\n    }\n\n    struct UserOrder {\n        uint orderedInEpoch;\n        uint supplyCurrencyAmount;\n        uint redeemTokenAmount;\n    }\n\n    mapping(address => UserOrder) public users;\n\n    uint public  totalSupply;\n    uint public  totalRedeem;\n\n    ERC20Like_3 public currency;\n    ERC20Like_3 public token;\n    ReserveLike_4 public reserve;\n    EpochTickerLike public epochTicker;\n\n    address self;\n\n    bool public waitingForUpdate = false;\n\n    modifier orderAllowed(address usr) {\n        require((users[usr].supplyCurrencyAmount == 0 && users[usr].redeemTokenAmount == 0)\n        || users[usr].orderedInEpoch == epochTicker.currentEpoch(), \"disburse required\");\n        _;\n    }\n\n    constructor(address currency_, address token_) public {\n        wards[msg.sender] = 1;\n        token = ERC20Like_3(token_);\n        currency = ERC20Like_3(currency_);\n        self = address(this);\n    }\n\n    function balance() external view returns (uint) {\n        return currency.balanceOf(self);\n    }\n\n    function tokenSupply() external view returns (uint) {\n        return token.totalSupply();\n    }\n\n    function depend(bytes32 contractName, address addr) public auth {\n        if (contractName == \"token\") {token = ERC20Like_3(addr);}\n        else if (contractName == \"currency\") {currency = ERC20Like_3(addr);}\n        else if (contractName == \"reserve\") {reserve = ReserveLike_4(addr);}\n        else if (contractName == \"epochTicker\") {epochTicker = EpochTickerLike(addr);}\n        else revert();\n    }\n\n    // supplyOrder function can be used to place or revoke an supply\n    function supplyOrder(address usr, uint newSupplyAmount) public auth orderAllowed(usr) {\n        users[usr].orderedInEpoch = epochTicker.currentEpoch();\n\n        uint currentSupplyAmount = users[usr].supplyCurrencyAmount;\n\n        users[usr].supplyCurrencyAmount = newSupplyAmount;\n\n        totalSupply = safeAdd(safeTotalSub(totalSupply, currentSupplyAmount), newSupplyAmount);\n\n        if (newSupplyAmount > currentSupplyAmount) {\n            uint delta = safeSub(newSupplyAmount, currentSupplyAmount);\n            require(currency.transferFrom(usr, self, delta), \"currency-transfer-failed\");\n            return;\n        }\n        uint delta = safeSub(currentSupplyAmount, newSupplyAmount);\n        if (delta > 0) {\n            _safeTransfer(currency, usr, delta);\n        }\n    }\n\n    // redeemOrder function can be used to place or revoke a redeem\n    function redeemOrder(address usr, uint newRedeemAmount) public auth orderAllowed(usr) {\n        users[usr].orderedInEpoch = epochTicker.currentEpoch();\n\n        uint currentRedeemAmount = users[usr].redeemTokenAmount;\n        users[usr].redeemTokenAmount = newRedeemAmount;\n        totalRedeem = safeAdd(safeTotalSub(totalRedeem, currentRedeemAmount), newRedeemAmount);\n\n        if (newRedeemAmount > currentRedeemAmount) {\n            uint delta = safeSub(newRedeemAmount, currentRedeemAmount);\n            require(token.transferFrom(usr, self, delta), \"token-transfer-failed\");\n            return;\n        }\n\n        uint delta = safeSub(currentRedeemAmount, newRedeemAmount);\n        if (delta > 0) {\n            _safeTransfer(token, usr, delta);\n        }\n    }\n\n    function calcDisburse(address usr) public view returns(uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        return calcDisburse(usr, epochTicker.lastEpochExecuted());\n    }\n\n    ///  calculates the current disburse of a user starting from the ordered epoch until endEpoch\n    function calcDisburse(address usr, uint endEpoch) public view returns(uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        uint epochIdx = users[usr].orderedInEpoch;\n        uint lastEpochExecuted = epochTicker.lastEpochExecuted();\n\n        // no disburse possible in this epoch\n        if (users[usr].orderedInEpoch == epochTicker.currentEpoch()) {\n            return (payoutCurrencyAmount, payoutTokenAmount, users[usr].supplyCurrencyAmount, users[usr].redeemTokenAmount);\n        }\n\n        if (endEpoch > lastEpochExecuted) {\n            // it is only possible to disburse epochs which are already over\n            endEpoch = lastEpochExecuted;\n        }\n\n        remainingSupplyCurrency = users[usr].supplyCurrencyAmount;\n        remainingRedeemToken = users[usr].redeemTokenAmount;\n        uint amount = 0;\n\n        // calculates disburse amounts as long as remaining tokens or currency is left or the end epoch is reached\n        while(epochIdx <= endEpoch && (remainingSupplyCurrency != 0 || remainingRedeemToken != 0 )){\n            if(remainingSupplyCurrency != 0) {\n                amount = rmul(remainingSupplyCurrency, epochs[epochIdx].supplyFulfillment.value);\n                // supply currency payout in token\n                if (amount != 0) {\n                    payoutTokenAmount = safeAdd(payoutTokenAmount, safeDiv(safeMul(amount, ONE), epochs[epochIdx].tokenPrice.value));\n                    remainingSupplyCurrency = safeSub(remainingSupplyCurrency, amount);\n                }\n            }\n\n            if(remainingRedeemToken != 0) {\n                amount = rmul(remainingRedeemToken, epochs[epochIdx].redeemFulfillment.value);\n                // redeem token payout in currency\n                if (amount != 0) {\n                    payoutCurrencyAmount = safeAdd(payoutCurrencyAmount, rmul(amount, epochs[epochIdx].tokenPrice.value));\n                    remainingRedeemToken = safeSub(remainingRedeemToken, amount);\n                }\n            }\n            epochIdx = safeAdd(epochIdx, 1);\n        }\n\n        return (payoutCurrencyAmount, payoutTokenAmount, remainingSupplyCurrency, remainingRedeemToken);\n    }\n\n    // the disburse function can be used after an epoch is over to receive currency and tokens\n    function disburse(address usr) public auth returns (uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n       return disburse(usr, epochTicker.lastEpochExecuted());\n    }\n\n    function _safeTransfer(ERC20Like_3 erc20, address usr, uint amount) internal {\n        uint max = erc20.balanceOf(self);\n        if(amount > max) {\n            amount = max;\n        }\n        require(erc20.transferFrom(self, usr, amount), \"token-transfer-failed\");\n    }\n\n    // the disburse function can be used after an epoch is over to receive currency and tokens\n    function disburse(address usr,  uint endEpoch) public auth returns (uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n        require(users[usr].orderedInEpoch <= epochTicker.lastEpochExecuted(), \"epoch-not-executed-yet\");\n\n        uint lastEpochExecuted = epochTicker.lastEpochExecuted();\n\n        if (endEpoch > lastEpochExecuted) {\n            // it is only possible to disburse epochs which are already over\n            endEpoch = lastEpochExecuted;\n        }\n\n        (payoutCurrencyAmount, payoutTokenAmount,\n         remainingSupplyCurrency, remainingRedeemToken) = calcDisburse(usr, endEpoch);\n        users[usr].supplyCurrencyAmount = remainingSupplyCurrency;\n        users[usr].redeemTokenAmount = remainingRedeemToken;\n        // if lastEpochExecuted is disbursed, orderInEpoch is at the current epoch again\n        // which allows to change the order. This is only possible if all previous epochs are disbursed\n        users[usr].orderedInEpoch = safeAdd(endEpoch, 1);\n\n\n        if (payoutCurrencyAmount > 0) {\n            _safeTransfer(currency, usr, payoutCurrencyAmount);\n        }\n\n        if (payoutTokenAmount > 0) {\n            _safeTransfer(token, usr, payoutTokenAmount);\n        }\n        return (payoutCurrencyAmount, payoutTokenAmount, remainingSupplyCurrency, remainingRedeemToken);\n    }\n\n    // called by epoch coordinator in epoch execute method\n    function epochUpdate(uint epochID, uint supplyFulfillment_, uint redeemFulfillment_, uint tokenPrice_, uint epochSupplyOrderCurrency, uint epochRedeemOrderCurrency) public auth {\n        require(waitingForUpdate == true);\n        waitingForUpdate = false;\n\n        epochs[epochID].supplyFulfillment.value = supplyFulfillment_;\n        epochs[epochID].redeemFulfillment.value = redeemFulfillment_;\n        epochs[epochID].tokenPrice.value = tokenPrice_;\n\n        // currency needs to be converted to tokenAmount with current token price\n        uint redeemInToken = 0;\n        uint supplyInToken = 0;\n        if(tokenPrice_ > 0) {\n            supplyInToken = rdiv(epochSupplyOrderCurrency, tokenPrice_);\n            redeemInToken = safeDiv(safeMul(epochRedeemOrderCurrency, ONE), tokenPrice_);\n        }\n\n        // calculates the delta between supply and redeem for tokens and burn or mint them\n        adjustTokenBalance(epochID, supplyInToken, redeemInToken);\n        // calculates the delta between supply and redeem for currency and deposit or get them from the reserve\n        adjustCurrencyBalance(epochID, epochSupplyOrderCurrency, epochRedeemOrderCurrency);\n\n        // the unfulfilled orders (1-fulfillment) is automatically ordered\n        totalSupply = safeAdd(safeTotalSub(totalSupply, epochSupplyOrderCurrency), rmul(epochSupplyOrderCurrency, safeSub(ONE, epochs[epochID].supplyFulfillment.value)));\n        totalRedeem = safeAdd(safeTotalSub(totalRedeem, redeemInToken), rmul(redeemInToken, safeSub(ONE, epochs[epochID].redeemFulfillment.value)));\n    }\n    function closeEpoch() public auth returns (uint totalSupplyCurrency_, uint totalRedeemToken_) {\n        require(waitingForUpdate == false);\n        waitingForUpdate = true;\n        return (totalSupply, totalRedeem);\n    }\n\n    function safeBurn(uint tokenAmount) internal {\n        uint max = token.balanceOf(self);\n        if(tokenAmount > max) {\n            tokenAmount = max;\n        }\n        token.burn(self, tokenAmount);\n    }\n\n    function safePayout(uint currencyAmount) internal {\n        uint max = reserve.totalBalance();\n        if(currencyAmount > max) {\n            currencyAmount = max;\n        }\n        reserve.payout(currencyAmount);\n    }\n\n    // adjust token balance after epoch execution -> min/burn tokens\n    function adjustTokenBalance(uint epochID, uint epochSupplyToken, uint epochRedeemToken) internal {\n        // mint token amount for supply\n\n        uint mintAmount = 0;\n        if (epochs[epochID].tokenPrice.value > 0) {\n            mintAmount = rmul(epochSupplyToken, epochs[epochID].supplyFulfillment.value);\n        }\n\n      // burn token amount for redeem\n        uint burnAmount = rmul(epochRedeemToken, epochs[epochID].redeemFulfillment.value);\n       // burn tokens that are not needed for disbursement\n        if (burnAmount > mintAmount) {\n            uint diff = safeSub(burnAmount, mintAmount);\n            safeBurn(diff);\n            return;\n        }\n        // mint tokens that are required for disbursement\n        uint diff = safeSub(mintAmount, burnAmount);\n        if (diff > 0) {\n            token.mint(self, diff);\n        }\n    }\n\n    // additional minting of tokens produces a dilution of all token holders\n    // interface is required for adapters\n    function mint(address usr, uint amount) public auth {\n        token.mint(usr, amount);\n    }\n\n    // adjust currency balance after epoch execution -> receive/send currency from/to reserve\n    function adjustCurrencyBalance(uint epochID, uint epochSupply, uint epochRedeem) internal {\n        // currency that was supplied in this epoch\n        uint currencySupplied = rmul(epochSupply, epochs[epochID].supplyFulfillment.value);\n        // currency required for redemption\n        uint currencyRequired = rmul(epochRedeem, epochs[epochID].redeemFulfillment.value);\n\n        if (currencySupplied > currencyRequired) {\n            // send surplus currency to reserve\n            uint diff = safeSub(currencySupplied, currencyRequired);\n            currency.approve(address(reserve), diff);\n            reserve.deposit(diff);\n            return;\n        }\n        uint diff = safeSub(currencyRequired, currencySupplied);\n        if (diff > 0) {\n            // get missing currency from reserve\n            safePayout(diff);\n        }\n    }\n\n    // recovery transfer can be used by governance to recover funds if tokens are stuck\n    function authTransfer(address erc20, address usr, uint amount) public auth {\n        ERC20Like_3(erc20).transferFrom(self, usr, amount);\n    }\n\n    // due to rounding in token & currency conversions currency & token balances might be off by 1 wei with the totalSupply/totalRedeem amounts.\n    // in order to prevent an underflow error, 0 is returned when amount to be subtracted is bigger then the total value.\n    function safeTotalSub(uint total, uint amount) internal returns (uint) {\n        if (total < amount) {\n            return 0;\n        }\n        return safeSub(total, amount);\n    } \n}\n"}}}