{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "NaiveBalancerSmartPoolPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface BPool {\r\n  function getCurrentTokens() external view returns (address[] memory tokens);\r\n\r\n  function getNormalizedWeight(address token) external view returns (uint256);\r\n\r\n  function getBalance(address token) external view returns (uint256);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface ISmartBPool {\r\n  function bPool() external view returns (BPool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/************\r\n@title IPriceOracle interface\r\n@notice Interface for the Aave price oracle.*/\r\ninterface IPriceOracle {\r\n  /***********\r\n    @dev returns the asset price in ETH\r\n     */\r\n  function getAssetPrice(address _asset) external view returns (uint256);\r\n}\r\n\r\ncontract BConst {\r\n  uint256 public constant BONE = 10**18;\r\n\r\n  uint256 public constant MIN_BOUND_TOKENS = 2;\r\n  uint256 public constant MAX_BOUND_TOKENS = 8;\r\n\r\n  uint256 public constant MIN_FEE = BONE / 10**6;\r\n  uint256 public constant MAX_FEE = BONE / 10;\r\n  uint256 public constant EXIT_FEE = 0;\r\n\r\n  uint256 public constant MIN_WEIGHT = BONE;\r\n  uint256 public constant MAX_WEIGHT = BONE * 50;\r\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n  uint256 public constant MIN_BALANCE = BONE / 10**12;\r\n\r\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\r\n\r\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\r\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\r\n  uint256 public constant BPOW_PRECISION = BONE / 10**10;\r\n\r\n  uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n}\r\n\r\ncontract BNum is BConst {\r\n  function btoi(uint256 a) internal pure returns (uint256) {\r\n    return a / BONE;\r\n  }\r\n\r\n  function bfloor(uint256 a) internal pure returns (uint256) {\r\n    return btoi(a) * BONE;\r\n  }\r\n\r\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'ERR_ADD_OVERFLOW');\r\n    return c;\r\n  }\r\n\r\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    (uint256 c, bool flag) = bsubSign(a, b);\r\n    require(!flag, 'ERR_SUB_UNDERFLOW');\r\n    return c;\r\n  }\r\n\r\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\r\n    if (a >= b) {\r\n      return (a - b, false);\r\n    } else {\r\n      return (b - a, true);\r\n    }\r\n  }\r\n\r\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c0 = a * b;\r\n    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\r\n    uint256 c1 = c0 + (BONE / 2);\r\n    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\r\n    uint256 c2 = c1 / BONE;\r\n    return c2;\r\n  }\r\n\r\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, 'ERR_DIV_ZERO');\r\n    uint256 c0 = a * BONE;\r\n    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\r\n    uint256 c1 = c0 + (b / 2);\r\n    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\r\n    uint256 c2 = c1 / b;\r\n    return c2;\r\n  }\r\n\r\n  // DSMath.wpow\r\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\r\n    uint256 z = n % 2 != 0 ? a : BONE;\r\n\r\n    for (n /= 2; n != 0; n /= 2) {\r\n      a = bmul(a, a);\r\n\r\n      if (n % 2 != 0) {\r\n        z = bmul(z, a);\r\n      }\r\n    }\r\n    return z;\r\n  }\r\n\r\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\r\n  // of approximation of b^0.w\r\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\r\n    require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\r\n    require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\r\n\r\n    uint256 whole = bfloor(exp);\r\n    uint256 remain = bsub(exp, whole);\r\n\r\n    uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n    if (remain == 0) {\r\n      return wholePow;\r\n    }\r\n\r\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n    return bmul(wholePow, partialResult);\r\n  }\r\n\r\n  function bpowApprox(\r\n    uint256 base,\r\n    uint256 exp,\r\n    uint256 precision\r\n  ) internal pure returns (uint256) {\r\n    // term 0:\r\n    uint256 a = exp;\r\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\r\n    uint256 term = BONE;\r\n    uint256 sum = term;\r\n    bool negative = false;\r\n\r\n    // term(k) = numer / denom\r\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n    // continue until term is less than precision\r\n    for (uint256 i = 1; term >= precision; i++) {\r\n      uint256 bigK = i * BONE;\r\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\r\n      term = bmul(term, bmul(c, x));\r\n      term = bdiv(term, bigK);\r\n      if (term == 0) break;\r\n\r\n      if (xneg) negative = !negative;\r\n      if (cneg) negative = !negative;\r\n      if (negative) {\r\n        sum = bsub(sum, term);\r\n      } else {\r\n        sum = badd(sum, term);\r\n      }\r\n    }\r\n\r\n    return sum;\r\n  }\r\n}\r\n\r\n/** @title NaiveBalancerSmartPoolPriceProvider\r\n * @notice Price provider for a balancer pool token\r\n * - NAIVE CALCULATION, USE ONLY FOR PRICE FETCHING\r\n * This implementation assumes the underlying pool on the smart pool is a standard Balancer Shared Pool\r\n * - DON'T USE THIS ORACLE IF FUNDAMENTAL CHANGES ON THE UNDERLYING POOL ARE APPLIED\r\n */\r\n\r\ncontract NaiveBalancerSmartPoolPriceProvider is BNum {\r\n  ISmartBPool public pool;\r\n  address[] public tokens;\r\n  uint256[] public weights;\r\n  bool[] public isPeggedToEth;\r\n  uint8[] public decimals;\r\n  IPriceOracle public priceOracle;\r\n\r\n  /**\r\n   * BalancerSmartPoolPriceProvider constructor.\r\n   * @param _pool Balancer pool address.\r\n   * @param _isPeggedToEth For each token, true if it is pegged to ETH (token order determined by pool.getPool().getFinalTokens()).\r\n   * @param _decimals Number of decimals for each token (token order determined by pool.getPool().getFinalTokens()).\r\n   * @param _priceOracle Aave price oracle.\r\n   */\r\n  constructor(\r\n    ISmartBPool _pool,\r\n    bool[] memory _isPeggedToEth,\r\n    uint8[] memory _decimals,\r\n    IPriceOracle _priceOracle\r\n  ) public {\r\n    pool = _pool;\r\n\r\n    BPool underlyingBPool = _pool.bPool();\r\n    //Get token list\r\n    tokens = underlyingBPool.getCurrentTokens();\r\n    uint256 length = tokens.length;\r\n    //Validate contructor params\r\n    require(length >= 2 && length <= 3, 'ERR_INVALID_POOL_TOKENS_NUMBER');\r\n    require(_isPeggedToEth.length == length, 'ERR_INVALID_PEGGED_LENGTH');\r\n    require(_decimals.length == length, 'ERR_INVALID_DECIMALS_LENGTH');\r\n    for (uint8 i = 0; i < length; i++) {\r\n      require(_decimals[i] <= 18, 'ERR_INVALID_DECIMALS');\r\n    }\r\n    require(address(_priceOracle) != address(0), 'ERR_INVALID_PRICE_PROVIDER');\r\n    //Get token normalized weights\r\n    for (uint8 i = 0; i < length; i++) {\r\n      weights.push(underlyingBPool.getNormalizedWeight(tokens[i]));\r\n    }\r\n    isPeggedToEth = _isPeggedToEth;\r\n    decimals = _decimals;\r\n    priceOracle = _priceOracle;\r\n  }\r\n\r\n  /**\r\n   * Returns the token balance in ethers by multiplying its balance with its price in ethers.\r\n   * @param index Token index.\r\n   */\r\n  function getEthBalanceByToken(uint256 index) internal view returns (uint256) {\r\n    uint256 pi = isPeggedToEth[index] ? BONE : uint256(priceOracle.getAssetPrice(tokens[index]));\r\n    require(pi > 0, 'ERR_NO_ORACLE_PRICE');\r\n    uint256 missingDecimals = 18 - decimals[index];\r\n    uint256 bi = bmul(pool.bPool().getBalance(tokens[index]), BONE * 10**(missingDecimals));\r\n    return bmul(bi, pi);\r\n  }\r\n\r\n  /**\r\n   * Calculates the price of the pool token using the formula of weighted arithmetic mean.\r\n   * @param ethTotals Balance of each token in ethers.\r\n   */\r\n  function getArithmeticMean(uint256[] memory ethTotals) internal view returns (uint256) {\r\n    uint256 totalEth = 0;\r\n    uint256 length = tokens.length;\r\n    for (uint8 i = 0; i < length; i++) {\r\n      totalEth = badd(totalEth, ethTotals[i]);\r\n    }\r\n    return bdiv(totalEth, pool.totalSupply());\r\n  }\r\n\r\n  /**\r\n   * Returns the pool's token price.\r\n   * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\r\n   */\r\n  function latestAnswer() external view returns (uint256) {\r\n    //Get token balances in ethers\r\n    uint256[] memory ethTotals = new uint256[](tokens.length);\r\n    uint256 length = tokens.length;\r\n    for (uint256 i = 0; i < length; i++) {\r\n      ethTotals[i] = getEthBalanceByToken(i);\r\n    }\r\n\r\n    return getArithmeticMean(ethTotals);\r\n  }\r\n\r\n  /**\r\n   * Returns Balancer pool address.\r\n   */\r\n  function getPool() external view returns (ISmartBPool) {\r\n    return pool;\r\n  }\r\n\r\n  /**\r\n   * Returns all tokens.\r\n   */\r\n  function getTokens() external view returns (address[] memory) {\r\n    return tokens;\r\n  }\r\n\r\n  /**\r\n   * Returns all tokens's weights.\r\n   */\r\n  function getWeights() external view returns (uint256[] memory) {\r\n    return weights;\r\n  }\r\n}"
    }
  }
}