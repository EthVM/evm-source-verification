{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "XAD_Token.sol": {
      "content": "pragma solidity ^0.5.7;\r\n\r\n/*\r\n * Creator:\"Julien ADOUT\"  \"SCI XAD\"\r\n *\r\n * Safe Math Smart Contract. \r\n */\r\n\r\ncontract SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * ERC-20 standard token interface, as defined\r\n * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>.\r\n */\r\ncontract Token {\r\n  \r\n  function totalSupply() public view returns (uint256 supply);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * Abstract Token Smart Contract that could be used as a base contract for\r\n * ERC-20 token contracts.\r\n */\r\ncontract AbstractToken is Token, SafeMath {\r\n  /**\r\n   * Create new Abstract Token contract.\r\n   */\r\n  constructor () public {\r\n    // Do nothing\r\n  }\r\n  \r\n  /**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return accounts [_owner];\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   * accounts [_to] + _value > accounts [_to] for overflow check\r\n   * which is already in safeMath\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    require(_to != address(0));\r\n    if (accounts [msg.sender] < _value) return false;\r\n    if (_value > 0 && msg.sender != _to) {\r\n      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n    }\r\n    emit Transfer (msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   * accounts [_to] + _value > accounts [_to] for overflow check\r\n   * which is already in safeMath\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public\r\n  returns (bool success) {\r\n    require(_to != address(0));\r\n    if (allowances [_from][msg.sender] < _value) return false;\r\n    if (accounts [_from] < _value) return false; \r\n\r\n    if (_value > 0 && _from != _to) {\r\n\t  allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value);\r\n      accounts [_from] = safeSub (accounts [_from], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n    }\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   * @param _spender address to allow the owner of to transfer tokens from message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n   function approve (address _spender, uint256 _value) public returns (bool success) {\r\n    allowances [msg.sender][_spender] = _value;\r\n    emit Approval (msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance(address _owner, address _spender) public view\r\n  returns (uint256 remaining) {\r\n    return allowances [_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * Mapping from addresses of token holders to the numbers of tokens belonging\r\n   * to these token holders.\r\n   */\r\n  mapping (address => uint256) accounts;\r\n\r\n  /**\r\n   * Mapping from addresses of token holders to the mapping of addresses of\r\n   * spenders to the allowances set by these token holders to these spenders.\r\n   */\r\n  mapping (address => mapping (address => uint256)) private allowances;\r\n  \r\n}\r\n\r\n\r\n/**\r\n * XAD Token smart contract.\r\n */\r\ncontract XAD_Token is AbstractToken {\r\n  /**\r\n   * Maximum allowed number of tokens in circulation.\r\n   * tokenSupply = tokensIActuallyWant * (10 ^ decimals)\r\n   */\r\n   \r\n   \r\n  uint256 constant MAX_TOKEN_COUNT = 0 * (0);\r\n   \r\n  /**\r\n   * Address of the owner of this smart contract.\r\n   */\r\n  address private owner;\r\n  \r\n  /**\r\n   * Frozen account list holder\r\n   */\r\n  mapping (address => bool) private frozenAccount;\r\n\r\n  /**\r\n   * Current number of tokens in circulation.\r\n   */\r\n  uint256 tokenCount = 0;\r\n  \r\n \r\n  /**\r\n   * True if tokens transfers are currently frozen, false otherwise.\r\n   */\r\n  bool frozen = false;\r\n  \r\n \r\n  /**\r\n   * Create new token smart contract and make msg.sender the\r\n   * owner of this smart contract.\r\n   */\r\n  constructor () public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   */\r\n  function totalSupply() public view returns (uint256 supply) {\r\n    return tokenCount;\r\n  }\r\n\r\n  string constant public name = \"XAD Token\";\r\n  string constant public symbol = \"XAD\";\r\n  uint8 constant public decimals = 4;\r\n  \r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.ss\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n    require(!frozenAccount[msg.sender]);\r\n\tif (frozen) return false;\r\n    else return AbstractToken.transfer (_to, _value);\r\n  }\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public\r\n    returns (bool success) {\r\n\trequire(!frozenAccount[_from]);\r\n    if (frozen) return false;\r\n    else return AbstractToken.transferFrom (_from, _to, _value);\r\n  }\r\n\r\n   /**\r\n   * Change how many tokens given spender is allowed to transfer from message\r\n   * spender.  In order to prevent double spending of allowance,\r\n   * To change the approve amount you first have to reduce the addresses`\r\n   * allowance to zero by calling `approve(_spender, 0)` if it is not\r\n   * already 0 to mitigate the race condition described here:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n   *        message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n  function approve (address _spender, uint256 _value) public\r\n    returns (bool success) {\r\n\trequire(allowance (msg.sender, _spender) == 0 || _value == 0);\r\n    return AbstractToken.approve (_spender, _value);\r\n  }\r\n\r\n  function mintToken(address target, uint256 mintedAmount) public\r\n  returns (bool success) {\r\n    require (msg.sender == owner);\r\n      if (mintedAmount > 0) {\r\n\t  \r\n      accounts [target] = safeAdd (accounts [target], mintedAmount);\r\n      tokenCount = safeAdd (tokenCount, mintedAmount);\r\n\t  \r\n\t  // adding transfer event and _from address as null address\r\n\t  emit Transfer(address(0), target, mintedAmount);\r\n\t  \r\n\t   return true;\r\n    }\r\n\t  return false;\r\n   \r\n    }\r\n\t\r\n  /**\r\n   * Burn intended tokens.\r\n   * Only be called by by burnable addresses.\r\n   *\r\n   * @param _value number of tokens to burn\r\n   * @return true if burnt successfully, false otherwise\r\n   */\r\n  \r\n  function burn(uint256 _value) public returns (bool success) {\r\n  \r\n        require(accounts[msg.sender] >= _value); \r\n\t\t\r\n\t\trequire (msg.sender == owner);\r\n\t\t\r\n\t\taccounts [msg.sender] = safeSub (accounts [msg.sender], _value);\r\n\t\t\r\n        tokenCount = safeSub (tokenCount, _value);\t\r\n\t\t\r\n        emit Burn(msg.sender, _value);\r\n\t\t\r\n        return true;\r\n    }\t\r\n  \r\n\r\n  /**\r\n   * Set new owner for the smart contract.\r\n   * May only be called by smart contract owner.\r\n   *\r\n   * @param _newOwner address of new owner of the smart contract\r\n   */\r\n  function setOwner(address _newOwner) public {\r\n    require (msg.sender == owner);\r\n\r\n    owner = _newOwner;\r\n  }\r\n\r\n\r\n  event Burn(address target,uint256 _value);\r\n\r\n\r\n}"
    }
  }
}