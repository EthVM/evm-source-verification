{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Token.sol": {
      "content": "pragma solidity ^0.4.25;\r\n\r\ncontract ERC20 {\r\n\tfunction transfer(address to, uint value) public returns (bool success);\r\n\tfunction transferFrom(address from, address to, uint value) public returns (bool success);\r\n\tfunction approve(address spender, uint value) public returns (bool success);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n    \r\n\tfunction mul(uint a, uint b) internal pure returns (uint) {\r\n\t\tuint c = a * b;\r\n\t\tassert(a == 0 || c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint a, uint b) internal pure returns (uint) {\r\n\t\tassert(b > 0);\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction sub(uint a, uint b) internal pure returns (uint) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add(uint a, uint b) internal pure returns (uint) {\r\n\t\tuint c = a + b;\r\n\t\tassert(c >= a && c >= b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction min(uint x, uint y) internal pure returns (uint) {\r\n\t\treturn x <= y ? x : y;\r\n\t}\r\n\r\n\tfunction max(uint x, uint y) internal pure returns (uint) {\r\n\t\treturn x >= y ? x : y;\r\n\t}\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Token is ERC20, SafeMath, Owned {\r\n\r\n\t// Public variables of the token\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 18;\r\n\t// 18 decimals is the strongly suggested default, avoid changing it\r\n\tuint public totalSupply;\r\n\r\n\t// This creates an array with all balances\r\n\tmapping(address => uint) public balanceOf;\r\n\tmapping(address => mapping(address => uint)) public allowance;\r\n\r\n\tmapping(address=>uint) public lock; \r\n\tmapping(address=>bool) public freezeIn;\r\n\tmapping(address=>bool) public freezeOut;\r\n\t\r\n\t//event definitions\r\n\t/* This notifies clients about the amount burn */\r\n\tevent Burn(address indexed from, uint value);\r\n\tevent FreezeIn(address[] indexed from, bool value);\r\n\tevent FreezeOut(address[] indexed from, bool value);\r\n\r\n\tfunction Token(string tokenName, string tokenSymbol, uint initSupply) public {\r\n\t\ttotalSupply=initSupply*10**uint(decimals);      //update total supply\r\n\t\tname=tokenName;\r\n\t\tsymbol=tokenSymbol;\r\n\t\tbalanceOf[owner]=totalSupply;       //give the owner all initial tokens\r\n\t}\r\n\r\n\t//ERC 20\r\n\t///////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tfunction internalTransfer(address from, address toaddr, uint value) internal {\r\n\t\trequire(toaddr!=0);\r\n\t\trequire(balanceOf[from]>=value);\r\n\r\n\t\trequire(now>=lock[from]);\r\n\t\trequire(!freezeIn[toaddr]);\r\n\t\trequire(!freezeOut[from]);\r\n\r\n\t\tbalanceOf[from]=sub(balanceOf[from], value);\r\n\t\tbalanceOf[toaddr]=add(balanceOf[toaddr], value);\r\n\r\n\t\tTransfer(from, toaddr, value);\r\n\t}\r\n\r\n\tfunction transfer(address toaddr, uint value) public returns (bool) {\r\n\t\tinternalTransfer(msg.sender, toaddr, value);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction transferFrom(address from, address toaddr, uint value) public returns (bool) {\r\n\t\trequire(allowance[from][msg.sender]>=value);\r\n\t\tallowance[from][msg.sender]=sub(allowance[from][msg.sender], value);\r\n\t\tinternalTransfer(from, toaddr, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address spender, uint amount) public returns (bool) {\r\n\t\trequire((amount == 0) || (allowance[msg.sender][spender] == 0));\r\n\t\tallowance[msg.sender][spender]=amount;\r\n\t\tApproval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tfunction setNameSymbol(string tokenName, string tokenSymbol) public onlyOwner {\r\n\t\tname=tokenName;\r\n\t\tsymbol=tokenSymbol;\r\n\t}\r\n\r\n\t////////////////////////////////////////////////////////////////////////////////////////////\r\n\tfunction setLock(address[] addrs, uint[] times) public onlyOwner {\r\n\t\trequire(addrs.length==times.length);\r\n\t\tfor (uint i=0; i<addrs.length; i++) {\r\n\t\t\tlock[addrs[i]]=times[i];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setFreezeIn(address[] addrs, bool value) public onlyOwner {\r\n\t\tfor (uint i=0; i<addrs.length; i++) {\r\n\t\t\tfreezeIn[addrs[i]]=value;\r\n\t\t}\r\n\t\tFreezeIn(addrs, value);\r\n\t}\r\n\r\n\tfunction setFreezeOut(address[] addrs, bool value) public onlyOwner {\r\n\t\tfor (uint i=0; i<addrs.length; i++) {\r\n\t\t\tfreezeOut[addrs[i]]=value;\r\n\t\t}\r\n\t\tFreezeOut(addrs, value);\r\n\t}\r\n\t///////////////////////////////////////////////////////////////////////////////////////////\r\n\tfunction mint(uint amount) public onlyOwner {\r\n\t\tbalanceOf[owner]=add(balanceOf[owner], amount);\r\n\t\ttotalSupply=add(totalSupply, amount);\r\n\t}\r\n\r\n\tfunction burn(uint amount) public {\r\n\t\tbalanceOf[msg.sender]=sub(balanceOf[msg.sender], amount);\r\n\t\ttotalSupply=sub(totalSupply, amount);\r\n\t}\r\n\t///////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\tfunction withdrawEther(uint amount) public onlyOwner {\r\n\t\towner.transfer(amount);\r\n\t}\r\n\r\n\t// can accept ether\r\n\tfunction() public payable {\r\n\t    revert();\r\n    }\r\n}"
    }
  }
}