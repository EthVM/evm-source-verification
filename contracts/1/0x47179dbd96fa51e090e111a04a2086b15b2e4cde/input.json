{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "STEST22Token.sol": {
      "content": "/**\r\n *Submitted for verification at Etherscan.io on 2018-01-09\r\n*/\r\n\r\npragma solidity ^0.4.13;\r\n\r\ncontract ERC20 {\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n//Safe math\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  /* Token supply got increased and a new owner received these tokens */\r\n  event Minted(address receiver, uint amount);\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /* Interface declaration */\r\n  function isToken() public constant returns (bool Yes) {\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _address) constant returns (uint balance) {\r\n    return balances[_address];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract STEST22Token is StandardToken {\r\n\r\n    string public name = \"STEST22 Token\";\r\n    string public symbol = \"STEST22\";\r\n    uint public totalSupply = 18000000;\r\n    uint8 public decimals = 0;\r\n    \r\n    //Addresses that are allowed to transfer tokens\r\n    mapping (address => bool) public allowedTransfer;\r\n    \r\n\t//Technical variables to store states\r\n\tbool public TransferAllowed = true;//Token transfers are blocked\r\n\t\r\n    //Technical variables to store statistical data\r\n\tuint public StatsMinted = 0;//Minted tokens amount\r\n\tuint public StatsTotal = 0;//Overall tokens amount\r\n\r\n    //Event logs\r\n    event Buy(address indexed sender, uint eth, uint tokens, uint bonus);//Tokens purchased\r\n    event Mint(address indexed from, uint tokens);// This notifies clients about the amount minted\r\n    event Burn(address indexed from, uint tokens);// This notifies clients about the amount burnt\r\n    \r\n    address public owner = 0x0;//Admin actions\r\n    address public minter = 0x0;//Minter tokens\r\n \r\n    function STEST22Token(address _owner, address _minter) payable {\r\n        owner = _owner;\r\n        minter = _minter;\r\n        \r\n        balances[owner] = 0;\r\n        balances[minter] = 0;\r\n        \r\n        allowedTransfer[owner] = true;\r\n        allowedTransfer[minter] = true;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    //Allow or prohibit token transfers\r\n    function setTransferAllowance(bool _allowance) external onlyOwner {\r\n        TransferAllowed = _allowance;\r\n    }\r\n    \r\n    // Send `_amount` of tokens to `_target`\r\n    function mintTokens(address _target, uint _amount) external returns (bool) {\r\n        require(msg.sender == owner || msg.sender == minter);\r\n        require(_amount > 0);//Number of tokens must be greater than 0\r\n        uint amount=_amount;\r\n        require(safeAdd(StatsTotal, amount) <= totalSupply);//The amount of tokens cannot be greater than Total supply\r\n        balances[_target] = safeAdd(balances[_target], amount);\r\n        StatsMinted = safeAdd(StatsMinted, amount);//Update number of tokens minted\r\n        StatsTotal = safeAdd(StatsTotal, amount);//Update total number of tokens\r\n        emit Transfer(0, this, amount);\r\n        emit Transfer(this, _target, amount);\r\n        emit Mint(_target, amount);\r\n        return true;\r\n    }\r\n    \r\n    // Decrease user balance\r\n    function decreaseTokens(address _target, uint _amount) external returns (bool) {\r\n        require(msg.sender == owner || msg.sender == minter);\r\n        require(_amount > 0);//Number of tokens must be greater than 0\r\n        uint amount=_amount;\r\n        balances[_target] = safeSub(balances[_target], amount);\r\n        StatsMinted = safeSub(StatsMinted, amount);//Update number of tokens minted\r\n        StatsTotal = safeSub(StatsTotal, amount);//Update total number of tokens\r\n        emit Transfer(_target, 0, amount);\r\n        emit Burn(_target, amount);\r\n        return true;\r\n    }\r\n    \r\n    // Allow `_target` make token tranfers\r\n    function allowTransfer(address _target, bool _allow) external onlyOwner {\r\n        allowedTransfer[_target] = _allow;\r\n    }\r\n    \r\n    function transfer(address _to, uint _value) returns (bool success) {\r\n        \r\n        //Forbid token transfers\r\n        if(!TransferAllowed){\r\n            require(allowedTransfer[msg.sender]);\r\n        }\r\n        \r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n        \r\n        //Forbid token transfers\r\n        if(!TransferAllowed){\r\n            require(allowedTransfer[msg.sender]);\r\n        }\r\n        \r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    //Change owner\r\n    function changeOwner(address _to) external onlyOwner() {\r\n        balances[_to] = balances[owner];\r\n        balances[owner] = 0;\r\n        owner = _to;\r\n    }\r\n\r\n    //Change minter\r\n    function changeMinter(address _to) external onlyOwner() {\r\n        balances[_to] = balances[minter];\r\n        balances[minter] = 0;\r\n        minter = _to;\r\n    }\r\n}"
    }
  }
}