{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SCALE.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface ERC721 {\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n}\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\ninterface Token {\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    function changeOwnerForce(address _newOwner) public isOwner {\r\n        require(_newOwner != owner);\r\n        owner = _newOwner;\r\n        emit OwnerUpdate(owner, _newOwner);\r\n    }\r\n\r\n}\r\n\r\ncontract Controlled is Owned {\r\n\r\n    bool public transferEnable = true;\r\n\r\n    bool public lockFlag = true;\r\n\r\n    constructor() {\r\n        setExclude(msg.sender);\r\n    }\r\n\r\n    mapping(address => bool) public locked;\r\n\r\n    mapping(address => bool) public exclude;\r\n\r\n    function enableTransfer(bool _enable) public isOwner{\r\n        transferEnable = _enable;\r\n    }\r\n\r\n    function disableLock(bool _enable) public isOwner returns (bool success){\r\n        lockFlag = _enable;\r\n        return true;\r\n    }\r\n\r\n    function addLock(address _addr) public isOwner returns (bool success){\r\n        require(_addr != msg.sender);\r\n        locked[_addr] = true;\r\n        return true;\r\n    }\r\n\r\n    function setExclude(address _addr) public isOwner returns (bool success){\r\n        exclude[_addr] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeLock(address _addr) public isOwner returns (bool success){\r\n        locked[_addr] = false;\r\n        return true;\r\n    }\r\n\r\n    modifier transferAllowed(address _addr) {\r\n        if (!exclude[_addr]) {\r\n            assert(transferEnable);\r\n            if(lockFlag){\r\n                assert(!locked[_addr]);\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier validAddress(address _addr) {\r\n        assert(address(0x0) != _addr && address(0x0) != msg.sender);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract StandardToken is Token, Controlled {\r\n\r\n    string public name = \"\";\r\n    string public symbol = \"\";\r\n    uint8 public decimals = 18;\r\n\r\n    uint256 public totalSupply;\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        name = name_;\r\n        symbol = symbol_;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view override returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public override transferAllowed(msg.sender) validAddress(_to) returns (bool success) {\r\n        require(_value > 0);\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override transferAllowed(_from) validAddress(_to) returns (bool success) {\r\n        require(_value > 0);\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override transferAllowed(_spender) returns (bool success) {\r\n        require(_value > 0);\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(totalSupply + amount > totalSupply);\r\n        require(balances[account] + amount > balances[account]);\r\n\r\n        balances[account] += amount;\r\n        totalSupply += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(totalSupply >= amount);\r\n        require(balances[account] >= amount);\r\n\r\n        totalSupply -= amount;\r\n        balances[account] -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n}\r\n\r\ncontract SCALE is StandardToken {\r\n\r\n    ERC721 public lizardContract;\r\n    ERC721 public dragonContract;\r\n\r\n    uint256 public immutable PER_DAY_PER_LIZARD_REWARD = 10 ether;\r\n    uint256 public immutable PER_DAY_PER_DRAGON_REWARD = 50 ether;\r\n    uint256 private MINE_PERIOD = 86400;\r\n    uint256 public GENESIS = 1635379200;\r\n\r\n    bool public mineIsActive = true;\r\n\r\n    mapping(address => uint256) public last;\r\n\r\n    constructor(address lizard, address dragon) StandardToken(\"SCALE\",\"SCALE\"){\r\n        lizardContract = ERC721(lizard);\r\n        dragonContract = ERC721(dragon);\r\n        _mint(address(0x008FA9C81e6b6184aEce369017E80569b8FC753fBc), 200 ether);\r\n        _mint(address(0x00C36BCC133EDfe4E3BBe0D92aF330bD5Ca946A258), 600 ether);\r\n        _mint(address(0x00f0a5043111c2a35fbd1acfb588c382e781ad6aef), 1350 ether);\r\n        _mint(address(0x00e08163c2bab9d0f933cd67fa52ec8687df98a55c), 1860 ether);\r\n\r\n        _mint(address(0x0034Cf7Ac942A815DDEDdF1319ce91dEa69Af46dCb), 4600 ether);\r\n        _mint(address(0x00D8c88B8681B3F699d8DAe59ec239fB0925acC660), 400 ether);\r\n        _mint(address(0x004B02b95F480FDD4d55c2aD7D5c6c70152cC5b8F9), 400 ether);\r\n        _mint(address(0x00f8ae589B64890C4A844405d37D1918DfF9fC136d), 8000 ether);\r\n        _mint(address(0x008FA9C81e6b6184aEce369017E80569b8FC753fBc), 200 ether);\r\n    }\r\n\r\n    function closeMineState() public isOwner {\r\n        require(mineIsActive, \"Mining is currently unavailable\");\r\n        mineIsActive = false;\r\n    }\r\n\r\n    function openMineState(uint256 timestamp) public isOwner {\r\n        require(!mineIsActive, \"Mining is currently on\");\r\n        mineIsActive = true;\r\n        GENESIS = timestamp;\r\n    }\r\n\r\n    function claim(address user) external {\r\n        require(mineIsActive, \"Mining is currently unavailable\");\r\n        require(block.timestamp > GENESIS, \"Mining is currently unavailable\");\r\n        uint256 owed = 0;\r\n        uint256 total = lizardContract.balanceOf(user);\r\n        uint256 minePeriods = minePeriod(last[user]);\r\n        owed += (minePeriods * PER_DAY_PER_LIZARD_REWARD) * total;\r\n        total = dragonContract.balanceOf(user);\r\n        owed += (minePeriods * PER_DAY_PER_DRAGON_REWARD) * total;\r\n        last[user] = block.timestamp;\r\n        _mint(user, owed);\r\n    }\r\n\r\n    function getTotalClaimable(address user)  external view returns(uint256) {\r\n        if (!mineIsActive) {\r\n            return 0;\r\n        }\r\n        if (block.timestamp < GENESIS) {\r\n            return 0;\r\n        }\r\n        uint256 owed = 0;\r\n        uint256 total = lizardContract.balanceOf(user);\r\n        uint256 minePeriods = minePeriod(last[user]);\r\n        owed += (minePeriods * PER_DAY_PER_LIZARD_REWARD) * total;\r\n        total = dragonContract.balanceOf(user);\r\n        owed += (minePeriods * PER_DAY_PER_DRAGON_REWARD) * total;\r\n        return owed;\r\n    }\r\n\r\n    function minePeriod(uint256 claimedTime) internal view returns (uint256) {\r\n        uint256 lastTime = Math.max(claimedTime, GENESIS);\r\n        return (block.timestamp - lastTime / MINE_PERIOD * MINE_PERIOD) / MINE_PERIOD;\r\n    }\r\n\r\n}"}}}