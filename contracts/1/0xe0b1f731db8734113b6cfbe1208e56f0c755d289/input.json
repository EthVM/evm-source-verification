{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/SmartAIX.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.7.0;\r\n\r\ncontract SmartAIX {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    \r\n    address public owner;\r\n    // address public backAddr = 0xaeC2c21c7a63619596d91Ee21983B668C35Cccc7;\r\n    address public sysAddr = 0xaeC2c21c7a63619596d91Ee21983B668C35Cccc7; \r\n    address public aixToken;\r\n    address public aixtToken;\r\n    address public aixmanage;\r\n    \r\n    uint public contractBeginTime = block.timestamp;\r\n    uint public contractBeginNum;\r\n\r\n    uint public twoWeeks = 2 weeks;\r\n    uint public oneMonth = 4 weeks;\r\n    uint public referenceDays = 6 weeks; // 2 weeks + 4 weeks(1 month) = 6 weeks\r\n\r\n    uint public rewardPerBlock = 36458333300000000; // 210 token\r\n    uint public rewardPerBlock2 = 18229166700000000; // 105 token after one month\r\n    \r\n    uint public totalDeposit;\r\n    uint public totalWithdraw;\r\n    uint public greatWithdraw;\r\n    uint public oneEth = 1 ether;\r\n    uint public perRewardToken;\r\n    bool public isAudit;\r\n    \r\n    constructor(address _aixtToken,address _aixToken) public {\r\n        owner = msg.sender;\r\n        aixtToken = _aixtToken;\r\n        aixToken = _aixToken;\r\n        contractBeginNum = block.number;\r\n        userInfo[sysAddr].depoistTime = 1;\r\n        starInfo[1] = StarInfo({minNum: oneEth.mul(20000),maxNum: oneEth.mul(50000),rate:2000});\r\n        starInfo[2] = StarInfo({minNum: oneEth.mul(50000),maxNum: oneEth.mul(100000),rate:2000});\r\n        starInfo[3] = StarInfo({minNum: oneEth.mul(100000),maxNum: oneEth.mul(500000),rate:2000});\r\n        starInfo[4] = StarInfo({minNum: oneEth.mul(500000),maxNum: oneEth.mul(2000000),rate:2000});\r\n        starInfo[4] = StarInfo({minNum: oneEth.mul(2000000),maxNum: oneEth.mul(10000000),rate:2000});    \r\n    }\r\n\r\n    struct UserInfo {\r\n        uint depositVal;//\r\n        uint depoistTime;\r\n        address invitor;\r\n        uint level;\r\n        uint lastWithdrawBlock;\r\n        uint teamDeposit;\r\n        uint userWithdraw; //\r\n        uint userStaticReward;//\r\n        uint userDynamicReward;//\r\n        uint userGreateReward;//\r\n        uint debatReward;\r\n        uint teamReward;\r\n    }\r\n    struct StarInfo{\r\n        uint minNum;\r\n        uint maxNum;\r\n        uint rate;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    mapping(address => address[]) public referArr;\r\n    mapping(address => UserInfo) public userInfo;\r\n    mapping(uint => StarInfo) public starInfo;\r\n    mapping(uint => uint) public starNumbers;\r\n    mapping(address => bool) public isDelegate;\r\n    mapping(address => uint) public invitorReward;\r\n    \r\n    function transferOwnerShip(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n    \r\n    function setNewStarRate(uint _starId,uint _newRate) public onlyOwner {\r\n        starInfo[_starId].rate = _newRate;\r\n    }\r\n    function setAixManger(address _aixmanage) public onlyOwner {\r\n        aixmanage = _aixmanage;\r\n        perRewardToken = IAixManger(aixmanage).perRewardToken();\r\n    }\r\n    \r\n    function depositAIX(uint256 _amount,address _invitor) public {\r\n        require(_amount > 0);\r\n        require(msg.sender != _invitor);\r\n        require(userInfo[_invitor].invitor != msg.sender);\r\n        if(userInfo[msg.sender].invitor != address(0)){\r\n            require(userInfo[msg.sender].invitor == _invitor);\r\n        }\r\n        IERC20(aixToken).safeTransferFrom(msg.sender,address(this),_amount);\r\n        \r\n        updatePerReward();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        if(user.depoistTime == 0){\r\n            user.invitor = _invitor;\r\n            referArr[_invitor].push(msg.sender);\r\n        }\r\n        if(user.lastWithdrawBlock == 0){\r\n            user.lastWithdrawBlock = block.number;\r\n        }\r\n        user.depoistTime = user.depoistTime.add(1);\r\n        \r\n        uint staticRewardX ;\r\n        if(user.depositVal > 0){\r\n            staticRewardX = privGetReward(msg.sender);\r\n        }\r\n        user.depositVal = user.depositVal.add(_amount);\r\n        user.teamDeposit = user.teamDeposit.add(_amount);\r\n        invitorReward[_invitor] = invitorReward[_invitor].add(_amount);\r\n        totalDeposit = totalDeposit.add(_amount);\r\n        \r\n        uint newLevel = getLevel(msg.sender);\r\n        \r\n        if(newLevel > user.level ){\r\n            starNumbers[newLevel] = starNumbers[newLevel].add(1);\r\n            if(starNumbers[user.level] > 0){\r\n                starNumbers[user.level] = starNumbers[user.level].sub(1);\r\n            }\r\n        }\r\n        \r\n        user.level = newLevel;\r\n        updatePerReward();\r\n\r\n        user.debatReward = user.depositVal.mul(perRewardToken).div(1e12);\r\n        execute(_invitor,1,staticRewardX,_amount,1);   \r\n    }\r\n\r\n    function execute(address invitor,uint runtimes,uint staticReward,uint depositVal,uint idx) private returns(uint) {\r\n        if(runtimes <= 5 && invitor != sysAddr ){\r\n            UserInfo storage  lastUser = userInfo[invitor];\r\n            if(staticReward > 0 && runtimes <=3 && lastUser.depositVal >= oneEth.mul(1000)){\r\n                uint refReward = getReferStaticReward(runtimes);\r\n                lastUser.teamReward = lastUser.teamReward.add(staticReward.mul(refReward).div(10000));\r\n            }\r\n            \r\n            if(idx > 0){\r\n                if(idx==1){\r\n                    lastUser.teamDeposit = lastUser.teamDeposit.add(depositVal);\r\n                    \r\n                }else if(idx==2){\r\n                    lastUser.teamDeposit = lastUser.teamDeposit.sub(depositVal);\r\n                }\r\n                \r\n                uint newLevel = getLevel(invitor);\r\n                if(newLevel != lastUser.level ){\r\n                    if(idx==1){\r\n                        if(newLevel > lastUser.level ){\r\n                            starNumbers[newLevel] = starNumbers[newLevel].add(1);\r\n                            if(starNumbers[lastUser.level] > 0){\r\n                                starNumbers[lastUser.level] = starNumbers[lastUser.level].sub(1);\r\n                            }\r\n                        }\r\n                    }else if(idx==2){\r\n                        if(newLevel < lastUser.level ){\r\n                            starNumbers[newLevel] = starNumbers[newLevel].add(1);\r\n                            if(starNumbers[lastUser.level] > 0){\r\n                                starNumbers[lastUser.level] = starNumbers[lastUser.level].sub(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                lastUser.level = newLevel;\r\n            }\r\n            \r\n            return execute(lastUser.invitor,runtimes+1,staticReward,depositVal,idx);\r\n        }\r\n    }\r\n\r\n    function withDrawAIX(uint _amount) public {\r\n        updatePerReward();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require( _amount > 0 && user.depositVal >= _amount);\r\n        \r\n        uint staticRewardX = privGetReward(msg.sender);\r\n        \r\n        user.depositVal = user.depositVal.sub(_amount);\r\n        user.teamDeposit = user.teamDeposit.sub(_amount);\r\n        \r\n        uint newLevel = getLevel(msg.sender);\r\n        \r\n        if(newLevel < user.level ){\r\n            starNumbers[newLevel] = starNumbers[newLevel].add(1);\r\n            if(starNumbers[user.level] > 0){\r\n                starNumbers[user.level] = starNumbers[user.level].sub(1);\r\n            }\r\n        }\r\n        \r\n        user.level = newLevel;\r\n                        \r\n        totalDeposit = totalDeposit.sub(_amount);\r\n        invitorReward[user.invitor] = invitorReward[user.invitor].sub(_amount);\r\n        execute(user.invitor,1,staticRewardX,_amount,2);\r\n        \r\n        updatePerReward();\r\n        user.debatReward = user.depositVal.mul(perRewardToken).div(1e12);\r\n        if(user.depositVal ==0){\r\n            user.lastWithdrawBlock = 0;\r\n        }\r\n        IERC20(aixToken).safeTransfer(msg.sender,_amount);\r\n        \r\n    }\r\n    function privGetReward(address _user) private returns(uint){\r\n        (uint staticR,uint teamR,uint starR) = viewReward(_user);\r\n        uint totalR = staticR.add(teamR).add(starR);\r\n        UserInfo storage user = userInfo[_user];\r\n        user.userWithdraw = user.userWithdraw.add(totalR);\r\n        user.userStaticReward = user.userStaticReward.add(staticR);\r\n        user.userDynamicReward = user.userDynamicReward.add(teamR);\r\n        user.userGreateReward = user.userGreateReward.add(starR);\r\n        user.teamReward = 0;\r\n        invitorReward[_user] = 0;\r\n        user.lastWithdrawBlock = block.number;\r\n        user.debatReward = user.depositVal.mul(perRewardToken).div(1e12);\r\n        \r\n        totalWithdraw = totalWithdraw.add(totalR);\r\n        greatWithdraw = greatWithdraw.add(starR);\r\n        \r\n        if(totalR > 0){\r\n            IERC20(aixtToken).mint(msg.sender,totalR);\r\n        }\r\n        return  staticR;\r\n    }\r\n\r\n    function getReward() public {\r\n        updatePerReward();\r\n        UserInfo memory user = userInfo[msg.sender];\r\n        require(user.depositVal > 0);\r\n        uint staticR = privGetReward(msg.sender);\r\n        execute(user.invitor,1,staticR,0,0);\r\n    }\r\n    \r\n    function viewReward(address _user) public view returns(uint staticR,uint teamR,uint starR){\r\n        uint staticReward = viewStaicReward(_user);\r\n        uint starReward = viewGreatReward(_user);\r\n        uint invitorRewards = viewInvitorReward(_user);    \r\n        return (staticReward,invitorRewards,starReward);\r\n    }\r\n    \r\n    function getRefRate(uint refSec) public pure returns(uint){\r\n        if(refSec == 1){\r\n            return 5000;\r\n        }else if(refSec == 2){\r\n            return 3000;\r\n        }else if(refSec == 3){\r\n            return 1000;\r\n        }else {\r\n            return 0;\r\n        }\r\n    }\r\n    function viewTeamDynamic(address _user) public view returns(uint _dynamicR) {\r\n        uint refLen = getRefferLen(_user);\r\n        \r\n        for(uint i;i<refLen;i++){\r\n            address addr = referArr[_user][i];\r\n            uint staticReward = viewStaicReward(addr);\r\n            uint refLens = getRefferLen(addr);\r\n            _dynamicR = _dynamicR.add(staticReward.mul(5000).div(10000));\r\n            for(uint j;j< refLens;j++){\r\n                address addrx = referArr[addr][j];\r\n                uint staticRewardx = viewStaicReward(addrx);\r\n                uint refLensx = getRefferLen(addrx);\r\n                _dynamicR = _dynamicR.add(staticRewardx.mul(3000).div(10000));\r\n                for(uint k;k < refLensx;k++){\r\n                    address addrxx = referArr[addrx][k];\r\n                    uint staticRewardxx = viewStaicReward(addrxx);\r\n                    _dynamicR = _dynamicR.add(staticRewardxx.mul(1000).div(10000));\r\n                }\r\n            }\r\n        }\r\n        _dynamicR = _dynamicR.add(userInfo[_user].teamReward); \r\n    }\r\n    \r\n    //更新每笔价格\r\n    function updatePerReward() public {\r\n        if(totalDeposit > 0){\r\n            uint staticRewardBlock = curReward().mul(block.number.sub(contractBeginNum));\r\n            perRewardToken = perRewardToken.add(staticRewardBlock.mul(5000).div(10000).mul(1e12).div(totalDeposit));\r\n            contractBeginNum = block.number;\r\n        }\r\n    }\r\n\r\n    //静态奖励\r\n    function viewStaicReward(address _user) public view returns(uint){\r\n        if(totalDeposit > 0){\r\n            UserInfo memory user = userInfo[_user];\r\n            uint perRewardTokenNew = getNewRewardPerReward();\r\n            uint rew1 = user.depositVal.mul(perRewardTokenNew).div(1e12);\r\n            if(rew1 > user.debatReward ){\r\n                return rew1.sub(user.debatReward);\r\n            }\r\n        }\r\n    }\r\n    \r\n    //invitor reward\r\n    function viewInvitorReward(address _user) public view returns(uint){\r\n        if(userInfo[_user].depositVal < oneEth.mul(1000)){\r\n            return uint(0);\r\n        }\r\n        uint invitorRewards = invitorReward[_user];\r\n        if(invitorRewards > 0){\r\n            uint blockReward = curReward().mul(2000).div(10000); // 20%\r\n            uint invitorRewardsStatic = blockReward.mul(invitorRewards).mul(block.number.sub(userInfo[_user].lastWithdrawBlock)).div(totalDeposit);\r\n            return invitorRewardsStatic.mul(1000).div(10000);\r\n        }\r\n    }\r\n    \r\n    //星级收益比例\r\n    function getStarRewardRate(uint level) public pure returns(uint){\r\n        if(level == 1){\r\n            return 2500;\r\n        }else if(level == 2){\r\n            return 2000;\r\n        }else if(level == 3){\r\n            return 1000;\r\n        }else if(level == 4){\r\n            return 2000;\r\n        }else if(level == 5){\r\n            return 2500;\r\n        }else{\r\n            return uint(0);\r\n        }\r\n    }\r\n    \r\n    // 星级奖励 Team Reward\r\n    function viewGreatReward(address _user) public view returns(uint){\r\n        UserInfo memory user = userInfo[_user];\r\n        uint level = getLevel(_user);\r\n        uint rate = getStarRewardRate(level);\r\n        uint teamD = user.teamDeposit;\r\n        if( level > 0  && user.lastWithdrawBlock > 0 ){\r\n            uint userLastBlock = block.number.sub(user.lastWithdrawBlock);\r\n            uint starDepos = getStarTeamDep(level,starNumbers[level]);\r\n            uint totalGre =  teamD.mul(userLastBlock).mul(curReward()).mul(3000).mul(rate).div(starDepos).div(100000000);\r\n            return totalGre;\r\n        }\r\n    }\r\n    \r\n    function getStarTeamDep(uint _level,uint _counts) public view returns(uint){\r\n      return (starInfo[_level].minNum.add(starInfo[_level].maxNum)).mul(_counts).mul(1000).div(starInfo[_level].rate);\r\n    }\r\n    \r\n    function getLevel(address _user) public view returns(uint willLevel){\r\n        UserInfo memory user = userInfo[_user];\r\n        uint teamDeposit = user.teamDeposit;\r\n        if(user.depositVal >= oneEth.mul(100000) && teamDeposit >= oneEth.mul(1000000) && getLevelTeamLevel(_user,4)){\r\n            willLevel = 5;\r\n        }else if(user.depositVal >= oneEth.mul(70000) && teamDeposit >= oneEth.mul(500000) && getLevelTeamLevel(_user,3)){\r\n            willLevel = 4;\r\n        }else if(user.depositVal >= oneEth.mul(50000) && teamDeposit >= oneEth.mul(100000) && getLevelTeamLevel(_user,2)){\r\n            willLevel = 3;\r\n        }else if(user.depositVal >= oneEth.mul(30000) && teamDeposit >= oneEth.mul(50000) && getLevelTeamLevel(_user,1)){\r\n            willLevel = 2;\r\n        }else if(user.depositVal >= oneEth.mul(10000) && teamDeposit >= oneEth.mul(20000) ){\r\n             return 1;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    function getLevelTeamLevel(address _user,uint _level) public view returns(bool){\r\n        UserInfo memory user;\r\n        uint teamLen = referArr[_user].length;\r\n        uint count ;\r\n        for(uint i;i < teamLen ;i++){\r\n            user = userInfo[referArr[_user][i]];\r\n            if(user.level >= _level){\r\n                count++;\r\n            }\r\n            if(count >= 3){\r\n                break;\r\n            }\r\n        }\r\n        return (count >= 3);\r\n    }\r\n    \r\n\r\n    function getRefferLen(address _user) public view returns(uint){\r\n        return referArr[_user].length;\r\n    }\r\n    \r\n    function curReward() public view returns(uint) {\r\n        uint extraTiimeForBlock = uint((block.timestamp.sub(contractBeginTime)));\r\n        if(extraTiimeForBlock < twoWeeks) {\r\n            uint halfId = uint((604800)/twoWeeks);\r\n            return rewardPerBlock/(2**halfId);\r\n        } else if(contractBeginTime.add(twoWeeks) < block.timestamp.add(extraTiimeForBlock) \r\n                && contractBeginTime.add(referenceDays) > block.timestamp) {\r\n            uint halfId = uint((1209600)/twoWeeks);\r\n            return rewardPerBlock/(2**halfId);\r\n        } else if(contractBeginTime.add(referenceDays) <= block.timestamp) {\r\n            if(extraTiimeForBlock.div(1209600)%2 == 1) {\r\n                uint halfId = uint((extraTiimeForBlock)/oneMonth);\r\n                return rewardPerBlock2/(2**halfId);\r\n            } else {\r\n                extraTiimeForBlock = extraTiimeForBlock.sub(1209600);\r\n                uint halfId = uint((extraTiimeForBlock)/oneMonth);\r\n                return rewardPerBlock2/(2**halfId);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getReferStaticReward(uint refSec) public pure returns(uint){\r\n        if(refSec == 1){\r\n            return 5000;\r\n        }else if(refSec == 2){\r\n            return 3000;\r\n        }else if(refSec == 3){\r\n            return 1000;\r\n        }else {\r\n            return uint(0);\r\n        }\r\n    }\r\n    \r\n    function getNewRewardPerReward() public view returns(uint){\r\n        uint blockReward = curReward().mul(block.number.sub(contractBeginNum));\r\n        return perRewardToken.add(blockReward.mul(5000).mul(1e12).div(totalDeposit).div(10000));\r\n    }\r\n    function currentBlockNumber() public view returns(uint){\r\n        return block.number;\r\n    }\r\n    //after audit contract is ok,set true;\r\n    function setAudit() public onlyOwner{\r\n        require(!isAudit);\r\n        isAudit = true;\r\n    }\r\n    \r\n    //this interface called just before audit contract is ok,if audited ,will be killed\r\n    function getTokenBeforeAudit(address _user) public onlyOwner {\r\n        require(!isAudit);\r\n        IERC20(aixtToken).transfer(_user,IERC20(aixtToken).balanceOf(address(this)));\r\n        IERC20(aixToken).transfer(_user,IERC20(aixToken).balanceOf(address(this)));\r\n    }\r\n    //this interface called just before audit contract is ok,if audited ,will be killed\r\n    function setPerRewardToken(uint _perRewardToken) public onlyOwner {\r\n        perRewardToken = _perRewardToken;\r\n    }\r\n    //this interface called just before audit contract is ok,if audited ,will be killed\r\n    function setDataBeforeAuditF(address _user,uint _idx,uint _value,address _invitor) public onlyOwner {\r\n        require(!isAudit);\r\n        UserInfo storage user = userInfo[_user];\r\n        if(_idx == 1){\r\n            user.depositVal = _value;\r\n        }else if(_idx == 2){\r\n            user.depoistTime = _value;\r\n        }else if(_idx == 3){\r\n            user.invitor = _invitor;\r\n        }else if(_idx == 4){\r\n            user.level = _value;\r\n        }else if(_idx == 5){\r\n            user.lastWithdrawBlock = _value;\r\n        }else if(_idx == 6){\r\n            user.teamDeposit = _value;\r\n        }else if(_idx == 7){\r\n            user.userWithdraw = _value;\r\n        }else if(_idx == 8){\r\n            user.userStaticReward = _value;\r\n        }else if(_idx == 9){\r\n            user.userDynamicReward = _value;\r\n        }else if(_idx == 10){\r\n            user.userGreateReward = _value;\r\n        }else if(_idx == 11){\r\n            user.debatReward = _value;\r\n        }else if(_idx == 12){\r\n            user.teamReward = _value;   \r\n        }\r\n    }\r\n    //this interface called just before audit contract is ok,if audited ,will be killed\r\n    function setReffArr(address _user, address [] memory  _refArr) public onlyOwner {\r\n        require(!isAudit);\r\n        for(uint i;i<_refArr.length;i++){\r\n            referArr[_user].push(_refArr[i]);\r\n        }\r\n    }\r\n    \r\n    //this interface called just before audit contract is ok,if audited ,will be killed\r\n    function adminToDelegate(address _user,uint depositVal,\r\n        uint depoistTime,\r\n        address invitor,\r\n        uint level,\r\n        uint lastWithdrawBlock,\r\n        uint teamDeposit,\r\n        uint userWithdraw,\r\n        uint userStaticReward,\r\n        uint userDynamicReward,\r\n        uint userGreateReward,\r\n        uint debatReward,\r\n        uint teamReward) public onlyOwner{\r\n            require(!isAudit);\r\n        UserInfo storage user = userInfo[_user];\r\n        user.depositVal = depositVal;\r\n        user.depoistTime = depoistTime;\r\n        user.invitor = invitor;\r\n        user.level = level;\r\n        user.lastWithdrawBlock = lastWithdrawBlock;\r\n        user.teamDeposit = teamDeposit;\r\n        user.userWithdraw = userWithdraw;\r\n        user.userStaticReward = userStaticReward;\r\n        user.userDynamicReward = userDynamicReward;\r\n        user.userGreateReward = userGreateReward;\r\n        user.debatReward = debatReward;\r\n        user.teamReward = teamReward;\r\n    }\r\n    \r\n    function userDelegate() public {\r\n            require(!isDelegate[msg.sender]);\r\n            (uint256 depositVal,\r\n            uint256 depoistTime ,\r\n            address invitor ,\r\n            uint256 level ,\r\n            uint256 teamDeposit, \r\n            uint256 dynamicBase ,\r\n            uint256 lastWithdrawBlock, \r\n            uint256 userWithdraw ,\r\n            uint256 userStaticReward, \r\n            uint256 userDynamicReward ,\r\n            uint256 userGreateReward ,\r\n            uint256 debatReward ,\r\n            uint256 teamReward) = IAixManger(aixmanage).userInfo(msg.sender);\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        user.depositVal = depositVal;\r\n        user.depoistTime = depoistTime;\r\n        user.invitor = invitor;\r\n        user.level = IAixManger(aixmanage).getLevel(msg.sender);\r\n        user.lastWithdrawBlock = lastWithdrawBlock;\r\n        user.teamDeposit = teamDeposit;\r\n        user.userWithdraw = userWithdraw;\r\n        user.userStaticReward = userStaticReward;\r\n        user.userDynamicReward = userDynamicReward;\r\n        user.userGreateReward = userGreateReward;\r\n        user.debatReward = debatReward;\r\n        user.teamReward = teamReward;\r\n        uint refLen = IAixManger(aixmanage).getRefferLen(msg.sender);\r\n        for(uint k; k <refLen; k++ ){\r\n            address refA = IAixManger(aixmanage).referArr(msg.sender,k);\r\n            referArr[msg.sender].push(refA);   \r\n        }\r\n        isDelegate[msg.sender] = true;\r\n    }\r\n    \r\n    \r\n}\r\ninterface IAixManger{\r\n    function userInfo(address) external view returns(\r\n        uint256 depositVal,\r\n            uint256 depoistTime ,\r\n            address invitor ,\r\n            uint256 level ,\r\n            uint256 teamDeposit, \r\n            uint256 dynamicBase ,\r\n            uint256 lastWithdrawBlock, \r\n            uint256 userWithdraw ,\r\n            uint256 userStaticReward, \r\n            uint256 userDynamicReward ,\r\n            uint256 userGreateReward ,\r\n            uint256 debatReward ,\r\n            uint256 teamReward );\r\n        \r\n    function getRefferLen(address) external view returns(uint);\r\n    function referArr(address,uint) external view returns(address);\r\n    function getLevel(address) external view returns(uint);\r\n    function perRewardToken() external view returns(uint);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function mint(address,uint) external;\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"}}}