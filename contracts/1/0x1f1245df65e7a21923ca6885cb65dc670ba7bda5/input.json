{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/FarmFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.7.0;\n\nlibrary EnumerableSet {\n  struct Set {\n    bytes32[] _values;\n    mapping (bytes32 => uint256) _indexes;\n  }\n\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    uint256 valueIndex = set._indexes[value];\n    if (valueIndex != 0) {\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n      bytes32 lastvalue = set._values[lastIndex];\n      set._values[toDeleteIndex] = lastvalue;\n      set._indexes[lastvalue] = toDeleteIndex + 1;\n      set._values.pop();\n      delete set._indexes[value];\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n    return set._values[index];\n  }\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(value)));\n  }\n\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(value)));\n  }\n\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(value)));\n  }\n\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint256(_at(set._inner, index)));\n  }\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n}\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n}\n\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () internal {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\n\ncontract FarmFactory is Context, Ownable {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  EnumerableSet.AddressSet private farms;\n  EnumerableSet.AddressSet private farmGenerators;\n\n  mapping (address => EnumerableSet.AddressSet) private userFarms;\n\n  constructor() public { }\n\n  function adminAllowFarmGenerator(address _address, bool _allow) public onlyOwner {\n    if (_allow) {\n      farmGenerators.add(_address);\n    } else {\n      farmGenerators.remove(_address);\n    }\n  }\n\n  /**\n   * @notice called by a registered FarmGenerator upon Farm creation\n   */\n  function registerFarm(address _farmAddress) public {\n    require(farmGenerators.contains(_msgSender()), 'FORBIDDEN');\n    farms.add(_farmAddress);\n  }\n\n  /**\n   * @notice Number of allowed FarmGenerators\n   */\n  function farmGeneratorsLength() external view returns (uint256) {\n    return farmGenerators.length();\n  }\n\n  /**\n   * @notice Gets the address of a registered FarmGenerator at specifiex index\n   */\n  function farmGeneratorAtIndex(uint256 _index) external view returns (address) {\n    return farmGenerators.at(_index);\n  }\n\n  /**\n   * @notice The length of all farms on the platform\n   */\n  function farmsLength() external view returns (uint256) {\n    return farms.length();\n  }\n\n  /**\n   * @notice gets a farm at a specific index. Although using Enumerable Set, since farms are only added and not removed this will never change\n   * @return the address of the Farm contract at index\n   */\n  function farmAtIndex(uint256 _index) external view returns (address) {\n    return farms.at(_index);\n  }\n\n  /**\n   * @notice called by a Farm contract when lp token balance changes from 0 to > 0 to allow tracking all farms a user is active in\n   */\n  function userEnteredFarm(address _user) public {\n    // msgSender = farm contract\n    address msgSender = _msgSender();\n    require(farms.contains(msgSender), 'FORBIDDEN');\n    EnumerableSet.AddressSet storage set = userFarms[_user];\n    set.add(msgSender);\n  }\n\n  /**\n   * @notice called by a Farm contract when all LP tokens have been withdrawn, removing the farm from the users active farm list\n   */\n  function userLeftFarm(address _user) public {\n    // msgSender = farm contract\n    address msgSender = _msgSender();\n    require(farms.contains(msgSender), 'FORBIDDEN');\n    EnumerableSet.AddressSet storage set = userFarms[_user];\n    set.remove(msgSender);\n  }\n\n  /**\n   * @notice returns the number of farms the user is active in\n   */\n  function userFarmsLength(address _user) external view returns (uint256) {\n    EnumerableSet.AddressSet storage set = userFarms[_user];\n    return set.length();\n  }\n\n  /**\n   * @notice called by a Farm contract when all LP tokens have been withdrawn, removing the farm from the users active farm list\n   * @return the address of the Farm contract the user is farming\n   */\n  function userFarmAtIndex(address _user, uint256 _index) external view returns (address) {\n    EnumerableSet.AddressSet storage set = userFarms[_user];\n    return set.at(_index);\n  }\n}\n"
    }
  }
}