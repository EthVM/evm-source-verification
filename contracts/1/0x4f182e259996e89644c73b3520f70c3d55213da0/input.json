{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Untitled.sol":{"content":"\n// File: contracts/interfaces/IERC20.sol\n\npragma solidity ^0.6.6;\n\n\ninterface IERC20 {\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) external returns (bool success);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n}\n\n// File: contracts/interfaces/ICollateralAuction.sol\n\npragma solidity ^0.6.6;\n\n\n\ninterface ICollateralAuction {\n    function baseToken() external returns(IERC20);\n\n    function auctions(uint256 _auctionId) external view returns (\n        IERC20 fromToken,    // Token that we are intending to sell\n        uint64 startTime,    // Start time of the auction\n        uint32 limitDelta,   // Limit time until all collateral is offered\n        uint256 startOffer,  // Start offer of `fromToken` for the requested `amount`\n        uint256 amount,      // Amount that we need to receive of `baseToken`\n        uint256 limit        // Limit of how much are willing to spend of `fromToken`\n    );\n\n    function getAuctionsLength() external view returns (uint256);\n    function take(uint256 _id, bytes calldata _data, bool _callback) external;\n\n    // return How much is being requested and how much is being offered\n    function offer(uint256 _auctionId) external view returns (uint256 selling, uint256 requesting);\n}\n\n// File: contracts/test/WETH9.sol\n\npragma solidity ^0.6.1;\n\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad, \"The sender dont have balance\");\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"The sender dont have balance\");\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"The sender dont have allowance\");\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n// File: contracts/interfaces/IUniswapV2Router02.sol\n\npragma solidity ^0.6.6;\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n// File: contracts/utils/Ownable.sol\n\npragma solidity ^0.6.1;\n\n\ncontract Ownable {\n    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n\n    address internal _owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"The owner should be the sender\");\n        _;\n    }\n\n    constructor() public {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0x0), msg.sender);\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"0x0 Is not a valid owner\");\n        emit OwnershipTransferred(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n}\n\n// File: contracts/AuctionTakeHelper.sol\n\npragma solidity ^0.6.1;\n\n\n\n\n\n\n\n/**\n  @author Victor Fage <victorfage@gmail.com>\n*/\ncontract AuctionTakeHelper is Ownable {\n\tICollateralAuction public collateralAuction;\n\tIERC20 public baseToken;\n\n\tIUniswapV2Router02 public router;\n\tIERC20 public WETH;\n\n\tconstructor(ICollateralAuction _collateralAuction, IUniswapV2Router02 _router) public {\n\t\tcollateralAuction = _collateralAuction;\n\t\tbaseToken = collateralAuction.baseToken();\n\n\t\tsetRouter(_router);\n\t\treApprove();\n\t}\n\n\tfunction getProfitAmount(uint256 _auctionId) external view returns(uint256) {\n\t\t(IERC20 fromToken,,,,,) = collateralAuction.auctions(_auctionId);\n\n\t\tif (fromToken == baseToken)\n\t\t\treturn 0;\n\n\t\t(uint256 amountGet, uint256 amountReturn) = collateralAuction.offer(_auctionId);\n\n\t\taddress[] memory path = new address[](2);\n\t\tuint256[] memory amounts;\n\n\t\tif (fromToken != WETH) {\n\t\t\t// Calculate amount get in WETH, converting fromToken to WETH\n\t\t\tpath[0] = address(fromToken);\n\t\t\tpath[1] = address(WETH);\n\t\t\tamounts = router.getAmountsIn(amountGet, path);\n\t\t\tamountGet = amounts[1];\n\t\t}\n\n\t\t// Calculate amount return in WETH, converting WETH to baseToken, to pay the auction\n\t\tpath[0] = address(WETH);\n\t\tpath[1] = address(baseToken);\n\t\tamounts = router.getAmountsOut(amountReturn, path);\n\t\tamountReturn = amounts[0];\n\n\t\treturn amountGet >= amountReturn ? amountGet - amountReturn : 0;\n\t}\n\n\tfunction take(uint256 _auctionId, bytes calldata _data, uint256 _profit) external {\n\t\tcollateralAuction.take(_auctionId, _data, true);\n\n\t\tuint256 wethBal = WETH.balanceOf(address(this));\n\t\trequire(wethBal >= _profit, \"take: dont get profit\");\n\n\t\tif (wethBal != 0) {\n\t\t\tWETH9(payable(address(WETH))).withdraw(wethBal);\n\t\t\tpayable(_owner).transfer(wethBal);\n\t\t}\n\t}\n\n\tfunction onTake(IERC20 _fromToken, uint256 _amountGet, uint256 _amountReturn) external {\n\t\trequire(msg.sender == address(collateralAuction), \"onTake: The sender should be the collateralAuction\");\n\n\t\tif (_fromToken == baseToken)\n\t\t\treturn;\n\n\t\taddress[] memory path = new address[](2);\n\n\t\tif (_fromToken != WETH) {\n\t\t\t_fromToken.approve(address(router), _amountGet);\n\n\t\t\t// Converting fromToken to WETH\n\t\t\tpath[0] = address(_fromToken);\n\t\t\tpath[1] = address(WETH);\n\t\t\tuint256[] memory amounts = router.swapExactTokensForTokens({\n\t\t\t\tamountIn:     _amountGet,\n\t\t\t\tamountOutMin: 0,\n\t\t\t\tpath: \t\t\t\tpath,\n\t\t\t\tto: \t\t\t\t\taddress(this),\n\t\t\t\tdeadline: \t\tuint(-1)\n\t\t\t});\n\t\t\t_amountGet = amounts[1];\n\t\t}\n\n\t\t// Converting WETH to baseToken, to pay the auction\n\t\tpath[0] = address(WETH);\n\t\tpath[1] = address(baseToken);\n\t\trouter.swapTokensForExactTokens({\n\t\t\tamountOut: \t _amountReturn,\n\t\t\tamountInMax: _amountGet,\n\t\t\tpath: \t\t\t path,\n\t\t\tto:\t\t\t\t   address(this),\n\t\t\tdeadline: \t uint(-1)\n\t\t});\n\t}\n\n\tfallback() external payable { }\n\n\treceive() external payable { }\n\n\tfunction withdrawERC20(IERC20 _token) external onlyOwner {\n\t\trequire(_token.transfer(_owner, _token.balanceOf(address(this))), \"withdraw: error transfer the tokens\");\n\t}\n\n\tfunction withdrawETH() external onlyOwner {\n\t\tpayable(_owner).transfer(address(this).balance);\n\t}\n\n\tfunction setRouter(IUniswapV2Router02 _router) public onlyOwner {\n\t\trouter = _router;\n\t\tWETH = IERC20(router.WETH());\n\t}\n\n\tfunction reApprove() public onlyOwner {\n\t\tWETH.approve(address(router), uint(-1));\n\t\tbaseToken.approve(address(collateralAuction), uint(-1));\n\t}\n}\n"}}}