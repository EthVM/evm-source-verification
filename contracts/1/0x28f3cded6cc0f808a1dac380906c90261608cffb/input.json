{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"PearlClaim.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0), \"ERC20: sending to the zero address\");\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n    function transfer(address to, uint256 tokens) external returns (bool success);\r\n}\r\n\r\ninterface ILooksRareAirdrop {\r\n    function hasClaimed(address wallet) external view returns (bool claimed);\r\n}\r\n\r\ninterface ILooksRareStaking {\r\n    function userInfo(address wallet) external view returns (uint256 amount, uint256 rewardDebt);\r\n}\r\n\r\ncontract PearlClaim is Ownable {\r\n    \r\n    event Claimed(address indexed wallet, address indexed token);\r\n    event Burned(address indexed token, uint256 amount);\r\n    event Recovered(address indexed token, uint256 amount, address indexed recipient);\r\n\r\n    mapping(address => bool) public walletHasClaimed;\r\n    mapping(address => bool) public claimEnded;\r\n    IERC20 public token;\r\n    IERC20 public constant looksRareToken = IERC20(0xf4d2888d29D722226FafA5d9B24F9164c092421E);\r\n    ILooksRareAirdrop public constant looksAirdrop = ILooksRareAirdrop(0xA35dce3e0E6ceb67a30b8D7f4aEe721C949B5970);\r\n    ILooksRareStaking public constant looksStaking = ILooksRareStaking(0x465A790B428268196865a3AE2648481ad7e0d3b1);\r\n    uint256 public multiplier = 22500;\r\n        \r\n    constructor() {\r\n        token = IERC20(address(0xe3451FD6c9f259fdB065834C719f40b64DCa09F0));\r\n    }\r\n\r\n    function updateToken(address _token) external onlyOwner {\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    function updateMultiplier(uint256 multi) external onlyOwner {\r\n        multiplier = multi;\r\n    }\r\n\r\n    function userAmountToClaim(address wallet) public view returns (uint256){\r\n        if(!looksAirdrop.hasClaimed(wallet) || walletHasClaimed[wallet]){\r\n            return 0;\r\n        }\r\n        (uint256 amountStaked,) = looksStaking.userInfo(wallet);\r\n        uint256 totalAmountOfLooks = amountStaked + looksRareToken.balanceOf(wallet);\r\n        uint256 transferToAmount = totalAmountOfLooks * multiplier;\r\n        return transferToAmount;\r\n    }\r\n\r\n    function claimTokens() external {\r\n        require(!walletHasClaimed[msg.sender], \"Wallet has already claimed these tokens.\");\r\n        require(looksAirdrop.hasClaimed(msg.sender), \"You are not eligible to claim\");\r\n        uint256 transferToAmount = userAmountToClaim(msg.sender);\r\n\r\n        walletHasClaimed[msg.sender] = true;\r\n\r\n        require(token.balanceOf(address(this)) >= transferToAmount, \"Not enough tokens to transfer\");\r\n        require(token.transfer(address(msg.sender), transferToAmount), \"Error in withdrawing tokens\");\r\n        emit Claimed(msg.sender, address(token));\r\n    }\r\n\r\n    function transferToken(address _token, address _to) external onlyOwner returns (bool _sent) {\r\n        require(_token != address(0), \"_token address cannot be 0\");\r\n        require(_to != address(0), \"_to address cannot be 0\");\r\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\r\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\r\n        if(_sent){\r\n            emit Recovered(_token, _contractBalance, _to);\r\n        }\r\n    }\r\n}"}}}