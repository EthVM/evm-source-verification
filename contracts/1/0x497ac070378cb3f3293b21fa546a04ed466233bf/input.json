{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ArbSomeShit.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function symbol() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n}\r\n\r\ninterface ICoverERC20 is IERC20 {\r\n    function burn(uint256 _amount) external returns (bool);\r\n\r\n    /// @notice access restriction - owner (Cover)\r\n    function mint(address _account, uint256 _amount) external returns (bool);\r\n    function setSymbol(string calldata _symbol) external returns (bool);\r\n    function burnByCover(address _account, uint256 _amount) external returns (bool);\r\n}\r\n\r\ninterface ICover {\r\n  event NewCoverERC20(address);\r\n\r\n  function getCoverDetails()\r\n    external view returns (string memory _name, uint48 _expirationTimestamp, address _collateral, uint256 _claimNonce, ICoverERC20 _claimCovToken, ICoverERC20 _noclaimCovToken);\r\n  function expirationTimestamp() external view returns (uint48);\r\n  function collateral() external view returns (address);\r\n  function claimCovToken() external view returns (ICoverERC20);\r\n  function noclaimCovToken() external view returns (ICoverERC20);\r\n  function name() external view returns (string memory);\r\n  function claimNonce() external view returns (uint256);\r\n\r\n  function redeemClaim() external;\r\n  function redeemNoclaim() external;\r\n  function redeemCollateral(uint256 _amount) external;\r\n\r\n  /// @notice access restriction - owner (Protocol)\r\n  function mint(uint256 _amount, address _receiver) external;\r\n\r\n  /// @notice access restriction - dev\r\n  function setCovTokenSymbol(string calldata _name) external;\r\n}\r\n\r\ninterface IBalancerPool {\r\n    function swapExactAmountIn(address, uint, address, uint, uint) external returns (uint, uint);\r\n    function swapExactAmountOut(address, uint, address, uint, uint) external returns (uint, uint);\r\n}\r\n\r\ncontract ArbSomeShit is Ownable {\r\n    IERC20 public DAI;\r\n\r\n    constructor() public Ownable() {\r\n      DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n    }\r\n\r\n    function burningArb(\r\n      ICover _cover,\r\n      IBalancerPool _claimPool,\r\n      IBalancerPool _noclaimPool,\r\n      uint _amount\r\n    ) external {\r\n      // step 1\r\n      DAI.transferFrom(msg.sender, address(this), _amount);\r\n\r\n      // step 2\r\n      _daiToTokenOnBalancer(_noclaimPool, _cover.noclaimCovToken(), _amount);\r\n      _daiToTokenOnBalancer(_claimPool, _cover.claimCovToken(), _amount);\r\n      _cover.redeemCollateral(_amount);\r\n\r\n      // step 3\r\n      uint256 new_balance = DAI.balanceOf(address(this));\r\n      require(new_balance > _amount, \"No arbys\");\r\n      require(DAI.transfer(msg.sender, new_balance), \"ERR_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function _daiToTokenOnBalancer(\r\n      IBalancerPool _pool,\r\n      IERC20 _token,\r\n      uint _amount\r\n    ) private {\r\n      if (DAI.allowance(address(this), address(_pool)) < _amount) {\r\n        DAI.approve(address(_pool), _amount);\r\n      }\r\n      _pool.swapExactAmountOut(address(DAI), _amount, address(_token), _amount, 2**256 - 1);\r\n    }\r\n\r\n    function destroy() external onlyOwner {\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n    function withdraw(IERC20 _tokenAddress, address _destination) external onlyOwner {\r\n        require(_tokenAddress.balanceOf(address(this)) > 0, \"Cannot withdraw 0\");\r\n        _tokenAddress.transfer(_destination, _tokenAddress.balanceOf(address(this)));\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n}"}}}