{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1024
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "/Users/simondos/projects/micobo-security-token/contracts/erc1820/ERC1820Client.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @dev Taken from node_modules/erc1820\n * updated solidity version\n * commented out interfaceAddr & delegateManagement\n */\ninterface ERC1820Registry {\n\tfunction setInterfaceImplementer(\n\t\taddress _addr,\n\t\tbytes32 _interfaceHash,\n\t\taddress _implementer\n\t) external;\n\n\tfunction getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\n\t\texternal\n\t\tview\n\t\treturns (address);\n\n\tfunction setManager(address _addr, address _newManager) external;\n\n\tfunction getManager(address _addr) external view returns (address);\n}\n\n\n/// Base client to interact with the registry.\ncontract ERC1820Client {\n\tERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\n\t\t0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\n\t);\n\n\tfunction setInterfaceImplementation(\n\t\tstring memory _interfaceLabel,\n\t\taddress _implementation\n\t) internal {\n\t\tbytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n\t\tERC1820REGISTRY.setInterfaceImplementer(\n\t\t\taddress(this),\n\t\t\tinterfaceHash,\n\t\t\t_implementation\n\t\t);\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/gsn/GSNRecipient.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../../node_modules/@openzeppelin/contracts/GSN/IRelayRecipient.sol\";\nimport \"../../node_modules/@openzeppelin/contracts/GSN/IRelayHub.sol\";\nimport \"../../node_modules/@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"../storage/SecurityTokenStorage.sol\";\n\n\n// copied here to be included in coverage\n\n/**\n * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface\n * and enables GSN support on all contracts in the inheritance tree.\n *\n * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},\n *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be\n * provided by derived contracts. See the\n * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more\n * information on how to use the pre-built {GSNRecipientSignature} and\n * {GSNRecipientERC20Fee}, or how to write your own.\n */\nabstract contract GSNRecipient is\n\tSecurityTokenStorage,\n\tIRelayRecipient,\n\tContext\n{\n\t/**\n\t * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.\n\t */\n\tevent RelayHubChanged(\n\t\taddress indexed oldRelayHub,\n\t\taddress indexed newRelayHub\n\t);\n\n\t/**\n\t * @dev Returns the address of the {IRelayHub} contract for this recipient.\n\t */\n\tfunction getHubAddr() public override view returns (address) {\n\t\treturn _relayHub;\n\t}\n\n\t/**\n\t * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not\n\t * use the default instance.\n\t *\n\t * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old\n\t * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.\n\t */\n\tfunction _upgradeRelayHub(address newRelayHub) internal virtual {\n\t\taddress currentRelayHub = _relayHub;\n\t\trequire(newRelayHub != address(0), \"zero address\");\n\t\trequire(newRelayHub != currentRelayHub, \"current one\");\n\n\t\temit RelayHubChanged(currentRelayHub, newRelayHub);\n\n\t\t_relayHub = newRelayHub;\n\t}\n\n\t/**\n\t * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If\n\t * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.\n\t */\n\t// This function is view for future-proofing, it may require reading from\n\t// storage in the future.\n\tfunction relayHubVersion() public view returns (string memory) {\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn \"1.0.0\";\n\t}\n\n\t/**\n\t * @dev Withdraws the recipient's deposits in `RelayHub`.\n\t *\n\t * Derived contracts should expose this in an external interface with proper access control.\n\t */\n\tfunction _withdrawDeposits(uint256 amount, address payable payee)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\tIRelayHub(_relayHub).withdraw(amount, payee);\n\t}\n\n\t// Overrides for Context's functions: when called from RelayHub, sender and\n\t// data require some pre-processing: the actual sender is stored at the end\n\t// of the call data, which in turns means it needs to be removed from it\n\t// when handling said data.\n\n\t/**\n\t * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\n\t * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).\n\t *\n\t * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.\n\t */\n\tfunction _msgSender()\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t\tview\n\t\treturns (address payable)\n\t{\n\t\tif (msg.sender != _relayHub) {\n\t\t\treturn msg.sender;\n\t\t} else {\n\t\t\treturn _getRelayedCallSender();\n\t\t}\n\t}\n\n\t/**\n\t * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,\n\t * and a reduced version for GSN relayed calls (where msg.data contains additional information).\n\t *\n\t * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.\n\t */\n\tfunction _msgData() internal virtual override view returns (bytes memory) {\n\t\tif (msg.sender != _relayHub) {\n\t\t\treturn msg.data;\n\t\t} else {\n\t\t\treturn _getRelayedCallData();\n\t\t}\n\t}\n\n\t// Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the\n\t// internal hook.\n\n\t/**\n\t * @dev See `IRelayRecipient.preRelayedCall`.\n\t *\n\t * This function should not be overriden directly, use `_preRelayedCall` instead.\n\t *\n\t * * Requirements:\n\t *\n\t * - the caller must be the `RelayHub` contract.\n\t */\n\tfunction preRelayedCall(bytes memory context)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bytes32)\n\t{\n\t\trequire(msg.sender == getHubAddr(), \"not hub\");\n\t\treturn _preRelayedCall(context);\n\t}\n\n\t/**\n\t * @dev See `IRelayRecipient.preRelayedCall`.\n\t *\n\t * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\n\t * must implement this function with any relayed-call preprocessing they may wish to do.\n\t *\n\t */\n\tfunction _preRelayedCall(bytes memory context)\n\t\tinternal\n\t\tvirtual\n\t\treturns (bytes32);\n\n\t/**\n\t * @dev See `IRelayRecipient.postRelayedCall`.\n\t *\n\t * This function should not be overriden directly, use `_postRelayedCall` instead.\n\t *\n\t * * Requirements:\n\t *\n\t * - the caller must be the `RelayHub` contract.\n\t */\n\tfunction postRelayedCall(\n\t\tbytes memory context,\n\t\tbool success,\n\t\tuint256 actualCharge,\n\t\tbytes32 preRetVal\n\t) public virtual override {\n\t\trequire(msg.sender == getHubAddr(), \"not hub\");\n\t\t_postRelayedCall(context, success, actualCharge, preRetVal);\n\t}\n\n\t/**\n\t * @dev See `IRelayRecipient.postRelayedCall`.\n\t *\n\t * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\n\t * must implement this function with any relayed-call postprocessing they may wish to do.\n\t *\n\t */\n\tfunction _postRelayedCall(\n\t\tbytes memory context,\n\t\tbool success,\n\t\tuint256 actualCharge,\n\t\tbytes32 preRetVal\n\t) internal virtual;\n\n\t/**\n\t * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract\n\t * will be charged a fee by RelayHub\n\t */\n\tfunction _approveRelayedCall()\n\t\tinternal\n\t\tview\n\t\treturns (uint256, bytes memory)\n\t{\n\t\treturn _approveRelayedCall(\"\");\n\t}\n\n\t/**\n\t * @dev See `GSNRecipient._approveRelayedCall`.\n\t *\n\t * This overload forwards `context` to _preRelayedCall and _postRelayedCall.\n\t */\n\tfunction _approveRelayedCall(bytes memory context)\n\t\tinternal\n\t\tview\n\t\treturns (uint256, bytes memory)\n\t{\n\t\treturn (_RELAYED_CALL_ACCEPTED, context);\n\t}\n\n\t/**\n\t * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.\n\t */\n\tfunction _rejectRelayedCall(uint256 errorCode)\n\t\tinternal\n\t\tview\n\t\treturns (uint256, bytes memory)\n\t{\n\t\treturn (_RELAYED_CALL_REJECTED + errorCode, \"\");\n\t}\n\n\t/*\n\t * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's\n\t * `serviceFee`.\n\t */\n\tfunction _computeCharge(\n\t\tuint256 gas,\n\t\tuint256 gasPrice,\n\t\tuint256 serviceFee\n\t) internal pure returns (uint256) {\n\t\t// The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be\n\t\t// charged for 1.4 times the spent amount.\n\t\treturn (gas * gasPrice * (100 + serviceFee)) / 100;\n\t}\n\n\tfunction _getRelayedCallSender()\n\t\tprivate\n\t\tpure\n\t\treturns (address payable result)\n\t{\n\t\t// We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\n\t\t// is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\n\t\t// so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\n\t\t// require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\n\t\t// bytes. This can always be done due to the 32-byte prefix.\n\n\t\t// The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\n\t\t// easiest/most-efficient way to perform this operation.\n\n\t\t// These fields are not accessible from assembly\n\t\tbytes memory array = msg.data;\n\t\tuint256 index = msg.data.length;\n\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\t// Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n\t\t\tresult := and(\n\t\t\t\tmload(add(array, index)),\n\t\t\t\t0xffffffffffffffffffffffffffffffffffffffff\n\t\t\t)\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction _getRelayedCallData() private pure returns (bytes memory) {\n\t\t// RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,\n\t\t// we must strip the last 20 bytes (length of an address type) from it.\n\n\t\tuint256 actualDataLength = msg.data.length - 20;\n\t\tbytes memory actualData = new bytes(actualDataLength);\n\n\t\tfor (uint256 i = 0; i < actualDataLength; ++i) {\n\t\t\tactualData[i] = msg.data[i];\n\t\t}\n\n\t\treturn actualData;\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/gsn/GSNable.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../../node_modules/@openzeppelin/contracts/GSN/IRelayRecipient.sol\";\nimport \"./GSNRecipient.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title GSNable\n * @dev enables GSN capability by implementing GSNRecipient\n * Can be set to accept ALL, NONE or add a MODULE implementing restrictions\n */\ncontract GSNable is GSNRecipient {\n\t/**\n\t * @dev Emitted when a new GSN mode is set\n\t */\n\tevent GSNModeSet(gsnMode);\n\n\t/**\n\t * @dev Emitted when a new GSN module address is set\n\t */\n\tevent GSNModuleSet(IRelayRecipient);\n\n\t/**\n\t * @dev Add access control by overriding this function!\n\t * should return true if sender is authorized\n\t */\n\tfunction _isGSNController() internal virtual view returns (bool) {\n\t\tthis;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Address of the GSN MODULE implementing IRelayRecipient\n\t */\n\tIRelayRecipient private _gsnModule = IRelayRecipient(address(0));\n\n\t/**\n\t * @dev Modifier to make a function callable only when _isGSNController returns true\n\t */\n\tmodifier onlyGSNController() {\n\t\trequire(_isGSNController(), \"!GSN_CONTROLLER\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev doc in IRelayRecipient\n\t */\n\tfunction acceptRelayedCall(\n\t\taddress relay,\n\t\taddress from,\n\t\tbytes calldata encodedFunction,\n\t\tuint256 transactionFee,\n\t\tuint256 gasPrice,\n\t\tuint256 gasLimit,\n\t\tuint256 nonce,\n\t\tbytes calldata approvalData,\n\t\tuint256 maxPossibleCharge\n\t) external override view returns (uint256, bytes memory) {\n\t\tif (_gsnMode == gsnMode.ALL) {\n\t\t\treturn _approveRelayedCall();\n\t\t} else if (_gsnMode == gsnMode.MODULE) {\n\t\t\treturn\n\t\t\t\t_gsnModule.acceptRelayedCall(\n\t\t\t\t\trelay,\n\t\t\t\t\tfrom,\n\t\t\t\t\tencodedFunction,\n\t\t\t\t\ttransactionFee,\n\t\t\t\t\tgasPrice,\n\t\t\t\t\tgasLimit,\n\t\t\t\t\tnonce,\n\t\t\t\t\tapprovalData,\n\t\t\t\t\tmaxPossibleCharge\n\t\t\t\t);\n\t\t} else {\n\t\t\treturn _rejectRelayedCall(0);\n\t\t}\n\t}\n\n\t/**\n\t * @dev doc in IRelayRecipient\n\t */\n\tfunction _preRelayedCall(bytes memory context)\n\t\tinternal\n\t\toverride\n\t\treturns (bytes32)\n\t{\n\t\tif (_gsnMode == gsnMode.MODULE) {\n\t\t\treturn _gsnModule.preRelayedCall(context);\n\t\t}\n\t}\n\n\t/**\n\t * @dev doc in IRelayRecipient\n\t */\n\tfunction _postRelayedCall(\n\t\tbytes memory context,\n\t\tbool success,\n\t\tuint256 actualCharge,\n\t\tbytes32 preRetVal\n\t) internal override {\n\t\tif (_gsnMode == gsnMode.MODULE) {\n\t\t\treturn\n\t\t\t\t_gsnModule.postRelayedCall(\n\t\t\t\t\tcontext,\n\t\t\t\t\tsuccess,\n\t\t\t\t\tactualCharge,\n\t\t\t\t\tpreRetVal\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sets GSN mode to either ALL, NONE or MODULE\n\t * @param mode ALL, NONE or MODULE\n\t */\n\tfunction setGSNMode(gsnMode mode) public onlyGSNController {\n\t\t_gsnMode = gsnMode(mode);\n\t\temit GSNModeSet(mode);\n\t}\n\n\t/**\n\t * @dev Gets GSN mode\n\t * @return gsnMode ALL, NONE or MODULE\n\t */\n\tfunction getGSNMode() public view onlyGSNController returns (gsnMode) {\n\t\treturn _gsnMode;\n\t}\n\n\t/**\n\t * @dev Sets Module address for MODULE mode\n\t * @param newGSNModule Address of new GSN module\n\t */\n\tfunction setGSNModule(IRelayRecipient newGSNModule)\n\t\tpublic\n\t\tonlyGSNController\n\t{\n\t\t_gsnModule = newGSNModule;\n\t\temit GSNModuleSet(newGSNModule);\n\t}\n\n\t/**\n\t * @dev Upgrades the relay hub address\n\t * @param newRelayHub Address of new relay hub\n\t */\n\tfunction upgradeRelayHub(address newRelayHub) public onlyGSNController {\n\t\t_upgradeRelayHub(newRelayHub);\n\t}\n\n\t/**\n\t * @dev Withdraws GSN deposits for this contract\n\t * @param amount Amount to be withdrawn\n\t * @param payee Address to sned the funds to\n\t */\n\tfunction withdrawDeposits(uint256 amount, address payable payee)\n\t\tpublic\n\t\tonlyGSNController\n\t{\n\t\t_withdrawDeposits(amount, payee);\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IAdmin.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @author Simon Dosch\n * @title IAdmin\n * @dev Administrable interface\n */\ninterface IAdmin {\n\t/**\n\t * @param role Role that is being assigned\n\t * @param account The address that is being assigned a role\n\t * @dev Assigns a role to an account\n\t * only ADMIN\n\t */\n\tfunction addRole(bytes32 role, address account) external;\n\n\t/**\n\t * @param roles Roles that are being assigned\n\t * @param accounts The addresses that are being assigned a role\n\t * @dev Assigns a bulk of roles to accounts\n\t * only ADMIN\n\t */\n\tfunction bulkAddRole(bytes32[] calldata roles, address[] calldata accounts)\n\t\texternal;\n\n\t/**\n\t * @param role Role that is being removed\n\t * @param account The address that a role is removed from\n\t * @dev Removes a role from an account\n\t * only ADMIN\n\t */\n\tfunction removeRole(bytes32 role, address account) external;\n\n\t/**\n\t * @param role Role that is being renounced by the _msgSender()\n\t * @dev Removes a role from the sender's address\n\t */\n\tfunction renounceRole(bytes32 role) external;\n\n\t/**\n\t * @dev check if an account has a role\n\t * @return bool True if account has role\n\t */\n\tfunction hasRole(bytes32 role, address account)\n\t\texternal\n\t\tview\n\t\treturns (bool);\n\n\t/**\n\t * @dev Emitted when `account` is granted `role`.\n\t *\n\t * `sender` is the account that originated the contract call, an admin role\n\t * bearer except when using {_setupRole}.\n\t */\n\tevent RoleGranted(\n\t\tbytes32 indexed role,\n\t\taddress indexed account,\n\t\taddress indexed sender\n\t);\n\n\t/**\n\t * @dev Emitted when `account` is revoked `role`.\n\t *\n\t * `sender` is the account that originated the contract call:\n\t *   - if using `revokeRole`, it is the admin role bearer\n\t *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n\t */\n\tevent RoleRevoked(\n\t\tbytes32 indexed role,\n\t\taddress indexed account,\n\t\taddress indexed sender\n\t);\n\n\t/**\n\t * @dev Emitted whenever an account renounced a role\n\t */\n\tevent RoleRenounced(bytes32 indexed role, address indexed account);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IConstrainable.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../interfaces/IConstraintModule.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title IConstrainable\n * @dev Constrainable interface\n */\ninterface IConstrainable {\n\tevent ModulesByPartitionSet(\n\t\taddress indexed caller,\n\t\tbytes32 indexed partition,\n\t\tIConstraintModule[] newModules\n\t);\n\n\t/**\n\t * @dev Returns all modules for requested partition\n\t * @param partition Partition to get modules for\n\t * @return IConstraintModule[]\n\t */\n\tfunction getModulesByPartition(bytes32 partition)\n\t\texternal\n\t\tview\n\t\treturns (IConstraintModule[] memory);\n\n\t/**\n\t * @dev Sets all modules for partition\n\t * @param partition Partition to set modules for\n\t * @param newModules IConstraintModule[] array of new modules for this partition\n\t */\n\tfunction setModulesByPartition(\n\t\tbytes32 partition,\n\t\tIConstraintModule[] calldata newModules\n\t) external;\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IConstraintModule.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @author Simon Dosch\n * @title IConstraintModule\n * @dev ConstraintModule's interface\n */\ninterface IConstraintModule {\n\t// ConstraintModule should also implement an interface to the token they are referring to\n\t// to call functions like hasRole() from Administrable\n\n\t// string private _module_name;\n\n\t/**\n\t * @dev Validates live transfer. Can modify state\n\t * @param msg_sender Sender of this function call\n\t * @param partition Partition the tokens are being transferred from\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer.\n\t * @param operatorData Information attached to the transfer, by the operator.\n\t * @return valid transfer is valid\n\t * @return reason Why the transfer failed (intended for require statement)\n\t */\n\tfunction executeTransfer(\n\t\taddress msg_sender,\n\t\tbytes32 partition,\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external returns (bool valid, string memory reason);\n\n\t/**\n\t * @dev Returns module name\n\t * @return bytes32 name of the constraint module\n\t */\n\tfunction getModuleName() external view returns (bytes32);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @title IERC1400 token standard\n * @dev ERC1400 interface\n */\ninterface IERC1400 {\n\t// Document Management\n\t/**\n\t * [ERC1400 INTERFACE (1/9)]\n\t * @dev Access a document associated with the token.\n\t * @param documentName Short name (represented as a bytes32) associated to the document.\n\t * @return Requested document + document hash.\n\t */\n\tfunction getDocument(bytes32 documentName)\n\t\texternal\n\t\tview\n\t\treturns (string memory, bytes32); // 1/9\n\n\t/**\n\t * [ERC1400 INTERFACE (2/9)]\n\t * @dev Associate a document with the token.\n\t * @param documentName Short name (represented as a bytes32) associated to the document.\n\t * @param uri Document content.\n\t * @param documentHash Hash of the document [optional parameter].\n\t */\n\tfunction setDocument(\n\t\tbytes32 documentName,\n\t\tstring calldata uri,\n\t\tbytes32 documentHash\n\t) external; // 2/9\n\n\t/**\n\t * @dev Event emitted when a new document is set\n\t */\n\tevent Document(bytes32 indexed name, string uri, bytes32 documentHash);\n\n\t/**\n\t * [ERC1400 INTERFACE (3/9)]\n\t * @dev Know if the token can be controlled by operators.\n\t * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\n\t * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\n\t */\n\tfunction isControllable() external view returns (bool); // 3/9\n\n\t/**\n\t * [ERC1400 INTERFACE (4/9)]\n\t * @dev Know if new tokens can be issued in the future.\n\t * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\n\t */\n\tfunction isIssuable() external view returns (bool); // 4/9\n\n\t/**\n\t * [ERC1400 INTERFACE (5/9)]\n\t * @dev Issue tokens from a specific partition.\n\t * @param partition Name of the partition.\n\t * @param tokenHolder Address for which we want to issue tokens.\n\t * @param value Number of tokens issued.\n\t * @param data Information attached to the issuance, by the issuer.\n\t */\n\tfunction issueByPartition(\n\t\tbytes32 partition,\n\t\taddress tokenHolder,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external; // 5/9\n\n\t/**\n\t * @dev Event emitted when tokens were issued to a partition\n\t */\n\tevent IssuedByPartition(\n\t\tbytes32 indexed partition,\n\t\taddress indexed operator,\n\t\taddress indexed to,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes operatorData\n\t);\n\n\t/**\n\t * [ERC1400 INTERFACE (6/9)]\n\t * @dev Redeem tokens of a specific partition.\n\t * @param partition Name of the partition.\n\t * @param value Number of tokens redeemed.\n\t * @param data Information attached to the redemption, by the redeemer.\n\t */\n\tfunction redeemByPartition(\n\t\tbytes32 partition,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external; // 6/9\n\n\t/**\n\t * [ERC1400 INTERFACE (7/9)]\n\t * @dev Redeem tokens of a specific partition.\n\t * @param partition Name of the partition.\n\t * @param tokenHolder Address for which we want to redeem tokens.\n\t * @param value Number of tokens redeemed.\n\t * @param data Information attached to the redemption.\n\t * @param operatorData Information attached to the redemption, by the operator.\n\t */\n\tfunction operatorRedeemByPartition(\n\t\tbytes32 partition,\n\t\taddress tokenHolder,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external; // 7/9\n\n\t/**\n\t * @dev Event emitted when tokens are redeemed from a partition\n\t */\n\tevent RedeemedByPartition(\n\t\tbytes32 indexed partition,\n\t\taddress indexed operator,\n\t\taddress indexed from,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes operatorData\n\t);\n\n\t/**\n\t * [ERC1400 INTERFACE (8/9)]\n\t * function canTransferByPartition\n\t * not implemented\n\t */\n\n\t/**\n\t * [ERC1400 INTERFACE (9/9)]\n\t * function canOperatorTransferByPartition\n\t * not implemented\n\t */\n\n\t/********************** ERC1400 OPTIONAL FUNCTIONS **************************/\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400 STANDARD]\n\t * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\n\t * Once set to false, '_isControllable' can never be set to 'true' again.\n\t */\n\tfunction renounceControl() external;\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400 STANDARD]\n\t * @dev Definitely renounce the possibility to issue new tokens.\n\t * Once set to false, '_isIssuable' can never be set to 'true' again.\n\t */\n\tfunction renounceIssuance() external;\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400Capped.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @title IERC1400Capped\n * @dev ERC1400Capped interface\n */\ninterface IERC1400Capped {\n\t/**\n\t * @dev Returns the cap on the token's total supply.\n\t */\n\tfunction cap() external view returns (uint256);\n\n\t/**\n\t * @dev Sets cap to a new value\n\t * New value need to be higher than old one\n\t * Is only callable by CAP?_EDITOR\n\t * @param newCap value of new cap\n\t */\n\tfunction setCap(uint256 newCap) external;\n\n\t/**\n\t * @dev Event emitted when a new cap is set\n\t */\n\tevent CapSet(uint256 newCap);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400Partition.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @title IERC1400Partition partially fungible token standard\n * @dev ERC1400Partition interface\n */\ninterface IERC1400Partition {\n\t/**\n\t * @dev ERC20 backwards-compatibility\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/********************** NEW FUNCTIONS **************************/\n\n\t/**\n\t * @dev Returns the total supply of a given partition\n\t * For ERC20 compatibility via proxy\n\t * @param partition Requested partition\n\t * @return uint256 _totalSupplyByPartition\n\t */\n\tfunction totalSupplyByPartition(bytes32 partition)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\t/********************** ERC1400Partition EXTERNAL FUNCTIONS **************************/\n\n\t/**\n\t * [ERC1400Partition INTERFACE (1/10)]\n\t * @dev Get balance of a tokenholder for a specific partition.\n\t * @param partition Name of the partition.\n\t * @param tokenHolder Address for which the balance is returned.\n\t * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\n\t */\n\tfunction balanceOfByPartition(bytes32 partition, address tokenHolder)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\t/**\n\t * [ERC1400Partition INTERFACE (2/10)]\n\t * @dev Get partitions index of a tokenholder.\n\t * @param tokenHolder Address for which the partitions index are returned.\n\t * @return Array of partitions index of 'tokenHolder'.\n\t */\n\tfunction partitionsOf(address tokenHolder)\n\t\texternal\n\t\tview\n\t\treturns (bytes32[] memory);\n\n\t/**\n\t * [ERC1400Partition INTERFACE (3/10)]\n\t * @dev Transfer tokens from a specific partition.\n\t * @param partition Name of the partition.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, by the token holder.\n\t * @return Destination partition.\n\t */\n\tfunction transferByPartition(\n\t\tbytes32 partition,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external returns (bytes32);\n\n\t/**\n\t * [ERC1400Partition INTERFACE (4/10)]\n\t * @dev Transfer tokens from a specific partition through an operator.\n\t * @param partition Name of the partition.\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer.\n\t * @param operatorData Information attached to the transfer, by the operator.\n\t * @return Destination partition.\n\t */\n\tfunction operatorTransferByPartition(\n\t\tbytes32 partition,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external returns (bytes32);\n\n\t/**\n\t * [ERC1400Partition INTERFACE (5/10)]\n\t * function getDefaultPartitions\n\t * default partition is always equal to _totalPartitions\n\t */\n\n\t/**\n\t * [ERC1400Partition INTERFACE (6/10)]\n\t * function setDefaultPartitions\n\t * default partition is always equal to _totalPartitions\n\t */\n\n\t/**\n\t * [ERC1400Partition INTERFACE (7/10)]\n\t * @dev Get controllers for a given partition.\n\t * Function used for ERC1400Raw and ERC20 backwards compatibility.\n\t * @param partition Name of the partition.\n\t * @return Array of controllers for partition.\n\t */\n\tfunction controllersByPartition(bytes32 partition)\n\t\texternal\n\t\tview\n\t\treturns (address[] memory);\n\n\t/**\n\t * [ERC1400Partition INTERFACE (8/10)]\n\t * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\n\t * @param partition Name of the partition.\n\t * @param operator Address to set as an operator for 'msg.sender'.\n\t */\n\tfunction authorizeOperatorByPartition(bytes32 partition, address operator)\n\t\texternal;\n\n\t/**\n\t * [ERC1400Partition INTERFACE (9/10)]\n\t * @dev Remove the right of the operator address to be an operator on a given\n\t * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\n\t * @param partition Name of the partition.\n\t * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\n\t */\n\tfunction revokeOperatorByPartition(bytes32 partition, address operator)\n\t\texternal;\n\n\t/**\n\t * [ERC1400Partition INTERFACE (10/10)]\n\t * @dev Indicate whether the operator address is an operator of the tokenHolder\n\t * address for the given partition.\n\t * @param partition Name of the partition.\n\t * @param operator Address which may be an operator of tokenHolder for the given partition.\n\t * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n\t * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n\t */\n\tfunction isOperatorForPartition(\n\t\tbytes32 partition,\n\t\taddress operator,\n\t\taddress tokenHolder\n\t) external view returns (bool); // 10/10\n\n\t/********************* ERC1400Partition OPTIONAL FUNCTIONS ***************************/\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400Partition STANDARD]\n\t * @dev Get list of existing partitions.\n\t * @return Array of all exisiting partitions.\n\t */\n\tfunction totalPartitions() external view returns (bytes32[] memory);\n\n\t/************** ERC1400Raw BACKWARDS RETROCOMPATIBILITY *************************/\n\n\t/**\n\t * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, by the token holder.\n\t */\n\tfunction transferWithData(\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external;\n\n\t/**\n\t * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\n\t * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, and intended for the token holder ('from').\n\t */\n\tfunction transferFromWithData(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external;\n\n\t/**\n\t * @dev Event emitted when tokens are transferred from a partition\n\t */\n\tevent TransferByPartition(\n\t\tbytes32 indexed fromPartition,\n\t\taddress operator,\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes operatorData\n\t);\n\n\t/**\n\t * @dev Event emitted when tokens are transferred between partitions\n\t */\n\tevent ChangedPartition(\n\t\tbytes32 indexed fromPartition,\n\t\tbytes32 indexed toPartition,\n\t\tuint256 value\n\t);\n\n\t/**\n\t * @dev Event emitted when an operator is authorized for a partition\n\t */\n\tevent AuthorizedOperatorByPartition(\n\t\tbytes32 indexed partition,\n\t\taddress indexed operator,\n\t\taddress indexed tokenHolder\n\t);\n\n\t/**\n\t * @dev Event emitted when an operator authorization is revoked for a partition\n\t */\n\tevent RevokedOperatorByPartition(\n\t\tbytes32 indexed partition,\n\t\taddress indexed operator,\n\t\taddress indexed tokenHolder\n\t);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IERC1400Raw.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @title IERC1400Raw token standard\n * @dev ERC1400Raw interface\n */\ninterface IERC1400Raw {\n\t/**\n\t * [ERC1400Raw INTERFACE (1/13)]\n\t * @dev Get the name of the token, e.g., \"MyToken\".\n\t * @return Name of the token.\n\t */\n\tfunction name() external view returns (string memory); // 1/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (2/13)]\n\t * @dev Get the symbol of the token, e.g., \"MYT\".\n\t * @return Symbol of the token.\n\t */\n\tfunction symbol() external view returns (string memory); // 2/13\n\n\t// implemented in ERC20\n\t// function totalSupply() external view returns (uint256); // 3/13\n\t// function balanceOf(address owner) external view returns (uint256); // 4/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (5/13)]\n\t * @dev Get the smallest part of the token thatâ€™s not divisible.\n\t * @return The smallest non-divisible part of the token.\n\t */\n\tfunction granularity() external view returns (uint256); // 5/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (6/13)]\n\t * @dev Get the list of controllers\n\t * @return List of addresses of all the controllers.\n\t */\n\t// function controllers() external view returns (address[] memory); // 6/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (7/13)]\n\t * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\n\t * and redeem tokens on its behalf.\n\t * @param operator Address to set as an operator for 'msg.sender'.\n\t */\n\tfunction authorizeOperator(address operator) external; // 7/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (8/13)]\n\t * @dev Remove the right of the operator address to be an operator for 'msg.sender'\n\t * and to transfer and redeem tokens on its behalf.\n\t * @param operator Address to rescind as an operator for 'msg.sender'.\n\t */\n\tfunction revokeOperator(address operator) external; // 8/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (9/13)]\n\t * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n\t * @param operator Address which may be an operator of tokenHolder.\n\t * @param tokenHolder Address of a token holder which may have the operator address as an operator.\n\t * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\n\t */\n\tfunction isOperator(address operator, address tokenHolder)\n\t\texternal\n\t\tview\n\t\treturns (bool); // 9/13\n\n\t/**\n\t * [ERC1400Raw INTERFACE (10/13)]\n\t * function transferWithData\n\t * is overridden in ERC1400Partition\n\t */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (11/13)]\n\t * function transferFromWithData\n\t * is overridden in ERC1400Partition\n\t */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (12/13)]\n\t * function redeem\n\t * is not needed when using ERC1400Partition\n\t */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (13/13)]\n\t * function redeemFrom\n\t * is not needed when using ERC1400Partition\n\t */\n\n\t/**\n\t * @dev Event emitted when tokens are transferred with data\n\t */\n\tevent TransferWithData(\n\t\taddress indexed operator,\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes operatorData\n\t);\n\n\t/**\n\t * @dev Event emitted when tokens are issued\n\t */\n\tevent Issued(\n\t\taddress indexed operator,\n\t\taddress indexed to,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes operatorData\n\t);\n\n\t/**\n\t * @dev Event emitted when tokens are redeemed\n\t */\n\tevent Redeemed(\n\t\taddress indexed operator,\n\t\taddress indexed from,\n\t\tuint256 value,\n\t\tbytes data,\n\t\tbytes operatorData\n\t);\n\n\t/**\n\t * @dev Event emitted when an operator is authorized\n\t */\n\tevent AuthorizedOperator(\n\t\taddress indexed operator,\n\t\taddress indexed tokenHolder\n\t);\n\n\t/**\n\t * @dev Event emitted when an operator authorization is revoked\n\t */\n\tevent RevokedOperator(\n\t\taddress indexed operator,\n\t\taddress indexed tokenHolder\n\t);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IOwnable.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @author Simon Dosch\n * @title IOwnable\n * @dev IOwnable interface\n */\ninterface IOwnable {\n\t/**\n\t * @dev Emitted when owership of the security token is transferred.\n\t */\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/interfaces/IPausable.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @author Simon Dosch\n * @title IPausable\n * @dev IPausable interface\n */\ninterface IPausable {\n\t/**\n\t * @dev Emitted when the pause is triggered by a pauser (`account`).\n\t */\n\tevent Paused(address account);\n\n\t/**\n\t * @dev Emitted when the pause is lifted by a pauser (`account`).\n\t */\n\tevent Unpaused(address account);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/storage/SecurityTokenStorage.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../interfaces/IConstraintModule.sol\";\n\n\ncontract SecurityTokenStorage {\n\t// Administrable\n\t/**\n\t * @dev Contains all the roles mapped to wether an account holds it or not\n\t */\n\tmapping(bytes32 => mapping(address => bool)) internal _roles;\n\n\t// Constrainable\n\t/**\n\t * @dev Contains active constraint modules for a given partition\n\t */\n\tmapping(bytes32 => IConstraintModule[]) internal _modulesByPartition;\n\n\t// ERC1400Raw\n\tstring internal _name;\n\tstring internal _symbol;\n\tuint256 internal _granularity;\n\tuint256 internal _totalSupply;\n\n\t/**\n\t * @dev Indicate whether the token can still be controlled by operators or not anymore.\n\t */\n\tbool internal _isControllable;\n\n\t/**\n\t * @dev Indicates the paused state\n\t */\n\tbool internal _paused;\n\n\t/**\n\t * @dev Mapping from tokenHolder to balance.\n\t */\n\tmapping(address => uint256) internal _balances;\n\n\t/**\n\t * @dev Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\n\t */\n\tmapping(address => mapping(address => bool)) internal _authorizedOperator;\n\n\t// ERC1400Partition\n\t/**\n\t * @dev Contains complete list of partitions that hold tokens.\n\t * Is used for ERC20 transfer\n\t */\n\tbytes32[] internal _totalPartitions;\n\n\t/**\n\t * @dev Mapping from partition to their index.\n\t */\n\tmapping(bytes32 => uint256) internal _indexOfTotalPartitions;\n\n\t/**\n\t * @dev Mapping from partition to global balance of corresponding partition.\n\t */\n\tmapping(bytes32 => uint256) internal _totalSupplyByPartition;\n\n\t/**\n\t * @dev Mapping from tokenHolder to their partitions.\n\t */\n\tmapping(address => bytes32[]) internal _partitionsOf;\n\n\t/**\n\t * @dev Mapping from (tokenHolder, partition) to their index.\n\t */\n\tmapping(address => mapping(bytes32 => uint256)) internal _indexOfPartitionsOf;\n\n\t/**\n\t * @dev Mapping from (tokenHolder, partition) to balance of corresponding partition.\n\t */\n\tmapping(address => mapping(bytes32 => uint256)) internal _balanceOfByPartition;\n\n\t/**************** Mappings to find partition operators ************************/\n\t/**\n\t * @dev Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\n\t */\n\tmapping(address => mapping(bytes32 => mapping(address => bool))) internal _authorizedOperatorByPartition;\n\n\t/**\n\t * @dev Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\n\t */\n\tmapping(bytes32 => address[]) internal _controllersByPartition;\n\n\t// INFO partition controllers can be set by the admin just like other roles\n\t// Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\n\t// mapping(bytes32 => mapping(address => bool)) internal _isControllerByPartition;\n\t/****************************************************************************/\n\n\t// ERC1400ERC20\n\t/**\n\t * @dev Mapping from (tokenHolder, spender) to allowed value.\n\t */\n\tmapping(address => mapping(address => uint256)) internal _allowances;\n\n\t// ERC1400\n\tstruct Doc {\n\t\tstring docURI;\n\t\tbytes32 docHash;\n\t}\n\n\t/**\n\t * @dev Mapping for token URIs.\n\t */\n\tmapping(bytes32 => Doc) internal _documents;\n\n\t/**\n\t * @dev Indicate whether the token can still be issued by the issuer or not anymore.\n\t */\n\tbool internal _isIssuable;\n\n\t// Capped\n\t/**\n\t * @dev Overall cap of the security token\n\t */\n\tuint256 internal _cap;\n\n\t// Ownable\n\t/**\n\t * @dev Owner of the security token\n\t */\n\taddress internal _owner;\n\n\t// GSN\n\t/**\n\t * @dev Enum describing the possible GSN modes\n\t */\n\tenum gsnMode { ALL, MODULE, NONE }\n\n\t/**\n\t * @dev Can be set to accept ALL, NONE or MODULE mode\n\t * Initialized with ALL\n\t */\n\tgsnMode internal _gsnMode;\n\n\t/**\n\t * @dev Default RelayHub address, deployed on mainnet and all testnets at the same address\n\t */\n\taddress internal _relayHub;\n\n\tuint256 internal _RELAYED_CALL_ACCEPTED;\n\tuint256 internal _RELAYED_CALL_REJECTED;\n\n\t/**\n\t * @dev How much gas is forwarded to postRelayedCall\n\t */\n\tuint256 internal _POST_RELAYED_CALL_MAX_GAS;\n\n\t// ReentrancyGuard\n\tbool internal _notEntered;\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/Administrable.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../interfaces/IAdmin.sol\";\nimport \"../gsn/GSNable.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title Administrable\n * @dev Manages roles for all inheriting contracts\n */\ncontract Administrable is IAdmin, GSNable {\n\t/**\n     * @dev list of standard roles\n     * roles can be added (i.e. for constraint modules)\n     *\n     * --main roles--\n     * ADMIN   (can add and remove roles)\n     * CONTROLLER (ERC1400, can force-transfer tokens if contract _isControllable)\n     * ISSUER (ISSUER)\n     * REDEEMER (BURNER, can redeem tokens, their own OR others IF _isOperatorForPartition())\n     * MODULE_EDITOR (can edit constraint modules),\n     *\n     * --additional roles--\n     * DOCUMENT_EDITOR\n     * CAP_EDITOR\n\n     * --constraint module roles--\n     * PAUSER\n     * WHITELIST_EDITOR\n     * TIME_LOCK_EDITOR\n     * SPENDING_LIMITS_EDITOR\n     * VESTING_PERIOD_EDITOR\n     * GSN_CONTROLLER\n     * DEFAULT_PARTITIONS_EDITOR\n\t *\n\t * ...\n     */\n\n\t// EVENTS in IAdmin.sol\n\n\t/**\n\t * @dev Modifier to make a function callable only when the caller is a specific role.\n\t */\n\tmodifier onlyRole(bytes32 role) {\n\t\trequire(hasRole(role, _msgSender()), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @param role Role that is being assigned\n\t * @param account The address that is being assigned a role\n\t * @dev Assigns a role to an account\n\t * only ADMIN\n\t */\n\tfunction addRole(bytes32 role, address account)\n\t\tpublic\n\t\toverride\n\t\tonlyRole(bytes32(\"ADMIN\"))\n\t{\n\t\t_add(role, account);\n\t}\n\n\t/**\n\t * @param roles Roles that are being assigned\n\t * @param accounts The addresses that are being assigned a role\n\t * @dev Assigns a bulk of roles to accounts\n\t * only ADMIN\n\t */\n\tfunction bulkAddRole(bytes32[] memory roles, address[] memory accounts)\n\t\tpublic\n\t\toverride\n\t\tonlyRole(bytes32(\"ADMIN\"))\n\t{\n\t\trequire(roles.length <= 100, \"too many roles\");\n\t\trequire(roles.length == accounts.length, \"length\");\n\t\tfor (uint256 i = 0; i < roles.length; i++) {\n\t\t\t_add(roles[i], accounts[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @param role Role that is being removed\n\t * @param account The address that a role is removed from\n\t * @dev Removes a role from an account\n\t * only ADMIN\n\t */\n\tfunction removeRole(bytes32 role, address account)\n\t\tpublic\n\t\toverride\n\t\tonlyRole(bytes32(\"ADMIN\"))\n\t{\n\t\t_remove(role, account);\n\t}\n\n\t/**\n\t * @param role Role that is being renounced by the _msgSender()\n\t * @dev Removes a role from the sender's address\n\t * ATTENTION: it is possible to remove the last ADMINN role by renouncing it!\n\t */\n\tfunction renounceRole(bytes32 role) public override {\n\t\t_remove(role, _msgSender());\n\n\t\temit RoleRenounced(role, _msgSender());\n\t}\n\n\t/**\n\t * @dev check if an account has a role\n\t * @return bool True if account has role\n\t */\n\tfunction hasRole(bytes32 role, address account)\n\t\tpublic\n\t\toverride\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn _roles[role][account];\n\t}\n\n\t/******* INTERNAL FUNCTIONS *******/\n\n\t/**\n\t * @dev give an account access to a role\n\t */\n\tfunction _add(bytes32 role, address account) internal {\n\t\trequire(!hasRole(role, account), \"already has role\");\n\n\t\t_roles[role][account] = true;\n\n\t\temit RoleGranted(role, account, _msgSender());\n\t}\n\n\t/**\n\t * @dev remove an account's access to a role\n\t * cannot remove own ADMIN role\n\t * address must have role\n\t */\n\tfunction _remove(bytes32 role, address account) internal {\n\t\trequire(hasRole(role, account), \"does not have role\");\n\n\t\t_roles[role][account] = false;\n\n\t\temit RoleRevoked(role, account, _msgSender());\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/Constrainable.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./Administrable.sol\";\nimport \"../interfaces/IConstraintModule.sol\";\nimport \"../interfaces/IConstrainable.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title Constrainable\n * @dev Adds transfer constraints in the form of updatable constraint modules\n */\ncontract Constrainable is IConstrainable, Administrable {\n\t/**\n\t * @dev Validates live transfer. Can modify state\n\t * @param msg_sender Sender of this function call\n\t * @param partition Partition the tokens are being transferred from\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer.\n\t * @param operatorData Information attached to the transfer, by the operator\n\t */\n\tfunction _executeTransfer(\n\t\taddress msg_sender,\n\t\tbytes32 partition,\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal {\n\t\tfor (uint256 i = 0; i < _modulesByPartition[partition].length; i++) {\n\t\t\t(\n\t\t\t\tbool valid,\n\t\t\t\tstring memory reason\n\t\t\t) = _modulesByPartition[partition][i].executeTransfer(\n\t\t\t\tmsg_sender,\n\t\t\t\tpartition,\n\t\t\t\toperator,\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tvalue,\n\t\t\t\tdata,\n\t\t\t\toperatorData\n\t\t\t);\n\n\t\t\trequire(valid, reason);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns all modules for requested partition\n\t * @param partition Partition to get modules for\n\t * @return IConstraintModule[]\n\t */\n\tfunction getModulesByPartition(bytes32 partition)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (IConstraintModule[] memory)\n\t{\n\t\treturn _modulesByPartition[partition];\n\t}\n\n\t/**\n\t * @dev Sets all modules for partition\n\t * @param partition Partition to set modules for\n\t * @param newModules IConstraintModule[] array of new modules for this partition\n\t */\n\tfunction setModulesByPartition(\n\t\tbytes32 partition,\n\t\tIConstraintModule[] calldata newModules\n\t) external override {\n\t\trequire(\n\t\t\thasRole(bytes32(\"MODULE_EDITOR\"), _msgSender()),\n\t\t\t\"!MODULE_EDITOR\"\n\t\t);\n\t\t_modulesByPartition[partition] = newModules;\n\t\temit ModulesByPartitionSet(_msgSender(), partition, newModules);\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400Capped.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./Ownable.sol\";\nimport \"../interfaces/IERC1400Capped.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title ERC1400Capped\n * @dev Regulating the cap of the security token\n */\ncontract ERC1400Capped is IERC1400Capped, Ownable {\n\t/**\n\t * @dev Returns the cap on the token's total supply.\n\t */\n\tfunction cap() public override view returns (uint256) {\n\t\treturn _cap;\n\t}\n\n\t/**\n\t * @dev Sets cap to a new value\n\t * New value need to be higher than old one\n\t * Is only callable by CAP?_EDITOR\n\t * @param newCap value of new cap\n\t */\n\tfunction setCap(uint256 newCap) public override {\n\t\trequire(hasRole(bytes32(\"CAP_EDITOR\"), _msgSender()), \"!CAP_EDITOR\");\n\t\trequire((newCap > _cap), \"new cap needs to be higher\");\n\n\t\t// set new cap\n\t\t_cap = newCap;\n\t\temit CapSet(newCap);\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400ERC20.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ERC1400Partition.sol\";\nimport \"../interfaces/IERC1400Raw.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title ERC1400ERC20\n * @dev Expands ERC1400s function by those of the ERC20 standard\n */\ncontract ERC1400ERC20 is ERC1400Partition, IERC20 {\n\t/**\n\t * @dev Returns the ERC20 decimal property as 0\n\t * @return uint8 Always returns decimals as 0\n\t */\n\tfunction decimals() external pure returns (uint8) {\n\t\treturn uint8(0);\n\t}\n\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() public override view returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address who) public override view returns (uint256) {\n\t\treturn _balances[who];\n\t}\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address to, uint256 value)\n\t\texternal\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_transferFromTotalPartitions(\n\t\t\t_msgSender(),\n\t\t\t_msgSender(),\n\t\t\tto,\n\t\t\tvalue,\n\t\t\t\"\",\n\t\t\t\"\"\n\t\t);\n\t\t// emitted in _transferByPartition\n\t\t// emit Transfer(_msgSender(), to, value);\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 value)\n\t\texternal\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t// Transfer Blocked - Sender not eligible\n\t\trequire(spender != address(0), \"zero address\");\n\n\t\t// mitigate https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t\t_allowances[_msgSender()][spender] = 0;\n\n\t\t_allowances[_msgSender()][spender] = value;\n\n\t\temit Approval(_msgSender(), spender, value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external override returns (bool) {\n\t\t// check if is operator by partition or has enough allowance here\n\t\trequire(value <= _allowances[from][_msgSender()], \"allowance too low\");\n\t\t// Transfer Blocked - Identity restriction\n\n\t\t_allowances[from][_msgSender()] = _allowances[from][_msgSender()].sub(\n\t\t\tvalue\n\t\t);\n\n\t\t// transfer by partition\n\t\t_transferFromTotalPartitions(from, from, to, value, \"\", \"\");\n\n\t\t// emitted in _transferByPartition\n\t\t// emit Transfer(_msgSender(), to, value);\n\t\treturn true;\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400Partition.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./ERC1400Raw.sol\";\nimport \"../interfaces/IERC1400Partition.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title ERC1400Partition\n * @dev ERC1400Partition logic\n * inspired by and modeled after https://github.com/ConsenSys/UniversalToken\n */\ncontract ERC1400Partition is IERC1400Partition, ERC1400Raw {\n\t/**\n\t * @dev Returns the total supply of a given partition\n\t * For ERC20 compatibility via proxy\n\t * @param partition Requested partition\n\t * @return uint256 _totalSupplyByPartition\n\t */\n\tfunction totalSupplyByPartition(bytes32 partition)\n\t\tpublic\n\t\toverride\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn _totalSupplyByPartition[partition];\n\t}\n\n\t/********************** ERC1400Partition EXTERNAL FUNCTIONS **************************/\n\n\t/**\n\t * [ERC1400Partition INTERFACE (1/10)]\n\t * @dev Get balance of a tokenholder for a specific partition.\n\t * @param partition Name of the partition.\n\t * @param tokenHolder Address for which the balance is returned.\n\t * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\n\t */\n\tfunction balanceOfByPartition(bytes32 partition, address tokenHolder)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn _balanceOfByPartition[tokenHolder][partition];\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (2/10)]\n\t * @dev Get partitions index of a tokenholder.\n\t * @param tokenHolder Address for which the partitions index are returned.\n\t * @return Array of partitions index of 'tokenHolder'.\n\t */\n\tfunction partitionsOf(address tokenHolder)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (bytes32[] memory)\n\t{\n\t\treturn _partitionsOf[tokenHolder];\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (3/10)]\n\t * @dev Transfer tokens from a specific partition.\n\t * @param partition Name of the partition.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, by the token holder.\n\t * @return Destination partition.\n\t */\n\tfunction transferByPartition(\n\t\tbytes32 partition,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external override returns (bytes32) {\n\t\treturn\n\t\t\t_transferByPartition(\n\t\t\t\tpartition,\n\t\t\t\t_msgSender(),\n\t\t\t\t_msgSender(),\n\t\t\t\tto,\n\t\t\t\tvalue,\n\t\t\t\tdata,\n\t\t\t\t\"\"\n\t\t\t);\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (4/10)]\n\t * @dev Transfer tokens from a specific partition through an operator.\n\t * @param partition Name of the partition.\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer.\n\t * @param operatorData Information attached to the transfer, by the operator.\n\t * @return Destination partition.\n\t */\n\tfunction operatorTransferByPartition(\n\t\tbytes32 partition,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external override returns (bytes32) {\n\t\trequire(\n\t\t\t_isOperatorForPartition(partition, _msgSender(), from),\n\t\t\t\"!CONTROLLER or !operator\"\n\t\t);\n\t\t// Transfer Blocked - Identity restriction\n\n\t\treturn\n\t\t\t_transferByPartition(\n\t\t\t\tpartition,\n\t\t\t\t_msgSender(),\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tvalue,\n\t\t\t\tdata,\n\t\t\t\toperatorData\n\t\t\t);\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (5/10)]\n\t * function getDefaultPartitions\n\t * default partition is always equal to _totalPartitions\n\t */\n\n\t/**\n\t * [ERC1400Partition INTERFACE (6/10)]\n\t * function setDefaultPartitions\n\t * default partition is always equal to _totalPartitions\n\t */\n\n\t/**\n\t * [ERC1400Partition INTERFACE (7/10)]\n\t * @dev Get controllers for a given partition.\n\t * Function used for ERC1400Raw and ERC20 backwards compatibility.\n\t * @param partition Name of the partition.\n\t * @return Array of controllers for partition.\n\t */\n\tfunction controllersByPartition(bytes32 partition)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (address[] memory)\n\t{\n\t\treturn _controllersByPartition[partition];\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (8/10)]\n\t * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\n\t * @param partition Name of the partition.\n\t * @param operator Address to set as an operator for 'msg.sender'.\n\t */\n\tfunction authorizeOperatorByPartition(bytes32 partition, address operator)\n\t\texternal\n\t\toverride\n\t{\n\t\t_authorizedOperatorByPartition[_msgSender()][partition][operator] = true;\n\t\temit AuthorizedOperatorByPartition(partition, operator, _msgSender());\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (9/10)]\n\t * @dev Remove the right of the operator address to be an operator on a given\n\t * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\n\t * @param partition Name of the partition.\n\t * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\n\t */\n\tfunction revokeOperatorByPartition(bytes32 partition, address operator)\n\t\texternal\n\t\toverride\n\t{\n\t\t_authorizedOperatorByPartition[_msgSender()][partition][operator] = false;\n\t\temit RevokedOperatorByPartition(partition, operator, _msgSender());\n\t}\n\n\t/**\n\t * [ERC1400Partition INTERFACE (10/10)]\n\t * @dev Indicate whether the operator address is an operator of the tokenHolder\n\t * address for the given partition.\n\t * @param partition Name of the partition.\n\t * @param operator Address which may be an operator of tokenHolder for the given partition.\n\t * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n\t * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n\t */\n\tfunction isOperatorForPartition(\n\t\tbytes32 partition,\n\t\taddress operator,\n\t\taddress tokenHolder\n\t) external override view returns (bool) {\n\t\treturn _isOperatorForPartition(partition, operator, tokenHolder);\n\t}\n\n\t/********************** ERC1400Partition INTERNAL FUNCTIONS **************************/\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Indicate whether the operator address is an operator of the tokenHolder\n\t * address for the given partition.\n\t * @param partition Name of the partition.\n\t * @param operator Address which may be an operator of tokenHolder for the given partition.\n\t * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\n\t * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\n\t */\n\tfunction _isOperatorForPartition(\n\t\tbytes32 partition,\n\t\taddress operator,\n\t\taddress tokenHolder\n\t) internal view returns (bool) {\n\t\treturn (_authorizedOperatorByPartition[tokenHolder][partition][operator] ||\n\t\t\t(_isControllable && hasRole(bytes32(\"CONTROLLER\"), operator)));\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Transfer tokens from a specific partition.\n\t * @param fromPartition Partition of the tokens to transfer.\n\t * @param operator The address performing the transfer.\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n\t * @param operatorData Information attached to the transfer, by the operator (if any).\n\t * @return Destination partition.\n\t */\n\tfunction _transferByPartition(\n\t\tbytes32 fromPartition,\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal returns (bytes32) {\n\t\trequire(\n\t\t\t_balanceOfByPartition[from][fromPartition] >= value,\n\t\t\t\"insufficient funds\"\n\t\t);\n\t\t// Transfer Blocked - Sender balance insufficient\n\n\t\t// The RIVER Principle\n\t\t// all transaction go to base partition by default\n\t\t// so over time, tokens converge towards the base!\n\t\tbytes32 toPartition = bytes32(0);\n\n\t\tif (operatorData.length != 0 && data.length >= 64) {\n\t\t\ttoPartition = _getDestinationPartition(fromPartition, data);\n\t\t}\n\n\t\t_removeTokenFromPartition(from, fromPartition, value);\n\t\t_transferWithData(\n\t\t\tfromPartition,\n\t\t\toperator,\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\toperatorData\n\t\t);\n\t\t_addTokenToPartition(to, toPartition, value);\n\n\t\temit TransferByPartition(\n\t\t\tfromPartition,\n\t\t\toperator,\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\toperatorData\n\t\t);\n\n\t\t// purely for better visibility on etherscan\n\t\temit Transfer(from, to, value);\n\n\t\tif (toPartition != fromPartition) {\n\t\t\temit ChangedPartition(fromPartition, toPartition, value);\n\t\t}\n\n\t\treturn toPartition;\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Remove a token from a specific partition.\n\t * @param from Token holder.\n\t * @param partition Name of the partition.\n\t * @param value Number of tokens to transfer.\n\t */\n\tfunction _removeTokenFromPartition(\n\t\taddress from,\n\t\tbytes32 partition,\n\t\tuint256 value\n\t) internal {\n\t\t_balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition]\n\t\t\t.sub(value);\n\t\t_totalSupplyByPartition[partition] = _totalSupplyByPartition[partition]\n\t\t\t.sub(value);\n\n\t\t// If the total supply is zero, finds and deletes the partition.\n\t\tif (_totalSupplyByPartition[partition] == 0) {\n\t\t\tuint256 index1 = _indexOfTotalPartitions[partition];\n\t\t\trequire(index1 > 0, \"last partition\");\n\t\t\t// Transfer Blocked - Token restriction\n\n\t\t\t// move the last item into the index being vacated\n\t\t\tbytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\n\t\t\t_totalPartitions[index1 - 1] = lastValue;\n\t\t\t// adjust for 1-based indexing\n\t\t\t_indexOfTotalPartitions[lastValue] = index1;\n\n\t\t\t_totalPartitions.pop();\n\t\t\t_indexOfTotalPartitions[partition] = 0;\n\t\t}\n\n\t\t// If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\n\t\tif (_balanceOfByPartition[from][partition] == 0) {\n\t\t\tuint256 index2 = _indexOfPartitionsOf[from][partition];\n\t\t\trequire(index2 > 0, \"last partition\");\n\t\t\t// Transfer Blocked - Token restriction\n\n\t\t\t// move the last item into the index being vacated\n\t\t\tbytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length -\n\t\t\t\t1];\n\t\t\t_partitionsOf[from][index2 - 1] = lastValue;\n\t\t\t// adjust for 1-based indexing\n\t\t\t_indexOfPartitionsOf[from][lastValue] = index2;\n\n\t\t\t_partitionsOf[from].pop();\n\t\t\t_indexOfPartitionsOf[from][partition] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Add a token to a specific partition.\n\t * @param to Token recipient.\n\t * @param partition Name of the partition.\n\t * @param value Number of tokens to transfer.\n\t */\n\tfunction _addTokenToPartition(\n\t\taddress to,\n\t\tbytes32 partition,\n\t\tuint256 value\n\t) internal {\n\t\tif (value != 0) {\n\t\t\tif (_indexOfPartitionsOf[to][partition] == 0) {\n\t\t\t\t_partitionsOf[to].push(partition);\n\t\t\t\t_indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\n\t\t\t}\n\t\t\t_balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition]\n\t\t\t\t.add(value);\n\n\t\t\tif (_indexOfTotalPartitions[partition] == 0) {\n\t\t\t\t_totalPartitions.push(partition);\n\t\t\t\t_indexOfTotalPartitions[partition] = _totalPartitions.length;\n\t\t\t}\n\t\t\t_totalSupplyByPartition[partition] = _totalSupplyByPartition[partition]\n\t\t\t\t.add(value);\n\t\t}\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Retrieve the destination partition from the 'data' field.\n\t * By convention, a partition change is requested ONLY when 'data' starts\n\t * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\t * When the flag is detected, the destination tranche is extracted from the\n\t * 32 bytes following the flag.\n\t * @param fromPartition Partition of the tokens to transfer.\n\t * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\n\t * @return toPartition Destination partition.\n\t */\n\tfunction _getDestinationPartition(bytes32 fromPartition, bytes memory data)\n\t\tinternal\n\t\tpure\n\t\treturns (bytes32 toPartition)\n\t{\n\t\t/* prettier-ignore */\n\t\tbytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n\t\tbytes32 flag;\n\t\tassembly {\n\t\t\tflag := mload(add(data, 32))\n\t\t}\n\t\tif (flag == changePartitionFlag) {\n\t\t\tassembly {\n\t\t\t\ttoPartition := mload(add(data, 64))\n\t\t\t}\n\t\t} else {\n\t\t\ttoPartition = fromPartition;\n\t\t}\n\t}\n\n\t/********************* ERC1400Partition OPTIONAL FUNCTIONS ***************************/\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400Partition STANDARD]\n\t * @dev Get list of existing partitions.\n\t * @return Array of all exisiting partitions.\n\t */\n\tfunction totalPartitions()\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (bytes32[] memory)\n\t{\n\t\treturn _totalPartitions;\n\t}\n\n\t/************** ERC1400Raw BACKWARDS RETROCOMPATIBILITY *************************/\n\n\t/**\n\t * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, by the token holder.\n\t */\n\tfunction transferWithData(\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external override {\n\t\t_transferFromTotalPartitions(\n\t\t\t_msgSender(),\n\t\t\t_msgSender(),\n\t\t\tto,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\t\"\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\n\t * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, and intended for the token holder ('from').\n\t */\n\tfunction transferFromWithData(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external override {\n\t\trequire(_isOperator(_msgSender(), from), \"!operator\");\n\n\t\t_transferFromTotalPartitions(\n\t\t\t_msgSender(),\n\t\t\tfrom,\n\t\t\tto,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\toperatorData\n\t\t);\n\t}\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400Partition STANDARD]\n\t * @dev Transfer tokens from all partitions.\n\t * @param operator The address performing the transfer.\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\n\t * @param operatorData Information attached to the transfer by the operator (if any).\n\t */\n\tfunction _transferFromTotalPartitions(\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal {\n\t\trequire(_totalPartitions.length != 0, \"no partitions\"); // Transfer Blocked - Token restriction\n\t\trequire(_totalPartitions.length <= 100, \"too many partitions\");\n\n\t\tuint256 _remainingValue = value;\n\t\tuint256 _localBalance;\n\n\t\tfor (uint256 i = 0; i < _totalPartitions.length; i++) {\n\t\t\t_localBalance = _balanceOfByPartition[from][_totalPartitions[i]];\n\t\t\tif (_remainingValue <= _localBalance) {\n\t\t\t\t_transferByPartition(\n\t\t\t\t\t_totalPartitions[i],\n\t\t\t\t\toperator,\n\t\t\t\t\tfrom,\n\t\t\t\t\tto,\n\t\t\t\t\t_remainingValue,\n\t\t\t\t\tdata,\n\t\t\t\t\toperatorData\n\t\t\t\t);\n\t\t\t\t_remainingValue = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (_localBalance != 0) {\n\t\t\t\t_transferByPartition(\n\t\t\t\t\t_totalPartitions[i],\n\t\t\t\t\toperator,\n\t\t\t\t\tfrom,\n\t\t\t\t\tto,\n\t\t\t\t\t_localBalance,\n\t\t\t\t\tdata,\n\t\t\t\t\toperatorData\n\t\t\t\t);\n\t\t\t\t_remainingValue = _remainingValue - _localBalance;\n\t\t\t}\n\t\t}\n\n\t\trequire(_remainingValue == 0, \"insufficient balance\"); // Transfer Blocked - Token restriction\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/ERC1400Raw.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../../node_modules/@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../erc1820/ERC1820Client.sol\";\nimport \"../utils/ReentrancyGuard.sol\";\nimport \"../interfaces/IERC1400Raw.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title ERC1400Raw\n * @dev ERC1400Raw logic\n * inspired by and modeled after https://github.com/ConsenSys/UniversalToken\n */\ncontract ERC1400Raw is IERC1400Raw, ERC1820Client, ReentrancyGuard {\n\tusing SafeMath for uint256;\n\n\t// INFO\n\t// moved functionality to admin contract controller role\n\t// Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\n\t// address[] internal _controllers;\n\n\t// Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\n\t// mapping(address => bool) internal _isController;\n\n\t/********************** ERC1400Raw EXTERNAL FUNCTIONS ***************************/\n\n\t/**\n\t * [ERC1400Raw INTERFACE (1/13)]\n\t * @dev Get the name of the token, e.g., \"MyToken\".\n\t * @return Name of the token.\n\t */\n\tfunction name() external override view returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * [ERC1400Raw INTERFACE (2/13)]\n\t * @dev Get the symbol of the token, e.g., \"MYT\".\n\t * @return Symbol of the token.\n\t */\n\tfunction symbol() external override view returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * [ERC1400Raw INTERFACE (3/13)]\n\t * INFO replaced by ERC20\n\t * @dev Get the total number of issued tokens.\n\t * @return Total supply of tokens currently in circulation.\n\t */\n\t/* function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    } */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (4/13)]\n\t * INFO replaced by ERC20\n\t * @dev Get the balance of the account with address 'tokenHolder'.\n\t * @param tokenHolder Address for which the balance is returned.\n\t * @return Amount of token held by 'tokenHolder' in the token contract.\n\t */\n\t/* function balanceOf(address tokenHolder) public override view returns (uint256) {\n        return _balances[tokenHolder];\n    } */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (5/13)]\n\t * @dev Get the smallest part of the token thatâ€™s not divisible.\n\t * @return The smallest non-divisible part of the token.\n\t */\n\tfunction granularity() external override view returns (uint256) {\n\t\treturn _granularity;\n\t}\n\n\t/**\n\t * [ERC1400Raw INTERFACE (6/13)]\n\t * @dev Always returns an empty array, since controllers are only managed in Administrable\n\t * @return c Empty list\n\t */\n\t/* function controllers() external override view returns (address[] memory c) {\n\t\treturn c;\n\t} */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (7/13)]\n\t * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\n\t * and redeem tokens on its behalf.\n\t * @param operator Address to set as an operator for 'msg.sender'.\n\t */\n\tfunction authorizeOperator(address operator) external override {\n\t\trequire(operator != _msgSender(), \"cannot authorize yourself\");\n\t\t_authorizedOperator[operator][_msgSender()] = true;\n\t\temit AuthorizedOperator(operator, _msgSender());\n\t}\n\n\t/**\n\t * [ERC1400Raw INTERFACE (8/13)]\n\t * @dev Remove the right of the operator address to be an operator for 'msg.sender'\n\t * and to transfer and redeem tokens on its behalf.\n\t * @param operator Address to rescind as an operator for 'msg.sender'.\n\t */\n\tfunction revokeOperator(address operator) external override {\n\t\trequire(operator != _msgSender(), \"cannot revoke yourself\");\n\t\t_authorizedOperator[operator][_msgSender()] = false;\n\t\temit RevokedOperator(operator, _msgSender());\n\t}\n\n\t/**\n\t * [ERC1400Raw INTERFACE (9/13)]\n\t * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n\t * @param operator Address which may be an operator of tokenHolder.\n\t * @param tokenHolder Address of a token holder which may have the operator address as an operator.\n\t * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\n\t */\n\tfunction isOperator(address operator, address tokenHolder)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn _isOperator(operator, tokenHolder);\n\t}\n\n\t/**\n\t * [ERC1400Raw INTERFACE (10/13)]\n\t * function transferWithData\n\t * is overridden in ERC1400Partition\n\t */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (11/13)]\n\t * function transferFromWithData\n\t * is overridden in ERC1400Partition\n\t */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (12/13)]\n\t * function redeem\n\t * is not needed when using ERC1400Partition\n\t */\n\n\t/**\n\t * [ERC1400Raw INTERFACE (13/13)]\n\t * function redeemFrom\n\t * is not needed when using ERC1400Partition\n\t */\n\n\t/********************** ERC1400Raw INTERNAL FUNCTIONS ***************************/\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Check if 'value' is multiple of the granularity.\n\t * @param value The quantity that want's to be checked.\n\t * @return 'true' if 'value' is a multiple of the granularity.\n\t */\n\tfunction _isMultiple(uint256 value) internal view returns (bool) {\n\t\treturn (value.div(_granularity).mul(_granularity) == value);\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Indicate whether the operator address is an operator of the tokenHolder address.\n\t * @param operator Address which may be an operator of 'tokenHolder'.\n\t * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\n\t * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\n\t */\n\tfunction _isOperator(address operator, address tokenHolder)\n\t\tinternal\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn (operator == tokenHolder ||\n\t\t\t_authorizedOperator[operator][tokenHolder] ||\n\t\t\t(_isControllable && hasRole(bytes32(\"CONTROLLER\"), operator)));\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Perform the transfer of tokens.\n\t * @param partition Name of the partition (bytes32 to be left empty for ERC1400Raw transfer).\n\t * @param operator The address performing the transfer.\n\t * @param from Token holder.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to transfer.\n\t * @param data Information attached to the transfer.\n\t * @param operatorData Information attached to the transfer by the operator (if any)..\n\t */\n\n\tfunction _transferWithData(\n\t\tbytes32 partition,\n\t\taddress operator,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal nonReentrant {\n\t\trequire(_isMultiple(value), \"violates granularity\");\n\t\t// Transfer Blocked - Token granularity\n\t\trequire(to != address(0), \"zero address\");\n\t\t// Transfer Blocked - Receiver not eligible\n\t\t// require(_balances[from] >= value, \"insufficient balance\"); // already checked in ERC1400Partition\n\t\t// Transfer Blocked - Sender balance insufficient\n\n\t\trequire(!_paused, \"paused\");\n\n\t\t// CONTROLLER bypasses constraint modules\n\t\tif (\n\t\t\t!(_isControllable && hasRole(bytes32(\"CONTROLLER\"), _msgSender()))\n\t\t) {\n\t\t\t_executeTransfer(\n\t\t\t\t_msgSender(),\n\t\t\t\tpartition,\n\t\t\t\toperator,\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tvalue,\n\t\t\t\tdata,\n\t\t\t\toperatorData\n\t\t\t);\n\t\t}\n\n\t\t// _callSender(partition, operator, from, to, value, data, operatorData);\n\n\t\t_balances[from] = _balances[from].sub(value);\n\t\t_balances[to] = _balances[to].add(value);\n\n\t\t// _callRecipient(partition, operator, from, to, value, data, operatorData, preventLocking);\n\n\t\temit TransferWithData(operator, from, to, value, data, operatorData);\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Perform the token redemption.\n\t * @param operator The address performing the redemption.\n\t * @param from Token holder whose tokens will be redeemed.\n\t * @param value Number of tokens to redeem.\n\t * @param data Information attached to the redemption.\n\t * @param operatorData Information attached to the redemption, by the operator (if any).\n\t */\n\tfunction _redeem(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal nonReentrant {\n\t\trequire(_isMultiple(value), \"violates granularity\");\n\t\t// Transfer Blocked - Token granularity\n\t\trequire(from != address(0), \"zero address\");\n\t\t// Transfer Blocked - Sender not eligible\n\t\t// require(_balances[from] >= value, \"insufficient balance\");\n\t\t// already checked in _redeemByPartition\n\n\t\t// is REDEEMER\n\t\trequire(hasRole(bytes32(\"REDEEMER\"), _msgSender()), \"!REDEEMER\");\n\n\t\t// we don't validate when redeeming\n\n\t\t_balances[from] = _balances[from].sub(value);\n\t\t_totalSupply = _totalSupply.sub(value);\n\n\t\temit Redeemed(operator, from, value, data, operatorData);\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Perform the issuance of tokens.\n\t * @param operator Address which triggered the issuance.\n\t * @param to Token recipient.\n\t * @param value Number of tokens issued.\n\t * @param data Information attached to the issuance, and intended for the recipient (to).\n\t * @param operatorData Information attached to the issuance by the operator (if any).\n\t */\n\tfunction _issue(\n\t\taddress operator,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal nonReentrant {\n\t\trequire(_isMultiple(value), \"violates granularity\");\n\t\t// Transfer Blocked - Token granularity\n\t\trequire(to != address(0), \"zero address\");\n\t\t// Transfer Blocked - Receiver not eligible\n\n\t\trequire(hasRole(bytes32(\"ISSUER\"), _msgSender()), \"!ISSUER\");\n\n\t\t// we don't validate when minting\n\n\t\t_totalSupply = _totalSupply.add(value);\n\t\t_balances[to] = _balances[to].add(value);\n\n\t\t// _callRecipient(partition, operator, address(0), to, value, data, operatorData, true);\n\n\t\temit Issued(operator, to, value, data, operatorData);\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/Ownable.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./Pausable.sol\";\nimport \"../interfaces/IOwnable.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title Ownable\n * @dev modeled after @openzeppelin/contracts/access/Ownable.sol\n */\ncontract Ownable is IOwnable, Pausable {\n\t// EVENTS in IOwnable.sol\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual {\n\t\trequire(hasRole(bytes32(\"ADMIN\"), _msgSender()), \"!ADMIN\");\n\t\trequire(\n\t\t\tnewOwner != address(0),\n\t\t\t\"Ownable: new owner is the zero address\"\n\t\t);\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/Pausable.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"./Constrainable.sol\";\nimport \"../interfaces/IPausable.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title Pausable\n * @dev modeled after @openzeppelin/contracts/utils/Pausable.sol\n */\ncontract Pausable is IPausable, Constrainable {\n\t// EVENTS in IPausable.sol\n\n\t/**\n\t * @dev Returns true if the contract is paused, and false otherwise.\n\t * @return bool True if the contract is paused\n\t */\n\tfunction paused() public view returns (bool) {\n\t\treturn _paused;\n\t}\n\n\t/**\n\t * @dev Called by a pauser to pause, triggers stopped state.\n\t */\n\tfunction pause() public {\n\t\trequire(!_paused, \"paused\");\n\t\trequire(hasRole(bytes32(\"PAUSER\"), _msgSender()), \"!PAUSER\");\n\t\t_paused = true;\n\t\temit Paused(_msgSender());\n\t}\n\n\t/**\n\t * @dev Called by a pauser to unpause, returns to normal state.\n\t */\n\tfunction unpause() public {\n\t\trequire(_paused, \"not paused\");\n\t\trequire(hasRole(bytes32(\"PAUSER\"), _msgSender()), \"!PAUSER\");\n\t\t_paused = false;\n\t\temit Unpaused(_msgSender());\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/token/SecurityToken.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../../node_modules/@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./ERC1400ERC20.sol\";\nimport \"../interfaces/IERC1400.sol\";\n\n\n/**\n * @author Simon Dosch\n * @title SecurityToken\n * @dev Main contract of the micobo Security Token Contract Suite\n * inspired by and modeled after https://github.com/ConsenSys/UniversalToken\n * implements access control for GSN\n * implements new function bulkIssueByPartition\n * implements IERC1400\n * inherits ERC1400ERC20\n */\ncontract SecurityToken is ERC1400ERC20, IERC1400, Initializable {\n\t/**\n\t * @dev Returns the version string of the {SecurityToken} for which this recipient implementation was built.\n\t */\n\tfunction version() public view returns (string memory) {\n\t\tthis;\n\t\treturn \"1.0.0\";\n\t}\n\n\t// INITIALIZATION\n\t/**\n\t * @dev Initialize ERC1400 + register\n\t * the contract implementation in ERC1820Registry.\n\t * @param name Name of the token.\n\t * @param symbol Symbol of the token.\n\t * @param granularity Granularity of the token.\n\t */\n\tfunction initialize(\n\t\tstring calldata name,\n\t\tstring calldata symbol,\n\t\tuint256 granularity,\n\t\tuint256 cap,\n\t\taddress admin,\n\t\taddress controller,\n\t\taddress issuer,\n\t\taddress redeemer,\n\t\taddress module_editor\n\t) external initializer {\n\t\t_add(bytes32(\"ADMIN\"), admin);\n\t\t_add(bytes32(\"CONTROLLER\"), controller);\n\t\t_add(bytes32(\"ISSUER\"), issuer);\n\t\t_add(bytes32(\"REDEEMER\"), redeemer);\n\t\t_add(bytes32(\"MODULE_EDITOR\"), module_editor);\n\n\t\t_cap = cap;\n\t\temit CapSet(cap);\n\n\t\tsetInterfaceImplementation(\"ERC1400Token\", address(this));\n\n\t\t_isIssuable = true;\n\t\t_isControllable = true;\n\n\t\t_owner = admin;\n\t\temit OwnershipTransferred(address(0), admin);\n\n\t\t// ERC1400Raw\n\t\t_name = name;\n\t\t_symbol = symbol;\n\t\t_totalSupply = 0;\n\n\t\t// Token granularity can not be lower than 1\n\t\trequire(granularity >= 1, \"granularity too low\");\n\t\t_granularity = granularity;\n\n\t\t// GSN\n\t\t_gsnMode = gsnMode.ALL;\n\n\t\t// Default RelayHub address, deployed on mainnet and all testnets at the same address\n\t\t_relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;\n\n\t\t_RELAYED_CALL_ACCEPTED = 0;\n\t\t_RELAYED_CALL_REJECTED = 11;\n\n\t\t// How much gas is forwarded to postRelayedCall\n\t\t_POST_RELAYED_CALL_MAX_GAS = 100000;\n\n\t\t// Reentrancy\n\t\t_initializeReentrancyGuard();\n\t}\n\n\t// GSN\n\t/**\n\t * @dev Adding access control by overriding this function!\n\t * @return true if sender is GSN_CONTROLLER\n\t */\n\tfunction _isGSNController() internal override view returns (bool) {\n\t\treturn hasRole(bytes32(\"GSN_CONTROLLER\"), _msgSender());\n\t}\n\n\t// BULK ISSUANCE\n\t/**\n\t * @dev Mints to a number of token holder at the same time\n\t * Must be issuable and tokenHolders and values must bne same length\n\t * @param partition partition id tokens should be minted for\n\t * @param tokenHolders addresses of all token receiver in the same order as \"values\"\n\t * @param values amounts of tokens to be minted in the same order as \"tokenHolders\"\n\t * @param data Additional data for issueByPartition\n\t */\n\tfunction bulkIssueByPartition(\n\t\tbytes32 partition,\n\t\taddress[] memory tokenHolders,\n\t\tuint256[] memory values,\n\t\tbytes memory data\n\t) public {\n\t\trequire(_isIssuable, \"token not issuable\");\n\t\trequire(tokenHolders.length <= 100, \"too many tokenHolders\");\n\t\trequire(\n\t\t\ttokenHolders.length == values.length,\n\t\t\t\"different array lengths\"\n\t\t);\n\n\t\tfor (uint256 i = 0; i < tokenHolders.length; i++) {\n\t\t\trequire(_totalSupply.add(values[i]) <= _cap, \"exceeds cap\");\n\t\t\t_issueByPartition(\n\t\t\t\tpartition,\n\t\t\t\t_msgSender(),\n\t\t\t\ttokenHolders[i],\n\t\t\t\tvalues[i],\n\t\t\t\tdata,\n\t\t\t\t\"\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/********************** ERC1400 EXTERNAL FUNCTIONS **************************/\n\n\t/**\n\t * [ERC1400 INTERFACE (1/9)]\n\t * @dev Access a document associated with the token.\n\t * @param documentName Short name (represented as a bytes32) associated to the document.\n\t * @return Requested document + document hash.\n\t */\n\tfunction getDocument(bytes32 documentName)\n\t\texternal\n\t\toverride\n\t\tview\n\t\treturns (string memory, bytes32)\n\t{\n\t\treturn (\n\t\t\t_documents[documentName].docURI,\n\t\t\t_documents[documentName].docHash\n\t\t);\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (2/9)]\n\t * @dev Associate a document with the token.\n\t * @param documentName Short name (represented as a bytes32) associated to the document.\n\t * @param uri Document content.\n\t * @param documentHash Hash of the document [optional parameter].\n\t */\n\tfunction setDocument(\n\t\tbytes32 documentName,\n\t\tstring calldata uri,\n\t\tbytes32 documentHash\n\t) external override {\n\t\trequire(\n\t\t\thasRole(bytes32(\"DOCUMENT_EDITOR\"), _msgSender()),\n\t\t\t\"!DOCUMENT_EDITOR\"\n\t\t);\n\t\t_documents[documentName] = Doc({ docURI: uri, docHash: documentHash });\n\t\temit Document(documentName, uri, documentHash);\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (3/9)]\n\t * @dev Know if the token can be controlled by operators.\n\t * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\n\t * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\n\t */\n\tfunction isControllable() external override view returns (bool) {\n\t\treturn _isControllable;\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (4/9)]\n\t * @dev Know if new tokens can be issued in the future.\n\t * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\n\t */\n\tfunction isIssuable() external override view returns (bool) {\n\t\treturn _isIssuable;\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (5/9)]\n\t * @dev Issue tokens from a specific partition.\n\t * @param partition Name of the partition.\n\t * @param tokenHolder Address for which we want to issue tokens.\n\t * @param value Number of tokens issued.\n\t * @param data Information attached to the issuance, by the issuer.\n\t */\n\tfunction issueByPartition(\n\t\tbytes32 partition,\n\t\taddress tokenHolder,\n\t\tuint256 value,\n\t\tbytes calldata data // onlyMinter is taken care of in _issue function\n\t) external override {\n\t\trequire(_isIssuable, \"token not issuable\");\n\n\t\t// total cap is always the sum of all partitionCaps, so it can't be violated\n\n\t\trequire(_totalSupply.add(value) <= _cap, \"exceeds cap\");\n\n\t\t_issueByPartition(\n\t\t\tpartition,\n\t\t\t_msgSender(),\n\t\t\ttokenHolder,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\t\"\"\n\t\t);\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (6/9)]\n\t * @dev Redeem tokens of a specific partition.\n\t * only controllers can redeem\n\t * @param partition Name of the partition.\n\t * @param value Number of tokens redeemed.\n\t * @param data Information attached to the redemption, by the redeemer.\n\t */\n\tfunction redeemByPartition(\n\t\tbytes32 partition,\n\t\tuint256 value,\n\t\tbytes calldata data\n\t) external override {\n\t\t// only REDEEMER can burn tokens (checked in _redeem())\n\n\t\t_redeemByPartition(\n\t\t\tpartition,\n\t\t\t_msgSender(),\n\t\t\t_msgSender(),\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\t\"\"\n\t\t);\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (7/9)]\n\t * @dev Redeem tokens of a specific partition.\n\t * @param partition Name of the partition.\n\t * @param tokenHolder Address for which we want to redeem tokens.\n\t * @param value Number of tokens redeemed.\n\t * @param data Information attached to the redemption.\n\t * @param operatorData Information attached to the redemption, by the operator.\n\t */\n\tfunction operatorRedeemByPartition(\n\t\tbytes32 partition,\n\t\taddress tokenHolder,\n\t\tuint256 value,\n\t\tbytes calldata data,\n\t\tbytes calldata operatorData\n\t) external override {\n\t\t// only REDEEMER can burn tokens (checked in _redeem())\n\n\t\trequire(\n\t\t\t_isOperatorForPartition(partition, _msgSender(), tokenHolder),\n\t\t\t\"!CONTROLLER or !operator\"\n\t\t);\n\t\t// Transfer Blocked - Identity restriction\n\n\t\t_redeemByPartition(\n\t\t\tpartition,\n\t\t\t_msgSender(),\n\t\t\ttokenHolder,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\toperatorData\n\t\t);\n\t}\n\n\t/**\n\t * [ERC1400 INTERFACE (8/9)]\n\t * function canTransferByPartition\n\t * not implemented\n\t */\n\n\t/**\n\t * [ERC1400 INTERFACE (9/9)]\n\t * function canOperatorTransferByPartition\n\t * not implemented\n\t */\n\n\t/********************** ERC1400 INTERNAL FUNCTIONS **************************/\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Issue tokens from a specific partition.\n\t * @param toPartition Name of the partition.\n\t * @param operator The address performing the issuance.\n\t * @param to Token recipient.\n\t * @param value Number of tokens to issue.\n\t * @param data Information attached to the issuance.\n\t * @param operatorData Information attached to the issuance, by the operator (if any).\n\t */\n\n\tfunction _issueByPartition(\n\t\tbytes32 toPartition,\n\t\taddress operator,\n\t\taddress to,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal {\n\t\t_issue(operator, to, value, data, operatorData);\n\t\t_addTokenToPartition(to, toPartition, value);\n\n\t\temit IssuedByPartition(\n\t\t\ttoPartition,\n\t\t\toperator,\n\t\t\tto,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\toperatorData\n\t\t);\n\n\t\t// purely for better visibility on etherscan\n\t\temit Transfer(address(0), to, value);\n\t}\n\n\t/**\n\t * [INTERNAL]\n\t * @dev Redeem tokens of a specific partition.\n\t * @param fromPartition Name of the partition.\n\t * @param operator The address performing the redemption.\n\t * @param from Token holder whose tokens will be redeemed.\n\t * @param value Number of tokens to redeem.\n\t * @param data Information attached to the redemption.\n\t * @param operatorData Information attached to the redemption, by the operator (if any).\n\t */\n\n\tfunction _redeemByPartition(\n\t\tbytes32 fromPartition,\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 value,\n\t\tbytes memory data,\n\t\tbytes memory operatorData\n\t) internal {\n\t\trequire(\n\t\t\t_balanceOfByPartition[from][fromPartition] >= value,\n\t\t\t\"insufficient balance\"\n\t\t);\n\t\t// Transfer Blocked - Sender balance insufficient\n\n\t\t_removeTokenFromPartition(from, fromPartition, value);\n\t\t_redeem(operator, from, value, data, operatorData);\n\n\t\temit RedeemedByPartition(\n\t\t\tfromPartition,\n\t\t\toperator,\n\t\t\tfrom,\n\t\t\tvalue,\n\t\t\tdata,\n\t\t\toperatorData\n\t\t);\n\n\t\t// purely for better visibility on etherscan\n\t\temit Transfer(from, address(0), value);\n\t}\n\n\t/********************** ERC1400 OPTIONAL FUNCTIONS **************************/\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400 STANDARD]\n\t * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\n\t * Once set to false, '_isControllable' can never be set to 'true' again.\n\t */\n\tfunction renounceControl() external override {\n\t\trequire(hasRole(bytes32(\"ADMIN\"), _msgSender()), \"!ADMIN\");\n\t\t_isControllable = false;\n\t}\n\n\t/**\n\t * [NOT MANDATORY FOR ERC1400 STANDARD]\n\t * @dev Definitely renounce the possibility to issue new tokens.\n\t * Once set to false, '_isIssuable' can never be set to 'true' again.\n\t */\n\tfunction renounceIssuance() external override {\n\t\trequire(hasRole(bytes32(\"ADMIN\"), _msgSender()), \"!ADMIN\");\n\t\t_isIssuable = false;\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity 0.6.6;\n\nimport \"../token/ERC1400Capped.sol\";\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard is ERC1400Capped {\n\tfunction _initializeReentrancyGuard() internal {\n\t\t// Storing an initial non-zero value makes deployment a bit more\n\t\t// expensive, but in exchange the refund on every call to nonReentrant\n\t\t// will be lower in amount. Since refunds are capped to a percetange of\n\t\t// the total transaction's gas, it is best to keep them low in cases\n\t\t// like this one, to increase the likelihood of the full refund coming\n\t\t// into effect.\n\t\t_notEntered = true;\n\t}\n\n\t/**\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\n\t * Calling a `nonReentrant` function from another `nonReentrant`\n\t * function is not supported. It is possible to prevent this from happening\n\t * by making the `nonReentrant` function external, and make it call a\n\t * `private` function that does the actual work.\n\t */\n\tmodifier nonReentrant() {\n\t\t// On the first call to nonReentrant, _notEntered will be true\n\t\trequire(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n\t\t// Any calls to nonReentrant after this point will fail\n\t\t_notEntered = false;\n\n\t\t_;\n\n\t\t// By storing the original value once again, a refund is triggered (see\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\n\t\t_notEntered = true;\n\t}\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/GSN/IRelayHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract\n * directly.\n *\n * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on\n * how to deploy an instance of `RelayHub` on your local test network.\n */\ninterface IRelayHub {\n    // Relay management\n\n    /**\n     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller\n     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay\n     * cannot be its own owner.\n     *\n     * All Ether in this function call will be added to the relay's stake.\n     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.\n     *\n     * Emits a {Staked} event.\n     */\n    function stake(address relayaddr, uint256 unstakeDelay) external payable;\n\n    /**\n     * @dev Emitted when a relay's stake or unstakeDelay are increased\n     */\n    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\n\n    /**\n     * @dev Registers the caller as a relay.\n     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).\n     *\n     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received\n     * `transactionFee` is not enforced by {relayCall}.\n     *\n     * Emits a {RelayAdded} event.\n     */\n    function registerRelay(uint256 transactionFee, string calldata url) external;\n\n    /**\n     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out\n     * {RelayRemoved} events) lets a client discover the list of available relays.\n     */\n    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\n\n    /**\n     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.\n     *\n     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be\n     * callable.\n     *\n     * Emits a {RelayRemoved} event.\n     */\n    function removeRelayByOwner(address relay) external;\n\n    /**\n     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.\n     */\n    event RelayRemoved(address indexed relay, uint256 unstakeTime);\n\n    /** Deletes the relay from the system, and gives back its stake to the owner.\n     *\n     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.\n     *\n     * Emits an {Unstaked} event.\n     */\n    function unstake(address relay) external;\n\n    /**\n     * @dev Emitted when a relay is unstaked for, including the returned stake.\n     */\n    event Unstaked(address indexed relay, uint256 stake);\n\n    // States a relay can be in\n    enum RelayState {\n        Unknown, // The relay is unknown to the system: it has never been staked for\n        Staked, // The relay has been staked for, but it is not yet active\n        Registered, // The relay has registered itself, and is active (can relay calls)\n        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n    }\n\n    /**\n     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function\n     * to return an empty entry.\n     */\n    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\n\n    // Balance management\n\n    /**\n     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.\n     *\n     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.\n     *\n     * Emits a {Deposited} event.\n     */\n    function depositFor(address target) external payable;\n\n    /**\n     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.\n     */\n    event Deposited(address indexed recipient, address indexed from, uint256 amount);\n\n    /**\n     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.\n     */\n    function balanceOf(address target) external view returns (uint256);\n\n    /**\n     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and\n     * contracts can use it to reduce their funding.\n     *\n     * Emits a {Withdrawn} event.\n     */\n    function withdraw(uint256 amount, address payable dest) external;\n\n    /**\n     * @dev Emitted when an account withdraws funds from `RelayHub`.\n     */\n    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\n\n    // Relaying\n\n    /**\n     * @dev Checks if the `RelayHub` will accept a relayed operation.\n     * Multiple things must be true for this to happen:\n     *  - all arguments must be signed for by the sender (`from`)\n     *  - the sender's nonce must be the current one\n     *  - the recipient must accept this transaction (via {acceptRelayedCall})\n     *\n     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error\n     * code if it returns one in {acceptRelayedCall}.\n     */\n    function canRelay(\n        address relay,\n        address from,\n        address to,\n        bytes calldata encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes calldata signature,\n        bytes calldata approvalData\n    ) external view returns (uint256 status, bytes memory recipientContext);\n\n    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.\n    enum PreconditionCheck {\n        OK,                         // All checks passed, the call can be relayed\n        WrongSignature,             // The transaction to relay is not signed by requested sender\n        WrongNonce,                 // The provided nonce has already been used by the sender\n        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall\n        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code\n    }\n\n    /**\n     * @dev Relays a transaction.\n     *\n     * For this to succeed, multiple conditions must be met:\n     *  - {canRelay} must `return PreconditionCheck.OK`\n     *  - the sender must be a registered relay\n     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender\n     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the\n     * recipient) use all gas available to them\n     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is\n     * spent)\n     *\n     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded\n     * function and {postRelayedCall} will be called in that order.\n     *\n     * Parameters:\n     *  - `from`: the client originating the request\n     *  - `to`: the target {IRelayRecipient} contract\n     *  - `encodedFunction`: the function call to relay, including data\n     *  - `transactionFee`: fee (%) the relay takes over actual gas cost\n     *  - `gasPrice`: gas price the client is willing to pay\n     *  - `gasLimit`: gas to forward when calling the encoded function\n     *  - `nonce`: client's nonce\n     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses\n     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the\n     * `RelayHub`, but it still can be used for e.g. a signature.\n     *\n     * Emits a {TransactionRelayed} event.\n     */\n    function relayCall(\n        address from,\n        address to,\n        bytes calldata encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes calldata signature,\n        bytes calldata approvalData\n    ) external;\n\n    /**\n     * @dev Emitted when an attempt to relay a call failed.\n     *\n     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The\n     * actual relayed call was not executed, and the recipient not charged.\n     *\n     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values\n     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.\n     */\n    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\n\n    /**\n     * @dev Emitted when a transaction is relayed.\n     * Useful when monitoring a relay's operation and relayed calls to a contract\n     *\n     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.\n     *\n     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.\n     */\n    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\n\n    // Reason error codes for the TransactionRelayed event\n    enum RelayCallStatus {\n        OK,                      // The transaction was successfully relayed and execution successful - never included in the event\n        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed\n        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting\n        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting\n        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient's balance changing\n    }\n\n    /**\n     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will\n     * spend up to `relayedCallStipend` gas.\n     */\n    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);\n\n    /**\n     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.\n     */\n    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);\n\n     // Relay penalization.\n     // Any account can penalize relays, removing them from the system immediately, and rewarding the\n    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it\n    // still loses half of its stake.\n\n    /**\n     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and\n     * different data (gas price, gas limit, etc. may be different).\n     *\n     * The (unsigned) transaction data and signature for both transactions must be provided.\n     */\n    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;\n\n    /**\n     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.\n     */\n    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;\n\n    /**\n     * @dev Emitted when a relay is penalized.\n     */\n    event Penalized(address indexed relay, address sender, uint256 amount);\n\n    /**\n     * @dev Returns an account's nonce in `RelayHub`.\n     */\n    function getNonce(address from) external view returns (uint256);\n}\n\n"
    },
    "/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/GSN/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.\n *\n * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.\n */\ninterface IRelayRecipient {\n    /**\n     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.\n     */\n    function getHubAddr() external view returns (address);\n\n    /**\n     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the\n     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).\n     *\n     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call\n     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,\n     * and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the\n     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for\n     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature\n     * over all or some of the previous values.\n     *\n     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,\n     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.\n     *\n     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered\n     * rejected. A regular revert will also trigger a rejection.\n     */\n    function acceptRelayedCall(\n        address relay,\n        address from,\n        bytes calldata encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes calldata approvalData,\n        uint256 maxPossibleCharge\n    )\n        external\n        view\n        returns (uint256, bytes memory);\n\n    /**\n     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.\n     * pre-charge the sender of the transaction.\n     *\n     * `context` is the second value returned in the tuple by {acceptRelayedCall}.\n     *\n     * Returns a value to be passed to {postRelayedCall}.\n     *\n     * {preRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\n     * will not be executed, but the recipient will still be charged for the transaction's cost.\n     */\n    function preRelayedCall(bytes calldata context) external returns (bytes32);\n\n    /**\n     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.\n     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform\n     * contract-specific bookkeeping.\n     *\n     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of\n     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,\n     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.\n     *\n     *\n     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\n     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the\n     * transaction's cost.\n     */\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "/Users/simondos/projects/micobo-security-token/node_modules/@openzeppelin/upgrades/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    }
  }
}