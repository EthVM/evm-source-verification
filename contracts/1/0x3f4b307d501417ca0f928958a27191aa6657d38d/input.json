{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ConnectUniswapV2.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\ninterface TokenInterface {\r\n    function approve(address, uint256) external;\r\n    function transfer(address, uint) external;\r\n    function transferFrom(address, address, uint) external;\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\ninterface MemoryInterface {\r\n    function getUint(uint id) external returns (uint num);\r\n    function setUint(uint id, uint val) external;\r\n}\r\n\r\ninterface EventInterface {\r\n    function emitEvent(uint connectorType, uint connectorID, bytes32 eventCode, bytes calldata eventData) external;\r\n}\r\n\r\ncontract Stores {\r\n\r\n  /**\r\n   * @dev Return ethereum address\r\n   */\r\n  function getEthAddr() internal pure returns (address) {\r\n    return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n  }\r\n\r\n  /**\r\n   * @dev Return memory variable address\r\n   */\r\n  function getMemoryAddr() internal pure returns (address) {\r\n    return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\r\n  }\r\n\r\n  /**\r\n   * @dev Return InstaEvent Address.\r\n   */\r\n  function getEventAddr() internal pure returns (address) {\r\n    return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\r\n  }\r\n\r\n  /**\r\n   * @dev Get Uint value from InstaMemory Contract.\r\n   */\r\n  function getUint(uint getId, uint val) internal returns (uint returnVal) {\r\n    returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\r\n  }\r\n\r\n  /**\r\n  * @dev Set Uint value in InstaMemory Contract.\r\n  */\r\n  function setUint(uint setId, uint val) virtual internal {\r\n    if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\r\n  }\r\n\r\n  /**\r\n  * @dev emit event on event contract\r\n  */\r\n  function emitEvent(bytes32 eventCode, bytes memory eventData) virtual internal {\r\n    (uint model, uint id) = connectorID();\r\n    EventInterface(getEventAddr()).emitEvent(model, id, eventCode, eventData);\r\n  }\r\n\r\n  /**\r\n  * @dev Connector Details.\r\n  */\r\n  function connectorID() public pure returns(uint model, uint id) {\r\n    (model, id) = (1, 71);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n  uint constant WAD = 10 ** 18;\r\n  uint constant RAY = 10 ** 27;\r\n\r\n  function add(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.add(x, y);\r\n  }\r\n\r\n  function sub(uint x, uint y) internal virtual pure returns (uint z) {\r\n    z = SafeMath.sub(x, y);\r\n  }\r\n\r\n  function mul(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.mul(x, y);\r\n  }\r\n\r\n  function div(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.div(x, y);\r\n  }\r\n\r\n  function wmul(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;\r\n  }\r\n\r\n  function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;\r\n  }\r\n\r\n  function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;\r\n  }\r\n\r\n  function rmul(uint x, uint y) internal pure returns (uint z) {\r\n    z = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;\r\n  }\r\n\r\n}\r\n\r\npragma solidity >=0.4.0;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    // credit for this implementation goes to\r\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        if (x == 0) return 0;\r\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\r\n        // however that code costs significantly more gas\r\n        uint256 xx = x;\r\n        uint256 r = 1;\r\n        if (xx >= 0x100000000000000000000000000000000) {\r\n            xx >>= 128;\r\n            r <<= 64;\r\n        }\r\n        if (xx >= 0x10000000000000000) {\r\n            xx >>= 64;\r\n            r <<= 32;\r\n        }\r\n        if (xx >= 0x100000000) {\r\n            xx >>= 32;\r\n            r <<= 16;\r\n        }\r\n        if (xx >= 0x10000) {\r\n            xx >>= 16;\r\n            r <<= 8;\r\n        }\r\n        if (xx >= 0x100) {\r\n            xx >>= 8;\r\n            r <<= 4;\r\n        }\r\n        if (xx >= 0x10) {\r\n            xx >>= 4;\r\n            r <<= 2;\r\n        }\r\n        if (xx >= 0x8) {\r\n            r <<= 1;\r\n        }\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1;\r\n        r = (r + x / r) >> 1; // Seven iterations should be enough\r\n        uint256 r1 = x / r;\r\n        return (r < r1 ? r : r1);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n  function allPairs(uint) external view returns (address pair);\r\n  function allPairsLength() external view returns (uint);\r\n\r\n  function feeTo() external view returns (address);\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  function balanceOf(address owner) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n}\r\n\r\ncontract UniswapHelpers is Stores, DSMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Return WETH address\r\n     */\r\n    function getAddressWETH() internal pure returns (address) {\r\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\r\n        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // kovan\r\n    }\r\n\r\n    /**\r\n     * @dev Return uniswap v2 router02 Address\r\n     */\r\n    function getUniswapAddr() internal pure returns (address) {\r\n        return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    }\r\n\r\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\r\n        amt = (_amt / 10 ** (18 - _dec));\r\n    }\r\n\r\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\r\n        amt = mul(_amt, 10 ** (18 - _dec));\r\n    }\r\n\r\n    function getTokenBalace(address token) internal view returns (uint256 amt) {\r\n        amt = token == getEthAddr() ? address(this).balance : TokenInterface(token).balanceOf(address(this));\r\n    }\r\n\r\n    function changeEthAddress(address buy, address sell) internal pure returns(TokenInterface _buy, TokenInterface _sell){\r\n        _buy = buy == getEthAddr() ? TokenInterface(getAddressWETH()) : TokenInterface(buy);\r\n        _sell = sell == getEthAddr() ? TokenInterface(getAddressWETH()) : TokenInterface(sell);\r\n    }\r\n\r\n    function convertEthToWeth(TokenInterface token, uint amount) internal {\r\n        if(address(token) == getAddressWETH()) token.deposit.value(amount)();\r\n    }\r\n\r\n    function convertWethToEth(TokenInterface token, uint amount) internal {\r\n       if(address(token) == getAddressWETH()) {\r\n            token.approve(getAddressWETH(), amount);\r\n            token.withdraw(amount);\r\n        }\r\n    }\r\n\r\n    function getExpectedBuyAmt(\r\n        IUniswapV2Router02 router,\r\n        address[] memory paths,\r\n        uint sellAmt\r\n    ) internal view returns(uint buyAmt) {\r\n        uint[] memory amts = router.getAmountsOut(\r\n            sellAmt,\r\n            paths\r\n        );\r\n        buyAmt = amts[1];\r\n    }\r\n\r\n    function getExpectedSellAmt(\r\n        IUniswapV2Router02 router,\r\n        address[] memory paths,\r\n        uint buyAmt\r\n    ) internal view returns(uint sellAmt) {\r\n        uint[] memory amts = router.getAmountsIn(\r\n            buyAmt,\r\n            paths\r\n        );\r\n        sellAmt = amts[0];\r\n    }\r\n\r\n    function checkPair(\r\n        IUniswapV2Router02 router,\r\n        address[] memory paths\r\n    ) internal view {\r\n        address pair = IUniswapV2Factory(router.factory()).getPair(paths[0], paths[1]);\r\n        require(pair != address(0), \"No-exchange-address\");\r\n    }\r\n\r\n    function getPaths(\r\n        address buyAddr,\r\n        address sellAddr\r\n    ) internal pure returns(address[] memory paths) {\r\n        paths = new address[](2);\r\n        paths[0] = address(sellAddr);\r\n        paths[1] = address(buyAddr);\r\n    }\r\n\r\n    function changeEthToWeth(\r\n        address[] memory tokens\r\n    ) internal pure returns(TokenInterface[] memory _tokens) {\r\n        _tokens = new TokenInterface[](2);\r\n        _tokens[0] = tokens[0] == getEthAddr() ? TokenInterface(getAddressWETH()) : TokenInterface(tokens[0]);\r\n        _tokens[1] = tokens[1] == getEthAddr() ? TokenInterface(getAddressWETH()) : TokenInterface(tokens[1]);\r\n    }\r\n\r\n    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n         return\r\n            Babylonian\r\n                .sqrt(\r\n                    reserveIn.mul(\r\n                        userIn.mul(3988000).add(reserveIn.mul(3988009))\r\n                    )\r\n                ).sub(reserveIn.mul(1997)) / 1994;\r\n    }\r\n}\r\n\r\ncontract LiquidityHelpers is UniswapHelpers {\r\n    function _addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint slippage\r\n    ) internal returns (uint _amtA, uint _amtB, uint _liquidity) {\r\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\r\n        (TokenInterface _tokenA, TokenInterface _tokenB) = changeEthAddress(tokenA, tokenB);\r\n\r\n        convertEthToWeth(_tokenA, amountADesired);\r\n        convertEthToWeth(_tokenB, amountBDesired);\r\n        _tokenA.approve(address(router), 0);\r\n        _tokenA.approve(address(router), amountADesired);\r\n\r\n        _tokenB.approve(address(router), 0);\r\n        _tokenB.approve(address(router), amountBDesired);\r\n\r\n       uint minAmtA = wmul(sub(WAD, slippage), amountADesired);\r\n        uint minAmtB = wmul(sub(WAD, slippage), amountBDesired);\r\n\r\n       (_amtA, _amtB, _liquidity) = router.addLiquidity(\r\n            address(_tokenA),\r\n            address(_tokenB),\r\n            amountADesired,\r\n            amountBDesired,\r\n            minAmtA,\r\n            minAmtB,\r\n            address(this),\r\n            now + 1\r\n        );\r\n\r\n        if (_amtA < amountADesired) {\r\n            convertWethToEth(_tokenA, _tokenA.balanceOf(address(this)));\r\n        }\r\n\r\n        if (_amtB < amountBDesired) {\r\n            convertWethToEth(_tokenB, _tokenB.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function _addSingleLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountA,\r\n        uint minUniAmount\r\n    ) internal returns (uint _amtA, uint _amtB, uint _liquidity) {\r\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\r\n        (TokenInterface _tokenA, TokenInterface _tokenB) = changeEthAddress(tokenA, tokenB);\r\n        \r\n        uint256 _amountA = amountA;\r\n        \r\n        if (amountA == uint(-1)) {\r\n            _amountA = tokenA == getEthAddr() ? address(this).balance : _tokenA.balanceOf(address(this));\r\n        }\r\n\r\n        convertEthToWeth(_tokenA, _amountA);\r\n\r\n\r\n        uint256 _amountB; \r\n        \r\n        (_amountA, _amountB)= _swapSingleToken(router, _tokenA, _tokenB, _amountA);\r\n\r\n        _tokenA.approve(address(router), 0);\r\n        _tokenA.approve(address(router), _amountA);\r\n\r\n        _tokenB.approve(address(router), 0);\r\n        _tokenB.approve(address(router), _amountB);\r\n\r\n       (_amtA, _amtB, _liquidity) = router.addLiquidity(\r\n            address(_tokenA),\r\n            address(_tokenB),\r\n            _amountA,\r\n            _amountB,\r\n            1, // TODO @thrilok209: check this\r\n            1, // TODO @thrilok209: check this\r\n            address(this),\r\n            now + 1\r\n        );\r\n\r\n        require(_liquidity >= minUniAmount, \"too much slippage\");\r\n\r\n        if (_amountA > _amtA) {\r\n            convertWethToEth(_tokenA, _tokenA.balanceOf(address(this)));\r\n        }\r\n\r\n        if (_amountB > _amtB) {\r\n            convertWethToEth(_tokenB, _tokenB.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function _swapSingleToken(\r\n        IUniswapV2Router02 router,\r\n        TokenInterface tokenA,\r\n        TokenInterface tokenB,\r\n        uint _amountA\r\n    ) internal returns(uint256 amountA, uint256 amountB){\r\n        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\r\n        IUniswapV2Pair lpToken = IUniswapV2Pair(factory.getPair(address(tokenA), address(tokenB)));\r\n        require(address(lpToken) != address(0), \"No-exchange-address\");\r\n        \r\n        (uint256 reserveA, uint256 reserveB, ) = lpToken.getReserves();\r\n        uint256 reserveIn = lpToken.token0() == address(tokenA) ? reserveA : reserveB;\r\n        uint256 swapAmtA = calculateSwapInAmount(reserveIn, _amountA);\r\n\r\n        address[] memory paths = getPaths(address(tokenB), address(tokenA));\r\n\r\n        tokenA.approve(address(router), swapAmtA);\r\n\r\n        amountB = router.swapExactTokensForTokens(\r\n            swapAmtA,\r\n            1, // TODO @thrilok209: check this\r\n            paths,\r\n            address(this),\r\n            now + 1\r\n        )[1];\r\n\r\n        amountA = sub(_amountA, swapAmtA);\r\n    }\r\n\r\n    function _removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint _amt,\r\n        uint unitAmtA,\r\n        uint unitAmtB\r\n    ) internal returns (uint _amtA, uint _amtB, uint _uniAmt) {\r\n        IUniswapV2Router02 router;\r\n        TokenInterface _tokenA;\r\n        TokenInterface _tokenB;\r\n        (router, _tokenA, _tokenB, _uniAmt) = _getRemoveLiquidityData(\r\n            tokenA,\r\n            tokenB,\r\n            _amt\r\n        );\r\n        {\r\n        uint minAmtA = convert18ToDec(_tokenA.decimals(), wmul(unitAmtA, _uniAmt));\r\n        uint minAmtB = convert18ToDec(_tokenB.decimals(), wmul(unitAmtB, _uniAmt));\r\n        (_amtA, _amtB) = router.removeLiquidity(\r\n            address(_tokenA),\r\n            address(_tokenB),\r\n            _uniAmt,\r\n            minAmtA,\r\n            minAmtB,\r\n            address(this),\r\n            now + 1\r\n        );\r\n        }\r\n        convertWethToEth(_tokenA, _amtA);\r\n        convertWethToEth(_tokenB, _amtB);\r\n    }\r\n\r\n    function _getRemoveLiquidityData(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint _amt\r\n    ) internal returns (IUniswapV2Router02 router, TokenInterface _tokenA, TokenInterface _tokenB, uint _uniAmt) {\r\n        router = IUniswapV2Router02(getUniswapAddr());\r\n        (_tokenA, _tokenB) = changeEthAddress(tokenA, tokenB);\r\n        address exchangeAddr = IUniswapV2Factory(router.factory()).getPair(address(_tokenA), address(_tokenB));\r\n        require(exchangeAddr != address(0), \"pair-not-found.\");\r\n\r\n        TokenInterface uniToken = TokenInterface(exchangeAddr);\r\n        _uniAmt = _amt == uint(-1) ? uniToken.balanceOf(address(this)) : _amt;\r\n        uniToken.approve(address(router), _uniAmt);\r\n    }\r\n}\r\n\r\ncontract UniswapLiquidity is LiquidityHelpers {\r\n    event LogDepositLiquidity(\r\n        address indexed tokenA,\r\n        address indexed tokenB,\r\n        uint amtA,\r\n        uint amtB,\r\n        uint uniAmount,\r\n        uint getIdA,\r\n        uint getIdB,\r\n        uint setId\r\n    );\r\n\r\n    event LogWithdrawLiquidity(\r\n        address indexed tokenA,\r\n        address indexed tokenB,\r\n        uint amountA,\r\n        uint amountB,\r\n        uint uniAmount,\r\n        uint getId,\r\n        uint[] setId\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev Deposit Liquidity.\r\n     * @param tokenA tokenA address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param tokenB tokenB address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amountADesired tokenA amount.\r\n     * @param amountBDesired tokenB amount.\r\n     * @param slippage slippage for tokenA & tokenB.(For 1%: 1e16, 10%: 1e17)\r\n     * @param getIdA Get tokenA amount at this ID from `InstaMemory` Contract.\r\n     * @param getIdB Get tokenB amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function deposit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint slippage,\r\n        uint getIdA,\r\n        uint getIdB,\r\n        uint setId\r\n    ) external payable {\r\n        uint _amtADesired = getUint(getIdA, amountADesired);\r\n        uint _amtBDesired = getUint(getIdB, amountBDesired);\r\n\r\n        (uint _amtA, uint _amtB, uint _uniAmt) = _addLiquidity(\r\n                                            tokenA,\r\n                                            tokenB,\r\n                                            _amtADesired,\r\n                                            _amtBDesired,\r\n                                            slippage\r\n                                        );\r\n        setUint(setId, _uniAmt);\r\n\r\n        emit LogDepositLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            _amtA,\r\n            _amtB,\r\n            _uniAmt,\r\n            getIdA,\r\n            getIdB,\r\n            setId\r\n        );\r\n\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Deposit Liquidity using Single token.\r\n     * @param tokenA tokenA address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param tokenB tokenB address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param amountA tokenA amount.\r\n     * @param minUniAmount min uni token amount.\r\n     * @param getId Get tokenA amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function singleDeposit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountA,\r\n        uint minUniAmount,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable {\r\n        uint _amt = getUint(getId, amountA);\r\n\r\n        (uint _amtA, uint _amtB, uint _uniAmt) = _addSingleLiquidity(\r\n                                            tokenA,\r\n                                            tokenB,\r\n                                            _amt,\r\n                                            minUniAmount\r\n                                        );\r\n        setUint(setId, _uniAmt);\r\n\r\n        emit LogDepositLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            _amtA,\r\n            _amtB,\r\n            _uniAmt,\r\n            getId,\r\n            0,\r\n            setId\r\n        );\r\n    }\r\n\r\n       \r\n\r\n    /**\r\n     * @dev Withdraw Liquidity.\r\n     * @param tokenA tokenA address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param tokenB tokenB address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param uniAmt uni token amount.\r\n     * @param unitAmtA unit amount of amtA/uniAmt with slippage.\r\n     * @param unitAmtB unit amount of amtB/uniAmt with slippage.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setIds Set token amounts at this IDs in `InstaMemory` Contract.\r\n    */\r\n    function withdraw(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint uniAmt,\r\n        uint unitAmtA,\r\n        uint unitAmtB,\r\n        uint getId,\r\n        uint[] calldata setIds\r\n    ) external payable {\r\n        uint _amt = getUint(getId, uniAmt);\r\n\r\n        (uint _amtA, uint _amtB, uint _uniAmt) = _removeLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            _amt,\r\n            unitAmtA,\r\n            unitAmtB\r\n        );\r\n\r\n        setUint(setIds[0], _amtA);\r\n        setUint(setIds[1], _amtB);\r\n\r\n         emit LogWithdrawLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            _amtA,\r\n            _amtB,\r\n            _uniAmt,\r\n            getId,\r\n            setIds\r\n        );\r\n    }\r\n}\r\n\r\ncontract UniswapResolver is UniswapLiquidity {\r\n    event LogBuy(\r\n        address indexed buyToken,\r\n        address indexed sellToken,\r\n        uint256 buyAmt,\r\n        uint256 sellAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n\r\n    event LogSell(\r\n        address indexed buyToken,\r\n        address indexed sellToken,\r\n        uint256 buyAmt,\r\n        uint256 sellAmt,\r\n        uint256 getId,\r\n        uint256 setId\r\n    );\r\n\r\n    /**\r\n     * @dev Buy ETH/ERC20_Token.\r\n     * @param buyAddr buying token address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param sellAddr selling token amount.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param buyAmt buying token amount.\r\n     * @param unitAmt unit amount of sellAmt/buyAmt with slippage.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function buy(\r\n        address buyAddr,\r\n        address sellAddr,\r\n        uint buyAmt,\r\n        uint unitAmt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable {\r\n        uint _buyAmt = getUint(getId, buyAmt);\r\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\r\n        address[] memory paths = getPaths(address(_buyAddr), address(_sellAddr));\r\n\r\n        uint _slippageAmt = convert18ToDec(_sellAddr.decimals(),\r\n            wmul(unitAmt, convertTo18(_buyAddr.decimals(), _buyAmt)));\r\n\r\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\r\n\r\n        checkPair(router, paths);\r\n        uint _expectedAmt = getExpectedSellAmt(router, paths, _buyAmt);\r\n        require(_slippageAmt >= _expectedAmt, \"Too much slippage\");\r\n\r\n        convertEthToWeth(_sellAddr, _expectedAmt);\r\n        _sellAddr.approve(address(router), _expectedAmt);\r\n\r\n        uint _sellAmt = router.swapTokensForExactTokens(\r\n            _buyAmt,\r\n            _expectedAmt,\r\n            paths,\r\n            address(this),\r\n            now + 1\r\n        )[0];\r\n\r\n        convertWethToEth(_buyAddr, _buyAmt);\r\n\r\n        setUint(setId, _sellAmt);\r\n\r\n        emit LogBuy(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\r\n    }\r\n\r\n    /**\r\n     * @dev Sell ETH/ERC20_Token.\r\n     * @param buyAddr buying token address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param sellAddr selling token amount.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\r\n     * @param sellAmt selling token amount.\r\n     * @param unitAmt unit amount of buyAmt/sellAmt with slippage.\r\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\r\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\r\n    */\r\n    function sell(\r\n        address buyAddr,\r\n        address sellAddr,\r\n        uint sellAmt,\r\n        uint unitAmt,\r\n        uint getId,\r\n        uint setId\r\n    ) external payable {\r\n        uint _sellAmt = getUint(getId, sellAmt);\r\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\r\n        address[] memory paths = getPaths(address(_buyAddr), address(_sellAddr));\r\n\r\n        if (_sellAmt == uint(-1)) {\r\n            _sellAmt = sellAddr == getEthAddr() ? address(this).balance : _sellAddr.balanceOf(address(this));\r\n        }\r\n\r\n        uint _slippageAmt = convert18ToDec(_buyAddr.decimals(),\r\n            wmul(unitAmt, convertTo18(_sellAddr.decimals(), _sellAmt)));\r\n\r\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\r\n\r\n        checkPair(router, paths);\r\n        uint _expectedAmt = getExpectedBuyAmt(router, paths, _sellAmt);\r\n        require(_slippageAmt <= _expectedAmt, \"Too much slippage\");\r\n\r\n        convertEthToWeth(_sellAddr, _sellAmt);\r\n        _sellAddr.approve(address(router), _sellAmt);\r\n\r\n        uint _buyAmt = router.swapExactTokensForTokens(\r\n            _sellAmt,\r\n            _expectedAmt,\r\n            paths,\r\n            address(this),\r\n            now + 1\r\n        )[1];\r\n\r\n        convertWethToEth(_buyAddr, _buyAmt);\r\n\r\n        setUint(setId, _buyAmt);\r\n\r\n        emit LogSell(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\r\n    }\r\n}\r\n\r\n\r\ncontract ConnectUniswapV2 is UniswapResolver {\r\n    string public name = \"UniswapV2-v1.1\";\r\n}"
    }
  }
}