{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/hodler/hodler.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.6.11;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function div(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0);\n        z = x / y;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    \n    /* Remove tranfer functionality for hodler token\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    */\n}\n\ncontract HodlerERC20 is IERC20 {\n    using SafeMath for uint;\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    uint public override totalSupply;\n    uint public totalWithdraw;\n    mapping(address => uint) public override balanceOf;\n    //mapping(address => mapping(address => uint)) public override allowance;\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _burnCurve(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalWithdraw = totalWithdraw.add(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    /* Remove tranfer functionality for hodler token\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n    */\n}\n\ncontract Hodler is HodlerERC20{\n  using SafeMath for uint256;\n\n  bool public initialized;\n  address public asset;\n  uint256 public start_amount;\n  uint256 public min_percent;\n  uint256 public max_percent;\n  \n  bool public started;\n  uint256 public start_time;\n  bool public ended;\n  mapping(address => uint256) public end_time;\n \n  event Deposit(address indexed from, uint256 amount);\n  event Withdraw(address indexed from, uint256 asset_value, uint256 token_value, bool started);\n\n  uint256 private unlocked = 1;\n  modifier lock() {\n      require(unlocked == 1, 'Hodler: LOCKED');\n      unlocked = 0;\n      _;\n      unlocked = 1;\n  }\n\n  function initialize(address _asset, uint256 _amount, uint256 _min, uint256 _max) public {\n      require(initialized == false, \"Hodler_initialize: already initialized\");\n      initialized = true;\n      asset = _asset;\n      start_amount = _amount;\n      min_percent = _min;\n      max_percent = _max;\n      string memory _name = IERC20(asset).name();\n      name = append(\"Hodler \", _name);\n      string memory _symbol = IERC20(asset).symbol();\n      symbol = append(\"hodl\", _symbol);\n      decimals = IERC20(asset).decimals();\n  }\n\n  function deposit(uint256 amount) public lock {\n      require(amount > 0, \"Hodler_Deposit: zero asset deposit\"); \n      require(ended == false, \"Hodler_Deposit: game ended\");\n      require(started == false, \"Hodler_Deposit: game started\");\n      if (totalSupply.add(amount) >= start_amount) {\n          require(totalSupply.add(amount) < start_amount.mul(2), \"Hodler_Deposit: final deposit out of range\");\n          started = true;\n          start_time = block.timestamp;\n      }\n      TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount); \n      _mint(msg.sender, amount);\n      Deposit(msg.sender, amount);\n  }\n\n  function withdraw(uint256 token_amount) public lock {\n      require(token_amount > 0, \"Hodler_withdraw: zero token withdraw\"); \n      require(ended == false, \"Hodler_withdraw: game ended\");\n      uint256 asset_withdraw;\n      if (started != true) {\n          asset_withdraw = token_amount;\n          _burn(msg.sender, token_amount);\n      } else {\n          asset_withdraw = calculateAssetOut(token_amount);\n          if (totalWithdraw.add(token_amount) == totalSupply) {\n              ended = true;\n          }  \n          require(asset_withdraw > 0, \"Hodler_withdraw: zero asset withdraw\");\n          _burnCurve(msg.sender, token_amount);\n          if (balanceOf[msg.sender] == 0) {end_time[msg.sender] = block.timestamp;}\n      }\n      TransferHelper.safeTransfer(asset, msg.sender, asset_withdraw);\n      Withdraw(msg.sender, asset_withdraw, token_amount, started);\n  }\n\n  function calculateAssetOut(uint256 token_amount) public view returns (uint256) {\n      uint256 rounding = totalSupply;\n      /*\n       1. Calc perc_assets_out_new = 40 * totalWithdraw/totalSupply + 80 \n          -> At min this is 40 * 0 + 80 = 80% \n          -> At max this is 40 * 1 + 80 = 120% \n      */\n      uint256 difference = max_percent.sub(min_percent);\n      uint256 perc_assets_out_old = difference.mul(rounding).mul(totalWithdraw).div(totalSupply).add(min_percent.mul(rounding));\n      uint256 new_totalWithdraw = totalWithdraw.add(token_amount);\n      uint256 perc_assets_out_new = difference.mul(rounding).mul(new_totalWithdraw).div(totalSupply).add(min_percent.mul(rounding));\n      /* \n        2. Calc mean percent difference -> perc_new - perc_old / 2 + perc_old\n          -> at 120 perc_new and 100 perc_old = (120 - 100) / 2 + 100 = 110% \n          -> at 100 perc_new and 80 perc_old = (100 - 80) / 2 + 80 = 90%\n      */\n      uint256 mean_perc = (perc_assets_out_new.sub(perc_assets_out_old)).div(2).add(perc_assets_out_old);\n      /* \n        3. Calc assets out -> token_amount * mean_perc_diff / 100\n          -> at mean_perc_diff 110% = 110 * token_amount / 100\n      */\n      uint256 assets_out = mean_perc.mul(token_amount).div(rounding.mul(100));\n      if (new_totalWithdraw == totalSupply) {\n          IERC20 weth = IERC20(asset);\n          assets_out = weth.balanceOf(address(this));\n      }\n      return assets_out;\n  }\n\n  function append(string memory a, string memory b) internal pure returns (string memory) {\n      return string(abi.encodePacked(a, b));\n  }\n}\n\ncontract HodlerFactory {\n\n    mapping(address => address[]) public hodler;\n    mapping(address => uint256) public index;\n    address[] public allHodlers;\n\n    event Create(address hodler, address asset);\n \n    function allHodlersLength() external view returns (uint) {\n        return allHodlers.length;\n    }\n\n    function createHodler(address asset) public returns (address) {\n        require(asset != address(0), \"HodlerFactory: zero asset input\");\n        uint256 _index = index[asset];\n        index[asset] += 1;\n        if (_index > 0) {\n            address previous = hodler[asset][_index - 1];\n            Hodler _previous = Hodler(previous);\n            bool started = _previous.started();\n            require(started == true, \"HodlerFactory: previous hodler did not start\");\n        }\n        Hodler _hodler = new Hodler();\n        _hodler.initialize(asset, 10**21, 80, 120);\n        hodler[asset].push(address(_hodler));\n        allHodlers.push(address(_hodler));\n\t    Create(address(_hodler), asset);\n        return address(_hodler);\n    }\n}\n"}}}