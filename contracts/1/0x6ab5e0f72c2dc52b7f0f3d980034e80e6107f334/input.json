{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "v_46_main.sol": {
      "content": "pragma solidity 0.6.0;\r\n\r\ncontract INTERSMART {\r\n\r\n    address public owner = address(0);\r\n\r\n    uint128 public price = 0.10 ether;\r\n    uint128 public fee   = 0.02 ether;\r\n\r\n    uint128[] deposits = [\r\n        0.08 ether,\r\n        1.28 ether,\r\n        10.24 ether,\r\n        40.96 ether\r\n    ];\r\n\r\n    uint8 public refLimit = 8;\r\n\r\n    uint8[] public stageLimits = [7, 7, 8, 10];\r\n\r\n    struct User {\r\n        address partner;\r\n        address[] partners;\r\n        uint256 overflowIdx;\r\n        uint256 profit;\r\n        mapping (uint8 => uint256) ids;\r\n        mapping (uint8 => uint8) rounds;\r\n        mapping (uint8 => mapping (uint8 => uint8)) lastLine;\r\n    }\r\n\r\n    mapping (address => User) internal _users;\r\n\r\n    struct Stage {\r\n        uint32 _amountOfUsers;\r\n        mapping (uint256 => address) _userByid;\r\n    }\r\n\r\n    mapping (uint8 => Stage) internal _stages;\r\n\r\n    address payable internal _wallet;\r\n\r\n    uint32 internal _startDate;\r\n\r\n    event getIn(address indexed referral, address indexed partner, address indexed referrer, uint256 price);\r\n    event getOut(address indexed account, uint256 profit);\r\n    event withdrawn(address indexed account, uint256 amount);\r\n    event stageUp(address indexed account, uint256 stage);\r\n    event reinvest(address indexed account, uint256 stage);\r\n    event payOut(address indexed referrer, address indexed referral, uint256 stage, uint256 round, uint256 amount);\r\n    event qualification(address indexed referrer);\r\n\r\n    constructor(address payable walletAddr) public {\r\n        require(walletAddr != address(0));\r\n        require(!_isContract(walletAddr), 'walletAddr cannot be a smart-contract');\r\n\r\n        _wallet = walletAddr;\r\n        User storage user = _users[_wallet];\r\n\r\n        for (uint8 i = 0; i < 4; i++) {\r\n            user.rounds[i] = stageLimits[i];\r\n            _stages[i]._amountOfUsers++;\r\n            _users[_wallet].ids[i] = _stages[i]._amountOfUsers;\r\n            _stages[i]._userByid[_users[_wallet].ids[i]] = _wallet;\r\n        }\r\n\r\n        _startDate = uint32(block.timestamp);\r\n    }\r\n\r\n    fallback() external payable {\r\n        receiver();\r\n    }\r\n\r\n    receive() external payable {\r\n        receiver();\r\n    }\r\n\r\n    function receiver() internal {\r\n        if (msg.value == 0) {\r\n\r\n            withdraw();\r\n\r\n        } else if (msg.value >= price) {\r\n\r\n            if (msg.value > price) {\r\n                msg.sender.transfer(msg.value - price);\r\n            }\r\n\r\n            if (!isRegistered(msg.sender)) {\r\n                regUser(_bytesToAddress(bytes(msg.data)));\r\n            } else {\r\n                revert('User is registered already');\r\n            }\r\n\r\n        } else revert('Incorrect value');\r\n    }\r\n\r\n    function regUser(address referrerAddr) public payable {\r\n        require(!isRegistered(msg.sender), 'User is registered already');\r\n        require(isRegistered(referrerAddr), 'User must provide an active referrer address');\r\n        require(msg.value == price, 'Value must be equal to the price');\r\n\r\n        User storage user = _users[msg.sender];\r\n        address referrer = referrerAddr;\r\n\r\n        _wallet.transfer(fee);\r\n\r\n        _stages[0]._amountOfUsers++;\r\n\r\n        _users[referrer].partners.push(msg.sender);\r\n        if (getUserAmountOfPartners(referrer) == refLimit) {\r\n            emit qualification(referrer);\r\n        }\r\n\r\n        user.partner = referrer;\r\n\r\n        (uint256 newID, uint256 overflowIdx, address freeReferrer) = getFreeReferrer(referrer);\r\n        _users[referrer].overflowIdx = overflowIdx;\r\n\r\n        user.ids[0] = newID;\r\n        _stages[0]._userByid[user.ids[0]] = msg.sender;\r\n\r\n        emit getIn(msg.sender, user.partner, freeReferrer, price);\r\n\r\n        _processStructure(msg.sender, 0);\r\n\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint256 amount = getUserProfit(msg.sender);\r\n\r\n        require(amount > 0, 'User has no profit yet');\r\n        require(getUserAmountOfPartners(msg.sender) >= 2, 'User did not invite 2 referrals yet');\r\n\r\n        _users[msg.sender].profit = 0;\r\n        msg.sender.transfer(amount);\r\n\r\n        emit withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    function _processStructure(address account, uint8 stage) internal {\r\n\r\n        _users[account].rounds[stage]++;\r\n\r\n        emit stageUp(account, stage);\r\n\r\n        uint256 deposit = deposits[stage];\r\n        uint256 full = 64 / 2**(uint256(stage));\r\n        uint8 round = _users[account].rounds[stage];\r\n        uint256 stageUpIdx;\r\n        uint256 profit;\r\n        uint256 reinvestIdx;\r\n\r\n        if (round == 1) {\r\n            if (stage < 3) {\r\n                stageUpIdx = full / 4;\r\n                profit = deposit * (stageUpIdx - 1);\r\n            } else {\r\n                stageUpIdx = 0;\r\n                profit = deposit * 3;\r\n            }\r\n            reinvestIdx = stageUpIdx+1;\r\n        } else {\r\n            stageUpIdx = 0;\r\n            profit = deposit;\r\n            if (round < stageLimits[stage]) {\r\n                reinvestIdx = full / 4 + 1;\r\n            } else {\r\n                reinvestIdx = 0;\r\n            }\r\n        }\r\n\r\n        address rootAddr = getUserReferrer(account, stage, 4-stage);\r\n\r\n        if (rootAddr != address(0) && rootAddr != _wallet) {\r\n\r\n            _users[rootAddr].lastLine[stage][round]++;\r\n\r\n            if (_users[rootAddr].lastLine[stage][round] == stageUpIdx) {\r\n\r\n                _stages[stage+1]._amountOfUsers++;\r\n                _users[rootAddr].ids[stage+1] = _stages[stage+1]._amountOfUsers; \r\n                _stages[stage+1]._userByid[_stages[stage+1]._amountOfUsers] = rootAddr;\r\n                _processStructure(rootAddr, stage+1);\r\n\r\n            } else if (_users[rootAddr].lastLine[stage][round] == reinvestIdx) {\r\n\r\n                _processStructure(rootAddr, stage);\r\n\r\n            } else if (round == 1 && _users[rootAddr].lastLine[stage][round] == full/2) {\r\n\r\n                _users[rootAddr].profit += profit;\r\n                emit payOut(rootAddr, account, stage, round, profit);\r\n\r\n            } else if (round > 1) {\r\n\r\n                _users[rootAddr].profit += profit;\r\n                emit payOut(rootAddr, account, stage, round, profit);\r\n\r\n            }\r\n\r\n        } else {\r\n            _users[_wallet].profit += deposit;\r\n        }\r\n\r\n    }\r\n\r\n    function getFreeReferrer(address referrer) public view returns(uint256 newID, uint256 overflowIdx, address freeReferrer) {\r\n        require(isRegistered(referrer), \"User is not registered yet\");\r\n        if (getUserAmountOfReferrals(referrer, 0) < 2) {\r\n            return (_users[referrer].ids[0] * 2 + getUserAmountOfReferrals(referrer, 0), getUserAmountOfReferrals(referrer, 0) + 1, referrer);\r\n        }\r\n\r\n        overflowIdx = _users[referrer].overflowIdx;\r\n        uint256 startIdx = _users[referrer].ids[0] * 2;\r\n        uint256 addend = overflowIdx;\r\n        uint256 line = 1;\r\n        uint256 count;\r\n\r\n        while (true) {\r\n            if (addend > 0) {\r\n                if (addend >= 2**line) {\r\n                    addend -= 2**line;\r\n                    startIdx = startIdx * 2;\r\n                    line++;\r\n                } else {\r\n                    count += addend;\r\n                    addend = 0;\r\n                }\r\n            } else if (startIdx + count < startIdx + 2**line) {\r\n                if (_stages[0]._userByid[startIdx + count] == address(0)) {\r\n                    return (startIdx + count, overflowIdx + 1, _stages[0]._userByid[(startIdx + count) / 2]);\r\n                } else {\r\n                    overflowIdx++;\r\n                    count++;\r\n                }\r\n            } else {\r\n                startIdx = startIdx * 2;\r\n                count = 0;\r\n                line++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _bytesToAddress(bytes memory source) internal pure returns(address parsedReferrer) {\r\n        assembly {\r\n            parsedReferrer := mload(add(source,0x14))\r\n        }\r\n        return parsedReferrer;\r\n    }\r\n\r\n    function _isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function getContractBalance() public view returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getAmountOfUsers(uint8 stage) public view returns(uint256) {\r\n        return _stages[stage]._amountOfUsers;\r\n    }\r\n\r\n    function getDaysSinceStart() public view returns(uint256) {\r\n        if (_startDate > 0) {\r\n            return ((block.timestamp - _startDate) / (1 days));\r\n        }\r\n    }\r\n\r\n    function isRegistered(address account) public view returns(bool) {\r\n        return (_users[account].rounds[0] > 0);\r\n    }\r\n\r\n    function getUserId(address user, uint8 stage) public view returns(uint256) {\r\n        return _users[user].ids[stage];\r\n    }\r\n\r\n    function getUserById(uint8 stage, uint256 id) public view returns(address) {\r\n        return _stages[stage]._userByid[id];\r\n    }\r\n\r\n    function getUserReferrer(address account, uint8 stage, uint256 level) public view returns(address) {\r\n        return _stages[stage]._userByid[_users[account].ids[stage] / 2**(level+1)];\r\n    }\r\n\r\n    function getUserReferrers(address account, uint8 stage) public view returns(address[] memory) {\r\n        uint256 limit = 5 - stage;\r\n        address[] memory referrers = new address[](limit);\r\n        for (uint256 i = 0; i < limit; i++) {\r\n            referrers[i] = getUserReferrer(account, stage, i);\r\n        }\r\n        return referrers;\r\n    }\r\n\r\n    function getUserPartners(address account) public view returns(address[] memory) {\r\n        return _users[account].partners;\r\n    }\r\n\r\n    function getUserAmountOfPartners(address account) public view returns(uint256) {\r\n        return _users[account].partners.length;\r\n    }\r\n\r\n    function getUserReferrals(address account, uint8 stage) public view returns(address, address) {\r\n        return (_stages[stage]._userByid[_users[account].ids[stage] * 2], _stages[stage]._userByid[_users[account].ids[stage] * 2 + 1]);\r\n    }\r\n\r\n    function getUserAmountOfReferrals(address account, uint8 stage) public view returns(uint256) {\r\n        if (_stages[stage]._userByid[_users[account].ids[stage] * 2 + 1] != address(0)) {\r\n            return 2;\r\n        } else if (_stages[stage]._userByid[_users[account].ids[stage] * 2] != address(0)) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function getUserProfit(address account) public view returns(uint256) {\r\n        return _users[account].profit;\r\n    }\r\n\r\n    function getUserPoints(address account, uint8 stage, uint8 round) public view returns(uint256) {\r\n        return _users[account].lastLine[stage][round];\r\n    }\r\n\r\n    function getUserRounds(address account, uint8 stage) public view returns(uint256) {\r\n        return _users[account].rounds[stage];\r\n    }\r\n\r\n    function getUserLevel(address account) public view returns(uint256) {\r\n        uint8 i;\r\n\r\n        for (i = 1; i <= 3; i++) {\r\n            if (_users[account].rounds[i] == 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return i-1;\r\n    }\r\n\r\n    function getUserStages(address account) public view returns(uint256[] memory) {\r\n        uint256[] memory stages = new uint256[](4);\r\n\r\n        for (uint8 i = 0; i < 4; i++) {\r\n\r\n            stages[i] = getUserRounds(account, i);\r\n\r\n        }\r\n\r\n        return stages;\r\n    }\r\n\r\n    function getStructure(address account, uint8 stage, uint256 round) public view returns(address[] memory) {\r\n        require(stage < 4, \"Invalid stage value\");\r\n        require(round > 0 && round <= stageLimits[stage], \"Invalid round value\");\r\n\r\n        uint256 limit = 64 / 2**(uint256(stage)) - 1;\r\n\r\n        address[] memory referrals = new address[](limit);\r\n\r\n        if (_users[account].rounds[stage] < round) {\r\n            return referrals;\r\n        }\r\n\r\n        uint256 id = _users[account].ids[stage];\r\n\r\n        uint256 count;\r\n        uint256 line;\r\n\r\n        while (count < limit) {\r\n            for (uint256 i = 0; i < 2**line; i++) {\r\n                uint256 idx = id * 2**line + i;\r\n                if (_users[_stages[stage]._userByid[idx]].rounds[stage] >= round) {\r\n                    referrals[count] = _stages[stage]._userByid[idx];\r\n                }\r\n                count++;\r\n            }\r\n            line++;\r\n        }\r\n\r\n        return referrals;\r\n    }\r\n\r\n    function getInfo1() external view returns(uint256[] memory) {\r\n        uint256[] memory info = new uint256[](2);\r\n\r\n        info[0] = getAmountOfUsers(0);\r\n        info[1] = getDaysSinceStart();\r\n\r\n        return info;\r\n    }\r\n\r\n    function getInfo2(address account) external view returns(uint256[] memory) {\r\n        uint256[] memory info = new uint256[](2);\r\n\r\n        info[0] = getUserAmountOfPartners(account);\r\n        info[1] = getUserProfit(account);\r\n\r\n        return info;\r\n    }\r\n\r\n    function getInfo3(address account) external view returns(address[] memory, uint256[] memory) {\r\n        address[] memory partners = getUserPartners(account);\r\n        uint256[] memory stages = new uint256[](partners.length);\r\n\r\n        for (uint256 i = 0; i < partners.length; i++) {\r\n            stages[i] = getUserLevel(partners[i]);\r\n        }\r\n\r\n        return (partners, stages);\r\n    }\r\n\r\n    function getInfo4(address account) external view returns(uint256[] memory, uint256[] memory) {\r\n        uint256[] memory reinvests = getUserStages(account);\r\n        uint256[] memory progress = new uint256[](4);\r\n\r\n        for (uint8 i = 0; i < 4; i++) {\r\n            address[] memory referrals;\r\n            if (reinvests[i] > 0) {\r\n                referrals = getStructure(account, i, 1);\r\n            }\r\n            for (uint256 l = 0; l < referrals.length; l++) {\r\n                if (referrals[l] != address(0)) {\r\n                    progress[i]++;\r\n                }\r\n            }\r\n            progress[i] = progress[i] * 10000 / (64 / 2**(uint256(i)) - 1);\r\n        }\r\n\r\n        return (reinvests, progress);\r\n    }\r\n\r\n}\r\n"
    }
  }
}