{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "KRILL.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\n/*\r\n\r\n       .\r\n      \":\"\r\n    ___:____     |\"\\/\"|\r\n  ,'        `.    \\  /\r\n  |  O        \\___/  |\r\n~^~^~^~^~^~^~^~^~^~^~^~^~\r\n\r\nWhales Game | Generative Yield NFTs\r\nMint tokens and earn KRILL with this new blockchain based game! Battle it out to see who can generate the most yield.\r\n\r\nWebsite: https://whales.game/\r\n\r\n*/\r\n\r\ninterface MetadataInterface {\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\r\n\tfunction deploySetWhalesGame(WhalesGame _wg) external;\r\n}\r\n\r\ninterface Callable {\r\n\tfunction tokenCallback(address _from, uint256 _tokens, bytes calldata _data) external returns (bool);\r\n}\r\n\r\ninterface Receiver {\r\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\r\n}\r\n\r\ninterface Router {\r\n\tfunction WETH() external pure returns (address);\r\n\tfunction factory() external pure returns (address);\r\n}\r\n\r\ninterface Factory {\r\n\tfunction getPair(address, address) external view returns (address);\r\n\tfunction createPair(address, address) external returns (address);\r\n}\r\n\r\ninterface Pair {\r\n\tfunction token0() external view returns (address);\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction balanceOf(address) external view returns (uint256);\r\n\tfunction allowance(address, address) external view returns (uint256);\r\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\tfunction transfer(address, uint256) external returns (bool);\r\n\tfunction transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n\r\n\r\ncontract KRILL {\r\n\r\n\tuint256 constant private UINT_MAX = type(uint256).max;\r\n\tuint256 constant private TRANSFER_FEE = 1; // 1% per transfer\r\n\r\n\tstring constant public name = \"Krill Token\";\r\n\tstring constant public symbol = \"KRILL\";\r\n\tuint8 constant public decimals = 18;\r\n\r\n\tstruct User {\r\n\t\tuint256 balance;\r\n\t\tmapping(address => uint256) allowance;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalSupply;\r\n\t\tmapping(address => User) users;\r\n\t\tmapping(address => bool) toWhitelist;\r\n\t\tmapping(address => bool) fromWhitelist;\r\n\t\taddress owner;\r\n\t\tRouter router;\r\n\t\tPair pair;\r\n\t\tbool weth0;\r\n\t\tWhalesGame wg;\r\n\t\tStakingRewards stakingRewards;\r\n\t}\r\n\tInfo private info;\r\n\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 tokens);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 tokens);\r\n\tevent WhitelistUpdated(address indexed user, bool fromWhitelisted, bool toWhitelisted);\r\n\r\n\r\n\tmodifier _onlyOwner() {\r\n\t\trequire(msg.sender == owner());\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\tconstructor() {\r\n\t\tinfo.router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\t\tinfo.pair = Pair(Factory(info.router.factory()).createPair(info.router.WETH(), address(this)));\r\n\t\tinfo.weth0 = info.pair.token0() == info.router.WETH();\r\n\t\tinfo.owner = msg.sender;\r\n\t}\r\n\r\n\tfunction setOwner(address _owner) external _onlyOwner {\r\n\t\tinfo.owner = _owner;\r\n\t}\r\n\r\n\tfunction setWhitelisted(address _address, bool _fromWhitelisted, bool _toWhitelisted) external _onlyOwner {\r\n\t\tinfo.fromWhitelist[_address] = _fromWhitelisted;\r\n\t\tinfo.toWhitelist[_address] = _toWhitelisted;\r\n\t\temit WhitelistUpdated(_address, _fromWhitelisted, _toWhitelisted);\r\n\t}\r\n\r\n\tfunction deploySetWhalesGame(WhalesGame _wg) external {\r\n\t\trequire(tx.origin == owner() && stakingRewardsAddress() == address(0x0));\r\n\t\tinfo.wg = _wg;\r\n\t\tinfo.stakingRewards = new StakingRewards(info.wg, info.pair);\r\n\t\t_approve(address(this), stakingRewardsAddress(), UINT_MAX);\r\n\t}\r\n\r\n\r\n\tfunction mint(address _receiver, uint256 _tokens) external {\r\n\t\trequire(msg.sender == address(info.wg));\r\n\t\tinfo.totalSupply += _tokens;\r\n\t\tinfo.users[_receiver].balance += _tokens;\r\n\t\temit Transfer(address(0x0), _receiver, _tokens);\r\n\t}\r\n\r\n\tfunction burn(uint256 _tokens) external {\r\n\t\trequire(balanceOf(msg.sender) >= _tokens);\r\n\t\tinfo.totalSupply -= _tokens;\r\n\t\tinfo.users[msg.sender].balance -= _tokens;\r\n\t\temit Transfer(msg.sender, address(0x0), _tokens);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _tokens) external returns (bool) {\r\n\t\treturn _transfer(msg.sender, _to, _tokens);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _tokens) external returns (bool) {\r\n\t\treturn _approve(msg.sender, _spender, _tokens);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokens) external returns (bool) {\r\n\t\tuint256 _allowance = allowance(_from, msg.sender);\r\n\t\trequire(_allowance >= _tokens);\r\n\t\tif (_allowance != UINT_MAX) {\r\n\t\t\tinfo.users[_from].allowance[msg.sender] -= _tokens;\r\n\t\t}\r\n\t\treturn _transfer(_from, _to, _tokens);\r\n\t}\r\n\r\n\tfunction transferAndCall(address _to, uint256 _tokens, bytes calldata _data) external returns (bool) {\r\n\t\tuint256 _balanceBefore = balanceOf(_to);\r\n\t\t_transfer(msg.sender, _to, _tokens);\r\n\t\tuint256 _tokensReceived = balanceOf(_to) - _balanceBefore;\r\n\t\tuint32 _size;\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_to)\r\n\t\t}\r\n\t\tif (_size > 0) {\r\n\t\t\trequire(Callable(_to).tokenCallback(msg.sender, _tokensReceived, _data));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\tfunction whalesGameAddress() public view returns (address) {\r\n\t\treturn address(info.wg);\r\n\t}\r\n\r\n\tfunction pairAddress() external view returns (address) {\r\n\t\treturn address(info.pair);\r\n\t}\r\n\r\n\tfunction stakingRewardsAddress() public view returns (address) {\r\n\t\treturn address(info.stakingRewards);\r\n\t}\r\n\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn info.owner;\r\n\t}\r\n\r\n\tfunction isFromWhitelisted(address _address) public view returns (bool) {\r\n\t\treturn info.fromWhitelist[_address];\r\n\t}\r\n\r\n\tfunction isToWhitelisted(address _address) public view returns (bool) {\r\n\t\treturn info.toWhitelist[_address];\r\n\t}\r\n\t\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn info.totalSupply;\r\n\t}\r\n\r\n\tfunction balanceOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].balance;\r\n\t}\r\n\r\n\tfunction allowance(address _user, address _spender) public view returns (uint256) {\r\n\t\treturn info.users[_user].allowance[_spender];\r\n\t}\r\n\r\n\tfunction allInfoFor(address _user) external view returns (uint256 totalTokens, uint256 totalLPTokens, uint256 wethReserve, uint256 krillReserve, uint256 userAllowance, uint256 userBalance, uint256 userLPBalance) {\r\n\t\ttotalTokens = totalSupply();\r\n\t\ttotalLPTokens = info.pair.totalSupply();\r\n\t\t(uint256 _res0, uint256 _res1, ) = info.pair.getReserves();\r\n\t\twethReserve = info.weth0 ? _res0 : _res1;\r\n\t\tkrillReserve = info.weth0 ? _res1 : _res0;\r\n\t\tuserAllowance = allowance(_user, whalesGameAddress());\r\n\t\tuserBalance = balanceOf(_user);\r\n\t\tuserLPBalance = info.pair.balanceOf(_user);\r\n\t}\r\n\r\n\r\n\tfunction _approve(address _owner, address _spender, uint256 _tokens) internal returns (bool) {\r\n\t\tinfo.users[_owner].allowance[_spender] = _tokens;\r\n\t\temit Approval(_owner, _spender, _tokens);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction _transfer(address _from, address _to, uint256 _tokens) internal returns (bool) {\r\n\t\trequire(balanceOf(_from) >= _tokens);\r\n\t\tinfo.users[_from].balance -= _tokens;\r\n\t\tuint256 _fee = 0;\r\n\t\tif (!(_from == stakingRewardsAddress() || _to == stakingRewardsAddress() || _to == whalesGameAddress() || isFromWhitelisted(_from) || isToWhitelisted(_to))) {\r\n\t\t\t_fee = _tokens * TRANSFER_FEE / 100;\r\n\t\t\taddress _this = address(this);\r\n\t\t\tinfo.users[_this].balance += _fee;\r\n\t\t\temit Transfer(_from, _this, _fee);\r\n\t\t\tinfo.stakingRewards.disburse(balanceOf(_this));\r\n\t\t}\r\n\t\tinfo.users[_to].balance += _tokens - _fee;\r\n\t\temit Transfer(_from, _to, _tokens - _fee);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\ncontract StakingRewards {\r\n\r\n\tuint256 constant private FLOAT_SCALAR = 2**64;\r\n\r\n\tstruct User {\r\n\t\tuint256 deposited;\r\n\t\tint256 scaledPayout;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalDeposited;\r\n\t\tuint256 scaledRewardsPerToken;\r\n\t\tuint256 pendingRewards;\r\n\t\tmapping(address => User) users;\r\n\t\tWhalesGame wg;\r\n\t\tKRILL krill;\r\n\t\tPair pair;\r\n\t}\r\n\tInfo private info;\r\n\r\n\r\n\tevent Deposit(address indexed user, uint256 amount);\r\n\tevent Withdraw(address indexed user, uint256 amount);\r\n\tevent Claim(address indexed user, uint256 amount);\r\n\tevent Reward(uint256 amount);\r\n\r\n\r\n\tconstructor(WhalesGame _wg, Pair _pair) {\r\n\t\tinfo.wg = _wg;\r\n\t\tinfo.krill = KRILL(msg.sender);\r\n\t\tinfo.pair = _pair;\r\n\t}\r\n\r\n\tfunction disburse(uint256 _amount) external {\r\n\t\tif (_amount > 0) {\r\n\t\t\tinfo.krill.transferFrom(msg.sender, address(this), _amount);\r\n\t\t\t_disburse(_amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction deposit(uint256 _amount) external {\r\n\t\tdepositFor(_amount, msg.sender);\r\n\t}\r\n\r\n\tfunction depositFor(uint256 _amount, address _user) public {\r\n\t\trequire(_amount > 0);\r\n\t\t_update();\r\n\t\tinfo.pair.transferFrom(msg.sender, address(this), _amount);\r\n\t\tinfo.totalDeposited += _amount;\r\n\t\tinfo.users[_user].deposited += _amount;\r\n\t\tinfo.users[_user].scaledPayout += int256(_amount * info.scaledRewardsPerToken);\r\n\t\temit Deposit(_user, _amount);\r\n\t}\r\n\r\n\tfunction withdrawAll() external {\r\n\t\tuint256 _deposited = depositedOf(msg.sender);\r\n\t\tif (_deposited > 0) {\r\n\t\t\twithdraw(_deposited);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction withdraw(uint256 _amount) public {\r\n\t\trequire(_amount > 0 && _amount <= depositedOf(msg.sender));\r\n\t\t_update();\r\n\t\tinfo.totalDeposited -= _amount;\r\n\t\tinfo.users[msg.sender].deposited -= _amount;\r\n\t\tinfo.users[msg.sender].scaledPayout -= int256(_amount * info.scaledRewardsPerToken);\r\n\t\tinfo.pair.transfer(msg.sender, _amount);\r\n\t\temit Withdraw(msg.sender, _amount);\r\n\t}\r\n\r\n\tfunction claim() external {\r\n\t\t_update();\r\n\t\tuint256 _rewards = rewardsOf(msg.sender);\r\n\t\tif (_rewards > 0) {\r\n\t\t\tinfo.users[msg.sender].scaledPayout += int256(_rewards * FLOAT_SCALAR);\r\n\t\t\tinfo.krill.transfer(msg.sender, _rewards);\r\n\t\t\temit Claim(msg.sender, _rewards);\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfunction totalDeposited() public view returns (uint256) {\r\n\t\treturn info.totalDeposited;\r\n\t}\r\n\r\n\tfunction depositedOf(address _user) public view returns (uint256) {\r\n\t\treturn info.users[_user].deposited;\r\n\t}\r\n\t\r\n\tfunction rewardsOf(address _user) public view returns (uint256) {\r\n\t\treturn uint256(int256(info.scaledRewardsPerToken * depositedOf(_user)) - info.users[_user].scaledPayout) / FLOAT_SCALAR;\r\n\t}\r\n\r\n\tfunction allInfoFor(address _user) external view returns (uint256 totalLPDeposited, uint256 totalLPTokens, uint256 wethReserve, uint256 krillReserve, uint256 userBalance, uint256 userAllowance, uint256 userDeposited, uint256 userRewards) {\r\n\t\ttotalLPDeposited = totalDeposited();\r\n\t\t( , totalLPTokens, wethReserve, krillReserve, , , ) = info.krill.allInfoFor(address(this));\r\n\t\tuserBalance = info.pair.balanceOf(_user);\r\n\t\tuserAllowance = info.pair.allowance(_user, address(this));\r\n\t\tuserDeposited = depositedOf(_user);\r\n\t\tuserRewards = rewardsOf(_user);\r\n\t}\r\n\r\n\tfunction _update() internal {\r\n\t\taddress _this = address(this);\r\n\t\tuint256 _balanceBefore = info.krill.balanceOf(_this);\r\n\t\tinfo.wg.claim();\r\n\t\t_disburse(info.krill.balanceOf(_this) - _balanceBefore);\r\n\t}\r\n\r\n\tfunction _disburse(uint256 _amount) internal {\r\n\t\tif (_amount > 0) {\r\n\t\t\tif (totalDeposited() == 0) {\r\n\t\t\t\tinfo.pendingRewards += _amount;\r\n\t\t\t} else {\r\n\t\t\t\tinfo.scaledRewardsPerToken += (_amount + info.pendingRewards) * FLOAT_SCALAR / totalDeposited();\r\n\t\t\t\tinfo.pendingRewards = 0;\r\n\t\t\t}\r\n\t\t\temit Reward(_amount);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\ncontract WhalesGame {\r\n\r\n\tuint256 constant public ETH_MINTABLE_SUPPLY = 2000;\r\n\tuint256 constant public WHITELIST_ETH_MINTABLE_SUPPLY = 8000;\r\n\tuint256 constant public KRILL_MINTABLE_SUPPLY = 40000;\r\n\tuint256 constant public MAX_SUPPLY = ETH_MINTABLE_SUPPLY + WHITELIST_ETH_MINTABLE_SUPPLY + KRILL_MINTABLE_SUPPLY;\r\n\tuint256 constant public INITIAL_MINT_COST_ETH = 0.05 ether;\r\n\tuint256 constant public KRILL_PER_DAY_PER_FISHERMAN = 1e22; // 10,000\r\n\r\n\tuint256 constant private KRILL_COST_ADD = 1e4;\r\n\tuint256 constant private KRILL_COST_EXPONENT = 3;\r\n\tuint256 constant private KRILL_COST_SCALER = 2e10;\r\n\t// KRILL minted tokens = 0, minting cost = 20,000\r\n\t// KRILL minted tokens = 40k, minting cost = 2,500,000\r\n\r\n\tuint256 constant private FLOAT_SCALAR = 2**64;\r\n\tuint256 constant private WHALE_MODULUS = 10; // 1 in 10\r\n\tuint256 constant private WHALES_CUT = 20; // 20% of all yield\r\n\tuint256 constant private STAKING_CUT = 25; // 25% of minting costs\r\n\tuint256 constant private DEV_TOKENS = 50;\r\n\tuint256 constant private OPENING_DELAY = 2 hours;\r\n\tuint256 constant private WHITELIST_DURATION = 8 hours;\r\n\r\n\tstruct User {\r\n\t\tuint256 balance;\r\n\t\tmapping(uint256 => uint256) list;\r\n\t\tmapping(address => bool) approved;\r\n\t\tmapping(uint256 => uint256) indexOf;\r\n\t\tuint256 rewards;\r\n\t\tuint256 lastUpdated;\r\n\t\tuint256 krillPerDay;\r\n\t\tuint256 whales;\r\n\t\tint256 scaledPayout;\r\n\t}\r\n\r\n\tstruct Token {\r\n\t\taddress owner;\r\n\t\taddress approved;\r\n\t\tbytes32 seed;\r\n\t\tbool isWhale;\r\n\t}\r\n\r\n\tstruct Info {\r\n\t\tuint256 totalSupply;\r\n\t\tuint256 totalWhales;\r\n\t\tuint256 ethMintedTokens;\r\n\t\tuint256 krillMintedTokens;\r\n\t\tuint256 scaledRewardsPerWhale;\r\n\t\tuint256 openingTime;\r\n\t\tuint256 whitelistExpiry;\r\n\t\tmapping(uint256 => Token) list;\r\n\t\tmapping(address => User) users;\r\n\t\tmapping(uint256 => uint256) claimedBitMap;\r\n\t\tbytes32 merkleRoot;\r\n\t\tMetadataInterface metadata;\r\n\t\taddress owner;\r\n\t\tKRILL krill;\r\n\t\tStakingRewards stakingRewards;\r\n\t}\r\n\tInfo private info;\r\n\r\n\tmapping(bytes4 => bool) public supportsInterface;\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\tevent Mint(address indexed owner, uint256 indexed tokenId, bytes32 seed, bool isWhale);\r\n\tevent ClaimFishermenRewards(address indexed user, uint256 amount);\r\n\tevent ClaimWhaleRewards(address indexed user, uint256 amount);\r\n\tevent Reward(address indexed user, uint256 amount);\r\n\tevent WhalesReward(uint256 amount);\r\n\tevent StakingReward(uint256 amount);\r\n\r\n\r\n\tmodifier _onlyOwner() {\r\n\t\trequire(msg.sender == owner());\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\tconstructor(MetadataInterface _metadata, KRILL _krill, bytes32 _merkleRoot) {\r\n\t\tinfo.metadata = _metadata;\r\n\t\tinfo.metadata.deploySetWhalesGame(this);\r\n\t\tinfo.krill = _krill;\r\n\t\tinfo.krill.deploySetWhalesGame(this);\r\n\t\tinfo.stakingRewards = StakingRewards(info.krill.stakingRewardsAddress());\r\n\t\tinfo.krill.approve(stakingRewardsAddress(), type(uint256).max);\r\n\t\tinfo.merkleRoot = _merkleRoot;\r\n\t\tinfo.owner = 0x99A768bd14Ea62FaADA61F2c7f123303CDAa69fC;\r\n\t\tinfo.openingTime = block.timestamp + OPENING_DELAY;\r\n\t\tinfo.whitelistExpiry = block.timestamp + OPENING_DELAY + WHITELIST_DURATION;\r\n\r\n\t\tsupportsInterface[0x01ffc9a7] = true; // ERC-165\r\n\t\tsupportsInterface[0x80ac58cd] = true; // ERC-721\r\n\t\tsupportsInterface[0x5b5e139f] = true; // Metadata\r\n\t\tsupportsInterface[0x780e9d63] = true; // Enumerable\r\n\r\n\t\tfor (uint256 i = 0; i < DEV_TOKENS; i++) {\r\n\t\t\t_mint(0xa1450E7D547b4748fc94C8C98C9dB667eaD31cF8);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setOwner(address _owner) external _onlyOwner {\r\n\t\tinfo.owner = _owner;\r\n\t}\r\n\r\n\tfunction setMetadata(MetadataInterface _metadata) external _onlyOwner {\r\n\t\tinfo.metadata = _metadata;\r\n\t}\r\n\r\n\tfunction withdraw() external {\r\n\t\taddress _this = address(this);\r\n\t\trequire(_this.balance > 0);\r\n\t\tpayable(0xFaDED72464D6e76e37300B467673b36ECc4d2ccF).transfer(_this.balance / 2); // 50% total\r\n\t\tpayable(0x1cC79d49ce5b9519C912D810E39025DD27d1F033).transfer(_this.balance / 10); // 5% total\r\n\t\tpayable(0xa1450E7D547b4748fc94C8C98C9dB667eaD31cF8).transfer(_this.balance); // 45% total\r\n\t}\r\n\r\n\t\r\n\treceive() external payable {\r\n\t\tmintManyWithETH(msg.value / INITIAL_MINT_COST_ETH);\r\n\t}\r\n\t\r\n\tfunction mintWithETH() external payable {\r\n\t\tmintManyWithETH(1);\r\n\t}\r\n\r\n\tfunction mintManyWithETH(uint256 _tokens) public payable {\r\n\t\trequire(isOpen());\r\n\t\trequire(_tokens > 0);\r\n\t\tif (whitelistExpired()) {\r\n\t\t\trequire(totalSupply() - krillMintedTokens() + _tokens <= ETH_MINTABLE_SUPPLY + WHITELIST_ETH_MINTABLE_SUPPLY);\r\n\t\t} else {\r\n\t\t\trequire(ethMintedTokens() + _tokens <= ETH_MINTABLE_SUPPLY);\r\n\t\t}\r\n\t\tuint256 _cost = _tokens * INITIAL_MINT_COST_ETH;\r\n\t\trequire(msg.value >= _cost);\r\n\t\tinfo.ethMintedTokens += _tokens;\r\n\t\tfor (uint256 i = 0; i < _tokens; i++) {\r\n\t\t\t_mint(msg.sender);\r\n\t\t}\r\n\t\tif (msg.value > _cost) {\r\n\t\t\tpayable(msg.sender).transfer(msg.value - _cost);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mintWithProof(uint256 _index, address _account, bytes32[] calldata _merkleProof) external payable {\r\n\t\trequire(isOpen());\r\n\t\trequire(!whitelistExpired() && whitelistMintedTokens() < WHITELIST_ETH_MINTABLE_SUPPLY);\r\n\t\trequire(msg.value >= INITIAL_MINT_COST_ETH);\r\n\t\trequire(!proofClaimed(_index));\r\n\t\tbytes32 _node = keccak256(abi.encodePacked(_index, _account));\r\n\t\trequire(_verify(_merkleProof, _node));\r\n\t\tuint256 _claimedWordIndex = _index / 256;\r\n\t\tuint256 _claimedBitIndex = _index % 256;\r\n\t\tinfo.claimedBitMap[_claimedWordIndex] = info.claimedBitMap[_claimedWordIndex] | (1 << _claimedBitIndex);\r\n\t\t_mint(_account);\r\n\t\tif (msg.value > INITIAL_MINT_COST_ETH) {\r\n\t\t\tpayable(msg.sender).transfer(msg.value - INITIAL_MINT_COST_ETH);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mint() external {\r\n\t\tmintMany(1);\r\n\t}\r\n\r\n\tfunction mintMany(uint256 _tokens) public {\r\n\t\trequire(isOpen());\r\n\t\trequire(_tokens > 0 && krillMintedTokens() + _tokens <= KRILL_MINTABLE_SUPPLY);\r\n\t\tuint256 _cost = calculateKrillMintCost(_tokens);\r\n\t\tinfo.krill.transferFrom(msg.sender, address(this), _cost);\r\n\t\tuint256 _stakingReward = _cost * STAKING_CUT / 100;\r\n\t\tinfo.stakingRewards.disburse(_stakingReward);\r\n\t\temit StakingReward(_stakingReward);\r\n\t\tinfo.krill.burn(info.krill.balanceOf(address(this)));\r\n\t\tinfo.krillMintedTokens += _tokens;\r\n\t\tfor (uint256 i = 0; i < _tokens; i++) {\r\n\t\t\t_mint(msg.sender);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction claim() external {\r\n\t\tclaimFishermenRewards();\r\n\t\tclaimWhaleRewards();\r\n\t}\r\n\r\n\tfunction claimFishermenRewards() public {\r\n\t\t_update(msg.sender);\r\n\t\tuint256 _rewards = info.users[msg.sender].rewards;\r\n\t\tif (_rewards > 0) {\r\n\t\t\tinfo.users[msg.sender].rewards = 0;\r\n\t\t\tinfo.krill.mint(msg.sender, _rewards);\r\n\t\t\temit ClaimFishermenRewards(msg.sender, _rewards);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction claimWhaleRewards() public {\r\n\t\tuint256 _rewards = whaleRewardsOf(msg.sender);\r\n\t\tif (_rewards > 0) {\r\n\t\t\tinfo.users[msg.sender].scaledPayout += int256(_rewards * FLOAT_SCALAR);\r\n\t\t\tinfo.krill.mint(msg.sender, _rewards);\r\n\t\t\temit ClaimWhaleRewards(msg.sender, _rewards);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction approve(address _approved, uint256 _tokenId) external {\r\n\t\trequire(msg.sender == ownerOf(_tokenId));\r\n\t\tinfo.list[_tokenId].approved = _approved;\r\n\t\temit Approval(msg.sender, _approved, _tokenId);\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address _operator, bool _approved) external {\r\n\t\tinfo.users[msg.sender].approved[_operator] = _approved;\r\n\t\temit ApprovalForAll(msg.sender, _operator, _approved);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n\t\t_transfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public {\r\n\t\t_transfer(_from, _to, _tokenId);\r\n\t\tuint32 _size;\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_to)\r\n\t\t}\r\n\t\tif (_size > 0) {\r\n\t\t\trequire(Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == 0x150b7a02);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction name() external view returns (string memory) {\r\n\t\treturn info.metadata.name();\r\n\t}\r\n\r\n\tfunction symbol() external view returns (string memory) {\r\n\t\treturn info.metadata.symbol();\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n\t\treturn info.metadata.tokenURI(_tokenId);\r\n\t}\r\n\r\n\tfunction krillAddress() external view returns (address) {\r\n\t\treturn address(info.krill);\r\n\t}\r\n\r\n\tfunction pairAddress() external view returns (address) {\r\n\t\treturn info.krill.pairAddress();\r\n\t}\r\n\r\n\tfunction stakingRewardsAddress() public view returns (address) {\r\n\t\treturn address(info.stakingRewards);\r\n\t}\r\n\r\n\tfunction merkleRoot() public view returns (bytes32) {\r\n\t\treturn info.merkleRoot;\r\n\t}\r\n\r\n\tfunction openingTime() public view returns (uint256) {\r\n\t\treturn info.openingTime;\r\n\t}\r\n\r\n\tfunction isOpen() public view returns (bool) {\r\n\t\treturn block.timestamp > openingTime();\r\n\t}\r\n\r\n\tfunction whitelistExpiry() public view returns (uint256) {\r\n\t\treturn info.whitelistExpiry;\r\n\t}\r\n\r\n\tfunction whitelistExpired() public view returns (bool) {\r\n\t\treturn block.timestamp > whitelistExpiry();\r\n\t}\r\n\r\n\tfunction owner() public view returns (address) {\r\n\t\treturn info.owner;\r\n\t}\r\n\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn info.totalSupply;\r\n\t}\r\n\r\n\tfunction ethMintedTokens() public view returns (uint256) {\r\n\t\treturn info.ethMintedTokens;\r\n\t}\r\n\r\n\tfunction krillMintedTokens() public view returns (uint256) {\r\n\t\treturn info.krillMintedTokens;\r\n\t}\r\n\r\n\tfunction whitelistMintedTokens() public view returns (uint256) {\r\n\t\treturn totalSupply() - ethMintedTokens() - krillMintedTokens();\r\n\t}\r\n\r\n\tfunction totalWhales() public view returns (uint256) {\r\n\t\treturn info.totalWhales;\r\n\t}\r\n\r\n\tfunction totalFishermen() public view returns (uint256) {\r\n\t\treturn totalSupply() - totalWhales();\r\n\t}\r\n\r\n\tfunction totalKrillPerDay() external view returns (uint256) {\r\n\t\treturn totalFishermen() * KRILL_PER_DAY_PER_FISHERMAN;\r\n\t}\r\n\r\n\tfunction currentKrillMintCost() public view returns (uint256) {\r\n\t\treturn krillMintCost(krillMintedTokens());\r\n\t}\r\n\r\n\tfunction krillMintCost(uint256 _krillMintedTokens) public pure returns (uint256) {\r\n\t\treturn (_krillMintedTokens + KRILL_COST_ADD)**KRILL_COST_EXPONENT * KRILL_COST_SCALER;\r\n\t}\r\n\r\n\tfunction calculateKrillMintCost(uint256 _tokens) public view returns (uint256 cost) {\r\n\t\tcost = 0;\r\n\t\tfor (uint256 i = 0; i < _tokens; i++) {\r\n\t\t\tcost += krillMintCost(krillMintedTokens() + i);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction fishermenRewardsOf(address _owner) public view returns (uint256) {\r\n\t\tuint256 _pending = 0;\r\n\t\tuint256 _last = info.users[_owner].lastUpdated;\r\n\t\tif (_last < block.timestamp) {\r\n\t\t\tuint256 _diff = block.timestamp - _last;\r\n\t\t\t_pending += ownerKrillPerDay(_owner) * _diff * (100 - WHALES_CUT) / 8640000;\r\n\t\t}\r\n\t\treturn info.users[_owner].rewards + _pending;\r\n\t}\r\n\t\r\n\tfunction whaleRewardsOf(address _owner) public view returns (uint256) {\r\n\t\treturn uint256(int256(info.scaledRewardsPerWhale * whalesOf(_owner)) - info.users[_owner].scaledPayout) / FLOAT_SCALAR;\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public view returns (uint256) {\r\n\t\treturn info.users[_owner].balance;\r\n\t}\r\n\r\n\tfunction whalesOf(address _owner) public view returns (uint256) {\r\n\t\treturn info.users[_owner].whales;\r\n\t}\r\n\r\n\tfunction fishermenOf(address _owner) public view returns (uint256) {\r\n\t\treturn balanceOf(_owner) - whalesOf(_owner);\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 _tokenId) public view returns (address) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].owner;\r\n\t}\r\n\r\n\tfunction getApproved(uint256 _tokenId) public view returns (address) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].approved;\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n\t\treturn info.users[_owner].approved[_operator];\r\n\t}\r\n\r\n\tfunction getSeed(uint256 _tokenId) public view returns (bytes32) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].seed;\r\n\t}\r\n\r\n\tfunction getIsWhale(uint256 _tokenId) public view returns (bool) {\r\n\t\trequire(_tokenId < totalSupply());\r\n\t\treturn info.list[_tokenId].isWhale;\r\n\t}\r\n\r\n\tfunction tokenByIndex(uint256 _index) public view returns (uint256) {\r\n\t\trequire(_index < totalSupply());\r\n\t\treturn _index;\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n\t\trequire(_index < balanceOf(_owner));\r\n\t\treturn info.users[_owner].list[_index];\r\n\t}\r\n\r\n\tfunction ownerKrillPerDay(address _owner) public view returns (uint256 amount) {\r\n\t\treturn info.users[_owner].krillPerDay;\r\n\t}\r\n\r\n\tfunction proofClaimed(uint256 _index) public view returns (bool) {\r\n\t\tuint256 _claimedWordIndex = _index / 256;\r\n\t\tuint256 _claimedBitIndex = _index % 256;\r\n\t\tuint256 _claimedWord = info.claimedBitMap[_claimedWordIndex];\r\n\t\tuint256 _mask = (1 << _claimedBitIndex);\r\n\t\treturn _claimedWord & _mask == _mask;\r\n\t}\r\n\r\n\tfunction getToken(uint256 _tokenId) public view returns (address tokenOwner, address approved, bytes32 seed, bool isWhale) {\r\n\t\treturn (ownerOf(_tokenId), getApproved(_tokenId), getSeed(_tokenId), getIsWhale(_tokenId));\r\n\t}\r\n\r\n\tfunction getTokens(uint256[] memory _tokenIds) public view returns (address[] memory owners, address[] memory approveds, bytes32[] memory seeds, bool[] memory isWhales) {\r\n\t\tuint256 _length = _tokenIds.length;\r\n\t\towners = new address[](_length);\r\n\t\tapproveds = new address[](_length);\r\n\t\tseeds = new bytes32[](_length);\r\n\t\tisWhales = new bool[](_length);\r\n\t\tfor (uint256 i = 0; i < _length; i++) {\r\n\t\t\t(owners[i], approveds[i], seeds[i], isWhales[i]) = getToken(_tokenIds[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getTokensTable(uint256 _limit, uint256 _page, bool _isAsc) external view returns (uint256[] memory tokenIds, address[] memory owners, address[] memory approveds, bytes32[] memory seeds, bool[] memory isWhales, uint256 totalTokens, uint256 totalPages) {\r\n\t\trequire(_limit > 0);\r\n\t\ttotalTokens = totalSupply();\r\n\r\n\t\tif (totalTokens > 0) {\r\n\t\t\ttotalPages = (totalTokens / _limit) + (totalTokens % _limit == 0 ? 0 : 1);\r\n\t\t\trequire(_page < totalPages);\r\n\r\n\t\t\tuint256 _offset = _limit * _page;\r\n\t\t\tif (_page == totalPages - 1 && totalTokens % _limit != 0) {\r\n\t\t\t\t_limit = totalTokens % _limit;\r\n\t\t\t}\r\n\r\n\t\t\ttokenIds = new uint256[](_limit);\r\n\t\t\tfor (uint256 i = 0; i < _limit; i++) {\r\n\t\t\t\ttokenIds[i] = tokenByIndex(_isAsc ? _offset + i : totalTokens - _offset - i - 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttotalPages = 0;\r\n\t\t\ttokenIds = new uint256[](0);\r\n\t\t}\r\n\t\t(owners, approveds, seeds, isWhales) = getTokens(tokenIds);\r\n\t}\r\n\r\n\tfunction getOwnerTokensTable(address _owner, uint256 _limit, uint256 _page, bool _isAsc) external view returns (uint256[] memory tokenIds, address[] memory approveds, bytes32[] memory seeds, bool[] memory isWhales, uint256 totalTokens, uint256 totalPages) {\r\n\t\trequire(_limit > 0);\r\n\t\ttotalTokens = balanceOf(_owner);\r\n\r\n\t\tif (totalTokens > 0) {\r\n\t\t\ttotalPages = (totalTokens / _limit) + (totalTokens % _limit == 0 ? 0 : 1);\r\n\t\t\trequire(_page < totalPages);\r\n\r\n\t\t\tuint256 _offset = _limit * _page;\r\n\t\t\tif (_page == totalPages - 1 && totalTokens % _limit != 0) {\r\n\t\t\t\t_limit = totalTokens % _limit;\r\n\t\t\t}\r\n\r\n\t\t\ttokenIds = new uint256[](_limit);\r\n\t\t\tfor (uint256 i = 0; i < _limit; i++) {\r\n\t\t\t\ttokenIds[i] = tokenOfOwnerByIndex(_owner, _isAsc ? _offset + i : totalTokens - _offset - i - 1);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttotalPages = 0;\r\n\t\t\ttokenIds = new uint256[](0);\r\n\t\t}\r\n\t\t( , approveds, seeds, isWhales) = getTokens(tokenIds);\r\n\t}\r\n\r\n\tfunction allMintingInfo() external view returns (uint256 ethMinted, uint256 whitelistMinted, uint256 krillMinted, uint256 currentKrillCost, uint256 whitelistExpiryTime, bool hasWhitelistExpired, uint256 openTime, bool open) {\r\n\t\treturn (ethMintedTokens(), whitelistMintedTokens(), krillMintedTokens(), currentKrillMintCost(), whitelistExpiry(), whitelistExpired(), openingTime(), isOpen());\r\n\t}\r\n\r\n\tfunction allInfoFor(address _owner) external view returns (uint256 supply, uint256 whales, uint256 ownerBalance, uint256 ownerWhales, uint256 ownerFishermenRewards, uint256 ownerWhaleRewards, uint256 ownerDailyKrill) {\r\n\t\treturn (totalSupply(), totalWhales(), balanceOf(_owner), whalesOf(_owner), fishermenRewardsOf(_owner), whaleRewardsOf(_owner), ownerKrillPerDay(_owner));\r\n\t}\r\n\r\n\r\n\tfunction _mint(address _receiver) internal {\r\n\t\trequire(msg.sender == tx.origin);\r\n\t\trequire(totalSupply() < MAX_SUPPLY);\r\n\t\tuint256 _tokenId = info.totalSupply++;\r\n\t\tToken storage _newToken = info.list[_tokenId];\r\n\t\t_newToken.owner = _receiver;\r\n\t\tbytes32 _seed = keccak256(abi.encodePacked(_tokenId, _receiver, blockhash(block.number - 1), gasleft()));\r\n\t\t_newToken.seed = _seed;\r\n\t\t_newToken.isWhale = _tokenId < DEV_TOKENS || _tokenId % WHALE_MODULUS == 0;\r\n\r\n\t\tif (_newToken.isWhale) {\r\n\t\t\tinfo.totalWhales++;\r\n\t\t\tinfo.users[_receiver].whales++;\r\n\t\t\tinfo.users[_receiver].scaledPayout += int256(info.scaledRewardsPerWhale);\r\n\t\t} else {\r\n\t\t\t_update(_receiver);\r\n\t\t\tinfo.users[_receiver].krillPerDay += KRILL_PER_DAY_PER_FISHERMAN;\r\n\t\t}\r\n\t\tuint256 _index = info.users[_receiver].balance++;\r\n\t\tinfo.users[_receiver].indexOf[_tokenId] = _index + 1;\r\n\t\tinfo.users[_receiver].list[_index] = _tokenId;\r\n\t\temit Transfer(address(0x0), _receiver, _tokenId);\r\n\t\temit Mint(_receiver, _tokenId, _seed, _newToken.isWhale);\r\n\t}\r\n\t\r\n\tfunction _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n\t\taddress _owner = ownerOf(_tokenId);\r\n\t\taddress _approved = getApproved(_tokenId);\r\n\t\trequire(_from == _owner);\r\n\t\trequire(msg.sender == _owner || msg.sender == _approved || isApprovedForAll(_owner, msg.sender));\r\n\r\n\t\tinfo.list[_tokenId].owner = _to;\r\n\t\tif (_approved != address(0x0)) {\r\n\t\t\tinfo.list[_tokenId].approved = address(0x0);\r\n\t\t\temit Approval(address(0x0), address(0x0), _tokenId);\r\n\t\t}\r\n\r\n\t\tif (getIsWhale(_tokenId)) {\r\n\t\t\tinfo.users[_from].whales--;\r\n\t\t\tinfo.users[_from].scaledPayout -= int256(info.scaledRewardsPerWhale);\r\n\t\t\tinfo.users[_to].whales++;\r\n\t\t\tinfo.users[_to].scaledPayout += int256(info.scaledRewardsPerWhale);\r\n\t\t} else {\r\n\t\t\t_update(_from);\r\n\t\t\tinfo.users[_from].krillPerDay -= KRILL_PER_DAY_PER_FISHERMAN;\r\n\t\t\t_update(_to);\r\n\t\t\tinfo.users[_to].krillPerDay += KRILL_PER_DAY_PER_FISHERMAN;\r\n\t\t}\r\n\r\n\t\tuint256 _index = info.users[_from].indexOf[_tokenId] - 1;\r\n\t\tuint256 _moved = info.users[_from].list[info.users[_from].balance - 1];\r\n\t\tinfo.users[_from].list[_index] = _moved;\r\n\t\tinfo.users[_from].indexOf[_moved] = _index + 1;\r\n\t\tinfo.users[_from].balance--;\r\n\t\tdelete info.users[_from].indexOf[_tokenId];\r\n\t\tuint256 _newIndex = info.users[_to].balance++;\r\n\t\tinfo.users[_to].indexOf[_tokenId] = _newIndex + 1;\r\n\t\tinfo.users[_to].list[_newIndex] = _tokenId;\r\n\t\temit Transfer(_from, _to, _tokenId);\r\n\t}\r\n\r\n\tfunction _update(address _owner) internal {\r\n\t\tuint256 _last = info.users[_owner].lastUpdated;\r\n\t\tif (_last < block.timestamp) {\r\n\t\t\tuint256 _diff = block.timestamp - _last;\r\n\t\t\tuint256 _rewards = ownerKrillPerDay(_owner) * _diff / 86400;\r\n\t\t\tuint256 _whalesCut = _rewards * WHALES_CUT / 100;\r\n\t\t\tinfo.scaledRewardsPerWhale += _whalesCut * FLOAT_SCALAR / totalWhales();\r\n\t\t\temit WhalesReward(_whalesCut);\r\n\t\t\tinfo.users[_owner].lastUpdated = block.timestamp;\r\n\t\t\tinfo.users[_owner].rewards += _rewards - _whalesCut;\r\n\t\t\temit Reward(_owner, _rewards - _whalesCut);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction _verify(bytes32[] memory _proof, bytes32 _leaf) internal view returns (bool) {\r\n\t\trequire(_leaf != merkleRoot());\r\n\t\tbytes32 _computedHash = _leaf;\r\n\t\tfor (uint256 i = 0; i < _proof.length; i++) {\r\n\t\t\tbytes32 _proofElement = _proof[i];\r\n\t\t\tif (_computedHash <= _proofElement) {\r\n\t\t\t\t_computedHash = keccak256(abi.encodePacked(_computedHash, _proofElement));\r\n\t\t\t} else {\r\n\t\t\t\t_computedHash = keccak256(abi.encodePacked(_proofElement, _computedHash));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn _computedHash == merkleRoot();\r\n\t}\r\n}"
    }
  }
}