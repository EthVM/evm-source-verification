{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 75
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/FlatArb.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity =0.7.6;\r\npragma abicoder v2;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() internal {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\nabstract contract Proxy {\r\n  /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n  fallback() external payable {\r\n    _fallback();\r\n  }\r\n  \r\n  receive() external payable {}\r\n\r\n  /**\r\n   * @return The Address of the implementation.\r\n   */\r\n  function _implementation() internal view virtual returns (address);\r\n\r\n  /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) internal {\r\n    //solium-disable-next-line\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize())\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize())\r\n\r\n      switch result\r\n        // delegatecall returns 0 on error.\r\n        case 0 {\r\n          revert(0, returndatasize())\r\n        }\r\n        default {\r\n          return(0, returndatasize())\r\n        }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n  function _willFallback() internal virtual {}\r\n\r\n  /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      codehash := extcodehash(account)\r\n    }\r\n    return (codehash != accountHash && codehash != 0x0);\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(success, 'Address: unable to send value, recipient may have reverted');\r\n  }\r\n}\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 internal constant IMPLEMENTATION_SLOT =\r\n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n  /**\r\n   * @dev Returns the current implementation.\r\n   * @return impl Address of the current implementation\r\n   */\r\n  function _implementation() internal view override returns (address impl) {\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    //solium-disable-next-line\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _setImplementation(address newImplementation) internal {\r\n    require(\r\n      Address.isContract(newImplementation),\r\n      'Cannot set a proxy implementation to a non-contract address'\r\n    );\r\n\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n    //solium-disable-next-line\r\n    assembly {\r\n      sstore(slot, newImplementation)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title BaseImmutableAdminUpgradeabilityProxy\r\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\r\n * helps saving transactions costs\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  address immutable ADMIN;\r\n\r\n  constructor(address admin) public {\r\n    ADMIN = admin;\r\n  }\r\n\r\n  modifier ifAdmin() {\r\n    if (msg.sender == ADMIN) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n \r\n\r\n  /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n  function admin() external ifAdmin returns (address) {\r\n    return ADMIN;\r\n  }\r\n\r\n  /**\r\n   * @return The address of the implementation.\r\n   */\r\n  function implementation() external ifAdmin returns (address) {\r\n    return _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n    external\r\n    payable\r\n    ifAdmin\r\n  {\r\n    _upgradeTo(newImplementation);\r\n    (bool success, ) = newImplementation.delegatecall(data);\r\n    require(success);\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal virtual override {\r\n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');\r\n    super._willFallback();\r\n  }\r\n}\r\n\r\n/**\r\n * @title InitializableUpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\r\n * implementation and init data.\r\n */\r\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n  /**\r\n   * @dev Contract initializer.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  function initialize(address _logic, bytes memory _data) public payable {\r\n    require(_implementation() == address(0));\r\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\r\n    _setImplementation(_logic);\r\n    if (_data.length > 0) {\r\n      (bool success, ) = _logic.delegatecall(_data);\r\n      require(success);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\r\n */\r\ncontract InitializableImmutableAdminUpgradeabilityProxy is\r\n  BaseImmutableAdminUpgradeabilityProxy,\r\n  InitializableUpgradeabilityProxy\r\n{\r\n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {}\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {\r\n    BaseImmutableAdminUpgradeabilityProxy._willFallback();\r\n  }\r\n}\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n  event MarketIdSet(string newMarketId);\r\n  event LendingPoolUpdated(address indexed newAddress);\r\n  event ConfigurationAdminUpdated(address indexed newAddress);\r\n  event EmergencyAdminUpdated(address indexed newAddress);\r\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n  event PriceOracleUpdated(address indexed newAddress);\r\n  event LendingRateOracleUpdated(address indexed newAddress);\r\n  event ProxyCreated(bytes32 id, address indexed newAddress);\r\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  function setMarketId(string calldata marketId) external;\r\n\r\n  function setAddress(bytes32 id, address newAddress) external;\r\n\r\n  function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  function getLendingPool() external view returns (address);\r\n\r\n  function setLendingPoolImpl(address pool) external;\r\n\r\n  function getLendingPoolConfigurator() external view returns (address);\r\n\r\n  function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n  function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n  function setLendingPoolCollateralManager(address manager) external;\r\n\r\n  function getPoolAdmin() external view returns (address);\r\n\r\n  function setPoolAdmin(address admin) external;\r\n\r\n  function getEmergencyAdmin() external view returns (address);\r\n\r\n  function setEmergencyAdmin(address admin) external;\r\n\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  function setPriceOracle(address priceOracle) external;\r\n\r\n  function getLendingRateOracle() external view returns (address);\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider {\r\n  string private _marketId;\r\n  mapping(bytes32 => address) private _addresses;\r\n\r\n  bytes32 private constant LENDING_POOL = 'LENDING_POOL';\r\n  bytes32 private constant LENDING_POOL_CONFIGURATOR = 'LENDING_POOL_CONFIGURATOR';\r\n  bytes32 private constant POOL_ADMIN = 'POOL_ADMIN';\r\n  bytes32 private constant EMERGENCY_ADMIN = 'EMERGENCY_ADMIN';\r\n  bytes32 private constant LENDING_POOL_COLLATERAL_MANAGER = 'COLLATERAL_MANAGER';\r\n  bytes32 private constant PRICE_ORACLE = 'PRICE_ORACLE';\r\n  bytes32 private constant LENDING_RATE_ORACLE = 'LENDING_RATE_ORACLE';\r\n\r\n  constructor(string memory marketId) public {\r\n    _setMarketId(marketId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the id of the Aave market to which this contracts points to\r\n   * @return The market id\r\n   **/\r\n  function getMarketId() external view override returns (string memory) {\r\n    return _marketId;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows to set the market which this LendingPoolAddressesProvider represents\r\n   * @param marketId The market id\r\n   */\r\n  function setMarketId(string memory marketId) external override onlyOwner {\r\n    _setMarketId(marketId);\r\n  }\r\n\r\n  /**\r\n   * @dev General function to update the implementation of a proxy registered with\r\n   * certain `id`. If there is no proxy registered, it will instantiate one and\r\n   * set as implementation the `implementationAddress`\r\n   * IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n   * setter function, in order to avoid unexpected consequences\r\n   * @param id The id\r\n   * @param implementationAddress The address of the new implementation\r\n   */\r\n  function setAddressAsProxy(bytes32 id, address implementationAddress)\r\n    external\r\n    override\r\n    onlyOwner\r\n  {\r\n    _updateImpl(id, implementationAddress);\r\n    emit AddressSet(id, implementationAddress, true);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets an address for an id replacing the address saved in the addresses map\r\n   * IMPORTANT Use this function carefully, as it will do a hard replacement\r\n   * @param id The id\r\n   * @param newAddress The address to set\r\n   */\r\n  function setAddress(bytes32 id, address newAddress) external override onlyOwner {\r\n    _addresses[id] = newAddress;\r\n    emit AddressSet(id, newAddress, false);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an address by id\r\n   * @return The address\r\n   */\r\n  function getAddress(bytes32 id) public view override returns (address) {\r\n    return _addresses[id];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the LendingPool proxy\r\n   * @return The LendingPool proxy address\r\n   **/\r\n  function getLendingPool() external view override returns (address) {\r\n    return getAddress(LENDING_POOL);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the implementation of the LendingPool, or creates the proxy\r\n   * setting the new `pool` implementation on the first time calling it\r\n   * @param pool The new LendingPool implementation\r\n   **/\r\n  function setLendingPoolImpl(address pool) external override onlyOwner {\r\n    _updateImpl(LENDING_POOL, pool);\r\n    emit LendingPoolUpdated(pool);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the LendingPoolConfigurator proxy\r\n   * @return The LendingPoolConfigurator proxy address\r\n   **/\r\n  function getLendingPoolConfigurator() external view override returns (address) {\r\n    return getAddress(LENDING_POOL_CONFIGURATOR);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy\r\n   * setting the new `configurator` implementation on the first time calling it\r\n   * @param configurator The new LendingPoolConfigurator implementation\r\n   **/\r\n  function setLendingPoolConfiguratorImpl(address configurator) external override onlyOwner {\r\n    _updateImpl(LENDING_POOL_CONFIGURATOR, configurator);\r\n    emit LendingPoolConfiguratorUpdated(configurator);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used\r\n   * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\r\n   * the addresses are changed directly\r\n   * @return The address of the LendingPoolCollateralManager\r\n   **/\r\n\r\n  function getLendingPoolCollateralManager() external view override returns (address) {\r\n    return getAddress(LENDING_POOL_COLLATERAL_MANAGER);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the address of the LendingPoolCollateralManager\r\n   * @param manager The new LendingPoolCollateralManager address\r\n   **/\r\n  function setLendingPoolCollateralManager(address manager) external override onlyOwner {\r\n    _addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager;\r\n    emit LendingPoolCollateralManagerUpdated(manager);\r\n  }\r\n\r\n  /**\r\n   * @dev The functions below are getters/setters of addresses that are outside the context\r\n   * of the protocol hence the upgradable proxy pattern is not used\r\n   **/\r\n\r\n  function getPoolAdmin() external view override returns (address) {\r\n    return getAddress(POOL_ADMIN);\r\n  }\r\n\r\n  function setPoolAdmin(address admin) external override onlyOwner {\r\n    _addresses[POOL_ADMIN] = admin;\r\n    emit ConfigurationAdminUpdated(admin);\r\n  }\r\n\r\n  function getEmergencyAdmin() external view override returns (address) {\r\n    return getAddress(EMERGENCY_ADMIN);\r\n  }\r\n\r\n  function setEmergencyAdmin(address emergencyAdmin) external override onlyOwner {\r\n    _addresses[EMERGENCY_ADMIN] = emergencyAdmin;\r\n    emit EmergencyAdminUpdated(emergencyAdmin);\r\n  }\r\n\r\n  function getPriceOracle() external view override returns (address) {\r\n    return getAddress(PRICE_ORACLE);\r\n  }\r\n\r\n  function setPriceOracle(address priceOracle) external override onlyOwner {\r\n    _addresses[PRICE_ORACLE] = priceOracle;\r\n    emit PriceOracleUpdated(priceOracle);\r\n  }\r\n\r\n  function getLendingRateOracle() external view override returns (address) {\r\n    return getAddress(LENDING_RATE_ORACLE);\r\n  }\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external override onlyOwner {\r\n    _addresses[LENDING_RATE_ORACLE] = lendingRateOracle;\r\n    emit LendingRateOracleUpdated(lendingRateOracle);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to update the implementation of a specific proxied component of the protocol\r\n   * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\r\n   *   as implementation and calls the initialize() function on the proxy\r\n   * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\r\n   *   calls the initialize() function via upgradeToAndCall() in the proxy\r\n   * @param id The id of the proxy to be updated\r\n   * @param newAddress The address of the new implementation\r\n   **/\r\n  function _updateImpl(bytes32 id, address newAddress) internal {\r\n    address payable proxyAddress = payable(_addresses[id]);\r\n\r\n    InitializableImmutableAdminUpgradeabilityProxy proxy =\r\n      InitializableImmutableAdminUpgradeabilityProxy(proxyAddress);\r\n    bytes memory params = abi.encodeWithSignature('initialize(address)', address(this));\r\n\r\n    if (proxyAddress == address(0)) {\r\n      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));\r\n      proxy.initialize(newAddress, params);\r\n      _addresses[id] = address(proxy);\r\n      emit ProxyCreated(id, address(proxy));\r\n    } else {\r\n      proxy.upgradeToAndCall(newAddress, params);\r\n    }\r\n  }\r\n\r\n  function _setMarketId(string memory marketId) internal {\r\n    _marketId = marketId;\r\n    emit MarketIdSet(marketId);\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      'SafeERC20: approve from non-zero to non-zero allowance'\r\n    );\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = address(token).call(data);\r\n    require(success, 'SafeERC20: low-level call failed');\r\n\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      // solhint-disable-next-line max-line-length\r\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\r\n    }\r\n  }\r\n}\r\n\r\ninterface IScaledBalanceToken {\r\n  /**\r\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n   * @param user The user whose balance is calculated\r\n   * @return The scaled balance of the user\r\n   **/\r\n  function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled balance of the user and the scaled total supply.\r\n   * @param user The address of the user\r\n   * @return The scaled balance of the user\r\n   * @return The scaled balance and the scaled total supply\r\n   **/\r\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n   * @return The scaled total supply\r\n   **/\r\n  function scaledTotalSupply() external view returns (uint256);\r\n}\r\n\r\nlibrary DataTypes {\r\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    //tokens addresses\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint8 id;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: Reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60-63: reserved\r\n    //bit 64-79: reserve factor\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    uint256 data;\r\n  }\r\n\r\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n\r\ninterface ILendingPool {\r\n  /**\r\n   * @dev Emitted on deposit()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the deposit\r\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n   * @param amount The amount deposited\r\n   * @param referral The referral code used\r\n   **/\r\n  event Deposit(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on withdraw()\r\n   * @param reserve The address of the underlyng asset being withdrawn\r\n   * @param user The address initiating the withdrawal, owner of aTokens\r\n   * @param to Address that will receive the underlying\r\n   * @param amount The amount to be withdrawn\r\n   **/\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n   * @param reserve The address of the underlying asset being borrowed\r\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n   * initiator of the transaction on flashLoan()\r\n   * @param onBehalfOf The address that will be getting the debt\r\n   * @param amount The amount borrowed out\r\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n   * @param borrowRate The numeric rate at which the user has borrowed\r\n   * @param referral The referral code used\r\n   **/\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 borrowRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on repay()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The beneficiary of the repayment, getting his debt reduced\r\n   * @param repayer The address of the user initiating the repay(), providing the funds\r\n   * @param amount The amount repaid\r\n   **/\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on swapBorrowRateMode()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user swapping his rate mode\r\n   * @param rateMode The rate mode that the user wants to swap to\r\n   **/\r\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on rebalanceStableBorrowRate()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user for which the rebalance has been executed\r\n   **/\r\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on flashLoan()\r\n   * @param target The address of the flash loan receiver contract\r\n   * @param initiator The address initiating the flash loan\r\n   * @param asset The address of the asset being flash borrowed\r\n   * @param amount The amount flash borrowed\r\n   * @param premium The fee flash borrowed\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address indexed initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    uint256 premium,\r\n    uint16 referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the pause is triggered.\r\n   */\r\n  event Paused();\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted.\r\n   */\r\n  event Unpaused();\r\n\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n   * LendingPoolCollateral manager using a DELEGATECALL\r\n   * This allows to have the events in the generated ABI for LendingPool.\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n   * gets added to the LendingPool ABI\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param liquidityRate The new liquidity rate\r\n   * @param stableBorrowRate The new stable borrow rate\r\n   * @param variableBorrowRate The new variable borrow rate\r\n   * @param liquidityIndex The new liquidity index\r\n   * @param variableBorrowIndex The new variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param rateMode The rate mode that the user wants to swap to\r\n   **/\r\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n\r\n  /**\r\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n   * - Users can be rebalanced if the following conditions are satisfied:\r\n   *     1. Usage ratio is above 95%\r\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n   *        borrowed at a stable rate and depositors are not earning enough\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param user The address of the user to be rebalanced\r\n   **/\r\n  function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n  /**\r\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n   * @param asset The address of the underlying asset deposited\r\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n\r\n  /**\r\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n   * For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts amounts being flash-borrowed\r\n   * @param modes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata modes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralETH the total collateral in ETH of the user\r\n   * @return totalDebtETH the total debt in ETH of the user\r\n   * @return availableBorrowsETH the borrowing power left of the user\r\n   * @return currentLiquidationThreshold the liquidation threshold of the user\r\n   * @return ltv the loan to value of the user\r\n   * @return healthFactor the current health factor of the user\r\n   **/\r\n  function getUserAccountData(address user)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    );\r\n\r\n  function initReserve(\r\n    address reserve,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external;\r\n\r\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\r\n    external;\r\n\r\n  function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n  /**\r\n   * @dev Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(address asset)\r\n    external\r\n    view\r\n    returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(address user)\r\n    external\r\n    view\r\n    returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the normalized income normalized income of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state of the reserve\r\n   **/\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromAfter,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  function setPause(bool val) external;\r\n\r\n  function paused() external view returns (bool);\r\n}\r\n\r\ninterface IAaveIncentivesController {\r\n  event RewardsAccrued(address indexed user, uint256 amount);\r\n\r\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\r\n\r\n  event RewardsClaimed(\r\n    address indexed user,\r\n    address indexed to,\r\n    address indexed claimer,\r\n    uint256 amount\r\n  );\r\n\r\n  event ClaimerSet(address indexed user, address indexed claimer);\r\n\r\n  /*\r\n   * @dev Returns the configuration of the distribution for a certain asset\r\n   * @param asset The address of the reference asset of the distribution\r\n   * @return The asset index, the emission per second and the last updated timestamp\r\n   **/\r\n  function getAssetData(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  /**\r\n   * @dev Whitelists an address to claim the rewards on behalf of another address\r\n   * @param user The address of the user\r\n   * @param claimer The address of the claimer\r\n   */\r\n  function setClaimer(address user, address claimer) external;\r\n\r\n  /**\r\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\r\n   * @param user The address of the user\r\n   * @return The claimer address\r\n   */\r\n  function getClaimer(address user) external view returns (address);\r\n\r\n  /**\r\n   * @dev Configure assets for a certain rewards emission\r\n   * @param assets The assets to incentivize\r\n   * @param emissionsPerSecond The emission for each asset\r\n   */\r\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\r\n    external;\r\n\r\n  /**\r\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\r\n   * @param asset The address of the user\r\n   * @param userBalance The balance of the user of the asset in the lending pool\r\n   * @param totalSupply The total supply of the asset in the lending pool\r\n   **/\r\n  function handleAction(\r\n    address asset,\r\n    uint256 userBalance,\r\n    uint256 totalSupply\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n   * @param user The address of the user\r\n   * @return The rewards\r\n   **/\r\n  function getRewardsBalance(address[] calldata assets, address user)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n   * @param amount Amount of rewards to claim\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewards(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n   * @param amount Amount of rewards to claim\r\n   * @param user Address to check and claim rewards\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewardsOnBehalf(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address user,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @return the unclaimed user rewards\r\n   */\r\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @param asset The asset to incentivize\r\n   * @return the user index for the asset\r\n   */\r\n  function getUserAssetData(address user, address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev for backward compatibility with previous implementation of the Incentives controller\r\n   */\r\n  function REWARD_TOKEN() external view returns (address);\r\n\r\n  /**\r\n   * @dev for backward compatibility with previous implementation of the Incentives controller\r\n   */\r\n  function PRECISION() external view returns (uint8);\r\n\r\n  /**\r\n   * @dev Gets the distribution end timestamp of the emissions\r\n   */\r\n  function DISTRIBUTION_END() external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title IInitializableAToken\r\n * @notice Interface for the initialize function on AToken\r\n * @author Aave\r\n **/\r\ninterface IInitializableAToken {\r\n  /**\r\n   * @dev Emitted when an aToken is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param treasury The address of the treasury\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param aTokenDecimals the decimals of the underlying\r\n   * @param aTokenName the name of the aToken\r\n   * @param aTokenSymbol the symbol of the aToken\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address treasury,\r\n    address incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string aTokenName,\r\n    string aTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the aToken\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n   * @param aTokenName The name of the aToken\r\n   * @param aTokenSymbol The symbol of the aToken\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address treasury,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string calldata aTokenName,\r\n    string calldata aTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param value The amount being\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints `amount` aTokens to `user`\r\n   * @param user The address receiving the minted tokens\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   * @return `true` if the the previous balance of the user was 0\r\n   */\r\n  function mint(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted after aTokens are burned\r\n   * @param from The owner of the aTokens, getting them burned\r\n   * @param target The address that will receive the underlying\r\n   * @param value The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Emitted during the transfer action\r\n   * @param from The user whose tokens are being transferred\r\n   * @param to The recipient\r\n   * @param value The amount being transferred\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n   * @param user The owner of the aTokens, getting them burned\r\n   * @param receiverOfUnderlying The address that will receive the underlying\r\n   * @param amount The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    address receiverOfUnderlying,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Mints aTokens to the reserve treasury\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   */\r\n  function mintToTreasury(uint256 amount, uint256 index) external;\r\n\r\n  /**\r\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n   * @param from The address getting liquidated, current owner of the aTokens\r\n   * @param to The recipient\r\n   * @param value The amount of tokens getting transferred\r\n   **/\r\n  function transferOnLiquidation(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n   * assets in borrow(), withdraw() and flashLoan()\r\n   * @param user The recipient of the underlying\r\n   * @param amount The amount getting transferred\r\n   * @return The amount transferred\r\n   **/\r\n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Invoked to execute actions on the aToken side after a repayment.\r\n   * @param user The user executing the repayment\r\n   * @param amount The amount getting repaid\r\n   **/\r\n  function handleRepayment(address user, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (IAaveIncentivesController);\r\n\r\n  /**\r\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   **/\r\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n}\r\n\r\n/**\r\n * @title IInitializableDebtToken\r\n * @notice Interface for the initialize function common between debt tokens\r\n * @author Aave\r\n **/\r\ninterface IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted when a debt token is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param debtTokenDecimals the decimals of the debt token\r\n   * @param debtTokenName the name of the debt token\r\n   * @param debtTokenSymbol the symbol of the debt token\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string debtTokenName,\r\n    string debtTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the debt token.\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\r\n   * @param debtTokenName The name of the token\r\n   * @param debtTokenSymbol The symbol of the token\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address underlyingAsset,\r\n    IAaveIncentivesController incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string memory debtTokenName,\r\n    string memory debtTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n\r\n/**\r\n * @title IVariableDebtToken\r\n * @author Aave\r\n * @notice Defines the basic interface for a variable debt token.\r\n **/\r\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\r\n   * @param value The amount to be minted\r\n   * @param index The last index of the reserve\r\n   **/\r\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt being minted\r\n   * @param index The variable debt index of the reserve\r\n   * @return `true` if the the previous balance of the user is 0\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when variable debt is burnt\r\n   * @param user The user which debt has been burned\r\n   * @param amount The amount of debt being burned\r\n   * @param index The index of the user\r\n   **/\r\n  event Burn(address indexed user, uint256 amount, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns user variable debt\r\n   * @param user The user which debt is burnt\r\n   * @param index The variable debt index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (IAaveIncentivesController);\r\n}\r\n\r\n/**\r\n * @title IFlashLoanReceiver interface\r\n * @notice Interface for the Aave fee IFlashLoanReceiver.\r\n * @author Aave\r\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n **/\r\ninterface IFlashLoanReceiver {\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external returns (bool);\r\n\r\n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  function LENDING_POOL() external view returns (ILendingPool);\r\n}\r\n\r\n/**\r\n * @title IPriceOracleGetter interface\r\n * @notice Interface for the Aave price oracle.\r\n **/\r\n\r\ninterface IPriceOracleGetter {\r\n  /**\r\n   * @dev returns the asset price in ETH\r\n   * @param asset the address of the asset\r\n   * @return the ETH price of the asset\r\n   **/\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title IStableDebtToken\r\n * @notice Defines the interface for the stable debt token\r\n * @dev It does not inherit from IERC20 to save in code size\r\n * @author Aave\r\n **/\r\ninterface IStableDebtToken is IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted when new stable debt is minted\r\n   * @param user The address of the user who triggered the minting\r\n   * @param onBehalfOf The recipient of stable debt tokens\r\n   * @param amount The amount minted\r\n   * @param currentBalance The current balance of the user\r\n   * @param balanceIncrease The increase in balance since the last action of the user\r\n   * @param newRate The rate of the debt after the minting\r\n   * @param avgStableRate The new average stable rate after the minting\r\n   * @param newTotalSupply The new total supply of the stable debt token after the action\r\n   **/\r\n  event Mint(\r\n    address indexed user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 currentBalance,\r\n    uint256 balanceIncrease,\r\n    uint256 newRate,\r\n    uint256 avgStableRate,\r\n    uint256 newTotalSupply\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when new stable debt is burned\r\n   * @param user The address of the user\r\n   * @param amount The amount being burned\r\n   * @param currentBalance The current balance of the user\r\n   * @param balanceIncrease The the increase in balance since the last action of the user\r\n   * @param avgStableRate The new average stable rate after the burning\r\n   * @param newTotalSupply The new total supply of the stable debt token after the action\r\n   **/\r\n  event Burn(\r\n    address indexed user,\r\n    uint256 amount,\r\n    uint256 currentBalance,\r\n    uint256 balanceIncrease,\r\n    uint256 avgStableRate,\r\n    uint256 newTotalSupply\r\n  );\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address.\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt tokens to mint\r\n   * @param rate The rate of the debt being minted\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 rate\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Burns debt of `user`\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address of the user getting his debt burned\r\n   * @param amount The amount of debt tokens getting burned\r\n   **/\r\n  function burn(address user, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Returns the average rate of all the stable rate loans.\r\n   * @return The average stable rate\r\n   **/\r\n  function getAverageStableRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the stable rate of the user debt\r\n   * @return The stable rate of the user\r\n   **/\r\n  function getUserStableRate(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last update of the user\r\n   * @return The timestamp\r\n   **/\r\n  function getUserLastUpdated(address user) external view returns (uint40);\r\n\r\n  /**\r\n   * @dev Returns the principal, the total supply and the average stable rate\r\n   **/\r\n  function getSupplyData()\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint40\r\n    );\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last update of the total supply\r\n   * @return The timestamp\r\n   **/\r\n  function getTotalSupplyLastUpdated() external view returns (uint40);\r\n\r\n  /**\r\n   * @dev Returns the total supply and the average stable rate\r\n   **/\r\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the principal debt balance of the user\r\n   * @return The debt balance of the user since the last burn/mint action\r\n   **/\r\n  function principalBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (IAaveIncentivesController);\r\n}\r\n\r\n/**\r\n * @title VersionedInitializable\r\n *\r\n * @dev Helper contract to implement initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n *\r\n * @author Aave, inspired by the OpenZeppelin Initializable contract\r\n */\r\nabstract contract VersionedInitializable {\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  uint256 private lastInitializedRevision = 0;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    uint256 revision = getRevision();\r\n    require(\r\n      initializing || isConstructor() || revision > lastInitializedRevision,\r\n      'Contract instance has already been initialized'\r\n    );\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      lastInitializedRevision = revision;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev returns the revision number of the contract\r\n   * Needs to be defined in the inherited class as a constant.\r\n   **/\r\n  function getRevision() internal pure virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns true if and only if the function is running in the constructor\r\n   **/\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    //solium-disable-next-line\r\n    assembly {\r\n      cs := extcodesize(address())\r\n    }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n * @title Helpers library\r\n * @author Aave\r\n */\r\nlibrary Helpers {\r\n  /**\r\n   * @dev Fetches the user current stable and variable debt balances\r\n   * @param user The user address\r\n   * @param reserve The reserve data object\r\n   * @return The stable and variable debt balance\r\n   **/\r\n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve)\r\n    internal\r\n    view\r\n    returns (uint256, uint256)\r\n  {\r\n    return (\r\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\r\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\r\n    );\r\n  }\r\n\r\n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve)\r\n    internal\r\n    view\r\n    returns (uint256, uint256)\r\n  {\r\n    return (\r\n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user),\r\n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user)\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @title Errors library\r\n * @author Aave\r\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\r\n * @dev Error messages prefix glossary:\r\n *  - VL = ValidationLogic\r\n *  - MATH = Math libraries\r\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\r\n *  - AT = AToken\r\n *  - SDT = StableDebtToken\r\n *  - VDT = VariableDebtToken\r\n *  - LP = LendingPool\r\n *  - LPAPR = LendingPoolAddressesProviderRegistry\r\n *  - LPC = LendingPoolConfiguration\r\n *  - RL = ReserveLogic\r\n *  - LPCM = LendingPoolCollateralManager\r\n *  - P = Pausable\r\n */\r\nlibrary Errors {\r\n  //common errors\r\n  string public constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin'\r\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\r\n\r\n  //contract specific errors\r\n  string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\r\n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\r\n  string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\r\n  string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity is not enough'\r\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more than the available balance'\r\n  string public constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.'\r\n  string public constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled'\r\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode selected'\r\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0'\r\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor is lesser than the liquidation threshold'\r\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collateral to cover a new borrow'\r\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\r\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\r\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount is greater than the max loan size in stable rate mode\r\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\r\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of an user an explicit amount to repay is needed'\r\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable rate loan in progress on this reserve'\r\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variable rate loan in progress on this reserve'\r\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance needs to be greater than 0'\r\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as collateral'\r\n  string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stable rate loan for this reserve'\r\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate rebalance conditions were not met'\r\n  string public constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed'\r\n  string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity available to borrow'\r\n  string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small for a FlashLoan.'\r\n  string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of the protocol is inconsistent'\r\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the function is not the lending pool configurator'\r\n  string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';\r\n  string public constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must be a lending pool'\r\n  string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance to himself'\r\n  string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be greater than zero'\r\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initialized'\r\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve needs to be 0'\r\n  string public constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserve'\r\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency admin'\r\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered'\r\n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not below the threshold'\r\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen cannot be liquidated'\r\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow the specified currency'\r\n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \"There isn't enough liquidity available to liquidate\"\r\n  string public constant LPCM_NO_ERRORS = '46'; // 'No errors'\r\n  string public constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected\r\n  string public constant MATH_MULTIPLICATION_OVERFLOW = '48';\r\n  string public constant MATH_ADDITION_OVERFLOW = '49';\r\n  string public constant MATH_DIVISION_BY_ZERO = '50';\r\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\r\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\r\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\r\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\r\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\r\n  string public constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\r\n  string public constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';\r\n  string public constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\r\n  string public constant LP_FAILED_COLLATERAL_SWAP = '60';\r\n  string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';\r\n  string public constant LP_REENTRANCY_NOT_ALLOWED = '62';\r\n  string public constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';\r\n  string public constant LP_IS_PAUSED = '64'; // 'Pool is paused'\r\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '65';\r\n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\r\n  string public constant RC_INVALID_LTV = '67';\r\n  string public constant RC_INVALID_LIQ_THRESHOLD = '68';\r\n  string public constant RC_INVALID_LIQ_BONUS = '69';\r\n  string public constant RC_INVALID_DECIMALS = '70';\r\n  string public constant RC_INVALID_RESERVE_FACTOR = '71';\r\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\r\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\r\n  string public constant LP_INCONSISTENT_PARAMS_LENGTH = '74';\r\n  string public constant UL_INVALID_INDEX = '77';\r\n  string public constant LP_NOT_CONTRACT = '78';\r\n  string public constant SDT_STABLE_DEBT_OVERFLOW = '79';\r\n  string public constant SDT_BURN_EXCEEDS_BALANCE = '80';\r\n\r\n  enum CollateralManagerErrors {\r\n    NO_ERROR,\r\n    NO_COLLATERAL_AVAILABLE,\r\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\r\n    CURRRENCY_NOT_BORROWED,\r\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\r\n    NOT_ENOUGH_LIQUIDITY,\r\n    NO_ACTIVE_RESERVE,\r\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\r\n    INVALID_EQUAL_ASSETS_TO_SWAP,\r\n    FROZEN_RESERVE\r\n  }\r\n}\r\n\r\n/**\r\n * @title WadRayMath library\r\n * @author Aave\r\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n **/\r\nlibrary WadRayMath {\r\n  uint256 internal constant WAD = 1e18;\r\n  uint256 internal constant halfWAD = WAD / 2;\r\n\r\n  uint256 internal constant RAY = 1e27;\r\n  uint256 internal constant halfRAY = RAY / 2;\r\n\r\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n  /**\r\n   * @return One ray, 1e27\r\n   **/\r\n  function ray() internal pure returns (uint256) {\r\n    return RAY;\r\n  }\r\n\r\n  /**\r\n   * @return One wad, 1e18\r\n   **/\r\n\r\n  function wad() internal pure returns (uint256) {\r\n    return WAD;\r\n  }\r\n\r\n  /**\r\n   * @return Half ray, 1e27/2\r\n   **/\r\n  function halfRay() internal pure returns (uint256) {\r\n    return halfRAY;\r\n  }\r\n\r\n  /**\r\n   * @return Half ray, 1e18/2\r\n   **/\r\n  function halfWad() internal pure returns (uint256) {\r\n    return halfWAD;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two wad, rounding half up to the nearest wad\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return The result of a*b, in wad\r\n   **/\r\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * b + halfWAD) / WAD;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two wad, rounding half up to the nearest wad\r\n   * @param a Wad\r\n   * @param b Wad\r\n   * @return The result of a/b, in wad\r\n   **/\r\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\r\n    uint256 halfB = b / 2;\r\n\r\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * WAD + halfB) / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Multiplies two ray, rounding half up to the nearest ray\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return The result of a*b, in ray\r\n   **/\r\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0 || b == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * b + halfRAY) / RAY;\r\n  }\r\n\r\n  /**\r\n   * @dev Divides two ray, rounding half up to the nearest ray\r\n   * @param a Ray\r\n   * @param b Ray\r\n   * @return The result of a/b, in ray\r\n   **/\r\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\r\n    uint256 halfB = b / 2;\r\n\r\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n\r\n    return (a * RAY + halfB) / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Casts ray down to wad\r\n   * @param a Ray\r\n   * @return a casted to wad, rounded half up to the nearest wad\r\n   **/\r\n  function rayToWad(uint256 a) internal pure returns (uint256) {\r\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n    uint256 result = halfRatio + a;\r\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\r\n\r\n    return result / WAD_RAY_RATIO;\r\n  }\r\n\r\n  /**\r\n   * @dev Converts wad up to ray\r\n   * @param a Wad\r\n   * @return a converted in ray\r\n   **/\r\n  function wadToRay(uint256 a) internal pure returns (uint256) {\r\n    uint256 result = a * WAD_RAY_RATIO;\r\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * @title PercentageMath library\r\n * @author Aave\r\n * @notice Provides functions to perform percentage calculations\r\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\r\n * @dev Operations are rounded half up\r\n **/\r\nlibrary PercentageMath {\r\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\r\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\r\n\r\n  /**\r\n   * @dev Executes a percentage multiplication\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return The percentage of value\r\n   **/\r\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\r\n    if (value == 0 || percentage == 0) {\r\n      return 0;\r\n    }\r\n\r\n    require(\r\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\r\n      Errors.MATH_MULTIPLICATION_OVERFLOW\r\n    );\r\n\r\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\r\n  }\r\n\r\n  /**\r\n   * @dev Executes a percentage division\r\n   * @param value The value of which the percentage needs to be calculated\r\n   * @param percentage The percentage of the value to be calculated\r\n   * @return The value divided the percentage\r\n   **/\r\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\r\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\r\n    uint256 halfPercentage = percentage / 2;\r\n\r\n    require(\r\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\r\n      Errors.MATH_MULTIPLICATION_OVERFLOW\r\n    );\r\n\r\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\r\n  }\r\n}\r\n\r\n/**\r\n * @title IReserveInterestRateStrategyInterface interface\r\n * @dev Interface for the calculation of the interest rates\r\n * @author Aave\r\n */\r\ninterface IReserveInterestRateStrategy {\r\n  function baseVariableBorrowRate() external view returns (uint256);\r\n\r\n  function getMaxVariableBorrowRate() external view returns (uint256);\r\n\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    uint256 availableLiquidity,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    address aToken,\r\n    uint256 liquidityAdded,\r\n    uint256 liquidityTaken,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 liquidityRate,\r\n      uint256 stableBorrowRate,\r\n      uint256 variableBorrowRate\r\n    );\r\n}\r\n\r\n/**\r\n * @title ReserveConfiguration library\r\n * @author Aave\r\n * @notice Implements the bitmap logic to handle the reserve configuration\r\n */\r\nlibrary ReserveConfiguration {\r\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\r\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\r\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\r\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\r\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\r\n\r\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\r\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\r\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\r\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\r\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\r\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\r\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\r\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\r\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\r\n\r\n  uint256 constant MAX_VALID_LTV = 65535;\r\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\r\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\r\n  uint256 constant MAX_VALID_DECIMALS = 255;\r\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\r\n\r\n  /**\r\n   * @dev Sets the Loan to Value of the reserve\r\n   * @param self The reserve configuration\r\n   * @param ltv the new ltv\r\n   **/\r\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\r\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\r\n\r\n    self.data = (self.data & LTV_MASK) | ltv;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the Loan to Value of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The loan to value\r\n   **/\r\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\r\n    return self.data & ~LTV_MASK;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the liquidation threshold of the reserve\r\n   * @param self The reserve configuration\r\n   * @param threshold The new liquidation threshold\r\n   **/\r\n  function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold)\r\n    internal\r\n    pure\r\n  {\r\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\r\n\r\n    self.data =\r\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\r\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the liquidation threshold of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The liquidation threshold\r\n   **/\r\n  function getLiquidationThreshold(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the liquidation bonus of the reserve\r\n   * @param self The reserve configuration\r\n   * @param bonus The new liquidation bonus\r\n   **/\r\n  function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus)\r\n    internal\r\n    pure\r\n  {\r\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\r\n\r\n    self.data =\r\n      (self.data & LIQUIDATION_BONUS_MASK) |\r\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the liquidation bonus of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The liquidation bonus\r\n   **/\r\n  function getLiquidationBonus(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the decimals of the underlying asset of the reserve\r\n   * @param self The reserve configuration\r\n   * @param decimals The decimals\r\n   **/\r\n  function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals)\r\n    internal\r\n    pure\r\n  {\r\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\r\n\r\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the decimals of the underlying asset of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The decimals of the asset\r\n   **/\r\n  function getDecimals(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the active state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param active The active state\r\n   **/\r\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\r\n    self.data =\r\n      (self.data & ACTIVE_MASK) |\r\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the active state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The active state\r\n   **/\r\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\r\n    return (self.data & ~ACTIVE_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the frozen state of the reserve\r\n   * @param self The reserve configuration\r\n   * @param frozen The frozen state\r\n   **/\r\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\r\n    self.data =\r\n      (self.data & FROZEN_MASK) |\r\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the frozen state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The frozen state\r\n   **/\r\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\r\n    return (self.data & ~FROZEN_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables borrowing on the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\r\n   **/\r\n  function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled)\r\n    internal\r\n    pure\r\n  {\r\n    self.data =\r\n      (self.data & BORROWING_MASK) |\r\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the borrowing state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The borrowing state\r\n   **/\r\n  function getBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (self.data & ~BORROWING_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables stable rate borrowing on the reserve\r\n   * @param self The reserve configuration\r\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\r\n   **/\r\n  function setStableRateBorrowingEnabled(\r\n    DataTypes.ReserveConfigurationMap memory self,\r\n    bool enabled\r\n  ) internal pure {\r\n    self.data =\r\n      (self.data & STABLE_BORROWING_MASK) |\r\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the stable rate borrowing state of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The stable rate borrowing state\r\n   **/\r\n  function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the reserve factor of the reserve\r\n   * @param self The reserve configuration\r\n   * @param reserveFactor The reserve factor\r\n   **/\r\n  function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor)\r\n    internal\r\n    pure\r\n  {\r\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\r\n\r\n    self.data =\r\n      (self.data & RESERVE_FACTOR_MASK) |\r\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the reserve factor of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The reserve factor\r\n   **/\r\n  function getReserveFactor(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration flags of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\r\n   **/\r\n  function getFlags(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (\r\n      bool,\r\n      bool,\r\n      bool,\r\n      bool\r\n    )\r\n  {\r\n    uint256 dataLocal = self.data;\r\n\r\n    return (\r\n      (dataLocal & ~ACTIVE_MASK) != 0,\r\n      (dataLocal & ~FROZEN_MASK) != 0,\r\n      (dataLocal & ~BORROWING_MASK) != 0,\r\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration paramters of the reserve\r\n   * @param self The reserve configuration\r\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\r\n   **/\r\n  function getParams(DataTypes.ReserveConfigurationMap storage self)\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 dataLocal = self.data;\r\n\r\n    return (\r\n      dataLocal & ~LTV_MASK,\r\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\r\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\r\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\r\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration paramters of the reserve from a memory object\r\n   * @param self The reserve configuration\r\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\r\n   **/\r\n  function getParamsMemory(DataTypes.ReserveConfigurationMap memory self)\r\n    internal\r\n    pure\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    return (\r\n      self.data & ~LTV_MASK,\r\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\r\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\r\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\r\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the configuration flags of the reserve from a memory object\r\n   * @param self The reserve configuration\r\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\r\n   **/\r\n  function getFlagsMemory(DataTypes.ReserveConfigurationMap memory self)\r\n    internal\r\n    pure\r\n    returns (\r\n      bool,\r\n      bool,\r\n      bool,\r\n      bool\r\n    )\r\n  {\r\n    return (\r\n      (self.data & ~ACTIVE_MASK) != 0,\r\n      (self.data & ~FROZEN_MASK) != 0,\r\n      (self.data & ~BORROWING_MASK) != 0,\r\n      (self.data & ~STABLE_BORROWING_MASK) != 0\r\n    );\r\n  }\r\n}\r\n\r\nlibrary MathUtils {\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n\r\n  /// @dev Ignoring leap years\r\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\r\n\r\n  /**\r\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\r\n   * @param rate The interest rate, in ray\r\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\r\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\r\n   **/\r\n\r\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    //solium-disable-next-line\r\n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp));\r\n\r\n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray());\r\n  }\r\n\r\n  /**\r\n   * @dev Function to calculate the interest using a compounded interest rate formula\r\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\r\n   *\r\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\r\n   *\r\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\r\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\r\n   *\r\n   * @param rate The interest rate, in ray\r\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\r\n   * @return The interest rate compounded during the timeDelta, in ray\r\n   **/\r\n  function calculateCompoundedInterest(\r\n    uint256 rate,\r\n    uint40 lastUpdateTimestamp,\r\n    uint256 currentTimestamp\r\n  ) internal pure returns (uint256) {\r\n    //solium-disable-next-line\r\n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp));\r\n\r\n    if (exp == 0) {\r\n      return WadRayMath.ray();\r\n    }\r\n\r\n    uint256 expMinusOne = exp - 1;\r\n\r\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\r\n\r\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\r\n\r\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\r\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\r\n\r\n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2;\r\n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6;\r\n\r\n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\r\n   * @param rate The interest rate (in ray)\r\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\r\n   **/\r\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\r\n  }\r\n}\r\n\r\n/**\r\n * @title ReserveLogic library\r\n * @author Aave\r\n * @notice Implements the logic to update the reserves state\r\n */\r\nlibrary ReserveLogic {\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param liquidityRate The new liquidity rate\r\n   * @param stableBorrowRate The new stable borrow rate\r\n   * @param variableBorrowRate The new variable borrow rate\r\n   * @param liquidityIndex The new liquidity index\r\n   * @param variableBorrowIndex The new variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed asset,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n\r\n  /**\r\n   * @dev Returns the ongoing normalized income for the reserve\r\n   * A value of 1e27 means there is no income. As time passes, the income is accrued\r\n   * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\r\n   * @param reserve The reserve object\r\n   * @return the normalized income. expressed in ray\r\n   **/\r\n  function getNormalizedIncome(DataTypes.ReserveData storage reserve)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint40 timestamp = reserve.lastUpdateTimestamp;\r\n\r\n    //solium-disable-next-line\r\n    if (timestamp == uint40(block.timestamp)) {\r\n      //if the index was updated in the same block, no need to perform any calculation\r\n      return reserve.liquidityIndex;\r\n    }\r\n\r\n    uint256 cumulated =\r\n      MathUtils.calculateLinearInterest(reserve.currentLiquidityRate, timestamp).rayMul(\r\n        reserve.liquidityIndex\r\n      );\r\n\r\n    return cumulated;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the ongoing normalized variable debt for the reserve\r\n   * A value of 1e27 means there is no debt. As time passes, the income is accrued\r\n   * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\r\n   * @param reserve The reserve object\r\n   * @return The normalized variable debt. expressed in ray\r\n   **/\r\n  function getNormalizedDebt(DataTypes.ReserveData storage reserve)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint40 timestamp = reserve.lastUpdateTimestamp;\r\n\r\n    //solium-disable-next-line\r\n    if (timestamp == uint40(block.timestamp)) {\r\n      //if the index was updated in the same block, no need to perform any calculation\r\n      return reserve.variableBorrowIndex;\r\n    }\r\n\r\n    uint256 cumulated =\r\n      MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp).rayMul(\r\n        reserve.variableBorrowIndex\r\n      );\r\n\r\n    return cumulated;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the liquidity cumulative index and the variable borrow index.\r\n   * @param reserve the reserve object\r\n   **/\r\n  function updateState(DataTypes.ReserveData storage reserve) internal {\r\n    uint256 scaledVariableDebt =\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).scaledTotalSupply();\r\n    uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\r\n    uint256 previousLiquidityIndex = reserve.liquidityIndex;\r\n    uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\r\n\r\n    (uint256 newLiquidityIndex, uint256 newVariableBorrowIndex) =\r\n      _updateIndexes(\r\n        reserve,\r\n        scaledVariableDebt,\r\n        previousLiquidityIndex,\r\n        previousVariableBorrowIndex,\r\n        lastUpdatedTimestamp\r\n      );\r\n\r\n    _mintToTreasury(\r\n      reserve,\r\n      scaledVariableDebt,\r\n      previousVariableBorrowIndex,\r\n      newLiquidityIndex,\r\n      newVariableBorrowIndex,\r\n      lastUpdatedTimestamp\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\r\n   * the flashloan fee to the reserve, and spread it between all the depositors\r\n   * @param reserve The reserve object\r\n   * @param totalLiquidity The total liquidity available in the reserve\r\n   * @param amount The amount to accomulate\r\n   **/\r\n  function cumulateToLiquidityIndex(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 totalLiquidity,\r\n    uint256 amount\r\n  ) internal {\r\n    uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(totalLiquidity.wadToRay());\r\n\r\n    uint256 result = amountToLiquidityRatio.add(WadRayMath.ray());\r\n\r\n    result = result.rayMul(reserve.liquidityIndex);\r\n    require(result <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\r\n\r\n    reserve.liquidityIndex = uint128(result);\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a reserve\r\n   * @param reserve The reserve object\r\n   * @param aTokenAddress The address of the overlying atoken contract\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function init(\r\n    DataTypes.ReserveData storage reserve,\r\n    address aTokenAddress,\r\n    address stableDebtTokenAddress,\r\n    address variableDebtTokenAddress,\r\n    address interestRateStrategyAddress\r\n  ) external {\r\n    require(reserve.aTokenAddress == address(0), Errors.RL_RESERVE_ALREADY_INITIALIZED);\r\n\r\n    reserve.liquidityIndex = uint128(WadRayMath.ray());\r\n    reserve.variableBorrowIndex = uint128(WadRayMath.ray());\r\n    reserve.aTokenAddress = aTokenAddress;\r\n    reserve.stableDebtTokenAddress = stableDebtTokenAddress;\r\n    reserve.variableDebtTokenAddress = variableDebtTokenAddress;\r\n    reserve.interestRateStrategyAddress = interestRateStrategyAddress;\r\n  }\r\n\r\n  struct UpdateInterestRatesLocalVars {\r\n    address stableDebtTokenAddress;\r\n    uint256 availableLiquidity;\r\n    uint256 totalStableDebt;\r\n    uint256 newLiquidityRate;\r\n    uint256 newStableRate;\r\n    uint256 newVariableRate;\r\n    uint256 avgStableRate;\r\n    uint256 totalVariableDebt;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\r\n   * @param reserve The address of the reserve to be updated\r\n   * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\r\n   * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\r\n   **/\r\n  function updateInterestRates(\r\n    DataTypes.ReserveData storage reserve,\r\n    address reserveAddress,\r\n    address aTokenAddress,\r\n    uint256 liquidityAdded,\r\n    uint256 liquidityTaken\r\n  ) internal {\r\n    UpdateInterestRatesLocalVars memory vars;\r\n\r\n    vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\r\n\r\n    (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(vars.stableDebtTokenAddress)\r\n      .getTotalSupplyAndAvgRate();\r\n\r\n    //calculates the total variable debt locally using the scaled total supply instead\r\n    //of totalSupply(), as it's noticeably cheaper. Also, the index has been\r\n    //updated by the previous updateState() call\r\n    vars.totalVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress)\r\n      .scaledTotalSupply()\r\n      .rayMul(reserve.variableBorrowIndex);\r\n\r\n    (\r\n      vars.newLiquidityRate,\r\n      vars.newStableRate,\r\n      vars.newVariableRate\r\n    ) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(\r\n      reserveAddress,\r\n      aTokenAddress,\r\n      liquidityAdded,\r\n      liquidityTaken,\r\n      vars.totalStableDebt,\r\n      vars.totalVariableDebt,\r\n      vars.avgStableRate,\r\n      reserve.configuration.getReserveFactor()\r\n    );\r\n    require(vars.newLiquidityRate <= type(uint128).max, Errors.RL_LIQUIDITY_RATE_OVERFLOW);\r\n    require(vars.newStableRate <= type(uint128).max, Errors.RL_STABLE_BORROW_RATE_OVERFLOW);\r\n    require(vars.newVariableRate <= type(uint128).max, Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW);\r\n\r\n    reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\r\n    reserve.currentStableBorrowRate = uint128(vars.newStableRate);\r\n    reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\r\n\r\n    emit ReserveDataUpdated(\r\n      reserveAddress,\r\n      vars.newLiquidityRate,\r\n      vars.newStableRate,\r\n      vars.newVariableRate,\r\n      reserve.liquidityIndex,\r\n      reserve.variableBorrowIndex\r\n    );\r\n  }\r\n\r\n  struct MintToTreasuryLocalVars {\r\n    uint256 currentStableDebt;\r\n    uint256 principalStableDebt;\r\n    uint256 previousStableDebt;\r\n    uint256 currentVariableDebt;\r\n    uint256 previousVariableDebt;\r\n    uint256 avgStableRate;\r\n    uint256 cumulatedStableInterest;\r\n    uint256 totalDebtAccrued;\r\n    uint256 amountToMint;\r\n    uint256 reserveFactor;\r\n    uint40 stableSupplyUpdatedTimestamp;\r\n  }\r\n\r\n  /**\r\n   * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\r\n   * specific asset.\r\n   * @param reserve The reserve reserve to be updated\r\n   * @param scaledVariableDebt The current scaled total variable debt\r\n   * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\r\n   * @param newLiquidityIndex The new liquidity index\r\n   * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\r\n   **/\r\n  function _mintToTreasury(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 scaledVariableDebt,\r\n    uint256 previousVariableBorrowIndex,\r\n    uint256 newLiquidityIndex,\r\n    uint256 newVariableBorrowIndex,\r\n    uint40 timestamp\r\n  ) internal {\r\n    MintToTreasuryLocalVars memory vars;\r\n\r\n    vars.reserveFactor = reserve.configuration.getReserveFactor();\r\n\r\n    if (vars.reserveFactor == 0) {\r\n      return;\r\n    }\r\n\r\n    //fetching the principal, total stable debt and the avg stable rate\r\n    (\r\n      vars.principalStableDebt,\r\n      vars.currentStableDebt,\r\n      vars.avgStableRate,\r\n      vars.stableSupplyUpdatedTimestamp\r\n    ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\r\n\r\n    //calculate the last principal variable debt\r\n    vars.previousVariableDebt = scaledVariableDebt.rayMul(previousVariableBorrowIndex);\r\n\r\n    //calculate the new total supply after accumulation of the index\r\n    vars.currentVariableDebt = scaledVariableDebt.rayMul(newVariableBorrowIndex);\r\n\r\n    //calculate the stable debt until the last timestamp update\r\n    vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\r\n      vars.avgStableRate,\r\n      vars.stableSupplyUpdatedTimestamp,\r\n      timestamp\r\n    );\r\n\r\n    vars.previousStableDebt = vars.principalStableDebt.rayMul(vars.cumulatedStableInterest);\r\n\r\n    //debt accrued is the sum of the current debt minus the sum of the debt at the last update\r\n    vars.totalDebtAccrued = vars\r\n      .currentVariableDebt\r\n      .add(vars.currentStableDebt)\r\n      .sub(vars.previousVariableDebt)\r\n      .sub(vars.previousStableDebt);\r\n\r\n    vars.amountToMint = vars.totalDebtAccrued.percentMul(vars.reserveFactor);\r\n\r\n    if (vars.amountToMint != 0) {\r\n      IAToken(reserve.aTokenAddress).mintToTreasury(vars.amountToMint, newLiquidityIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the reserve indexes and the timestamp of the update\r\n   * @param reserve The reserve reserve to be updated\r\n   * @param scaledVariableDebt The scaled variable debt\r\n   * @param liquidityIndex The last stored liquidity index\r\n   * @param variableBorrowIndex The last stored variable borrow index\r\n   **/\r\n  function _updateIndexes(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 scaledVariableDebt,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex,\r\n    uint40 timestamp\r\n  ) internal returns (uint256, uint256) {\r\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\r\n\r\n    uint256 newLiquidityIndex = liquidityIndex;\r\n    uint256 newVariableBorrowIndex = variableBorrowIndex;\r\n\r\n    //only cumulating if there is any income being produced\r\n    if (currentLiquidityRate > 0) {\r\n      uint256 cumulatedLiquidityInterest =\r\n        MathUtils.calculateLinearInterest(currentLiquidityRate, timestamp);\r\n      newLiquidityIndex = cumulatedLiquidityInterest.rayMul(liquidityIndex);\r\n      require(newLiquidityIndex <= type(uint128).max, Errors.RL_LIQUIDITY_INDEX_OVERFLOW);\r\n\r\n      reserve.liquidityIndex = uint128(newLiquidityIndex);\r\n\r\n      //as the liquidity rate might come only from stable rate loans, we need to ensure\r\n      //that there is actual variable debt before accumulating\r\n      if (scaledVariableDebt != 0) {\r\n        uint256 cumulatedVariableBorrowInterest =\r\n          MathUtils.calculateCompoundedInterest(reserve.currentVariableBorrowRate, timestamp);\r\n        newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(variableBorrowIndex);\r\n        require(\r\n          newVariableBorrowIndex <= type(uint128).max,\r\n          Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW\r\n        );\r\n        reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\r\n      }\r\n    }\r\n\r\n    //solium-disable-next-line\r\n    reserve.lastUpdateTimestamp = uint40(block.timestamp);\r\n    return (newLiquidityIndex, newVariableBorrowIndex);\r\n  }\r\n}\r\n\r\n/**\r\n * @title UserConfiguration library\r\n * @author Aave\r\n * @notice Implements the bitmap logic to handle the user configuration\r\n */\r\nlibrary UserConfiguration {\r\n  uint256 internal constant BORROWING_MASK =\r\n    0x5555555555555555555555555555555555555555555555555555555555555555;\r\n\r\n  /**\r\n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @param borrowing True if the user is borrowing the reserve, false otherwise\r\n   **/\r\n  function setBorrowing(\r\n    DataTypes.UserConfigurationMap storage self,\r\n    uint256 reserveIndex,\r\n    bool borrowing\r\n  ) internal {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    self.data =\r\n      (self.data & ~(1 << (reserveIndex * 2))) |\r\n      (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\r\n  }\r\n\r\n  /**\r\n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\r\n   **/\r\n  function setUsingAsCollateral(\r\n    DataTypes.UserConfigurationMap storage self,\r\n    uint256 reserveIndex,\r\n    bool usingAsCollateral\r\n  ) internal {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    self.data =\r\n      (self.data & ~(1 << (reserveIndex * 2 + 1))) |\r\n      (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\r\n   **/\r\n  function isUsingAsCollateralOrBorrowing(\r\n    DataTypes.UserConfigurationMap memory self,\r\n    uint256 reserveIndex\r\n  ) internal pure returns (bool) {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2)) & 3 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve for borrowing\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve for borrowing, false otherwise\r\n   **/\r\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2)) & 1 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve as collateral\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve as collateral, false otherwise\r\n   **/\r\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been borrowing from any reserve\r\n   * @param self The configuration object\r\n   * @return True if the user has been borrowing any reserve, false otherwise\r\n   **/\r\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\r\n    return self.data & BORROWING_MASK != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has not been using any reserve\r\n   * @param self The configuration object\r\n   * @return True if the user has been borrowing any reserve, false otherwise\r\n   **/\r\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\r\n    return self.data == 0;\r\n  }\r\n}\r\n\r\n/**\r\n * @title GenericLogic library\r\n * @author Aave\r\n * @title Implements protocol-level logic to calculate and validate the state of a user\r\n */\r\nlibrary GenericLogic {\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\r\n\r\n  struct balanceDecreaseAllowedLocalVars {\r\n    uint256 decimals;\r\n    uint256 liquidationThreshold;\r\n    uint256 totalCollateralInETH;\r\n    uint256 totalDebtInETH;\r\n    uint256 avgLiquidationThreshold;\r\n    uint256 amountToDecreaseInETH;\r\n    uint256 collateralBalanceAfterDecrease;\r\n    uint256 liquidationThresholdAfterDecrease;\r\n    uint256 healthFactorAfterDecrease;\r\n    bool reserveUsageAsCollateralEnabled;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if a specific balance decrease is allowed\r\n   * (i.e. doesn't bring the user borrow position health factor under HEALTH_FACTOR_LIQUIDATION_THRESHOLD)\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param user The address of the user\r\n   * @param amount The amount to decrease\r\n   * @param reservesData The data of all the reserves\r\n   * @param userConfig The user configuration\r\n   * @param reserves The list of all the active reserves\r\n   * @param oracle The address of the oracle contract\r\n   * @return true if the decrease of the balance is allowed\r\n   **/\r\n  function balanceDecreaseAllowed(\r\n    address asset,\r\n    address user,\r\n    uint256 amount,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap calldata userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view returns (bool) {\r\n    if (!userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral(reservesData[asset].id)) {\r\n      return true;\r\n    }\r\n\r\n    balanceDecreaseAllowedLocalVars memory vars;\r\n\r\n    (, vars.liquidationThreshold, , vars.decimals, ) = reservesData[asset]\r\n      .configuration\r\n      .getParams();\r\n\r\n    if (vars.liquidationThreshold == 0) {\r\n      return true;\r\n    }\r\n\r\n    (\r\n      vars.totalCollateralInETH,\r\n      vars.totalDebtInETH,\r\n      ,\r\n      vars.avgLiquidationThreshold,\r\n\r\n    ) = calculateUserAccountData(user, reservesData, userConfig, reserves, reservesCount, oracle);\r\n\r\n    if (vars.totalDebtInETH == 0) {\r\n      return true;\r\n    }\r\n\r\n    vars.amountToDecreaseInETH = IPriceOracleGetter(oracle).getAssetPrice(asset).mul(amount).div(\r\n      10**vars.decimals\r\n    );\r\n\r\n    vars.collateralBalanceAfterDecrease = vars.totalCollateralInETH.sub(vars.amountToDecreaseInETH);\r\n\r\n    //if there is a borrow, there can't be 0 collateral\r\n    if (vars.collateralBalanceAfterDecrease == 0) {\r\n      return false;\r\n    }\r\n\r\n    vars.liquidationThresholdAfterDecrease = vars\r\n      .totalCollateralInETH\r\n      .mul(vars.avgLiquidationThreshold)\r\n      .sub(vars.amountToDecreaseInETH.mul(vars.liquidationThreshold))\r\n      .div(vars.collateralBalanceAfterDecrease);\r\n\r\n    uint256 healthFactorAfterDecrease =\r\n      calculateHealthFactorFromBalances(\r\n        vars.collateralBalanceAfterDecrease,\r\n        vars.totalDebtInETH,\r\n        vars.liquidationThresholdAfterDecrease\r\n      );\r\n\r\n    return healthFactorAfterDecrease >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n  }\r\n\r\n  struct CalculateUserAccountDataVars {\r\n    uint256 reserveUnitPrice;\r\n    uint256 tokenUnit;\r\n    uint256 compoundedLiquidityBalance;\r\n    uint256 compoundedBorrowBalance;\r\n    uint256 decimals;\r\n    uint256 ltv;\r\n    uint256 liquidationThreshold;\r\n    uint256 i;\r\n    uint256 healthFactor;\r\n    uint256 totalCollateralInETH;\r\n    uint256 totalDebtInETH;\r\n    uint256 avgLtv;\r\n    uint256 avgLiquidationThreshold;\r\n    uint256 reservesLength;\r\n    bool healthFactorBelowThreshold;\r\n    address currentReserveAddress;\r\n    bool usageAsCollateralEnabled;\r\n    bool userUsesReserveAsCollateral;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the user data across the reserves.\r\n   * this includes the total liquidity/collateral/borrow balances in ETH,\r\n   * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\r\n   * @param user The address of the user\r\n   * @param reservesData Data of all the reserves\r\n   * @param userConfig The configuration of the user\r\n   * @param reserves The list of the available reserves\r\n   * @param oracle The price oracle address\r\n   * @return The total collateral and total debt of the user in ETH, the avg ltv, liquidation threshold and the HF\r\n   **/\r\n  function calculateUserAccountData(\r\n    address user,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap memory userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  )\r\n    internal\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    CalculateUserAccountDataVars memory vars;\r\n\r\n    if (userConfig.isEmpty()) {\r\n      return (0, 0, 0, 0, uint256(-1));\r\n    }\r\n    for (vars.i = 0; vars.i < reservesCount; vars.i++) {\r\n      if (!userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\r\n        continue;\r\n      }\r\n\r\n      vars.currentReserveAddress = reserves[vars.i];\r\n      DataTypes.ReserveData storage currentReserve = reservesData[vars.currentReserveAddress];\r\n\r\n      (vars.ltv, vars.liquidationThreshold, , vars.decimals, ) = currentReserve\r\n        .configuration\r\n        .getParams();\r\n\r\n      vars.tokenUnit = 10**vars.decimals;\r\n      vars.reserveUnitPrice = IPriceOracleGetter(oracle).getAssetPrice(vars.currentReserveAddress);\r\n\r\n      if (vars.liquidationThreshold != 0 && userConfig.isUsingAsCollateral(vars.i)) {\r\n        vars.compoundedLiquidityBalance = IERC20(currentReserve.aTokenAddress).balanceOf(user);\r\n\r\n        uint256 liquidityBalanceETH =\r\n          vars.reserveUnitPrice.mul(vars.compoundedLiquidityBalance).div(vars.tokenUnit);\r\n\r\n        vars.totalCollateralInETH = vars.totalCollateralInETH.add(liquidityBalanceETH);\r\n\r\n        vars.avgLtv = vars.avgLtv.add(liquidityBalanceETH.mul(vars.ltv));\r\n        vars.avgLiquidationThreshold = vars.avgLiquidationThreshold.add(\r\n          liquidityBalanceETH.mul(vars.liquidationThreshold)\r\n        );\r\n      }\r\n\r\n      if (userConfig.isBorrowing(vars.i)) {\r\n        vars.compoundedBorrowBalance = IERC20(currentReserve.stableDebtTokenAddress).balanceOf(\r\n          user\r\n        );\r\n        vars.compoundedBorrowBalance = vars.compoundedBorrowBalance.add(\r\n          IERC20(currentReserve.variableDebtTokenAddress).balanceOf(user)\r\n        );\r\n\r\n        vars.totalDebtInETH = vars.totalDebtInETH.add(\r\n          vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\r\n        );\r\n      }\r\n    }\r\n\r\n    vars.avgLtv = vars.totalCollateralInETH > 0 ? vars.avgLtv.div(vars.totalCollateralInETH) : 0;\r\n    vars.avgLiquidationThreshold = vars.totalCollateralInETH > 0\r\n      ? vars.avgLiquidationThreshold.div(vars.totalCollateralInETH)\r\n      : 0;\r\n\r\n    vars.healthFactor = calculateHealthFactorFromBalances(\r\n      vars.totalCollateralInETH,\r\n      vars.totalDebtInETH,\r\n      vars.avgLiquidationThreshold\r\n    );\r\n    return (\r\n      vars.totalCollateralInETH,\r\n      vars.totalDebtInETH,\r\n      vars.avgLtv,\r\n      vars.avgLiquidationThreshold,\r\n      vars.healthFactor\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the health factor from the corresponding balances\r\n   * @param totalCollateralInETH The total collateral in ETH\r\n   * @param totalDebtInETH The total debt in ETH\r\n   * @param liquidationThreshold The avg liquidation threshold\r\n   * @return The health factor calculated from the balances provided\r\n   **/\r\n  function calculateHealthFactorFromBalances(\r\n    uint256 totalCollateralInETH,\r\n    uint256 totalDebtInETH,\r\n    uint256 liquidationThreshold\r\n  ) internal pure returns (uint256) {\r\n    if (totalDebtInETH == 0) return uint256(-1);\r\n\r\n    return (totalCollateralInETH.percentMul(liquidationThreshold)).wadDiv(totalDebtInETH);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\r\n   * average Loan To Value\r\n   * @param totalCollateralInETH The total collateral in ETH\r\n   * @param totalDebtInETH The total borrow balance\r\n   * @param ltv The average loan to value\r\n   * @return the amount available to borrow in ETH for the user\r\n   **/\r\n\r\n  function calculateAvailableBorrowsETH(\r\n    uint256 totalCollateralInETH,\r\n    uint256 totalDebtInETH,\r\n    uint256 ltv\r\n  ) internal pure returns (uint256) {\r\n    uint256 availableBorrowsETH = totalCollateralInETH.percentMul(ltv);\r\n\r\n    if (availableBorrowsETH < totalDebtInETH) {\r\n      return 0;\r\n    }\r\n\r\n    availableBorrowsETH = availableBorrowsETH.sub(totalDebtInETH);\r\n    return availableBorrowsETH;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ReserveLogic library\r\n * @author Aave\r\n * @notice Implements functions to validate the different actions of the protocol\r\n */\r\nlibrary ValidationLogic {\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\r\n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\r\n\r\n  /**\r\n   * @dev Validates a deposit action\r\n   * @param reserve The reserve object on which the user is depositing\r\n   * @param amount The amount to be deposited\r\n   */\r\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\r\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\r\n\r\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a withdraw action\r\n   * @param reserveAddress The address of the reserve\r\n   * @param amount The amount to be withdrawn\r\n   * @param userBalance The balance of the user\r\n   * @param reservesData The reserves state\r\n   * @param userConfig The user configuration\r\n   * @param reserves The addresses of the reserves\r\n   * @param reservesCount The number of reserves\r\n   * @param oracle The price oracle\r\n   */\r\n  function validateWithdraw(\r\n    address reserveAddress,\r\n    uint256 amount,\r\n    uint256 userBalance,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view {\r\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\r\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\r\n\r\n    (bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n\r\n    require(\r\n      GenericLogic.balanceDecreaseAllowed(\r\n        reserveAddress,\r\n        msg.sender,\r\n        amount,\r\n        reservesData,\r\n        userConfig,\r\n        reserves,\r\n        reservesCount,\r\n        oracle\r\n      ),\r\n      Errors.VL_TRANSFER_NOT_ALLOWED\r\n    );\r\n  }\r\n\r\n  struct ValidateBorrowLocalVars {\r\n    uint256 currentLtv;\r\n    uint256 currentLiquidationThreshold;\r\n    uint256 amountOfCollateralNeededETH;\r\n    uint256 userCollateralBalanceETH;\r\n    uint256 userBorrowBalanceETH;\r\n    uint256 availableLiquidity;\r\n    uint256 healthFactor;\r\n    bool isActive;\r\n    bool isFrozen;\r\n    bool borrowingEnabled;\r\n    bool stableRateBorrowingEnabled;\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a borrow action\r\n   * @param asset The address of the asset to borrow\r\n   * @param reserve The reserve state from which the user is borrowing\r\n   * @param userAddress The address of the user\r\n   * @param amount The amount to be borrowed\r\n   * @param amountInETH The amount to be borrowed, in ETH\r\n   * @param interestRateMode The interest rate mode at which the user is borrowing\r\n   * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\r\n   * @param reservesData The state of all the reserves\r\n   * @param userConfig The state of the user for the specific reserve\r\n   * @param reserves The addresses of all the active reserves\r\n   * @param oracle The price oracle\r\n   */\r\n\r\n  function validateBorrow(\r\n    address asset,\r\n    DataTypes.ReserveData storage reserve,\r\n    address userAddress,\r\n    uint256 amount,\r\n    uint256 amountInETH,\r\n    uint256 interestRateMode,\r\n    uint256 maxStableLoanPercent,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view {\r\n    ValidateBorrowLocalVars memory vars;\r\n\r\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\r\n      .configuration\r\n      .getFlags();\r\n\r\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\r\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\r\n\r\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\r\n\r\n    //validate interest rate mode\r\n    require(\r\n      uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\r\n        uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\r\n      Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\r\n    );\r\n\r\n    (\r\n      vars.userCollateralBalanceETH,\r\n      vars.userBorrowBalanceETH,\r\n      vars.currentLtv,\r\n      vars.currentLiquidationThreshold,\r\n      vars.healthFactor\r\n    ) = GenericLogic.calculateUserAccountData(\r\n      userAddress,\r\n      reservesData,\r\n      userConfig,\r\n      reserves,\r\n      reservesCount,\r\n      oracle\r\n    );\r\n\r\n    require(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\r\n\r\n    require(\r\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\r\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\r\n    );\r\n\r\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\r\n    vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(\r\n      vars.currentLtv\r\n    ); //LTV is calculated in percentage\r\n\r\n    require(\r\n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\r\n      Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\r\n    );\r\n\r\n    /**\r\n     * Following conditions need to be met if the user is borrowing at a stable rate:\r\n     * 1. Reserve must be enabled for stable rate borrowing\r\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\r\n     *    they are borrowing, to prevent abuses.\r\n     * 3. Users will be able to borrow only a portion of the total available liquidity\r\n     **/\r\n\r\n    if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\r\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\r\n\r\n      require(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\r\n\r\n      require(\r\n        !userConfig.isUsingAsCollateral(reserve.id) ||\r\n          reserve.configuration.getLtv() == 0 ||\r\n          amount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\r\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\r\n      );\r\n\r\n      vars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\r\n\r\n      //calculate the max available loan size in stable rate mode as a percentage of the\r\n      //available liquidity\r\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\r\n\r\n      require(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a repay action\r\n   * @param reserve The reserve state from which the user is repaying\r\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\r\n   * @param onBehalfOf The address of the user msg.sender is repaying for\r\n   * @param stableDebt The borrow balance of the user\r\n   * @param variableDebt The borrow balance of the user\r\n   */\r\n  function validateRepay(\r\n    DataTypes.ReserveData storage reserve,\r\n    uint256 amountSent,\r\n    DataTypes.InterestRateMode rateMode,\r\n    address onBehalfOf,\r\n    uint256 stableDebt,\r\n    uint256 variableDebt\r\n  ) external view {\r\n    bool isActive = reserve.configuration.getActive();\r\n\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n\r\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\r\n\r\n    require(\r\n      (stableDebt > 0 &&\r\n        DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\r\n        (variableDebt > 0 &&\r\n          DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\r\n      Errors.VL_NO_DEBT_OF_SELECTED_TYPE\r\n    );\r\n\r\n    require(\r\n      amountSent != uint256(-1) || msg.sender == onBehalfOf,\r\n      Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a swap of borrow rate mode.\r\n   * @param reserve The reserve state on which the user is swapping the rate\r\n   * @param userConfig The user reserves configuration\r\n   * @param stableDebt The stable debt of the user\r\n   * @param variableDebt The variable debt of the user\r\n   * @param currentRateMode The rate mode of the borrow\r\n   */\r\n  function validateSwapRateMode(\r\n    DataTypes.ReserveData storage reserve,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    uint256 stableDebt,\r\n    uint256 variableDebt,\r\n    DataTypes.InterestRateMode currentRateMode\r\n  ) external view {\r\n    (bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\r\n\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\r\n\r\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\r\n      require(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\r\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\r\n      require(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\r\n      /**\r\n       * user wants to swap to stable, before swapping we need to ensure that\r\n       * 1. stable borrow rate is enabled on the reserve\r\n       * 2. user is not trying to abuse the reserve by depositing\r\n       * more collateral than he is borrowing, artificially lowering\r\n       * the interest rate, borrowing at variable, and switching to stable\r\n       **/\r\n      require(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\r\n\r\n      require(\r\n        !userConfig.isUsingAsCollateral(reserve.id) ||\r\n          reserve.configuration.getLtv() == 0 ||\r\n          stableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\r\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\r\n      );\r\n    } else {\r\n      revert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a stable borrow rate rebalance action\r\n   * @param reserve The reserve state on which the user is getting rebalanced\r\n   * @param reserveAddress The address of the reserve\r\n   * @param stableDebtToken The stable debt token instance\r\n   * @param variableDebtToken The variable debt token instance\r\n   * @param aTokenAddress The address of the aToken contract\r\n   */\r\n  function validateRebalanceStableBorrowRate(\r\n    DataTypes.ReserveData storage reserve,\r\n    address reserveAddress,\r\n    IERC20 stableDebtToken,\r\n    IERC20 variableDebtToken,\r\n    address aTokenAddress\r\n  ) external view {\r\n    (bool isActive, , , ) = reserve.configuration.getFlags();\r\n\r\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\r\n\r\n    //if the usage ratio is below 95%, no rebalances are needed\r\n    uint256 totalDebt =\r\n      stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\r\n    uint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay();\r\n    uint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\r\n\r\n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\r\n    //then we allow rebalancing of the stable rate positions.\r\n\r\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\r\n    uint256 maxVariableBorrowRate =\r\n      IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).getMaxVariableBorrowRate();\r\n\r\n    require(\r\n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\r\n        currentLiquidityRate <=\r\n        maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\r\n      Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Validates the action of setting an asset as collateral\r\n   * @param reserve The state of the reserve that the user is enabling or disabling as collateral\r\n   * @param reserveAddress The address of the reserve\r\n   * @param reservesData The data of all the reserves\r\n   * @param userConfig The state of the user for the specific reserve\r\n   * @param reserves The addresses of all the active reserves\r\n   * @param oracle The price oracle\r\n   */\r\n  function validateSetUseReserveAsCollateral(\r\n    DataTypes.ReserveData storage reserve,\r\n    address reserveAddress,\r\n    bool useAsCollateral,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) external view {\r\n    uint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\r\n\r\n    require(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\r\n\r\n    require(\r\n      useAsCollateral ||\r\n        GenericLogic.balanceDecreaseAllowed(\r\n          reserveAddress,\r\n          msg.sender,\r\n          underlyingBalance,\r\n          reservesData,\r\n          userConfig,\r\n          reserves,\r\n          reservesCount,\r\n          oracle\r\n        ),\r\n      Errors.VL_DEPOSIT_ALREADY_IN_USE\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Validates a flashloan action\r\n   * @param assets The assets being flashborrowed\r\n   * @param amounts The amounts for each asset being borrowed\r\n   **/\r\n  function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\r\n    require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\r\n  }\r\n\r\n  /**\r\n   * @dev Validates the liquidation action\r\n   * @param collateralReserve The reserve data of the collateral\r\n   * @param principalReserve The reserve data of the principal\r\n   * @param userConfig The user configuration\r\n   * @param userHealthFactor The user's health factor\r\n   * @param userStableDebt Total stable debt balance of the user\r\n   * @param userVariableDebt Total variable debt balance of the user\r\n   **/\r\n  function validateLiquidationCall(\r\n    DataTypes.ReserveData storage collateralReserve,\r\n    DataTypes.ReserveData storage principalReserve,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    uint256 userHealthFactor,\r\n    uint256 userStableDebt,\r\n    uint256 userVariableDebt\r\n  ) internal view returns (uint256, string memory) {\r\n    if (\r\n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()\r\n    ) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE),\r\n        Errors.VL_NO_ACTIVE_RESERVE\r\n      );\r\n    }\r\n\r\n    if (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\r\n        Errors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\r\n      );\r\n    }\r\n\r\n    bool isCollateralEnabled =\r\n      collateralReserve.configuration.getLiquidationThreshold() > 0 &&\r\n        userConfig.isUsingAsCollateral(collateralReserve.id);\r\n\r\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\r\n    if (!isCollateralEnabled) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\r\n        Errors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\r\n      );\r\n    }\r\n\r\n    if (userStableDebt == 0 && userVariableDebt == 0) {\r\n      return (\r\n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\r\n        Errors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\r\n      );\r\n    }\r\n\r\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\r\n  }\r\n\r\n  /**\r\n   * @dev Validates an aToken transfer\r\n   * @param from The user from which the aTokens are being transferred\r\n   * @param reservesData The state of all the reserves\r\n   * @param userConfig The state of the user for the specific reserve\r\n   * @param reserves The addresses of all the active reserves\r\n   * @param oracle The price oracle\r\n   */\r\n  function validateTransfer(\r\n    address from,\r\n    mapping(address => DataTypes.ReserveData) storage reservesData,\r\n    DataTypes.UserConfigurationMap storage userConfig,\r\n    mapping(uint256 => address) storage reserves,\r\n    uint256 reservesCount,\r\n    address oracle\r\n  ) internal view {\r\n    (, , , , uint256 healthFactor) =\r\n      GenericLogic.calculateUserAccountData(\r\n        from,\r\n        reservesData,\r\n        userConfig,\r\n        reserves,\r\n        reservesCount,\r\n        oracle\r\n      );\r\n\r\n    require(\r\n      healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\r\n      Errors.VL_TRANSFER_NOT_ALLOWED\r\n    );\r\n  }\r\n}\r\n\r\ncontract LendingPoolStorage {\r\n  using ReserveLogic for DataTypes.ReserveData;\r\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  ILendingPoolAddressesProvider internal _addressesProvider;\r\n\r\n  mapping(address => DataTypes.ReserveData) internal _reserves;\r\n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig;\r\n\r\n  // the list of the available reserves, structured as a mapping for gas savings reasons\r\n  mapping(uint256 => address) internal _reservesList;\r\n\r\n  uint256 internal _reservesCount;\r\n\r\n  bool internal _paused;\r\n\r\n  uint256 internal _maxStableRateBorrowSizePercent;\r\n\r\n  uint256 internal _flashLoanPremiumTotal;\r\n\r\n  uint256 internal _maxNumberOfReserves;\r\n}\r\n\r\n/**\r\n * @title LendingPool contract\r\n * @dev Main point of interaction with an Aave protocol's market\r\n * - Users can:\r\n *   # Deposit\r\n *   # Withdraw\r\n *   # Borrow\r\n *   # Repay\r\n *   # Swap their loans between variable and stable rate\r\n *   # Enable/disable their deposits as collateral rebalance stable rate borrow positions\r\n *   # Liquidate positions\r\n *   # Execute Flash Loans\r\n * - To be covered by a proxy contract, owned by the LendingPoolAddressesProvider of the specific market\r\n * - All admin functions are callable by the LendingPoolConfigurator contract defined also in the\r\n *   LendingPoolAddressesProvider\r\n * @author Aave\r\n **/\r\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\r\n  using SafeMath for uint256;\r\n  using WadRayMath for uint256;\r\n  using PercentageMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint256 public constant LENDINGPOOL_REVISION = 0x2;\r\n\r\n  modifier whenNotPaused() {\r\n    _whenNotPaused();\r\n    _;\r\n  }\r\n\r\n  modifier onlyLendingPoolConfigurator() {\r\n    _onlyLendingPoolConfigurator();\r\n    _;\r\n  }\r\n\r\n  function _whenNotPaused() internal view {\r\n    require(!_paused, Errors.LP_IS_PAUSED);\r\n  }\r\n\r\n  function _onlyLendingPoolConfigurator() internal view {\r\n    require(\r\n      _addressesProvider.getLendingPoolConfigurator() == msg.sender,\r\n      Errors.LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR\r\n    );\r\n  }\r\n\r\n  function getRevision() internal pure override returns (uint256) {\r\n    return LENDINGPOOL_REVISION;\r\n  }\r\n\r\n  /**\r\n   * @dev Function is invoked by the proxy contract when the LendingPool contract is added to the\r\n   * LendingPoolAddressesProvider of the market.\r\n   * - Caching the address of the LendingPoolAddressesProvider in order to reduce gas consumption\r\n   *   on subsequent operations\r\n   * @param provider The address of the LendingPoolAddressesProvider\r\n   **/\r\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\r\n    _addressesProvider = provider;\r\n    _maxStableRateBorrowSizePercent = 2500;\r\n    _flashLoanPremiumTotal = 9;\r\n    _maxNumberOfReserves = 128;\r\n  }\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    ValidationLogic.validateDeposit(reserve, amount);\r\n\r\n    address aToken = reserve.aTokenAddress;\r\n\r\n    ReserveLogic.updateState(reserve);\r\n    ReserveLogic.updateInterestRates(reserve, asset, aToken, amount, 0);\r\n\r\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\r\n\r\n    bool isFirstDeposit = IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\r\n\r\n    if (isFirstDeposit) {\r\n      UserConfiguration.setUsingAsCollateral(_usersConfig[onBehalfOf], reserve.id, true);\r\n      emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\r\n    }\r\n\r\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external override whenNotPaused returns (uint256) {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    address aToken = reserve.aTokenAddress;\r\n\r\n    uint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\r\n\r\n    uint256 amountToWithdraw = amount;\r\n\r\n    if (amount == type(uint256).max) {\r\n      amountToWithdraw = userBalance;\r\n    }\r\n\r\n    ValidationLogic.validateWithdraw(\r\n      asset,\r\n      amountToWithdraw,\r\n      userBalance,\r\n      _reserves,\r\n      _usersConfig[msg.sender],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    ReserveLogic.updateState(reserve);\r\n\r\n    ReserveLogic.updateInterestRates(reserve, asset, aToken, 0, amountToWithdraw);\r\n\r\n    if (amountToWithdraw == userBalance) {\r\n      UserConfiguration.setUsingAsCollateral(_usersConfig[msg.sender],reserve.id, false);\r\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\r\n    }\r\n\r\n    IAToken(aToken).burn(msg.sender, to, amountToWithdraw, reserve.liquidityIndex);\r\n\r\n    emit Withdraw(asset, msg.sender, to, amountToWithdraw);\r\n\r\n    return amountToWithdraw;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    _executeBorrow(\r\n      ExecuteBorrowParams(\r\n        asset,\r\n        msg.sender,\r\n        onBehalfOf,\r\n        amount,\r\n        interestRateMode,\r\n        reserve.aTokenAddress,\r\n        referralCode,\r\n        true\r\n      )\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external override whenNotPaused returns (uint256) {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\r\n\r\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\r\n\r\n    ValidationLogic.validateRepay(\r\n      reserve,\r\n      amount,\r\n      interestRateMode,\r\n      onBehalfOf,\r\n      stableDebt,\r\n      variableDebt\r\n    );\r\n\r\n    uint256 paybackAmount =\r\n      interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\r\n\r\n    if (amount < paybackAmount) {\r\n      paybackAmount = amount;\r\n    }\r\n\r\n    ReserveLogic.updateState(reserve);\r\n\r\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\r\n    } else {\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\r\n        onBehalfOf,\r\n        paybackAmount,\r\n        reserve.variableBorrowIndex\r\n      );\r\n    }\r\n\r\n    address aToken = reserve.aTokenAddress;\r\n    ReserveLogic.updateInterestRates(reserve, asset, aToken, paybackAmount, 0);\r\n\r\n    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\r\n      UserConfiguration.setBorrowing(_usersConfig[onBehalfOf], reserve.id, false);\r\n    }\r\n\r\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\r\n\r\n    IAToken(aToken).handleRepayment(msg.sender, paybackAmount);\r\n\r\n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\r\n\r\n    return paybackAmount;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param rateMode The rate mode that the user wants to swap to\r\n   **/\r\n  function swapBorrowRateMode(address asset, uint256 rateMode) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\r\n\r\n    DataTypes.InterestRateMode interestRateMode = DataTypes.InterestRateMode(rateMode);\r\n\r\n    ValidationLogic.validateSwapRateMode(\r\n      reserve,\r\n      _usersConfig[msg.sender],\r\n      stableDebt,\r\n      variableDebt,\r\n      interestRateMode\r\n    );\r\n\r\n    ReserveLogic.updateState(reserve);\r\n\r\n    if (interestRateMode == DataTypes.InterestRateMode.STABLE) {\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\r\n        msg.sender,\r\n        msg.sender,\r\n        stableDebt,\r\n        reserve.variableBorrowIndex\r\n      );\r\n    } else {\r\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\r\n        msg.sender,\r\n        variableDebt,\r\n        reserve.variableBorrowIndex\r\n      );\r\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\r\n        msg.sender,\r\n        msg.sender,\r\n        variableDebt,\r\n        reserve.currentStableBorrowRate\r\n      );\r\n    }\r\n\r\n    ReserveLogic.updateInterestRates(reserve, asset, reserve.aTokenAddress, 0, 0);\r\n\r\n    emit Swap(asset, msg.sender, rateMode);\r\n  }\r\n\r\n  /**\r\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n   * - Users can be rebalanced if the following conditions are satisfied:\r\n   *     1. Usage ratio is above 95%\r\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\r\n   *        borrowed at a stable rate and depositors are not earning enough\r\n   * @param asset The address of the underlying asset borrowed\r\n   * @param user The address of the user to be rebalanced\r\n   **/\r\n  function rebalanceStableBorrowRate(address asset, address user) external override whenNotPaused {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\r\n    IERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\r\n    address aTokenAddress = reserve.aTokenAddress;\r\n\r\n    uint256 stableDebt = IERC20(stableDebtToken).balanceOf(user);\r\n\r\n    ValidationLogic.validateRebalanceStableBorrowRate(\r\n      reserve,\r\n      asset,\r\n      stableDebtToken,\r\n      variableDebtToken,\r\n      aTokenAddress\r\n    );\r\n\r\n    ReserveLogic.updateState(reserve);\r\n\r\n    IStableDebtToken(address(stableDebtToken)).burn(user, stableDebt);\r\n    IStableDebtToken(address(stableDebtToken)).mint(\r\n      user,\r\n      user,\r\n      stableDebt,\r\n      reserve.currentStableBorrowRate\r\n    );\r\n\r\n    ReserveLogic.updateInterestRates(reserve, asset, aTokenAddress, 0, 0);\r\n\r\n    emit RebalanceStableBorrowRate(asset, user);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n   * @param asset The address of the underlying asset deposited\r\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n    external\r\n    override\r\n    whenNotPaused\r\n  {\r\n    DataTypes.ReserveData storage reserve = _reserves[asset];\r\n\r\n    ValidationLogic.validateSetUseReserveAsCollateral(\r\n      reserve,\r\n      asset,\r\n      useAsCollateral,\r\n      _reserves,\r\n      _usersConfig[msg.sender],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    UserConfiguration.setUsingAsCollateral(_usersConfig[msg.sender], reserve.id, useAsCollateral);\r\n\r\n    if (useAsCollateral) {\r\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\r\n    } else {\r\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external override whenNotPaused {\r\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\r\n\r\n    //solium-disable-next-line\r\n    (bool success, bytes memory result) =\r\n      collateralManager.delegatecall(\r\n        abi.encodeWithSignature(\r\n          'liquidationCall(address,address,address,uint256,bool)',\r\n          collateralAsset,\r\n          debtAsset,\r\n          user,\r\n          debtToCover,\r\n          receiveAToken\r\n        )\r\n      );\r\n\r\n    require(success, Errors.LP_LIQUIDATION_CALL_FAILED);\r\n\r\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\r\n\r\n    require(returnCode == 0, string(abi.encodePacked(returnMessage)));\r\n  }\r\n\r\n  struct FlashLoanLocalVars {\r\n    IFlashLoanReceiver receiver;\r\n    address oracle;\r\n    uint256 i;\r\n    address currentAsset;\r\n    address currentATokenAddress;\r\n    uint256 currentAmount;\r\n    uint256 currentPremium;\r\n    uint256 currentAmountPlusPremium;\r\n    address debtToken;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n   * as long as the amount taken plus a fee is returned.\r\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\r\n   * For further details please visit https://developers.aave.com\r\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\r\n   * @param assets The addresses of the assets being flash-borrowed\r\n   * @param amounts The amounts amounts being flash-borrowed\r\n   * @param modes Types of the debt to open if the flash loan is not returned:\r\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n   * @param params Variadic packed params to pass to the receiver as extra information\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata modes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external override whenNotPaused {\r\n    FlashLoanLocalVars memory vars;\r\n\r\n    ValidationLogic.validateFlashloan(assets, amounts);\r\n\r\n    address[] memory aTokenAddresses = new address[](assets.length);\r\n    uint256[] memory premiums = new uint256[](assets.length);\r\n\r\n    vars.receiver = IFlashLoanReceiver(receiverAddress);\r\n\r\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\r\n      aTokenAddresses[vars.i] = _reserves[assets[vars.i]].aTokenAddress;\r\n\r\n      premiums[vars.i] = amounts[vars.i].mul(_flashLoanPremiumTotal).div(10000);\r\n\r\n      IAToken(aTokenAddresses[vars.i]).transferUnderlyingTo(receiverAddress, amounts[vars.i]);\r\n    }\r\n\r\n    require(\r\n      vars.receiver.executeOperation(assets, amounts, premiums, msg.sender, params),\r\n      Errors.LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN\r\n    );\r\n\r\n    for (vars.i = 0; vars.i < assets.length; vars.i++) {\r\n      vars.currentAsset = assets[vars.i];\r\n      vars.currentAmount = amounts[vars.i];\r\n      vars.currentPremium = premiums[vars.i];\r\n      vars.currentATokenAddress = aTokenAddresses[vars.i];\r\n      vars.currentAmountPlusPremium = vars.currentAmount.add(vars.currentPremium);\r\n\r\n      if (DataTypes.InterestRateMode(modes[vars.i]) == DataTypes.InterestRateMode.NONE) {\r\n       ReserveLogic.updateState(_reserves[vars.currentAsset]);\r\n        ReserveLogic.cumulateToLiquidityIndex(_reserves[vars.currentAsset],\r\n          IERC20(vars.currentATokenAddress).totalSupply(),\r\n          vars.currentPremium\r\n        );\r\n        ReserveLogic.updateInterestRates(\r\n        _reserves[vars.currentAsset],\r\n          vars.currentAsset,\r\n          vars.currentATokenAddress,\r\n          vars.currentAmountPlusPremium,\r\n          0\r\n        );\r\n\r\n        IERC20(vars.currentAsset).safeTransferFrom(\r\n          receiverAddress,\r\n          vars.currentATokenAddress,\r\n          vars.currentAmountPlusPremium\r\n        );\r\n      } else {\r\n        // If the user chose to not return the funds, the system checks if there is enough collateral and\r\n        // eventually opens a debt position\r\n        _executeBorrow(\r\n          ExecuteBorrowParams(\r\n            vars.currentAsset,\r\n            msg.sender,\r\n            onBehalfOf,\r\n            vars.currentAmount,\r\n            modes[vars.i],\r\n            vars.currentATokenAddress,\r\n            referralCode,\r\n            false\r\n          )\r\n        );\r\n      }\r\n      emit FlashLoan(\r\n        receiverAddress,\r\n        msg.sender,\r\n        vars.currentAsset,\r\n        vars.currentAmount,\r\n        vars.currentPremium,\r\n        referralCode\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state of the reserve\r\n   **/\r\n  function getReserveData(address asset)\r\n    external\r\n    view\r\n    override\r\n    returns (DataTypes.ReserveData memory)\r\n  {\r\n    return _reserves[asset];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralETH the total collateral in ETH of the user\r\n   * @return totalDebtETH the total debt in ETH of the user\r\n   * @return availableBorrowsETH the borrowing power left of the user\r\n   * @return currentLiquidationThreshold the liquidation threshold of the user\r\n   * @return ltv the loan to value of the user\r\n   * @return healthFactor the current health factor of the user\r\n   **/\r\n  function getUserAccountData(address user)\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    )\r\n  {\r\n    (\r\n      totalCollateralETH,\r\n      totalDebtETH,\r\n      ltv,\r\n      currentLiquidationThreshold,\r\n      healthFactor\r\n    ) = GenericLogic.calculateUserAccountData(\r\n      user,\r\n      _reserves,\r\n      _usersConfig[user],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\r\n      totalCollateralETH,\r\n      totalDebtETH,\r\n      ltv\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(address asset)\r\n    external\r\n    view\r\n    override\r\n    returns (DataTypes.ReserveConfigurationMap memory)\r\n  {\r\n    return _reserves[asset].configuration;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(address user)\r\n    external\r\n    view\r\n    override\r\n    returns (DataTypes.UserConfigurationMap memory)\r\n  {\r\n    return _usersConfig[user];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the normalized income per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset)\r\n    external\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return ReserveLogic.getNormalizedIncome(_reserves[asset]);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return ReserveLogic.getNormalizedDebt(_reserves[asset]);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns if the LendingPool is paused\r\n   */\r\n  function paused() external view override returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the list of the initialized reserves\r\n   **/\r\n  function getReservesList() external view override returns (address[] memory) {\r\n    address[] memory _activeReserves = new address[](_reservesCount);\r\n\r\n    for (uint256 i = 0; i < _reservesCount; i++) {\r\n      _activeReserves[i] = _reservesList[i];\r\n    }\r\n    return _activeReserves;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\r\n   **/\r\n  function getAddressesProvider() external view override returns (ILendingPoolAddressesProvider) {\r\n    return _addressesProvider;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the percentage of available liquidity that can be borrowed at once at stable rate\r\n   */\r\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() public view returns (uint256) {\r\n    return _maxStableRateBorrowSizePercent;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the fee on flash loans \r\n   */\r\n  function FLASHLOAN_PREMIUM_TOTAL() public view returns (uint256) {\r\n    return _flashLoanPremiumTotal;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the maximum number of reserves supported to be listed in this LendingPool\r\n   */\r\n  function MAX_NUMBER_RESERVES() public view returns (uint256) {\r\n    return _maxNumberOfReserves;\r\n  }\r\n\r\n  /**\r\n   * @dev Validates and finalizes an aToken transfer\r\n   * - Only callable by the overlying aToken of the `asset`\r\n   * @param asset The address of the underlying asset of the aToken\r\n   * @param from The user from which the aTokens are transferred\r\n   * @param to The user receiving the aTokens\r\n   * @param amount The amount being transferred/withdrawn\r\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\r\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n   */\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromBefore,\r\n    uint256 balanceToBefore\r\n  ) external override whenNotPaused {\r\n    require(msg.sender == _reserves[asset].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN);\r\n\r\n    ValidationLogic.validateTransfer(\r\n      from,\r\n      _reserves,\r\n      _usersConfig[from],\r\n      _reservesList,\r\n      _reservesCount,\r\n      _addressesProvider.getPriceOracle()\r\n    );\r\n\r\n    uint256 reserveId = _reserves[asset].id;\r\n\r\n    if (from != to) {\r\n      if (balanceFromBefore.sub(amount) == 0) {\r\n        DataTypes.UserConfigurationMap storage fromConfig = _usersConfig[from];\r\n        UserConfiguration.setUsingAsCollateral(fromConfig, reserveId, false);\r\n        emit ReserveUsedAsCollateralDisabled(asset, from);\r\n      }\r\n\r\n      if (balanceToBefore == 0 && amount != 0) {\r\n        DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to];\r\n        UserConfiguration.setUsingAsCollateral(toConfig, reserveId, true);\r\n        emit ReserveUsedAsCollateralEnabled(asset, to);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n   * interest rate strategy\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n   * @param aTokenAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function initReserve(\r\n    address asset,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external override onlyLendingPoolConfigurator {\r\n    require(Address.isContract(asset), Errors.LP_NOT_CONTRACT);\r\n    ReserveLogic.init(\r\n      _reserves[asset],\r\n      aTokenAddress,\r\n      stableDebtAddress,\r\n      variableDebtAddress,\r\n      interestRateStrategyAddress\r\n    );\r\n    _addReserveToList(asset);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the address of the interest rate strategy contract\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param rateStrategyAddress The address of the interest rate strategy contract\r\n   **/\r\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\r\n    external\r\n    override\r\n    onlyLendingPoolConfigurator\r\n  {\r\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the configuration bitmap of the reserve as a whole\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @param configuration The new configuration bitmap\r\n   **/\r\n  function setConfiguration(address asset, uint256 configuration)\r\n    external\r\n    override\r\n    onlyLendingPoolConfigurator\r\n  {\r\n    _reserves[asset].configuration.data = configuration;\r\n  }\r\n\r\n  /**\r\n   * @dev Set the _pause state of a reserve\r\n   * - Only callable by the LendingPoolConfigurator contract\r\n   * @param val `true` to pause the reserve, `false` to un-pause it\r\n   */\r\n  function setPause(bool val) external override onlyLendingPoolConfigurator {\r\n    _paused = val;\r\n    if (_paused) {\r\n      emit Paused();\r\n    } else {\r\n      emit Unpaused();\r\n    }\r\n  }\r\n\r\n  struct ExecuteBorrowParams {\r\n    address asset;\r\n    address user;\r\n    address onBehalfOf;\r\n    uint256 amount;\r\n    uint256 interestRateMode;\r\n    address aTokenAddress;\r\n    uint16 referralCode;\r\n    bool releaseUnderlying;\r\n  }\r\n\r\n  function _executeBorrow(ExecuteBorrowParams memory vars) internal {\r\n    DataTypes.ReserveData storage reserve = _reserves[vars.asset];\r\n    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];\r\n\r\n    address oracle = _addressesProvider.getPriceOracle();\r\n\r\n    uint256 amountInETH =\r\n      IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\r\n        10**ReserveConfiguration.getDecimals(reserve.configuration)\r\n      );\r\n\r\n    ValidationLogic.validateBorrow(\r\n      vars.asset,\r\n      reserve,\r\n      vars.onBehalfOf,\r\n      vars.amount,\r\n      amountInETH,\r\n      vars.interestRateMode,\r\n      _maxStableRateBorrowSizePercent,\r\n      _reserves,\r\n      userConfig,\r\n      _reservesList,\r\n      _reservesCount,\r\n      oracle\r\n    );\r\n\r\n    ReserveLogic.updateState(reserve);\r\n\r\n    uint256 currentStableRate = 0;\r\n\r\n    bool isFirstBorrowing = false;\r\n    if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {\r\n      currentStableRate = reserve.currentStableBorrowRate;\r\n\r\n      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(\r\n        vars.user,\r\n        vars.onBehalfOf,\r\n        vars.amount,\r\n        currentStableRate\r\n      );\r\n    } else {\r\n      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\r\n        vars.user,\r\n        vars.onBehalfOf,\r\n        vars.amount,\r\n        reserve.variableBorrowIndex\r\n      );\r\n    }\r\n\r\n    if (isFirstBorrowing) {\r\n      UserConfiguration.setBorrowing(userConfig, reserve.id, true);\r\n    }\r\n\r\n    ReserveLogic.updateInterestRates(\r\n      reserve,\r\n      vars.asset,\r\n      vars.aTokenAddress,\r\n      0,\r\n      vars.releaseUnderlying ? vars.amount : 0\r\n    );\r\n\r\n    if (vars.releaseUnderlying) {\r\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\r\n    }\r\n\r\n    emit Borrow(\r\n      vars.asset,\r\n      vars.user,\r\n      vars.onBehalfOf,\r\n      vars.amount,\r\n      vars.interestRateMode,\r\n      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE\r\n        ? currentStableRate\r\n        : reserve.currentVariableBorrowRate,\r\n      vars.referralCode\r\n    );\r\n  }\r\n\r\n  function _addReserveToList(address asset) internal {\r\n    uint256 reservesCount = _reservesCount;\r\n\r\n    require(reservesCount < _maxNumberOfReserves, Errors.LP_NO_MORE_RESERVES_ALLOWED);\r\n\r\n    bool reserveAlreadyAdded = _reserves[asset].id != 0 || _reservesList[0] == asset;\r\n\r\n    if (!reserveAlreadyAdded) {\r\n      _reserves[asset].id = uint8(reservesCount);\r\n      _reservesList[reservesCount] = asset;\r\n\r\n      _reservesCount = reservesCount + 1;\r\n    }\r\n  }\r\n}\r\n\r\n\r\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n\r\n  ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\r\n  ILendingPool public immutable override LENDING_POOL;\r\n\r\n  constructor(ILendingPoolAddressesProvider provider) {\r\n    ADDRESSES_PROVIDER = provider;\r\n    LENDING_POOL = ILendingPool(provider.getLendingPool());\r\n  }\r\n}\r\n\r\n\r\n\r\n/// @title Safe casting methods\r\n/// @notice Contains methods for safely casting between types\r\nlibrary SafeCast {\r\n    /// @notice Cast a uint256 to a uint160, revert on overflow\r\n    /// @param y The uint256 to be downcasted\r\n    /// @return z The downcasted integer, now type uint160\r\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\r\n        require((z = uint160(y)) == y);\r\n    }\r\n\r\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\r\n    /// @param y The int256 to be downcasted\r\n    /// @return z The downcasted integer, now type int128\r\n    function toInt128(int256 y) internal pure returns (int128 z) {\r\n        require((z = int128(y)) == y);\r\n    }\r\n\r\n    /// @notice Cast a uint256 to a int256, revert on overflow\r\n    /// @param y The uint256 to be casted\r\n    /// @return z The casted integer, now type int256\r\n    function toInt256(uint256 y) internal pure returns (int256 z) {\r\n        require(y < 2**255);\r\n        z = int256(y);\r\n    }\r\n}\r\n\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(MAX_TICK), 'T');\r\n\r\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n\r\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n    /// ever return.\r\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\r\n        // second inequality must be < because the price can never reach the price at the max tick\r\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\r\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n        uint256 r = ratio;\r\n        uint256 msb = 0;\r\n\r\n        assembly {\r\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(5, gt(r, 0xFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(4, gt(r, 0xFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(3, gt(r, 0xFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(2, gt(r, 0xF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(1, gt(r, 0x3))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := gt(r, 0x1)\r\n            msb := or(msb, f)\r\n        }\r\n\r\n        if (msb >= 128) r = ratio >> (msb - 127);\r\n        else r = ratio << (127 - msb);\r\n\r\n        int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(63, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(62, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(61, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(60, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(59, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(58, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(57, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(56, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(55, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(54, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(53, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(52, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(51, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(50, f))\r\n        }\r\n\r\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\r\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\r\n\r\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\r\n    }\r\n}\r\n\r\n/// @title Pool state that never changes\r\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\r\ninterface IUniswapV3PoolImmutables {\r\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\r\n    /// @return The contract address\r\n    function factory() external view returns (address);\r\n\r\n    /// @notice The first of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token0() external view returns (address);\r\n\r\n    /// @notice The second of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token1() external view returns (address);\r\n\r\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\r\n    /// @return The fee\r\n    function fee() external view returns (uint24);\r\n\r\n    /// @notice The pool tick spacing\r\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\r\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\r\n    /// This value is an int24 to avoid casting even though it is always positive.\r\n    /// @return The tick spacing\r\n    function tickSpacing() external view returns (int24);\r\n\r\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\r\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\r\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\r\n    /// @return The max amount of liquidity per tick\r\n    function maxLiquidityPerTick() external view returns (uint128);\r\n}\r\n\r\n/// @title Pool state that can change\r\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\r\n/// per transaction\r\ninterface IUniswapV3PoolState {\r\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n    /// when accessed externally.\r\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n    /// boundary.\r\n    /// observationIndex The index of the last oracle observation that was written,\r\n    /// observationCardinality The current maximum number of observations stored in the pool,\r\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n    /// feeProtocol The protocol fee for both tokens of the pool.\r\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n    /// unlocked Whether the pool is currently locked to reentrancy\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint8 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\r\n    /// @dev This value can overflow the uint256\r\n    function feeGrowthGlobal0X128() external view returns (uint256);\r\n\r\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\r\n    /// @dev This value can overflow the uint256\r\n    function feeGrowthGlobal1X128() external view returns (uint256);\r\n\r\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\r\n    /// @dev Protocol fees will never exceed uint128 max in either token\r\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\r\n\r\n    /// @notice The currently in range liquidity available to the pool\r\n    /// @dev This value has no relationship to the total liquidity across all ticks\r\n    function liquidity() external view returns (uint128);\r\n\r\n    /// @notice Look up information about a specific tick in the pool\r\n    /// @param tick The tick to look up\r\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\r\n    /// tick upper,\r\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\r\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\r\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\r\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\r\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\r\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\r\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\r\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\r\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\r\n    /// a specific position.\r\n    function ticks(int24 tick)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 liquidityGross,\r\n            int128 liquidityNet,\r\n            uint256 feeGrowthOutside0X128,\r\n            uint256 feeGrowthOutside1X128,\r\n            int56 tickCumulativeOutside,\r\n            uint160 secondsPerLiquidityOutsideX128,\r\n            uint32 secondsOutside,\r\n            bool initialized\r\n        );\r\n\r\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\r\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\r\n\r\n    /// @notice Returns the information about a position by the position's key\r\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\r\n    /// @return _liquidity The amount of liquidity in the position,\r\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\r\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\r\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\r\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\r\n    function positions(bytes32 key)\r\n        external\r\n        view\r\n        returns (\r\n            uint128 _liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    /// @notice Returns data about a specific observation index\r\n    /// @param index The element of the observations array to fetch\r\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\r\n    /// ago, rather than at a specific index in the array.\r\n    /// @return blockTimestamp The timestamp of the observation,\r\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\r\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\r\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\r\n    function observations(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint32 blockTimestamp,\r\n            int56 tickCumulative,\r\n            uint160 secondsPerLiquidityCumulativeX128,\r\n            bool initialized\r\n        );\r\n}\r\n\r\n\r\n/// @title Pool state that is not stored\r\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\r\n/// blockchain. The functions here may have variable gas costs.\r\ninterface IUniswapV3PoolDerivedState {\r\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\r\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\r\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\r\n    /// you must call it with secondsAgos = [3600, 0].\r\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\r\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\r\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\r\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\r\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\r\n    /// timestamp\r\n    function observe(uint32[] calldata secondsAgos)\r\n        external\r\n        view\r\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\r\n\r\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\r\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\r\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\r\n    /// snapshot is taken and the second snapshot is taken.\r\n    /// @param tickLower The lower tick of the range\r\n    /// @param tickUpper The upper tick of the range\r\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\r\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\r\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\r\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\r\n        external\r\n        view\r\n        returns (\r\n            int56 tickCumulativeInside,\r\n            uint160 secondsPerLiquidityInsideX128,\r\n            uint32 secondsInside\r\n        );\r\n}\r\n\r\n\r\n/// @title Permissionless pool actions\r\n/// @notice Contains pool methods that can be called by anyone\r\ninterface IUniswapV3PoolActions {\r\n    /// @notice Sets the initial price for the pool\r\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\r\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n\r\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\r\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\r\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\r\n    /// @param recipient The address for which the liquidity will be created\r\n    /// @param tickLower The lower tick of the position in which to add liquidity\r\n    /// @param tickUpper The upper tick of the position in which to add liquidity\r\n    /// @param amount The amount of liquidity to mint\r\n    /// @param data Any data that should be passed through to the callback\r\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n    function mint(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount,\r\n        bytes calldata data\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Collects tokens owed to a position\r\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\r\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\r\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\r\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\r\n    /// @param recipient The address which should receive the fees collected\r\n    /// @param tickLower The lower tick of the position for which to collect fees\r\n    /// @param tickUpper The upper tick of the position for which to collect fees\r\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\r\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\r\n    /// @return amount0 The amount of fees collected in token0\r\n    /// @return amount1 The amount of fees collected in token1\r\n    function collect(\r\n        address recipient,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\r\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\r\n    /// @dev Fees must be collected separately via a call to #collect\r\n    /// @param tickLower The lower tick of the position for which to burn liquidity\r\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\r\n    /// @param amount How much liquidity to burn\r\n    /// @return amount0 The amount of token0 sent to the recipient\r\n    /// @return amount1 The amount of token1 sent to the recipient\r\n    function burn(\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint128 amount\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Swap token0 for token1, or token1 for token0\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\r\n    /// @param recipient The address to receive the output of the swap\r\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\r\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n    /// @param data Any data to be passed through to the callback\r\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n    function swap(\r\n        address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes calldata data\r\n    ) external returns (int256 amount0, int256 amount1);\r\n\r\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\r\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\r\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\r\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\r\n    /// @param recipient The address which will receive the token0 and token1 amounts\r\n    /// @param amount0 The amount of token0 to send\r\n    /// @param amount1 The amount of token1 to send\r\n    /// @param data Any data to be passed through to the callback\r\n    function flash(\r\n        address recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\r\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\r\n    /// the input observationCardinalityNext.\r\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\r\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\r\n}\r\n\r\n\r\n/// @title Permissioned pool actions\r\n/// @notice Contains pool methods that may only be called by the factory owner\r\ninterface IUniswapV3PoolOwnerActions {\r\n    /// @notice Set the denominator of the protocol's % share of the fees\r\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\r\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\r\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\r\n\r\n    /// @notice Collect the protocol fee accrued to the pool\r\n    /// @param recipient The address to which collected protocol fees should be sent\r\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\r\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\r\n    /// @return amount0 The protocol fee collected in token0\r\n    /// @return amount1 The protocol fee collected in token1\r\n    function collectProtocol(\r\n        address recipient,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n}\r\n\r\n\r\n/// @title Events emitted by a pool\r\n/// @notice Contains all events emitted by the pool\r\ninterface IUniswapV3PoolEvents {\r\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\r\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\r\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\r\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\r\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\r\n\r\n    /// @notice Emitted when liquidity is minted for a given position\r\n    /// @param sender The address that minted the liquidity\r\n    /// @param owner The owner of the position and recipient of any minted liquidity\r\n    /// @param tickLower The lower tick of the position\r\n    /// @param tickUpper The upper tick of the position\r\n    /// @param amount The amount of liquidity minted to the position range\r\n    /// @param amount0 How much token0 was required for the minted liquidity\r\n    /// @param amount1 How much token1 was required for the minted liquidity\r\n    event Mint(\r\n        address sender,\r\n        address indexed owner,\r\n        int24 indexed tickLower,\r\n        int24 indexed tickUpper,\r\n        uint128 amount,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n\r\n    /// @notice Emitted when fees are collected by the owner of a position\r\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\r\n    /// @param owner The owner of the position for which fees are collected\r\n    /// @param tickLower The lower tick of the position\r\n    /// @param tickUpper The upper tick of the position\r\n    /// @param amount0 The amount of token0 fees collected\r\n    /// @param amount1 The amount of token1 fees collected\r\n    event Collect(\r\n        address indexed owner,\r\n        address recipient,\r\n        int24 indexed tickLower,\r\n        int24 indexed tickUpper,\r\n        uint128 amount0,\r\n        uint128 amount1\r\n    );\r\n\r\n    /// @notice Emitted when a position's liquidity is removed\r\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\r\n    /// @param owner The owner of the position for which liquidity is removed\r\n    /// @param tickLower The lower tick of the position\r\n    /// @param tickUpper The upper tick of the position\r\n    /// @param amount The amount of liquidity to remove\r\n    /// @param amount0 The amount of token0 withdrawn\r\n    /// @param amount1 The amount of token1 withdrawn\r\n    event Burn(\r\n        address indexed owner,\r\n        int24 indexed tickLower,\r\n        int24 indexed tickUpper,\r\n        uint128 amount,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    );\r\n\r\n    /// @notice Emitted by the pool for any swaps between token0 and token1\r\n    /// @param sender The address that initiated the swap call, and that received the callback\r\n    /// @param recipient The address that received the output of the swap\r\n    /// @param amount0 The delta of the token0 balance of the pool\r\n    /// @param amount1 The delta of the token1 balance of the pool\r\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\r\n    /// @param liquidity The liquidity of the pool after the swap\r\n    /// @param tick The log base 1.0001 of price of the pool after the swap\r\n    event Swap(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        int256 amount0,\r\n        int256 amount1,\r\n        uint160 sqrtPriceX96,\r\n        uint128 liquidity,\r\n        int24 tick\r\n    );\r\n\r\n    /// @notice Emitted by the pool for any flashes of token0/token1\r\n    /// @param sender The address that initiated the swap call, and that received the callback\r\n    /// @param recipient The address that received the tokens from flash\r\n    /// @param amount0 The amount of token0 that was flashed\r\n    /// @param amount1 The amount of token1 that was flashed\r\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\r\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\r\n    event Flash(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        uint256 paid0,\r\n        uint256 paid1\r\n    );\r\n\r\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\r\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\r\n    /// just before a mint/swap/burn.\r\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\r\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\r\n    event IncreaseObservationCardinalityNext(\r\n        uint16 observationCardinalityNextOld,\r\n        uint16 observationCardinalityNextNew\r\n    );\r\n\r\n    /// @notice Emitted when the protocol fee is changed by the pool\r\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\r\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\r\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\r\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\r\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\r\n\r\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\r\n    /// @param sender The address that collects the protocol fees\r\n    /// @param recipient The address that receives the collected protocol fees\r\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\r\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\r\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\r\n}\r\n\r\n\r\n/// @title The interface for a Uniswap V3 Pool\r\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\r\n/// to the ERC20 specification\r\n/// @dev The pool interface is broken up into many smaller pieces\r\ninterface IUniswapV3Pool is\r\n    IUniswapV3PoolImmutables,\r\n    IUniswapV3PoolState,\r\n    IUniswapV3PoolDerivedState,\r\n    IUniswapV3PoolActions,\r\n    IUniswapV3PoolOwnerActions,\r\n    IUniswapV3PoolEvents\r\n{\r\n\r\n}\r\n\r\n/// @title Callback for IUniswapV3PoolActions#swap\r\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\r\ninterface IUniswapV3SwapCallback {\r\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\r\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n\r\n\r\n/// @title Immutable state\r\n/// @notice Functions that return immutable state of the router\r\ninterface IPeripheryImmutableState {\r\n    /// @return Returns the address of the Uniswap V3 factory\r\n    function factory() external view returns (address);\r\n\r\n    /// @return Returns the address of WETH9\r\n    function WETH9() external view returns (address);\r\n}\r\n\r\n\r\n\r\n/// @title Immutable state\r\n/// @notice Immutable state used by periphery contracts\r\nabstract contract PeripheryImmutableState is IPeripheryImmutableState {\r\n    /// @inheritdoc IPeripheryImmutableState\r\n    address public immutable override factory;\r\n    /// @inheritdoc IPeripheryImmutableState\r\n    address public immutable override WETH9;\r\n\r\n    constructor(address _factory, address _WETH9) {\r\n        factory = _factory;\r\n        WETH9 = _WETH9;\r\n    }\r\n}\r\n\r\n/// @title Function for getting block timestamp\r\n/// @dev Base contract that is overridden for tests\r\nabstract contract BlockTimestamp {\r\n    /// @dev Method that exists purely to be overridden for tests\r\n    /// @return The current block timestamp\r\n    function _blockTimestamp() internal view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract PeripheryValidation is BlockTimestamp {\r\n    modifier checkDeadline(uint256 deadline) {\r\n        require(_blockTimestamp() <= deadline, 'Transaction too old');\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/// @title Optimized overflow and underflow safe math operations\r\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\r\nlibrary LowGasSafeMath {\r\n    /// @notice Returns x + y, reverts if sum overflows uint256\r\n    /// @param x The augend\r\n    /// @param y The addend\r\n    /// @return z The sum of x and y\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    /// @notice Returns x - y, reverts if underflows\r\n    /// @param x The minuend\r\n    /// @param y The subtrahend\r\n    /// @return z The difference of x and y\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    /// @notice Returns x * y, reverts if overflows\r\n    /// @param x The multiplicand\r\n    /// @param y The multiplier\r\n    /// @return z The product of x and y\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(x == 0 || (z = x * y) / x == y);\r\n    }\r\n\r\n    /// @notice Returns x + y, reverts if overflows or underflows\r\n    /// @param x The augend\r\n    /// @param y The addend\r\n    /// @return z The sum of x and y\r\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require((z = x + y) >= x == (y >= 0));\r\n    }\r\n\r\n    /// @notice Returns x - y, reverts if overflows or underflows\r\n    /// @param x The minuend\r\n    /// @param y The subtrahend\r\n    /// @return z The difference of x and y\r\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require((z = x - y) <= x == (y >= 0));\r\n    }\r\n}\r\n\r\n\r\n/// @title Periphery Payments\r\n/// @notice Functions to ease deposits and withdrawals of ETH\r\ninterface IPeripheryPayments {\r\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\r\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\r\n    /// @param recipient The address receiving ETH\r\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\r\n\r\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\r\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\r\n    /// that use ether for the input amount\r\n    function refundETH() external payable;\r\n\r\n    /// @notice Transfers the full amount of a token held by this contract to recipient\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\r\n    /// @param token The contract address of the token which will be transferred to `recipient`\r\n    /// @param amountMinimum The minimum amount of token required for a transfer\r\n    /// @param recipient The destination address of the token\r\n    function sweepToken(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient\r\n    ) external payable;\r\n}\r\n\r\n\r\n/// @title Interface for WETH9\r\ninterface IWETH9 is IERC20 {\r\n    /// @notice Deposit ether to get wrapped ether\r\n    function deposit() external payable;\r\n\r\n    /// @notice Withdraw wrapped ether to get ether\r\n    function withdraw(uint256) external;\r\n}\r\n\r\n\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nabstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {\r\n    receive() external payable {\r\n        require(msg.sender == WETH9, 'Not WETH9');\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPayments\r\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable override {\r\n        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));\r\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\r\n\r\n        if (balanceWETH9 > 0) {\r\n            IWETH9(WETH9).withdraw(balanceWETH9);\r\n            TransferHelper.safeTransferETH(recipient, balanceWETH9);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPayments\r\n    function sweepToken(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient\r\n    ) external payable override {\r\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\r\n        require(balanceToken >= amountMinimum, 'Insufficient token');\r\n\r\n        if (balanceToken > 0) {\r\n            TransferHelper.safeTransfer(token, recipient, balanceToken);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPayments\r\n    function refundETH() external payable override {\r\n        if (address(this).balance > 0) TransferHelper.safeTransferETH(msg.sender, address(this).balance);\r\n    }\r\n\r\n    /// @param token The token to pay\r\n    /// @param payer The entity that must pay\r\n    /// @param recipient The entity that will receive payment\r\n    /// @param value The amount to pay\r\n    function pay(\r\n        address token,\r\n        address payer,\r\n        address recipient,\r\n        uint256 value\r\n    ) internal {\r\n        if (token == WETH9 && address(this).balance >= value) {\r\n            // pay with WETH9\r\n            IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay\r\n            IWETH9(WETH9).transfer(recipient, value);\r\n        } else if (payer == address(this)) {\r\n            // pay with tokens already in the contract (for the exact input multihop case)\r\n            TransferHelper.safeTransfer(token, recipient, value);\r\n        } else {\r\n            // pull payment\r\n            TransferHelper.safeTransferFrom(token, payer, recipient, value);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Periphery Payments\r\n/// @notice Functions to ease deposits and withdrawals of ETH\r\ninterface IPeripheryPaymentsWithFee is IPeripheryPayments {\r\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between\r\n    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\r\n    function unwrapWETH9WithFee(\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) external payable;\r\n\r\n    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\r\n    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\r\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\r\n    function sweepTokenWithFee(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) external payable;\r\n}\r\n\r\n\r\n\r\nabstract contract PeripheryPaymentsWithFee is PeripheryPayments, IPeripheryPaymentsWithFee {\r\n    using LowGasSafeMath for uint256;\r\n\r\n    /// @inheritdoc IPeripheryPaymentsWithFee\r\n    function unwrapWETH9WithFee(\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) public payable override {\r\n        require(feeBips > 0 && feeBips <= 100);\r\n\r\n        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));\r\n        require(balanceWETH9 >= amountMinimum, 'Insufficient WETH9');\r\n\r\n        if (balanceWETH9 > 0) {\r\n            IWETH9(WETH9).withdraw(balanceWETH9);\r\n            uint256 feeAmount = balanceWETH9.mul(feeBips) / 10_000;\r\n            if (feeAmount > 0) TransferHelper.safeTransferETH(feeRecipient, feeAmount);\r\n            TransferHelper.safeTransferETH(recipient, balanceWETH9 - feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPeripheryPaymentsWithFee\r\n    function sweepTokenWithFee(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient,\r\n        uint256 feeBips,\r\n        address feeRecipient\r\n    ) public payable override {\r\n        require(feeBips > 0 && feeBips <= 100);\r\n\r\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\r\n        require(balanceToken >= amountMinimum, 'Insufficient token');\r\n\r\n        if (balanceToken > 0) {\r\n            uint256 feeAmount = balanceToken.mul(feeBips) / 10_000;\r\n            if (feeAmount > 0) TransferHelper.safeTransfer(token, feeRecipient, feeAmount);\r\n            TransferHelper.safeTransfer(token, recipient, balanceToken - feeAmount);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title Multicall interface\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\ninterface IMulticall {\r\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\r\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\r\n    /// @param data The encoded function data for each of the calls to make to this contract\r\n    /// @return results The results from each of the calls passed in via data\r\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\r\n}\r\n\r\n\r\n/// @title Multicall\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall is IMulticall {\r\n    /// @inheritdoc IMulticall\r\n    function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\r\n                if (result.length < 68) revert();\r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                revert(abi.decode(result, (string)));\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\n/// @title Self Permit\r\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\r\ninterface ISelfPermit {\r\n    /// @notice Permits this contract to spend a given token from `msg.sender`\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\r\n    /// @param token The address of the token spent\r\n    /// @param value The amount that can be spent of token\r\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermit(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n\r\n    /// @notice Permits this contract to spend a given token from `msg.sender`\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\r\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\r\n    /// @param token The address of the token spent\r\n    /// @param value The amount that can be spent of token\r\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermitIfNecessary(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n\r\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\r\n    /// @param token The address of the token spent\r\n    /// @param nonce The current nonce of the owner\r\n    /// @param expiry The timestamp at which the permit is no longer valid\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermitAllowed(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n\r\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\r\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\r\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\r\n    /// @param token The address of the token spent\r\n    /// @param nonce The current nonce of the owner\r\n    /// @param expiry The timestamp at which the permit is no longer valid\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function selfPermitAllowedIfNecessary(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable;\r\n}\r\n\r\n/// @title Interface for permit\r\n/// @notice Interface used by DAI/CHAI for permit\r\ninterface IERC20PermitAllowed {\r\n    /// @notice Approve the spender to spend some tokens via the holder signature\r\n    /// @dev This is the permit interface used by DAI and CHAI\r\n    /// @param holder The address of the token holder, the token owner\r\n    /// @param spender The address of the token spender\r\n    /// @param nonce The holder's nonce, increases at each call to permit\r\n    /// @param expiry The timestamp at which the permit is no longer valid\r\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\r\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\r\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\r\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n\r\n/// @title Self Permit\r\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\r\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\r\n/// that requires an approval in a single transaction.\r\nabstract contract SelfPermit is ISelfPermit {\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermit(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable override {\r\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\r\n    }\r\n\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermitIfNecessary(\r\n        address token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable override {\r\n        if (IERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);\r\n    }\r\n\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermitAllowed(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable override {\r\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\r\n    }\r\n\r\n    /// @inheritdoc ISelfPermit\r\n    function selfPermitAllowedIfNecessary(\r\n        address token,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable override {\r\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\r\n            selfPermitAllowed(token, nonce, expiry, v, r, s);\r\n    }\r\n}\r\n\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonalo S <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\n\r\nlibrary BytesLib {\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, 'slice_overflow');\r\n        require(_start + _length >= _start, 'slice_overflow');\r\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    //zero out the 32 bytes slice we are about to return\r\n                    //we need to do it because Solidity does not garbage collect\r\n                    mstore(tempBytes, 0)\r\n\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_start + 20 >= _start, 'toAddress_overflow');\r\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_start + 3 >= _start, 'toUint24_overflow');\r\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Functions for manipulating path data for multihop swaps\r\nlibrary Path {\r\n    using BytesLib for bytes;\r\n\r\n    /// @dev The length of the bytes encoded address\r\n    uint256 private constant ADDR_SIZE = 20;\r\n    /// @dev The length of the bytes encoded fee\r\n    uint256 private constant FEE_SIZE = 3;\r\n\r\n    /// @dev The offset of a single token address and pool fee\r\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\r\n    /// @dev The offset of an encoded pool key\r\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\r\n    /// @dev The minimum length of an encoding that contains 2 or more pools\r\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\r\n\r\n    /// @notice Returns true iff the path contains two or more pools\r\n    /// @param path The encoded swap path\r\n    /// @return True if path contains two or more pools, otherwise false\r\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\r\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\r\n    }\r\n\r\n    /// @notice Returns the number of pools in the path\r\n    /// @param path The encoded swap path\r\n    /// @return The number of pools in the path\r\n    function numPools(bytes memory path) internal pure returns (uint256) {\r\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\r\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Decodes the first pool in path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return tokenA The first token of the given pool\r\n    /// @return tokenB The second token of the given pool\r\n    /// @return fee The fee level of the pool\r\n    function decodeFirstPool(bytes memory path)\r\n        internal\r\n        pure\r\n        returns (\r\n            address tokenA,\r\n            address tokenB,\r\n            uint24 fee\r\n        )\r\n    {\r\n        tokenA = path.toAddress(0);\r\n        fee = path.toUint24(ADDR_SIZE);\r\n        tokenB = path.toAddress(NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Gets the segment corresponding to the first pool in the path\r\n    /// @param path The bytes encoded swap path\r\n    /// @return The segment containing all data necessary to target the first pool in the path\r\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\r\n        return path.slice(0, POP_OFFSET);\r\n    }\r\n\r\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\r\n    /// @param path The swap path\r\n    /// @return The remaining token + fee elements in the path\r\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\r\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\r\n    }\r\n}\r\n\r\n\r\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\r\nlibrary PoolAddress {\r\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\r\n\r\n    /// @notice The identifying key of the pool\r\n    struct PoolKey {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n    }\r\n\r\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\r\n    /// @param tokenA The first token of a pool, unsorted\r\n    /// @param tokenB The second token of a pool, unsorted\r\n    /// @param fee The fee level of the pool\r\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\r\n    function getPoolKey(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) internal pure returns (PoolKey memory) {\r\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\r\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\r\n    }\r\n\r\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\r\n    /// @param factory The Uniswap V3 factory contract address\r\n    /// @param key The PoolKey\r\n    /// @return pool The contract address of the V3 pool\r\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\r\n        require(key.token0 < key.token1);\r\n        pool = address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex'ff',\r\n                        factory,\r\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\r\n                        POOL_INIT_CODE_HASH\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/// @notice Provides validation for callbacks from Uniswap V3 Pools\r\nlibrary CallbackValidation {\r\n    /// @notice Returns the address of a valid Uniswap V3 Pool\r\n    /// @param factory The contract address of the Uniswap V3 factory\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The V3 pool contract address\r\n    function verifyCallback(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) internal view returns (IUniswapV3Pool pool) {\r\n        return verifyCallback(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee));\r\n    }\r\n\r\n    /// @notice Returns the address of a valid Uniswap V3 Pool\r\n    /// @param factory The contract address of the Uniswap V3 factory\r\n    /// @param poolKey The identifying key of the V3 pool\r\n    /// @return pool The V3 pool contract address\r\n    function verifyCallback(address factory, PoolAddress.PoolKey memory poolKey)\r\n        internal\r\n        view\r\n        returns (IUniswapV3Pool pool)\r\n    {\r\n        pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\r\n        require(msg.sender == address(pool));\r\n    }\r\n}\r\n\r\n\r\n/// @title Uniswap V3 Swap Router\r\n/// @notice Router for stateless execution of swaps against Uniswap V3\r\ncontract SwapRouter is\r\n    ISwapRouter,\r\n    PeripheryImmutableState,\r\n    PeripheryValidation,\r\n    PeripheryPaymentsWithFee,\r\n    Multicall,\r\n    SelfPermit\r\n{\r\n    using Path for bytes;\r\n    using SafeCast for uint256;\r\n\r\n    /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap\r\n    /// can never actually be this value\r\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\r\n\r\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\r\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n    constructor(address _factory, address _WETH9) PeripheryImmutableState(_factory, _WETH9) {}\r\n\r\n    /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) private view returns (IUniswapV3Pool) {\r\n        return IUniswapV3Pool(PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(tokenA, tokenB, fee)));\r\n    }\r\n\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    /// @inheritdoc IUniswapV3SwapCallback\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external override {\r\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\r\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\r\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\r\n        CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);\r\n\r\n        (bool isExactInput, uint256 amountToPay) =\r\n            amount0Delta > 0\r\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\r\n                : (tokenOut < tokenIn, uint256(amount1Delta));\r\n        if (isExactInput) {\r\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\r\n        } else {\r\n            // either initiate the next swap or pay\r\n            if (data.path.hasMultiplePools()) {\r\n                data.path = data.path.skipToken();\r\n                exactOutputInternal(amountToPay, msg.sender, 0, data);\r\n            } else {\r\n                amountInCached = amountToPay;\r\n                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\r\n                pay(tokenIn, data.payer, msg.sender, amountToPay);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Performs a single exact input swap\r\n    function exactInputInternal(\r\n        uint256 amountIn,\r\n        address recipient,\r\n        uint160 sqrtPriceLimitX96,\r\n        SwapCallbackData memory data\r\n    ) private returns (uint256 amountOut) {\r\n        // allow swapping to the router address with address 0\r\n        if (recipient == address(0)) recipient = address(this);\r\n\r\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\r\n\r\n        bool zeroForOne = tokenIn < tokenOut;\r\n\r\n        (int256 amount0, int256 amount1) =\r\n            getPool(tokenIn, tokenOut, fee).swap(\r\n                recipient,\r\n                zeroForOne,\r\n                amountIn.toInt256(),\r\n                sqrtPriceLimitX96 == 0\r\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\r\n                    : sqrtPriceLimitX96,\r\n                abi.encode(data)\r\n            );\r\n\r\n        return uint256(-(zeroForOne ? amount1 : amount0));\r\n    }\r\n\r\n    /// @inheritdoc ISwapRouter\r\n    function exactInputSingle(ExactInputSingleParams calldata params)\r\n        external\r\n        payable\r\n        override\r\n        checkDeadline(params.deadline)\r\n        returns (uint256 amountOut)\r\n    {\r\n        amountOut = exactInputInternal(\r\n            params.amountIn,\r\n            params.recipient,\r\n            params.sqrtPriceLimitX96,\r\n            SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut), payer: msg.sender})\r\n        );\r\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\r\n    }\r\n\r\n    /// @inheritdoc ISwapRouter\r\n    function exactInput(ExactInputParams memory params)\r\n        external\r\n        payable\r\n        override\r\n        checkDeadline(params.deadline)\r\n        returns (uint256 amountOut)\r\n    {\r\n        address payer = msg.sender; // msg.sender pays for the first hop\r\n\r\n        while (true) {\r\n            bool hasMultiplePools = params.path.hasMultiplePools();\r\n\r\n            // the outputs of prior swaps become the inputs to subsequent ones\r\n            params.amountIn = exactInputInternal(\r\n                params.amountIn,\r\n                hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies\r\n                0,\r\n                SwapCallbackData({\r\n                    path: params.path.getFirstPool(), // only the first pool in the path is necessary\r\n                    payer: payer\r\n                })\r\n            );\r\n\r\n            // decide whether to continue or terminate\r\n            if (hasMultiplePools) {\r\n                payer = address(this); // at this point, the caller has paid\r\n                params.path = params.path.skipToken();\r\n            } else {\r\n                amountOut = params.amountIn;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(amountOut >= params.amountOutMinimum, 'Too little received');\r\n    }\r\n\r\n    /// @dev Performs a single exact output swap\r\n    function exactOutputInternal(\r\n        uint256 amountOut,\r\n        address recipient,\r\n        uint160 sqrtPriceLimitX96,\r\n        SwapCallbackData memory data\r\n    ) private returns (uint256 amountIn) {\r\n        // allow swapping to the router address with address 0\r\n        if (recipient == address(0)) recipient = address(this);\r\n\r\n        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();\r\n\r\n        bool zeroForOne = tokenIn < tokenOut;\r\n\r\n        (int256 amount0Delta, int256 amount1Delta) =\r\n            getPool(tokenIn, tokenOut, fee).swap(\r\n                recipient,\r\n                zeroForOne,\r\n                -amountOut.toInt256(),\r\n                sqrtPriceLimitX96 == 0\r\n                    ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\r\n                    : sqrtPriceLimitX96,\r\n                abi.encode(data)\r\n            );\r\n\r\n        uint256 amountOutReceived;\r\n        (amountIn, amountOutReceived) = zeroForOne\r\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\r\n            : (uint256(amount1Delta), uint256(-amount0Delta));\r\n        // it's technically possible to not receive the full output amount,\r\n        // so if no price limit has been specified, require this possibility away\r\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);\r\n    }\r\n\r\n    /// @inheritdoc ISwapRouter\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\r\n        external\r\n        payable\r\n        override\r\n        checkDeadline(params.deadline)\r\n        returns (uint256 amountIn)\r\n    {\r\n        // avoid an SLOAD by using the swap return data\r\n        amountIn = exactOutputInternal(\r\n            params.amountOut,\r\n            params.recipient,\r\n            params.sqrtPriceLimitX96,\r\n            SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn), payer: msg.sender})\r\n        );\r\n\r\n        require(amountIn <= params.amountInMaximum, 'Too much requested');\r\n        // has to be reset even though we don't use it in the single hop case\r\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n    }\r\n\r\n    /// @inheritdoc ISwapRouter\r\n    function exactOutput(ExactOutputParams calldata params)\r\n        external\r\n        payable\r\n        override\r\n        checkDeadline(params.deadline)\r\n        returns (uint256 amountIn)\r\n    {\r\n        // it's okay that the payer is fixed to msg.sender here, as they're only paying for the \"final\" exact output\r\n        // swap, which happens first, and subsequent swaps are paid for within nested callback frames\r\n        exactOutputInternal(\r\n            params.amountOut,\r\n            params.recipient,\r\n            0,\r\n            SwapCallbackData({path: params.path, payer: msg.sender})\r\n        );\r\n\r\n        amountIn = amountInCached;\r\n        require(amountIn <= params.amountInMaximum, 'Too much requested');\r\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface ISushiswapRouter is IUniswapV2Router02 {}\r\n\r\ncontract Borrower is FlashLoanReceiverBase, Ownable{\r\n    LendingPoolAddressesProvider private provider; // the address provider for the lending pool\r\n    LendingPool private lendingPool; // this performs flash loan functionality\r\n    \r\n    ISwapRouter private constant uniswapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\r\n    IUniswapV2Router02 private constant uniswap2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    ISushiswapRouter private constant sushiswapRouter = ISushiswapRouter(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n    // sushi main: 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\r\n    // Events, mostly for debugging\r\n    //event loanStarted(address ad, uint256 am);\r\n    //event flashLoaning(address ad, uint256 am);\r\n    //event execOp(address ad, uint256 am, uint8 inEx, uint8 outEx, uint256 minimum1, uint256 minimum2);\r\n    //event sentBack(address ad, uint256 am);\r\n    //event constructed(bool yesno, address uni, address sushi);\r\n    //event uniswapStarted(address loanT, address swapT);\r\n    //event uniswapDone(uint256 am);\r\n    //event uni2swapStarted(address loanT, address swapT);\r\n    //event uni2swapDone(uint256 am);\r\n    //event sushiswapStarted(address loanT, address swapT);\r\n    //event sushiswapDone(uint256 am);\r\n    //event codeTest(address returned);\r\n    \r\n    // _provider kovan:\"0x88757f2f99175387aB4C6a4b3067c77A695b0349\"\r\n    // mainnet _provider: 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5\r\n    constructor(LendingPoolAddressesProvider _provider) \r\n    FlashLoanReceiverBase(_provider) // initialise parent contracts\r\n    public {\r\n        provider = _provider;\r\n        lendingPool = LendingPool(provider.getLendingPool()); // pointer the lending pool given by the provider, converting address to LendingPool\r\n        //emit constructed(true, address(uniswapRouter), address(sushiswapRouter));\r\n    }\r\n    \r\n    function performUniSwap(uint256 amountToSwap, address input, address output, uint256 minimum) \r\n    private returns (uint256 amountReceived){\r\n        //emit uniswapStarted(input, output);\r\n            \r\n        // gives the router permission to take money (amountToSwap equals to the amount that was loaned)\r\n        TransferHelper.safeApprove(input, address(uniswapRouter), amountToSwap);\r\n        \r\n        // swap parameters\r\n        ISwapRouter.ExactInputSingleParams memory params  =\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: input,\r\n                tokenOut: output,\r\n                fee: uint24(3000), // same as 0.3%\r\n                recipient: address(this),\r\n                deadline: block.timestamp,\r\n                amountIn: amountToSwap,\r\n                amountOutMinimum: minimum, // this is a naive amount, need to change in production\r\n                sqrtPriceLimitX96: 0 // tells the router to use all the input tokens\r\n            });\r\n            \r\n        // execute the swap\r\n        amountReceived = uniswapRouter.exactInputSingle(params);\r\n        //emit uniswapDone(amountReceived);\r\n    }\r\n    \r\n    function performUni2Swap(uint256 amountToSwap, address input, address output, uint256 minimum) \r\n    private returns (uint256 amountReceived){\r\n        //emit uni2swapStarted(input, output);\r\n        \r\n        // approve the router to take the input token\r\n        IERC20(input).approve(address(uniswap2Router), amountToSwap);\r\n        \r\n        // tokens to swap\r\n        address[] memory path = new address[](2);\r\n        path[0] = input;\r\n        path[1] = output;\r\n        \r\n        // execute swaps\r\n        amountReceived = uniswap2Router.swapExactTokensForTokens(amountToSwap, minimum, path, address(this), block.timestamp)[1];\r\n        \r\n        //emit uni2swapDone(amountReceived);\r\n    }\r\n    \r\n    function performSushiSwap(uint256 amountToSwap, address input, address output, uint256 minimum)\r\n    private returns (uint256 amountReceived){\r\n        //emit sushiswapStarted(input, output);\r\n        \r\n        // approve the router to take the input token\r\n        IERC20(input).approve(address(sushiswapRouter), amountToSwap);\r\n        \r\n        // tokens to swap\r\n        address[] memory path = new address[](2);\r\n        path[0] = input;\r\n        path[1] = output;\r\n        \r\n        // execute swaps\r\n        amountReceived = sushiswapRouter.swapExactTokensForTokens(amountToSwap, minimum, path, address(this), block.timestamp)[1];\r\n        \r\n        //emit sushiswapDone(amountReceived);\r\n    }\r\n    \r\n    function startLoan(uint256 amountToLoan, address _loanToken, address _swapForToken, \r\n    uint8 exchanges0, uint8 exchanges1, uint256 minimums0, uint256 minimums1) public onlyOwner {\r\n        //emit loanStarted(_loanToken, amountToLoan);\r\n        \r\n        address[] memory assets = new address[](1);\r\n        assets[0] = _loanToken; // borrow loanToken\r\n        \r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = amountToLoan; // borrowing amount\r\n        \r\n        uint256[] memory modes = new uint256[](1);\r\n        modes[0] = 0; // borrow as a flash loan\r\n        \r\n        bytes memory params = abi.encode(_swapForToken, exchanges0, exchanges1, minimums0, minimums1);\r\n        \r\n        //emit flashLoaning(_loanToken, amounts[0]);\r\n        lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), params, 0);\r\n    }\r\n    \r\n    function performArb(uint256 amounts, address assets, bytes calldata params)\r\n    internal returns (uint256) {\r\n        // swap the loaned coins to another coin and back\r\n        address swapFor;\r\n        uint8 inEx;\r\n        uint8 outEx;\r\n        uint256 minimum1;\r\n        uint256 minimum2;\r\n        (swapFor, inEx, outEx, minimum1, minimum2) = abi.decode(params, (address, uint8, uint8, uint256, uint256));\r\n        //emit execOp(swapFor, amounts, inEx, outEx, minimum1, mminimum2);\r\n        \r\n        uint256 amountReceived;\r\n        if (inEx == 0)      amountReceived = performSushiSwap(amounts, assets, swapFor, minimum1);\r\n        else if (inEx == 1) amountReceived = performUni2Swap(amounts, assets, swapFor, minimum1);\r\n        else if (inEx == 2) amountReceived = performUniSwap(amounts, assets, swapFor, minimum1);\r\n        \r\n        if (outEx == 0)      amountReceived = performSushiSwap(amountReceived, swapFor, assets, minimum2); \r\n        else if (outEx == 1) amountReceived = performUni2Swap(amountReceived, swapFor, assets, minimum2);\r\n        else if (outEx == 2) amountReceived = performUniSwap(amountReceived, swapFor, assets, minimum2);\r\n        return amountReceived;\r\n    }\r\n    \r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address initiator,\r\n        bytes calldata params\r\n    )\r\n        external override returns (bool)\r\n    {\r\n        //\r\n        // This contract now has the funds requested.\r\n        // Your logic goes here.\r\n        //\r\n        \r\n        // Check if profit covers lending fee\r\n        performArb(amounts[0], assets[0], params);\r\n        \r\n        // At the end of your logic above, this contract owes\r\n        // the flashloaned amounts + premiums.\r\n        // Therefore ensure your contract has enough to repay\r\n        // these amounts.\r\n        \r\n        // Approve the LendingPool contract allowance to *pull* the owed amount\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            uint amountOwing = SafeMath.add(amounts[i], premiums[i]);\r\n            IERC20(assets[i]).approve(address(lendingPool), amountOwing);\r\n            //emit sentBack(assets[i], amountOwing);\r\n        }\r\n         \r\n        return true;\r\n    }\r\n    \r\n\r\n    /*\r\n    * Rugpull all ERC20 tokens from the contract\r\n    */\r\n    function rugPull(address withdrawalToken) public payable onlyOwner {\r\n        \r\n        // withdraw all ETH\r\n        msg.sender.call{ value: address(this).balance }(\"\");\r\n        \r\n        // withdraw all x ERC20 tokens\r\n        IERC20(withdrawalToken).transfer(msg.sender, IERC20(withdrawalToken).balanceOf(address(this)));\r\n    }\r\n    \r\n    receive() external payable {}\r\n}"
    }
  }
}