{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Auction.sol": {
      "content": "// File @openzeppelin/contracts/utils/Context.sol@v4.3.3\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.3\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/Pausable.sol@v4.3.3\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v4.3.3\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity 0.8.7;\r\ncontract Auction is Ownable, Pausable {\r\n  using Counters for Counters.Counter;\r\n\r\n  uint256[] public minimumUnitPrice;\r\n  uint256 public immutable minimumBidIncrement;\r\n  uint256 public immutable unitPriceStepSize;\r\n  uint256 public immutable minimumQuantity;\r\n  uint256 public immutable maximumQuantity;\r\n  uint256 public immutable numberOfAuctions;\r\n  uint256[] public itemsPerDay;\r\n  address payable public immutable beneficiaryAddress;\r\n\r\n  Counters.Counter private _auctionIDCounter;\r\n  Counters.Counter private _bidPlacedCounter;\r\n\r\n  bool private _allowWithdrawals;\r\n\r\n  event AuctionStarted(uint256 auctionID);\r\n  event AuctionEnded(uint256 auctionID);\r\n  event BidPlaced(uint256 indexed auctionID, address indexed bidder, uint256 bidIndex, uint256 unitPrice, uint256 quantity);\r\n  event WinnerSelected(uint256 indexed auctionID, address indexed bidder, uint256 unitPrice, uint256 quantity);\r\n  event BidderRefunded(address indexed bidder, uint256 refundAmount);\r\n\r\n  struct Bid {\r\n    uint256 unitPrice;\r\n    uint256 quantity;\r\n  }\r\n\r\n  struct AuctionStatus {\r\n    bool started;\r\n    bool ended;\r\n  }\r\n\r\n\r\n  mapping (uint256 => AuctionStatus) private _auctionStatus;\r\n\r\n  mapping (address => Bid) private _bids;\r\n\r\n  mapping (uint256 => uint256) private _remainingItemsPerAuction;\r\n\r\n\r\n  constructor(\r\n    address _contractOwner,\r\n    address payable _beneficiaryAddress,\r\n\r\n    uint256 _minimumBidIncrement,\r\n    uint256 _unitPriceStepSize,\r\n    uint256 _minimumQuantity,\r\n    uint256 _maximumQuantity,\r\n    uint256 _numberOfAuctions,\r\n    uint256[] memory _itemsPerDay\r\n  ) {\r\n    beneficiaryAddress = _beneficiaryAddress;\r\n    transferOwnership(_contractOwner);\r\n    \r\n    minimumBidIncrement = _minimumBidIncrement;\r\n    unitPriceStepSize = _unitPriceStepSize;\r\n    minimumQuantity = _minimumQuantity;\r\n    maximumQuantity = _maximumQuantity;\r\n    numberOfAuctions = _numberOfAuctions;\r\n\r\n    for(uint256 i = 0; i < _numberOfAuctions; i++) {\r\n      itemsPerDay.push(_itemsPerDay[i]);\r\n      _remainingItemsPerAuction[i] = _itemsPerDay[i];\r\n    }\r\n    minimumUnitPrice = [40000000000000000,60000000000000000,80000000000000000];\r\n    pause();\r\n  }\r\n\r\n  modifier whenAuctionActive() {\r\n    require(!currentAuctionStatus().ended, \"Auction has already ended.\");\r\n    require(currentAuctionStatus().started, \"Auction hasn't started yet.\");\r\n    _;\r\n  }\r\n\r\n  modifier whenPreAuction() {\r\n    require(!currentAuctionStatus().ended, \"Auction has already ended.\");\r\n    require(!currentAuctionStatus().started, \"Auction has already started.\");\r\n    _;\r\n  }\r\n\r\n  modifier whenAuctionEnded() {\r\n    require(currentAuctionStatus().ended, \"Auction hasn't ended yet.\");\r\n    require(currentAuctionStatus().started, \"Auction hasn't started yet.\");\r\n    _;\r\n  }\r\n\r\n  function pause() public onlyOwner {\r\n    _pause();\r\n  }\r\n\r\n  function unpause() public onlyOwner {\r\n    _unpause();\r\n  }\r\n\r\n  function setAllowWithdrawals(bool allowWithdrawals_) public onlyOwner {\r\n    _allowWithdrawals = allowWithdrawals_;\r\n  }\r\n\r\n  function getAllowWithdrawals() public view returns (bool) {\r\n    return _allowWithdrawals;\r\n  }\r\n\r\n  function auctionStatus(uint256 _auctionID) public view returns (AuctionStatus memory) {\r\n    return _auctionStatus[_auctionID];\r\n  }\r\n\r\n  function currentAuctionStatus() public view returns (AuctionStatus memory) {\r\n    return _auctionStatus[getCurrentAuctionID()];\r\n  }\r\n\r\n\r\n  function contractBalance() external view returns (uint256) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function bidsPlacedCount() external view returns (uint256) {\r\n    return _bidPlacedCounter.current();\r\n  }\r\n\r\n  function getCurrentAuctionID() public view returns (uint) {\r\n    return _auctionIDCounter.current();\r\n  }\r\n\r\n  function incrementAuctionID() public onlyOwner whenPaused whenAuctionEnded {\r\n    _auctionIDCounter.increment();\r\n    require(_auctionIDCounter.current() < numberOfAuctions, \"Max number of auctions reached.\");\r\n  }\r\n  \r\n  function finalizeAuctions() public onlyOwner whenPaused whenAuctionEnded {\r\n    require(_auctionIDCounter.current() == numberOfAuctions - 1, \"Auctions not over\");      \r\n    _auctionIDCounter.increment();\r\n    _auctionStatus[numberOfAuctions].started = true;\r\n    _auctionStatus[numberOfAuctions].ended = true;\r\n  }\r\n\r\n\r\n  function decrementAuctionID() public onlyOwner whenPaused {\r\n    _auctionIDCounter.decrement();\r\n  }\r\n\r\n  function startAuction() external onlyOwner whenPreAuction {\r\n    uint256 currentAuctionID = getCurrentAuctionID();\r\n    _auctionStatus[currentAuctionID].started = true;\r\n    if (paused()) {\r\n      unpause();\r\n    }\r\n    emit AuctionStarted(currentAuctionID);\r\n  }\r\n\r\n  function endAuction() external onlyOwner whenAuctionActive {\r\n    uint256 currentAuctionID = getCurrentAuctionID();\r\n    _auctionStatus[currentAuctionID].ended = true;\r\n    if (!paused()) {\r\n      pause();\r\n    }\r\n    emit AuctionEnded(currentAuctionID);\r\n  }\r\n\r\n  function getBid(address bidder) external view returns (Bid memory) {\r\n    return _bids[bidder];\r\n  }\r\n\r\n  function getRemainingItemsForAuction(uint256 auctionID) external view returns (uint256) {\r\n    require(auctionID < numberOfAuctions, \"Invalid auctionID.\");\r\n    return _remainingItemsPerAuction[auctionID];\r\n  }\r\n\r\n\r\n  function selectWinners(address[] calldata bidders) external onlyOwner whenPaused whenAuctionEnded {\r\n    uint256 auctionID = getCurrentAuctionID();\r\n\r\n    for(uint256 i = 0; i < bidders.length; i++) {\r\n      address bidder = bidders[i];\r\n      uint256 bidUnitPrice = _bids[bidder].unitPrice;\r\n      uint256 bidQuantity = _bids[bidder].quantity;\r\n\r\n\r\n      if (bidUnitPrice == 0 || bidQuantity == 0) {\r\n        continue;\r\n      }\r\n\r\n      if (_remainingItemsPerAuction[auctionID] == bidQuantity) {\r\n\r\n        _bids[bidder] = Bid(0,0);\r\n        emit WinnerSelected(auctionID, bidder, bidUnitPrice, bidQuantity);\r\n        _remainingItemsPerAuction[auctionID] = 0;\r\n        break;\r\n      } else if (_remainingItemsPerAuction[auctionID] < bidQuantity) {\r\n\r\n        emit WinnerSelected(auctionID, bidder, bidUnitPrice, _remainingItemsPerAuction[auctionID]);\r\n\r\n        _bids[bidder].quantity -= _remainingItemsPerAuction[auctionID];\r\n        _remainingItemsPerAuction[auctionID] = 0;\r\n        break;\r\n      } else {\r\n        \r\n        _bids[bidder] = Bid(0,0);\r\n        emit WinnerSelected(auctionID, bidder, bidUnitPrice, bidQuantity);\r\n        _remainingItemsPerAuction[auctionID] -= bidQuantity;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  function refundBidders(address payable[] calldata bidders) external onlyOwner whenPaused whenAuctionEnded {\r\n    uint256 totalRefundAmount = 0;\r\n    for(uint256 i = 0; i < bidders.length; i++) {\r\n      address payable bidder = bidders[i];\r\n      uint256 refundAmount = _bids[bidder].unitPrice * _bids[bidder].quantity;\r\n\r\n  \r\n      if (refundAmount == 0) {\r\n        continue;\r\n      }\r\n\r\n      _bids[bidder] = Bid(0,0);\r\n      (bool success, ) = bidder.call{ value: refundAmount }(\"\");\r\n      require(success, \"Transfer failed.\");\r\n      totalRefundAmount += refundAmount;\r\n      emit BidderRefunded(bidder, refundAmount);\r\n    }\r\n  }\r\n\r\n  function withdrawContractBalance() external onlyOwner {\r\n    (bool success, ) = beneficiaryAddress.call{value: address(this).balance}(\"\");\r\n    require(success, \"Transfer failed.\");\r\n  }\r\n  \r\n  function withdrawPartialContractBalance(uint256 amount) external onlyOwner {\r\n    require(amount <= address(this).balance, \"More than balance\");\r\n    (bool success, ) = beneficiaryAddress.call{value: amount}(\"\");\r\n    require(success, \"Transfer failed.\");\r\n  }\r\n\r\n\r\n  function claimRefund() external whenPaused whenAuctionEnded {\r\n\r\n    require(_allowWithdrawals, \"Withdrawals are not allowed right now.\");\r\n    uint256 refundAmount = _bids[msg.sender].unitPrice * _bids[msg.sender].quantity;\r\n    require(refundAmount > 0, \"Refund amount is 0.\");\r\n    _bids[msg.sender] = Bid(0,0);\r\n    (bool success, ) = msg.sender.call{ value: refundAmount }(\"\");\r\n    require(success, \"Transfer failed.\");\r\n    emit BidderRefunded(msg.sender, refundAmount);\r\n  }\r\n\r\n\r\n  function placeBid(uint256 quantity, uint256 unitPrice) external payable whenNotPaused whenAuctionActive {\r\n\r\n    if (msg.value > 0 && msg.value < minimumBidIncrement) {\r\n      revert(\"Bid lower than minimum bid increment.\");\r\n    }\r\n\r\n\r\n    uint256 initialUnitPrice = _bids[msg.sender].unitPrice;\r\n    uint256 initialQuantity = _bids[msg.sender].quantity;\r\n    uint256 initialTotalValue = initialUnitPrice * initialQuantity;\r\n\r\n\r\n    uint256 finalUnitPrice = unitPrice;\r\n    uint256 finalQuantity = quantity;\r\n    uint256 finalTotalValue = initialTotalValue + msg.value;\r\n\r\n\r\n    require(finalUnitPrice % unitPriceStepSize == 0, \"Unit price step too small.\");\r\n\r\n\r\n    require(finalQuantity >= minimumQuantity, \"Quantity too low.\");\r\n    require(finalQuantity <= maximumQuantity, \"Quantity too high.\");\r\n\r\n\r\n    require(finalTotalValue >= initialTotalValue, \"Total value can't be lowered.\");\r\n\r\n\r\n    require(finalUnitPrice >= initialUnitPrice, \"Unit price can't be lowered.\");\r\n\r\n\r\n    require(finalQuantity * finalUnitPrice == finalTotalValue, \"Quantity * Unit Price != Total Value\");\r\n\r\n\r\n    require(finalUnitPrice >= minimumUnitPrice[_auctionIDCounter.current()], \"Bid unit price too low.\");\r\n\r\n\r\n    if (initialUnitPrice == finalUnitPrice && initialQuantity == finalQuantity) {\r\n      revert(\"This bid doesn't change anything.\");\r\n    }\r\n\r\n\r\n    _bids[msg.sender].unitPrice = finalUnitPrice;\r\n    _bids[msg.sender].quantity = finalQuantity;\r\n\r\n    emit BidPlaced(_auctionIDCounter.current(), msg.sender, _bidPlacedCounter.current(), finalUnitPrice, finalQuantity);\r\n\r\n    _bidPlacedCounter.increment();\r\n  }\r\n\r\n\r\n  receive() external payable {\r\n    require(msg.value > 0, \"No ether was sent.\");\r\n    require(msg.sender == beneficiaryAddress || msg.sender == owner(), \"Only owner or beneficiary can fund contract.\");\r\n  }\r\n}"
    }
  }
}