{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"AINStake.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-12-06\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Sender is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"New owner address is invalid\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n      * @dev Multiplies two numbers, throws on overflow.\r\n      */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev A staking contract that pays interest if users and the owner (on behalf of users) stake\r\n * tokens\r\n */\r\ncontract AINStake is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    ERC20 public token;\r\n    uint256 public closingTime;\r\n    uint256 public interestRate = 1020000; // 1.02 (2%, monthly)\r\n    uint256 public divider = 1000000;\r\n    uint256 public maxStakingAmountPerUser = 20000 ether; // 20,000 AIN (~1,000,000 KRW)\r\n    uint256 public maxUnstakingAmountPerUser = 40000 ether; // 40,000 AIN\r\n    uint256 public maxStakingAmountPerContract = 2000000 ether; // 2,000,000 AIN (~100,000,000 KRW)\r\n    uint256 constant public MONTH = 30 days; // ~1 month in seconds\r\n\r\n    bool public stakingClosed = false;\r\n    bool public contractClosed = false;\r\n    bool public reEntrancyMutex = false;\r\n\r\n    mapping(address => UserStake) public userStakeMap; // userAddress => { index, [{ amount, startTime }, ...] }\r\n    // sum of all stakes from the user (only the principal amounts, stakes from the owner don't count)\r\n    mapping(address => uint256) public singleStakeSum; // userAddress => sum\r\n    uint256 public contractSingleStakeSum;\r\n    address[] public userList;\r\n\r\n    struct StakeItem {\r\n        uint256 amount; // amount of tokens staked\r\n        uint256 startTime; // timestamp when tokens are staked\r\n    }\r\n\r\n    struct UserStake {\r\n        uint256 index; // index of the user within userList\r\n        StakeItem[] stakes; // stakes from the user\r\n    }\r\n\r\n    event MultiStake(address[] users, uint256[] amounts, uint256 startTime);\r\n    event Stake(address user, uint256 amount, uint256 startTime);\r\n    event Unstake(address user, uint256 amount);\r\n\r\n    constructor(ERC20 _token, uint256 _closingTime) public {\r\n        token = _token;\r\n        closingTime = _closingTime;\r\n    }\r\n\r\n    function userExists(address user) public view returns (bool) {\r\n        return userStakeMap[user].index > 0 || (userList.length > 0 && userList[0] == user);\r\n    }\r\n\r\n    function getUserListLength() public view returns (uint256) {\r\n        return userList.length;\r\n    }\r\n\r\n    function getUserStakeCount(address user) public view returns (uint256) {\r\n        return userStakeMap[user].stakes.length;\r\n    }\r\n\r\n    /**\r\n     * @return staking information of a user\r\n     */\r\n    function getUserStake(address user, uint256 index) public view returns (uint256, uint256) {\r\n        if (index >= getUserStakeCount(user)) {\r\n            return (0, 0);\r\n        }\r\n        StakeItem memory item = userStakeMap[user].stakes[index];\r\n        return (item.amount, item.startTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Closes contract, return staked tokens to users, and transfer contract's tokens to the owner\r\n     */\r\n    function closeContract() onlyOwner public returns (bool) {\r\n        require(contractClosed == false, \"contract is closed\");\r\n\r\n        // unstake all users\r\n        for (uint256 i = 0; i < userList.length; i++) {\r\n            if (userStakeMap[userList[i]].stakes.length > 0) {\r\n                _unstake(userList[i]);\r\n            }\r\n        }\r\n\r\n        uint256 balance = token.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            require(token.transfer(owner, balance), \"token transfer to owner failed\");\r\n        }\r\n        stakingClosed = true;\r\n        contractClosed = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Opens staking (users can start staking after calling this function)\r\n     */\r\n    function openStaking() onlyOwner public returns (bool) {\r\n        require(stakingClosed == true, \"staking is open\");\r\n        require(contractClosed == false, \"contract is closed\");\r\n        stakingClosed = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Closes staking (users can only unstake after calling this function)\r\n     */\r\n    function closeStaking() onlyOwner public returns (bool) {\r\n        require(stakingClosed == false, \"staking is closed\");\r\n        stakingClosed = true;\r\n        return true;\r\n    }\r\n\r\n    function setMaxStakingAmountPerUser(uint256 max) onlyOwner public {\r\n        maxStakingAmountPerUser = max;\r\n    }\r\n\r\n    function setMaxUnstakingAmountPerUser(uint256 max) onlyOwner public {\r\n        maxUnstakingAmountPerUser = max;\r\n    }\r\n\r\n    function setMaxStakingAmountPerContract(uint256 max) onlyOwner public {\r\n        maxStakingAmountPerContract = max;\r\n    }\r\n\r\n    function extendContract(uint256 rate, uint256 time) onlyOwner public {\r\n        require(contractClosed == false, \"contract is closed\");\r\n        require(block.timestamp >= closingTime,\r\n            \"cannot extend contract before the current closingTime\");\r\n        if (interestRate != rate) {\r\n            for (uint256 i = 0; i < userList.length; i++) {\r\n                address user = userList[i];\r\n                uint256 total = calcUserStakeAndInterest(user, closingTime);\r\n                resetUserStakes(user);\r\n                _stake(user, total, block.timestamp);\r\n            }\r\n            interestRate = rate;\r\n        }\r\n        closingTime = time;\r\n    }\r\n\r\n    /**\r\n     * @return sum of stakes from an address as well as stakes from the owner\r\n     */\r\n    function getUserTotalStakeSum(address user) public view returns (uint256) {\r\n        uint256 sum = 0;\r\n        StakeItem[] memory stakes = userStakeMap[user].stakes;\r\n        for (uint256 i = 0; i < stakes.length; i++) {\r\n            sum = sum.add(stakes[i].amount);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @return min(total stakes + interest earned from the stakes, maxUnstakingAmountPerUser) of an address\r\n     */\r\n    function calcUserStakeAndInterest(address user, uint256 _endTime) public view returns (uint256) {\r\n        uint256 endTime = min(_endTime, closingTime);\r\n        uint256 total = 0;\r\n        uint256 multiplier = 1000000;\r\n        uint256 currentMonthsPassed = 0;\r\n        uint256 currentMonthSum = 0;\r\n        StakeItem[] memory stakes = userStakeMap[user].stakes;\r\n        for (uint256 i = stakes.length; i > 0; i--) { // start with the most recent stakes\r\n            uint256 amount = stakes[i.sub(1)].amount;\r\n            uint256 startTime = stakes[i.sub(1)].startTime;\r\n            if (startTime > endTime) { // should not happen\r\n                total = total.add(amount);\r\n            } else {\r\n                uint256 monthsPassed = (endTime.sub(startTime)).div(MONTH);\r\n                if (monthsPassed == currentMonthsPassed) {\r\n                    currentMonthSum = currentMonthSum.add(amount);\r\n                } else {\r\n                    total = total.add(currentMonthSum.mul(multiplier).div(divider));\r\n                    currentMonthSum = amount;\r\n                    while (currentMonthsPassed < monthsPassed) {\r\n                        multiplier = multiplier.mul(interestRate).div(divider);\r\n                        currentMonthsPassed = currentMonthsPassed.add(1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        total = total.add(currentMonthSum.mul(multiplier).div(divider));\r\n        require(total <= maxUnstakingAmountPerUser, \"maxUnstakingAmountPerUser exceeded\");\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * @return the total staked amount + interest in this contract\r\n     */\r\n    function calcContractStakeAndInterest(uint256 endTime) public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < userList.length; i++) {\r\n            total = total.add(calcUserStakeAndInterest(userList[i], endTime));\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function addUser(address user) private {\r\n        userList.push(user);\r\n        userStakeMap[user].index = userList.length.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Deletes user's stakes from userStakeMap (keeps the user in userList)\r\n     */\r\n    function resetUserStakes(address user) private {\r\n        // NOTE: decreasing array length will automatically clean up the storage slots occupied by \r\n        // the out-of-bounds elements\r\n        userStakeMap[user].stakes.length = 0;\r\n        contractSingleStakeSum = contractSingleStakeSum.sub(singleStakeSum[user]);\r\n        delete singleStakeSum[user];\r\n    }\r\n\r\n    function addMultiStakeWhitelist(address[] users) onlyOwner public {\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!userExists(user)) {\r\n                addUser(user);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _stake(address user, uint256 amount, uint256 startTime) private {\r\n        userStakeMap[user].stakes.push(StakeItem(amount, startTime));\r\n    }\r\n\r\n    /**\r\n     * @dev Airdrops tokens, in the form of stakes, to multiple users. Note that before calling this\r\n     * fucntion, the owner should call token.approve() for the transferFrom() to work, as well as\r\n     * addMultiStakeWhitelist() to register users.\r\n     */\r\n    function multiStake(address[] users, uint256[] amounts) onlyOwner public returns (bool) {\r\n        require(contractClosed == false, \"contract closed\");\r\n        require(users.length == amounts.length, \"array length mismatch\");\r\n\r\n        address emptyAddr = address(0);\r\n        uint256 amountTotal = 0;\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(users[i] != emptyAddr, \"invalid address\");\r\n            amountTotal = amountTotal.add(amounts[i]);\r\n        }\r\n        require(token.transferFrom(msg.sender, address(this), amountTotal), \"transferFrom failed\");\r\n\r\n        uint256 startTime = block.timestamp;\r\n        for (uint256 j = 0; j < users.length; j++) {\r\n            _stake(users[j], amounts[j], startTime);\r\n        }\r\n\r\n        emit MultiStake(users, amounts, startTime);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Stakes tokens and earn interest. User must first approve this contract for transferring\r\n     * her tokens.\r\n     */\r\n    function stake(uint256 amount) public returns (bool) {\r\n        require(!reEntrancyMutex, \"re-entrancy occurred\");\r\n        require(stakingClosed == false, \"staking closed\");\r\n        require(contractClosed == false, \"contract closed\");\r\n        require(block.timestamp < closingTime, \"past closing time\");\r\n        require(amount > 0, \"invalid amount\");\r\n        require(amount.add(singleStakeSum[msg.sender]) <= maxStakingAmountPerUser,\r\n            \"max user staking amount exceeded\");\r\n        require(amount.add(contractSingleStakeSum) <= maxStakingAmountPerContract,\r\n            \"max contract staking amount exceeded\");\r\n        \r\n        reEntrancyMutex = true;\r\n        require(token.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\r\n\r\n        if (!userExists(msg.sender)) {\r\n            addUser(msg.sender);\r\n        }\r\n        \r\n        _stake(msg.sender, amount, block.timestamp);\r\n        singleStakeSum[msg.sender] = singleStakeSum[msg.sender].add(amount);\r\n        contractSingleStakeSum = contractSingleStakeSum.add(amount);\r\n        reEntrancyMutex = false;\r\n\r\n        emit Stake(msg.sender, amount, block.timestamp);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _unstake(address user) private returns (uint256) {\r\n        require(!reEntrancyMutex, \"re-entrancy occurred\");\r\n        reEntrancyMutex = true;\r\n        uint256 amount = calcUserStakeAndInterest(user, block.timestamp);\r\n        require(amount > 0 && amount <= maxUnstakingAmountPerUser, \"invalid unstaking amount\");\r\n        resetUserStakes(user);\r\n        require(token.transfer(user, amount), \"transfer failed\");\r\n        reEntrancyMutex = false;\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Unstakes a user's stakes and interest all at once\r\n     */\r\n    function unstake() public returns (bool) {\r\n        require(contractClosed == false, \"contract closed\");\r\n        require(userStakeMap[msg.sender].stakes.length > 0, \"no stakes\");\r\n        uint256 amount = _unstake(msg.sender);\r\n        emit Unstake(msg.sender, amount);\r\n        return true;\r\n    }\r\n}"}}}