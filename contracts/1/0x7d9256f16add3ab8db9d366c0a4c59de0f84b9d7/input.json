{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"disclose.sol":{"content":"// SPDX-License-Identifier: MIT\n// Copyright (c) 2021 Varia LLC\n/// Wet Code by Erich Dylus & Sarah Brennan\n/// Dry Code by LexDAO LLC\npragma solidity 0.8.6;\n\n/// @notice This contract manages function access control, adapted from @boringcrypto (https://github.com/boringcrypto/BoringSolidity).\ncontract Ownable {\n    address public owner; \n    address public pendingOwner;\n    \n    event TransferOwnership(address indexed from, address indexed to); \n    event TransferOwnershipClaim(address indexed from, address indexed to);\n    \n    /// @notice Initialize contract.\n    constructor() {\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n    \n    /// @notice Access control modifier that requires modified function to be called by `owner` account.\n    modifier onlyOwner {\n        require(msg.sender == owner, 'Ownable:!owner');\n        _;\n    } \n    \n    /// @notice The `pendingOwner` can claim `owner` account.\n    function claimOwner() external {\n        require(msg.sender == pendingOwner, 'Ownable:!pendingOwner');\n        emit TransferOwnership(owner, msg.sender);\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n    \n    /// @notice Transfer `owner` account.\n    /// @param to Account granted `owner` access control.\n    /// @param direct If 'true', ownership is directly transferred. \n    function transferOwnership(address to, bool direct) external onlyOwner {\n        if (direct) {\n            owner = to;\n            emit TransferOwnership(msg.sender, to);\n        } else {\n            pendingOwner = to;\n            emit TransferOwnershipClaim(msg.sender, to);\n        }\n    }\n}\n\n/// @notice This contract allows potential delegates of DAO voting power to ethSign disclosures.\ncontract VoteDelegateDisclosure is Ownable {\n    uint8 public version; // counter for ricardian template versions\n    uint256 public signatures; // counter for ricardian signatures - registration `id`\n    string public template; // string stored for ricardian template signature - amendable by `owner`\n    \n    mapping(address => uint256) public registrations; // maps signatures to registration `id` (revocation, composability, etc.)\n    \n    event Amend(string template);\n    event Sign(uint256 indexed id, string details);\n    event Revoke(uint256 indexed id, string details);\n    \n    constructor(string memory _template) {\n        template = _template; // initialize ricardian template\n    }\n    \n    function amend(string calldata _template) external onlyOwner {\n        version++; // increment ricardian template version\n        template = _template; // replace ricardian template string stored in this contract\n        emit Amend(_template); // emit amendment details in event for apps\n    }\n\n    function sign(string calldata details) external returns (uint256 id) {\n        signatures++; // increment `signatures` count for registration id\n        id = signatures; // gas-optimize stored variable with alias\n        registrations[msg.sender] = id; // assign registration id to caller signatory\n        emit Sign(id, details); // emit signature details in event for apps\n    }\n    \n    function revoke(uint256 id, string calldata details) external {\n        require(registrations[msg.sender] == id, '!signatory'); // confirm caller is `id` signatory\n        registrations[msg.sender] = 0; // nullify registration id\n        emit Revoke(id, details); // emit revocation details in event for apps\n    }\n}"}}}