{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/kyberTrader_bk.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// import \"./kyber/IERC20.sol\";\r\n// import \"./kyber/IKyberNetworkProxy.sol\";\r\ninterface IERC20 {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function decimals() external view returns (uint8 digits);\r\n    function totalSupply() external view returns (uint256 supply);\r\n}\r\n\r\n// to support backward compatible contract name -- so function signature remains same\r\nabstract contract ERC20 is IERC20 {\r\n}\r\n\r\ninterface IKyberNetworkProxy {\r\n\r\n    event ExecuteTrade(address indexed trader, IERC20 src, IERC20 dest, address destAddress, uint256 actualSrcAmount, uint256 actualDestAmount, address platformWallet, uint256 platformFeeBps);\r\n\r\n    /// @notice backward compatible\r\n    function tradeWithHint(ERC20 src, uint256 srcAmount, ERC20 dest, address payable destAddress, uint256 maxDestAmount, uint256 minConversionRate, address payable walletId, bytes calldata hint)\r\n    external payable returns (uint256);\r\n    function tradeWithHintAndFee(IERC20 src, uint256 srcAmount, IERC20 dest, address payable destAddress, uint256 maxDestAmount, uint256 minConversionRate, address payable platformWallet, uint256 platformFeeBps, bytes calldata hint) external payable returns (uint256 destAmount);\r\n    function trade(IERC20 src, uint256 srcAmount, IERC20 dest, address payable destAddress, uint256 maxDestAmount, uint256 minConversionRate, address payable platformWallet) external payable returns (uint256);\r\n\r\n    /// @notice backward compatible\r\n    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint256 srcQty) external view returns (uint256 expectedRate, uint256 worstRate);\r\n    function getExpectedRateAfterFee(IERC20 src, IERC20 dest, uint256 srcQty, uint256 platformFeeBps, bytes calldata hint) external view returns (uint256 expectedRate);\r\n}\r\n\r\ncontract KyberTrader {\r\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    IKyberNetworkProxy kyberProxy;\r\n    address payable public platformWallet;\r\n    uint256 public platformFeeBps;\r\n\r\n    // constructor\r\n    // _platformWallet: To receive platform fees\r\n    // _platformFeeBps: Platform fee amount in basis points\r\n    constructor(\r\n        IKyberNetworkProxy _kyberProxy,\r\n        address payable _platformWallet,\r\n        uint256 _platformFeeBps\r\n        ) public\r\n    {\r\n        kyberProxy = _kyberProxy;\r\n        platformWallet = _platformWallet;\r\n        platformFeeBps = _platformFeeBps;\r\n    }\r\n\r\n    /// @dev Get the conversion rate for exchanging srcQty of srcToken to destToken\r\n    function getConversionRates(\r\n        IERC20 srcToken,\r\n        IERC20 destToken,\r\n        uint256 srcQty\r\n    ) public\r\n      view\r\n      returns (uint256)\r\n    {\r\n      return kyberProxy.getExpectedRateAfterFee(srcToken, destToken, srcQty, platformFeeBps, '');\r\n    }\r\n\r\n    /// @dev Swap from srcToken to destToken (including ether)\r\n    function executeSwap(\r\n        IERC20 srcToken,\r\n        uint256 srcQty,\r\n        IERC20 destToken,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount\r\n    ) external payable {\r\n        if (srcToken != ETH_TOKEN_ADDRESS) {\r\n            // check that the token transferFrom has succeeded\r\n            // we recommend using OpenZeppelin's SafeERC20 contract instead\r\n            // NOTE: msg.sender must have called srcToken.approve(thisContractAddress, srcQty)\r\n            require(srcToken.transferFrom(msg.sender, address(this), srcQty), \"transferFrom failed\");\r\n\r\n            // mitigate ERC20 Approve front-running attack, by initially setting\r\n            // allowance to 0\r\n            require(srcToken.approve(address(kyberProxy), 0), \"approval to 0 failed\");\r\n\r\n            // set the spender's token allowance to tokenQty\r\n            require(srcToken.approve(address(kyberProxy), srcQty), \"approval to srcQty failed\");\r\n        }\r\n\r\n        // Get the minimum conversion rate\r\n        uint256 minConversionRate = kyberProxy.getExpectedRateAfterFee(\r\n            srcToken,\r\n            destToken,\r\n            srcQty,\r\n            platformFeeBps,\r\n            '' // empty hint\r\n        );\r\n\r\n        // Execute the trade and send to destAddress\r\n        kyberProxy.tradeWithHintAndFee{value: msg.value}(\r\n            srcToken,\r\n            srcQty,\r\n            destToken,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            platformWallet,\r\n            platformFeeBps,\r\n            '' // empty hint\r\n        );\r\n    }\r\n}"}}}