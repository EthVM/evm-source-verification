{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ExchangeProxyUpkaran.sol": {
      "content": "// File: @opengsn/gsn/contracts/interfaces/IRelayRecipient.sol\r\n\r\n// SPDX-License-Identifier:MIT\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * a contract must implement this interface in order to support relayed transaction.\r\n * It is better to inherit the BaseRelayRecipient as its implementation.\r\n */\r\ncontract IRelayRecipient {\r\n    /**\r\n     * return if the forwarder is trusted to forward relayed transactions to us.\r\n     * the forwarder is required to verify the sender's signature, and verify\r\n     * the call is not a replay.\r\n     */\r\n    function isTrustedForwarder(address forwarder) public view returns (bool);\r\n\r\n    /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\r\n     * of the msg.data.\r\n     * otherwise, return `msg.sender`\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal view returns (address payable);\r\n\r\n    /**\r\n     * return the msg.data of this call.\r\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\r\n     * of the msg.data - so this method will strip those 20 bytes off.\r\n     * otherwise, return `msg.data`\r\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\r\n     * signing or hashing the\r\n     */\r\n    function _msgData() internal view returns (bytes memory);\r\n\r\n    function versionRecipient() external view returns (string memory);\r\n}\r\n\r\n// File: @opengsn/gsn/contracts/BaseRelayRecipient.sol\r\n\r\n// SPDX-License-Identifier:MIT\r\n// solhint-disable no-inline-assembly\r\npragma solidity ^0.5.12;\r\n\r\n/**\r\n * A base contract to be inherited by any contract that want to receive relayed transactions\r\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\r\n */\r\ncontract BaseRelayRecipient is IRelayRecipient {\r\n    /*\r\n     * Forwarder singleton we accept calls from\r\n     */\r\n    address public trustedForwarder;\r\n\r\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\r\n        return forwarder == trustedForwarder;\r\n    }\r\n\r\n    /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, return the original sender.\r\n     * otherwise, return `msg.sender`.\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal view returns (address payable ret) {\r\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\r\n            // At this point we know that the sender is a trusted forwarder,\r\n            // so we trust that the last bytes of msg.data are the verified sender address.\r\n            // extract sender address from the end of msg.data\r\n            assembly {\r\n                ret := shr(96, calldataload(sub(calldatasize(), 20)))\r\n            }\r\n        } else {\r\n            return msg.sender;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return the msg.data of this call.\r\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\r\n     * of the msg.data - so this method will strip those 20 bytes off.\r\n     * otherwise, return `msg.data`\r\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\r\n     * signing or hashing the\r\n     */\r\n    function _msgData() internal view returns (bytes memory ret) {\r\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\r\n            // At this point we know that the sender is a trusted forwarder,\r\n            // we copy the msg.data , except the last 20 bytes (and update the total length)\r\n            assembly {\r\n                let ptr := mload(0x40)\r\n                // copy only size-20 bytes\r\n                let size := sub(calldatasize(), 20)\r\n                // structure RLP data as <offset> <length> <bytes>\r\n                mstore(ptr, 0x20)\r\n                mstore(add(ptr, 32), size)\r\n                calldatacopy(add(ptr, 64), 0, size)\r\n                return(ptr, add(size, 64))\r\n            }\r\n        } else {\r\n            return msg.data;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ExchangeProxyUpkaran.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// modified to support gasless and batched transaction by: yashnaman\r\n\r\npragma solidity 0.5.12;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract PoolInterface {\r\n    function swapExactAmountIn(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256, uint256);\r\n\r\n    function swapExactAmountOut(\r\n        address,\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256, uint256);\r\n\r\n    function calcInGivenOut(\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) public pure returns (uint256);\r\n\r\n    function getDenormalizedWeight(address) external view returns (uint256);\r\n\r\n    function getBalance(address) external view returns (uint256);\r\n\r\n    function getSwapFee() external view returns (uint256);\r\n}\r\n\r\ncontract TokenInterface {\r\n    function balanceOf(address) public view returns (uint256);\r\n\r\n    function allowance(address, address) public view returns (uint256);\r\n\r\n    function approve(address, uint256) public returns (bool);\r\n\r\n    function transfer(address, uint256) public returns (bool);\r\n\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) public returns (bool);\r\n\r\n    function deposit() public payable;\r\n\r\n    function withdraw(uint256) public;\r\n}\r\n\r\ninterface IEIP2612LikePermit {\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ninterface IDAILikePermit {\r\n    function nonces(address) external returns (uint256);\r\n\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\ncontract ExchangeProxyUpkaran is BaseRelayRecipient {\r\n    string public versionRecipient = '1.0.0+balancer.exchangeproxy.gasless';\r\n    struct DAILikePermit {\r\n        // address holder;\r\n        // address spender;\r\n        // uint256 nonce;\r\n        uint256 expiry;\r\n        // bool allowed;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n    struct EIP2612LikePermit {\r\n        // address owner;\r\n        // address spender;\r\n        uint256 value;\r\n        uint256 deadline;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n    struct Swap {\r\n        address pool;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 swapAmount; // tokenInAmount / tokenOutAmount\r\n        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\r\n        uint256 maxPrice;\r\n    }\r\n    struct Repay {\r\n        address repayInToken;\r\n        uint256 repayAmount;\r\n        address repayTo;\r\n    }\r\n\r\n    TokenInterface weth;\r\n    address private constant ETH_ADDRESS =\r\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    constructor(address _trustedForwarder, address _weth) public {\r\n        trustedForwarder = _trustedForwarder;\r\n        weth = TokenInterface(_weth);\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'ERR_ADD_OVERFLOW');\r\n        return c;\r\n    }\r\n\r\n    function permit(address tokenIn, EIP2612LikePermit memory eip2612LikePermit)\r\n        internal\r\n    {\r\n        if (\r\n            TokenInterface(tokenIn).allowance(_msgSender(), address(this)) !=\r\n            eip2612LikePermit.value\r\n        ) {\r\n            IEIP2612LikePermit(tokenIn).permit(\r\n                _msgSender(),\r\n                address(this),\r\n                eip2612LikePermit.value,\r\n                eip2612LikePermit.deadline,\r\n                eip2612LikePermit.v,\r\n                eip2612LikePermit.r,\r\n                eip2612LikePermit.s\r\n            );\r\n        }\r\n    }\r\n\r\n    function permit(address tokenIn, DAILikePermit memory daiLikePermit)\r\n        internal\r\n    {\r\n        if (\r\n            TokenInterface(tokenIn).allowance(_msgSender(), address(this)) !=\r\n            uint256(-1)\r\n        ) {\r\n            uint256 nonce = IDAILikePermit(tokenIn).nonces(_msgSender());\r\n            IDAILikePermit(tokenIn).permit(\r\n                _msgSender(),\r\n                address(this),\r\n                nonce,\r\n                daiLikePermit.expiry,\r\n                true,\r\n                daiLikePermit.v,\r\n                daiLikePermit.r,\r\n                daiLikePermit.s\r\n            );\r\n        }\r\n    }\r\n\r\n    function transferFromAll(\r\n        TokenInterface token,\r\n        uint256 amount,\r\n        Repay memory repay\r\n    ) internal returns (bool) {\r\n        if (isETH(token)) {\r\n            weth.deposit.value(msg.value)();\r\n        } else {\r\n            require(\r\n                token.transferFrom(\r\n                    _msgSender(),\r\n                    address(this),\r\n                    add(amount, repay.repayAmount)\r\n                ),\r\n                'ERR_TRANSFER_FAILED'\r\n            );\r\n            if (repay.repayAmount > 0 && repay.repayInToken != address(0)) {\r\n                require(\r\n                    TokenInterface(repay.repayInToken).transfer(\r\n                        repay.repayTo,\r\n                        repay.repayAmount\r\n                    ),\r\n                    'ERR_TRANSFER_FAILED'\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBalance(TokenInterface token) internal view returns (uint256) {\r\n        if (isETH(token)) {\r\n            return address(this).balance;\r\n        } else {\r\n            return token.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function transferAll(TokenInterface token, uint256 amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        if (isETH(token)) {\r\n            weth.withdraw(amount);\r\n            (bool xfer, ) = _msgSender().call.value(amount)('');\r\n            require(xfer, 'ERR_ETH_FAILED');\r\n        } else {\r\n            require(\r\n                token.transfer(_msgSender(), amount),\r\n                'ERR_TRANSFER_FAILED'\r\n            );\r\n        }\r\n    }\r\n\r\n    function isETH(TokenInterface token) internal pure returns (bool) {\r\n        return (address(token) == ETH_ADDRESS);\r\n    }\r\n\r\n    function multihopBatchSwapExactIn(\r\n        Swap[][] memory swapSequences,\r\n        TokenInterface tokenIn,\r\n        TokenInterface tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        Repay memory repay\r\n    ) public payable returns (uint256 totalAmountOut) {\r\n        transferFromAll(tokenIn, totalAmountIn, repay);\r\n\r\n        for (uint256 i = 0; i < swapSequences.length; i++) {\r\n            uint256 tokenAmountOut;\r\n            for (uint256 k = 0; k < swapSequences[i].length; k++) {\r\n                Swap memory swap = swapSequences[i][k];\r\n                TokenInterface SwapTokenIn = TokenInterface(swap.tokenIn);\r\n                if (k == 1) {\r\n                    // Makes sure that on the second swap the output of the first was used\r\n                    // so there is not intermediate token leftover\r\n                    swap.swapAmount = tokenAmountOut;\r\n                }\r\n\r\n                PoolInterface pool = PoolInterface(swap.pool);\r\n                if (SwapTokenIn.allowance(address(this), swap.pool) > 0) {\r\n                    SwapTokenIn.approve(swap.pool, 0);\r\n                }\r\n                SwapTokenIn.approve(swap.pool, swap.swapAmount);\r\n                (tokenAmountOut, ) = pool.swapExactAmountIn(\r\n                    swap.tokenIn,\r\n                    swap.swapAmount,\r\n                    swap.tokenOut,\r\n                    swap.limitReturnAmount,\r\n                    swap.maxPrice\r\n                );\r\n            }\r\n            // This takes the amountOut of the last swap\r\n            totalAmountOut = add(tokenAmountOut, totalAmountOut);\r\n        }\r\n\r\n        require(totalAmountOut >= minTotalAmountOut, 'ERR_LIMIT_OUT');\r\n\r\n        transferAll(tokenOut, totalAmountOut);\r\n        transferAll(tokenIn, getBalance(tokenIn));\r\n    }\r\n\r\n    function multihopBatchSwapExactInDAILike(\r\n        Swap[][] memory swapSequences,\r\n        TokenInterface tokenIn,\r\n        TokenInterface tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        Repay memory repay,\r\n        DAILikePermit memory daiLikePermit\r\n    ) public payable returns (uint256 totalAmountOut) {\r\n        permit(address(tokenIn), daiLikePermit);\r\n        return\r\n            multihopBatchSwapExactIn(\r\n                swapSequences,\r\n                tokenIn,\r\n                tokenOut,\r\n                totalAmountIn,\r\n                minTotalAmountOut,\r\n                repay\r\n            );\r\n    }\r\n\r\n    function multihopBatchSwapExactInEIP2612Like(\r\n        Swap[][] memory swapSequences,\r\n        TokenInterface tokenIn,\r\n        TokenInterface tokenOut,\r\n        uint256 totalAmountIn,\r\n        uint256 minTotalAmountOut,\r\n        Repay memory repay,\r\n        EIP2612LikePermit memory eip2612LikePermit\r\n    ) public payable returns (uint256 totalAmountOut) {\r\n        permit(address(tokenIn), eip2612LikePermit);\r\n        return\r\n            multihopBatchSwapExactIn(\r\n                swapSequences,\r\n                tokenIn,\r\n                tokenOut,\r\n                totalAmountIn,\r\n                minTotalAmountOut,\r\n                repay\r\n            );\r\n    }\r\n\r\n    function multihopBatchSwapExactOut(\r\n        Swap[][] memory swapSequences,\r\n        TokenInterface tokenIn,\r\n        TokenInterface tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        Repay memory repay\r\n    ) public payable returns (uint256 totalAmountIn) {\r\n        transferFromAll(tokenIn, maxTotalAmountIn, repay);\r\n\r\n        for (uint256 i = 0; i < swapSequences.length; i++) {\r\n            uint256 tokenAmountInFirstSwap;\r\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\r\n            if (swapSequences[i].length == 1) {\r\n                Swap memory swap = swapSequences[i][0];\r\n                TokenInterface SwapTokenIn = TokenInterface(swap.tokenIn);\r\n\r\n                PoolInterface pool = PoolInterface(swap.pool);\r\n                if (SwapTokenIn.allowance(address(this), swap.pool) > 0) {\r\n                    SwapTokenIn.approve(swap.pool, 0);\r\n                }\r\n                SwapTokenIn.approve(swap.pool, swap.limitReturnAmount);\r\n\r\n                (tokenAmountInFirstSwap, ) = pool.swapExactAmountOut(\r\n                    swap.tokenIn,\r\n                    swap.limitReturnAmount,\r\n                    swap.tokenOut,\r\n                    swap.swapAmount,\r\n                    swap.maxPrice\r\n                );\r\n            } else {\r\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\r\n                // of token C. But first we need to buy B with A so we can then buy C with B\r\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\r\n                uint256 intermediateTokenAmount; // This would be token B as described above\r\n                Swap memory secondSwap = swapSequences[i][1];\r\n                PoolInterface poolSecondSwap = PoolInterface(secondSwap.pool);\r\n                intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\r\n                    poolSecondSwap.getBalance(secondSwap.tokenIn),\r\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\r\n                    poolSecondSwap.getBalance(secondSwap.tokenOut),\r\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\r\n                    secondSwap.swapAmount,\r\n                    poolSecondSwap.getSwapFee()\r\n                );\r\n\r\n                //// Buy intermediateTokenAmount of token B with A in the first pool\r\n                Swap memory firstSwap = swapSequences[i][0];\r\n                TokenInterface FirstSwapTokenIn =\r\n                    TokenInterface(firstSwap.tokenIn);\r\n                PoolInterface poolFirstSwap = PoolInterface(firstSwap.pool);\r\n                if (\r\n                    FirstSwapTokenIn.allowance(address(this), firstSwap.pool) <\r\n                    uint256(-1)\r\n                ) {\r\n                    FirstSwapTokenIn.approve(firstSwap.pool, uint256(-1));\r\n                }\r\n\r\n                (tokenAmountInFirstSwap, ) = poolFirstSwap.swapExactAmountOut(\r\n                    firstSwap.tokenIn,\r\n                    firstSwap.limitReturnAmount,\r\n                    firstSwap.tokenOut,\r\n                    intermediateTokenAmount, // This is the amount of token B we need\r\n                    firstSwap.maxPrice\r\n                );\r\n\r\n                //// Buy the final amount of token C desired\r\n                TokenInterface SecondSwapTokenIn =\r\n                    TokenInterface(secondSwap.tokenIn);\r\n                if (\r\n                    SecondSwapTokenIn.allowance(\r\n                        address(this),\r\n                        secondSwap.pool\r\n                    ) < uint256(-1)\r\n                ) {\r\n                    SecondSwapTokenIn.approve(secondSwap.pool, uint256(-1));\r\n                }\r\n\r\n                poolSecondSwap.swapExactAmountOut(\r\n                    secondSwap.tokenIn,\r\n                    secondSwap.limitReturnAmount,\r\n                    secondSwap.tokenOut,\r\n                    secondSwap.swapAmount,\r\n                    secondSwap.maxPrice\r\n                );\r\n            }\r\n            totalAmountIn = add(tokenAmountInFirstSwap, totalAmountIn);\r\n        }\r\n\r\n        require(totalAmountIn <= maxTotalAmountIn, 'ERR_LIMIT_IN');\r\n\r\n        transferAll(tokenOut, getBalance(tokenOut));\r\n        transferAll(tokenIn, getBalance(tokenIn));\r\n    }\r\n\r\n    function multihopBatchSwapExactOutDAILike(\r\n        Swap[][] memory swapSequences,\r\n        TokenInterface tokenIn,\r\n        TokenInterface tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        Repay memory repay,\r\n        DAILikePermit memory daiLikePermit\r\n    ) public payable returns (uint256 totalAmountIn) {\r\n        permit(address(tokenIn), daiLikePermit);\r\n        return\r\n            multihopBatchSwapExactOut(\r\n                swapSequences,\r\n                tokenIn,\r\n                tokenOut,\r\n                maxTotalAmountIn,\r\n                repay\r\n            );\r\n    }\r\n\r\n    function multihopBatchSwapExactOutEIP2612Like(\r\n        Swap[][] memory swapSequences,\r\n        TokenInterface tokenIn,\r\n        TokenInterface tokenOut,\r\n        uint256 maxTotalAmountIn,\r\n        Repay memory repay,\r\n        EIP2612LikePermit memory eip2612LikePermit\r\n    ) public payable returns (uint256 totalAmountIn) {\r\n        permit(address(tokenIn), eip2612LikePermit);\r\n        return\r\n            multihopBatchSwapExactOut(\r\n                swapSequences,\r\n                tokenIn,\r\n                tokenOut,\r\n                maxTotalAmountIn,\r\n                repay\r\n            );\r\n    }\r\n\r\n    function() external payable {}\r\n}"
    }
  }
}