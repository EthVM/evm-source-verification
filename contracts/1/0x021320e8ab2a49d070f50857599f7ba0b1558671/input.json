{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "map_heco.sol": {
      "content": "pragma solidity ^0.6.12;\r\npragma experimental ABIEncoderV2;\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint256);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IMdexPair {\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  constructor () internal {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ow1\");\r\n    _;\r\n  }\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ow2\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"mul e0\");\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"div e0\");\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Map is Ownable {\r\n  using SafeMath for uint256;\r\n  IERC20 private r_fee_token;\r\n  IERC20 private r_usdt_token;\r\n  IMdexPair private r_fee_pair;\r\n  address private r_router_address;\r\n  uint256 private r_tx_fee_rate;\r\n  uint256 private r_tx_fee_type;\r\n  address private r_tx_fee_address;\r\n\r\n\r\n  struct token_info_item {\r\n    address token_address;\r\n    string name;\r\n    string symbol;\r\n    uint256 decimals;\r\n    uint256 balance;\r\n  }\r\n\r\n  function getTokenInfo(IERC20 _token, address _user) public view returns (token_info_item memory token_info) {\r\n    token_info.token_address = address(_token);\r\n    token_info.name = _token.name();\r\n    token_info.symbol = _token.symbol();\r\n    token_info.decimals = _token.decimals();\r\n    token_info.balance = _token.balanceOf(_user);\r\n  }\r\n\r\n  function set(IERC20 _fee_token, IERC20 _usdt_token, IMdexPair _fee_pair, address _router_address, uint256 _tx_fee_rate, uint256 _tx_fee_type, address _tx_fee_address) public onlyOwner {\r\n    r_fee_token = _fee_token;\r\n    r_usdt_token = _usdt_token;\r\n    r_fee_pair = _fee_pair;\r\n    r_router_address = _router_address;\r\n    r_tx_fee_rate = _tx_fee_rate;\r\n    r_tx_fee_type = _tx_fee_type;\r\n    r_tx_fee_address = _tx_fee_address;\r\n  }\r\n\r\n  function setTxFeeRate(uint256 _tx_fee_rate) public onlyOwner {\r\n    r_tx_fee_rate = _tx_fee_rate;\r\n  }\r\n\r\n  function setTxFeeType(uint256 _tx_fee_type) public onlyOwner {\r\n    r_tx_fee_type = _tx_fee_type;\r\n  }\r\n\r\n  function getPrice() internal view returns (uint256) {\r\n    if (address(r_fee_pair) == address(0)) {\r\n      return 0;\r\n    }\r\n    address token0_new = IMdexPair(r_fee_pair).token0();\r\n    address token1_new = IMdexPair(r_fee_pair).token1();\r\n    (uint256 _reserve0,uint256  _reserve1,) = IMdexPair(r_fee_pair).getReserves();\r\n    uint256 decimals0 = IERC20(token0_new).decimals();\r\n    uint256 decimals1 = IERC20(token1_new).decimals();\r\n    uint256 price1 = _reserve0.mul(10 ** 18).mul(10 ** decimals1).div(_reserve1).div(10 ** decimals0);\r\n    uint256 price2 = _reserve1.mul(10 ** 18).mul(10 ** decimals0).div(_reserve0).div(10 ** decimals1);\r\n    uint256 tx_price;\r\n    if (token0_new == address(r_fee_token))\r\n      tx_price = price1;\r\n    else\r\n      tx_price = price2;\r\n    return tx_price;\r\n  }\r\n\r\n  function getFeeNum() public view returns (uint256 tx_price, uint256 tx_fee_rate, uint256 tx_fee_type, uint256 fee_token_decimals, uint256 usdt_token_decimals, IERC20 fee_token, IERC20 usdt_token, address tx_fee_address, address router_address) {\r\n    tx_price = getPrice();\r\n    tx_fee_rate = r_tx_fee_rate;\r\n    tx_fee_type = r_tx_fee_type;\r\n    fee_token_decimals = 18;\r\n    usdt_token_decimals = 18;\r\n    if (address(r_fee_token) != address(0)) {\r\n      fee_token_decimals = r_fee_token.decimals();\r\n    }\r\n    if (address(r_usdt_token) != address(0)) {\r\n      usdt_token_decimals = r_usdt_token.decimals();\r\n    }\r\n    fee_token = r_fee_token;\r\n    usdt_token = r_usdt_token;\r\n    tx_fee_address = r_tx_fee_address;\r\n    router_address = r_router_address;\r\n  }\r\n\r\n}"
    }
  }
}