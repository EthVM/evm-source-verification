{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Appeth.sol": {
      "content": "pragma solidity 0.4.26;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if(a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"NaN\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b > 0, \"NaN\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b <= a, \"NaN\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"NaN\");\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0, \"NaN\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Roles {\r\n    mapping(string => mapping(address => bool)) private rules;\r\n\r\n    event RoleAdded(string indexed role, address indexed to);\r\n    event RoleRemoved(string indexed role, address indexed to);\r\n\r\n    modifier onlyHasRole(string _role) {\r\n        require(rules[_role][msg.sender], \"Access denied\");\r\n        _;\r\n    }\r\n\r\n    function hasRole(string _role, address _to) view public returns(bool) {\r\n        require(_to != address(0), \"Zero address\");\r\n\r\n        return rules[_role][_to];\r\n    }\r\n\r\n    function addRole(string _role, address _to) internal {\r\n        require(_to != address(0), \"Zero address\");\r\n\r\n        rules[_role][_to] = true;\r\n\r\n        emit RoleAdded(_role, _to);\r\n    }\r\n\r\n    function removeRole(string _role, address _to) internal {\r\n        require(_to != address(0), \"Zero address\");\r\n\r\n        rules[_role][_to] = false;\r\n        \r\n        emit RoleRemoved(_role, _to);\r\n    }\r\n}\r\n\r\ncontract Appeth is Roles {\r\n    using SafeMath for uint;\r\n\r\n    struct Investor {\r\n        uint invested;\r\n        uint last_payout;\r\n    }\r\n\r\n    struct Admin {\r\n        uint percent;\r\n        uint timeout;\r\n        uint min_balance;\r\n        uint last_withdraw;\r\n    }\r\n\r\n    mapping(address => Investor) public investors;\r\n    mapping(address => bool) public blockeds;\r\n    mapping(address => Admin) public admins;\r\n\r\n    event Payout(address indexed holder, uint etherAmount);\r\n    event Deposit(address indexed holder, uint etherAmount);\r\n    event WithdrawEther(address indexed to, uint etherAmount);\r\n    event Blocked(address indexed holder);\r\n    event UnBlocked(address indexed holder);\r\n\r\n    constructor() public {\r\n        addRole(\"manager\", 0xa9515D17e53e9b2e22df2943EA03cB8539862501);\r\n\r\n\t\tadmins[0x4D845160118c26ED399B8b86c4B2b5B62c180447] = Admin(10, 0, 50 ether, 0);\r\n    }\r\n\r\n    function investorBonusSize(address _to) view public returns(uint) {\r\n        uint b = investors[_to].invested;\r\n\r\n        if(b >= 24 ether) return 25;\r\n        if(b >= 15 ether) return 18;\r\n        if(b >= 9 ether) return 12;\r\n        if(b >= 5 ether) return 8;\r\n        if(b >= 2 ether) return 5;\r\n        return 3;\r\n    }\r\n\r\n    function payoutSize(address _to) view public returns(uint) {\r\n        uint invested = investors[_to].invested;\r\n\r\n        if(invested == 0) return 0;\r\n\r\n        return invested.mul(investorBonusSize(_to)).div(100).mul(block.timestamp.sub(investors[_to].last_payout)).div(1 days);\r\n    }\r\n\r\n    function bytesToAddress(bytes bys) pure private returns(address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function() payable external {\r\n        if(hasRole(\"manager\", msg.sender)) {\r\n            require(msg.data.length > 0, \"Send the address in data\");\r\n\r\n            address addr = bytesToAddress(msg.data);\r\n\r\n            require(!hasRole(\"manager\", addr) && admins[addr].percent == 0, \"This address is manager\");\r\n\r\n            if(!blockeds[addr]) {\r\n                blockeds[addr] = true;\r\n                emit Blocked(addr);\r\n            }\r\n            else {\r\n                blockeds[addr] = false;\r\n                emit UnBlocked(addr);\r\n            }\r\n            \r\n            if(msg.value > 0) {\r\n                msg.sender.transfer(msg.value);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if(investors[msg.sender].invested > 0 && !blockeds[msg.sender]) {\r\n            uint payout = payoutSize(msg.sender);\r\n\r\n            require(msg.value > 0 || payout > 0, \"No payouts\");\r\n\r\n            if(payout > 0) {\r\n                investors[msg.sender].last_payout = block.timestamp;\r\n\r\n                msg.sender.transfer(payout);\r\n\r\n                emit Payout(msg.sender, payout);\r\n            }\r\n        }\r\n\r\n        if(msg.value > 0) {\r\n            if (msg.value == 0.0001 ether) {\r\n                if(blockeds[msg.sender]) {\r\n                    return;\r\n                }\r\n\r\n                uint amount = investors[msg.sender].invested;\r\n\r\n                investors[msg.sender].invested = investors[msg.sender].invested.sub(amount);\r\n                \r\n                msg.sender.transfer(amount);\r\n\r\n                emit WithdrawEther(msg.sender, amount);\r\n\r\n                return;\r\n            } \r\n\r\n            require(msg.value >= 0.01 ether, \"Minimum investment amount 0.01 ether\");\r\n\r\n            investors[msg.sender].last_payout = block.timestamp;\r\n            investors[msg.sender].invested = investors[msg.sender].invested.add(msg.value);\r\n                \r\n            emit Deposit(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function withdrawEther(address _to) public {\r\n        Admin storage admin = admins[msg.sender];\r\n        uint balance = address(this).balance;\r\n\r\n        require(admin.percent > 0, \"Access denied\");\r\n        require(admin.timeout == 0 || block.timestamp > admin.last_withdraw.add(admin.timeout), \"Timeout\");\r\n        require(_to != address(0), \"Zero address\");\r\n        require(balance > 0, \"Not enough balance\");\r\n\r\n        uint amount = balance > admin.min_balance ? balance.div(100).mul(admin.percent) : balance;\r\n\r\n        admin.last_withdraw = block.timestamp;\r\n\r\n        _to.transfer(amount);\r\n\r\n        emit WithdrawEther(_to, amount);\r\n    }\r\n}"
    }
  }
}