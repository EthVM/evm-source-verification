{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/DeployDebtPopperRewards.sol":{"content":"pragma solidity 0.6.7;\n\ncontract GebMath {\n    uint256 public constant RAY = 10 ** 27;\n    uint256 public constant WAD = 10 ** 18;\n\n    function ray(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 9);\n    }\n    function rad(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 27);\n    }\n    function minimum(uint x, uint y) public pure returns (uint z) {\n        z = (x <= y) ? x : y;\n    }\n    function addition(uint x, uint y) public pure returns (uint z) {\n        z = x + y;\n        require(z >= x, \"uint-uint-add-overflow\");\n    }\n    function subtract(uint x, uint y) public pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function multiply(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n\nabstract contract StabilityFeeTreasuryLike {\n    function getAllowance(address) virtual external view returns (uint, uint);\n    function systemCoin() virtual external view returns (address);\n    function pullFunds(address, address, uint) virtual external;\n    function setTotalAllowance(address, uint256) external virtual;\n    function setPerBlockAllowance(address, uint256) external virtual;    \n}\n\ncontract MandatoryFixedTreasuryReimbursement is GebMath {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"MandatoryFixedTreasuryReimbursement/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    // The fixed reward sent by the treasury to a fee receiver\n    uint256 public fixedReward;               // [wad]\n    // SF treasury\n    StabilityFeeTreasuryLike public treasury;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(\n      bytes32 parameter,\n      address addr\n    );\n    event ModifyParameters(\n      bytes32 parameter,\n      uint256 val\n    );\n    event RewardCaller(address indexed finalFeeReceiver, uint256 fixedReward);\n\n    constructor(address treasury_, uint256 fixedReward_) public {\n        require(fixedReward_ > 0, \"MandatoryFixedTreasuryReimbursement/null-reward\");\n        require(treasury_ != address(0), \"MandatoryFixedTreasuryReimbursement/null-treasury\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        treasury    = StabilityFeeTreasuryLike(treasury_);\n        fixedReward = fixedReward_;\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"treasury\", treasury_);\n        emit ModifyParameters(\"fixedReward\", fixedReward);\n    }\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Treasury Utils ---\n    /*\n    * @notify Return the amount of SF that the treasury can transfer in one transaction when called by this contract\n    */\n    function treasuryAllowance() public view returns (uint256) {\n        (uint total, uint perBlock) = treasury.getAllowance(address(this));\n        return minimum(total, perBlock);\n    }\n    /*\n    * @notify Get the actual reward to be sent by taking the minimum between the fixed reward and the amount that can be sent by the treasury\n    */\n    function getCallerReward() public view returns (uint256 reward) {\n        reward = minimum(fixedReward, treasuryAllowance() / RAY);\n    }\n    /*\n    * @notice Send a SF reward to a fee receiver by calling the treasury\n    * @param proposedFeeReceiver The address that will receive the reward (unless null in which case msg.sender will receive it)\n    */\n    function rewardCaller(address proposedFeeReceiver) internal {\n        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, revert\n        require(address(treasury) != proposedFeeReceiver, \"MandatoryFixedTreasuryReimbursement/reward-receiver-cannot-be-treasury\");\n        require(both(address(treasury) != address(0), fixedReward > 0), \"MandatoryFixedTreasuryReimbursement/invalid-treasury-or-reward\");\n\n        // Determine the actual fee receiver and reward them\n        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\n        uint256 finalReward      = getCallerReward();\n        treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), finalReward);\n\n        emit RewardCaller(finalFeeReceiver, finalReward);\n    }\n}\n\nabstract contract AccountingEngineLike {\n    function debtPoppers(uint256) virtual public view returns (address);\n}\n\ncontract DebtPopperRewards is MandatoryFixedTreasuryReimbursement {\n    // --- Variables ---\n    // When the next reward period starts\n    uint256 public rewardPeriodStart;                    // [unix timestamp]\n    // Delay between two consecutive reward periods\n    uint256 public interPeriodDelay;                     // [seconds]\n    // Time (after a block of debt is popped) after which no reward can be given anymore\n    uint256 public rewardTimeline;                       // [seconds]\n    // Amount of pops that can be rewarded per period\n    uint256 public maxPerPeriodPops;\n    // Timestamp from which the contract accepts requests for rewarding debt poppers\n    uint256 public rewardStartTime;\n\n    // Whether a debt block has been popped\n    mapping(uint256 => bool)    public rewardedPop;      // [unix timestamp => bool]\n    // Amount of pops that were rewarded in each period\n    mapping(uint256 => uint256) public rewardsPerPeriod; // [unix timestamp => wad]\n\n    // Accounting engine contract\n    AccountingEngineLike        public accountingEngine;\n\n    // --- Events ---\n    event SetRewardPeriodStart(uint256 rewardPeriodStart);\n    event RewardForPop(uint256 slotTimestamp, uint256 reward);\n\n    constructor(\n        address accountingEngine_,\n        address treasury_,\n        uint256 rewardPeriodStart_,\n        uint256 interPeriodDelay_,\n        uint256 rewardTimeline_,\n        uint256 fixedReward_,\n        uint256 maxPerPeriodPops_,\n        uint256 rewardStartTime_\n    ) public MandatoryFixedTreasuryReimbursement(treasury_, fixedReward_) {\n        require(rewardPeriodStart_ >= now, \"DebtPopperRewards/invalid-reward-period-start\");\n        require(interPeriodDelay_ > 0, \"DebtPopperRewards/invalid-inter-period-delay\");\n        require(rewardTimeline_ > 0, \"DebtPopperRewards/invalid-harvest-timeline\");\n        require(maxPerPeriodPops_ > 0, \"DebtPopperRewards/invalid-max-per-period-pops\");\n        require(accountingEngine_ != address(0), \"DebtPopperRewards/null-accounting-engine\");\n\n        accountingEngine   = AccountingEngineLike(accountingEngine_);\n\n        rewardPeriodStart  = rewardPeriodStart_;\n        interPeriodDelay   = interPeriodDelay_;\n        rewardTimeline     = rewardTimeline_;\n        fixedReward        = fixedReward_;\n        maxPerPeriodPops   = maxPerPeriodPops_;\n        rewardStartTime    = rewardStartTime_;\n\n        emit ModifyParameters(\"accountingEngine\", accountingEngine_);\n        emit ModifyParameters(\"interPeriodDelay\", interPeriodDelay);\n        emit ModifyParameters(\"rewardTimeline\", rewardTimeline);\n        emit ModifyParameters(\"rewardStartTime\", rewardStartTime);\n        emit ModifyParameters(\"maxPerPeriodPops\", maxPerPeriodPops);\n\n        emit SetRewardPeriodStart(rewardPeriodStart);\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Modify a uint256 parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n        require(val > 0, \"DebtPopperRewards/invalid-value\");\n        if (parameter == \"interPeriodDelay\") {\n          interPeriodDelay = val;\n        }\n        else if (parameter == \"rewardTimeline\") {\n          rewardTimeline = val;\n        }\n        else if (parameter == \"fixedReward\") {\n          require(val > 0, \"DebtPopperRewards/null-reward\");\n          fixedReward = val;\n        }\n        else if (parameter == \"maxPerPeriodPops\") {\n          maxPerPeriodPops = val;\n        }\n        else if (parameter == \"rewardPeriodStart\") {\n          require(val > now, \"DebtPopperRewards/invalid-reward-period-start\");\n          rewardPeriodStart = val;\n        }\n        else revert(\"DebtPopperRewards/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n    /*\n    * @notify Set a new treasury address\n    * @param parameter The parameter name\n    * @param addr The new address for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        require(addr != address(0), \"DebtPopperRewards/null-address\");\n        if (parameter == \"treasury\") treasury = StabilityFeeTreasuryLike(addr);\n        else revert(\"DebtPopperRewards/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, addr);\n    }\n\n    /*\n    * @notify Get rewarded for popping a debt slot from the AccountingEngine debt queue\n    * @oaran slotTimestamp The time of the popped slot\n    * @param feeReceiver The address that will receive the reward for popping\n    */\n    function getRewardForPop(uint256 slotTimestamp, address feeReceiver) external {\n        // Perform checks\n        require(slotTimestamp >= rewardStartTime, \"DebtPopperRewards/slot-time-before-reward-start\");\n        require(slotTimestamp < now, \"DebtPopperRewards/slot-cannot-be-in-the-future\");\n        require(now >= rewardPeriodStart, \"DebtPopperRewards/wait-more\");\n        require(addition(slotTimestamp, rewardTimeline) >= now, \"DebtPopperRewards/missed-reward-window\");\n        require(accountingEngine.debtPoppers(slotTimestamp) == msg.sender, \"DebtPopperRewards/not-debt-popper\");\n        require(!rewardedPop[slotTimestamp], \"DebtPopperRewards/pop-already-rewarded\");\n        require(getCallerReward() >= fixedReward, \"DebtPopperRewards/invalid-available-reward\");\n\n        // Update state\n        rewardedPop[slotTimestamp]          = true;\n        rewardsPerPeriod[rewardPeriodStart] = addition(rewardsPerPeriod[rewardPeriodStart], 1);\n\n        // If we offered rewards for too many pops, enforce a delay since rewards are available again\n        if (rewardsPerPeriod[rewardPeriodStart] >= maxPerPeriodPops) {\n          rewardPeriodStart = addition(now, interPeriodDelay);\n          emit SetRewardPeriodStart(rewardPeriodStart);\n        }\n\n        emit RewardForPop(slotTimestamp, fixedReward);\n\n        // Give the reward\n        rewardCaller(feeReceiver);\n    }\n}\n\ncontract DeployDebtPopperRewards {\n    // --- Variables ---\n    uint256 public constant WAD = 10**18;\n    uint256 public constant RAY = 10**27;\n    uint256 public constant RAD = 10**45;\n\n    function execute(\n        address _accountingEngine,\n        address _treasury\n    ) public returns (address) {\n        // Define params\n        uint256 rewardPeriodStart = now;\n        uint256 interPeriodDelay = 1209600;\n        uint256 rewardTimeline = 4838400;\n        uint256 fixedReward = 5 * WAD;\n        uint256 maxPerPeriodPops = 10;\n        uint256 rewardStartTime = now;\n\n        // deploy the throttler\n        DebtPopperRewards popperRewards = new DebtPopperRewards(\n            _accountingEngine,\n            _treasury,\n            rewardPeriodStart,\n            interPeriodDelay,\n            rewardTimeline,\n            fixedReward,\n            maxPerPeriodPops,\n            rewardStartTime\n\n        );\n\n        // setting allowances in the SF treasury\n        StabilityFeeTreasuryLike(_treasury).setPerBlockAllowance(address(popperRewards), 1 * RAD);\n        StabilityFeeTreasuryLike(_treasury).setTotalAllowance(address(popperRewards), uint(-1));\n\n        return address(popperRewards);\n    }\n}\n"}}}