{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BubbleBudzProxyMint.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// Open0x Ownable (by 0xInuarashi)\r\nabstract contract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed oldOwner_, address indexed newOwner_);\r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function _transferOwnership(address newOwner_) internal virtual {\r\n        address _oldOwner = owner;\r\n        owner = newOwner_;\r\n        emit OwnershipTransferred(_oldOwner, newOwner_);    \r\n    }\r\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\r\n        require(newOwner_ != address(0x0), \"Ownable: new owner is the zero address!\");\r\n        _transferOwnership(newOwner_);\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0x0));\r\n    }\r\n}\r\n\r\nabstract contract PayableGovernance is Ownable {\r\n    // Receivable Fallback\r\n    event Received(address from, uint amount);\r\n    receive() external payable { emit Received(msg.sender, msg.value); }\r\n\r\n    // Payable Governance\r\n    mapping(address => bool) internal shareholderToUnlockGovernance;\r\n\r\n    address internal Shareholder_1 = 0x1D628369DD259660482bf6c14Cb558F8d69a8242; // Chief\r\n    address internal Shareholder_2 = 0x1eD3D146cb5945e1C894A70013Ed83F95693EA22; // 0xInuarashi\r\n\r\n    uint internal Shareholder_1_Share = 80; // Chief\r\n    uint internal Shareholder_2_Share = 20; // 0xInuarashi\r\n\r\n    function withdrawEther() public onlyOwner {\r\n        uint _totalETH = address(this).balance; // balance of contract\r\n\r\n        uint _Shareholder_1_ETH = ((_totalETH * Shareholder_1_Share) / 100); \r\n        uint _Shareholder_2_ETH = ((_totalETH * Shareholder_2_Share) / 100); \r\n\r\n        payable(Shareholder_1).transfer(_Shareholder_1_ETH);\r\n        payable(Shareholder_2).transfer(_Shareholder_2_ETH);\r\n    }\r\n    function viewWithdrawEtherAmounts() public view onlyOwner returns (uint[] memory) {\r\n        uint _totalETH = address(this).balance;\r\n        uint[] memory _ethToSendArray = new uint[](4);\r\n\r\n        uint _Shareholder_1_ETH = ((_totalETH * Shareholder_1_Share) / 100); \r\n        uint _Shareholder_2_ETH = ((_totalETH * Shareholder_2_Share) / 100); \r\n\r\n        _ethToSendArray[0] = _Shareholder_1_ETH;\r\n        _ethToSendArray[1] = _Shareholder_2_ETH;\r\n        _ethToSendArray[2] = _totalETH;\r\n        _ethToSendArray[3] = _Shareholder_1_ETH + _Shareholder_2_ETH; \r\n\r\n        return _ethToSendArray;\r\n    }\r\n\r\n    // Payable Governance Emergency Functions\r\n    modifier onlyShareholder {\r\n        require(msg.sender == Shareholder_1 || msg.sender == Shareholder_2, \"You are not a shareholder!\");\r\n        _;\r\n    }\r\n    modifier emergencyOnly {\r\n        require(shareholderToUnlockGovernance[Shareholder_1] && shareholderToUnlockGovernance[Shareholder_2], \"Emergency Functions have not been unlocked!\");\r\n        _;\r\n    }\r\n\r\n    function unlockEmergencyFunctionsAsShareholder() public onlyShareholder {\r\n        shareholderToUnlockGovernance[msg.sender] = true;\r\n    }\r\n    function emergencyWithdrawEther() public onlyOwner emergencyOnly {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function checkGovernanceStatus(address address_) public view onlyShareholder returns (bool) {  \r\n        return shareholderToUnlockGovernance[address_];\r\n    }\r\n}\r\n\r\ninterface iBubbleBudz {\r\n    function ownerMintMany(address to_, uint256 amount_) external;\r\n    function transferOwnership(address newOwner_) external;\r\n    function ownerOf(uint256 tokenId_) external view returns (address);\r\n    function normalTokensLimit() external view returns (uint256);\r\n    function normalTokensMinted() external view returns (uint256);\r\n    function addressToWhitelistMints(address address_) external view returns (uint256);\r\n    function addressToPublicMints(address address_) external view returns (uint256);\r\n    function withdrawEther() external;\r\n}\r\n\r\ncontract BubbleBudzProxyMint is Ownable, PayableGovernance {\r\n    // General NFT Variables\r\n    uint256 public mintPrice = 0.045 ether;\r\n    uint256 public maxMintsPerTx = 50;\r\n\r\n    function setMintPrice(uint256 mintPrice_) external onlyOwner {\r\n        mintPrice = mintPrice_; }\r\n    function setMaxMintsPerTx(uint256 maxMintsPerTx_) external onlyOwner {\r\n        maxMintsPerTx = maxMintsPerTx_; }\r\n\r\n    // Access\r\n    function transferOwnershipOfBubbleBudz(address newOwner_) external onlyOwner {\r\n        BB.transferOwnership(newOwner_);\r\n    }\r\n\r\n    // Interfaces\r\n    iBubbleBudz public BB;\r\n    function setBubbleBudz(address address_) external onlyOwner {\r\n        BB = iBubbleBudz(address_); }\r\n\r\n    // Modifiers\r\n    modifier onlySender{ require(msg.sender == tx.origin, \"No contracts\"); _; }\r\n\r\n    // Owner Mint Logic\r\n    function ownerMint(address to_, uint256 amount_) public onlyOwner {\r\n        BB.ownerMintMany(to_, amount_); }\r\n\r\n    // Minting Proxy Logic\r\n    bool public publicMintEnabled = true;\r\n    modifier publicMint { require(publicMintEnabled, \"Public Mint is not Enabled!\"); _; }\r\n    function setPublicMint(bool bool_) external onlyOwner { publicMintEnabled = bool_; }\r\n\r\n    function mint(uint256 amount_) public payable onlySender publicMint {\r\n        // Checks that mints is remaining, within tx, and has the correct value sent.\r\n        require(BB.normalTokensLimit() >= BB.normalTokensMinted() + amount_, \"No more mints remaining!\");\r\n        require(maxMintsPerTx >= amount_, \"Over maximum mints per tx!\");\r\n        require(msg.value == mintPrice * amount_, \"Invalid value sent!\");\r\n        \r\n        // Mint many to the msg.sender.\r\n        BB.ownerMintMany(msg.sender, amount_); // This calls the main contract to mint\r\n    }\r\n\r\n    // Claiming Proxy Logic\r\n    mapping(address => uint256) public addressToBBClaimed;\r\n\r\n    bool public publicClaimEnabled = true;\r\n    modifier publicClaim { require(publicClaimEnabled, \"Public Claiming is not Enabled!\"); _; }\r\n    function setPublicClaim(bool bool_) external onlyOwner { publicClaimEnabled = bool_; }\r\n\r\n    function claim() public onlySender publicClaim {\r\n        // Querys the amount to claim based on two mappings. Then, checks if claimed already or not. \r\n        // Lastly, check if token supply is enough.\r\n        uint256 _claimable = BB.addressToPublicMints(msg.sender) + BB.addressToWhitelistMints(msg.sender);\r\n        require(addressToBBClaimed[msg.sender] == 0, \"You have already claimed your Bubble Budz!\");\r\n        require(BB.normalTokensLimit() >= BB.normalTokensMinted() + _claimable, \"No more supply remaining!\");\r\n\r\n        // Set the address as claimed with the _claimable amount.\r\n        addressToBBClaimed[msg.sender] += _claimable; // add the claimed amount\r\n\r\n        // Mint many to the msg.sender.\r\n        BB.ownerMintMany(msg.sender, _claimable);\r\n    }\r\n\r\n    // Just In Case\r\n    function BBWithdrawEther() external onlyOwner {\r\n        BB.withdrawEther();\r\n    }\r\n}"}}}