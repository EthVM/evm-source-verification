{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AaveDelegate.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface ILendingPool {\r\n      function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n      ) external;\r\n      \r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 rateMode,\r\n        address onBehalfOf\r\n      ) external returns (uint256);\r\n}\r\n\r\ninterface IyVault {\r\n    function token() external view returns (address);\r\n    function deposit(uint, address) external returns (uint);\r\n    function withdraw(uint, address, uint) external returns (uint);\r\n    function permit(address, address, uint, uint, bytes32) external view returns (bool);\r\n}\r\n\r\ninterface IyRegistry {\r\n    function latestVault(address) external view returns (address);\r\n}\r\n\r\ninterface IProtocolDataProvider {\r\n  function getReserveTokensAddresses(address asset) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\r\n}\r\n\r\ninterface IDebtToken {\r\n    function borrowAllowance(address, address) external view returns (uint);\r\n}\r\n\r\ncontract AaveDelegate {\r\n    ILendingPool constant public lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\r\n    IyRegistry constant public registry = IyRegistry(0xE15461B18EE31b7379019Dc523231C57d1Cbc18c);\r\n    IProtocolDataProvider constant public provider = IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\r\n    \r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n    \r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n    \r\n    function approvalVariable(address token) external view returns (address) {\r\n        (, , address variableDebtTokenAddress) = provider.getReserveTokensAddresses(token);\r\n        return variableDebtTokenAddress;\r\n    }\r\n    \r\n    function approvalStable(address token) external view returns (address) {\r\n        (, address stableDebtTokenAddress, ) = provider.getReserveTokensAddresses(token);\r\n        return stableDebtTokenAddress;\r\n    }\r\n    \r\n    function vault(address token) external view returns (address) {\r\n        return registry.latestVault(token);\r\n    }\r\n    \r\n    function availableVariable(address delegate, address token) external view returns (uint) {\r\n        (, , address variableDebtTokenAddress) = provider.getReserveTokensAddresses(token);\r\n        return IDebtToken(variableDebtTokenAddress).borrowAllowance(delegate, address(this));\r\n    }\r\n    \r\n    function availableStable(address delegate, address token) external view returns (uint) {\r\n        (, address stableDebtTokenAddress, ) = provider.getReserveTokensAddresses(token);\r\n        return IDebtToken(stableDebtTokenAddress).borrowAllowance(delegate, address(this));\r\n    }\r\n    \r\n    function depositAllVariable(address token) external {\r\n        (, , address variableDebtTokenAddress) = provider.getReserveTokensAddresses(token);\r\n        uint256 variableAllowance = IDebtToken(variableDebtTokenAddress).borrowAllowance(msg.sender, address(this));\r\n        _deposit(token, variableAllowance, 2);\r\n    }\r\n    \r\n    function depositAllStable(address token) external {\r\n        (, address stableDebtTokenAddress, ) = provider.getReserveTokensAddresses(token);\r\n        uint256 stableAllowance = IDebtToken(stableDebtTokenAddress).borrowAllowance(msg.sender, address(this));\r\n        _deposit(token, stableAllowance, 1);\r\n    }\r\n    \r\n    function deposit(address token, uint amount, uint interestRateModel) external {\r\n        _deposit(token, amount, interestRateModel);\r\n    }\r\n    \r\n    // Stable: 1, Variable: 2\r\n    function _deposit(address token, uint amount, uint interestRateModel) internal {\r\n        IyVault _vault = IyVault(registry.latestVault(token));\r\n        lendingPool.borrow(token, amount, interestRateModel, 7, msg.sender);\r\n        IERC20(token).approve(address(_vault), amount);\r\n        _vault.deposit(amount, msg.sender);\r\n    }\r\n    \r\n    function withdrawAll(address token, uint maxLoss, uint rateMode) external {\r\n        IyVault _vault = IyVault(registry.latestVault(token));\r\n        _withdraw(_vault, token, IERC20(address(_vault)).balanceOf(msg.sender), maxLoss, rateMode);\r\n    }\r\n    \r\n    function withdrawAllWithPermit(address token, uint maxLoss, uint expiry, bytes32 signature, uint rateMode) external {\r\n        IyVault _vault = IyVault(registry.latestVault(token));\r\n        uint _amount = IERC20(address(_vault)).balanceOf(msg.sender);\r\n        _vault.permit(msg.sender, address(this), _amount, expiry, signature);\r\n        _withdraw(_vault, token, _amount, maxLoss, rateMode);\r\n    }\r\n    \r\n    function withdraw(address token, uint amount, uint maxLoss, uint rateMode) external {\r\n        IyVault _vault = IyVault(registry.latestVault(token));\r\n        _withdraw(_vault, token, amount, maxLoss, rateMode);\r\n    }\r\n    \r\n    function withdrawWithPermit(address token, uint amount, uint maxLoss, uint expiry, bytes32 signature, uint rateMode) external {\r\n        IyVault _vault = IyVault(registry.latestVault(token));\r\n        _vault.permit(msg.sender, address(this), amount, expiry, signature);\r\n        _withdraw(_vault, token, amount, maxLoss, rateMode);\r\n    }\r\n    \r\n    // Stable: 1, Variable: 2\r\n    function _withdraw(IyVault _vault, address token, uint amount, uint maxLoss, uint rateMode) internal {\r\n        safeTransferFrom(address(_vault), msg.sender, address(this), amount);\r\n        uint _amount = _vault.withdraw(amount, address(this), maxLoss);\r\n        IERC20(token).approve(address(lendingPool), _amount);\r\n        lendingPool.repay(token, _amount, rateMode, msg.sender);\r\n        safeTransfer(token, msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n}"
    }
  }
}