{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/LatestOracle.sol":{"content":"pragma solidity > 0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n}\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract Ownable {\r\n    address owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract MonetaryPolicy {\r\n    uint256 public minRebaseTimeIntervalSec;\r\n    uint256 public rebaseWindowOffsetSec;\r\n    uint256 public rebaseWindowLengthSec;    \r\n}\r\n\r\ncontract MarketOracle is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    MonetaryPolicy public policy;\r\n    \r\n    address public liquidityTokenAddress;\r\n\r\n    uint256 public constant zero = uint256(0);\r\n\r\n    uint256 public window;\r\n    uint256 public sumOfStakes;\r\n    uint256 public sumOfWeightedPrices;\r\n\r\n    struct Staker {\r\n        uint256 stake;\r\n        uint256 lastTimeStaked;\r\n    }\r\n\r\n    mapping(address => Staker) public staker;\r\n    \r\n    modifier onlyPolicy() {\r\n        require(address(msg.sender) == address(policy));\r\n        _;\r\n    }\r\n  \r\n    function removeAdmin() external onlyOwner {\r\n        owner = address(0);\r\n    }\r\n  \r\n   function setWindow(uint256 _window) external onlyOwner {\r\n       window = _window;\r\n   }\r\n    \r\n   function setPolicy(address _policyAddress) external onlyOwner {\r\n       policy = MonetaryPolicy(_policyAddress);       \r\n   }\r\n   \r\n   function setLiquidityToken(address _factory, address _donutAddress, address _coffeeAddress) external onlyOwner {\r\n       liquidityTokenAddress = UniswapV2Library.pairFor(_factory, _donutAddress, _coffeeAddress);\r\n   }   \r\n\r\n    function inOracleWindow() public view returns(bool isWithinBounds) {\r\n        uint256 minRebaseTimeIntervalSec_ = policy.minRebaseTimeIntervalSec();\r\n        uint256 rebaseWindowOffsetSec_ = policy.rebaseWindowOffsetSec();\r\n        isWithinBounds = (now.mod(minRebaseTimeIntervalSec_) < rebaseWindowOffsetSec_);\r\n    }    \r\n    \r\n    function inVotingWindow() public view returns(bool isWithinBounds) {\r\n        uint256 lastTimeStaked_ = staker[msg.sender].lastTimeStaked;\r\n        uint256 minRebaseTimeIntervalSec_ = policy.minRebaseTimeIntervalSec();\r\n        uint256 timeVoted_ = (lastTimeStaked_.mod(minRebaseTimeIntervalSec_));\r\n        isWithinBounds = (now.sub(lastTimeStaked_)) > minRebaseTimeIntervalSec_.sub(timeVoted_);\r\n    }\r\n    \r\n    function inUnStakingWindow() public view returns(bool isWithinBounds) {\r\n        uint256 lastTimeStaked_ = staker[msg.sender].lastTimeStaked;\r\n        isWithinBounds = lastTimeStaked_ > zero ? now.sub(lastTimeStaked_) >= window : true;\r\n    }\r\n\r\n    function stake(uint256 _stake) external {\r\n        staker[msg.sender].stake = staker[msg.sender].stake.add(_stake);        \r\n        TransferHelper.safeTransferFrom(liquidityTokenAddress, msg.sender, address(this), _stake);\r\n    }\r\n\r\n    function unstake(uint256 _stake) external {\r\n        require(inUnStakingWindow());\r\n        require(_stake <= staker[msg.sender].stake);\r\n        staker[msg.sender].stake = staker[msg.sender].stake.sub(_stake);        \r\n        TransferHelper.safeTransfer(liquidityTokenAddress, msg.sender, _stake);\r\n    }\r\n\r\n    function vote(uint256 _price) external {\r\n        require(inOracleWindow());\r\n        require(inVotingWindow());\r\n        require(_price >= 1e17 && _price <= 1e19);\r\n        uint256 stake_ = staker[msg.sender].stake;\r\n        sumOfStakes = sumOfStakes.add(stake_);\r\n        sumOfWeightedPrices = sumOfWeightedPrices.add(stake_.mul(_price));\r\n        staker[msg.sender].lastTimeStaked = now;        \r\n    }\r\n\r\n    function getMean() external view returns(uint256 weightedMean_) {\r\n        weightedMean_ = ((sumOfWeightedPrices.mul(1e18)).div(sumOfStakes)).div(1e18);\r\n    }\r\n\r\n    function getData() external onlyPolicy returns(uint256 weightedMean_) {\r\n        weightedMean_ =  sumOfStakes > zero ? ((sumOfWeightedPrices.mul(1e18)).div(sumOfStakes)).div(1e18) : 1e18;\r\n        delete sumOfStakes;\r\n        delete sumOfWeightedPrices;\r\n    }\r\n\r\n    \r\n}"}}}