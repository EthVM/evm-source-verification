{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Untitled.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-11-07\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by .\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves  tokens from the caller's account to .\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that  will be\r\n     * allowed to spend on behalf of  through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets  as the allowance of  over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves  tokens from  to  using the\r\n     * allowance mechanism.  is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when  tokens are moved from one account () to\r\n     * another ().\r\n     *\r\n     * Note that  may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a  for an  is set by\r\n     * a call to {approve}.  is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a  statement to your contract,\r\n * which allows you to call the safe operations as , etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n *  restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's  operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's ~ operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's ~ operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's  operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's  operator. Note: this function uses a\r\n     *  opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's  operator. Note: this function uses a\r\n     *  opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's  operator. This function uses a\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's  operator. This function uses a\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if  is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others,  will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's : sends  wei to\r\n     * , forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by , making them unable to receive funds via\r\n     * . {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to , care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level . A\r\n     * plain is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If  reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * -  must be a contract.\r\n     * - calling  with  must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[], but with\r\n     *  as a fallback revert reason when  reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[],\r\n     * but also transferring  wei to .\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least .\r\n     * - the called Solidity function must be .\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[], but\r\n     * with  as a fallback revert reason when  reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.6.6;\r\n\r\ncontract Wbtcdefi {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeERC20 for IERC20;\r\n\t// USDT contract  Decimals: 6\r\n\tIERC20 public  investToken;\r\n    Token public tevvoToken;\r\n\r\n    address public owner;\r\n    address public refundAllocation;\r\n    uint256 private houseFee = 2;\r\n    uint256 private poolTime = 24 hours;\r\n    uint256 private payoutPeriod = 24 hours;\r\n    uint256 private dailyWinPool = 5;\r\n    uint256 private incomeTimes = 30;\r\n    uint256 private incomeDivide = 10;\r\n    uint256 public roundID;\r\n    uint256 public currUserID;\r\n    uint256 public m1 = 0;\r\n    uint256 public m2 = 0;\r\n    uint256 public totalDeposit = 0;\r\n    uint256 public totalWithdrawn = 0;\r\n    uint256[4] private awardPercentage;\r\n\r\n    struct Leaderboard {\r\n        uint256 amt;\r\n        address addr;\r\n    }\r\n\r\n    Leaderboard[4] public topSponsors;\r\n    \r\n    Leaderboard[4] public lastTopSponsors;\r\n    uint256[4] public lastTopSponsorsWinningAmount;\r\n    address [] public admins;\r\n    uint256 rate = 100000000000000000;// 1 ETH = 100 TVO tokens\r\n        \r\n\r\n    mapping (uint => address) public userList;\r\n    mapping (uint256 => DataStructs.DailyRound) public round;\r\n    mapping (address => DataStructs.User) public player;\r\n    mapping (address => bool) public isLeader;\r\n    mapping (address => DataStructs.PlayerEarnings) public playerEarnings;\r\n    mapping (address => mapping (uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_; \r\n\r\n    /****************************  EVENTS   *****************************************/\r\n\r\n    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\r\n    event investmentEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\r\n    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\r\n    event roundAwardsEvent(address indexed _playerAddress, uint256 indexed _amount);\r\n    event ownershipTransferred(address indexed owner, address indexed newOwner);\r\n\r\n\r\n\r\n    constructor (address _investToken,address _admin, address _tokenToBeUsed, address _refundAllocation) public {\r\n         owner = msg.sender;\r\n         refundAllocation = _refundAllocation;\r\n         investToken = IERC20(_investToken);\r\n         tevvoToken = Token(_tokenToBeUsed);\r\n         roundID = 1;\r\n         round[1].startTime = now;\r\n         round[1].endTime = now + poolTime;\r\n         awardPercentage[0] = 40;\r\n         awardPercentage[1] = 30;\r\n         awardPercentage[2] = 20;\r\n         awardPercentage[3] = 10;\r\n         \r\n         \r\n        currUserID++;\r\n         \r\n        player[_admin].id = currUserID;\r\n        player[_admin].incomeLimitLeft = 500000000000000000000000;\r\n        player[_admin].lastSettledTime = now;\r\n        player[_admin].referralCount = 20;\r\n        playerEarnings[_admin].withdrawableAmount = 15000000000000000000000;\r\n        userList[currUserID] = _admin;\r\n         \r\n         \r\n    }\r\n    \r\n    /****************************  MODIFIERS    *****************************************/\r\n    \r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 100000000000000000 || _eth == 0, \"Minimum contribution amount is 0.1 ETH\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets permissible values for incoming tx\r\n     */\r\n    modifier isallowedValue(uint256 _eth) {\r\n        require(_eth % 100000000000000000 == 0 || _eth == 0, \"Only in multiples of 0.1\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /****************************  CORE LOGIC    *****************************************/\r\n\r\n\r\n    //function to maintain the business logic \r\n    function registerUser(uint256 _referrerID) \r\n    public\r\n    isWithinLimits(msg.value)\r\n    isallowedValue(msg.value)\r\n    payable {\r\n        \r\n        require(_referrerID > 0 && _referrerID <= currUserID, \"Incorrect Referrer ID\");\r\n        require(msg.value > 0, \"Sorry, incorrect amount\");\r\n        address _referrer = userList[_referrerID];\r\n    \r\n        uint256 amount = msg.value;\r\n        if (player[msg.sender].id <= 0) { //if player is a new joinee\r\n        \r\n            currUserID++;\r\n            player[msg.sender].id = currUserID;\r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].currInvestment = amount;\r\n            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].totalInvestment = amount;\r\n            player[msg.sender].referrer = _referrer;\r\n            playerEarnings[msg.sender].withdrawableAmount = amount.mul(15).div(incomeDivide);\r\n            userList[currUserID] = msg.sender;\r\n            \r\n            player[_referrer].referralCount = player[_referrer].referralCount.add(1);\r\n            \r\n            if(_referrer == owner) {\r\n                player[owner].directsIncome = player[owner].directsIncome.add(amount.mul(20).div(100));\r\n                player[owner].totalVolETH += amount;\r\n            }\r\n            else {\r\n                plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                player[_referrer].totalVolETH += amount;\r\n                addSponsorToPool(_referrer);\r\n                //directsReferralBonus(msg.sender, amount);\r\n                investToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n            }\r\n                \r\n              emit registerUserEvent(msg.sender, _referrer);\r\n        }\r\n            //if the player has already joined earlier\r\n        else {\r\n            withdrawEarnings();\r\n            amount += playerEarnings[msg.sender].lockedAmount; \r\n            require(player[msg.sender].incomeLimitLeft == 0, \"limit is still remaining\");\r\n            require(playerEarnings[msg.sender].lockedAmount == player[msg.sender].currInvestment.mul(15).div(incomeDivide));\r\n            _referrer = player[msg.sender].referrer;\r\n            playerEarnings[msg.sender].lockedAmount = 0;\r\n            \r\n            player[msg.sender].lastSettledTime = now;\r\n            player[msg.sender].currInvestment = amount;\r\n            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\r\n            player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\r\n            playerEarnings[msg.sender].withdrawableAmount = amount.mul(15).div(incomeDivide);\r\n            \r\n            if(_referrer == owner) {\r\n                player[owner].directsIncome = player[owner].directsIncome.add(amount.mul(20).div(100));\r\n                player[owner].totalVolETH += amount;\r\n            }\r\n            else {\r\n                plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\r\n                addSponsorToPool(_referrer);\r\n                //directsReferralBonus(msg.sender, amount);\r\n                investToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n            }\r\n        }\r\n            \r\n            //add amount to daily pool\r\n            round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\r\n            //transfer 2% to  admin\r\n            \r\n            investToken.safeTransfer( address(uint160(owner)), amount.mul(houseFee).div(100));\r\n\t\t    for(uint i=0; i<admins.length; i++){\r\n\t\t        investToken.safeTransfer( address(uint160(admins[i])), amount.div(100));\r\n\t\t    }\r\n\t    \tinvestToken.safeTransfer( address(uint160(refundAllocation)), amount.mul(3).div(100));\r\n            \r\n            \r\n            \r\n            \r\n            \r\n            \r\n//            address(uint160(owner)).transfer(amount.mul(houseFee).div(100));\r\n           \r\n//            for(uint i=0; i<admins.length; i++){\r\n//                address(uint160(admins[i])).transfer(amount.div(100));\r\n//            }\r\n            \r\n//            address(uint160(refundAllocation)).transfer(amount.mul(3).div(100));\r\n            \r\n            //calculate token rewards\r\n//            uint256 tokensToAward = amount.div(rate).mul(10e18);\r\n//            tevvoToken.transfer(msg.sender,tokensToAward);\r\n                \r\n            //check if round time has finished\r\n            if (now > round[roundID].endTime && round[roundID].ended == false) {\r\n                startNextRound();\r\n            }\r\n            totalDeposit += amount;\r\n            \r\n            emit investmentEvent (msg.sender, amount);\r\n    }\r\n    \r\n    function directsReferralBonus(address _playerAddress, uint256 amount)\r\n    private\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        \r\n        if(isLeader[_nextReferrer] == true){\r\n            if (player[_nextReferrer].incomeLimitLeft >= amount.mul(30).div(100)) {\r\n                player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.mul(30).div(100));\r\n                player[_nextReferrer].directsIncome = player[_nextReferrer].directsIncome.add(amount.mul(30).div(100));\r\n            \r\n                emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.mul(30).div(100), now);                        \r\n            }\r\n            else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                player[_nextReferrer].directsIncome = player[_nextReferrer].directsIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                m1 = m1.add(amount.mul(30).div(100).sub(player[_nextReferrer].incomeLimitLeft));\r\n                emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                player[_nextReferrer].incomeLimitLeft = 0;\r\n            }\r\n            else  {\r\n                m1 = m1.add(amount.mul(30).div(100)); //make a note of the missed commission;\r\n            }\r\n        }\r\n        else {\r\n            if (player[_nextReferrer].incomeLimitLeft >= amount.mul(20).div(100)) {\r\n                player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.mul(20).div(100));\r\n                player[_nextReferrer].directsIncome = player[_nextReferrer].directsIncome.add(amount.mul(20).div(100));\r\n            \r\n                emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.mul(20).div(100), now);                        \r\n            }\r\n            else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                player[_nextReferrer].directsIncome = player[_nextReferrer].directsIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                m1 = m1.add(amount.mul(20).div(100).sub(player[_nextReferrer].incomeLimitLeft));\r\n                emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                player[_nextReferrer].incomeLimitLeft = 0;\r\n            }\r\n            else  {\r\n                m1 = m1.add(amount.mul(20).div(100)); //make a note of the missed commission;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    //function to manage the matching bonus from the daily ROI\r\n    function roiReferralBonus(address _playerAddress, uint256 amount)\r\n    private\r\n    {\r\n        address _nextReferrer = player[_playerAddress].referrer;\r\n        uint256 _amountLeft = amount.div(2);\r\n        uint i;\r\n\r\n        for(i=0; i < 25; i++) {\r\n            \r\n            if (_nextReferrer != address(0x0)) {\r\n                if(i == 0) {\r\n                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\r\n                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\r\n                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(2));\r\n                        \r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);\r\n                        \r\n                    } else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                        m2 = m2.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\r\n                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                        player[_nextReferrer].incomeLimitLeft = 0;\r\n                        \r\n                    }\r\n                    else {\r\n                        m2 = m2.add(amount.div(2)); \r\n                    }\r\n                    _amountLeft = _amountLeft.sub(amount.div(2));                \r\n                }\r\n                else { // for users 2-25\r\n                    if(player[_nextReferrer].referralCount >= i+1) {\r\n                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\r\n                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\r\n                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(20));\r\n                            \r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\r\n                        \r\n                        }else if(player[_nextReferrer].incomeLimitLeft !=0) {\r\n                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\r\n                            m2 = m2.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\r\n                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\r\n                            player[_nextReferrer].incomeLimitLeft = 0;                        \r\n                        }\r\n                        else {\r\n                            m2 = m2.add(amount.div(20)); \r\n                        }\r\n                    }\r\n                    else {\r\n                         m2 = m2.add(amount.div(20)); //make a note of the missed commission;\r\n                    }\r\n                }\r\n            }   \r\n            else {\r\n                    m2 = m2.add((uint(25).sub(i)).mul(amount.div(20)).add(_amountLeft)); \r\n                    break;                \r\n            }\r\n            _nextReferrer = player[_nextReferrer].referrer;\r\n        }\r\n    }\r\n    \r\n\r\n    //method to settle and withdraw the daily ROI\r\n    function settleIncome(address _playerAddress)\r\n    private {\r\n        \r\n            \r\n        uint256 remainingTimeForPayout;\r\n        uint256 currInvestedAmount;\r\n            \r\n        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) {\r\n            \r\n            //calculate how much time has passed since last settlement\r\n            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\r\n            uint256 _dailyIncome;\r\n            //calculate how many number of days, payout is remaining\r\n            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\r\n            \r\n            currInvestedAmount = player[_playerAddress].currInvestment;\r\n            //calculate 2.5% of his invested amount\r\n            _dailyIncome = currInvestedAmount.div(40);\r\n            //check his income limit remaining\r\n            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) {\r\n                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\r\n                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\r\n                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\r\n                roiReferralBonus(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\r\n            }\r\n            //if person income limit lesser than the daily ROI\r\n            else if(player[_playerAddress].incomeLimitLeft !=0) {\r\n                uint256 temp;\r\n                temp = player[_playerAddress].incomeLimitLeft;                 \r\n                player[_playerAddress].incomeLimitLeft = 0;\r\n                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\r\n                player[_playerAddress].lastSettledTime = now;\r\n                emit dailyPayoutEvent( _playerAddress, temp, now);\r\n                roiReferralBonus(_playerAddress, temp);\r\n            }         \r\n        }\r\n        \r\n    }\r\n    \r\n\r\n    //function to allow users to withdraw their earnings\r\n    function withdrawEarnings() \r\n    public {\r\n        \r\n        address _playerAddress = msg.sender;\r\n        \r\n        //settle the daily dividend\r\n        settleIncome(_playerAddress);\r\n        \r\n        uint256 _earnings =\r\n                    player[_playerAddress].dailyIncome +\r\n                    player[_playerAddress].directsIncome +\r\n                    player[_playerAddress].roiReferralIncome +\r\n                    player[_playerAddress].sponsorPoolIncome ;\r\n                    \r\n        uint256 contractBalance = investToken.balanceOf(address(this));\r\n        require(contractBalance >= _earnings, \"Oops, short of amount in contract\");\r\n\r\n        //can only withdraw if they have some earnings.         \r\n        if(_earnings > 0) {\r\n            if(_earnings <= playerEarnings[msg.sender].withdrawableAmount) {\r\n                playerEarnings[msg.sender].withdrawableAmount -= _earnings;\r\n            }\r\n            else {\r\n                playerEarnings[msg.sender].lockedAmount += _earnings.sub(playerEarnings[msg.sender].withdrawableAmount);\r\n                _earnings = playerEarnings[msg.sender].withdrawableAmount;\r\n                playerEarnings[msg.sender].withdrawableAmount = 0;\r\n            }\r\n            \r\n            player[_playerAddress].dailyIncome = 0;\r\n            player[_playerAddress].directsIncome = 0;\r\n            player[_playerAddress].roiReferralIncome = 0;\r\n            player[_playerAddress].sponsorPoolIncome = 0;\r\n            \r\n            totalWithdrawn += _earnings;\r\n            investToken.safeTransfer( msg.sender, _earnings);\r\n//            address(uint160(_playerAddress)).transfer(_earnings);\r\n            emit withdrawEvent(_playerAddress, _earnings, now);\r\n        }\r\n        \r\n        if (now > round[roundID].endTime && round[roundID].ended == false) {\r\n                startNextRound();\r\n            }\r\n    }\r\n    \r\n    \r\n    //To start the new round for daily pool\r\n    function startNextRound()\r\n    private\r\n     {\r\n        uint256 _roundID = roundID;\r\n       \r\n        uint256 _poolAmount = round[roundID].pool;\r\n        \r\n            if (_poolAmount >= 10 ether) {\r\n                round[_roundID].ended = true;\r\n                uint256 distributedSponsorAwards = awardTopPromoters();\r\n                \r\n                _roundID++;\r\n                roundID++;\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n                round[_roundID].pool = _poolAmount.sub(distributedSponsorAwards);\r\n            }\r\n            else {\r\n                round[_roundID].startTime = now;\r\n                round[_roundID].endTime = now.add(poolTime);\r\n                round[_roundID].pool = _poolAmount;\r\n            }\r\n        \r\n    }\r\n\r\n\r\n    \r\n    function addSponsorToPool(address _add)\r\n        private\r\n        returns (bool)\r\n    {\r\n        if (_add == address(0x0)){\r\n            return false;\r\n        }\r\n\r\n        uint256 _amt = plyrRnds_[_add][roundID].ethVolume;\r\n        // if the amount is less than the last on the leaderboard, reject\r\n        if (topSponsors[3].amt >= _amt){\r\n            return false;\r\n        }\r\n\r\n        address firstAddr = topSponsors[0].addr;\r\n        uint256 firstAmt = topSponsors[0].amt;\r\n        \r\n        address secondAddr = topSponsors[1].addr;\r\n        uint256 secondAmt = topSponsors[1].amt;\r\n        \r\n        address thirdAddr = topSponsors[2].addr;\r\n        uint256 thirdAmt = topSponsors[2].amt;\r\n        \r\n\r\n\r\n        // if the user should be at the top\r\n        if (_amt > topSponsors[0].amt){\r\n\r\n            if (topSponsors[0].addr == _add){\r\n                topSponsors[0].amt = _amt;\r\n                return true;\r\n            }\r\n            //if user is at the second position already and will come on first\r\n            else if (topSponsors[1].addr == _add){\r\n\r\n                topSponsors[0].addr = _add;\r\n                topSponsors[0].amt = _amt;\r\n                topSponsors[1].addr = firstAddr;\r\n                topSponsors[1].amt = firstAmt;\r\n                return true;\r\n            }\r\n            //if user is at the third position and will come on first\r\n            else if (topSponsors[2].addr == _add) {\r\n                topSponsors[0].addr = _add;\r\n                topSponsors[0].amt = _amt;\r\n                topSponsors[1].addr = firstAddr;\r\n                topSponsors[1].amt = firstAmt;\r\n                topSponsors[2].addr = secondAddr;\r\n                topSponsors[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n            else{\r\n\r\n                topSponsors[0].addr = _add;\r\n                topSponsors[0].amt = _amt;\r\n                topSponsors[1].addr = firstAddr;\r\n                topSponsors[1].amt = firstAmt;\r\n                topSponsors[2].addr = secondAddr;\r\n                topSponsors[2].amt = secondAmt;\r\n                topSponsors[3].addr = thirdAddr;\r\n                topSponsors[3].amt = thirdAmt;\r\n                return true;\r\n            }\r\n        }\r\n        // if the user should be at the second position\r\n        else if (_amt > topSponsors[1].amt){\r\n\r\n            if (topSponsors[1].addr == _add){\r\n                topSponsors[1].amt = _amt;\r\n                return true;\r\n            }\r\n            //if user is at the third position, move it to second\r\n            else if(topSponsors[2].addr == _add) {\r\n                topSponsors[1].addr = _add;\r\n                topSponsors[1].amt = _amt;\r\n                topSponsors[2].addr = secondAddr;\r\n                topSponsors[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n            else{\r\n                topSponsors[1].addr = _add;\r\n                topSponsors[1].amt = _amt;\r\n                topSponsors[2].addr = secondAddr;\r\n                topSponsors[2].amt = secondAmt;\r\n                topSponsors[3].addr = thirdAddr;\r\n                topSponsors[3].amt = thirdAmt;\r\n                return true;\r\n            }\r\n        }\r\n        //if the user should be at third position\r\n        else if(_amt > topSponsors[2].amt){\r\n            if(topSponsors[2].addr == _add) {\r\n                topSponsors[2].amt = _amt;\r\n                return true;\r\n            }\r\n            else {\r\n                topSponsors[2].addr = _add;\r\n                topSponsors[2].amt = _amt;\r\n                topSponsors[3].addr = thirdAddr;\r\n                topSponsors[3].amt = thirdAmt;\r\n            }\r\n        }\r\n        // if the user should be at the fourth position\r\n        else if (_amt > topSponsors[3].amt){\r\n\r\n             if (topSponsors[3].addr == _add){\r\n                topSponsors[3].amt = _amt;\r\n                return true;\r\n            }\r\n            \r\n            else{\r\n                topSponsors[3].addr = _add;\r\n                topSponsors[3].amt = _amt;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function awardTopPromoters() \r\n        private \r\n        returns (uint256)\r\n        {\r\n            uint256 totAmt = round[roundID].pool.mul(10).div(100);\r\n            uint256 distributedAmount;\r\n            uint256 i;\r\n       \r\n\r\n            for (i = 0; i< 4; i++) {\r\n                if (topSponsors[i].addr != address(0x0)) {\r\n                    if (player[topSponsors[i].addr].incomeLimitLeft >= totAmt.mul(awardPercentage[i]).div(100)) {\r\n                        player[topSponsors[i].addr].incomeLimitLeft = player[topSponsors[i].addr].incomeLimitLeft.sub(totAmt.mul(awardPercentage[i]).div(100));\r\n                        player[topSponsors[i].addr].sponsorPoolIncome = player[topSponsors[i].addr].sponsorPoolIncome.add(totAmt.mul(awardPercentage[i]).div(100));                                                \r\n                        emit roundAwardsEvent(topSponsors[i].addr, totAmt.mul(awardPercentage[i]).div(100));\r\n                    }\r\n                    else if(player[topSponsors[i].addr].incomeLimitLeft !=0) {\r\n                        player[topSponsors[i].addr].sponsorPoolIncome = player[topSponsors[i].addr].sponsorPoolIncome.add(player[topSponsors[i].addr].incomeLimitLeft);\r\n                        m2 = m2.add((totAmt.mul(awardPercentage[i]).div(100)).sub(player[topSponsors[i].addr].incomeLimitLeft));\r\n                        emit roundAwardsEvent(topSponsors[i].addr,player[topSponsors[i].addr].incomeLimitLeft);\r\n                        player[topSponsors[i].addr].incomeLimitLeft = 0;\r\n                    }\r\n                    else {\r\n                        m2 = m2.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                    }\r\n\r\n                    distributedAmount = distributedAmount.add(totAmt.mul(awardPercentage[i]).div(100));\r\n                    lastTopSponsors[i].addr = topSponsors[i].addr;\r\n                    lastTopSponsors[i].amt = topSponsors[i].amt;\r\n                    lastTopSponsorsWinningAmount[i] = totAmt.mul(awardPercentage[i]).div(100);\r\n                    topSponsors[i].addr = address(0x0);\r\n                    topSponsors[i].amt = 0;\r\n                }\r\n            }\r\n            return distributedAmount;\r\n        }\r\n\r\n  \r\n    function withdrawAdminFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\r\n\r\n        if(_numberUI == 1 && m1 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    m1 = m1.sub(_amount);\r\n                    address(uint160(_receiver)).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n        else if(_numberUI == 2 && m2 >= _amount) {\r\n            if(_amount > 0) {\r\n                if(address(this).balance >= _amount) {\r\n                    m2 = m2.sub(_amount);\r\n                    address(uint160(_receiver)).transfer(_amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function takeRemainingTVOTokens() public onlyOwner {\r\n        tevvoToken.transfer(owner,tevvoToken.balanceOf(address(this)));\r\n    }\r\n    \r\n    function addAdmin(address _adminAddress) public onlyOwner returns(address [] memory){\r\n\r\n        if(admins.length < 5) {\r\n                admins.push(_adminAddress);\r\n            }\r\n        return admins;\r\n    }\r\n    \r\n    function removeAdmin(address  _adminAddress) public onlyOwner returns(address[] memory){\r\n\r\n        for(uint i=0; i < admins.length; i++){\r\n            if(admins[i] == _adminAddress) {\r\n                admins[i] = admins[admins.length-1];\r\n                delete admins[admins.length-1];\r\n                admins.pop();\r\n            }\r\n        }\r\n        return admins;\r\n\r\n    }\r\n    \r\n    function drawPool() public onlyOwner {\r\n            startNextRound();\r\n        }\r\n        \r\n        function addLeader (address _leaderAddress) public onlyOwner {\r\n            require(isLeader[_leaderAddress] == false,\"leader already added\");\r\n            \r\n            isLeader[_leaderAddress] = true;\r\n        }\r\n\r\n     /* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n     /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) private {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit ownershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface Token {\r\n    function transfer(address _to, uint256 _amount) external  returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function decimals()external view returns (uint8);\r\n}\r\n\r\nlibrary DataStructs {\r\n\r\n        struct DailyRound {\r\n            uint256 startTime;\r\n            uint256 endTime;\r\n            bool ended; //has daily round ended\r\n            uint256 pool; //amount in the pool;\r\n        }\r\n\r\n        struct User {\r\n            uint256 id;\r\n            uint256 totalInvestment;\r\n            uint256 directsIncome;\r\n            uint256 roiReferralIncome;\r\n            uint256 currInvestment;\r\n            uint256 dailyIncome;            \r\n            uint256 lastSettledTime;\r\n            uint256 incomeLimitLeft;\r\n            uint256 sponsorPoolIncome;\r\n            uint256 referralCount;\r\n            address referrer;\r\n            uint256 totalVolETH;\r\n        }\r\n        struct PlayerEarnings {\r\n            uint256 withdrawableAmount;\r\n            uint256 lockedAmount;\r\n        }\r\n\r\n        struct PlayerDailyRounds {\r\n            uint256 ethVolume;\r\n        }\r\n}"}}}