{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Funder.sol": {
      "content": "pragma solidity >=0.4.23;\r\n\r\ninterface TokenLike {\r\n    function transferFrom(address,address,uint) external;\r\n    function transfer(address,uint) external ;\r\n}\r\n\r\ncontract Funder {\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external  auth { wards[usr] = 1; }\r\n    function deny(address usr) external  auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"fun/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    mapping (address => mapping (address => uint256)) public  allowance;\r\n    bytes32                                           public  symbol = \"fGAZ\";\r\n    uint256                                           public  decimals = 18; // standard token precision. override to customize\r\n    bytes32                                           public  name = \"fund_gaz\";     // Optional token name\r\n    mapping (address => uint256)                      public  bud;        // Whitelisted contracts, set by an auth\r\n\r\n    TokenLike                                         public  pro;         //众筹资产\r\n    TokenLike                                         public  gaz;         //平台币\r\n    uint256                                           public  one = 10**18;        \r\n    uint256                                           public  step;        //最低加价幅度\r\n    uint256                                           public  balanc;      //拍卖余额\r\n    uint256                                           public  depi;        //拍卖轮次\r\n    uint256                                           public  ltim;        //释放启动时间\r\n    uint256                                           public  Tima;        //拍卖时长\r\n    uint256                                           public  low;         //拍卖最低出价\r\n    uint256                                           public  timb;        //每轮拍卖启动时间\r\n    uint256                                           public  live;        //暂停拍卖标示\r\n    mapping(uint => uint)                             public  pta;         //价格序号\r\n    mapping(uint => mapping(uint => uint))            public  psn;         //价格序号对应的价格\r\n    mapping(uint => uint)                             public  Tem;         //每轮拍卖锁仓时间\r\n    mapping(uint => uint)                             public  total;       //每轮拍卖总量\r\n    mapping(uint => uint)                             public  sp;          //每轮拍卖起价\r\n    mapping(address => uint)                          public  balanceOf;   //众筹总余额\r\n    mapping(uint => mapping(address => uint))         public  balancetl;   //每轮众筹总余额\r\n    mapping(uint => mapping(uint => uint))            public  order;       //每轮每价位众筹者编号\r\n    mapping(uint => mapping(uint => mapping(uint => address)))        public  maid;  //每轮每价位众筹者编号对应的地址\r\n    mapping(uint => mapping(uint => mapping(uint => uint)))           public  waid;  //每轮每价位众筹者编号对应的数量\r\n    \r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n    event Auction(address indexed ust,uint indexed pri,uint wad);\r\n    event Withdraw(address indexed src, uint wad);\r\n\r\n    constructor(address _gaz,address _pro) public {\r\n        wards[msg.sender] = 1;\r\n        gaz = TokenLike(_gaz);\r\n        pro = TokenLike(_pro);\r\n    }\r\n    // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n   \r\n    function star() external auth  returns (bool){\r\n        ltim = now;\r\n        return true;\r\n    }     \r\n    function step(uint256 _step) external auth  returns (bool){\r\n        require(Tima < now - timb,\"fund/Auction-not-closed\");\r\n        step = _step;\r\n        return true;\r\n    }   \r\n    function settima(uint256 _tima) external auth  returns (bool){\r\n        Tima = _tima;\r\n        return true;\r\n    }\r\n    function approve(address guy) external returns (bool) {\r\n        return approve(guy, uint(-1));\r\n    } \r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(bud[dst] == 1 || bud[msg.sender] == 1, \"fund/-not-white\");\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"fund/insufficient-approval\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n        require(balanceOf[src] >= wad, \"fund/insufficient-balance\");\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n    function deposit(uint256 wad ,uint256 _low, uint256 _tea) public  auth returns (bool){\r\n        require(wad > 0,\"fund/not\");\r\n        require(Tima < now - timb,\"fund/Auction-not-closed\");\r\n        gaz.transferFrom(msg.sender, address(this), wad);\r\n        balanc=add(balanc, wad);\r\n        depi=add(depi,uint256(1));\r\n        low = _low;\r\n        timb = now;\r\n        Tem[depi] = _tea;\r\n        total[depi] = balanc;\r\n        sp[depi] = _low;\r\n        return true;\r\n    }\r\n    function exitpro(uint256 wad ,address usr) public  auth returns (bool){\r\n        pro.transfer(usr, wad);\r\n        return true;\r\n    }\r\n    function exitgaz(uint256 wad ,address usr) public  auth returns (bool){\r\n        require(balanc >= wad,\"fund/insuff-balance\");\r\n        balanc=sub(balanc,wad);\r\n        gaz.transfer(usr, wad);\r\n        return true;\r\n    }\r\n    function auction(uint256 wad,uint256 pri) public  returns (bool){\r\n        require(live == 1,\"fund/Auction-pause\");\r\n        require((balanc == 0 &&  pri > low) || (balanc > 0 &&  pri >= low),\"fund/Offer-too-low\");\r\n        require(wad > 0 && pri % step == 0,\"fund/The minimum markup does not meet the requirements\");\r\n        require(Tima > now - timb,\"fund/Auction-closed\");\r\n        uint256 bof=balanceOf[msg.sender];\r\n        balancetl[depi][msg.sender] =add(balancetl[depi][msg.sender],wad);\r\n        balanceOf[msg.sender]=add(balanceOf[msg.sender],wad);\r\n        if (order[depi][pri] == 0) {\r\n            pta[depi] += 1;\r\n            psn[depi][pta[depi]]=pri;}\r\n        order[depi][pri]=add(order[depi][pri],uint256(1));\r\n        uint256 ord = order[depi][pri];\r\n        maid[depi][pri][ord]= msg.sender;\r\n        waid[depi][pri][ord]= wad;\r\n        uint256 data = mul(wad,pri)/one;\r\n        uint256 wad1;\r\n        address usr;\r\n        pro.transferFrom(msg.sender, address(this) , data); \r\n        \r\n        //如果众筹数量小于本轮众筹余额，就从余额中扣除\r\n        if (wad <= balanc) {\r\n            balanc=sub(balanc,wad);\r\n        \r\n         //如果众筹数量大于本轮众筹余额，部分从余额中扣除，剩余数量来自于最低出价者中的最后出价者   \r\n        }else if  (wad > balanc ){\r\n            if  (balanc > 0) {\r\n                 wad1 = sub(wad,balanc);\r\n                 balanc = 0;\r\n                 \r\n        // 如果本轮众筹余额为零，数量来自于最低出价者中的最后出价者        \r\n           }else if  ( balanc == 0) { \r\n                 wad1 = wad;\r\n           } do {\r\n                 while (order[depi][low] <= 0) low=add(low,step); \r\n                 uint256 i= order[depi][low];\r\n                 uint256 wad2 = waid[depi][low][i];\r\n                 usr  = maid[depi][low][i];\r\n                 if (wad1 <= wad2) {\r\n                     balancetl[depi][usr]=sub(balancetl[depi][usr],wad1);\r\n                     balanceOf[usr]=sub(balanceOf[usr],wad1);\r\n                     waid[depi][low][i] =sub(waid[depi][low][i],wad1);\r\n                     pro.transfer(usr, mul(wad1,low)/one); \r\n                     wad1 = 0;\r\n                     \r\n         //如果最低出价者中的最后出价者数量不足，则不足部分由最低出价者中倒数第二个出价者扣除            \r\n                }else if (wad1 > wad2) {\r\n                     if (wad2>0) {\r\n                     balancetl[depi][usr]=sub(balancetl[depi][usr],wad2);\r\n                     balanceOf[usr]=sub(balanceOf[usr],wad2);\r\n                     pro.transfer(usr, mul(wad2,low)/one); \r\n                     uint256 id = order[depi][low];\r\n                     waid[depi][low][id] = 0;\r\n                     wad1=sub(wad1,wad2);\r\n                     }order[depi][low] =sub(order[depi][low],uint256(1));\r\n                     \r\n          //如果最低出价者中倒数第二个出价者余额仍然不足，则重复本轮扣除方式\r\n          //如果最低出价者是该价位的最后一个出价者，则最低出价改为高一个价位\r\n          //如果最低出价者是该价位的最后一个出价者，则最低出价改为高一个价位\r\n          //如果高一个价位没有出价者，则继续高一个价位，直到一个新的出价者\r\n          //新的最低出价者有可能是他自己，这样相当于扣除自己刚刚拍卖的数量\r\n\r\n                }\r\n            } while (wad1 >0);\r\n        }\r\n        bof = sub(balanceOf[msg.sender],bof);\r\n        emit Auction(msg.sender,pri,bof);\r\n        return true;\r\n    }\r\n    function withdraw(uint wad) external returns (bool) {\r\n        require(balanceOf[msg.sender] >= wad, \"fund/insufficient-balance\");\r\n        require(ltim != 0, \"fund/Release has not been activated yet\");\r\n   \r\n        //提现后的余额必须大于锁仓中的余额\r\n        require(wad <= callfree(),\"fund/insufficient-lock\") ;\r\n        balanceOf[msg.sender] = sub(balanceOf[msg.sender],wad);\r\n        gaz.transfer(msg.sender, wad);\r\n        emit Withdraw(msg.sender, wad);\r\n        return true;\r\n     }\r\n    function callfree() public view returns (uint256) {\r\n        require(ltim != 0, \"fund/Release has not been activated yet\");\r\n        uint256 dend;\r\n        uint256 pend;\r\n        uint256 lock; \r\n        if (Tima > now-timb) \r\n        dend = 1;\r\n        pend = balancetl[depi][msg.sender];\r\n        //计算每一轮拍卖被锁的数量之和  \r\n        for (uint i = 1; i <=sub(depi,dend); i++) {\r\n            if (balancetl[i][msg.sender]>0) {\r\n               uint256  lte = sub(Tem[i], sub(now,ltim));\r\n               if (lte > 0 )\r\n               {   uint256 unc = mul(lte,balancetl[i][msg.sender])/Tem[i];\r\n                   lock =add(lock,unc);\r\n                }\r\n            }\r\n        }   \r\n        return sub(sub(balanceOf[msg.sender],lock),pend);\r\n     }\r\n    function highest(uint256 _depi) public view returns(uint256){\r\n         uint256 hig;\r\n         for (uint i = 1; i <=pta[depi]; i++) {\r\n              uint256 pri = psn[_depi][i];\r\n              hig = max(hig,pri);\r\n            }\r\n         return  hig;\r\n    }\r\n    function gross(uint256 _depi, uint256 _pri) public view returns(uint256){\r\n         uint256 or = order[_depi][ _pri];\r\n         uint256 grs;\r\n         for (uint i = 1; i <=or; i++) {\r\n              uint256 gr = waid[_depi][_pri][i];\r\n              grs = add(grs,gr);\r\n            }\r\n         return  grs;\r\n    }\r\n    function check(uint256 _depi, uint256 _pri) public view returns(uint256){\r\n         uint256 cmax;\r\n         for (uint i = low; i <_pri; i=i+step) {\r\n              uint256 gro = gross(_depi, i);\r\n              cmax = add(cmax,gro);\r\n            }\r\n         return  cmax ;\r\n    }\r\n    function kiss(address a) external  auth returns (bool){\r\n        require(a != address(0), \"fund/no-contract-0\");\r\n        bud[a] = 1;\r\n        return true;\r\n    }\r\n\r\n    function diss(address a) external  auth returns (bool){\r\n         bud[a] = 0;\r\n         return true;\r\n    }\r\n    function setlive() external  auth returns (bool){\r\n        if (live == 1) live = 0;\r\n        else if (live == 0) live = 1;\r\n        return true;\r\n     } \r\n}"
    }
  }
}