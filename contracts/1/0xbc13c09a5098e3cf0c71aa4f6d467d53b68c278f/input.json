{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Relay.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interfaces/IRelay.sol\";\n\n/// @title Relay\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ncontract Relay is IRelay {\n\n    /// @inheritdoc IOracleRouterV2\n    address public override owner;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"ACW\");\n        _;\n    }\n\n    /// @inheritdoc IRelay\n    IWETH public override wnative;\n    /// @inheritdoc IRelay\n    IUniswapV2Router01 public override router;\n    /// @inheritdoc IRelay\n    IERC20 public override gton;\n\n    /// @inheritdoc IRelay\n    mapping (string => uint256) public override feeMin;\n    /// @inheritdoc IRelay\n    /// @dev 30000 = 30%, 200 = 0.2%, 1 = 0.001%\n    mapping (string => uint256) public override feePercent;\n\n    /// @inheritdoc IRelay\n    mapping(string => uint256) public override lowerLimit;\n\n    /// @inheritdoc IRelay\n    mapping(string => uint256) public override upperLimit;\n\n    /// @inheritdoc IRelay\n    bytes32 public override relayTopic;\n\n    /// @inheritdoc IOracleRouterV2\n    mapping(address => bool) public override canRoute;\n\n    /// @inheritdoc IRelay\n    mapping(string => bool) public override isAllowedChain;\n\n    receive() external payable {\n        // only accept ETH via fallback from the WETH contract\n        assert(msg.sender == address(wnative));\n    }\n\n    constructor (\n        IWETH _wnative,\n        IUniswapV2Router01 _router,\n        IERC20 _gton,\n        bytes32 _relayTopic,\n        string[] memory allowedChains,\n        uint[2][] memory fees,\n        uint[2][] memory limits\n    ) {\n        owner = msg.sender;\n        wnative = _wnative;\n        router = _router;\n        gton = _gton;\n        relayTopic = _relayTopic;\n        for (uint256 i = 0; i < allowedChains.length; i++) {\n            isAllowedChain[allowedChains[i]] = true;\n            feeMin[allowedChains[i]] = fees[i][0];\n            feePercent[allowedChains[i]] = fees[i][1];\n            lowerLimit[allowedChains[i]] = limits[i][0];\n            upperLimit[allowedChains[i]] = limits[i][1];\n        }\n    }\n\n    /// @inheritdoc IOracleRouterV2\n    function setOwner(address _owner) external override isOwner {\n        address ownerOld = owner;\n        owner = _owner;\n        emit SetOwner(ownerOld, _owner);\n    }\n\n    /// @inheritdoc IRelay\n    function setIsAllowedChain(string calldata chain, bool newBool)\n        external\n        override\n        isOwner\n    {\n        isAllowedChain[chain] = newBool;\n        emit SetIsAllowedChain(chain, newBool);\n    }\n\n    /// @inheritdoc IRelay\n    function setFees(string calldata destination, uint256 _feeMin, uint256 _feePercent) external override {\n        feeMin[destination] = _feeMin;\n        feePercent[destination] = _feePercent;\n        emit SetFees(destination, _feeMin, _feePercent);\n    }\n\n    /// @inheritdoc IRelay\n    function setLimits(string calldata destination, uint256 _lowerLimit, uint256 _upperLimit) external override {\n        lowerLimit[destination] = _lowerLimit;\n        upperLimit[destination] = _upperLimit;\n        emit SetLimits(destination, _lowerLimit, _upperLimit);\n    }\n\n    /// @inheritdoc IRelay\n    function lock(string calldata destination, bytes calldata receiver) external payable override {\n        require(isAllowedChain[destination], \"R1\");\n        require(msg.value > lowerLimit[destination], \"R2\");\n        require(msg.value < upperLimit[destination], \"R3\");\n        // wrap native tokens\n        wnative.deposit{value: msg.value}();\n        // trade wrapped native tokens for relay tokens\n        wnative.approve(address(router), msg.value);\n        address[] memory path = new address[](2);\n        path[0] = address(wnative);\n        path[1] = address(gton);\n        uint256[] memory amounts = router.swapExactTokensForTokens(msg.value, 0, path, address(this), block.timestamp+3600);\n        // subtract fee\n        uint256 amountMinusFee;\n        uint256 fee = amounts[1] * feePercent[destination] / 100000;\n        if (fee > feeMin[destination]) {\n            amountMinusFee = amounts[1] - fee;\n        } else {\n            amountMinusFee = amounts[1] - feeMin[destination];\n        }\n        emit CalculateFee(amounts[0], amounts[1], feeMin[destination], feePercent[destination], fee, amountMinusFee);\n        // check that remainder after subtracting fees is larger than 0\n        require(amountMinusFee > 0, \"R4\");\n        // emit event to notify oracles and initiate crosschain transfer\n        emit Lock(destination, receiver, destination, receiver, amountMinusFee);\n    }\n\n    /// @inheritdoc IRelay\n    function reclaimERC20(IERC20 token, uint256 amount) external override isOwner {\n        token.transfer(msg.sender, amount);\n    }\n\n    /// @inheritdoc IRelay\n    function reclaimNative(uint256 amount) external override isOwner {\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// @inheritdoc IOracleRouterV2\n    function setCanRoute(address parser, bool _canRoute)\n        external\n        override\n        isOwner\n    {\n        canRoute[parser] = _canRoute;\n        emit SetCanRoute(msg.sender, parser, canRoute[parser]);\n    }\n\n    /// @inheritdoc IRelay\n    function setRelayTopic(bytes32 _relayTopic) external override isOwner {\n        bytes32 topicOld = relayTopic;\n        relayTopic = _relayTopic;\n        emit SetRelayTopic(topicOld, _relayTopic);\n    }\n\n    function equal(bytes32 a, bytes32 b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n\n    function deserializeUint(\n        bytes memory b,\n        uint256 startPos,\n        uint256 len\n    ) internal pure returns (uint256) {\n        uint256 v = 0;\n        for (uint256 p = startPos; p < startPos + len; p++) {\n            v = v * 256 + uint256(uint8(b[p]));\n        }\n        return v;\n    }\n\n    function deserializeAddress(bytes memory b, uint256 startPos)\n        internal\n        pure\n        returns (address)\n    {\n        return address(uint160(deserializeUint(b, startPos, 20)));\n    }\n\n    /// @inheritdoc IOracleRouterV2\n    function routeValue(\n        bytes16 uuid,\n        string memory chain,\n        bytes memory emiter,\n        bytes32 topic0,\n        bytes memory token,\n        bytes memory sender,\n        bytes memory receiver,\n        uint256 amount\n    ) external override {\n        require(canRoute[msg.sender], \"ACR\");\n        if (equal(topic0, relayTopic)) {\n            // trade relay tokens for wrapped native tokens\n            gton.approve(address(router), amount);\n            address[] memory path = new address[](2);\n            path[0] = address(gton);\n            path[1] = address(wnative);\n            uint[] memory amounts = router.swapExactTokensForTokens(amount, 0, path, address(this), block.timestamp+3600);\n            // unwrap to get native tokens\n            wnative.withdraw(amounts[1]);\n            // transfer native tokens to the receiver\n            address payable user = payable(deserializeAddress(receiver, 0));\n            user.transfer(amounts[1]);\n            emit DeliverRelay(user, amounts[0], amounts[1]);\n        }\n        emit RouteValue(uuid, chain, emiter, token, sender, receiver, amount);\n    }\n}\n\n"},"interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\ninterface IERC20 {\n    function mint(address _to, uint256 _value) external;\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        returns (bool);\n\n    function transfer(address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n}\n"},"interfaces/IOracleRouterV2.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title The interface for Graviton oracle router\n/// @notice Forwards data about crosschain locking/unlocking events to balance keepers\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ninterface IOracleRouterV2 {\n    /// @notice User that can grant access permissions and perform privileged actions\n    function owner() external view returns (address);\n\n    /// @notice Transfers ownership of the contract to a new account (`_owner`).\n    /// @dev Can only be called by the current owner.\n    function setOwner(address _owner) external;\n\n    /// @notice Look up if `user` can route data to balance keepers\n    function canRoute(address user) external view returns (bool);\n\n    /// @notice Sets the permission to route data to balance keepers\n    /// @dev Can only be called by the current owner.\n    function setCanRoute(address parser, bool _canRoute) external;\n\n    /// @notice Routes value to balance keepers according to the type of event associated with topic0\n    /// @param uuid Unique identifier of the routed data\n    /// @param chain Type of blockchain associated with the routed event, i.e. \"EVM\"\n    /// @param emiter The blockchain-specific address where the data event originated\n    /// @param topic0 Unique identifier of the event\n    /// @param token The blockchain-specific token address\n    /// @param sender The blockchain-specific address that sent the tokens\n    /// @param receiver The blockchain-specific address to receive the tokens\n    /// @dev receiver is always same as sender, kept for compatibility\n    /// @param amount The amount of tokens\n    function routeValue(\n        bytes16 uuid,\n        string memory chain,\n        bytes memory emiter,\n        bytes32 topic0,\n        bytes memory token,\n        bytes memory sender,\n        bytes memory receiver,\n        uint256 amount\n    ) external;\n\n    /// @notice Event emitted when the owner changes via #setOwner`.\n    /// @param ownerOld The account that was the previous owner of the contract\n    /// @param ownerNew The account that became the owner of the contract\n    event SetOwner(address indexed ownerOld, address indexed ownerNew);\n\n    /// @notice Event emitted when the `parser` permission is updated via `#setCanRoute`\n    /// @param owner The owner account at the time of change\n    /// @param parser The account whose permission to route data was updated\n    /// @param newBool Updated permission\n    event SetCanRoute(\n        address indexed owner,\n        address indexed parser,\n        bool indexed newBool\n    );\n\n    /// @notice Event emitted when data is routed\n    /// @param uuid Unique identifier of the routed data\n    /// @param chain Type of blockchain associated with the routed event, i.e. \"EVM\"\n    /// @param emiter The blockchain-specific address where the data event originated\n    /// @param token The blockchain-specific token address\n    /// @param sender The blockchain-specific address that sent the tokens\n    /// @param receiver The blockchain-specific address to receive the tokens\n    /// @dev receiver is always same as sender, kept for compatibility\n    /// @param amount The amount of tokens\n    event RouteValue(\n        bytes16 uuid,\n        string chain,\n        bytes emiter,\n        bytes indexed token,\n        bytes indexed sender,\n        bytes indexed receiver,\n        uint256 amount\n    );\n}\n"},"interfaces/IRelay.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IWETH.sol\";\nimport \"./IOracleRouterV2.sol\";\nimport \"./IUniswapV2Router01.sol\";\nimport \"./IUniswapV2Factory.sol\";\nimport \"./IUniswapV2Pair.sol\";\n\n/// @title The interface for Graviton relay contract\n/// @notice Trades native tokens for gton to start crosschain swap,\n/// trades gton for native tokens to compelete crosschain swap\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ninterface IRelay is IOracleRouterV2 {\n    /// @notice ERC20 wrapped version of the native token\n    function wnative() external view returns (IWETH);\n\n    /// @notice UniswapV2 router\n    function router() external view returns (IUniswapV2Router01);\n\n    /// @notice relay token\n    function gton() external view returns (IERC20);\n\n    /// @notice chains for relay swaps to and from\n    function isAllowedChain(string calldata chain) external view returns (bool);\n\n    /// @notice allow/forbid chain to relay swap\n    /// @param chain blockchain name, e.g. 'FTM', 'PLG'\n    /// @param newBool new permission for the chain\n    function setIsAllowedChain(string calldata chain, bool newBool) external;\n\n    /// @notice minimum fee for a destination\n    function feeMin(string calldata destination) external view returns (uint256);\n\n    /// @notice percentage fee for a destination\n    function feePercent(string calldata destination) external view returns (uint256);\n\n    /// @notice Sets fees for a destination\n    /// @param _feeMin Minimum fee\n    /// @param _feePercent Percentage fee\n    function setFees(string calldata destination, uint256 _feeMin, uint256 _feePercent) external;\n\n    /// @notice minimum amount of native tokens allowed to swap\n    function lowerLimit(string calldata destination) external view returns (uint256);\n\n    /// @notice maximum amount of native tokens allowed to swap\n    function upperLimit(string calldata destination) external view returns (uint256);\n\n    /// @notice Sets limits for a destination\n    /// @param _lowerLimit Minimum amount of native tokens allowed to swap\n    /// @param _upperLimit Maximum amount of native tokens allowed to swap\n    function setLimits(string calldata destination, uint256 _lowerLimit, uint256 _upperLimit) external;\n\n    /// @notice topic0 of the event associated with initiating a relay transfer\n    function relayTopic() external view returns (bytes32);\n\n    /// @notice Sets topic0 of the event associated with initiating a relay transfer\n    function setRelayTopic(bytes32 _relayTopic) external;\n\n    /// @notice Trades native tokens for relay, takes fees,\n    /// emits event to start crosschain transfer\n    /// @param destination The blockchain that will receive native tokens\n    /// @param receiver The account that will receive native tokens\n    function lock(string calldata destination, bytes calldata receiver) external payable;\n\n    /// @notice Transfers locked ERC20 tokens to owner\n    function reclaimERC20(IERC20 token, uint256 amount) external;\n\n    /// @notice Transfers locked native tokens to owner\n    function reclaimNative(uint256 amount) external;\n\n    /// @notice Event emitted when native tokens equivalent to\n    /// `amount` of relay tokens are locked via `#lock`\n    /// @dev Oracles read this event and unlock\n    /// equivalent amount of native tokens on the destination chain\n    /// @param destinationHash The blockchain that will receive native tokens\n    /// @dev indexed string returns keccak256 of the value\n    /// @param receiverHash The account that will receive native tokens\n    /// @dev indexed bytes returns keccak256 of the value\n    /// @param destination The blockchain that will receive native tokens\n    /// @param receiver The account that will receive native tokens\n    /// @param amount The amount of relay tokens equivalent to the\n    /// amount of locked native tokens\n    event Lock(\n        string indexed destinationHash,\n        bytes indexed receiverHash,\n        string destination,\n        bytes receiver,\n        uint256 amount\n    );\n\n    /// @notice Event emitted when fees are calculated\n    /// @param amountIn Native tokens sent to dex\n    /// @param amountOut Relay tokens received on dex\n    /// @param feeMin Minimum fee\n    /// @param feePercent Percentage for the fee in %\n    /// @dev precision 3 decimals\n    /// @param fee Percentage fee in relay tokens\n    /// @param amountMinusFee Relay tokens minus fees\n    event CalculateFee(\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 feeMin,\n        uint256 feePercent,\n        uint256 fee,\n        uint256 amountMinusFee\n    );\n\n    /// @notice Event emitted when the relay tokens are traded for\n    /// `amount0` of gton swaped for native tokens via '#routeValue'\n    /// `amount1` of native tokens sent to the `user` via '#routeValue'\n    event DeliverRelay(address user, uint256 amount0, uint256 amount1);\n\n    /// @notice Event emitted when the RelayTopic is set via '#setRelayTopic'\n    /// @param topicOld The previous topic\n    /// @param topicNew The new topic\n    event SetRelayTopic(bytes32 indexed topicOld, bytes32 indexed topicNew);\n\n    /// @notice Event emitted when the wallet is set via '#setWallet'\n    /// @param walletOld The previous wallet address\n    /// @param walletNew The new wallet address\n    event SetWallet(address indexed walletOld, address indexed walletNew);\n\n    /// @notice Event emitted when permission for a chain is set via '#setIsAllowedChain'\n    /// @param chain Name of blockchain whose permission is changed, i.e. \"FTM\", \"PLG\"\n    /// @param newBool Updated permission\n    event SetIsAllowedChain(string chain, bool newBool);\n\n    /// @notice Event emitted when fees are set via '#setFees'\n    /// @param _feeMin Minimum fee\n    /// @param _feePercent Percentage fee\n    event SetFees(string destination, uint256 _feeMin, uint256 _feePercent);\n\n    /// @notice Event emitted when limits are set via '#setLimits'\n    /// @param _lowerLimit Minimum fee\n    /// @param _upperLimit Percentage fee\n    event SetLimits(string destination, uint256 _lowerLimit, uint256 _upperLimit);\n}\n"},"interfaces/IUniswapV2Factory.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"},"interfaces/IUniswapV2Pair.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"},"interfaces/IUniswapV2Router01.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"interfaces/IWETH.sol":{"content":"pragma solidity >=0.8.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint amount) external;\n\n    function transfer(address to, uint amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"}}}