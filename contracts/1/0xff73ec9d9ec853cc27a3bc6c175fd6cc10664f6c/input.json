{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"vestingse.sol":{"content":"// SPDX-License-Identifier: Ulicense\npragma solidity 0.8.2;\n\n// Presale and good ERC20 contracts interaction interface\ninterface IContracts {\n    function transfer(address, uint256) external returns (bool);\n}\n\n// Broken ERC20 transfer for rescue ERC20 tokens\ninterface IErc20 {\n    function balanceOf(address) external returns (uint256);\n\n    // some tokens (like USDT) not return bool as standard require\n    function transfer(address, uint256) external;\n}\n\n/// @title Uniqly vesting contract\n/// Users from external list (not presale contracts)\n/// @author rav3n_pl\ncontract UniqVestingSE {\n    // user is eligible to receive bonus NFT tokens (default=0)\n    mapping(address => uint256) internal _bonus;\n\n    /// it will be used by future contract\n    function bonus(address user) external view returns (uint256) {\n        return _bonus[user];\n    }\n\n    // always true, for ABI/backend compatibility\n    function initialized(address) external pure returns (bool) {\n        return true;\n    }\n\n    // total amount of token bought by presale contracts (default=0)\n    mapping(address => uint256) internal _tokensTotal;\n\n    function tokensTotal(address user) external view returns (uint256) {\n        return _tokensTotal[user];\n    }\n\n    // percentage already withdrawn by user (default=0)\n    mapping(address => uint256) internal _pctWithdrawn;\n\n    function pctWithdrawn(address user) external view returns (uint256) {\n        return _pctWithdrawn[user];\n    }\n\n    /// ERC20 token contract address\n    address public immutable token;\n\n    /// timestamp that users can start withdrawals\n    uint256 public immutable dateStart;\n    /// address of contract owner\n    address public owner;\n\n    // Manually disable adding investors to match main contract date\n    bool addDisabled;\n\n    function closeAdd() external onlyOwner {\n        addDisabled = true;\n    }\n\n    /**\n    @dev contract constructor\n    @param _token address of ERC20 token contract\n    @param _dateStart uint256 timestamp from when users can start withdrawing tokens \n    */\n    constructor(address _token, uint256 _dateStart) {\n        token = _token;\n        dateStart = _dateStart;\n        owner = msg.sender;\n    }\n\n    // for ABI/backend compatibility\n    function calc() external view returns (uint256) {\n        return _tokensTotal[msg.sender];\n    }\n\n    /**\n    @dev Number of tokens eligible to withdraw\n    @return number of tokens available for user\n     */\n    function balanceOf(address user) external view returns (uint256) {\n        return (_tokensTotal[user] * (100 - _pctWithdrawn[user])) / 100;\n    }\n\n    /**\n    @dev user call this function to withdraw tokens\n    @return bool true if any token transfer made\n    */\n    function claim() external returns (bool) {\n        // can't work before timestamp\n        require(block.timestamp > dateStart, \"Initial vesting in progress\");\n\n        // initial percent is 20\n        uint256 pct = 20;\n        uint256 time = dateStart + 1 weeks;\n        // every week to date\n        while (time < block.timestamp) {\n            pct += 4;\n            // can't be more than 100\n            if (pct == 100) {\n                break;\n            }\n            time += 1 weeks;\n        }\n        // do we have any % of tokens to withdraw?\n        if (pct > _pctWithdrawn[msg.sender]) {\n            uint256 thisTime = pct - _pctWithdrawn[msg.sender];\n            // is user a patient one?\n            // you've got a prize/s in near future!\n            if (pct > 59) {\n                // 60% for 1st bonus, even when initial 20% claimed\n                // but no bonus at all if claimed more than 20%\n                if (_pctWithdrawn[msg.sender] < 21) {\n                    _bonus[msg.sender] = 1;\n                    // second bonus after 100% and max 20% withdrawn\n                    if (pct == 100 && thisTime > 79) {\n                        _bonus[msg.sender] = 2;\n                    }\n                }\n            }\n            // how many tokens it would be...\n            uint256 amt = (_tokensTotal[msg.sender] * thisTime) / 100;\n            // yes, no reentrance please\n            _pctWithdrawn[msg.sender] += thisTime;\n            // transfer tokens counted\n            return IContracts(token).transfer(msg.sender, amt);\n        }\n        // did nothing\n        return false;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only for Owner\");\n        _;\n    }\n\n    // change ownership in two steps to be sure about owner address\n    address public newOwner;\n\n    // only current owner can delegate new one\n    function giveOwnership(address _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    // new owner need to accept ownership\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"You are not New Owner\");\n        newOwner = address(0);\n        owner = msg.sender;\n    }\n\n    /**\n    @dev Add investor to vesting contract that not used collection contract\n    @param addr - address to add\n    @param amount - tokens due\n    */\n    function addInvestor(address addr, uint256 amount) external onlyOwner {\n        require(!addDisabled, \"Too late do add investors\");\n        _addInvestor(addr, amount);\n    }\n\n    /**\n    @dev Add investors in bulk\n    @param addr table of addresses\n    @param amount table of amounts\n    */\n    function addInvestors(address[] calldata addr, uint256[] calldata amount)\n        external\n        onlyOwner\n    {\n        require(!addDisabled, \"Too late do add investors\");\n        require(addr.length == amount.length, \"Data length not match\");\n        for (uint256 i = 0; i < addr.length; i++) {\n            _addInvestor(addr[i], amount[i]);\n        }\n    }\n\n    // internal function adding investors\n    function _addInvestor(address addr, uint256 amt) internal {\n        require(_tokensTotal[addr] == 0, \"Address already on list\");\n        _tokensTotal[addr] = amt;\n    }\n\n    /**\n    @dev Function to recover accidentally send ERC20 tokens\n    @param _token ERC20 token address\n    */\n    function rescueERC20(address _token) external onlyOwner {\n        uint256 amt = IErc20(_token).balanceOf(address(this));\n        require(amt > 0, \"Nothing to rescue\");\n        IErc20(_token).transfer(owner, amt);\n    }\n}\n"}}}