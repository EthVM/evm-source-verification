{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MigrationContract.sol": {
      "content": "/**\r\n°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\r\n°°°°°__This migration contract is deployed to migrate BGLD v1 to v2__°°°°°°\r\n°°°                                                                     °°°\r\n---------->> Check out the website for migration instructions! <<----------\r\n°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\r\n-->> BGLD contract address (v2): 0x4b4fa17f83c09873cb5b4e0023f25d4f533fc9ba\r\n***************************************************************************\r\n---------------->>  Telegram:https://t.me/BGLDofficial  <<----------------\r\n---------------->>  Website: https://www.BGLD.it  <<-----------------------\r\n---------------->>  Twitter: https://twitter.com/Basedgoldbgld  <<---------\r\n***************************************************************************\r\n***************************************************************************\r\nLinks to Based Gold v2:\r\nhttps://etherscan.io/address/0x4b4fa17f83c09873cb5b4e0023f25d4f533fc9ba\r\nhttps://www.dextools.io/app/ether/pair-explorer/0x4233b83f3D5Bc39770fb7a456EF85B7eEC26fe14\r\n\r\n\r\n███╗   ███╗██╗ ██████╗ ██████╗  █████╗ ████████╗██╗ ██████╗ ███╗   ██╗        \r\n████╗ ████║██║██╔════╝ ██╔══██╗██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║        \r\n██╔████╔██║██║██║  ███╗██████╔╝███████║   ██║   ██║██║   ██║██╔██╗ ██║        \r\n██║╚██╔╝██║██║██║   ██║██╔══██╗██╔══██║   ██║   ██║██║   ██║██║╚██╗██║        \r\n██║ ╚═╝ ██║██║╚██████╔╝██║  ██║██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║        \r\n╚═╝     ╚═╝╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝        \r\n                                                                              \r\n██████╗  █████╗ ███████╗███████╗██████╗      ██████╗  ██████╗ ██╗     ██████╗ \r\n██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗    ██╔════╝ ██╔═══██╗██║     ██╔══██╗\r\n██████╔╝███████║███████╗█████╗  ██║  ██║    ██║  ███╗██║   ██║██║     ██║  ██║\r\n██╔══██╗██╔══██║╚════██║██╔══╝  ██║  ██║    ██║   ██║██║   ██║██║     ██║  ██║\r\n██████╔╝██║  ██║███████║███████╗██████╔╝    ╚██████╔╝╚██████╔╝███████╗██████╔╝\r\n╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝      ╚═════╝  ╚═════╝ ╚══════╝╚═════╝ \r\n                                                                              \r\n██████╗  ██████╗ ██╗     ██████╗                                              \r\n██╔══██╗██╔════╝ ██║     ██╔══██╗                                             \r\n██████╔╝██║  ███╗██║     ██║  ██║                                             \r\n██╔══██╗██║   ██║██║     ██║  ██║                                             \r\n██████╔╝╚██████╔╝███████╗██████╔╝                                             \r\n╚═════╝  ╚═════╝ ╚══════╝╚═════╝                                              \r\n                                                                              \r\n██╗   ██╗ ██╗         ██╗      ██╗   ██╗██████╗                               \r\n██║   ██║███║         ╚██╗     ██║   ██║╚════██╗                              \r\n██║   ██║╚██║    █████╗╚██╗    ██║   ██║ █████╔╝                              \r\n╚██╗ ██╔╝ ██║    ╚════╝██╔╝    ╚██╗ ██╔╝██╔═══╝                               \r\n ╚████╔╝  ██║         ██╔╝      ╚████╔╝ ███████╗                              \r\n  ╚═══╝   ╚═╝         ╚═╝        ╚═══╝  ╚══════╝                              \r\n                                                                              \r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.10;                                                      \r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\ncontract MigrationContract {                                            \r\n    address private _owner;\r\n\r\n    address public tokenV1 = 0xbA7970f10D9f0531941DcEd1dda7ef3016B24e5b; // BGLD V1\r\n    address public tokenV2 = 0x4B4Fa17F83c09873cb5b4e0023f25d4f533Fc9Ba; // BGLD V2\r\n\r\n    // \"Migration wallet\"\r\n    // Address where V1 tokens will be send to for collection/LP draining \r\n    // and where V2 tokens will be send from in return\r\n    // if collectAddress is not this contract's address:\r\n    // APPROVE this contract from the collectAddress to access V2 tokens!\r\n    // Also exclude the collectAddress from Fees in v2 contract & must be capable to transfer before trading is open\r\n    address public collectAddress = 0xF5eaDdc6AC4Da273338b726b0646a9bc07B449B4;\r\n\r\n    // Swap ratio = 1:1\r\n    uint256 public tokenMultiplyRatio = 1;\r\n    uint256 public tokenDivideRatio = 1;\r\n\r\n    // Minimum balance to migrate = 0.000 000 000 000 000 001 token!\r\n    uint256 public minimumV1Balance;\r\n    uint256 public minimumV2Balance;\r\n\r\n    bool public migrationEnabled;     \r\n    bool public whitelistEnabled = true;\r\n    bool public enableV2toV1;\r\n\r\n    mapping (address => bool) private _isBlacklisted;\r\n    mapping (address => uint256) private _isWhitelisted;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event V1TokensMigratedToV2(address indexed account, uint256 amountV1, uint256 amountV2);\r\n    event V2TokensMigratedToV1(address indexed account, uint256 amountV1, uint256 amountV2);\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"MigrationContract: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _owner = msg.sender; \r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"MigrationContract: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    // This migrate function automatically migrates ALL your tokenV1 to tokenV2 (max balance)  \r\n    function MigrateV1toV2tokens() external {               \r\n        uint256 amountV1 = GetV1BalanceOf(msg.sender); \r\n        require(migrationEnabled && amountV1 > minimumV1Balance, \"MigrationContract: Migration is disabled or your tokenV1 balance is insufficient\");\r\n   \r\n        IERC20(tokenV1).transferFrom(msg.sender, collectAddress, amountV1);\r\n        uint256 amountV2 = 0;\r\n\r\n        if (!_isBlacklisted[msg.sender]) {\r\n            if (whitelistEnabled) {\r\n                if (_isWhitelisted[msg.sender] >= amountV1) {\r\n                    _isWhitelisted[msg.sender] = 0;\r\n                    amountV2 = amountV1 * tokenMultiplyRatio / tokenDivideRatio;\r\n                    if(collectAddress == address(this)) {\r\n                    IERC20(tokenV2).transfer(msg.sender, amountV2);\r\n                    } else {\r\n                        IERC20(tokenV2).transferFrom(collectAddress, msg.sender, amountV2);\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                amountV2 = amountV1 * tokenMultiplyRatio / tokenDivideRatio;\r\n                if(collectAddress == address(this)) {\r\n                    IERC20(tokenV2).transfer(msg.sender, amountV2);\r\n                    } else {\r\n                        IERC20(tokenV2).transferFrom(collectAddress, msg.sender, amountV2);\r\n                    }\r\n            }\r\n        }\r\n        emit V1TokensMigratedToV2(msg.sender, amountV1, amountV2);\r\n    }\r\n\r\n    // This function can be enabled or disabled by calling function SetV2toV1Status(_TrueOrFalse);\r\n    function MigrateV2toV1tokens() external {\r\n        uint256 amountV2 = GetV2BalanceOf(msg.sender);\r\n        require(enableV2toV1 && migrationEnabled && amountV2 > minimumV2Balance, \"MigrationContract: Migration from V2 to V1 is disabled or your tokenV2 balance is insufficient\");\r\n              \r\n        IERC20(tokenV2).transferFrom(msg.sender, collectAddress, amountV2);\r\n        uint256 amountV1 = 0;\r\n\r\n        if (!_isBlacklisted[msg.sender]) {\r\n            if (whitelistEnabled) {\r\n                if (_isWhitelisted[msg.sender] >= amountV2) {\r\n                    _isWhitelisted[msg.sender] = 0;\r\n                    amountV1 = amountV2 * tokenDivideRatio / tokenMultiplyRatio;\r\n                    IERC20(tokenV1).transferFrom(collectAddress, msg.sender, amountV1);\r\n                }\r\n\r\n            } else {\r\n                amountV1 = amountV2 * tokenDivideRatio / tokenMultiplyRatio;\r\n                if(collectAddress == address(this)) {\r\n                    IERC20(tokenV1).transfer(msg.sender, amountV1);\r\n                    } else {\r\n                        IERC20(tokenV1).transferFrom(collectAddress, msg.sender, amountV1);\r\n                    }\r\n            }\r\n        }\r\n        emit V2TokensMigratedToV1(msg.sender, amountV1, amountV2);\r\n    }\r\n\r\n    function MigrateV1toV2tokens(uint256 amountV1) external {                \r\n        require(migrationEnabled && amountV1 > minimumV1Balance, \"MigrationContract: Migration is disabled at the moment\");      \r\n\r\n        IERC20(tokenV1).transferFrom(msg.sender, collectAddress, amountV1);\r\n        uint256 amountV2 = 0;\r\n\r\n        if (!_isBlacklisted[msg.sender]) {\r\n            if (whitelistEnabled) {\r\n                if (_isWhitelisted[msg.sender] >= amountV1) {\r\n                unchecked { _isWhitelisted[msg.sender] -= amountV1; }\r\n                    amountV2 = amountV1 * tokenMultiplyRatio / tokenDivideRatio;\r\n                    if(collectAddress == address(this)) {\r\n                    IERC20(tokenV2).transfer(msg.sender, amountV2);\r\n                    } else {\r\n                        IERC20(tokenV2).transferFrom(collectAddress, msg.sender, amountV2);\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                amountV2 = amountV1 * tokenMultiplyRatio / tokenDivideRatio;\r\n                if(collectAddress == address(this)) {\r\n                    IERC20(tokenV2).transfer(msg.sender, amountV2);\r\n                    } else {\r\n                        IERC20(tokenV2).transferFrom(collectAddress, msg.sender, amountV2);\r\n                    }\r\n            }\r\n        }\r\n        emit V1TokensMigratedToV2(msg.sender, amountV1, amountV2);\r\n    }\r\n\r\n    function MigrateV2toV1tokens(uint256 amountV2) external {\r\n        require(enableV2toV1 && migrationEnabled && amountV2 > minimumV2Balance, \"MigrationContract: Migration from V2 to V1 is disabled\");\r\n  \r\n        IERC20(tokenV2).transferFrom(msg.sender, collectAddress, amountV2);\r\n        uint256 amountV1 = 0;\r\n\r\n        if (!_isBlacklisted[msg.sender]) {\r\n            if (whitelistEnabled) {\r\n                if (_isWhitelisted[msg.sender] >= amountV2) {\r\n                   unchecked { _isWhitelisted[msg.sender] -= amountV2; }\r\n                    amountV1 = amountV2 * tokenDivideRatio / tokenMultiplyRatio;\r\n                    if(collectAddress == address(this)) {\r\n                    IERC20(tokenV1).transfer(msg.sender, amountV1);\r\n                    } else {\r\n                        IERC20(tokenV1).transferFrom(collectAddress, msg.sender, amountV1);\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                amountV1 = amountV2 * tokenDivideRatio / tokenMultiplyRatio;\r\n                if(collectAddress == address(this)) {\r\n                    IERC20(tokenV1).transfer(msg.sender, amountV1);\r\n                    } else {\r\n                        IERC20(tokenV1).transferFrom(collectAddress, msg.sender, amountV1);\r\n                    }\r\n            }\r\n        }\r\n        emit V2TokensMigratedToV1(msg.sender, amountV1, amountV2);\r\n    }\r\n    \r\n    function SetMigrationStatus(bool enabled_TrueOrFalse) external onlyOwner {          \r\n        migrationEnabled = enabled_TrueOrFalse;\r\n    }\r\n\r\n    function SetV2toV1Status(bool enabled_TrueOrFalse) external onlyOwner {          \r\n        enableV2toV1 = enabled_TrueOrFalse;\r\n    }\r\n\r\n    function SetWhitelistEnabled(bool enabled_TrueOrFalse) external onlyOwner {          \r\n        whitelistEnabled = enabled_TrueOrFalse;\r\n    }\r\n\r\n    function SetTokenAddresses(address newV1address, address newV2address, address newCollectAddress) external onlyOwner {          \r\n        tokenV1 = newV1address;\r\n        tokenV2 = newV2address;\r\n        collectAddress = newCollectAddress; \r\n    }\r\n\r\n    function SetBlacklist(address account, bool trueOrFalse) external onlyOwner {\r\n        _isBlacklisted[account] = trueOrFalse;\r\n    }\r\n\r\n    function SetMultipleBlacklist(address[] calldata accounts, bool trueOrFalse) external onlyOwner {\r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n        _isBlacklisted[accounts[i]] = trueOrFalse;\r\n        }\r\n    }\r\n\r\n    function SetWhitelist(address account, uint256 amount) external onlyOwner {\r\n        _isWhitelisted[account] = amount;\r\n    }\r\n\r\n    // Watch out for high gas fees: adding ~1000 addressess will require a gas limit of ~ 1 210 000 (at 50 gwei = ~0.06 ETH / 1000 accounts)\r\n    function SetMultipleWhitelist(address[] calldata accounts, uint256[] calldata amounts) external onlyOwner {      \r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n        _isWhitelisted[accounts[i]] = amounts[i];\r\n        }\r\n    }\r\n\r\n    function GetWhitelistBalance(address account) public view returns (uint256) {\r\n        return _isWhitelisted[account];\r\n    }\r\n\r\n    // Make sure tokenRatios are not set to zero!!!\r\n    // Amount of V1 tokens multiplied by tokenMultiplyRatio and then divided by tokenDivideRatio\r\n    // equals amount of V2 tokens the caller will receive\r\n    function SetTokenRatios(uint256 newMultiplyRatio, uint256 newDivideRatio) external onlyOwner {          \r\n        tokenMultiplyRatio = newMultiplyRatio;\r\n        tokenDivideRatio = newDivideRatio;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function GetV1BalanceOf(address account) public view returns (uint256) {\r\n        return(IERC20(tokenV1).balanceOf(account));\r\n    }\r\n\r\n    function GetV2BalanceOf(address account) public view returns (uint256) {\r\n        return(IERC20(tokenV2).balanceOf(account));\r\n    }\r\n\r\n    function GetCollectAddressV1Balance() public view returns (uint256) {\r\n        return(IERC20(tokenV1).balanceOf(collectAddress));\r\n    }\r\n\r\n    function GetCollectAddressV2Balance() public view returns (uint256) {\r\n        return(IERC20(tokenV2).balanceOf(collectAddress));\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    // Withdraw ETH that's potentially stuck in the Migration Contract\r\n    function recoverETHFromContract() public virtual onlyOwner {                                        \r\n        TransferHelper.safeTransferETH(owner(), address(this).balance);\r\n    }\r\n\r\n    // Withdraw ERC20 tokens that are potentially stuck in the Migration Contract\r\n    function recoverTokensFromContract(address _tokenAddress, uint256 _amount) public virtual onlyOwner {                               \r\n        TransferHelper.safeTransfer(_tokenAddress, owner(), _amount);\r\n    }\r\n}"
    }
  }
}