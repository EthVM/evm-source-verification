{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"UmbMultiSig.sol":{"content":"// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/PowerMultiSig.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n// Inheritance\r\n\r\n\r\n// TODO remove power user\r\n\r\n/// @title   Multi Signature base on Power\r\n/// @author  umb.network\r\n/// @notice  It's based on https://github.com/gnosis/MultiSigWallet but modified in a way to support power of vote.\r\n///          It has option to assign power to owners, so we can have \"super owner(s)\".\r\nabstract contract PowerMultiSig {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public MAX_OWNER_COUNT = 5;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint256 value;\r\n        uint256 executed;\r\n        bytes data;\r\n    }\r\n\r\n    mapping(uint256 => Transaction) public transactions;\r\n    mapping(uint256 => mapping(address => bool)) public confirmations;\r\n    mapping(address => uint256) public ownersPowers;\r\n    address[] public owners;\r\n\r\n    uint256 public requiredPower;\r\n    uint256 public totalCurrentPower;\r\n    uint256 public transactionCount;\r\n\r\n    // ========== MODIFIERS ========== //\r\n\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this), \"only MultiSigMinter can execute this\");\r\n        _;\r\n    }\r\n\r\n    modifier whenOwnerDoesNotExist(address _owner) {\r\n        require(ownersPowers[_owner] == 0, \"owner already exists\");\r\n        _;\r\n    }\r\n\r\n    modifier whenOwnerExists(address _owner) {\r\n        require(ownersPowers[_owner] > 0, \"owner do NOT exists\");\r\n        _;\r\n    }\r\n\r\n    modifier whenTransactionExists(uint256 _transactionId) {\r\n        require(transactions[_transactionId].destination != address(0), \"transaction does not exists\");\r\n        _;\r\n    }\r\n\r\n    modifier whenConfirmedBy(uint256 _transactionId, address _owner) {\r\n        require(confirmations[_transactionId][_owner], \"transaction NOT confirmed by owner\");\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmedBy(uint256 _transactionId, address _owner) {\r\n        require(!confirmations[_transactionId][_owner], \"transaction already confirmed by owner\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotExecuted(uint256 _transactionId) {\r\n        require(transactions[_transactionId].executed == 0, \"transaction already executed\");\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != address(0), \"address is empty\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint256 _totalOwnersCount, uint256 _totalPowerSum, uint256 _requiredPower) {\r\n        require(_totalPowerSum >= _requiredPower, \"owners do NOT have enough power\");\r\n        require(_totalOwnersCount <= MAX_OWNER_COUNT, \"too many owners\");\r\n        require(_requiredPower != 0, \"_requiredPower is zero\");\r\n        require(_totalOwnersCount != 0, \"_totalOwnersCount is zero\");\r\n        _;\r\n    }\r\n\r\n    // ========== CONSTRUCTOR ========== //\r\n\r\n    constructor(address[] memory _owners, uint256[] memory _powers, uint256 _requiredPower)\r\n    validRequirement(_owners.length, sum(_powers), _requiredPower)\r\n    {\r\n        uint256 sumOfPowers = 0;\r\n\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            require(ownersPowers[_owners[i]] == 0, \"owner already exists\");\r\n            require(_owners[i] != address(0), \"owner is empty\");\r\n            require(_powers[i] != 0, \"power is empty\");\r\n\r\n            ownersPowers[_owners[i]] = _powers[i];\r\n            sumOfPowers = sumOfPowers.add(_powers[i]);\r\n        }\r\n\r\n        owners = _owners;\r\n        requiredPower = _requiredPower;\r\n        totalCurrentPower = sumOfPowers;\r\n    }\r\n\r\n    // ========== MODIFIERS ========== //\r\n\r\n    function addOwner(address _owner, uint256 _power)\r\n    public\r\n    onlyWallet\r\n    whenOwnerDoesNotExist(_owner)\r\n    notNull(_owner)\r\n    validRequirement(owners.length + 1, totalCurrentPower + _power, requiredPower)\r\n    {\r\n        require(_power != 0, \"_power is empty\");\r\n\r\n        ownersPowers[_owner] = _power;\r\n        owners.push(_owner);\r\n        totalCurrentPower = totalCurrentPower.add(_power);\r\n\r\n        emit LogOwnerAddition(_owner, _power);\r\n    }\r\n\r\n    function removeOwner(address _owner) public onlyWallet whenOwnerExists(_owner)\r\n    {\r\n        uint256 ownerPower = ownersPowers[_owner];\r\n        require(\r\n            totalCurrentPower - ownerPower >= requiredPower,\r\n            \"can't remove owner, because there will be not enough power left\"\r\n        );\r\n\r\n        ownersPowers[_owner] = 0;\r\n        totalCurrentPower = totalCurrentPower.sub(ownerPower);\r\n\r\n        for (uint256 i = 0; i < owners.length - 1; i++) {\r\n            if (owners[i] == _owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        }\r\n\r\n        owners.pop();\r\n\r\n        emit LogOwnerRemoval(_owner);\r\n    }\r\n\r\n    function replaceOwner(address _oldOwner, address _newOwner)\r\n    public\r\n    onlyWallet\r\n    whenOwnerExists(_oldOwner)\r\n    whenOwnerDoesNotExist(_newOwner)\r\n    {\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (owners[i] == _oldOwner) {\r\n                owners[i] = _newOwner;\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 power = ownersPowers[_oldOwner];\r\n        ownersPowers[_newOwner] = power;\r\n        ownersPowers[_oldOwner] = 0;\r\n\r\n        emit LogOwnerRemoval(_oldOwner);\r\n        emit LogOwnerAddition(_newOwner, power);\r\n    }\r\n\r\n    function changeRequiredPower(uint256 _newPower)\r\n    public\r\n    onlyWallet\r\n    validRequirement(owners.length, totalCurrentPower, _newPower)\r\n    {\r\n        requiredPower = _newPower;\r\n        emit LogPowerChange(_newPower);\r\n    }\r\n\r\n    function submitTransaction(address _destination, uint256 _value, bytes memory _data)\r\n    public\r\n    returns (uint256 transactionId)\r\n    {\r\n        transactionId = _addTransaction(_destination, _value, _data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    function confirmTransactions(uint256[] calldata _transactionsIds) external {\r\n        for (uint i=0; i < _transactionsIds.length; i++) {\r\n            confirmTransaction(_transactionsIds[i]);\r\n        }\r\n    }\r\n\r\n    function confirmTransaction(uint256 _transactionId)\r\n    public\r\n    whenOwnerExists(msg.sender)\r\n    whenTransactionExists(_transactionId)\r\n    notConfirmedBy(_transactionId, msg.sender)\r\n    {\r\n        confirmations[_transactionId][msg.sender] = true;\r\n        emit LogConfirmation(msg.sender, _transactionId);\r\n        executeTransaction(_transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param _transactionId Transaction ID.\r\n    function revokeLogConfirmation(uint256 _transactionId)\r\n    public\r\n    whenOwnerExists(msg.sender)\r\n    whenConfirmedBy(_transactionId, msg.sender)\r\n    whenNotExecuted(_transactionId)\r\n    {\r\n        confirmations[_transactionId][msg.sender] = false;\r\n        emit LogRevocation(msg.sender, _transactionId);\r\n    }\r\n\r\n    function executeTransactions(uint256[] calldata _transactionsIds) external {\r\n        for (uint i=0; i < _transactionsIds.length; i++) {\r\n            executeTransaction(_transactionsIds[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param _transactionId Transaction ID.\r\n    function executeTransaction(uint256 _transactionId)\r\n    public\r\n    whenOwnerExists(msg.sender)\r\n    whenConfirmedBy(_transactionId, msg.sender)\r\n    whenNotExecuted(_transactionId)\r\n    {\r\n        if (isConfirmed(_transactionId)) {\r\n            Transaction storage txn = transactions[_transactionId];\r\n            txn.executed = block.timestamp;\r\n\r\n            (bool success, bytes memory returnedData) = txn.destination.call(txn.data);\r\n\r\n            require(success, string(abi.encodePacked(\"executeTransaction failed: \", string(returnedData))));\r\n\r\n            emit LogExecution(_transactionId, returnedData);\r\n        }\r\n    }\r\n\r\n    function _addTransaction(address _destination, uint256 _value, bytes memory _data)\r\n    internal\r\n    notNull(_destination)\r\n    returns (uint256 transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n\r\n        transactions[transactionId] = Transaction({\r\n            destination : _destination,\r\n            value : _value,\r\n            data : _data,\r\n            executed : 0\r\n        });\r\n\r\n        transactionCount += 1;\r\n        emit LogSubmission(transactionId);\r\n    }\r\n\r\n    // ========== VIEWS ========== //\r\n\r\n    function ownersCount() public view returns (uint256) {\r\n        return owners.length;\r\n    }\r\n\r\n    function sum(uint256[] memory _numbers) public pure returns (uint256 total) {\r\n        uint256 numbersCount = _numbers.length;\r\n\r\n        for (uint256 i = 0; i < numbersCount; i++) {\r\n            total += _numbers[i];\r\n        }\r\n    }\r\n\r\n    function isConfirmed(uint256 _transactionId) public view returns (bool) {\r\n        uint256 power = 0;\r\n\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (confirmations[_transactionId][owners[i]]) {\r\n                power += ownersPowers[owners[i]];\r\n            }\r\n\r\n            if (power >= requiredPower) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isExceuted(uint256 _transactionId) public view returns (bool) {\r\n        return transactions[_transactionId].executed != 0;\r\n    }\r\n\r\n    function getTransactionShort(uint256 _transactionId)\r\n    public view returns (address destination, uint256 value, uint256 executed) {\r\n        Transaction memory t = transactions[_transactionId];\r\n        return (t.destination, t.value, t.executed);\r\n    }\r\n\r\n    function getTransaction(uint256 _transactionId)\r\n    public view returns (address destination, uint256 value, uint256 executed, bytes memory data) {\r\n        Transaction memory t = transactions[_transactionId];\r\n        return (t.destination, t.value, t.executed, t.data);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param _transactionId Transaction ID.\r\n    /// @return count Number of confirmations.\r\n    function getLogConfirmationCount(uint256 _transactionId) public view returns (uint256 count)\r\n    {\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (confirmations[_transactionId][owners[i]]) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param _pending Include pending transactions.\r\n    /// @param _executed Include executed transactions.\r\n    /// @return count Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool _pending, bool _executed) public view returns (uint256 count)\r\n    {\r\n        for (uint256 i = 0; i < transactionCount; i++) {\r\n            if (_pending && transactions[i].executed == 0 || _executed && transactions[i].executed != 0) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param _transactionId Transaction ID.\r\n    /// @return _confirmations Returns array of owner addresses.\r\n    function getLogConfirmations(uint256 _transactionId)\r\n    public\r\n    view\r\n    returns (address[] memory _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint256 count = 0;\r\n        uint256 i;\r\n\r\n        for (i = 0; i < owners.length; i++) {\r\n            if (confirmations[_transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        }\r\n\r\n        _confirmations = new address[](count);\r\n\r\n        for (i = 0; i < count; i++) {\r\n            _confirmations[i] = confirmationsTemp[i];\r\n        }\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param _from Index start position of transaction array.\r\n    /// @param _to Index end position of transaction array.\r\n    /// @param _pending Include pending transactions.\r\n    /// @param _executed Include executed transactions.\r\n    /// @return _transactionIds Returns array of transaction IDs.\r\n    function getTransactionIds(uint256 _from, uint256 _to, bool _pending, bool _executed)\r\n    public\r\n    view\r\n    returns (uint256[] memory _transactionIds)\r\n    {\r\n        uint256[] memory transactionIdsTemp = new uint256[](_to - _from);\r\n        uint256 count = 0;\r\n        uint256 i;\r\n\r\n        for (i = _from; i < _to; i++) {\r\n            if (_pending && transactions[i].executed == 0 || _executed && transactions[i].executed != 0) {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        }\r\n\r\n        _transactionIds = new uint256[](count);\r\n\r\n        for (i = 0; i < count; i++) {\r\n            _transactionIds[i] = transactionIdsTemp[i];\r\n        }\r\n    }\r\n\r\n    // ========== EVENTS ========== //\r\n\r\n    event LogConfirmation(address indexed sender, uint256 indexed transactionId);\r\n    event LogRevocation(address indexed sender, uint256 indexed transactionId);\r\n    event LogSubmission(uint256 indexed transactionId);\r\n    event LogExecution(uint256 indexed transactionId, bytes returnedData);\r\n    event LogOwnerAddition(address indexed owner, uint256 power);\r\n    event LogOwnerRemoval(address indexed owner);\r\n    event LogPowerChange(uint256 power);\r\n}\r\n\r\n// File: contracts/UmbMultiSig.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n// Inheritance\r\n\r\n\r\n/// @title   Umbrella MultiSig contract\r\n/// @author  umb.network\r\n/// @notice  This is extended version of PowerMultiSig wallet, that will allow to execute commands without FE.\r\n/// @dev     Original MultiSig requires FE to run, but here, we have some predefined data for few transactions\r\n///          so we can run it directly from Etherscan and not worry about data bytes\r\ncontract UmbMultiSig is PowerMultiSig {\r\n\r\n    // ========== MODIFIERS ========== //\r\n\r\n    // ========== CONSTRUCTOR ========== //\r\n\r\n    constructor(address[] memory _owners, uint256[] memory _powers, uint256 _requiredPower)\r\n    PowerMultiSig(_owners, _powers, _requiredPower) {\r\n    }\r\n\r\n    // ========== VIEWS ========== //\r\n\r\n    function createFunctionSignature(string memory _f) public pure returns (bytes memory) {\r\n        return abi.encodeWithSignature(_f);\r\n    }\r\n\r\n    // ========== MUTATIVE FUNCTIONS ========== //\r\n\r\n    // ========== helpers for: MultiSig\r\n\r\n    function submitAddOwner(address _owner, uint256 _power) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"addOwner(address,uint256)\", _owner, _power);\r\n        return submitTransaction(address(this), 0, data);\r\n    }\r\n\r\n    function submitRemoveOwner(address _owner) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"removeOwner(address)\", _owner);\r\n        return submitTransaction(address(this), 0, data);\r\n    }\r\n\r\n    function submitReplaceOwner(address _old, address _new) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"replaceOwner(address,address)\", _old, _new);\r\n        return submitTransaction(address(this), 0, data);\r\n    }\r\n\r\n    function submitChangeRequiredPower(uint256 _power) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"changeRequiredPower(uint256)\", _power);\r\n        return submitTransaction(address(this), 0, data);\r\n    }\r\n\r\n    // ========== helpers for: UMB, rUMB\r\n\r\n    function submitTokenMintTx(address _destination, address _holder, uint _amount) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"mint(address,uint256)\", _holder, _amount);\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    // ========== helpers for: UMB\r\n\r\n    function submitUMBSetRewardTokensTx(\r\n        address _destination,\r\n        address[] memory _tokens,\r\n        bool[] calldata _statuses\r\n    ) external returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"setRewardTokens(address[],bool[])\", _tokens, _statuses);\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    // ========== helpers for: rUMB\r\n\r\n    function submitRUMBStartEarlySwapTx(address _destination) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"startEarlySwap()\");\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    // ========== helpers for: StakingRewards\r\n\r\n    function submitStakingRewardsSetRewardsDistributionTx(\r\n        address _destination,\r\n        address _rewardsDistributor\r\n    ) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"setRewardsDistribution(address)\", _rewardsDistributor);\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    function submitStakingRewardsSetRewardsDurationTx(address _destination, uint _duration) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"setRewardsDuration(uint256)\", _duration);\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    function submitStakingRewardsNotifyRewardAmountTx(address _destination, uint _amount) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", _amount);\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    function submitStakingRewardsFinishFarmingTx(address _destination) public returns (uint) {\r\n        bytes memory data = abi.encodeWithSignature(\"finishFarming()\");\r\n        return submitTransaction(_destination, 0, data);\r\n    }\r\n\r\n    // ========== EVENTS ========== //\r\n}"}}}