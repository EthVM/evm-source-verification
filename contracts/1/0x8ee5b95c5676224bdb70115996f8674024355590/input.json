{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Lottery.sol": {
      "content": "// SPDX-License-Identifier: Apache2.0\n\npragma solidity ^0.5.0;\n\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathChainlink {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n\n// \ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n\n// \ncontract VRFRequestIDBase {\n\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n    address _requester, uint256 _nonce)\n    internal pure returns (uint256)\n  {\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n\n// \n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\ncontract VRFConsumerBase is VRFRequestIDBase {\n\n  using SafeMathChainlink for uint256;\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\n    internal;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   * @param _seed seed mixed into the input of the VRF.\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\n    internal returns (bytes32 requestId)\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash].add(1);\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal LINK;\n  address private vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) public {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n\ninterface ILotteryDao {\n    enum Era {\n        EXPANSION,\n        NEUTRAL,\n        DEBT\n    }\n\n    function treasury() external view returns (address);\n    function dollar() external view returns (address);\n    function era() external view returns (Era, uint256);\n    function epoch() external view returns (uint256);\n\n    function requestDAI(address recipient, uint256 amount) external;\n}\n\ninterface ILottery {\n    function newGame(uint256[] calldata prizes) external;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Lottery is ILottery, VRFConsumerBase {\n    using SafeMathChainlink for uint256;\n\n    struct Purchase {\n        uint256 ticketStart;\n        uint256 ticketEnd;\n    }\n\n    struct Game {\n        uint256 issuedTickets;\n        uint256 totalPurchases;\n        bool winnersExtracted;\n        bool ongoing;\n        address[] winners;\n        uint256[] winningTickets;\n        uint256[] prizes;\n        bool[] rewardsRedeemed;\n\n        mapping(address => uint256[]) players;\n        mapping(uint256 => Purchase) purchases;\n    }\n    \n    struct LinkVRF {\n        bytes32 keyHash;\n        uint256 fee;\n    }\n\n    ILotteryDao public dao;\n\n    LinkVRF private link;\n\n    uint256 public gameLength;\n    mapping(uint256 => Game) public games;\n\n    constructor()\n        VRFConsumerBase(\n            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, // VRF Coordinator\n            0x514910771AF9Ca656af840dff83E8264EcF986CA  // LINK Token\n        ) public\n    {\n        dao = ILotteryDao(0x0aF9087FE3e8e834F3339FE4bEE87705e84Fd488);\n        link.fee = 2e18;\n        link.keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\n    }\n\n    event GameStarted(uint256 indexed gameIndex, uint256[] prizes);\n    event TicketsPurchase(address indexed sender, uint256 indexed purchaseId, uint256 indexed lotteryId, uint256 ticketStart, uint256 ticketEnd);\n    event LotteryEnded(uint256 indexed lotteryId);\n    event WinningTicketsSorted(uint256 indexed lotteryId, uint256[] winningTickets);\n    event RewardRedeemed(address indexed recipient, uint256 indexed lotteryId, uint256 reward);\n\n    modifier onlyDAO() {\n        require(msg.sender == address(dao), \"Lottery: sender isn't the DAO\");\n        _;\n    }\n\n    function gameIndex() public view returns (uint256) {\n        return gameLength.sub(1);\n    }\n\n    function treasury() public view returns (address) {\n        return dao.treasury();\n    }\n\n    function dollar() public view returns (IERC20) {\n        return IERC20(dao.dollar());\n    }\n\n    function getWinners(uint256 gameIndex) external view returns(address[] memory) {\n        return games[gameIndex].winners;\n    }\n\n    function getWinningTickets(uint256 gameIndex) external view returns(uint256[] memory) {\n        return games[gameIndex].winningTickets;\n    }\n\n    function getPrizes(uint256 gameIndex) external view returns(uint256[] memory) {\n        return games[gameIndex].prizes;\n    }\n\n    function getIssuedTickets(uint256 gameIndex) external view returns (uint256) {\n        return games[gameIndex].issuedTickets;\n    }\n\n    function getRedeemedPrizes(uint256 gameIndex) external view returns(bool[] memory) {\n        return games[gameIndex].rewardsRedeemed;\n    }\n\n    function isOngoing(uint256 gameIndex) external view returns(bool) {\n        return games[gameIndex].ongoing;\n    }\n\n    function areWinnersExtracted(uint256 gameIndex) external view returns(bool) {\n        return games[gameIndex].winnersExtracted;\n    }\n\n    function getTotalPurchases(uint256 gameIndex) external view returns(uint256) {\n        return games[gameIndex].totalPurchases;\n    }\n\n    function getPlayerPurchaseIndexes(uint256 gameIndex, address player) external view returns(uint256[] memory) {\n        return games[gameIndex].players[player];\n    }\n\n    function getPurchase(uint256 gameIndex, uint256 purchaseIndex) external view returns(uint256, uint256) {\n        return (games[gameIndex].purchases[purchaseIndex].ticketStart, games[gameIndex].purchases[purchaseIndex].ticketEnd);\n    }\n\n    function newGame(uint256[] calldata prizes) external onlyDAO {   \n        require(LINK.balanceOf(address(this)) >= link.fee, \"Lottery: Insufficient link balance\");\n\n        if (gameLength > 0)\n            require(games[gameIndex()].winnersExtracted, \"Lottery: can't start a new lottery before the winner is extracted\");\n\n        games[gameLength].ongoing = true;\n        games[gameLength].prizes = prizes;\n        games[gameLength].winners = new address[](prizes.length);\n        games[gameLength].rewardsRedeemed = new bool[](prizes.length);\n\n        emit GameStarted(gameLength, prizes);\n\n        gameLength++;\n    }\n\n    function changeChainlinkData(bytes32 keyHash, uint256 fee) external onlyDAO {\n        link.keyHash = keyHash;\n        link.fee = fee;\n    }\n\n    function purchaseTickets(uint256 amount) external {\n        require(amount >= 10e18, \"Lottery: Insufficient purchase amount\");\n\n        uint256 finalizedAmount = amount.sub(amount % 10e18);\n\n        Game storage game = games[gameIndex()];\n\n        require(game.ongoing, \"Lottery: No ongoing game\");\n\n        dollar().transferFrom(msg.sender, treasury(), finalizedAmount);\n\n        uint256 newTickets = finalizedAmount.div(10e18);\n\n        Purchase memory purchase = Purchase(\n            game.issuedTickets,\n            game.issuedTickets.add(newTickets) - 1\n        );\n\n        game.players[msg.sender].push(game.totalPurchases);\n        game.purchases[game.totalPurchases] = purchase;\n\n        game.issuedTickets = game.issuedTickets.add(newTickets);\n\n        emit TicketsPurchase(msg.sender, game.totalPurchases, gameIndex(), purchase.ticketStart, purchase.ticketEnd);\n\n        game.totalPurchases += 1;\n    }\n\n    function extractWinner() external {\n        Game storage game = games[gameIndex()];\n        require(game.ongoing, \"Lottery: winner already extracted\");\n\n        (ILotteryDao.Era era, uint256 start) = dao.era();\n        require(era == ILotteryDao.Era.EXPANSION && dao.epoch() >= start + 3, \"Lottery: Can only extract during expansion\");\n\n        game.ongoing = false;\n\n        requestRandomness(link.keyHash, link.fee, uint256(keccak256(abi.encodePacked(block.number, block.difficulty, now))));\n\n        emit LotteryEnded(gameIndex());\n    }\n\n    function redeemReward(uint256 gameIndex, uint256 purchaseIndex, uint256 winningTicket) external {\n        Game storage game = games[gameIndex];\n\n        require(game.winnersExtracted, \"Lottery: winner hasn't been extracted yet\");\n        \n        bool found;\n        uint256 index;\n        for (uint256 i = 0; i < game.winningTickets.length; i++) {\n            if (winningTicket == game.winningTickets[i]) {\n                found = true;\n                index = i;\n                break;\n            }\n        }\n\n        require(found, \"Lottery: winning ticket not found\");\n        require(!game.rewardsRedeemed[index], \"Lottery: Reward already redeemed\");\n\n        game.rewardsRedeemed[index] = true;\n\n        Purchase storage purchase = game.purchases[game.players[msg.sender][purchaseIndex]];\n\n        require(purchase.ticketStart <= winningTicket && purchase.ticketEnd >= winningTicket, \"Lottery: purchase doesn't contain the winning ticket\");\n\n        dao.requestDAI(msg.sender, game.prizes[index]);\n\n        game.winners[index] = msg.sender;\n\n        emit RewardRedeemed(msg.sender, gameIndex, game.prizes[index]);\n    }\n\n    /**\n     * Callback function used by VRF Coordinator\n     */\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal {\n        Game storage game = games[gameIndex()];\n        \n        for (uint256 i = 0; i < game.prizes.length; i++) {\n            game.winningTickets.push(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, randomness, game.prizes[i]))) % game.issuedTickets);\n        }\n\n        game.winnersExtracted = true;\n\n        emit WinningTicketsSorted(gameIndex(), game.winningTickets);\n    }\n\n}"
    }
  }
}