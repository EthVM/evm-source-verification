{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Voting.sol": {
      "content": "// File: contracts/zeppelin/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n* @title Ownable\r\n* @dev The Ownable contract has an owner address, and provides basic authorization control\r\n* functions, this simplifies the implementation of \"user permissions\".\r\n*/\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n    * @return the address of the owner.\r\n    */\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @return true if `msg.sender` is the owner of the contract.\r\n    */\r\n    function isOwner() public view returns(bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/HydroInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface HydroInterface {\r\n    function balances(address) external view returns (uint);\r\n    function allowed(address, address) external view returns (uint);\r\n    function transfer(address _to, uint256 _amount) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function approve(address _spender, uint256 _amount) external returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes calldata _extraData)\r\n        external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function authenticate(uint _value, uint _challenge, uint _partnerId) external;\r\n}\r\n\r\n// File: contracts/interfaces/SnowflakeInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface SnowflakeInterface {\r\n    function deposits(uint) external view returns (uint);\r\n    function resolverAllowances(uint, address) external view returns (uint);\r\n\r\n    function identityRegistryAddress() external returns (address);\r\n    function hydroTokenAddress() external returns (address);\r\n    function clientRaindropAddress() external returns (address);\r\n\r\n    function setAddresses(address _identityRegistryAddress, address _hydroTokenAddress) external;\r\n    function setClientRaindropAddress(address _clientRaindropAddress) external;\r\n\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, string calldata casedHydroId,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addProvidersFor(\r\n        address approvingAddress, address[] calldata providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function removeProvidersFor(\r\n        address approvingAddress, address[] calldata providers, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function upgradeProvidersFor(\r\n        address approvingAddress, address[] calldata newProviders, address[] calldata oldProviders,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function addResolver(address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData) external;\r\n    function addResolverAsProvider(\r\n        uint ein, address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData\r\n    ) external;\r\n    function addResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, uint withdrawAllowance, bytes calldata extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function changeResolverAllowances(address[] calldata resolvers, uint[] calldata withdrawAllowances) external;\r\n    function changeResolverAllowancesDelegated(\r\n        address approvingAddress, address[] calldata resolvers, uint[] calldata withdrawAllowances,\r\n        uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n    function removeResolver(address resolver, bool isSnowflake, bytes calldata extraData) external;\r\n    function removeResolverFor(\r\n        address approvingAddress, address resolver, bool isSnowflake, bytes calldata extraData,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n\r\n    function triggerRecoveryAddressChangeFor(\r\n        address approvingAddress, address newRecoveryAddress, uint8 v, bytes32 r, bytes32 s\r\n    ) external;\r\n\r\n    function transferSnowflakeBalance(uint einTo, uint amount) external;\r\n    function withdrawSnowflakeBalance(address to, uint amount) external;\r\n    function transferSnowflakeBalanceFrom(uint einFrom, uint einTo, uint amount) external;\r\n    function withdrawSnowflakeBalanceFrom(uint einFrom, address to, uint amount) external;\r\n    function transferSnowflakeBalanceFromVia(uint einFrom, address via, uint einTo, uint amount, bytes calldata _bytes)\r\n        external;\r\n    function withdrawSnowflakeBalanceFromVia(uint einFrom, address via, address to, uint amount, bytes calldata _bytes)\r\n        external;\r\n}\r\n\r\n// File: contracts/interfaces/SnowflakeResolverInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface SnowflakeResolverInterface {\r\n    function callOnAddition() external view returns (bool);\r\n    function callOnRemoval() external view returns (bool);\r\n    function onAddition(uint ein, uint allowance, bytes calldata extraData) external returns (bool);\r\n    function onRemoval(uint ein, bytes calldata extraData) external returns (bool);\r\n}\r\n\r\n// File: contracts/SnowflakeResolver.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract SnowflakeResolver is Ownable {\r\n    string public snowflakeName;\r\n    string public snowflakeDescription;\r\n\r\n    address public snowflakeAddress;\r\n\r\n    bool public callOnAddition;\r\n    bool public callOnRemoval;\r\n\r\n    constructor(\r\n        string memory _snowflakeName, string memory _snowflakeDescription,\r\n        address _snowflakeAddress,\r\n        bool _callOnAddition, bool _callOnRemoval\r\n    )\r\n        public\r\n    {\r\n        snowflakeName = _snowflakeName;\r\n        snowflakeDescription = _snowflakeDescription;\r\n\r\n        setSnowflakeAddress(_snowflakeAddress);\r\n\r\n        callOnAddition = _callOnAddition;\r\n        callOnRemoval = _callOnRemoval;\r\n    }\r\n\r\n    modifier senderIsSnowflake() {\r\n        require(msg.sender == snowflakeAddress, \"Did not originate from Snowflake.\");\r\n        _;\r\n    }\r\n\r\n    // this can be overriden to initialize other variables, such as e.g. an ERC20 object to wrap the HYDRO token\r\n    function setSnowflakeAddress(address _snowflakeAddress) public onlyOwner {\r\n        snowflakeAddress = _snowflakeAddress;\r\n    }\r\n\r\n    // if callOnAddition is true, onAddition is called every time a user adds the contract as a resolver\r\n    // this implementation **must** use the senderIsSnowflake modifier\r\n    // returning false will disallow users from adding the contract as a resolver\r\n    function onAddition(uint ein, uint allowance, bytes memory extraData) public returns (bool);\r\n\r\n    // if callOnRemoval is true, onRemoval is called every time a user removes the contract as a resolver\r\n    // this function **must** use the senderIsSnowflake modifier\r\n    // returning false soft prevents users from removing the contract as a resolver\r\n    // however, note that they can force remove the resolver, bypassing onRemoval\r\n    function onRemoval(uint ein, bytes memory extraData) public returns (bool);\r\n\r\n    function transferHydroBalanceTo(uint einTo, uint amount) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(hydro.approveAndCall(snowflakeAddress, amount, abi.encode(einTo)), \"Unsuccessful approveAndCall.\");\r\n    }\r\n\r\n    function withdrawHydroBalanceTo(address to, uint amount) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(hydro.transfer(to, amount), \"Unsuccessful transfer.\");\r\n    }\r\n\r\n    function transferHydroBalanceToVia(address via, uint einTo, uint amount, bytes memory snowflakeCallBytes) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(\r\n            hydro.approveAndCall(\r\n                snowflakeAddress, amount, abi.encode(true, address(this), via, einTo, snowflakeCallBytes)\r\n            ),\r\n            \"Unsuccessful approveAndCall.\"\r\n        );\r\n    }\r\n\r\n    function withdrawHydroBalanceToVia(address via, address to, uint amount, bytes memory snowflakeCallBytes) internal {\r\n        HydroInterface hydro = HydroInterface(SnowflakeInterface(snowflakeAddress).hydroTokenAddress());\r\n        require(\r\n            hydro.approveAndCall(\r\n                snowflakeAddress, amount, abi.encode(false, address(this), via, to, snowflakeCallBytes)\r\n            ),\r\n            \"Unsuccessful approveAndCall.\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IdentityRegistryInterface.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\ninterface IdentityRegistryInterface {\r\n    function isSigned(address _address, bytes32 messageHash, uint8 v, bytes32 r, bytes32 s)\r\n        external pure returns (bool);\r\n\r\n    // Identity View Functions /////////////////////////////////////////////////////////////////////////////////////////\r\n    function identityExists(uint ein) external view returns (bool);\r\n    function hasIdentity(address _address) external view returns (bool);\r\n    function getEIN(address _address) external view returns (uint ein);\r\n    function isAssociatedAddressFor(uint ein, address _address) external view returns (bool);\r\n    function isProviderFor(uint ein, address provider) external view returns (bool);\r\n    function isResolverFor(uint ein, address resolver) external view returns (bool);\r\n    function getIdentity(uint ein) external view returns (\r\n        address recoveryAddress,\r\n        address[] memory associatedAddresses, address[] memory providers, address[] memory resolvers\r\n    );\r\n\r\n    // Identity Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function createIdentity(address recoveryAddress, address[] calldata providers, address[] calldata resolvers)\r\n        external returns (uint ein);\r\n    function createIdentityDelegated(\r\n        address recoveryAddress, address associatedAddress, address[] calldata providers, address[] calldata resolvers,\r\n        uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external returns (uint ein);\r\n    function addAssociatedAddress(\r\n        address approvingAddress, address addressToAdd, uint8 v, bytes32 r, bytes32 s, uint timestamp\r\n    ) external;\r\n    function addAssociatedAddressDelegated(\r\n        address approvingAddress, address addressToAdd,\r\n        uint8[2] calldata v, bytes32[2] calldata r, bytes32[2] calldata s, uint[2] calldata timestamp\r\n    ) external;\r\n    function removeAssociatedAddress() external;\r\n    function removeAssociatedAddressDelegated(address addressToRemove, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function addProviders(address[] calldata providers) external;\r\n    function addProvidersFor(uint ein, address[] calldata providers) external;\r\n    function removeProviders(address[] calldata providers) external;\r\n    function removeProvidersFor(uint ein, address[] calldata providers) external;\r\n    function addResolvers(address[] calldata resolvers) external;\r\n    function addResolversFor(uint ein, address[] calldata resolvers) external;\r\n    function removeResolvers(address[] calldata resolvers) external;\r\n    function removeResolversFor(uint ein, address[] calldata resolvers) external;\r\n\r\n    // Recovery Management Functions ///////////////////////////////////////////////////////////////////////////////////\r\n    function triggerRecoveryAddressChange(address newRecoveryAddress) external;\r\n    function triggerRecoveryAddressChangeFor(uint ein, address newRecoveryAddress) external;\r\n    function triggerRecovery(uint ein, address newAssociatedAddress, uint8 v, bytes32 r, bytes32 s, uint timestamp)\r\n        external;\r\n    function triggerDestruction(\r\n        uint ein, address[] calldata firstChunk, address[] calldata lastChunk, bool resetResolvers\r\n    ) external;\r\n}\r\n\r\n// File: contracts/resolvers/Voting.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Voting is SnowflakeResolver {\r\nmapping(uint=>Candidate) public candidates;\r\nmapping(uint=>bool) public aParticipant;\r\nmapping(uint=>bool) public aCandidate;\r\nmapping(uint=>bool) private hasVoted;\r\n\r\nstruct Candidate{\r\n    uint voteCount;\r\n}\r\n\r\n\r\n//uint256 candidateFee= 20000000000000000000;//200tokens\r\nuint256 regFee= 100000000000000000000;//100tokens\r\n\r\n//this is the routed address where all fees will go to be later burned\r\naddress public FEEWALLET;\r\n\r\n\r\nuint256 burnAmount=1000000000000000000000;//1000tokens\r\nuint maxNoOfCandidates=2;\r\naddress _snowflakeAddress;\r\nuint deadlineInDays;\r\n\r\nuint[] candidateEINs;\r\nuint[] voterEINs;\r\n\r\n//requires that the ein is a registered candidate\r\nmodifier isCandidate(uint ein){\r\n    require(aCandidate[ein]==true,'This EIN has not registered as a candidate');\r\n    _;\r\n}\r\n\r\n//requires that the ein has set this contract a resolver\r\nmodifier isParticipant(uint _ein){\r\n    require(aParticipant[_ein]==true, 'this EIN has not registered as a participant');\r\n    _;\r\n}\r\n\r\n//requires that the entered ein is not a candidate yet\r\nmodifier isNotCandidate(uint _ein){\r\n    require(aParticipant[_ein]==true && aCandidate[_ein]==false,\"you are a candidate\");\r\n    _;\r\n}\r\n\r\n//requires that the target does not have a hydroId yet\r\nmodifier noIdYet(address target){\r\n    require(checkforReg(target)==false);\r\n    _;\r\n}\r\n\r\nmodifier HasEIN(address target){\r\n    require(checkforReg(target)==true);\r\n    _;\r\n}\r\n\r\n//requires that the deadline hasn't passed\r\nmodifier voteStillValid(){\r\n    require (now<=deadlineInDays,\"this election has expired\");\r\n    _;\r\n}\r\n\r\n\r\nevent voted(uint _candidate);\r\nevent becameCandidate(uint _candidateEIN);\r\nevent registeredAsVoter(uint voterEin);\r\nevent newDeadlineSet(uint _newDeadline);\r\n\r\n constructor (address snowflakeAddress,string memory _name,string memory _description,uint _days,address feeOwner)\r\n        SnowflakeResolver(_name, _description, snowflakeAddress, true, false) public\r\n    {\r\n        snowflakeAddress=_snowflakeAddress;\r\n        deadlineInDays=now+_days*1 days;\r\n        FEEWALLET=feeOwner;\r\n        \r\n    }\r\n//sets the maximum no of candidates for this resolver\r\n//can only be set by contract owner\r\nfunction setMaxCandidacy(uint _max) public  voteStillValid() onlyOwner(){\r\n    maxNoOfCandidates=_max;\r\n}\r\n//check if address interacting with contract already has an ein\r\nfunction checkforReg(address _target) public  returns(bool){\r\n    SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n    IdentityRegistryInterface idRegistry= IdentityRegistryInterface(snowfl.identityRegistryAddress());\r\n    _target=msg.sender;\r\n    bool hasId=idRegistry.hasIdentity(msg.sender);\r\n    return hasId;\r\n}\r\n\r\n//basic check to return ein of the specific address\r\n   function checkEIN(address _address) public returns(uint){\r\n        SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n    IdentityRegistryInterface idRegistry= IdentityRegistryInterface(snowfl.identityRegistryAddress());\r\n       uint Ein=idRegistry.getEIN(_address);\r\n       return Ein;\r\n   }\r\n        \r\n /**   \r\n\r\n//implement create Identity function\r\n//might not be needed for now\r\nfunction createId(address recoveryAddress) public returns(uint ein){\r\n    SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n    IdentityRegistryInterface idRegistry= IdentityRegistryInterface(snowfl.identityRegistryAddress());\r\n    address[] memory _providers = new address [](2);\r\n    address[] memory _resolvers= new address [](1);\r\n    _providers[0]= address(this);\r\n    _providers[1]= _snowflakeAddress;\r\n    _resolvers[0]= address(this);\r\n    \r\n    return idRegistry.createIdentity(recoveryAddress,_providers,_resolvers);\r\n    \r\n    \r\n} \r\n\r\n**/\r\n//called to register any new actor in the system\r\n//makes the ein to be a participant in the system\r\n//a fee of 100 tokens is required\r\nfunction onAddition(uint ein,uint /**allocation**/,bytes memory) public senderIsSnowflake() returns (bool){\r\n    SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n    snowfl.withdrawSnowflakeBalanceFrom(ein, FEEWALLET, regFee );\r\n    aParticipant[ein]=true;\r\n     emit registeredAsVoter(ein);\r\n    return true;\r\n   \r\n}\r\n\r\n function onRemoval(uint, bytes memory) public senderIsSnowflake() returns (bool) {}\r\n \r\n //anyone who wants to become a candidate\r\n //1000 hydro tokens are deducted from the ein of msg.sender and sent to FEEWALLET\r\n function becomeCandidate(uint ein) public isParticipant(ein)  voteStillValid() isNotCandidate(ein){\r\n     SnowflakeInterface snowfl=SnowflakeInterface(snowflakeAddress);\r\n   uint candidateCount= candidateEINs.length;\r\n    require(candidateCount<=maxNoOfCandidates,\"candidate limit reached!\");\r\n    snowfl.withdrawSnowflakeBalanceFrom(ein,FEEWALLET, burnAmount);\r\n    aCandidate[ein]=true;\r\n    candidateEINs.push(ein);\r\n    emit becameCandidate(ein);\r\n }\r\n \r\n //main vote function\r\nfunction vote(uint _ein) public  HasEIN(msg.sender) isCandidate(_ein)  voteStillValid() returns(bool){\r\n SnowflakeInterface snowfl=SnowflakeInterface(snowflakeAddress);\r\n IdentityRegistryInterface idRegistry= IdentityRegistryInterface(snowfl.identityRegistryAddress());\r\n uint ein=checkEIN(msg.sender);\r\n \r\n require(aParticipant[ein]==true,'you are not a voter,register first');\r\n require (aCandidate[ein]==false,\"you are a candidate\");\r\n require(idRegistry.isResolverFor(ein,address(this)),\"This EIN has not set this resolver.\");\r\n require (hasVoted[ein]==false,\"you have already voted\");\r\n \r\n candidates[_ein].voteCount++;\r\n hasVoted[ein]=true;\r\n  emit voted(_ein);\r\n return (true);\r\n\r\n\r\n}\r\n//return the current max number of candidates\r\nfunction getMaxCandidates() public view returns(uint[] memory,uint){\r\n    return(candidateEINs,maxNoOfCandidates);\r\n}\r\n\r\n\r\n\r\n    function withdrawFees(address to) public onlyOwner {\r\n        SnowflakeInterface snowfl = SnowflakeInterface(snowflakeAddress);\r\n        HydroInterface hydro = HydroInterface(snowfl.hydroTokenAddress());\r\n        withdrawHydroBalanceTo(to, hydro.balanceOf(address(this)));\r\n    }\r\n    \r\n    function setNewDeadline(uint _newDays) public onlyOwner voteStillValid returns(uint){\r\n        deadlineInDays=now+_newDays*1 days;\r\n        emit newDeadlineSet(deadlineInDays);\r\n        return deadlineInDays;\r\n    }\r\n    \r\n    function getDeadline() public view returns(uint){\r\n        return deadlineInDays;\r\n    }\r\n\r\n}"
    }
  }
}