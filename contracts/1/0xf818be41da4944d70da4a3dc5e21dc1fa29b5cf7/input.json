{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MvpLockedWallet.sol":{"content":"pragma solidity ^0.4.26;\r\n\r\n\r\n/// MVP locked wallet\r\n/// @author Forest Wang - <forest@merculet.io>\r\n/// 必须是owners发起取款，auditor进行确认\r\n// MvpLockedWallet\r\ncontract MvpLockedWallet {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event TransactionNotAllowed(address indexed destination);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event BalanceNotEnough(address indexed owner, uint indexed withdrawValue, uint indexed balance);\r\n    event BalanceAddition(address indexed owner, uint indexed changeValue, uint indexed balance);\r\n    event BalanceSubtraction(address indexed owner, uint indexed changeValue, uint indexed balance);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping(uint => Transaction) public transactions;\r\n    mapping(uint => mapping(address => bool)) public confirmations;\r\n    mapping(address => bool) public isOwner;\r\n    mapping(address => uint256) public tokenBalance;\r\n    address[] public owners;\r\n    address public auditor;\r\n    address public contractAddress;\r\n    uint public transactionCount;\r\n\r\n    /*\r\n     *  Struct\r\n     */\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n        bool multiSig;\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n\r\n    modifier validAuditor(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function()\r\n    public\r\n    payable\r\n    {\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /// Contract constructor sets initial owners.\r\n    /// @param _auditor Auditor of this contract who confirms the transfer out transaction.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _contractAddress Erc20 contract address.\r\n    constructor(address _auditor, address[] _owners, address _contractAddress)\r\n    public\r\n    validAuditor(_auditor)\r\n    {\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n            tokenBalance[_owners[i]] = 0;\r\n        }\r\n        owners = _owners;\r\n        auditor = _auditor;\r\n        contractAddress = _contractAddress;\r\n    }\r\n\r\n    /// Bytes to uint to check method\r\n    function bytesToUint(bytes b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 number;\r\n        for (uint i = 0; i < b.length; i++) {\r\n            number = number + uint(b[i]) * (2 ** (8 * (b.length - (i + 1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    /// GET balance of owner\r\n    /// @param owner Get balance of owner\r\n    function getBalance(address owner)\r\n    public\r\n    view\r\n    ownerExists(owner)\r\n    returns (uint)\r\n    {\r\n        return tokenBalance[owner];\r\n    }\r\n\r\n    /// Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address, it must be the contract or Erc20 contract address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n    public\r\n    returns (uint transactionId)\r\n    {\r\n        if (destination != contractAddress && destination != address(this)) {\r\n            emit TransactionNotAllowed(destination);\r\n            return;\r\n        }\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data)) {\r\n                // Erc20 contract transfer\r\n                if (txn.destination == contractAddress) {\r\n                    (bool isTransfer, address to, uint v) = decodeTransferData(txn.data);\r\n                    if (isTransfer) {\r\n                        // subtract balance if not to this contract address\r\n                        if (address(this) != to) {\r\n                            tokenBalance[to] = tokenBalance[to].sub(v);\r\n                            emit BalanceSubtraction(to, v, tokenBalance[to]);\r\n                        }\r\n                    }\r\n                    (bool isTransferFrom,  address from2, address to2, uint v2) = decodeTransferFromData(txn.data);\r\n                    if (isTransferFrom && address(this) == to2) {\r\n                        tokenBalance[from2] = tokenBalance[from2].add(v2);\r\n                        emit BalanceAddition(from2, v2, tokenBalance[from2]);\r\n                        if (!isOwner[from2] && msg.sender == auditor) {\r\n                            // Add from2 into owner if it is not in\r\n                            isOwner[from2] = true;\r\n                            owners.push(from2);\r\n                            emit OwnerAddition(from2);\r\n                        }\r\n                    }\r\n                }\r\n                emit Execution(transactionId);\r\n            } else {\r\n                emit ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // call has been separated into its own function in order to take advantage\r\n    // of the Solidity's code generator to produce a loop that copies tx.data into memory.\r\n    function external_call(address destination, uint value, uint dataLength, bytes data)\r\n    internal\r\n    returns (bool)\r\n    {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n            sub(gas, 34710), // 34710 is the value that solidity is currently emitting\r\n            // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n            // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n            destination,\r\n            value,\r\n            d,\r\n            dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\r\n            x,\r\n            0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n    public\r\n    returns (bool)\r\n    {\r\n        Transaction storage txn = transactions[transactionId];\r\n        (bool isTransfer, address to, uint v) = decodeTransferData(txn.data);\r\n        if (!transactions[transactionId].multiSig) {\r\n            if (txn.destination == contractAddress) {\r\n                if (isTransfer) {\r\n                    to;\r\n                    v;\r\n                    return true;\r\n                }\r\n                (bool isTransferFrom,  address from2, address to2, uint v2) = decodeTransferFromData(txn.data);\r\n                if (isTransferFrom) {\r\n                    from2;\r\n                    to2;\r\n                    v2;\r\n                    return true;\r\n                }\r\n            }\r\n            if (msg.sender == auditor) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (txn.destination == contractAddress) {\r\n                // withdraw check balance if transfer to other address from contract address\r\n                if (isTransfer && to != address(this)) {\r\n                    if (v > tokenBalance[to]) {\r\n                        emit BalanceNotEnough(to, v, tokenBalance[to]);\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            uint count = 0;\r\n            for (uint i = 0; i < owners.length; i++) {\r\n                if (confirmations[transactionId][owners[i]])\r\n                    count += 1;\r\n            }\r\n            if (count >= 2 && msg.sender == auditor) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        Transaction memory txn = Transaction({\r\n        destination : destination,\r\n        value : value,\r\n        data : data,\r\n        executed : false,\r\n        multiSig : true});\r\n\r\n        // if the method is add remove replace and change daily not need multi sig\r\n        uint256 iMethod = decodeMethod(data);\r\n        // check method\r\n        if (iMethod == 1885719368) {// add owner\r\n            txn.multiSig = false;\r\n        }\r\n        if (destination == contractAddress) {\r\n            (bool isTransfer, address to,) = decodeTransferData(data);\r\n            // not need multiSig if to contract\r\n            if (isTransfer && address(this) == to)\r\n                txn.multiSig = false;\r\n            (bool isTransferFrom,  , address to2,) = decodeTransferFromData(data);\r\n            // not need multiSig if to contract\r\n            if (isTransferFrom && address(this) == to2)\r\n                txn.multiSig = false;\r\n        }\r\n        transactions[transactionId] = txn;\r\n        transactionCount = transactionCount.add(1);\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /// Decode method from data\r\n    /// @param data transaction data\r\n    function decodeMethod(bytes data)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        if (data .length > 4) {\r\n            bytes memory method = new bytes(4);\r\n            for (uint j = 0; j < 4; j++)\r\n                method[j] = data[j];\r\n            return bytesToUint(method);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /// Decode method transfer from data\r\n    /// @param data transaction data\r\n    function decodeTransferData(bytes data)\r\n    internal\r\n    pure\r\n    returns (bool isTransfer, address to, uint v)\r\n    {\r\n        isTransfer = false;\r\n        if (data.length >= 36) {\r\n            uint256 iMethod = decodeMethod(data);\r\n            // Transfer\r\n            if (iMethod == 2835717307) {\r\n                bytes memory toAddress = new bytes(20);\r\n                for (uint k = 16; k < 36; k++)\r\n                    toAddress[k - 16] = data[k];\r\n                to = address(bytesToUint(toAddress));\r\n                bytes memory value = new bytes(20);\r\n                for (k = 48; k < 68; k++)\r\n                    value[k - 48] = data[k];\r\n                v = bytesToUint(value);\r\n                isTransfer = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// Decode method transferFrom from data\r\n    /// @param data transaction data\r\n    function decodeTransferFromData(bytes data)\r\n    internal\r\n    pure\r\n    returns (bool isTransferFrom, address from, address to, uint v)\r\n    {\r\n        isTransferFrom = false;\r\n        if (data.length >= 100) {\r\n            uint256 iMethod = decodeMethod(data);\r\n            // TransferFrom\r\n            if (iMethod == 599290589) {\r\n                bytes memory fromAddress = new bytes(20);\r\n                for (uint k = 16; k < 36; k++)\r\n                    fromAddress[k - 16] = data[k];\r\n                from = address(bytesToUint(fromAddress));\r\n                bytes memory toAddress = new bytes(20);\r\n                for (k = 48; k < 68; k++)\r\n                    toAddress[k - 48] = data[k];\r\n                to = address(bytesToUint(toAddress));\r\n                bytes memory value = new bytes(20);\r\n                for (k = 80; k < 100; k++)\r\n                    value[k - 80] = data[k];\r\n                v = bytesToUint(value);\r\n                isTransferFrom = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i = 0; i < owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i = 0; i < transactionCount; i++)\r\n            if (pending && !transactions[i].executed\r\n            || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n    public\r\n    constant\r\n    returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n    public\r\n    constant\r\n    returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i = 0; i < count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < transactionCount; i++)\r\n            if (pending && !transactions[i].executed\r\n            || executed && transactions[i].executed) {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i = from; i < to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n}"}}}