{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Birbtoken.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\n\r\n/*\r\nThis contract allows anyone to atomically mutate ERC20 tokens to a new token and back at a 1:1 ratio.  \r\nThis contract is atomic, decentralized, and has no owner.\r\n*/\r\n \r\n\r\nabstract contract ERC20Basic {\r\n  function totalSupply() virtual public view returns (uint256);\r\n  function balanceOf(address who) virtual public view returns (uint256);\r\n  function transfer(address to, uint256 value) virtual public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nabstract contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    virtual public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    virtual public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) virtual public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\nabstract contract ApproveAndCallFallBack {\r\n\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\r\n\r\n}\r\n \r\n\r\ncontract _AtomicProxyToken {\r\n    \r\n  \r\n    address public _originalToken;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8  public decimals = 8;\r\n    uint private _totalSupply;\r\n    \r\n    uint public supplyFactor = 100000000;\r\n\r\n    event  Approval(address src, address ext, uint amt);\r\n    event  Transfer(address src, address dst, uint amt); \r\n\r\n    mapping (address => uint)                       public  balances;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n    mapping (address => uint)                       public  nonces;\r\n    \r\n    uint256 immutable MAX_INT  = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    \r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\r\n    \r\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\r\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n\r\n  \r\n\r\n   constructor(string memory tokenName, string memory tokenSymbol, address mutatingToken){\r\n       name = tokenName;\r\n       symbol = tokenSymbol;\r\n       _originalToken = mutatingToken;\r\n   }    \r\n\r\n    /**\r\n     *  \r\n     * @dev Deposit original tokens, receive proxy tokens \r\n     * @param amount Amount of original tokens to charge\r\n     */\r\n    function depositTokens(address from, uint amount) internal returns (bool)\r\n    {\r\n        require( amount > 0 );\r\n        \r\n        require( ERC20( _originalToken ).transferFrom( from, address(this), amount) );\r\n            \r\n        balances[from] += (amount * supplyFactor);\r\n        _totalSupply += (amount * supplyFactor);\r\n        \r\n        emit Transfer(address(0x0), from, amount);\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Withdraw original tokens, dissipate proxy tokens \r\n     * @param amount Amount of original tokens to release\r\n     */\r\n    function withdrawTokens(uint amount) public returns (bool)\r\n    {\r\n        address from = msg.sender;\r\n        require( amount > 0 );\r\n        \r\n        balances[from] -= (amount * supplyFactor);\r\n        _totalSupply -=  (amount * supplyFactor);\r\n        \r\n        emit Transfer( from, address(0x0), amount);\r\n            \r\n        require( ERC20( _originalToken ).transfer( from, amount) ); \r\n        \r\n        return true;\r\n    }\r\n    \r\n    \r\n     /**\r\n     * Do not allow Ether to enter \r\n     */\r\n     fallback()  external payable  \r\n    {\r\n        revert();\r\n    }\r\n    \r\n    \r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address ext, uint amt) public returns (bool) {\r\n        allowance[msg.sender][ext] = amt;\r\n        emit Approval(msg.sender, ext, amt);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint tokens) public returns (bool) {\r\n        address from = msg.sender;\r\n        balances[from] = balances[from] - (tokens);\r\n        \r\n        balances[to] = balances[to] + (tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = balances[from] - (tokens);\r\n        allowance[from][msg.sender] = allowance[from][msg.sender] - (tokens);\r\n        balances[to] = balances[to] + (tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n\r\n        allowance[msg.sender][spender] = tokens;\r\n\r\n        emit Approval(msg.sender, spender, tokens);\r\n\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n\r\n        return true;\r\n\r\n    }\r\n    \r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public returns (bool success) {\r\n        \r\n        require( token == _originalToken );\r\n        \r\n        require( depositTokens(from, tokens) );\r\n\r\n        return true;\r\n\r\n     }\r\n     \r\n     \r\n      /**\r\n     * @notice Triggers an approval from owner to spends\r\n     * @param owner The address to approve from\r\n     * @param spender The address to be approved\r\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\r\n     * @param deadline The time at which to expire the signature\r\n     * @param v The recovery byte of the signature\r\n     * @param r Half of the ECDSA signature pair\r\n     * @param s Half of the ECDSA signature pair\r\n     */\r\n    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        \r\n       \r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \"permit: invalid signature\");\r\n        require(signatory == owner, \"permit: unauthorized\");\r\n        require(block.timestamp <= deadline, \"permit: signature expired\");\r\n\r\n        allowance[owner][spender] = rawAmount;\r\n\r\n        emit Approval(owner, spender, rawAmount);\r\n    }\r\n    \r\n    \r\n    function getChainId() internal view returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n\r\n}"}}}