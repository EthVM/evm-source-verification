{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/WorkerManager.sol": {
      "content": "// Copyright 2010 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerManager {\n    /// @notice Returns true if worker node is available\n    /// @param workerAddress address of the worker node\n    function isAvailable(address workerAddress) external view returns (bool);\n\n    /// @notice Returns true if worker node is pending\n    /// @param workerAddress address of the worker node\n    function isPending(address workerAddress) external view returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice Get the user of the worker node, which may not be the owner yet, or how was the previous owner of a retired node\n    function getUser(address workerAddress) external view returns (address);\n\n    /// @notice Returns true if worker node is owned by some user\n    function isOwned(address workerAddress) external view returns (bool);\n\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\n    /// @param workerAddress address of the worker\n    function hire(address payable workerAddress) external payable;\n\n    /// @notice Called by the worker to accept the job\n    function acceptJob() external;\n\n    /// @notice Called by the worker to reject a job offer\n    function rejectJob() external payable;\n\n    /// @notice Called by the user to cancel a job offer\n    /// @param workerAddress address of the worker node\n    function cancelHire(address workerAddress) external;\n\n    /// @notice Called by the user to retire his worker.\n    /// @param workerAddress address of the worker to be retired\n    /// @dev this also removes all authorizations in place\n    function retire(address payable workerAddress) external;\n\n    /// @notice Returns true if worker node was retired by its owner\n    function isRetired(address workerAddress) external view returns (bool);\n\n    /// @notice Events signalling every state transition\n    event JobOffer(address indexed worker, address indexed user);\n    event JobAccepted(address indexed worker, address indexed user);\n    event JobRejected(address indexed worker, address indexed user);\n    event Retired(address indexed worker, address indexed user);\n}\n"
    },
    "contracts/WorkerManagerImpl.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerManagerImpl\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\nimport \"./WorkerManager.sol\";\n\ncontract WorkerManagerImpl is WorkerManager {\n    /// @dev user can only hire a worker if he sends more than minimum value\n    uint256 constant MINIMUM_FUNDING = 0.001 ether;\n\n    /// @dev transfers bigger than maximum value should be done directly\n    uint256 constant MAXIMUM_FUNDING = 3 ether;\n\n    /// @notice A worker can be in 4 different states, starting from Available\n    enum WorkerState {Available, Pending, Owned, Retired}\n\n    /// @dev mapping from worker to its user\n    mapping(address => address payable) private userOf;\n\n    /// @dev mapping from worker to its internal state\n    mapping(address => WorkerState) private stateOf;\n\n    function isAvailable(address workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[workerAddress] == WorkerState.Available;\n    }\n\n    function isPending(address workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[workerAddress] == WorkerState.Pending;\n    }\n\n    function getOwner(address _workerAddress)\n        public\n        override\n        view\n        returns (address)\n    {\n        return\n            stateOf[_workerAddress] == WorkerState.Owned\n                ? userOf[_workerAddress]\n                : address(0);\n    }\n\n    function getUser(address _workerAddress)\n        public\n        override\n        view\n        returns (address)\n    {\n        return userOf[_workerAddress];\n    }\n\n    function isOwned(address _workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[_workerAddress] == WorkerState.Owned;\n    }\n\n    function hire(address payable _workerAddress) public override payable {\n        require(isAvailable(_workerAddress), \"worker is not available\");\n        require(_workerAddress != address(0), \"worker address can not be 0x0\");\n        require(msg.value >= MINIMUM_FUNDING, \"funding below minimum\");\n        require(msg.value <= MAXIMUM_FUNDING, \"funding above maximum\");\n\n        // set owner\n        userOf[_workerAddress] = msg.sender;\n\n        // change state\n        stateOf[_workerAddress] = WorkerState.Pending;\n\n        // transfer ether to worker\n        _workerAddress.transfer(msg.value);\n\n        // emit event\n        emit JobOffer(_workerAddress, msg.sender);\n    }\n\n    function acceptJob() public override {\n        require(\n            userOf[msg.sender] != address(0),\n            \"worker does not have a job offer\"\n        );\n        require(\n            stateOf[msg.sender] == WorkerState.Pending,\n            \"worker not is not in pending state\"\n        );\n\n        // change state\n        stateOf[msg.sender] = WorkerState.Owned;\n        // from now on getOwner will return the user\n\n        // emit event\n        emit JobAccepted(msg.sender, userOf[msg.sender]);\n    }\n\n    function rejectJob() public override payable {\n        require(\n            userOf[msg.sender] != address(0),\n            \"worker does not have a job offer\"\n        );\n\n        address payable owner = userOf[msg.sender];\n\n        // reset hirer back to null\n        userOf[msg.sender] = address(0);\n\n        // change state\n        stateOf[msg.sender] = WorkerState.Available;\n\n        // return the money\n        owner.transfer(msg.value);\n\n        // emit event\n        emit JobRejected(msg.sender, userOf[msg.sender]);\n    }\n\n    function cancelHire(address _workerAddress) public override {\n        require(\n            userOf[_workerAddress] != address(0),\n            \"worker does not have a job offer\"\n        );\n\n        require(\n            userOf[_workerAddress] == msg.sender,\n            \"only hirer can cancel the offer\"\n        );\n\n        // change state\n        stateOf[_workerAddress] = WorkerState.Retired;\n\n        // emit event\n        emit JobRejected(_workerAddress, msg.sender);\n    }\n\n    function retire(address payable _workerAddress) public override {\n        require(\n            stateOf[_workerAddress] == WorkerState.Owned,\n            \"worker not owned\"\n        );\n        require(\n            userOf[_workerAddress] == msg.sender,\n            \"only owner can retire worker\"\n        );\n\n        // change state\n        stateOf[_workerAddress] = WorkerState.Retired;\n\n        // emit event\n        emit Retired(_workerAddress, msg.sender);\n    }\n\n    function isRetired(address _workerAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return stateOf[_workerAddress] == WorkerState.Retired;\n    }\n}\n"
    }
  }
}