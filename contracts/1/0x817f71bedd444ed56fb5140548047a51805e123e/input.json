{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FToken.sol": {
      "content": "pragma experimental ABIEncoderV2;\r\npragma solidity 0.6.4;\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\ninterface IInterestRateModel {\r\n    function utilizationRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves\r\n    ) external pure returns (uint256);\r\n\r\n    function getBorrowRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves\r\n    ) external view returns (uint256);\r\n\r\n    function getSupplyRate(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves,\r\n        uint256 reserveFactorMantissa\r\n    ) external view returns (uint256);\r\n\r\n    function APR(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves\r\n    ) external view returns (uint256);\r\n\r\n    function APY(\r\n        uint256 cash,\r\n        uint256 borrows,\r\n        uint256 reserves,\r\n        uint256 reserveFactorMantissa\r\n    ) external view returns (uint256);\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\ninterface IBankController {\r\n    function getCashPrior(address underlying) external view returns (uint256);\r\n\r\n    function getCashAfter(address underlying, uint256 msgValue)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getFTokeAddress(address underlying)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function transferToUser(\r\n        address token,\r\n        address payable user,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function transferIn(\r\n        address account,\r\n        address underlying,\r\n        uint256 amount\r\n    ) external payable;\r\n\r\n    function borrowCheck(\r\n        address account,\r\n        address underlying,\r\n        address fToken,\r\n        uint256 borrowAmount\r\n    ) external;\r\n\r\n    function repayCheck(address underlying) external;\r\n\r\n    function rewardForByType(\r\n        address account,\r\n        uint256 gasSpend,\r\n        uint256 gasPrice,\r\n        uint256 rewardType\r\n    ) external;\r\n\r\n    function liquidateBorrowCheck(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        address borrower,\r\n        address liquidator,\r\n        uint256 repayAmount\r\n    ) external;\r\n\r\n    function liquidateTokens(\r\n        address fTokenBorrowed,\r\n        address fTokenCollateral,\r\n        uint256 actualRepayAmount\r\n    ) external view returns (uint256);\r\n\r\n    function withdrawCheck(\r\n        address fToken,\r\n        address withdrawer,\r\n        uint256 withdrawTokens\r\n    ) external view returns (uint256);\r\n\r\n    function transferCheck(\r\n        address fToken,\r\n        address src,\r\n        address dst,\r\n        uint256 transferTokens\r\n    ) external;\r\n\r\n    function marketsContains(address fToken) external view returns (bool);\r\n\r\n    function seizeCheck(address cTokenCollateral, address cTokenBorrowed)\r\n        external;\r\n\r\n    function mintCheck(address underlying, address minter, uint256 amount) external;\r\n\r\n    function addReserves(address underlying, uint256 addAmount)\r\n        external\r\n        payable;\r\n\r\n    function reduceReserves(\r\n        address underlying,\r\n        address payable account,\r\n        uint256 reduceAmount\r\n    ) external;\r\n\r\n    function calcMaxBorrowAmount(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcMaxWithdrawAmount(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcMaxCashOutAmount(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calcMaxBorrowAmountWithRatio(address user, address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferEthGasCost() external view returns (uint256);\r\n\r\n    function isFTokenValid(address fToken) external view returns (bool);\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return b - a;\r\n        }\r\n        return a - b;\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\ncontract Exponential {\r\n    uint256 constant expScale = 1e18;\r\n    uint256 constant doubleScale = 1e36;\r\n    uint256 constant halfExpScale = expScale / 2;\r\n\r\n    using SafeMath for uint256;\r\n\r\n    function getExp(uint256 num, uint256 denom)\r\n        public\r\n        pure\r\n        returns (uint256 rational)\r\n    {\r\n        rational = num.mul(expScale).div(denom);\r\n    }\r\n\r\n    function getDiv(uint256 num, uint256 denom)\r\n        public\r\n        pure\r\n        returns (uint256 rational)\r\n    {\r\n        rational = num.mul(expScale).div(denom);\r\n    }\r\n\r\n    function addExp(uint256 a, uint256 b) public pure returns (uint256 result) {\r\n        result = a.add(b);\r\n    }\r\n\r\n    function subExp(uint256 a, uint256 b) public pure returns (uint256 result) {\r\n        result = a.sub(b);\r\n    }\r\n\r\n    function mulExp(uint256 a, uint256 b) public pure returns (uint256) {\r\n        uint256 doubleScaledProduct = a.mul(b);\r\n\r\n        uint256 doubleScaledProductWithHalfScale = halfExpScale.add(\r\n            doubleScaledProduct\r\n        );\r\n\r\n        return doubleScaledProductWithHalfScale.div(expScale);\r\n    }\r\n\r\n    function divExp(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return getDiv(a, b);\r\n    }\r\n\r\n    function mulExp3(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c\r\n    ) public pure returns (uint256) {\r\n        return mulExp(mulExp(a, b), c);\r\n    }\r\n\r\n    function mulScalar(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256 scaled)\r\n    {\r\n        scaled = a.mul(scalar);\r\n    }\r\n\r\n    function mulScalarTruncate(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 product = mulScalar(a, scalar);\r\n        return truncate(product);\r\n    }\r\n\r\n    function mulScalarTruncateAddUInt(\r\n        uint256 a,\r\n        uint256 scalar,\r\n        uint256 addend\r\n    ) public pure returns (uint256) {\r\n        uint256 product = mulScalar(a, scalar);\r\n        return truncate(product).add(addend);\r\n    }\r\n\r\n    function divScalarByExpTruncate(uint256 scalar, uint256 divisor)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 fraction = divScalarByExp(scalar, divisor);\r\n        return truncate(fraction);\r\n    }\r\n\r\n    function divScalarByExp(uint256 scalar, uint256 divisor)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numerator = expScale.mul(scalar);\r\n        return getExp(numerator, divisor);\r\n    }\r\n\r\n    function divScalar(uint256 a, uint256 scalar)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a.div(scalar);\r\n    }\r\n\r\n    function truncate(uint256 exp) public pure returns (uint256) {\r\n        return exp.div(expScale);\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\nlibrary EthAddressLib {\r\n    /**\r\n     * @dev returns the address used within the protocol to identify ETH\r\n     * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\ninterface IFToken is IERC20 {\r\n    function mint(address user, uint256 amount) external returns (bytes memory);\r\n\r\n    function borrow(address borrower, uint256 borrowAmount)\r\n        external\r\n        returns (bytes memory);\r\n\r\n    function withdraw(\r\n        address payable withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) external returns (uint256, bytes memory);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function accrueInterest() external;\r\n\r\n    function getAccountState(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    function MonitorEventCallback(\r\n        address who,\r\n        bytes32 funcName,\r\n        bytes calldata payload\r\n    ) external;\r\n\r\n    //用户存借取还操作后的兑换率\r\n    function exchangeRateCurrent() external view returns (uint256 exchangeRate);\r\n\r\n    function repay(address borrower, uint256 repayAmount)\r\n        external\r\n        returns (uint256, bytes memory);\r\n\r\n    function borrowBalanceStored(address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function exchangeRateStored() external view returns (uint256 exchangeRate);\r\n\r\n    function liquidateBorrow(\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        address fTokenCollateral\r\n    ) external returns (bytes memory);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint256);\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256);\r\n\r\n    function _reduceReserves(uint256 reduceAmount) external;\r\n\r\n    function _addReservesFresh(uint256 addAmount) external;\r\n\r\n    function cancellingOut(address striker)\r\n        external\r\n        returns (bool strikeOk, bytes memory strikeLog);\r\n\r\n    function APR() external view returns (uint256);\r\n\r\n    function APY() external view returns (uint256);\r\n\r\n    function calcBalanceOfUnderlying(address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function borrowSafeRatio() external view returns (uint256);\r\n\r\n    function tokenCash(address token, address account)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getBorrowRate() external view returns (uint256);\r\n\r\n    function addTotalCash(uint256 _addAmount) external;\r\n    function subTotalCash(uint256 _subAmount) external;\r\n\r\n    function totalCash() external view returns (uint256);\r\n    function totalReserves() external view returns (uint256);\r\n    function totalBorrows() external view returns (uint256);\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\ninterface IBank {\r\n    function MonitorEventCallback(bytes32 funcName, bytes calldata payload)\r\n        external;\r\n\r\n    function deposit(address token, uint256 amount) external payable;\r\n\r\n    function borrow(address token, uint256 amount) external;\r\n\r\n    function withdraw(address underlying, uint256 withdrawTokens) external;\r\n\r\n    function withdrawUnderlying(address underlying, uint256 amount) external;\r\n\r\n    function repay(address token, uint256 amount) external payable;\r\n\r\n    function liquidateBorrow(\r\n        address borrower,\r\n        address underlyingBorrow,\r\n        address underlyingCollateral,\r\n        uint256 repayAmount\r\n    ) external payable;\r\n\r\n    function tokenIn(address token, uint256 amountIn) external payable;\r\n\r\n    function tokenOut(address token, uint256 amountOut) external;\r\n\r\n    function cancellingOut(address token) external;\r\n\r\n    function paused() external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\ncontract FToken is Exponential, Initializable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals;\r\n\r\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\r\n\r\n    uint256 public initialExchangeRate;\r\n\r\n    address public admin;\r\n\r\n    uint256 public totalBorrows;\r\n\r\n    uint256 public totalReserves;\r\n\r\n    uint256 public reserveFactor;\r\n\r\n    uint256 public borrowIndex;\r\n\r\n    uint256 internal constant borrowRateMax = 0.0005e16;\r\n\r\n    uint256 public accrualBlockNumber;\r\n\r\n    IInterestRateModel public interestRateModel;\r\n\r\n    // 该 fToken 所代表的原生代币\r\n    address public underlying;\r\n\r\n    mapping(address => uint256) public accountTokens;\r\n\r\n    IBankController public controller;\r\n\r\n    uint256 public borrowSafeRatio;\r\n\r\n    address public bank; // bank主合约入口地址\r\n\r\n    bool internal _notEntered;\r\n\r\n    uint256 public constant ONE = 1e18;\r\n\r\n    // 借款人账户\r\n    struct BorrowSnapshot {\r\n        uint256 principal;\r\n        uint256 interestIndex;\r\n    }\r\n\r\n    mapping(address => BorrowSnapshot) public accountBorrows;\r\n    uint256 public totalCash;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event NewInterestRateModel(address oldIRM, uint256 oldUR, uint256 oldAPR, uint256 oldAPY, uint256 exRate1,\r\n        address newIRM, uint256 newUR, uint256 newAPR, uint256 newAPY, uint256 exRate2\r\n    );\r\n    event NewInitialExchangeRate(uint256 oldInitialExchangeRate, uint256 oldUR, uint256 oldAPR, uint256 oldAPY, uint256 exRate1,\r\n        uint256 _initialExchangeRate, uint256 newUR, uint256 newAPR, uint256 newAPY, uint256 exRate2);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function initialize(\r\n        uint256 _initialExchangeRate,\r\n        address _controller,\r\n        address _initialInterestRateModel,\r\n        address _underlying,\r\n        address _bank,\r\n        uint256 _borrowSafeRatio,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) public initializer {\r\n        initialExchangeRate = _initialExchangeRate;\r\n        controller = IBankController(_controller);\r\n        interestRateModel = IInterestRateModel(_initialInterestRateModel);\r\n        admin = msg.sender;\r\n        underlying = _underlying;\r\n        borrowSafeRatio = _borrowSafeRatio;\r\n        accrualBlockNumber = getBlockNumber();\r\n        borrowIndex = ONE;\r\n        bank = _bank;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin, \"require admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyBank {\r\n        require(msg.sender == bank, \"require admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyController {\r\n        require(msg.sender == address(controller), \"require controller\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyRestricted {\r\n        require(\r\n            msg.sender == admin ||\r\n                msg.sender == bank ||\r\n                msg.sender == address(controller) ||\r\n                controller.marketsContains(msg.sender),\r\n            \"only restricted user\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyBankComponent {\r\n        require(\r\n            msg.sender == bank ||\r\n                msg.sender == address(controller) ||\r\n                msg.sender == address(this) ||\r\n                controller.marketsContains(msg.sender),\r\n            \"only bank component\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenUnpaused {\r\n        require(!IBank(bank).paused(), \"System paused\");\r\n        _;\r\n    }\r\n\r\n    function _setController(address _controller) external onlyAdmin {\r\n        controller = IBankController(_controller);\r\n    }\r\n\r\n    function tokenCash(address token, address account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            token != EthAddressLib.ethAddress()\r\n                ? IERC20(token).balanceOf(account)\r\n                : address(account).balance;\r\n    }\r\n\r\n    struct TransferLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 amount_transferred;\r\n        uint256 account_balance;\r\n        address payee_address;\r\n        uint256 payee_balance;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     */\r\n    function transfer(address dst, uint256 amount)\r\n        external\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        // spender - src - dst\r\n        transferTokens(msg.sender, msg.sender, dst, amount);\r\n\r\n        TransferLogStruct memory tls = TransferLogStruct(\r\n            msg.sender,\r\n            underlying,\r\n            address(this),\r\n            amount,\r\n            balanceOf(msg.sender),\r\n            dst,\r\n            balanceOf(dst),\r\n            tokenCash(underlying, address(controller))\r\n        );\r\n\r\n        IBank(bank).MonitorEventCallback(\"Transfer\", abi.encode(tls));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `src` to `dst`\r\n     * @param src The address of the source account\r\n     * @param dst The address of the destination account\r\n     * @param amount The number of tokens to transfer\r\n     */\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amount\r\n    ) external nonReentrant returns (bool) {\r\n        // spender - src - dst\r\n        transferTokens(msg.sender, src, dst, amount);\r\n\r\n        TransferLogStruct memory tls = TransferLogStruct(\r\n            src,\r\n            underlying,\r\n            address(this),\r\n            amount,\r\n            balanceOf(src),\r\n            dst,\r\n            balanceOf(dst),\r\n            tokenCash(underlying, address(controller))\r\n        );\r\n\r\n        IBank(bank).MonitorEventCallback(\"TransferFrom\", abi.encode(tls));\r\n\r\n        return true;\r\n    }\r\n\r\n    // tokens -> 转账的 fToken 的数量\r\n    function transferTokens(\r\n        address spender,\r\n        address src,\r\n        address dst,\r\n        uint256 tokens\r\n    ) internal whenUnpaused returns (bool) {\r\n        //accrueInterest();\r\n        controller.transferCheck(address(this), src, dst, mulScalarTruncate(tokens, borrowSafeRatio));\r\n\r\n        require(src != dst, \"Cannot transfer to self\");\r\n\r\n        uint256 startingAllowance = 0;\r\n        if (spender == src) {\r\n            startingAllowance = uint256(-1);\r\n        } else {\r\n            startingAllowance = transferAllowances[src][spender];\r\n        }\r\n\r\n        uint256 allowanceNew = startingAllowance.sub(tokens);\r\n\r\n        accountTokens[src] = accountTokens[src].sub(tokens);\r\n        accountTokens[dst] = accountTokens[dst].add(tokens);\r\n\r\n        if (startingAllowance != uint256(-1)) {\r\n            transferAllowances[src][spender] = allowanceNew;\r\n        }\r\n\r\n        emit Transfer(src, dst, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `src`\r\n     * @dev This will overwrite the approval amount for `spender`\r\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\r\n     * @param spender The address of the account which may transfer tokens\r\n     * @param amount The number of tokens that are approved (-1 means infinite)\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        address src = msg.sender;\r\n        transferAllowances[src][spender] = amount;\r\n        emit Approval(src, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current allowance from `owner` for `spender`\r\n     * @param owner The address of the account which owns the tokens to be spent\r\n     * @param spender The address of the account which may transfer tokens\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return transferAllowances[owner][spender];\r\n    }\r\n\r\n    struct MintLocals {\r\n        uint256 exchangeRate;\r\n        uint256 mintTokens;\r\n        uint256 totalSupplyNew;\r\n        uint256 accountTokensNew;\r\n        uint256 actualMintAmount;\r\n    }\r\n\r\n    struct DepositLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 amount_deposited;\r\n        uint256 underlying_deposited;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 account_balance;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    // 存款记账\r\n    function mint(address user, uint256 amount)\r\n        external\r\n        onlyBank\r\n        nonReentrant\r\n        returns (bytes memory)\r\n    {\r\n        accrueInterest();\r\n        return mintInternal(user, amount);\r\n    }\r\n\r\n    // 存款记账\r\n    function mintInternal(address user, uint256 amount)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n        MintLocals memory tmp;\r\n        controller.mintCheck(underlying, user, amount);\r\n        tmp.exchangeRate = exchangeRateStored();\r\n        tmp.mintTokens = divScalarByExpTruncate(amount, tmp.exchangeRate);\r\n        tmp.totalSupplyNew = addExp(totalSupply, tmp.mintTokens);\r\n        tmp.accountTokensNew = addExp(accountTokens[user], tmp.mintTokens);\r\n        totalSupply = tmp.totalSupplyNew;\r\n        accountTokens[user] = tmp.accountTokensNew;\r\n\r\n        uint256 preCalcTokenCash = tokenCash(underlying, address(controller))\r\n            .add(amount);\r\n\r\n        DepositLogStruct memory dls = DepositLogStruct(\r\n            user,\r\n            underlying,\r\n            address(this),\r\n            tmp.mintTokens,\r\n            amount,\r\n            exchangeRateAfter(amount), //cheque_token_value, 存之后的交换率（预判）\r\n            interestRateModel.getBorrowRate(\r\n                preCalcTokenCash,\r\n                totalBorrows,\r\n                totalReserves\r\n            ), //loan_interest_rate 借款利率,存之后的价款利率\r\n            tokenCash(address(this), user),\r\n            preCalcTokenCash\r\n        );\r\n\r\n        emit Transfer(address(0), user, tmp.mintTokens);\r\n\r\n        return abi.encode(dls);\r\n    }\r\n\r\n    struct BorrowLocals {\r\n        uint256 accountBorrows;\r\n        uint256 accountBorrowsNew;\r\n        uint256 totalBorrowsNew;\r\n    }\r\n\r\n    struct BorrowLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 amount_borrowed;\r\n        uint256 interest_accrued;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 account_debt;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    // 用户借钱\r\n    function borrow(address payable borrower, uint256 borrowAmount)\r\n        external\r\n        onlyBank\r\n        nonReentrant\r\n        returns (bytes memory)\r\n    {\r\n        accrueInterest();\r\n        return borrowInternal(borrower, borrowAmount);\r\n    }\r\n\r\n    // 用户借钱\r\n    function borrowInternal(address payable borrower, uint256 borrowAmount)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        controller.borrowCheck(\r\n            borrower,\r\n            underlying,\r\n            address(this),\r\n            mulScalarTruncate(borrowAmount, borrowSafeRatio)\r\n        );\r\n\r\n        require(\r\n            controller.getCashPrior(underlying) >= borrowAmount,\r\n            \"Insufficient balance\"\r\n        );\r\n\r\n        BorrowLocals memory tmp;\r\n        uint256 lastPrincipal = accountBorrows[borrower].principal;\r\n        tmp.accountBorrows = borrowBalanceStoredInternal(borrower);\r\n        tmp.accountBorrowsNew = addExp(tmp.accountBorrows, borrowAmount);\r\n        tmp.totalBorrowsNew = addExp(totalBorrows, borrowAmount);\r\n\r\n        accountBorrows[borrower].principal = tmp.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = tmp.totalBorrowsNew;\r\n\r\n        controller.transferToUser(underlying, borrower, borrowAmount);\r\n        subTotalCash(borrowAmount);\r\n\r\n        BorrowLogStruct memory bls = BorrowLogStruct(\r\n            borrower,\r\n            underlying,\r\n            address(this),\r\n            borrowAmount,\r\n            SafeMath.abs(tmp.accountBorrows, lastPrincipal),\r\n            exchangeRateStored(),\r\n            getBorrowRate(),\r\n            accountBorrows[borrower].principal,\r\n            tokenCash(underlying, address(controller))\r\n        );\r\n\r\n        return abi.encode(bls);\r\n    }\r\n\r\n    struct RepayLocals {\r\n        uint256 repayAmount;\r\n        uint256 borrowerIndex;\r\n        uint256 accountBorrows;\r\n        uint256 accountBorrowsNew;\r\n        uint256 totalBorrowsNew;\r\n        uint256 actualRepayAmount;\r\n    }\r\n\r\n    // 计算兑换率\r\n    function exchangeRateStored() public view returns (uint256 exchangeRate) {\r\n        return calcExchangeRate(totalBorrows, totalReserves);\r\n    }\r\n\r\n    function calcExchangeRate(uint256 _totalBorrows, uint256 _totalReserves)\r\n        public\r\n        view\r\n        returns (uint256 exchangeRate)\r\n    {\r\n        uint256 _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) {\r\n            return initialExchangeRate;\r\n        } else {\r\n            /*\r\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n             */\r\n            uint256 totalCash = controller.getCashPrior(underlying);\r\n            uint256 cashPlusBorrowsMinusReserves = subExp(\r\n                addExp(totalCash, _totalBorrows),\r\n                _totalReserves\r\n            );\r\n            exchangeRate = getDiv(cashPlusBorrowsMinusReserves, _totalSupply);\r\n        }\r\n    }\r\n\r\n    // 计算兑换率(预判)，在实际转账之前调用，只是用于发事件，用户后端审计\r\n    function exchangeRateAfter(uint256 transferInAmout)\r\n        public\r\n        view\r\n        returns (uint256 exchangeRate)\r\n    {\r\n        uint256 _totalSupply = totalSupply;\r\n        if (_totalSupply == 0) {\r\n            // 如果市场是初始化状态，那么返回初始兑换率\r\n            return initialExchangeRate;\r\n        } else {\r\n            /*\r\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\r\n             */\r\n            uint256 totalCash = controller.getCashAfter(\r\n                underlying,\r\n                transferInAmout\r\n            );\r\n            uint256 cashPlusBorrowsMinusReserves = subExp(\r\n                addExp(totalCash, totalBorrows),\r\n                totalReserves\r\n            );\r\n            exchangeRate = getDiv(cashPlusBorrowsMinusReserves, _totalSupply);\r\n        }\r\n    }\r\n\r\n    function balanceOfUnderlying(address owner) external returns (uint256) {\r\n        // 获取利率\r\n        uint256 exchangeRate = exchangeRateCurrent();\r\n        // 利率乘余额\r\n        uint256 balance = mulScalarTruncate(exchangeRate, accountTokens[owner]);\r\n        return balance;\r\n    }\r\n\r\n    function calcBalanceOfUnderlying(address owner)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (, , uint256 _totalBorrows, uint256 _trotalReserves) = peekInterest();\r\n\r\n        uint256 _exchangeRate = calcExchangeRate(\r\n            _totalBorrows,\r\n            _trotalReserves\r\n        );\r\n        // 利率乘余额\r\n        uint256 balance = mulScalarTruncate(\r\n            _exchangeRate,\r\n            accountTokens[owner]\r\n        );\r\n        return balance;\r\n    }\r\n\r\n    function exchangeRateCurrent() public nonReentrant returns (uint256) {\r\n        accrueInterest();\r\n        return exchangeRateStored();\r\n    }\r\n\r\n    // 获取账户信息\r\n    function getAccountState(address account)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 fTokenBalance = accountTokens[account];\r\n        uint256 borrowBalance = borrowBalanceStoredInternal(account);\r\n        uint256 exchangeRate = exchangeRateStored();\r\n\r\n        return (fTokenBalance, borrowBalance, exchangeRate);\r\n    }\r\n\r\n    struct WithdrawLocals {\r\n        uint256 exchangeRate;\r\n        uint256 withdrawTokens;\r\n        uint256 withdrawAmount;\r\n        uint256 totalSupplyNew;\r\n        uint256 accountTokensNew;\r\n    }\r\n\r\n    struct WithdrawLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 amount_withdrawed;\r\n        uint256 underlying_withdrawed;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 account_balance;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    // todo onlyController\r\n    function withdraw(\r\n        address payable withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) external onlyBank nonReentrant returns (uint256, bytes memory) {\r\n        accrueInterest();\r\n        return withdrawInternal(withdrawer, withdrawTokensIn, withdrawAmountIn);\r\n    }\r\n\r\n    function withdrawInternal(\r\n        address payable withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) internal returns (uint256, bytes memory) {\r\n        // 一个是想要兑换 cTokens 的数量，一个是想要兑换 asset 的数量，必须有一个是 0\r\n        require(\r\n            withdrawTokensIn == 0 || withdrawAmountIn == 0,\r\n            \"withdraw parameter not valid\"\r\n        );\r\n        WithdrawLocals memory tmp;\r\n\r\n        tmp.exchangeRate = exchangeRateStored();\r\n\r\n        if (withdrawTokensIn > 0) {\r\n            tmp.withdrawTokens = withdrawTokensIn;\r\n            tmp.withdrawAmount = mulScalarTruncate(\r\n                tmp.exchangeRate,\r\n                withdrawTokensIn\r\n            );\r\n        } else {\r\n            tmp.withdrawTokens = divScalarByExpTruncate(\r\n                withdrawAmountIn,\r\n                tmp.exchangeRate\r\n            );\r\n            tmp.withdrawAmount = withdrawAmountIn;\r\n        }\r\n\r\n        controller.withdrawCheck(address(this), withdrawer, tmp.withdrawTokens);\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n\r\n        tmp.totalSupplyNew = totalSupply.sub(tmp.withdrawTokens);\r\n        tmp.accountTokensNew = accountTokens[withdrawer].sub(\r\n            tmp.withdrawTokens\r\n        );\r\n\r\n        require(\r\n            controller.getCashPrior(underlying) >= tmp.withdrawAmount,\r\n            \"Insufficient money\"\r\n        );\r\n\r\n        controller.transferToUser(underlying, withdrawer, tmp.withdrawAmount);\r\n        subTotalCash(tmp.withdrawAmount);\r\n\r\n        totalSupply = tmp.totalSupplyNew;\r\n        accountTokens[withdrawer] = tmp.accountTokensNew;\r\n\r\n        WithdrawLogStruct memory wls = WithdrawLogStruct(\r\n            withdrawer,\r\n            underlying,\r\n            address(this),\r\n            tmp.withdrawTokens,\r\n            tmp.withdrawAmount,\r\n            exchangeRateStored(),\r\n            getBorrowRate(),\r\n            tokenCash(address(this), withdrawer),\r\n            tokenCash(underlying, address(controller))\r\n        );\r\n\r\n        emit Transfer(withdrawer, address(0), tmp.withdrawTokens);\r\n\r\n        return (tmp.withdrawAmount, abi.encode(wls));\r\n    }\r\n\r\n    function strikeWithdrawInternal(\r\n        address withdrawer,\r\n        uint256 withdrawTokensIn,\r\n        uint256 withdrawAmountIn\r\n    ) internal returns (uint256, bytes memory) {\r\n        // 一个是想要兑换 cTokens 的数量，一个是想要兑换 asset 的数量，必须有一个是 0\r\n        require(\r\n            withdrawTokensIn == 0 || withdrawAmountIn == 0,\r\n            \"withdraw parameter not valid\"\r\n        );\r\n        WithdrawLocals memory tmp;\r\n\r\n        tmp.exchangeRate = exchangeRateStored();\r\n\r\n        if (withdrawTokensIn > 0) {\r\n            tmp.withdrawTokens = withdrawTokensIn;\r\n            tmp.withdrawAmount = mulScalarTruncate(\r\n                tmp.exchangeRate,\r\n                withdrawTokensIn\r\n            );\r\n        } else {\r\n            tmp.withdrawTokens = divScalarByExpTruncate(\r\n                withdrawAmountIn,\r\n                tmp.exchangeRate\r\n            );\r\n            tmp.withdrawAmount = withdrawAmountIn;\r\n        }\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n\r\n        tmp.totalSupplyNew = totalSupply.sub(tmp.withdrawTokens);\r\n        tmp.accountTokensNew = accountTokens[withdrawer].sub(\r\n            tmp.withdrawTokens\r\n        );\r\n\r\n        totalSupply = tmp.totalSupplyNew;\r\n        accountTokens[withdrawer] = tmp.accountTokensNew;\r\n\r\n        uint256 preCalcTokenCash = tokenCash(underlying, address(controller))\r\n            .add(tmp.withdrawAmount);\r\n\r\n        WithdrawLogStruct memory wls = WithdrawLogStruct(\r\n            withdrawer,\r\n            underlying,\r\n            address(this),\r\n            tmp.withdrawTokens,\r\n            tmp.withdrawAmount,\r\n            exchangeRateStored(),\r\n            interestRateModel.getBorrowRate(\r\n                preCalcTokenCash,\r\n                totalBorrows,\r\n                totalReserves\r\n            ),\r\n            tokenCash(address(this), withdrawer),\r\n            preCalcTokenCash\r\n        );\r\n\r\n        emit Transfer(withdrawer, address(0), tmp.withdrawTokens);\r\n\r\n        return (tmp.withdrawAmount, abi.encode(wls));\r\n    }\r\n\r\n    // 更新利息\r\n    function accrueInterest() public onlyRestricted {\r\n        uint256 currentBlockNumber = getBlockNumber();\r\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\r\n\r\n        // 太短 零利息\r\n        if (accrualBlockNumberPrior == currentBlockNumber) {\r\n            return;\r\n        }\r\n\r\n        uint256 cashPrior = controller.getCashPrior(underlying);\r\n        uint256 borrowsPrior = totalBorrows;\r\n        uint256 reservesPrior = totalReserves;\r\n        uint256 borrowIndexPrior = borrowIndex;\r\n\r\n        // // 计算借贷利率\r\n        uint256 borrowRate = interestRateModel.getBorrowRate(\r\n            cashPrior,\r\n            borrowsPrior,\r\n            reservesPrior\r\n        );\r\n        // // 不能超过最大利率\r\n        require(borrowRate <= borrowRateMax, \"borrow rate is too high\");\r\n\r\n        // // 计算块差\r\n        uint256 blockDelta = currentBlockNumber.sub(accrualBlockNumberPrior);\r\n\r\n        /*\r\n         *  simpleInterestFactor = borrowRate * blockDelta\r\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\r\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\r\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n         */\r\n\r\n        uint256 simpleInterestFactor;\r\n        uint256 interestAccumulated;\r\n        uint256 totalBorrowsNew;\r\n        uint256 totalReservesNew;\r\n        uint256 borrowIndexNew;\r\n\r\n        simpleInterestFactor = mulScalar(borrowRate, blockDelta);\r\n\r\n        interestAccumulated = divExp(\r\n            mulExp(simpleInterestFactor, borrowsPrior),\r\n            expScale\r\n        );\r\n\r\n        totalBorrowsNew = addExp(interestAccumulated, borrowsPrior);\r\n\r\n        totalReservesNew = addExp(\r\n            divExp(mulExp(reserveFactor, interestAccumulated), expScale),\r\n            reservesPrior\r\n        );\r\n\r\n        borrowIndexNew = addExp(\r\n            divExp(mulExp(simpleInterestFactor, borrowIndexPrior), expScale),\r\n            borrowIndexPrior\r\n        );\r\n\r\n        accrualBlockNumber = currentBlockNumber;\r\n        borrowIndex = borrowIndexNew;\r\n        totalBorrows = totalBorrowsNew;\r\n        totalReserves = totalReservesNew;\r\n\r\n        borrowRate = interestRateModel.getBorrowRate(\r\n            cashPrior,\r\n            totalBorrows,\r\n            totalReserves\r\n        );\r\n        // 不能超过最大利率\r\n        require(borrowRate <= borrowRateMax, \"borrow rate is too high\");\r\n    }\r\n\r\n    function peekInterest()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _accrualBlockNumber,\r\n            uint256 _borrowIndex,\r\n            uint256 _totalBorrows,\r\n            uint256 _totalReserves\r\n        )\r\n    {\r\n        _accrualBlockNumber = getBlockNumber();\r\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\r\n\r\n        // 太短 零利息\r\n        if (accrualBlockNumberPrior == _accrualBlockNumber) {\r\n            return (\r\n                accrualBlockNumber,\r\n                borrowIndex,\r\n                totalBorrows,\r\n                totalReserves\r\n            );\r\n        }\r\n\r\n        uint256 cashPrior = controller.getCashPrior(underlying);\r\n        uint256 borrowsPrior = totalBorrows;\r\n        uint256 reservesPrior = totalReserves;\r\n        uint256 borrowIndexPrior = borrowIndex;\r\n\r\n        // // 计算借贷利率\r\n        uint256 borrowRate = interestRateModel.getBorrowRate(\r\n            cashPrior,\r\n            borrowsPrior,\r\n            reservesPrior\r\n        );\r\n        // // 不能超过最大利率\r\n        require(borrowRate <= borrowRateMax, \"borrow rate is too high\");\r\n\r\n        // // 计算块差\r\n        uint256 blockDelta = _accrualBlockNumber.sub(accrualBlockNumberPrior);\r\n\r\n        /*\r\n         *  simpleInterestFactor = borrowRate * blockDelta\r\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\r\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\r\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\r\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\r\n         */\r\n\r\n        uint256 simpleInterestFactor;\r\n        uint256 interestAccumulated;\r\n        uint256 totalBorrowsNew;\r\n        uint256 totalReservesNew;\r\n        uint256 borrowIndexNew;\r\n\r\n        simpleInterestFactor = mulScalar(borrowRate, blockDelta);\r\n\r\n        interestAccumulated = divExp(\r\n            mulExp(simpleInterestFactor, borrowsPrior),\r\n            expScale\r\n        );\r\n\r\n        totalBorrowsNew = addExp(interestAccumulated, borrowsPrior);\r\n\r\n        totalReservesNew = addExp(\r\n            divExp(mulExp(reserveFactor, interestAccumulated), expScale),\r\n            reservesPrior\r\n        );\r\n\r\n        borrowIndexNew = addExp(\r\n            divExp(mulExp(simpleInterestFactor, borrowIndexPrior), expScale),\r\n            borrowIndexPrior\r\n        );\r\n\r\n        _borrowIndex = borrowIndexNew;\r\n        _totalBorrows = totalBorrowsNew;\r\n        _totalReserves = totalReservesNew;\r\n\r\n        borrowRate = interestRateModel.getBorrowRate(\r\n            cashPrior,\r\n            totalBorrows,\r\n            totalReserves\r\n        );\r\n        // 不能超过最大利率\r\n        require(borrowRate <= borrowRateMax, \"borrow rate is too high\");\r\n    }\r\n\r\n    function borrowBalanceCurrent(address account)\r\n        external\r\n        nonReentrant\r\n        returns (uint256)\r\n    {\r\n        accrueInterest();\r\n        BorrowSnapshot memory borrowSnapshot = accountBorrows[account];\r\n        require(borrowSnapshot.interestIndex <= borrowIndex, \"borrowIndex error\");\r\n\r\n        return borrowBalanceStoredInternal(account);\r\n    }\r\n\r\n    function borrowBalanceStoredInternal(address user)\r\n        internal\r\n        view\r\n        returns (uint256 result)\r\n    {\r\n        // 借贷数量\r\n        BorrowSnapshot memory borrowSnapshot = accountBorrows[user];\r\n\r\n        if (borrowSnapshot.principal == 0) {\r\n            return 0;\r\n        }\r\n\r\n        result = mulExp(borrowSnapshot.principal, divExp(borrowIndex, borrowSnapshot.interestIndex));\r\n    }\r\n\r\n    function _setReserveFactorFresh(uint256 newReserveFactor)\r\n        external\r\n        onlyAdmin\r\n        nonReentrant\r\n    {\r\n        accrueInterest();\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n        reserveFactor = newReserveFactor;\r\n    }\r\n\r\n    struct ReserveDepositLogStruct {\r\n        address token_address;\r\n        uint256 reserve_funded;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function _setInterestRateModel(IInterestRateModel newInterestRateModel)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        address oldIRM = address(interestRateModel);\r\n        uint256 oldUR = utilizationRate();\r\n        uint256 oldAPR = APR();\r\n        uint256 oldAPY = APY();\r\n\r\n        uint256 exRate1 = exchangeRateStored();     \r\n        accrueInterest();\r\n        uint256 exRate2 = exchangeRateStored();\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n\r\n        interestRateModel = newInterestRateModel;\r\n        uint256 newUR = utilizationRate();\r\n        uint256 newAPR = APR();\r\n        uint256 newAPY = APY();\r\n\r\n        emit NewInterestRateModel(oldIRM, oldUR, oldAPR, oldAPY, exRate1, address(newInterestRateModel), newUR, newAPR, newAPY, exRate2);\r\n\r\n        ReserveDepositLogStruct memory rds = ReserveDepositLogStruct(\r\n            underlying,\r\n            0,\r\n            exchangeRateStored(),\r\n            getBorrowRate(),\r\n            tokenCash(underlying, address(controller))\r\n        );\r\n\r\n        IBank(bank).MonitorEventCallback(\r\n            \"ReserveDeposit\",\r\n            abi.encode(rds)\r\n        );\r\n    }\r\n\r\n    function _setInitialExchangeRate(uint256 _initialExchangeRate) external onlyAdmin {\r\n        uint256 oldInitialExchangeRate = initialExchangeRate;\r\n\r\n        uint256 oldUR = utilizationRate();\r\n        uint256 oldAPR = APR();\r\n        uint256 oldAPY = APY();\r\n\r\n        uint256 exRate1 = exchangeRateStored();\r\n        accrueInterest();\r\n        uint256 exRate2 = exchangeRateStored();\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n\r\n        initialExchangeRate = _initialExchangeRate;\r\n        uint256 newUR = utilizationRate();\r\n        uint256 newAPR = APR();\r\n        uint256 newAPY = APY();\r\n\r\n        emit NewInitialExchangeRate(oldInitialExchangeRate, oldUR, oldAPR, oldAPY, exRate1, initialExchangeRate, newUR, newAPR, newAPY, exRate2);\r\n\r\n        ReserveDepositLogStruct memory rds = ReserveDepositLogStruct(\r\n            underlying,\r\n            0,\r\n            exchangeRateStored(),\r\n            getBorrowRate(),\r\n            tokenCash(underlying, address(controller))\r\n        );\r\n\r\n        IBank(bank).MonitorEventCallback(\r\n            \"ReserveDeposit\",\r\n            abi.encode(rds)\r\n        );\r\n    }\r\n\r\n    function getBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    function repay(address borrower, uint256 repayAmount)\r\n        external\r\n        onlyBank\r\n        nonReentrant\r\n        returns (uint256, bytes memory)\r\n    {\r\n        accrueInterest();\r\n        return repayInternal(borrower, repayAmount);\r\n    }\r\n\r\n    struct RepayLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 amount_repayed;\r\n        uint256 interest_accrued;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 account_debt;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function repayInternal(address borrower, uint256 repayAmount)\r\n        internal\r\n        returns (uint256, bytes memory)\r\n    {\r\n        controller.repayCheck(underlying);\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n\r\n        RepayLocals memory tmp;\r\n        uint256 lastPrincipal = accountBorrows[borrower].principal;\r\n        tmp.borrowerIndex = accountBorrows[borrower].interestIndex;\r\n        tmp.accountBorrows = borrowBalanceStoredInternal(borrower);\r\n\r\n        // -1 表示还最大\r\n        if (repayAmount == uint256(-1)) {\r\n            tmp.repayAmount = tmp.accountBorrows;\r\n        } else {\r\n            tmp.repayAmount = repayAmount;\r\n        }\r\n\r\n        tmp.accountBorrowsNew = tmp.accountBorrows.sub(tmp.repayAmount);\r\n        if (totalBorrows < tmp.repayAmount) {\r\n            tmp.totalBorrowsNew = 0;\r\n        } else {\r\n            tmp.totalBorrowsNew = totalBorrows.sub(tmp.repayAmount);\r\n        }\r\n\r\n        accountBorrows[borrower].principal = tmp.accountBorrowsNew;\r\n        accountBorrows[borrower].interestIndex = borrowIndex;\r\n        totalBorrows = tmp.totalBorrowsNew;\r\n\r\n        uint256 preCalcTokenCash = tokenCash(underlying, address(controller))\r\n            .add(tmp.repayAmount);\r\n\r\n        RepayLogStruct memory rls = RepayLogStruct(\r\n            borrower,\r\n            underlying,\r\n            address(this),\r\n            tmp.repayAmount,\r\n            SafeMath.abs(tmp.accountBorrows, lastPrincipal),\r\n            exchangeRateAfter(tmp.repayAmount), //repay之后的交换率\r\n            interestRateModel.getBorrowRate(\r\n                preCalcTokenCash,\r\n                totalBorrows,\r\n                totalReserves\r\n            ), //repay之后的借款利率\r\n            accountBorrows[borrower].principal,\r\n            preCalcTokenCash\r\n        );\r\n\r\n        return (tmp.repayAmount, abi.encode(rls));\r\n    }\r\n\r\n    function borrowBalanceStored(address account)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return borrowBalanceStoredInternal(account);\r\n    }\r\n\r\n    struct LiquidateBorrowLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 debt_written_off;\r\n        uint256 interest_accrued;\r\n        address debtor_address;\r\n        uint256 collateral_purchased;\r\n        address collateral_cheque_token_address;\r\n        uint256 debtor_balance;\r\n        uint256 debt_remaining;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 account_balance;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    function liquidateBorrow(\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 repayAmount,\r\n        FToken fTokenCollateral\r\n    ) public onlyBank nonReentrant returns (bytes memory) {\r\n        require(\r\n            controller.isFTokenValid(address(this)) &&\r\n                controller.isFTokenValid(address(fTokenCollateral)),\r\n            \"Market not listed\"\r\n        );\r\n        accrueInterest();\r\n        fTokenCollateral.accrueInterest();\r\n        uint256 lastPrincipal = accountBorrows[borrower].principal;\r\n        uint256 newPrincipal = borrowBalanceStoredInternal(borrower);\r\n\r\n        controller.liquidateBorrowCheck(\r\n            address(this),\r\n            address(fTokenCollateral),\r\n            borrower,\r\n            liquidator,\r\n            repayAmount\r\n        );\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n        require(\r\n            fTokenCollateral.accrualBlockNumber() == getBlockNumber(),\r\n            \"Blocknumber fails\"\r\n        );\r\n\r\n        // 还钱\r\n        (uint256 actualRepayAmount, ) = repayInternal(borrower, repayAmount);\r\n\r\n        // 计算清算的质押物数量（fToken数量）\r\n        uint256 seizeTokens = controller.liquidateTokens(\r\n            address(this),\r\n            address(fTokenCollateral),\r\n            actualRepayAmount\r\n        );\r\n\r\n        // 借款人得要有这么多余额才行\r\n        require(\r\n            fTokenCollateral.balanceOf(borrower) >= seizeTokens,\r\n            \"Seize too much\"\r\n        );\r\n\r\n        if (address(fTokenCollateral) == address(this)) {\r\n            seizeInternal(address(this), liquidator, borrower, seizeTokens);\r\n        } else {\r\n            fTokenCollateral.seize(liquidator, borrower, seizeTokens);\r\n        }\r\n\r\n        uint256 preCalcTokenCash = tokenCash(underlying, address(controller))\r\n            .add(actualRepayAmount);\r\n\r\n        LiquidateBorrowLogStruct memory lbls = LiquidateBorrowLogStruct(\r\n            liquidator,\r\n            underlying,\r\n            address(this),\r\n            actualRepayAmount,\r\n            SafeMath.abs(newPrincipal, lastPrincipal),\r\n            borrower,\r\n            seizeTokens,\r\n            address(fTokenCollateral),\r\n            tokenCash(address(fTokenCollateral), borrower),\r\n            accountBorrows[borrower].principal, //debt_remaining\r\n            exchangeRateAfter(actualRepayAmount),\r\n            interestRateModel.getBorrowRate(\r\n                preCalcTokenCash,\r\n                totalBorrows,\r\n                totalReserves\r\n            ),\r\n            tokenCash(address(fTokenCollateral), liquidator),\r\n            preCalcTokenCash\r\n        );\r\n\r\n        return abi.encode(lbls);\r\n    }\r\n\r\n    function seize(\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 seizeTokens\r\n    ) external nonReentrant {\r\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\r\n    }\r\n\r\n    struct CallingOutLogStruct {\r\n        address user_address;\r\n        address token_address;\r\n        address cheque_token_address;\r\n        uint256 amount_wiped_out;\r\n        uint256 debt_cancelled_out;\r\n        uint256 interest_accrued;\r\n        uint256 cheque_token_value;\r\n        uint256 loan_interest_rate;\r\n        uint256 account_balance;\r\n        uint256 account_debt;\r\n        uint256 global_token_reserved;\r\n    }\r\n\r\n    //冲账处理\r\n    function cancellingOut(address striker)\r\n        public\r\n        onlyBank\r\n        nonReentrant\r\n        returns (bool strikeOk, bytes memory strikeLog)\r\n    {\r\n        // 需要冲账时，计算利息\r\n        if (\r\n            borrowBalanceStoredInternal(striker) > 0 && balanceOf(striker) > 0\r\n        ) {\r\n            accrueInterest();\r\n            uint256 lastPrincipal = accountBorrows[striker].principal;\r\n            uint256 curBorrowBalance = borrowBalanceStoredInternal(striker);\r\n            uint256 userSupplyBalance = calcBalanceOfUnderlying(striker);\r\n            uint256 lastFtokenBalance = balanceOf(striker);\r\n            uint256 actualRepayAmount;\r\n            bytes memory repayLog;\r\n            uint256 withdrawAmount;\r\n            bytes memory withdrawLog;\r\n            // 有借款和存款(fToken)\r\n            if (curBorrowBalance > 0 && userSupplyBalance > 0) {\r\n                //无实际转账的赎回（冲账赎回）\r\n                if (userSupplyBalance > curBorrowBalance) {\r\n                    (withdrawAmount, withdrawLog) = strikeWithdrawInternal(\r\n                        striker,\r\n                        0,\r\n                        curBorrowBalance\r\n                    );\r\n                } else {\r\n                    (withdrawAmount, withdrawLog) = strikeWithdrawInternal(\r\n                        striker,\r\n                        balanceOf(striker),\r\n                        0\r\n                    );\r\n                }\r\n\r\n                (actualRepayAmount, repayLog) = repayInternal(\r\n                    striker,\r\n                    withdrawAmount\r\n                );\r\n\r\n                CallingOutLogStruct memory cols;\r\n\r\n                cols.user_address = striker;\r\n                cols.token_address = underlying;\r\n                cols.cheque_token_address = address(this);\r\n                cols.amount_wiped_out = SafeMath.abs(\r\n                    lastFtokenBalance,\r\n                    balanceOf(striker)\r\n                );\r\n                cols.debt_cancelled_out = actualRepayAmount;\r\n                cols.interest_accrued = SafeMath.abs(\r\n                    curBorrowBalance,\r\n                    lastPrincipal\r\n                );\r\n                cols.cheque_token_value = exchangeRateStored();\r\n                cols.loan_interest_rate = interestRateModel.getBorrowRate(\r\n                    tokenCash(underlying, address(controller)),\r\n                    totalBorrows,\r\n                    totalReserves\r\n                );\r\n                cols.account_balance = tokenCash(address(this), striker);\r\n                cols.account_debt = accountBorrows[striker].principal;\r\n                cols.global_token_reserved = tokenCash(\r\n                    underlying,\r\n                    address(controller)\r\n                );\r\n\r\n                strikeLog = abi.encode(cols);\r\n\r\n                strikeOk = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return accountTokens[owner];\r\n    }\r\n\r\n    function _setBorrowSafeRatio(uint256 _borrowSafeRatio) public onlyAdmin {\r\n        borrowSafeRatio = _borrowSafeRatio;\r\n    }\r\n\r\n    function seizeInternal(\r\n        address seizerToken,\r\n        address liquidator,\r\n        address borrower,\r\n        uint256 seizeTokens\r\n    ) internal {\r\n        require(borrower != liquidator, \"Liquidator cannot be borrower\");\r\n        controller.seizeCheck(address(this), seizerToken);\r\n\r\n        accountTokens[borrower] = accountTokens[borrower].sub(seizeTokens);\r\n        accountTokens[liquidator] = accountTokens[liquidator].add(seizeTokens);\r\n\r\n        emit Transfer(borrower, liquidator, seizeTokens);\r\n    }\r\n\r\n    // onlyController\r\n    function _reduceReserves(uint256 reduceAmount) external onlyController {\r\n        accrueInterest();\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n        require(\r\n            controller.getCashPrior(underlying) >= reduceAmount,\r\n            \"Insufficient cash\"\r\n        );\r\n        require(totalReserves >= reduceAmount, \"Insufficient reserves\");\r\n\r\n        totalReserves = SafeMath.sub(\r\n            totalReserves,\r\n            reduceAmount,\r\n            \"reduce reserves underflow\"\r\n        );\r\n    }\r\n\r\n    function _addReservesFresh(uint256 addAmount) external onlyController {\r\n        accrueInterest();\r\n\r\n        require(accrualBlockNumber == getBlockNumber(), \"Blocknumber fails\");\r\n        totalReserves = SafeMath.add(totalReserves, addAmount);\r\n    }\r\n\r\n    function addTotalCash(uint256 _addAmount) public onlyBankComponent {\r\n        totalCash = totalCash.add(_addAmount);\r\n    }\r\n\r\n    function subTotalCash(uint256 _subAmount) public onlyBankComponent {\r\n        totalCash = totalCash.sub(_subAmount);\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"re-entered\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true;\r\n    }\r\n\r\n    // 借款年利率\r\n    function APR() public view returns (uint256) {\r\n        uint256 cash = tokenCash(underlying, address(controller));\r\n        return interestRateModel.APR(cash, totalBorrows, totalReserves);\r\n    }\r\n\r\n    // 存款年利率\r\n    function APY() public view returns (uint256) {\r\n        uint256 cash = tokenCash(underlying, address(controller));\r\n        return\r\n            interestRateModel.APY(\r\n                cash,\r\n                totalBorrows,\r\n                totalReserves,\r\n                reserveFactor\r\n            );\r\n    }\r\n\r\n    function utilizationRate() public view returns (uint256) {\r\n        uint256 cash = tokenCash(underlying, address(controller));\r\n        return interestRateModel.utilizationRate(cash, totalBorrows, totalReserves);\r\n    }\r\n\r\n    // 借款年利率\r\n    function getBorrowRate() public view returns (uint256) {\r\n        uint256 cash = tokenCash(underlying, address(controller));\r\n        return\r\n            interestRateModel.getBorrowRate(cash, totalBorrows, totalReserves);\r\n    }\r\n\r\n    // 存款年利率\r\n    function getSupplyRate() public view returns (uint256) {\r\n        uint256 cash = tokenCash(underlying, address(controller));\r\n        return\r\n            interestRateModel.getSupplyRate(\r\n                cash,\r\n                totalBorrows,\r\n                totalReserves,\r\n                reserveFactor\r\n            );\r\n    }\r\n}"
    }
  }
}