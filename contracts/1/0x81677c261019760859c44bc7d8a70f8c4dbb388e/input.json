{"language":"Solidity","settings":{"evmVersion":"byzantium","libraries":{"CrossDelegate.sol":{"HTLCDebtLib":"0x88f54adf33962fae05f802d2568f4dbf2ff030e3","HTLCTxLib":"0x2532d74f8db5b369e58dafbd1a104890f8dfa000","RapidityLib":"0x2af614e23dd48a8a3f6b59245c1458712e55bc37"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CrossDelegate.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-11-17\r\n*/\r\n\r\n// File: contracts/components/Owned.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n///  later changed\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @dev `owner` is the only address that can call a function with this\r\n    /// modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    /// @notice The Constructor assigns the message sender to be `owner`\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    function transferOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    /// @notice `owner` can step down and assign some other address to this role\r\n    /// @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    ///  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        owner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/components/Halt.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Halt is Owned {\r\n\r\n    bool public halted = false;\r\n\r\n    modifier notHalted() {\r\n        require(!halted, \"Smart contract is halted\");\r\n        _;\r\n    }\r\n\r\n    modifier isHalted() {\r\n        require(halted, \"Smart contract is not halted\");\r\n        _;\r\n    }\r\n\r\n    /// @notice function Emergency situation that requires\r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt)\r\n        public\r\n        onlyOwner\r\n    {\r\n        halted = halt;\r\n    }\r\n}\r\n\r\n// File: contracts/components/ReentrancyGuard.sol\r\n\r\npragma solidity 0.4.26;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/BasicStorageLib.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary BasicStorageLib {\r\n\r\n    struct UintData {\r\n        mapping(bytes => mapping(bytes => uint))           _storage;\r\n    }\r\n\r\n    struct BoolData {\r\n        mapping(bytes => mapping(bytes => bool))           _storage;\r\n    }\r\n\r\n    struct AddressData {\r\n        mapping(bytes => mapping(bytes => address))        _storage;\r\n    }\r\n\r\n    struct BytesData {\r\n        mapping(bytes => mapping(bytes => bytes))          _storage;\r\n    }\r\n\r\n    struct StringData {\r\n        mapping(bytes => mapping(bytes => string))         _storage;\r\n    }\r\n\r\n    /* uintStorage */\r\n\r\n    function setStorage(UintData storage self, bytes memory key, bytes memory innerKey, uint value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(UintData storage self, bytes memory key, bytes memory innerKey) internal view returns (uint) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(UintData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* boolStorage */\r\n\r\n    function setStorage(BoolData storage self, bytes memory key, bytes memory innerKey, bool value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(BoolData storage self, bytes memory key, bytes memory innerKey) internal view returns (bool) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(BoolData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* addressStorage */\r\n\r\n    function setStorage(AddressData storage self, bytes memory key, bytes memory innerKey, address value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(AddressData storage self, bytes memory key, bytes memory innerKey) internal view returns (address) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(AddressData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* bytesStorage */\r\n\r\n    function setStorage(BytesData storage self, bytes memory key, bytes memory innerKey, bytes memory value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(BytesData storage self, bytes memory key, bytes memory innerKey) internal view returns (bytes memory) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(BytesData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n    /* stringStorage */\r\n\r\n    function setStorage(StringData storage self, bytes memory key, bytes memory innerKey, string memory value) internal {\r\n        self._storage[key][innerKey] = value;\r\n    }\r\n\r\n    function getStorage(StringData storage self, bytes memory key, bytes memory innerKey) internal view returns (string memory) {\r\n        return self._storage[key][innerKey];\r\n    }\r\n\r\n    function delStorage(StringData storage self, bytes memory key, bytes memory innerKey) internal {\r\n        delete self._storage[key][innerKey];\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/components/BasicStorage.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract BasicStorage {\r\n    /************************************************************\r\n     **\r\n     ** VARIABLES\r\n     **\r\n     ************************************************************/\r\n\r\n    //// basic variables\r\n    using BasicStorageLib for BasicStorageLib.UintData;\r\n    using BasicStorageLib for BasicStorageLib.BoolData;\r\n    using BasicStorageLib for BasicStorageLib.AddressData;\r\n    using BasicStorageLib for BasicStorageLib.BytesData;\r\n    using BasicStorageLib for BasicStorageLib.StringData;\r\n\r\n    BasicStorageLib.UintData    internal uintData;\r\n    BasicStorageLib.BoolData    internal boolData;\r\n    BasicStorageLib.AddressData internal addressData;\r\n    BasicStorageLib.BytesData   internal bytesData;\r\n    BasicStorageLib.StringData  internal stringData;\r\n}\r\n\r\n// File: contracts/interfaces/IRC20Protocol.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\ninterface IRC20Protocol {\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function balanceOf(address _owner) external view returns (uint);\r\n}\r\n\r\n// File: contracts/interfaces/IQuota.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\ninterface IQuota {\r\n  function userMintLock(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function userMintRevoke(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function userMintRedeem(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n\r\n  function smgMintLock(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function smgMintRevoke(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function smgMintRedeem(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n\r\n  function userBurnLock(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function userBurnRevoke(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function userBurnRedeem(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n\r\n  function smgBurnLock(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function smgBurnRevoke(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function smgBurnRedeem(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n\r\n  function userFastMint(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function userFastBurn(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n\r\n  function smgFastMint(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n  function smgFastBurn(uint tokenId, bytes32 storemanGroupId, uint value) external;\r\n\r\n  function assetLock(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\r\n  function assetRedeem(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\r\n  function assetRevoke(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\r\n\r\n  function debtLock(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\r\n  function debtRedeem(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\r\n  function debtRevoke(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\r\n\r\n  function getUserMintQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\r\n  function getSmgMintQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\r\n\r\n  function getUserBurnQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\r\n  function getSmgBurnQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\r\n\r\n  function getAsset(uint tokenId, bytes32 storemanGroupId) external view returns (uint asset, uint asset_receivable, uint asset_payable);\r\n  function getDebt(uint tokenId, bytes32 storemanGroupId) external view returns (uint debt, uint debt_receivable, uint debt_payable);\r\n\r\n  function isDebtClean(bytes32 storemanGroupId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IStoremanGroup.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.24;\r\n\r\ninterface IStoremanGroup {\r\n    function getSelectedSmNumber(bytes32 groupId) external view returns(uint number);\r\n    function getStoremanGroupConfig(bytes32 id) external view returns(bytes32 groupId, uint8 status, uint deposit, uint chain1, uint chain2, uint curve1, uint curve2,  bytes gpk1, bytes gpk2, uint startTime, uint endTime);\r\n    function getDeposit(bytes32 id) external view returns(uint);\r\n    function getStoremanGroupStatus(bytes32 id) external view returns(uint8 status, uint startTime, uint endTime);\r\n    function setGpk(bytes32 groupId, bytes gpk1, bytes gpk2) external;\r\n    function setInvalidSm(bytes32 groupId, uint[] indexs, uint8[] slashTypes) external returns(bool isContinue);\r\n    function getThresholdByGrpId(bytes32 groupId) external view returns (uint);\r\n    function getSelectedSmInfo(bytes32 groupId, uint index) external view returns(address wkAddr, bytes PK, bytes enodeId);\r\n    function recordSmSlash(address wk) public;\r\n}\r\n\r\n// File: contracts/interfaces/ITokenManager.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\ninterface ITokenManager {\r\n    function getTokenPairInfo(uint id) external view\r\n      returns (uint origChainID, bytes tokenOrigAccount, uint shadowChainID, bytes tokenShadowAccount);\r\n\r\n    function getTokenPairInfoSlim(uint id) external view \r\n      returns (uint origChainID, bytes tokenOrigAccount, uint shadowChainID);\r\n\r\n    function mintToken(uint id, address to,uint value) external;\r\n\r\n    function burnToken(uint id, uint value) external;\r\n}\r\n\r\n// File: contracts/interfaces/ISignatureVerifier.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\ninterface ISignatureVerifier {\r\n  function verify(\r\n        uint curveId,\r\n        bytes32 signature,\r\n        bytes32 groupKeyX,\r\n        bytes32 groupKeyY,\r\n        bytes32 randomPointX,\r\n        bytes32 randomPointY,\r\n        bytes32 message\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath mul overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath div 0\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath sub b > a\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath add overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath mod 0\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/crossApproach/lib/HTLCTxLib.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary HTLCTxLib {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     *\r\n     * ENUMS\r\n     *\r\n     */\r\n\r\n    /// @notice tx info status\r\n    /// @notice uninitialized,locked,redeemed,revoked\r\n    enum TxStatus {None, Locked, Redeemed, Revoked, AssetLocked, DebtLocked}\r\n\r\n    /**\r\n     *\r\n     * STRUCTURES\r\n     *\r\n     */\r\n\r\n    /// @notice struct of HTLC user mint lock parameters\r\n    struct HTLCUserParams {\r\n        bytes32 xHash;                  /// hash of HTLC random number\r\n        bytes32 smgID;                  /// ID of storeman group which user has selected\r\n        uint tokenPairID;               /// token pair id on cross chain\r\n        uint value;                     /// exchange token value\r\n        uint lockFee;                   /// exchange token value\r\n        uint lockedTime;                /// HTLC lock time\r\n    }\r\n\r\n    /// @notice HTLC(Hashed TimeLock Contract) tx info\r\n    struct BaseTx {\r\n        bytes32 smgID;                  /// HTLC transaction storeman ID\r\n        uint lockedTime;                /// HTLC transaction locked time\r\n        uint beginLockedTime;           /// HTLC transaction begin locked time\r\n        TxStatus status;                /// HTLC transaction status\r\n    }\r\n\r\n    /// @notice user  tx info\r\n    struct UserTx {\r\n        BaseTx baseTx;\r\n        uint tokenPairID;\r\n        uint value;\r\n        uint fee;\r\n        address userAccount;            /// HTLC transaction sender address for the security check while user's revoke\r\n    }\r\n    /// @notice storeman  tx info\r\n    struct SmgTx {\r\n        BaseTx baseTx;\r\n        uint tokenPairID;\r\n        uint value;\r\n        address  userAccount;          /// HTLC transaction user address for the security check while user's redeem\r\n    }\r\n    /// @notice storeman  debt tx info\r\n    struct DebtTx {\r\n        BaseTx baseTx;\r\n        bytes32 srcSmgID;              /// HTLC transaction sender(source storeman) ID\r\n    }\r\n\r\n    struct Data {\r\n        /// @notice mapping of hash(x) to UserTx -- xHash->htlcUserTxData\r\n        mapping(bytes32 => UserTx) mapHashXUserTxs;\r\n\r\n        /// @notice mapping of hash(x) to SmgTx -- xHash->htlcSmgTxData\r\n        mapping(bytes32 => SmgTx) mapHashXSmgTxs;\r\n\r\n        /// @notice mapping of hash(x) to DebtTx -- xHash->htlcDebtTxData\r\n        mapping(bytes32 => DebtTx) mapHashXDebtTxs;\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * MANIPULATIONS\r\n     *\r\n     */\r\n\r\n    /// @notice                     add user transaction info\r\n    /// @param params               parameters for user tx\r\n    function addUserTx(Data storage self, HTLCUserParams memory params)\r\n        public\r\n    {\r\n        UserTx memory userTx = self.mapHashXUserTxs[params.xHash];\r\n        // UserTx storage userTx = self.mapHashXUserTxs[params.xHash];\r\n        // require(params.value != 0, \"Value is invalid\");\r\n        require(userTx.baseTx.status == TxStatus.None, \"User tx exists\");\r\n\r\n        userTx.baseTx.smgID = params.smgID;\r\n        userTx.baseTx.lockedTime = params.lockedTime;\r\n        userTx.baseTx.beginLockedTime = now;\r\n        userTx.baseTx.status = TxStatus.Locked;\r\n        userTx.tokenPairID = params.tokenPairID;\r\n        userTx.value = params.value;\r\n        userTx.fee = params.lockFee;\r\n        userTx.userAccount = msg.sender;\r\n\r\n        self.mapHashXUserTxs[params.xHash] = userTx;\r\n    }\r\n\r\n    /// @notice                     refund coins from HTLC transaction, which is used for storeman redeem(outbound)\r\n    /// @param x                    HTLC random number\r\n    function redeemUserTx(Data storage self, bytes32 x)\r\n        external\r\n        returns(bytes32 xHash)\r\n    {\r\n        xHash = sha256(abi.encodePacked(x));\r\n\r\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\r\n        require(userTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\r\n        require(now < userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime), \"Redeem timeout\");\r\n\r\n        userTx.baseTx.status = TxStatus.Redeemed;\r\n\r\n        return xHash;\r\n    }\r\n\r\n    /// @notice                     revoke user transaction\r\n    /// @param  xHash               hash of HTLC random number\r\n    function revokeUserTx(Data storage self, bytes32 xHash)\r\n        external\r\n    {\r\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\r\n        require(userTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\r\n        require(now >= userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime), \"Revoke is not permitted\");\r\n\r\n        userTx.baseTx.status = TxStatus.Revoked;\r\n    }\r\n\r\n    /// @notice                    function for get user info\r\n    /// @param xHash               hash of HTLC random number\r\n    /// @return smgID              ID of storeman which user has selected\r\n    /// @return tokenPairID        token pair ID of cross chain\r\n    /// @return value              exchange value\r\n    /// @return fee                exchange fee\r\n    /// @return userAccount        HTLC transaction sender address for the security check while user's revoke\r\n    function getUserTx(Data storage self, bytes32 xHash)\r\n        external\r\n        view\r\n        returns (bytes32, uint, uint, uint, address)\r\n    {\r\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\r\n        return (userTx.baseTx.smgID, userTx.tokenPairID, userTx.value, userTx.fee, userTx.userAccount);\r\n    }\r\n\r\n    /// @notice                     add storeman transaction info\r\n    /// @param  xHash               hash of HTLC random number\r\n    /// @param  smgID               ID of the storeman which user has selected\r\n    /// @param  tokenPairID         token pair ID of cross chain\r\n    /// @param  value               HTLC transfer value of token\r\n    /// @param  userAccount            user account address on the destination chain, which is used to redeem token\r\n    function addSmgTx(Data storage self, bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, address userAccount, uint lockedTime)\r\n        external\r\n    {\r\n        SmgTx memory smgTx = self.mapHashXSmgTxs[xHash];\r\n        // SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\r\n        require(value != 0, \"Value is invalid\");\r\n        require(smgTx.baseTx.status == TxStatus.None, \"Smg tx exists\");\r\n\r\n        smgTx.baseTx.smgID = smgID;\r\n        smgTx.baseTx.status = TxStatus.Locked;\r\n        smgTx.baseTx.lockedTime = lockedTime;\r\n        smgTx.baseTx.beginLockedTime = now;\r\n        smgTx.tokenPairID = tokenPairID;\r\n        smgTx.value = value;\r\n        smgTx.userAccount = userAccount;\r\n\r\n        self.mapHashXSmgTxs[xHash] = smgTx;\r\n    }\r\n\r\n    /// @notice                     refund coins from HTLC transaction, which is used for users redeem(inbound)\r\n    /// @param x                    HTLC random number\r\n    function redeemSmgTx(Data storage self, bytes32 x)\r\n        external\r\n        returns(bytes32 xHash)\r\n    {\r\n        xHash = sha256(abi.encodePacked(x));\r\n\r\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\r\n        require(smgTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\r\n        require(now < smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime), \"Redeem timeout\");\r\n\r\n        smgTx.baseTx.status = TxStatus.Redeemed;\r\n\r\n        return xHash;\r\n    }\r\n\r\n    /// @notice                     revoke storeman transaction\r\n    /// @param  xHash               hash of HTLC random number\r\n    function revokeSmgTx(Data storage self, bytes32 xHash)\r\n        external\r\n    {\r\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\r\n        require(smgTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\r\n        require(now >= smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime), \"Revoke is not permitted\");\r\n\r\n        smgTx.baseTx.status = TxStatus.Revoked;\r\n    }\r\n\r\n    /// @notice                     function for get smg info\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @return smgID               ID of storeman which user has selected\r\n    /// @return tokenPairID         token pair ID of cross chain\r\n    /// @return value               exchange value\r\n    /// @return userAccount            user account address for redeem\r\n    function getSmgTx(Data storage self, bytes32 xHash)\r\n        external\r\n        view\r\n        returns (bytes32, uint, uint, address)\r\n    {\r\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\r\n        return (smgTx.baseTx.smgID, smgTx.tokenPairID, smgTx.value, smgTx.userAccount);\r\n    }\r\n\r\n    /// @notice                     add storeman transaction info\r\n    /// @param  xHash               hash of HTLC random number\r\n    /// @param  srcSmgID            ID of source storeman group\r\n    /// @param  destSmgID           ID of the storeman which will take over of the debt of source storeman group\r\n    /// @param  lockedTime          HTLC lock time\r\n    /// @param  status              Status, should be 'Locked' for asset or 'DebtLocked' for debt\r\n    function addDebtTx(Data storage self, bytes32 xHash, bytes32 srcSmgID, bytes32 destSmgID, uint lockedTime, TxStatus status)\r\n        external\r\n    {\r\n        DebtTx memory debtTx = self.mapHashXDebtTxs[xHash];\r\n        // DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\r\n        require(debtTx.baseTx.status == TxStatus.None, \"Debt tx exists\");\r\n\r\n        debtTx.baseTx.smgID = destSmgID;\r\n        debtTx.baseTx.status = status;//TxStatus.Locked;\r\n        debtTx.baseTx.lockedTime = lockedTime;\r\n        debtTx.baseTx.beginLockedTime = now;\r\n        debtTx.srcSmgID = srcSmgID;\r\n\r\n        self.mapHashXDebtTxs[xHash] = debtTx;\r\n    }\r\n\r\n    /// @notice                     refund coins from HTLC transaction\r\n    /// @param x                    HTLC random number\r\n    /// @param status               Status, should be 'Locked' for asset or 'DebtLocked' for debt\r\n    function redeemDebtTx(Data storage self, bytes32 x, TxStatus status)\r\n        external\r\n        returns(bytes32 xHash)\r\n    {\r\n        xHash = sha256(abi.encodePacked(x));\r\n\r\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\r\n        // require(debtTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\r\n        require(debtTx.baseTx.status == status, \"Status is not locked\");\r\n        require(now < debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime), \"Redeem timeout\");\r\n\r\n        debtTx.baseTx.status = TxStatus.Redeemed;\r\n\r\n        return xHash;\r\n    }\r\n\r\n    /// @notice                     revoke debt transaction, which is used for source storeman group\r\n    /// @param  xHash               hash of HTLC random number\r\n    /// @param  status              Status, should be 'Locked' for asset or 'DebtLocked' for debt\r\n    function revokeDebtTx(Data storage self, bytes32 xHash, TxStatus status)\r\n        external\r\n    {\r\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\r\n        // require(debtTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\r\n        require(debtTx.baseTx.status == status, \"Status is not locked\");\r\n        require(now >= debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime), \"Revoke is not permitted\");\r\n\r\n        debtTx.baseTx.status = TxStatus.Revoked;\r\n    }\r\n\r\n    /// @notice                     function for get debt info\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @return srcSmgID            ID of source storeman\r\n    /// @return destSmgID           ID of destination storeman\r\n    function getDebtTx(Data storage self, bytes32 xHash)\r\n        external\r\n        view\r\n        returns (bytes32, bytes32)\r\n    {\r\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\r\n        return (debtTx.srcSmgID, debtTx.baseTx.smgID);\r\n    }\r\n\r\n    function getLeftTime(uint endTime) private view returns (uint) {\r\n        if (now < endTime) {\r\n            return endTime.sub(now);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /// @notice                     function for get debt info\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @return leftTime            the left lock time\r\n    function getLeftLockedTime(Data storage self, bytes32 xHash)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\r\n        if (userTx.baseTx.status != TxStatus.None) {\r\n            return getLeftTime(userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime));\r\n        }\r\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\r\n        if (smgTx.baseTx.status != TxStatus.None) {\r\n            return getLeftTime(smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime));\r\n        }\r\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\r\n        if (debtTx.baseTx.status != TxStatus.None) {\r\n            return getLeftTime(debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime));\r\n        }\r\n        require(false, 'invalid xHash');\r\n    }\r\n}\r\n\r\n// File: contracts/crossApproach/lib/RapidityTxLib.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\nlibrary RapidityTxLib {\r\n\r\n    /**\r\n     *\r\n     * ENUMS\r\n     *\r\n     */\r\n\r\n    /// @notice tx info status\r\n    /// @notice uninitialized,Redeemed\r\n    enum TxStatus {None, Redeemed}\r\n\r\n    /**\r\n     *\r\n     * STRUCTURES\r\n     *\r\n     */\r\n    struct Data {\r\n        /// @notice mapping of uniqueID to TxStatus -- uniqueID->TxStatus\r\n        mapping(bytes32 => TxStatus) mapTxStatus;\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * MANIPULATIONS\r\n     *\r\n     */\r\n\r\n    /// @notice                     add user transaction info\r\n    /// @param  uniqueID            Rapidity random number\r\n    function addRapidityTx(Data storage self, bytes32 uniqueID)\r\n        internal\r\n    {\r\n        TxStatus status = self.mapTxStatus[uniqueID];\r\n        require(status == TxStatus.None, \"Rapidity tx exists\");\r\n        self.mapTxStatus[uniqueID] = TxStatus.Redeemed;\r\n    }\r\n}\r\n\r\n// File: contracts/crossApproach/lib/CrossTypes.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary CrossTypes {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     *\r\n     * STRUCTURES\r\n     *\r\n     */\r\n\r\n    struct Data {\r\n\r\n        /// map of the htlc transaction info\r\n        HTLCTxLib.Data htlcTxData;\r\n\r\n        /// map of the rapidity transaction info\r\n        RapidityTxLib.Data rapidityTxData;\r\n\r\n        /// quota data of storeman group\r\n        IQuota quota;\r\n\r\n        /// token manager instance interface\r\n        ITokenManager tokenManager;\r\n\r\n        /// storemanGroup admin instance interface\r\n        IStoremanGroup smgAdminProxy;\r\n\r\n        /// storemanGroup fee admin instance address\r\n        address smgFeeProxy;\r\n\r\n        ISignatureVerifier sigVerifier;\r\n\r\n        /// @notice transaction fee, smgID => fee\r\n        mapping(bytes32 => uint) mapStoremanFee;\r\n\r\n        /// @notice transaction fee, origChainID => shadowChainID => fee\r\n        mapping(uint => mapping(uint =>uint)) mapLockFee;\r\n\r\n        /// @notice transaction fee, origChainID => shadowChainID => fee\r\n        mapping(uint => mapping(uint =>uint)) mapRevokeFee;\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * MANIPULATIONS\r\n     *\r\n     */\r\n\r\n    // /// @notice       convert bytes32 to address\r\n    // /// @param b      bytes32\r\n    // function bytes32ToAddress(bytes32 b) internal pure returns (address) {\r\n    //     return address(uint160(bytes20(b))); // high\r\n    //     // return address(uint160(uint256(b))); // low\r\n    // }\r\n\r\n    /// @notice       convert bytes to address\r\n    /// @param b      bytes\r\n    function bytesToAddress(bytes b) internal pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(b,20))\r\n        }\r\n    }\r\n\r\n    function transfer(address tokenScAddr, address to, uint value)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint beforeBalance;\r\n        uint afterBalance;\r\n        beforeBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\r\n        // IRC20Protocol(tokenScAddr).transfer(to, value);\r\n        tokenScAddr.call(bytes4(keccak256(\"transfer(address,uint256)\")), to, value);\r\n        afterBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\r\n        return afterBalance == beforeBalance.add(value);\r\n    }\r\n\r\n    function transferFrom(address tokenScAddr, address from, address to, uint value)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint beforeBalance;\r\n        uint afterBalance;\r\n        beforeBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\r\n        // IRC20Protocol(tokenScAddr).transferFrom(from, to, value);\r\n        tokenScAddr.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), from, to, value);\r\n        afterBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\r\n        return afterBalance == beforeBalance.add(value);\r\n    }\r\n}\r\n\r\n// File: contracts/crossApproach/CrossStorage.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\n\r\n\r\n\r\n\r\ncontract CrossStorage is BasicStorage {\r\n    using HTLCTxLib for HTLCTxLib.Data;\r\n    using RapidityTxLib for RapidityTxLib.Data;\r\n\r\n    /************************************************************\r\n     **\r\n     ** VARIABLES\r\n     **\r\n     ************************************************************/\r\n\r\n    CrossTypes.Data internal storageData;\r\n\r\n    /// @notice locked time(in seconds)\r\n    uint public lockedTime = uint(3600*36);\r\n\r\n    /// @notice Since storeman group admin receiver address may be changed, system should make sure the new address\r\n    /// @notice can be used, and the old address can not be used. The solution is add timestamp.\r\n    /// @notice unit: second\r\n    uint public smgFeeReceiverTimeout = uint(10*60);\r\n\r\n    enum GroupStatus { none, initial, curveSeted, failed, selected, ready, unregistered, dismissed }\r\n\r\n}\r\n\r\n// File: contracts/crossApproach/lib/HTLCDebtLib.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\n\r\n\r\nlibrary HTLCDebtLib {\r\n    using SafeMath for uint;\r\n    using HTLCTxLib for HTLCTxLib.Data;\r\n\r\n    /**\r\n     *\r\n     * STRUCTURES\r\n     *\r\n     */\r\n    /// @notice struct of HTLC debt lock parameters\r\n    struct HTLCDebtLockParams {\r\n        bytes32 xHash;                  /// hash of HTLC random number\r\n        bytes32 srcSmgID;               /// ID of source storeman group\r\n        bytes32 destSmgID;              /// ID of destination storeman group\r\n        uint lockedTime;                /// HTLC lock time\r\n    }\r\n\r\n    /**\r\n     *\r\n     * EVENTS\r\n     *\r\n     **/\r\n\r\n    /// @notice                     event of storeman debt lock\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @param srcSmgID             ID of source storeman group\r\n    /// @param destSmgID            ID of destination storeman group\r\n    event SrcDebtLockLogger(bytes32 indexed xHash, bytes32 indexed srcSmgID, bytes32 indexed destSmgID);\r\n\r\n    /// @notice                     event of redeem storeman debt\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @param srcSmgID             ID of source storeman group\r\n    /// @param destSmgID            ID of destination storeman group\r\n    /// @param x                    HTLC random number\r\n    event DestDebtRedeemLogger(bytes32 indexed xHash, bytes32 indexed srcSmgID, bytes32 indexed destSmgID, bytes32 x);\r\n\r\n    /// @notice                     event of revoke storeman debt\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @param srcSmgID             ID of source storeman group\r\n    /// @param destSmgID            ID of destination storeman group\r\n    event SrcDebtRevokeLogger(bytes32 indexed xHash, bytes32 indexed srcSmgID, bytes32 indexed destSmgID);\r\n\r\n    /// @notice                     event of storeman debt lock\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @param srcSmgID             ID of source storeman group\r\n    /// @param destSmgID            ID of destination storeman group\r\n    event DestDebtLockLogger(bytes32 indexed xHash, bytes32 indexed srcSmgID, bytes32 indexed destSmgID);\r\n\r\n    /// @notice                     event of redeem storeman debt\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @param srcSmgID             ID of source storeman group\r\n    /// @param destSmgID            ID of destination storeman group\r\n    /// @param x                    HTLC random number\r\n    event SrcDebtRedeemLogger(bytes32 indexed xHash, bytes32 indexed srcSmgID, bytes32 indexed destSmgID, bytes32 x);\r\n\r\n    /// @notice                     event of revoke storeman debt\r\n    /// @param xHash                hash of HTLC random number\r\n    /// @param srcSmgID             ID of source storeman group\r\n    /// @param destSmgID            ID of destination storeman group\r\n    event DestDebtRevokeLogger(bytes32 indexed xHash, bytes32 indexed srcSmgID, bytes32 indexed destSmgID);\r\n\r\n    /**\r\n     *\r\n     * MANIPULATIONS\r\n     *\r\n     */\r\n\r\n    /// @notice                     lock storeman debt\r\n    /// @param  storageData         Cross storage data\r\n    /// @param  params              parameters of storeman debt lock\r\n    function srcDebtLock(CrossTypes.Data storage storageData, HTLCDebtLockParams memory params)\r\n        public\r\n    {\r\n        storageData.htlcTxData.addDebtTx(params.xHash, params.srcSmgID, params.destSmgID, params.lockedTime, HTLCTxLib.TxStatus.AssetLocked);\r\n\r\n        storageData.quota.assetLock(params.srcSmgID, params.destSmgID);\r\n\r\n        emit SrcDebtLockLogger(params.xHash, params.srcSmgID, params.destSmgID);\r\n    }\r\n\r\n    /// @notice                     lock storeman debt\r\n    /// @param  storageData         Cross storage data\r\n    /// @param  params              parameters of storeman debt lock\r\n    function destDebtLock(CrossTypes.Data storage storageData, HTLCDebtLockParams memory params)\r\n        public\r\n    {\r\n        storageData.htlcTxData.addDebtTx(params.xHash, params.srcSmgID, params.destSmgID, params.lockedTime, HTLCTxLib.TxStatus.DebtLocked);\r\n\r\n        storageData.quota.debtLock(params.srcSmgID, params.destSmgID);\r\n\r\n        emit DestDebtLockLogger(params.xHash, params.srcSmgID, params.destSmgID);\r\n    }\r\n\r\n    /// @notice                     redeem storeman debt\r\n    /// @param  storageData         Cross storage data\r\n    /// @param  x                   HTLC random number\r\n    function srcDebtRedeem(CrossTypes.Data storage storageData, bytes32 x)\r\n        external\r\n    {\r\n        bytes32 xHash = storageData.htlcTxData.redeemDebtTx(x, HTLCTxLib.TxStatus.DebtLocked);\r\n\r\n        bytes32 srcSmgID;\r\n        bytes32 destSmgID;\r\n        (srcSmgID, destSmgID) = storageData.htlcTxData.getDebtTx(xHash);\r\n\r\n        storageData.quota.debtRedeem(srcSmgID, destSmgID);\r\n\r\n        emit SrcDebtRedeemLogger(xHash, srcSmgID, destSmgID, x);\r\n    }\r\n\r\n    /// @notice                     redeem storeman debt\r\n    /// @param  storageData         Cross storage data\r\n    /// @param  x                   HTLC random number\r\n    function destDebtRedeem(CrossTypes.Data storage storageData, bytes32 x)\r\n        external\r\n    {\r\n        bytes32 xHash = storageData.htlcTxData.redeemDebtTx(x, HTLCTxLib.TxStatus.AssetLocked);\r\n\r\n        bytes32 srcSmgID;\r\n        bytes32 destSmgID;\r\n        (srcSmgID, destSmgID) = storageData.htlcTxData.getDebtTx(xHash);\r\n\r\n        storageData.quota.assetRedeem(srcSmgID, destSmgID);\r\n\r\n        emit DestDebtRedeemLogger(xHash, srcSmgID, destSmgID, x);\r\n    }\r\n\r\n    /// @notice                     revoke storeman debt\r\n    /// @param  storageData         Cross storage data\r\n    /// @param  xHash               hash of HTLC random number\r\n    function destDebtRevoke(CrossTypes.Data storage storageData, bytes32 xHash)\r\n        external\r\n    {\r\n        storageData.htlcTxData.revokeDebtTx(xHash, HTLCTxLib.TxStatus.DebtLocked);\r\n\r\n        bytes32 srcSmgID;\r\n        bytes32 destSmgID;\r\n        (srcSmgID, destSmgID) = storageData.htlcTxData.getDebtTx(xHash);\r\n\r\n        storageData.quota.debtRevoke(srcSmgID, destSmgID);\r\n\r\n        emit DestDebtRevokeLogger(xHash, srcSmgID, destSmgID);\r\n    }\r\n\r\n    /// @notice                     revoke storeman debt\r\n    /// @param  storageData         Cross storage data\r\n    /// @param  xHash               hash of HTLC random number\r\n    function srcDebtRevoke(CrossTypes.Data storage storageData, bytes32 xHash)\r\n        external\r\n    {\r\n        storageData.htlcTxData.revokeDebtTx(xHash, HTLCTxLib.TxStatus.AssetLocked);\r\n\r\n        bytes32 srcSmgID;\r\n        bytes32 destSmgID;\r\n        (srcSmgID, destSmgID) = storageData.htlcTxData.getDebtTx(xHash);\r\n\r\n        storageData.quota.assetRevoke(srcSmgID, destSmgID);\r\n\r\n        emit SrcDebtRevokeLogger(xHash, srcSmgID, destSmgID);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ISmgFeeProxy.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity 0.4.26;\r\n\r\ninterface ISmgFeeProxy {\r\n  function smgTransfer(bytes32 smgID) external payable;\r\n}\r\n\r\n// File: contracts/crossApproach/lib/RapidityLib.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\n\r\n\r\n// import \"../../interfaces/IRC20Protocol.sol\";\r\n\r\n\r\nlibrary RapidityLib {\r\n    using SafeMath for uint;\r\n    using RapidityTxLib for RapidityTxLib.Data;\r\n\r\n    /**\r\n    *\r\n    * STRUCTURES\r\n    *\r\n    */\r\n\r\n    /// @notice struct of Rapidity storeman mint lock parameters\r\n    struct RapidityUserMintParams {\r\n        bytes32 smgID;                      /// ID of storeman group which user has selected\r\n        uint tokenPairID;                   /// token pair id on cross chain\r\n        uint value;                         /// exchange token value\r\n        bytes userShadowAccount;            /// account of shadow chain, used to receive token\r\n    }\r\n\r\n    /// @notice struct of Rapidity storeman mint lock parameters\r\n    struct RapiditySmgMintParams {\r\n        bytes32 uniqueID;                   /// Rapidity random number\r\n        bytes32 smgID;                      /// ID of storeman group which user has selected\r\n        uint tokenPairID;                   /// token pair id on cross chain\r\n        uint value;                         /// exchange token value\r\n        address userShadowAccount;          /// account of shadow chain, used to receive token\r\n    }\r\n\r\n    /// @notice struct of Rapidity user burn lock parameters\r\n    struct RapidityUserBurnParams {\r\n        bytes32 smgID;                  /// ID of storeman group which user has selected\r\n        uint tokenPairID;               /// token pair id on cross chain\r\n        uint value;                     /// exchange token value\r\n        bytes userOrigAccount;          /// account of token original chain, used to receive token\r\n    }\r\n\r\n    /// @notice struct of Rapidity user burn lock parameters\r\n    struct RapiditySmgBurnParams {\r\n        bytes32 uniqueID;               /// Rapidity random number\r\n        bytes32 smgID;                  /// ID of storeman group which user has selected\r\n        uint tokenPairID;               /// token pair id on cross chain\r\n        uint value;                     /// exchange token value\r\n        address userOrigAccount;          /// account of token original chain, used to receive token\r\n    }\r\n\r\n    /**\r\n     *\r\n     * EVENTS\r\n     *\r\n     **/\r\n\r\n\r\n    /// @notice                         event of exchange WRC-20 token with original chain token request\r\n    /// @notice                         event invoked by storeman group\r\n    /// @param smgID                    ID of storemanGroup\r\n    /// @param tokenPairID              token pair ID of cross chain token\r\n    /// @param value                    Rapidity value\r\n    /// @param userAccount              account of shadow chain, used to receive token\r\n    event UserFastMintLogger(bytes32 indexed smgID, uint indexed tokenPairID, uint value, uint fee, bytes userAccount);\r\n\r\n    /// @notice                         event of exchange WRC-20 token with original chain token request\r\n    /// @notice                         event invoked by storeman group\r\n    /// @param uniqueID                 unique random number\r\n    /// @param smgID                    ID of storemanGroup\r\n    /// @param tokenPairID              token pair ID of cross chain token\r\n    /// @param value                    Rapidity value\r\n    /// @param userAccount              account of original chain, used to receive token\r\n    event SmgFastMintLogger(bytes32 indexed uniqueID, bytes32 indexed smgID, uint indexed tokenPairID, uint value, address userAccount);\r\n\r\n    /// @notice                         event of exchange WRC-20 token with original chain token request\r\n    /// @notice                         event invoked by storeman group\r\n    /// @param smgID                    ID of storemanGroup\r\n    /// @param tokenPairID              token pair ID of cross chain token\r\n    /// @param value                    Rapidity value\r\n    /// @param userAccount              account of shadow chain, used to receive token\r\n    event UserFastBurnLogger(bytes32 indexed smgID, uint indexed tokenPairID, uint value, uint fee, bytes userAccount);\r\n\r\n    /// @notice                         event of exchange WRC-20 token with original chain token request\r\n    /// @notice                         event invoked by storeman group\r\n    /// @param uniqueID                 unique random number\r\n    /// @param smgID                    ID of storemanGroup\r\n    /// @param tokenPairID              token pair ID of cross chain token\r\n    /// @param value                    Rapidity value\r\n    /// @param userAccount              account of original chain, used to receive token\r\n    event SmgFastBurnLogger(bytes32 indexed uniqueID, bytes32 indexed smgID, uint indexed tokenPairID, uint value, address userAccount);\r\n\r\n    /**\r\n    *\r\n    * MANIPULATIONS\r\n    *\r\n    */\r\n\r\n    /// @notice                         mintBridge, user lock token on token original chain\r\n    /// @notice                         event invoked by user mint lock\r\n    /// @param storageData              Cross storage data\r\n    /// @param params                   parameters for user mint lock token on token original chain\r\n    function userFastMint(CrossTypes.Data storage storageData, RapidityUserMintParams memory params)\r\n        public\r\n    {\r\n        uint origChainID;\r\n        uint shadowChainID;\r\n        bytes memory tokenOrigAccount;\r\n        (origChainID,tokenOrigAccount,shadowChainID) = storageData.tokenManager.getTokenPairInfoSlim(params.tokenPairID);\r\n        require(origChainID != 0, \"Token does not exist\");\r\n\r\n        uint lockFee = storageData.mapLockFee[origChainID][shadowChainID];\r\n\r\n        storageData.quota.userFastMint(params.tokenPairID, params.smgID, params.value);\r\n\r\n        if (lockFee > 0) {\r\n            if (storageData.smgFeeProxy == address(0)) {\r\n                storageData.mapStoremanFee[params.smgID] = storageData.mapStoremanFee[params.smgID].add(lockFee);\r\n            } else {\r\n                ISmgFeeProxy(storageData.smgFeeProxy).smgTransfer.value(lockFee)(params.smgID);\r\n            }\r\n        }\r\n\r\n        address tokenScAddr = CrossTypes.bytesToAddress(tokenOrigAccount);\r\n\r\n        uint left;\r\n        if (tokenScAddr == address(0)) {\r\n            left = (msg.value).sub(params.value).sub(lockFee);\r\n        } else {\r\n            left = (msg.value).sub(lockFee);\r\n\r\n            // require(IRC20Protocol(tokenScAddr).transferFrom(msg.sender, this, params.value), \"Lock token failed\");\r\n            require(CrossTypes.transferFrom(tokenScAddr, msg.sender, this, params.value), \"Lock token failed\");\r\n        }\r\n        if (left != 0) {\r\n            (msg.sender).transfer(left);\r\n        }\r\n        emit UserFastMintLogger(params.smgID, params.tokenPairID, params.value, lockFee, params.userShadowAccount);\r\n    }\r\n\r\n    /// @notice                         mintBridge, storeman mint lock token on token shadow chain\r\n    /// @notice                         event invoked by user mint lock\r\n    /// @param storageData              Cross storage data\r\n    /// @param params                   parameters for storeman mint lock token on token shadow chain\r\n    function smgFastMint(CrossTypes.Data storage storageData, RapiditySmgMintParams memory params)\r\n        public\r\n    {\r\n        storageData.rapidityTxData.addRapidityTx(params.uniqueID);\r\n\r\n        storageData.quota.smgFastMint(params.tokenPairID, params.smgID, params.value);\r\n\r\n        storageData.tokenManager.mintToken(params.tokenPairID, params.userShadowAccount, params.value);\r\n\r\n        emit SmgFastMintLogger(params.uniqueID, params.smgID, params.tokenPairID, params.value, params.userShadowAccount);\r\n    }\r\n\r\n    /// @notice                         burnBridge, user lock token on token original chain\r\n    /// @notice                         event invoked by user burn lock\r\n    /// @param storageData              Cross storage data\r\n    /// @param params                   parameters for user burn lock token on token original chain\r\n    function userFastBurn(CrossTypes.Data storage storageData, RapidityUserBurnParams memory params)\r\n        public\r\n    {\r\n        uint origChainID;\r\n        uint shadowChainID;\r\n        bytes memory tokenShadowAccount;\r\n        (origChainID,,shadowChainID,tokenShadowAccount) = storageData.tokenManager.getTokenPairInfo(params.tokenPairID);\r\n        require(origChainID != 0, \"Token does not exist\");\r\n\r\n        uint lockFee = storageData.mapLockFee[origChainID][shadowChainID];\r\n\r\n        storageData.quota.userFastBurn(params.tokenPairID, params.smgID, params.value);\r\n\r\n        address tokenScAddr = CrossTypes.bytesToAddress(tokenShadowAccount);\r\n        // require(IRC20Protocol(tokenScAddr).transferFrom(msg.sender, this, params.value), \"Lock token failed\");\r\n        require(CrossTypes.transferFrom(tokenScAddr, msg.sender, this, params.value), \"Lock token failed\");\r\n\r\n        storageData.tokenManager.burnToken(params.tokenPairID, params.value);\r\n\r\n        if (lockFee > 0) {\r\n            if (storageData.smgFeeProxy == address(0)) {\r\n                storageData.mapStoremanFee[params.smgID] = storageData.mapStoremanFee[params.smgID].add(lockFee);\r\n            } else {\r\n                ISmgFeeProxy(storageData.smgFeeProxy).smgTransfer.value(lockFee)(params.smgID);\r\n            }\r\n        }\r\n\r\n        uint left = (msg.value).sub(lockFee);\r\n        if (left != 0) {\r\n            (msg.sender).transfer(left);\r\n        }\r\n\r\n        emit UserFastBurnLogger(params.smgID, params.tokenPairID, params.value, lockFee, params.userOrigAccount);\r\n    }\r\n\r\n    /// @notice                         burnBridge, storeman burn lock token on token shadow chain\r\n    /// @notice                         event invoked by user burn lock\r\n    /// @param storageData              Cross storage data\r\n    /// @param params                   parameters for storeman burn lock token on token shadow chain\r\n    function smgFastBurn(CrossTypes.Data storage storageData, RapiditySmgBurnParams memory params)\r\n        public\r\n    {\r\n        uint origChainID;\r\n        bytes memory tokenOrigAccount;\r\n        (origChainID,tokenOrigAccount,) = storageData.tokenManager.getTokenPairInfoSlim(params.tokenPairID);\r\n        require(origChainID != 0, \"Token does not exist\");\r\n\r\n        storageData.rapidityTxData.addRapidityTx(params.uniqueID);\r\n\r\n        storageData.quota.smgFastBurn(params.tokenPairID, params.smgID, params.value);\r\n\r\n        address tokenScAddr = CrossTypes.bytesToAddress(tokenOrigAccount);\r\n\r\n        if (tokenScAddr == address(0)) {\r\n            (params.userOrigAccount).transfer(params.value);\r\n        } else {\r\n            // require(IRC20Protocol(tokenScAddr).transfer(params.userOrigAccount, params.value), \"Transfer token failed\");\r\n            require(CrossTypes.transfer(tokenScAddr, params.userOrigAccount, params.value), \"Transfer token failed\");\r\n        }\r\n\r\n        emit SmgFastBurnLogger(params.uniqueID, params.smgID, params.tokenPairID, params.value, params.userOrigAccount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/crossApproach/CrossDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2019 Wanchain Foundation.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\n//                            _           _           _\r\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\r\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\r\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\r\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\r\n//\r\n//\r\n\r\npragma solidity ^0.4.26;\r\n\r\n\r\n\r\n// import \"./lib/HTLCMintLib.sol\";\r\n// import \"./lib/HTLCBurnLib.sol\";\r\n\r\n\r\n\r\ncontract CrossDelegate is CrossStorage, ReentrancyGuard, Halt {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     *\r\n     * EVENTS\r\n     *\r\n     **/\r\n\r\n    /// @notice                         event of storeman group ID withdraw the original coin to receiver\r\n    /// @param smgID                    ID of storemanGroup\r\n    /// @param timeStamp                timestamp of the withdraw\r\n    /// @param receiver                 receiver address\r\n    /// @param fee                      shadow coin of the fee which the storeman group pk got it\r\n    event SmgWithdrawFeeLogger(bytes32 indexed smgID, uint timeStamp, address indexed receiver, uint fee);\r\n\r\n    /**\r\n     *\r\n     * MODIFIERS\r\n     *\r\n     */\r\n    /// @dev Check valid value\r\n    modifier onlyMeaningfulValue(uint value) {\r\n        require(value != 0, \"Value is null\");\r\n        _;\r\n    }\r\n\r\n    /// @notice                                 check the storeman group is ready\r\n    /// @param smgID                            ID of storeman group\r\n    modifier onlyReadySmg(bytes32 smgID) {\r\n        uint8 status;\r\n        uint startTime;\r\n        uint endTime;\r\n        (status,startTime,endTime) = storageData.smgAdminProxy.getStoremanGroupStatus(smgID);\r\n\r\n        require(status == uint8(GroupStatus.ready) && now >= startTime && now <= endTime, \"PK is not ready\");\r\n        _;\r\n    }\r\n\r\n\r\n    // function _checkValue(uint value) private view {\r\n    //     require(value != 0, \"Value is null\");\r\n    // }\r\n\r\n    // function _checkReadySmg(bytes32 smgID) private view {\r\n    //     uint8 status;\r\n    //     uint startTime;\r\n    //     uint endTime;\r\n    //     (,status,,,,,,,,startTime,endTime) = storageData.smgAdminProxy.getStoremanGroupConfig(smgID);\r\n\r\n    //     require(status == uint8(GroupStatus.ready) && now >= startTime && now <= endTime, \"PK is not ready\");\r\n    // }\r\n\r\n    // function _checkUnregisteredSmg(bytes32 smgID) private view {\r\n    //     uint8 status;\r\n    //     (,status,,,,,,,,,) = storageData.smgAdminProxy.getStoremanGroupConfig(smgID);\r\n\r\n    //     require(status == uint8(GroupStatus.unregistered), \"PK is not unregistered\");\r\n    // }\r\n\r\n    /**\r\n     *\r\n     * MANIPULATIONS\r\n     *\r\n     */\r\n\r\n    // /// @notice                                 get the exist storeman group info\r\n    // /// @param smgID                            ID of storeman group\r\n    // /// @return curveID                         ID of elliptic curve\r\n    // /// @return PK                              PK of storeman group\r\n    // function acquireExistSmgInfo(bytes32 smgID)\r\n    //     private\r\n    //     view\r\n    //     returns (uint curveID, bytes memory PK)\r\n    // {\r\n    //     uint origChainID;\r\n    //     (,,,origChainID,,curveID,,PK,,,) = storageData.smgAdminProxy.getStoremanGroupConfig(smgID);\r\n    //     require(origChainID != 0, \"PK does not exist\");\r\n\r\n    //     return (curveID, PK);\r\n    // }\r\n\r\n    /// @notice                                 check the storeman group is ready or not\r\n    /// @param smgID                            ID of storeman group\r\n    /// @return curveID                         ID of elliptic curve\r\n    /// @return PK                              PK of storeman group\r\n    function acquireReadySmgInfo(bytes32 smgID)\r\n        private\r\n        view\r\n        returns (uint curveID, bytes memory PK)\r\n    {\r\n        uint8 status;\r\n        uint startTime;\r\n        uint endTime;\r\n        (,status,,,,curveID,,PK,,startTime,endTime) = storageData.smgAdminProxy.getStoremanGroupConfig(smgID);\r\n\r\n        require(status == uint8(GroupStatus.ready) && now >= startTime && now <= endTime, \"PK is not ready\");\r\n\r\n        return (curveID, PK);\r\n    }\r\n\r\n    /// @notice                                 get the unregistered storeman group info\r\n    /// @param smgID                            ID of storeman group\r\n    /// @return curveID                         ID of elliptic curve\r\n    /// @return PK                              PK of storeman group\r\n    function acquireUnregisteredSmgInfo(bytes32 smgID)\r\n        private\r\n        view\r\n        returns (uint curveID, bytes memory PK)\r\n    {\r\n        uint8 status;\r\n        (,status,,,,curveID,,PK,,,) = storageData.smgAdminProxy.getStoremanGroupConfig(smgID);\r\n\r\n        require(status == uint8(GroupStatus.unregistered), \"PK is not unregistered\");\r\n    }\r\n    /*\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     account of user, used to receive WRC20 token\r\n    function userMintLock(bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, bytes userAccount)\r\n        external\r\n        payable\r\n        notHalted\r\n        nonReentrant\r\n        onlyReadySmg(smgID)\r\n        onlyMeaningfulValue(value)\r\n    {\r\n        HTLCMintLib.HTLCUserMintLockParams memory params = HTLCMintLib.HTLCUserMintLockParams({\r\n            xHash: xHash,\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            lockedTime: lockedTime.mul(2),\r\n            userShadowAccount: userAccount\r\n        });\r\n\r\n        HTLCMintLib.userMintLock(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     address of user, used to receive WRC20 token\r\n    /// @param  r                               signature\r\n    /// @param  s                               signature\r\n    function smgMintLock(bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, address userAccount, bytes r, bytes32 s)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        uint curveID;\r\n        bytes memory PK;\r\n        (curveID, PK) = acquireReadySmgInfo(smgID);\r\n\r\n        bytes32 mHash = sha256(abi.encode(xHash, tokenPairID, value, userAccount));\r\n        verifySignature(curveID, mHash, PK, r, s);\r\n\r\n        HTLCMintLib.HTLCSmgMintLockParams memory params = HTLCMintLib.HTLCSmgMintLockParams({\r\n            xHash: xHash,\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            lockedTime: lockedTime,\r\n            userShadowAccount: userAccount\r\n        });\r\n        HTLCMintLib.smgMintLock(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  x                               HTLC random number\r\n    function userMintRedeem(bytes32 x)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCMintLib.userMintRedeem(storageData, x);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  x                               HTLC random number\r\n    function smgMintRedeem(bytes32 x)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCMintLib.smgMintRedeem(storageData, x);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    function smgMintRevoke(bytes32 xHash)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCMintLib.smgMintRevoke(storageData, xHash);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    function userMintRevoke(bytes32 xHash)\r\n        external\r\n        payable\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCMintLib.userMintRevoke(storageData, xHash);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     account of user, used to receive original chain token\r\n    function userBurnLock(bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, bytes userAccount)\r\n        external\r\n        payable\r\n        notHalted\r\n        nonReentrant\r\n        onlyReadySmg(smgID)\r\n        onlyMeaningfulValue(value)\r\n    {\r\n        HTLCBurnLib.HTLCUserBurnLockParams memory params = HTLCBurnLib.HTLCUserBurnLockParams({\r\n            xHash: xHash,\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            lockedTime: lockedTime.mul(2),\r\n            userOrigAccount: userAccount\r\n        });\r\n        HTLCBurnLib.userBurnLock(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     address of user, used to receive WRC20 token\r\n    /// @param  r                               signature\r\n    /// @param  s                               signature\r\n    function smgBurnLock(bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, address userAccount, bytes r, bytes32 s)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        uint curveID;\r\n        bytes memory PK;\r\n        (curveID, PK) = acquireReadySmgInfo(smgID);\r\n\r\n        bytes32 mHash = sha256(abi.encode(xHash, tokenPairID, value, userAccount));\r\n        verifySignature(curveID, mHash, PK, r, s);\r\n\r\n        HTLCBurnLib.HTLCSmgBurnLockParams memory params = HTLCBurnLib.HTLCSmgBurnLockParams({\r\n            xHash: xHash,\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            lockedTime: lockedTime,\r\n            userOrigAccount: userAccount\r\n        });\r\n        HTLCBurnLib.smgBurnLock(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  x                               HTLC random number\r\n    function userBurnRedeem(bytes32 x)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCBurnLib.userBurnRedeem(storageData, x);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  x                               HTLC random number\r\n    function smgBurnRedeem(bytes32 x)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCBurnLib.smgBurnRedeem(storageData, x);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    function smgBurnRevoke(bytes32 xHash)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCBurnLib.smgBurnRevoke(storageData, xHash);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    function userBurnRevoke(bytes32 xHash)\r\n        external\r\n        payable\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        HTLCBurnLib.userBurnRevoke(storageData, xHash);\r\n    }\r\n*/\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     account of user, used to receive shadow chain token\r\n    function userFastMint(bytes32 smgID, uint tokenPairID, uint value, bytes userAccount)\r\n        external\r\n        payable\r\n        notHalted\r\n        // nonReentrant\r\n        onlyReadySmg(smgID)\r\n        onlyMeaningfulValue(value)\r\n    {\r\n        RapidityLib.RapidityUserMintParams memory params = RapidityLib.RapidityUserMintParams({\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            userShadowAccount: userAccount\r\n        });\r\n        RapidityLib.userFastMint(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  uniqueID                        fast cross chain random number\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     address of user, used to receive WRC20 token\r\n    /// @param  r                               signature\r\n    /// @param  s                               signature\r\n    function smgFastMint(bytes32 uniqueID, bytes32 smgID, uint tokenPairID, uint value, address userAccount, bytes r, bytes32 s)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        uint curveID;\r\n        bytes memory PK;\r\n        // (curveID, PK) = acquireExistSmgInfo(smgID);\r\n        (curveID, PK) = acquireReadySmgInfo(smgID);\r\n\r\n        bytes32 mHash = sha256(abi.encode(uniqueID, tokenPairID, value, userAccount));\r\n        verifySignature(curveID, mHash, PK, r, s);\r\n\r\n        RapidityLib.RapiditySmgMintParams memory params = RapidityLib.RapiditySmgMintParams({\r\n            uniqueID: uniqueID,\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            userShadowAccount: userAccount\r\n        });\r\n        RapidityLib.smgFastMint(storageData, params);\r\n    }\r\n\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     account of user, used to receive original chain token\r\n    function userFastBurn(bytes32 smgID, uint tokenPairID, uint value, bytes userAccount)\r\n        external\r\n        payable\r\n        notHalted\r\n        nonReentrant\r\n        onlyReadySmg(smgID)\r\n        onlyMeaningfulValue(value)\r\n    {\r\n        RapidityLib.RapidityUserBurnParams memory params = RapidityLib.RapidityUserBurnParams({\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            userOrigAccount: userAccount\r\n        });\r\n        RapidityLib.userFastBurn(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 request exchange RC20 token with WRC20 on wanchain\r\n    /// @param  uniqueID                        fast cross chain random number\r\n    /// @param  smgID                           ID of storeman\r\n    /// @param  tokenPairID                     token pair ID of cross chain token\r\n    /// @param  value                           exchange value\r\n    /// @param  userAccount                     address of user, used to receive original token/coin\r\n    /// @param  r                               signature\r\n    /// @param  s                               signature\r\n    function smgFastBurn(bytes32 uniqueID, bytes32 smgID, uint tokenPairID, uint value, address userAccount, bytes r, bytes32 s)\r\n        external\r\n        notHalted\r\n        nonReentrant\r\n    {\r\n        uint curveID;\r\n        bytes memory PK;\r\n        // (curveID, PK) = acquireExistSmgInfo(smgID);\r\n        (curveID, PK) = acquireReadySmgInfo(smgID);\r\n\r\n        bytes32 mHash = sha256(abi.encode(uniqueID, tokenPairID, value, userAccount));\r\n        verifySignature(curveID, mHash, PK, r, s);\r\n\r\n        RapidityLib.RapiditySmgBurnParams memory params = RapidityLib.RapiditySmgBurnParams({\r\n            uniqueID: uniqueID,\r\n            smgID: smgID,\r\n            tokenPairID: tokenPairID,\r\n            value: value,\r\n            userOrigAccount: userAccount\r\n        });\r\n        RapidityLib.smgFastBurn(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 lock storeman debt\r\n    /// @param  xHash                           hash of HTLC random number\r\n    /// @param  srcSmgID                        ID of src storeman\r\n    /// @param  destSmgID                       ID of dst storeman\r\n    /// @param  r                               signature\r\n    /// @param  s                               signature\r\n    function srcDebtLock(bytes32 xHash, bytes32 srcSmgID, bytes32 destSmgID, bytes r, bytes32 s)\r\n        external\r\n        notHalted\r\n        onlyReadySmg(destSmgID)\r\n    {\r\n        uint curveID;\r\n        bytes memory PK;\r\n        (curveID, PK) = acquireUnregisteredSmgInfo(srcSmgID);\r\n\r\n        bytes32 mHash = sha256(abi.encode(xHash, destSmgID));\r\n        verifySignature(curveID, mHash, PK, r, s);\r\n\r\n        HTLCDebtLib.HTLCDebtLockParams memory params = HTLCDebtLib.HTLCDebtLockParams({\r\n            xHash: xHash,\r\n            srcSmgID: srcSmgID,\r\n            destSmgID: destSmgID,\r\n            lockedTime: lockedTime.mul(2)\r\n        });\r\n        HTLCDebtLib.srcDebtLock(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 lock storeman debt\r\n    /// @param  xHash                           hash of HTLC random number\r\n    /// @param  srcSmgID                        ID of src storeman\r\n    /// @param  destSmgID                       ID of dst storeman\r\n    /// @param  r                               signature\r\n    /// @param  s                               signature\r\n    function destDebtLock(bytes32 xHash, bytes32 srcSmgID, bytes32 destSmgID, bytes r, bytes32 s)\r\n        external\r\n        notHalted\r\n    {\r\n        uint curveID;\r\n        bytes memory PK;\r\n        (curveID, PK) = acquireReadySmgInfo(destSmgID);\r\n\r\n        bytes32 mHash = sha256(abi.encode(xHash, srcSmgID));\r\n        verifySignature(curveID, mHash, PK, r, s);\r\n\r\n        HTLCDebtLib.HTLCDebtLockParams memory params = HTLCDebtLib.HTLCDebtLockParams({\r\n            xHash: xHash,\r\n            srcSmgID: srcSmgID,\r\n            destSmgID: destSmgID,\r\n            lockedTime: lockedTime\r\n        });\r\n        HTLCDebtLib.destDebtLock(storageData, params);\r\n    }\r\n\r\n    /// @notice                                 redeem debt, destination storeman group takes over the debt of source storeman group\r\n    /// @param  x                               HTLC random number\r\n    function srcDebtRedeem(bytes32 x)\r\n        external\r\n        notHalted\r\n    {\r\n        HTLCDebtLib.srcDebtRedeem(storageData, x);\r\n    }\r\n\r\n    /// @notice                                 redeem debt, destination storeman group takes over the debt of source storeman group\r\n    /// @param  x                               HTLC random number\r\n    function destDebtRedeem(bytes32 x)\r\n        external\r\n        notHalted\r\n    {\r\n        HTLCDebtLib.destDebtRedeem(storageData, x);\r\n    }\r\n\r\n    /// @notice                                 source storeman group revoke the debt on debt chain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    function destDebtRevoke(bytes32 xHash)\r\n        external\r\n        notHalted\r\n    {\r\n        HTLCDebtLib.destDebtRevoke(storageData, xHash);\r\n    }\r\n\r\n    /// @notice                                 source storeman group revoke the debt on asset chain\r\n    /// @param  xHash                           hash of HTLC random number\r\n    function srcDebtRevoke(bytes32 xHash)\r\n        external\r\n        notHalted\r\n    {\r\n        HTLCDebtLib.srcDebtRevoke(storageData, xHash);\r\n    }\r\n\r\n    /// @notice                             get the fee of the storeman group should get\r\n    /// @param smgID                        ID of storemanGroup\r\n    /// @return fee                         original coin the storeman group should get\r\n    function getStoremanFee(bytes32 smgID)\r\n        external\r\n        view\r\n        returns(uint fee)\r\n    {\r\n        fee = storageData.mapStoremanFee[smgID];\r\n    }\r\n\r\n    /// @notice                             get the fee of the storeman group should get\r\n    /// @param origChainID                  ID of token original chain\r\n    /// @param shadowChainID                ID of token shadow chain\r\n    /// @param lockFee                      Coin the storeman group should get while storeman redeem user lock\r\n    /// @param revokeFee                    Coin the storeman group should get while user revoke its lock\r\n    function setFees(uint origChainID, uint shadowChainID, uint lockFee, uint revokeFee)\r\n        external\r\n        onlyOwner\r\n    {\r\n        storageData.mapLockFee[origChainID][shadowChainID] = lockFee;\r\n        storageData.mapRevokeFee[origChainID][shadowChainID] = revokeFee;\r\n    }\r\n\r\n    /// @notice                             get the fee of the storeman group should get\r\n    /// @param origChainID                  Original chain ID\r\n    /// @param shadowChainID                Shadow Chain ID\r\n    /// @return lockFee                     Coin the storeman group should get while storeman redeem user lock\r\n    /// @return revokeFee                   Coin the storeman group should get while user revoke its lock\r\n    function getFees(uint origChainID, uint shadowChainID)\r\n        external\r\n        view\r\n        returns(uint lockFee, uint revokeFee)\r\n    {\r\n        lockFee = storageData.mapLockFee[origChainID][shadowChainID];\r\n        revokeFee = storageData.mapRevokeFee[origChainID][shadowChainID];\r\n    }\r\n\r\n    /// @notice                             get the fee of the storeman group should get\r\n    /// @param time                         Coin the storeman group should get while storeman redeem user lock\r\n    function setLockedTime(uint time)\r\n        external\r\n        onlyOwner\r\n    {\r\n        lockedTime = time;\r\n    }\r\n\r\n    /// @notice                             get the fee of the storeman group should get\r\n    /// @param  xHash                       hash of HTLC random number\r\n    /// @return leftLockTime                left time of locked transaction\r\n    function getLeftLockedTime(bytes32 xHash) external view returns (uint leftLockedTime) {\r\n        leftLockedTime = storageData.htlcTxData.getLeftLockedTime(xHash);\r\n    }\r\n\r\n    /// @notice                             update the initialized state value of this contract\r\n    /// @param tokenManager                 address of the token manager\r\n    /// @param smgAdminProxy                address of the storeman group admin\r\n    /// @param smgFeeProxy                  address of the proxy to store fee for storeman group\r\n    /// @param quota                        address of the quota\r\n    /// @param sigVerifier                  address of the signature verifier\r\n    function setPartners(address tokenManager, address smgAdminProxy, address smgFeeProxy, address quota, address sigVerifier)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(tokenManager != address(0) && smgAdminProxy != address(0) && quota != address(0) && sigVerifier != address(0),\r\n            \"Parameter is invalid\");\r\n\r\n        storageData.smgAdminProxy = IStoremanGroup(smgAdminProxy);\r\n        storageData.tokenManager = ITokenManager(tokenManager);\r\n        storageData.quota = IQuota(quota);\r\n        storageData.smgFeeProxy = smgFeeProxy;\r\n        storageData.sigVerifier = ISignatureVerifier(sigVerifier);\r\n    }\r\n\r\n    /// @notice                             get the initialized state value of this contract\r\n    /// @return tokenManager                address of the token manager\r\n    /// @return smgAdminProxy               address of the storeman group admin\r\n    /// @return smgFeeProxy                 address of the proxy to store fee for storeman group\r\n    /// @return quota                       address of the quota\r\n    /// @return sigVerifier                 address of the signature verifier\r\n    function getPartners()\r\n        external\r\n        view\r\n        returns(address tokenManager, address smgAdminProxy, address smgFeeProxy, address quota, address sigVerifier)\r\n    {\r\n        tokenManager = address(storageData.tokenManager);\r\n        smgAdminProxy = address(storageData.smgAdminProxy);\r\n        smgFeeProxy = storageData.smgFeeProxy;\r\n        quota = address(storageData.quota);\r\n        sigVerifier = address(storageData.sigVerifier);\r\n    }\r\n\r\n    /// @notice                             get the fee of the storeman group should get\r\n    /// @param timeout                      Timeout for storeman group receiver withdraw fee, uint second\r\n    function setWithdrawFeeTimeout(uint timeout)\r\n        external\r\n        onlyOwner\r\n    {\r\n        smgFeeReceiverTimeout = timeout;\r\n    }\r\n\r\n    /// @notice                             storeman group withdraw the fee to receiver account\r\n    /// @param smgID                        ID of the storeman group\r\n    /// @param receiver                     account of the receiver\r\n    /// @param r                            signature\r\n    /// @param s                            signature\r\n    function smgWithdrawFee(bytes32 smgID, uint timeStamp, address receiver, bytes r, bytes32 s)\r\n        external\r\n        nonReentrant\r\n    {\r\n\r\n        require(now < timeStamp.add(smgFeeReceiverTimeout), \"The receiver address expired\");\r\n\r\n        uint curveID;\r\n        bytes memory PK;\r\n        (,,,,,curveID,,PK,,,) = storageData.smgAdminProxy.getStoremanGroupConfig(smgID);\r\n        verifySignature(curveID, sha256(abi.encode(timeStamp, receiver)), PK, r, s);\r\n\r\n        uint fee = storageData.mapStoremanFee[smgID];\r\n\r\n        require(fee > 0, \"Fee is null\");\r\n\r\n        delete storageData.mapStoremanFee[smgID];\r\n        receiver.transfer(fee);\r\n\r\n        emit SmgWithdrawFeeLogger(smgID, now, receiver, fee);\r\n    }\r\n\r\n    /// @notice       convert bytes to bytes32\r\n    /// @param b      bytes array\r\n    /// @param offset offset of array to begin convert\r\n    // function bytesToBytes32(bytes b, uint offset) private pure returns (bytes32) {\r\n    //     bytes32 out;\r\n\r\n    //     for (uint i = 0; i < 32; i++) {\r\n    //       out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\r\n    //     }\r\n    //     return out;\r\n    // }\r\n    function bytesToBytes32(bytes memory b, uint offset) private pure returns (bytes32 result) {\r\n        assembly {\r\n            result := mload(add(add(b, offset), 32))\r\n        }\r\n    }\r\n\r\n    /// @notice             verify signature\r\n    /// @param  curveID     ID of elliptic curve\r\n    /// @param  message     message to be verified\r\n    /// @param  r           Signature info r\r\n    /// @param  s           Signature info s\r\n    function verifySignature(uint curveID, bytes32 message, bytes PK, bytes r, bytes32 s)\r\n        private\r\n        // view\r\n    {\r\n        bytes32 PKx = bytesToBytes32(PK, 0);\r\n        bytes32 PKy = bytesToBytes32(PK, 32);\r\n\r\n        bytes32 Rx = bytesToBytes32(r, 0);\r\n        bytes32 Ry = bytesToBytes32(r, 32);\r\n\r\n        require(storageData.sigVerifier.verify(curveID, s, PKx, PKy, Rx, Ry, message), \"Signature verification failed\");\r\n    }\r\n\r\n    // /// @notice                              get the detailed quota info. of this storeman group\r\n    // /// @param smgID                         ID of storemanGroup\r\n    // /// @param tokenPairID                   token pair ID of cross chain token\r\n    // /// @return _quota                       storemanGroup's total quota\r\n    // /// @return mintBridgeQuota              inbound, the amount which storeman group can handle\r\n    // /// @return BurnBridgeQuota              outbound, the amount which storeman group can handle\r\n    // /// @return _receivable                  amount of original token to be received, equals to amount of WAN token to be minted\r\n    // /// @return _payable                     amount of WAN token to be burnt\r\n    // /// @return _debt                        amount of original token has been exchanged to the wanchain\r\n    // function queryStoremanGroupQuota(bytes32 smgID, uint tokenPairID)\r\n    //     external\r\n    //     view\r\n    //     returns(uint, uint, uint, uint, uint, uint)\r\n    // {\r\n    //     return storageData.quotaData.queryQuotaInfo(smgID, tokenPairID);\r\n    // }\r\n}"}}}