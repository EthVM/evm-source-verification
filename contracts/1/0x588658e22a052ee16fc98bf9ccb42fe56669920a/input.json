{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/3_Ballot.sol": {
      "content": "pragma solidity 0.6.7;\n\ncontract GebMath {\n    uint256 public constant RAY = 10 ** 27;\n    uint256 public constant WAD = 10 ** 18;\n\n    function ray(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 9);\n    }\n    function rad(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 27);\n    }\n    function minimum(uint x, uint y) public pure returns (uint z) {\n        z = (x <= y) ? x : y;\n    }\n    function addition(uint x, uint y) public pure returns (uint z) {\n        z = x + y;\n        require(z >= x, \"uint-uint-add-overflow\");\n    }\n    function subtract(uint x, uint y) public pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function multiply(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ncontract UniswapV2Library {\n    // --- Math ---\n    function uniAddition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'UniswapV2Library: add-overflow');\n    }\n    function uniSubtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'UniswapV2Library: sub-underflow');\n    }\n    function uniMultiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'UniswapV2Library: mul-overflow');\n    }\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // Modified Uniswap function to work with dapp.tools (CREATE2 throws)\n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        return IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n    }\n\n    // fetches and sorts the reserves for a pair; modified from the initial Uniswap version in order to work with dapp.tools\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = uniMultiply(amountA, reserveB) / reserveA;\n    }\n\n    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = uniMultiply(amountIn, 997);\n        uint numerator = uniMultiply(amountInWithFee, reserveOut);\n        uint denominator = uniAddition(uniMultiply(reserveIn, 1000), amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = uniMultiply(uniMultiply(reserveIn, amountOut), 1000);\n        uint denominator = uniMultiply(uniSubtract(reserveOut, amountOut), 997);\n        amountIn = uniAddition((numerator / denominator), 1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\ncontract BabylonianMath {\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n\n// Contract for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\ncontract FixedPointMath is BabylonianMath {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint private constant Q112 = uint(1) << RESOLUTION;\n    uint private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n        uint z;\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).divide(denominator)\n    function frac(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(super.sqrt(uint256(self._x)) << 56));\n    }\n}\n\n// Contract with helper methods for oracles that are concerned with computing average prices\ncontract UniswapV2OracleLibrary is FixedPointMath {\n    // Helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2 ** 32);\n    }\n\n    // Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices(\n        address pair\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n        blockTimestamp = currentBlockTimestamp();\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n        if (blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            price0Cumulative += uint(frac(reserve1, reserve0)._x) * timeElapsed;\n            // counterfactual\n            price1Cumulative += uint(frac(reserve0, reserve1)._x) * timeElapsed;\n        }\n    }\n}\n\nabstract contract ConverterFeedLike {\n    function getResultWithValidity() virtual external view returns (uint256,bool);\n    function updateResult(address) virtual external;\n}\n\nabstract contract IncreasingRewardRelayerLike {\n    function reimburseCaller(address) virtual external;\n}\n\ncontract UniswapConsecutiveSlotsPriceFeedMedianizer is GebMath, UniswapV2Library, UniswapV2OracleLibrary {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"UniswapConsecutiveSlotsPriceFeedMedianizer/account-not-authorized\");\n        _;\n    }\n\n    // --- Observations ---\n    struct UniswapObservation {\n        uint timestamp;\n        uint price0Cumulative;\n        uint price1Cumulative;\n    }\n    struct ConverterFeedObservation {\n        uint timestamp;\n        uint timeAdjustedPrice;\n    }\n\n    // --- Uniswap Vars ---\n    // Default amount of targetToken used when calculating the denominationToken output\n    uint256              public defaultAmountIn;\n    // Token for which the contract calculates the medianPrice for\n    address              public targetToken;\n    // Pair token from the Uniswap pair\n    address              public denominationToken;\n    address              public uniswapPair;\n\n    IUniswapV2Factory    public uniswapFactory;\n\n    UniswapObservation[] public uniswapObservations;\n\n    // --- Converter Feed Vars ---\n    // Latest converter price accumulator snapshot\n    uint256                    public converterPriceCumulative;\n\n    ConverterFeedLike          public converterFeed;\n    ConverterFeedObservation[] public converterFeedObservations;\n\n    // --- General Vars ---\n    // Symbol - you want to change this every deployment\n    bytes32 public symbol = \"raiusd\";\n\n    uint8   public granularity;\n    // When the price feed was last updated\n    uint256 public lastUpdateTime;\n    // Total number of updates\n    uint256 public updates;\n    /**\n      The ideal amount of time over which the moving average should be computed, e.g. 24 hours.\n      In practice it can and most probably will be different than the actual window over which the contract medianizes.\n    **/\n    uint256 public windowSize;\n    // Maximum window size used to determine if the median is 'valid' (close to the real one) or not\n    uint256 public maxWindowSize;\n    // Stored for gas savings. Equals windowSize / granularity\n    uint256 public periodSize;\n    // This is the denominator for computing\n    uint256 public converterFeedScalingFactor;\n    // The last computed median price\n    uint256 private medianPrice;\n    // Manual flag that can be set by governance and indicates if a result is valid or not\n    uint256 public validityFlag;\n\n    // Contract relaying the SF reward to addresses that update this oracle\n    IncreasingRewardRelayerLike public relayer;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(\n      bytes32 parameter,\n      address addr\n    );\n    event ModifyParameters(\n      bytes32 parameter,\n      uint256 val\n    );\n    event UpdateResult(uint256 medianPrice, uint256 lastUpdateTime);\n    event FailedConverterFeedUpdate(bytes reason);\n    event FailedUniswapPairSync(bytes reason);\n\n    constructor(\n      address converterFeed_,\n      address uniswapFactory_,\n      uint256 defaultAmountIn_,\n      uint256 windowSize_,\n      uint256 converterFeedScalingFactor_,\n      uint256 maxWindowSize_,\n      uint8   granularity_\n    ) public {\n        require(uniswapFactory_ != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-factory\");\n        require(granularity_ > 1, 'UniswapConsecutiveSlotsPriceFeedMedianizer/null-granularity');\n        require(windowSize_ > 0, 'UniswapConsecutiveSlotsPriceFeedMedianizer/null-window-size');\n        require(maxWindowSize_ > windowSize_, 'UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-max-window-size');\n        require(defaultAmountIn_ > 0, 'UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-default-amount-in');\n        require(converterFeedScalingFactor_ > 0, 'UniswapConsecutiveSlotsPriceFeedMedianizer/null-feed-scaling-factor');\n        require(\n            (periodSize = windowSize_ / granularity_) * granularity_ == windowSize_,\n            'UniswapConsecutiveSlotsPriceFeedMedianizer/window-not-evenly-divisible'\n        );\n\n        authorizedAccounts[msg.sender] = 1;\n\n        converterFeed                  = ConverterFeedLike(converterFeed_);\n        uniswapFactory                 = IUniswapV2Factory(uniswapFactory_);\n        defaultAmountIn                = defaultAmountIn_;\n        windowSize                     = windowSize_;\n        maxWindowSize                  = maxWindowSize_;\n        converterFeedScalingFactor     = converterFeedScalingFactor_;\n        granularity                    = granularity_;\n        lastUpdateTime                 = now;\n        validityFlag                   = 1;\n\n        // Emit events\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(bytes32(\"converterFeed\"), converterFeed_);\n        emit ModifyParameters(bytes32(\"maxWindowSize\"), maxWindowSize_);\n    }\n\n    // --- Administration ---\n    /**\n    * @notice Modify the converter feed address\n    * @param parameter Name of the parameter to modify\n    * @param data New parameter value\n    **/\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-data\");\n        if (parameter == \"converterFeed\") {\n          require(data != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-converter-feed\");\n          converterFeed = ConverterFeedLike(data);\n        }\n        else if (parameter == \"targetToken\") {\n          require(uniswapPair == address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/pair-already-set\");\n          targetToken = data;\n          if (denominationToken != address(0)) {\n            uniswapPair = uniswapFactory.getPair(targetToken, denominationToken);\n            require(uniswapPair != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-pair\");\n          }\n        }\n        else if (parameter == \"denominationToken\") {\n          require(uniswapPair == address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/pair-already-set\");\n          denominationToken = data;\n          if (targetToken != address(0)) {\n            uniswapPair = uniswapFactory.getPair(targetToken, denominationToken);\n            require(uniswapPair != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-pair\");\n          }\n        }\n        else if (parameter == \"relayer\") {\n          relayer = IncreasingRewardRelayerLike(data);\n        }\n        else revert(\"UniswapConsecutiveSlotsPriceFeedMedianizer/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"validityFlag\") {\n          require(either(data == 1, data == 0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-data\");\n          validityFlag = data;\n        }\n        else if (parameter == \"defaultAmountIn\") {\n          require(data > 0, \"UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-default-amount-in\");\n          defaultAmountIn = data;\n        }\n        else if (parameter == \"maxWindowSize\") {\n          require(data > windowSize, 'UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-max-window-size');\n          maxWindowSize = data;\n        }\n        else revert(\"UniswapConsecutiveSlotsPriceFeedMedianizer/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- General Utils ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) private pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n    /**\n    * @notice Returns the oldest observations (relative to the current index in the Uniswap/Converter lists)\n    **/\n    function getFirstObservationsInWindow()\n      private view returns (UniswapObservation storage firstUniswapObservation, ConverterFeedObservation storage firstConverterFeedObservation) {\n        uint256 earliestObservationIndex = earliestObservationIndex();\n        firstUniswapObservation          = uniswapObservations[earliestObservationIndex];\n        firstConverterFeedObservation    = converterFeedObservations[earliestObservationIndex];\n    }\n    /**\n      @notice It returns the time passed since the first observation in the window\n    **/\n    function timeElapsedSinceFirstObservation() public view returns (uint256) {\n        if (updates > 1) {\n          (\n            UniswapObservation storage firstUniswapObservation,\n          ) = getFirstObservationsInWindow();\n          return subtract(now, firstUniswapObservation.timestamp);\n        }\n        return 0;\n    }\n    /**\n    * @notice Calculate the median price using the latest observations and the latest Uniswap pair prices\n    * @param price0Cumulative Cumulative price for the first token in the pair\n    * @param price1Cumulative Cumulative price for the second token in the pair\n    **/\n    function getMedianPrice(uint256 price0Cumulative, uint256 price1Cumulative) private view returns (uint256) {\n        if (updates > 1) {\n          (\n            UniswapObservation storage firstUniswapObservation,\n          ) = getFirstObservationsInWindow();\n\n          uint timeSinceFirst = subtract(now, firstUniswapObservation.timestamp);\n          (address token0,)   = sortTokens(targetToken, denominationToken);\n          uint256 uniswapAmountOut;\n\n          if (token0 == targetToken) {\n              uniswapAmountOut = uniswapComputeAmountOut(\n                firstUniswapObservation.price0Cumulative, price0Cumulative, timeSinceFirst, defaultAmountIn\n              );\n          } else {\n              uniswapAmountOut = uniswapComputeAmountOut(\n                firstUniswapObservation.price1Cumulative, price1Cumulative, timeSinceFirst, defaultAmountIn\n              );\n          }\n\n          return converterComputeAmountOut(timeSinceFirst, uniswapAmountOut);\n        }\n\n        return medianPrice;\n    }\n    /**\n    * @notice Returns the index of the earliest observation in the window\n    **/\n    function earliestObservationIndex() public view returns (uint256) {\n        if (updates <= granularity) {\n          return 0;\n        }\n        return subtract(updates, uint(granularity));\n    }\n    /**\n    * @notice Get the observation list length\n    **/\n    function getObservationListLength() public view returns (uint256, uint256) {\n        return (uniswapObservations.length, converterFeedObservations.length);\n    }\n\n    // --- Uniswap Utils ---\n    /**\n    * @notice Given the Uniswap cumulative prices of the start and end of a period, and the length of the period, compute the average\n    *         price in terms of how much amount out is received for the amount in.\n    * @param priceCumulativeStart Old snapshot of the cumulative price of a token\n    * @param priceCumulativeEnd New snapshot of the cumulative price of a token\n    * @param timeElapsed Total time elapsed\n    * @param amountIn Amount of target tokens we want to find the price for\n    **/\n    function uniswapComputeAmountOut(\n        uint256 priceCumulativeStart,\n        uint256 priceCumulativeEnd,\n        uint256 timeElapsed,\n        uint256 amountIn\n    ) public pure returns (uint256 amountOut) {\n        require(priceCumulativeEnd >= priceCumulativeStart, \"UniswapConverterBasicAveragePriceFeedMedianizer/invalid-end-cumulative\");\n        require(timeElapsed > 0, \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-time-elapsed\");\n        // Overflow is desired\n        uq112x112 memory priceAverage = uq112x112(\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n        );\n        amountOut = decode144(mul(priceAverage, amountIn));\n    }\n\n    // --- Converter Utils ---\n    /**\n    * @notice Calculate the price of an amount of tokens using the converter price feed as well as the time elapsed between\n    *         the latest timestamp and the timestamp of the earliest observation in the window.\n    *         Used after the contract determines the amount of Uniswap pair denomination tokens for amountIn target tokens\n    * @param timeElapsed Time elapsed between now and the earliest observation in the window.\n    * @param amountIn Amount of denomination tokens to calculate the price for\n    **/\n    function converterComputeAmountOut(\n        uint256 timeElapsed,\n        uint256 amountIn\n    ) public view returns (uint256 amountOut) {\n        require(timeElapsed > 0, \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-time-elapsed\");\n        uint256 priceAverage = converterPriceCumulative / timeElapsed;\n        amountOut            = multiply(amountIn, priceAverage) / converterFeedScalingFactor;\n    }\n\n    // --- Core Logic ---\n    /**\n    * @notice Update the internal median price\n    **/\n    function updateResult(address feeReceiver) external {\n        require(address(relayer) != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-relayer\");\n        require(uniswapPair != address(0), \"UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-pair\");\n\n        // Get final fee receiver\n        address finalFeeReceiver = (feeReceiver == address(0)) ? msg.sender : feeReceiver;\n\n        // Update the converter's median price first\n        try converterFeed.updateResult(finalFeeReceiver) {}\n        catch (bytes memory converterRevertReason) {\n          emit FailedConverterFeedUpdate(converterRevertReason);\n        }\n\n        // Get the observation for the current period\n        uint256 timeElapsedSinceLatest = (uniswapObservations.length == 0) ?\n          subtract(now, lastUpdateTime) : subtract(now, uniswapObservations[uniswapObservations.length - 1].timestamp);\n        // We only want to commit updates once per period (i.e. windowSize / granularity)\n        if (uniswapObservations.length > 0) {\n          require(timeElapsedSinceLatest >= periodSize, \"UniswapConsecutiveSlotsPriceFeedMedianizer/not-enough-time-elapsed\");\n        }\n\n        // Update Uniswap pair\n        try IUniswapV2Pair(uniswapPair).sync() {}\n        catch (bytes memory uniswapRevertReason) {\n          emit FailedUniswapPairSync(uniswapRevertReason);\n        }\n\n        // Get the last update time used when calculating the reward\n        uint256 rewardCalculationLastUpdateTime = (uniswapObservations.length == 0) ? 0 : lastUpdateTime;\n\n        // Get Uniswap cumulative prices\n        (uint uniswapPrice0Cumulative, uint uniswapPrice1Cumulative,) = currentCumulativePrices(uniswapPair);\n\n        // Add new observations\n        updateObservations(timeElapsedSinceLatest, uniswapPrice0Cumulative, uniswapPrice1Cumulative);\n\n        // Calculate latest medianPrice\n        medianPrice    = getMedianPrice(uniswapPrice0Cumulative, uniswapPrice1Cumulative);\n        lastUpdateTime = now;\n        updates        = addition(updates, 1);\n\n        emit UpdateResult(medianPrice, lastUpdateTime);\n\n        // Reward caller\n        relayer.reimburseCaller(finalFeeReceiver);\n    }\n    /**\n    * @notice Push new observation data in the observation arrays\n    * @param timeElapsedSinceLatest Time elapsed between now and the earliest observation in the window\n    * @param uniswapPrice0Cumulative Latest cumulative price of the first token in a Uniswap pair\n    * @param uniswapPrice1Cumulative Latest cumulative price of the second tokens in a Uniswap pair\n    **/\n    function updateObservations(\n      uint256 timeElapsedSinceLatest,\n      uint256 uniswapPrice0Cumulative,\n      uint256 uniswapPrice1Cumulative\n    ) internal {\n        // Add converter feed observation\n        (uint256 priceFeedValue, bool hasValidValue) = converterFeed.getResultWithValidity();\n        require(hasValidValue, \"UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-converter-price-feed\");\n        uint256 newTimeAdjustedPrice = multiply(priceFeedValue, timeElapsedSinceLatest);\n\n        // Add converter observation\n        converterFeedObservations.push(ConverterFeedObservation(now, newTimeAdjustedPrice));\n        // Add Uniswap observation\n        uniswapObservations.push(UniswapObservation(now, uniswapPrice0Cumulative, uniswapPrice1Cumulative));\n\n        // Add the new update\n        converterPriceCumulative = addition(converterPriceCumulative, newTimeAdjustedPrice);\n\n        // Subtract the earliest update\n        if (updates >= granularity) {\n          (\n            ,\n            ConverterFeedObservation storage firstConverterFeedObservation\n          ) = getFirstObservationsInWindow();\n          converterPriceCumulative = subtract(converterPriceCumulative, firstConverterFeedObservation.timeAdjustedPrice);\n        }\n    }\n\n    // --- Getters ---\n    /**\n    * @notice Fetch the latest medianPrice or revert if is is null\n    **/\n    function read() external view returns (uint256) {\n        require(\n          both(both(both(medianPrice > 0, updates > granularity), timeElapsedSinceFirstObservation() <= maxWindowSize), validityFlag == 1),\n          \"UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-price-feed\"\n        );\n        return medianPrice;\n    }\n    /**\n    * @notice Fetch the latest medianPrice and whether it is null or not\n    **/\n    function getResultWithValidity() external view returns (uint256, bool) {\n        return (\n          medianPrice,\n          both(both(both(medianPrice > 0, updates > granularity), timeElapsedSinceFirstObservation() <= maxWindowSize), validityFlag == 1)\n        );\n    }\n}\n\nabstract contract StabilityFeeTreasuryLike {\n    function getAllowance(address) virtual external view returns (uint, uint);\n    function systemCoin() virtual external view returns (address);\n    function pullFunds(address, address, uint) virtual external;\n    function setTotalAllowance(address, uint256) external virtual;\n    function setPerBlockAllowance(address, uint256) external virtual;\n}\n\ncontract IncreasingTreasuryReimbursement is GebMath {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"IncreasingTreasuryReimbursement/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    // Starting reward for the fee receiver/keeper\n    uint256 public baseUpdateCallerReward;          // [wad]\n    // Max possible reward for the fee receiver/keeper\n    uint256 public maxUpdateCallerReward;           // [wad]\n    // Max delay taken into consideration when calculating the adjusted reward\n    uint256 public maxRewardIncreaseDelay;          // [seconds]\n    // Rate applied to baseUpdateCallerReward every extra second passed beyond a certain point (e.g next time when a specific function needs to be called)\n    uint256 public perSecondCallerRewardIncrease;   // [ray]\n\n    // SF treasury\n    StabilityFeeTreasuryLike  public treasury;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(\n      bytes32 parameter,\n      address addr\n    );\n    event ModifyParameters(\n      bytes32 parameter,\n      uint256 val\n    );\n    event FailRewardCaller(bytes revertReason, address feeReceiver, uint256 amount);\n\n    constructor(\n      address treasury_,\n      uint256 baseUpdateCallerReward_,\n      uint256 maxUpdateCallerReward_,\n      uint256 perSecondCallerRewardIncrease_\n    ) public {\n        if (address(treasury_) != address(0)) {\n          require(StabilityFeeTreasuryLike(treasury_).systemCoin() != address(0), \"IncreasingTreasuryReimbursement/treasury-coin-not-set\");\n        }\n        require(maxUpdateCallerReward_ >= baseUpdateCallerReward_, \"IncreasingTreasuryReimbursement/invalid-max-caller-reward\");\n        require(perSecondCallerRewardIncrease_ >= RAY, \"IncreasingTreasuryReimbursement/invalid-per-second-reward-increase\");\n        authorizedAccounts[msg.sender] = 1;\n\n        treasury                        = StabilityFeeTreasuryLike(treasury_);\n        baseUpdateCallerReward          = baseUpdateCallerReward_;\n        maxUpdateCallerReward           = maxUpdateCallerReward_;\n        perSecondCallerRewardIncrease   = perSecondCallerRewardIncrease_;\n        maxRewardIncreaseDelay          = uint(-1);\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"treasury\", treasury_);\n        emit ModifyParameters(\"baseUpdateCallerReward\", baseUpdateCallerReward);\n        emit ModifyParameters(\"maxUpdateCallerReward\", maxUpdateCallerReward);\n        emit ModifyParameters(\"perSecondCallerRewardIncrease\", perSecondCallerRewardIncrease);\n    }\n\n    // --- Boolean Logic ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Treasury ---\n    /**\n    * @notice This returns the stability fee treasury allowance for this contract by taking the minimum between the per block and the total allowances\n    **/\n    function treasuryAllowance() public view returns (uint256) {\n        (uint total, uint perBlock) = treasury.getAllowance(address(this));\n        return minimum(total, perBlock);\n    }\n    /*\n    * @notice Get the SF reward that can be sent to a function caller right now\n    * @param timeOfLastUpdate The last time when the function that the treasury pays for has been updated\n    * @param defaultDelayBetweenCalls Enforced delay between calls to the function for which the treasury reimburses callers\n    */\n    function getCallerReward(uint256 timeOfLastUpdate, uint256 defaultDelayBetweenCalls) public view returns (uint256) {\n        // If the rewards are null or if the time of the last update is in the future or present, return 0\n        bool nullRewards = (baseUpdateCallerReward == 0 && maxUpdateCallerReward == 0);\n        if (either(timeOfLastUpdate >= now, nullRewards)) return 0;\n\n        // If the time elapsed is smaller than defaultDelayBetweenCalls or if the base reward is zero, return 0\n        uint256 timeElapsed = (timeOfLastUpdate == 0) ? defaultDelayBetweenCalls : subtract(now, timeOfLastUpdate);\n        if (either(timeElapsed < defaultDelayBetweenCalls, baseUpdateCallerReward == 0)) {\n            return 0;\n        }\n\n        // If too much time elapsed, return the max reward\n        uint256 adjustedTime      = subtract(timeElapsed, defaultDelayBetweenCalls);\n        uint256 maxPossibleReward = minimum(maxUpdateCallerReward, treasuryAllowance() / RAY);\n        if (adjustedTime > maxRewardIncreaseDelay) {\n            return maxPossibleReward;\n        }\n\n        // Calculate the reward\n        uint256 calculatedReward = baseUpdateCallerReward;\n        if (adjustedTime > 0) {\n            calculatedReward = rmultiply(rpower(perSecondCallerRewardIncrease, adjustedTime, RAY), calculatedReward);\n        }\n\n        // If the reward is higher than max, set it to max\n        if (calculatedReward > maxPossibleReward) {\n            calculatedReward = maxPossibleReward;\n        }\n        return calculatedReward;\n    }\n    /**\n    * @notice Send a stability fee reward to an address\n    * @param proposedFeeReceiver The SF receiver\n    * @param reward The system coin amount to send\n    **/\n    function rewardCaller(address proposedFeeReceiver, uint256 reward) internal {\n        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, return\n        if (address(treasury) == proposedFeeReceiver) return;\n        if (either(address(treasury) == address(0), reward == 0)) return;\n\n        // Determine the actual receiver and send funds\n        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\n        try treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), reward) {}\n        catch(bytes memory revertReason) {\n            emit FailRewardCaller(revertReason, finalFeeReceiver, reward);\n        }\n    }\n}\n\n\ncontract IncreasingRewardRelayer is IncreasingTreasuryReimbursement {\n    // --- Variables ---\n    // Address that can request funds\n    address public refundRequestor;\n    // Timestamp of the last reimbursement\n    uint256 public lastReimburseTime;       // [timestamp]\n    // Enforced gap between reimbursements\n    uint256 public reimburseDelay;          // [seconds]\n\n    constructor(\n      address refundRequestor_,\n      address treasury_,\n      uint256 baseUpdateCallerReward_,\n      uint256 maxUpdateCallerReward_,\n      uint256 perSecondCallerRewardIncrease_,\n      uint256 reimburseDelay_\n    ) public IncreasingTreasuryReimbursement(treasury_, baseUpdateCallerReward_, maxUpdateCallerReward_, perSecondCallerRewardIncrease_) {\n        require(refundRequestor_ != address(0), \"IncreasingRewardRelayer/null-refund-requestor\");\n        require(reimburseDelay_ > 0, \"IncreasingRewardRelayer/null-reimburse-delay\");\n\n        refundRequestor = refundRequestor_;\n        reimburseDelay  = reimburseDelay_;\n\n        emit ModifyParameters(\"refundRequestor\", refundRequestor);\n        emit ModifyParameters(\"reimburseDelay\", reimburseDelay);\n    }\n\n    // --- Administration ---\n    /*\n    * @notice Change the addresses of contracts that this wrapper is connected to\n    * @param parameter The contract whose address is changed\n    * @param addr The new contract address\n    */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        require(addr != address(0), \"IncreasingRewardRelayer/null-addr\");\n        if (parameter == \"treasury\") {\n          require(StabilityFeeTreasuryLike(addr).systemCoin() != address(0), \"IncreasingRewardRelayer/treasury-coin-not-set\");\n          treasury = StabilityFeeTreasuryLike(addr);\n        } else if (parameter == \"refundRequestor\") {\n          refundRequestor = addr;\n        }\n        else revert(\"IncreasingRewardRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(\n          parameter,\n          addr\n        );\n    }\n    /*\n    * @notify Modify a uint256 parameter\n    * @param parameter The parameter name\n    * @param val The new parameter value\n    */\n    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n        if (parameter == \"baseUpdateCallerReward\") {\n          require(val <= maxUpdateCallerReward, \"IncreasingRewardRelayer/invalid-base-caller-reward\");\n          baseUpdateCallerReward = val;\n        }\n        else if (parameter == \"maxUpdateCallerReward\") {\n          require(val >= baseUpdateCallerReward, \"IncreasingRewardRelayer/invalid-max-caller-reward\");\n          maxUpdateCallerReward = val;\n        }\n        else if (parameter == \"perSecondCallerRewardIncrease\") {\n          require(val >= RAY, \"IncreasingRewardRelayer/invalid-caller-reward-increase\");\n          perSecondCallerRewardIncrease = val;\n        }\n        else if (parameter == \"maxRewardIncreaseDelay\") {\n          require(val > 0, \"IncreasingRewardRelayer/invalid-max-increase-delay\");\n          maxRewardIncreaseDelay = val;\n        }\n        else if (parameter == \"reimburseDelay\") {\n          require(val > 0, \"IncreasingRewardRelayer/invalid-reimburse-delay\");\n          reimburseDelay = val;\n        }\n        else revert(\"IncreasingRewardRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(\n          parameter,\n          val\n        );\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notice Send a stability fee reward to an address proposed by the refundRequestor\n    * @param feeReceiver Address that will receive the SF reward\n    */\n    function reimburseCaller(address feeReceiver) external {\n        // Perform checks\n        require(refundRequestor == msg.sender, \"IncreasingRewardRelayer/invalid-caller\");\n        require(feeReceiver != address(0), \"IncreasingRewardRelayer/null-fee-receiver\");\n        require(feeReceiver != refundRequestor, \"IncreasingRewardRelayer/requestor-cannot-receive-fees\");\n        // Check delay between calls\n        require(either(subtract(now, lastReimburseTime) >= reimburseDelay, lastReimburseTime == 0), \"IncreasingRewardRelayer/wait-more\");\n        // Get the caller's reward\n        uint256 callerReward = getCallerReward(lastReimburseTime, reimburseDelay);\n        // Store the timestamp of the reimbursement\n        lastReimburseTime = now;\n        // Pay the fee receiver\n        rewardCaller(feeReceiver, callerReward);\n    }\n}\n\nabstract contract OldTwapLike is UniswapConsecutiveSlotsPriceFeedMedianizer {\n    function treasury() public virtual returns (address);\n}\n\n// @notice Proposal to deploy and setup a new Uniswap TWAP\n// @notice The contract will be deployed/setup, but not yet connected to the system (to allow for testing)\n// Missing steps:\n// - Connect to the RateSetter\ncontract DeployUniswapTWAP {\n    // --- Variables ---\n    uint256 public constant RAY = 10**27;\n\n    function execute(address oldTwapAddress) public returns (address, address) {\n        OldTwapLike oldTwap               = OldTwapLike(oldTwapAddress);\n        StabilityFeeTreasuryLike treasury = StabilityFeeTreasuryLike(oldTwap.treasury());\n\n        // deploy new TWAP\n        UniswapConsecutiveSlotsPriceFeedMedianizer newTwap = new UniswapConsecutiveSlotsPriceFeedMedianizer(\n            address(oldTwap.converterFeed()),\n            address(oldTwap.uniswapFactory()),\n            oldTwap.defaultAmountIn(),\n            64800, // windowSize\n            oldTwap.converterFeedScalingFactor(),\n            86400, // maxWindowSize\n            3      // granularity\n        );\n\n        newTwap.modifyParameters(\"targetToken\", oldTwap.targetToken());\n        newTwap.modifyParameters(\"denominationToken\", oldTwap.denominationToken());\n\n        // deploy increasing reward relayer\n        IncreasingRewardRelayer rewardRelayer = new IncreasingRewardRelayer(\n            address(newTwap), // refundRequestor\n            address(oldTwap.treasury()),\n            0.0001 ether,     // baseUpdateCallerReward\n            0.0001 ether,     // maxUpdateCallerReward\n            1 * RAY,          // perSecondCallerRewardIncrease,\n            21600             // reimburseDelay\n        );\n\n        rewardRelayer.modifyParameters(\"maxRewardIncreaseDelay\", 10800);\n\n        // setting relayer in the TWAP\n        newTwap.modifyParameters(\"relayer\", address(rewardRelayer));\n\n        // Setup treasury allowance\n        treasury.setTotalAllowance(address(oldTwap), 0);\n        treasury.setPerBlockAllowance(address(oldTwap), 0);\n\n        treasury.setTotalAllowance(address(rewardRelayer), uint(-1));\n        treasury.setPerBlockAllowance(address(rewardRelayer), 0.0001 ether * RAY);\n\n        return (address(newTwap), address(rewardRelayer));\n    }\n}\n"
    }
  }
}