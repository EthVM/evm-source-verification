{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/AuctionHouseLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./AuctionHouseV1.sol\";\n\nimport \"./CryptographIndexLogicV1.sol\";\nimport \"./TheCryptographLogicV1.sol\";\nimport \"./SingleAuctionLogicV1.sol\";\nimport \"./CryptographFactoryLogicV1.sol\";\nimport \"./MintingAuctionLogicV1.sol\";\nimport \"./ERC2665LogicV1.sol\";\nimport \"./CryptographKYCLogicV1.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title Auction House Logic Code\n/// @notice The main contract used by collectors to Bid on and Trade cyptographs. Abstract this smart contract on the proxy address for interaction.\ncontract AuctionHouseLogicV1 is VCProxyData, AuctionHouseHeaderV1, AuctionHouseStoragePublicV1 {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall hence its memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that require to be called only by the Cryptograph Factory\n    modifier restrictedToFactory(){\n        require((msg.sender == factory), \"Only the Cryptograph Factory smart contract can call this function\");\n        _;\n    }\n\n    /// @notice Generic catch-all function that accept payments to prevent accidental Eth burn.\n    /// @dev A receive function is NOT necessary. Your compiler doesn't know better. \n    fallback() external payable {\n        pendingWithdrawals[msg.sender] += msg.value;\n        emit Deposit(msg.value,msg.sender, msg.sender, msg.sender);\n    }\n\n    /// @notice You now have to pay real money to supress compiler warnings\n    /// @dev Completely unecessary trashcode that will always get intercepted by the proxy first\n    receive() external payable{\n        pendingWithdrawals[msg.sender] += msg.value;\n        emit Deposit(msg.value,msg.sender, msg.sender, msg.sender);\n    }\n\n    /// @notice Init function of the auction house\n    /// @dev Callable only once after deployment\n    /// @param _factory The address of the CryptographFactory Instance\n    /// @param _index The address of the CryptographIndex Instance\n    /// @param _ERC2665Lieutenant The address of the ERC2665 Instance\n    /// @param _kycContract The address of the KYC contract Instance\n    function init(address _factory, address _index, address _ERC2665Lieutenant, address _kycContract) external {\n        require((initialized == false), \"The Auction House has already been initialized\");\n        require(_factory != address(0), \"_factory should be != 0x0\");\n        require(_index != address(0), \"_index should be != 0x0\");\n        require(_ERC2665Lieutenant != address(0), \"_ERC2665Lieutenant should be != 0x0\");\n        require(_kycContract != address(0), \"_kycContract should be != 0x0\");\n        \n        initialized = true;\n        factory = _factory;\n        index = _index;\n        ERC2665Lieutenant = _ERC2665Lieutenant;\n        kycContract = _kycContract;\n    }\n\n    /// @notice Send eth and add it to a withdrawal account.\n    /// @dev This is how single auctions smart contracts deposit money\n    /// @param _account The address of the account to credit with the payable amount\n    /// @param _contributor The address of the user wallet from which the money is from\n    function addFundsFor(address _account, address _contributor) external payable{\n        pendingWithdrawals[_account] += msg.value;\n        emit Deposit(msg.value, _account, _contributor, msg.sender);\n    }\n\n    /// @notice Withdraw all the eth from msg.sender account\n    /// @dev Only way an external account can take away money from the cryptograph ecosystem\n    function withdraw() external {\n\n        //Calculating the withdrawn amount\n        uint256 amount = pendingWithdrawals[msg.sender];\n\n        //Emptying the account\n        pendingWithdrawals[msg.sender] = 0;\n\n        //Firing the event\n        emit UserWithdrawal(amount, msg.sender);\n\n        //Finally transferring the money\n        msg.sender.transfer(amount);\n    }\n\n    /// @notice Place a bid to own a cryptograph\n    /// @dev Calling this function is the only way to eventually gain ownership of a cryptograph\n    /// @param _cryptographIssue The serial of the Cryptograph you want to bid on\n    /// @param _isOfficial True if bidding on an official cryptograph, false if bidding on a community cryptograph\n    /// @param _editionSerial If you are bidding on an edition, specify it's specific edition issue # here\n    /// @param _newBidAmount The amount of money you want to bid\n    /// @param _previousStandingBidAmount Protection against ordonancement attacks. Please indicate what value is currently visible for yourCryptographAuction.highestBidder().\n    function bid(\n        uint256 _cryptographIssue,\n        bool _isOfficial,\n        uint256 _editionSerial,\n        uint256 _newBidAmount,\n        uint256 _previousStandingBidAmount\n    ) external payable{\n\n        //KYC\n        require(CryptographKYCLogicV1(kycContract).checkKyc(msg.sender, _newBidAmount),\n            \"Bid above a specific amount requires the bidder to be KYCed\");\n\n        //Grabbing the auction\n        SingleAuctionLogicV1 _auc = SingleAuctionLogicV1(\n            TheCryptographLogicV1(\n                CryptographIndexLogicV1(index).getCryptograph(_cryptographIssue, _isOfficial, _editionSerial)\n            ).myAuction()\n        );\n\n        //The first check being made is that the current highest standing bid match the announced bid the user is bidding on top of\n        require(_auc.currentBids(_auc.highestBidder()) == _previousStandingBidAmount,\n            \"bid not accepted: current highest standing bid is different than the one specified\");\n\n        //Credit the full amount paid to the msg.sender account\n        pendingWithdrawals[msg.sender] += msg.value;\n\n        //Check that the sender has enough money in his account to bid\n        require(pendingWithdrawals[msg.sender] + _auc.currentBids(msg.sender) >= _newBidAmount, \"bid not accepted: Not enough ether was sent\");\n\n        uint256 toSend = _newBidAmount - _auc.currentBids(msg.sender);\n\n        //Tapping the money from the account\n        pendingWithdrawals[msg.sender] -= toSend;\n\n        //Emiting the bidding event first (before the deposit events from payouts start triggering)\n        emit UserBid(address(_auc), _newBidAmount, msg.sender);\n\n        //Bidding\n        _auc.bid{value: toSend }(_newBidAmount, msg.sender);\n    }\n\n    /// @notice Return the highest bid placed on a cryptograph\n    /// @dev Easy way to optain the highest current bid for a cryptograph you want to bid on. Can be nested within bid() for unsafe bids that will always go through.\n    /// @param _cryptographIssue The serial of the Cryptograph you want to peek highest bid on\n    /// @param _isOfficial True if peeking on an official cryptograph, false if peeking on a community cryptograph\n    /// @param _editionSerial If you are peeking on an edition, specify it's specific edition issue # here\n    function getHighestBid(uint256 _cryptographIssue, bool _isOfficial, uint256 _editionSerial) external view returns(uint256){\n        SingleAuctionLogicV1 _auc = SingleAuctionLogicV1(\n            TheCryptographLogicV1(\n                CryptographIndexLogicV1(index).getCryptograph(_cryptographIssue, _isOfficial, _editionSerial)\n            ).myAuction()\n        );\n        return _auc.currentBids(_auc.highestBidder());\n    }\n\n    /// @notice Cancel your bid on a Cryptograph. WARNING : if highest bidder, you might only get a fraction of your money back\n    /// @dev During the initial auction or once a sale has been accepted, a highest bidder can't cancel his bid.\n    /// @param _cryptographIssue The serial of the Cryptograph you want to cancel bid on\n    /// @param _isOfficial True if cancelling bid on an official cryptograph, false if cancelling bid on a community cryptograph\n    /// @param _editionSerial If cancelling bid on an edition, specify it's specific edition issue # here\n    function cancelBid(uint256 _cryptographIssue, bool _isOfficial, uint256 _editionSerial) external{\n\n        //Grabbing the auction\n        SingleAuctionLogicV1 _auc = SingleAuctionLogicV1(\n            TheCryptographLogicV1(\n                CryptographIndexLogicV1(index).getCryptograph(_cryptographIssue, _isOfficial, _editionSerial)\n            ).myAuction()\n        );\n\n        //Emitting the cancelBid event before deposit event is triggered\n        emit UserCancelledBid(address(_auc), msg.sender);\n\n        //Actually cancel the bid\n        _auc.cancelBid(msg.sender);\n    }\n\n    /// @notice Win a cryptograph for the highest bidder\n    /// @dev Callable by anyone, but should be called by PA for automatisation.\n    /// @param _cryptographIssue The issue # of the Cryptograph you want to claim\n    /// @param _isOfficial True if claiming an official cryptograph, false if claiming a community cryptograph\n    /// @param _editionSerial If claiming an edition, specify it's specific edition issue # here\n    function win(uint256 _cryptographIssue, bool _isOfficial, uint256 _editionSerial) external{\n\n        //Grabbing the auction\n        TheCryptographLogicV1 _cry = TheCryptographLogicV1(\n                CryptographIndexLogicV1(index).getCryptograph(_cryptographIssue, _isOfficial, _editionSerial)\n            );\n\n        SingleAuctionLogicV1 _auc = SingleAuctionLogicV1(_cry.myAuction());\n\n        //Emitting the Win event before other events are triggered\n        emit UserWin(address(_auc), _auc.currentBids(_auc.highestBidder()), _auc.highestBidder());\n\n        //Update the ERC2665\n        ERC2665LogicV1(ERC2665Lieutenant).transferACryptograph(_cry.owner(), _auc.highestBidder(), address(_cry), _auc.currentBids(_auc.highestBidder()));\n\n        //Actually Win the auction and claim the cryptograph\n        if(!(_auc.win(_auc.highestBidder()) == 0)){\n            CryptographFactoryLogicV1(factory).mintGGBMA(_cryptographIssue, _isOfficial, _auc.highestBidder()); //Minting in the case of GGBMA\n            MintingAuctionLogicV1(address(_auc)).distributeBid(_auc.highestBidder()); //Distributing the money\n        }\n    }\n\n    /// @notice Set a selling price for a cryptograph if you are the owner. Set to 0 if not for sale, a sale is triggered if the selling price is leq than current highest bid.\n    /// @dev Only callable by the Cryptograph owner\n    /// @param _cryptographIssue The issue of the Cryptograph you want to sell\n    /// @param _isOfficial True if selling an official cryptograph, false if selling a community cryptograph\n    /// @param _editionSerial If selling an edition, specify its specific edition issue # here\n    /// @param _newSellingPrice the new selling price you want to set\n    function setSellingPrice(uint256 _cryptographIssue, bool _isOfficial, uint256 _editionSerial, uint256 _newSellingPrice) external{\n\n        //Grabbing the auction\n        SingleAuctionLogicV1 _auc = SingleAuctionLogicV1(\n            TheCryptographLogicV1(\n                CryptographIndexLogicV1(index).getCryptograph(_cryptographIssue, _isOfficial, _editionSerial)\n            ).myAuction()\n        );\n\n        //Emitting the UserSell event before other events are triggered\n        emit UserSellingPriceAdjust(address(_auc), _newSellingPrice);\n\n        //Actually adjust the selling price\n        _auc.setSellingPrice(msg.sender, _newSellingPrice);\n    }\n\n    /// @notice Call an ERC2665 transfer on a cryptograph\n    /// @dev Only callable by the ERC2665 contract\n    /// @param _cryptograph The address of the cryptograph getting transferred\n    /// @param _contributor The address of the transfer fee payer\n    /// @param _to The address of the new cryptograph owner\n    function transferERC2665(address _cryptograph, address _contributor, address _to) external payable{\n        require(msg.sender == ERC2665Lieutenant, \"Only the ERC2665Lieutenant can call this function\");\n        SingleAuctionLogicV1(TheCryptographLogicV1(_cryptograph).myAuction()).transferERC2665{value:msg.value}(_contributor, _to);\n    }\n\n    /// @notice Call an ERC2665 Approve on a cryptograph\n    /// @dev Only callable by the ERC2665 contract\n    /// @param _cryptograph The address of the cryptograph getting transferred\n    /// @param _contributor The address of the transfer fee payer\n    /// @param _approvedAddress The address of the potential owner\n    function approveERC2665(address _cryptograph, address _contributor, address _approvedAddress) external payable{\n        require(msg.sender == ERC2665Lieutenant, \"Only the ERC2665Lieutenant can call this function\");\n        SingleAuctionLogicV1(TheCryptographLogicV1(_cryptograph).myAuction()).approveERC2665{value:msg.value}(_contributor, _approvedAddress);\n    }\n\n}\n\n"},"browser/AuctionHouseV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Auction House Header\n/// @notice Contain all the events emitted by the Auction House\ncontract AuctionHouseHeaderV1 {\n\n    // Deposit: Event emitted whenever money is made available for withdrawal in the Auction House\n    // amount: Amount of money being deposited\n    // beneficiary: Account that will be able to withdraw the money\n    // contributor: Which user wallet initially contributed the received money\n    // origin: Which smart contract sent the money\n    event Deposit(uint256 indexed amount, address indexed beneficiary, address indexed contributor, address origin);\n\n    // Withdrawal: event emitted whenever a user withdraw his Eth on the auction house smart contract\n    // amount: total amount of money withdrawn\n    // account: address of user withdrawing his money\n    event UserWithdrawal(uint256 indexed amount, address indexed account);\n\n    // Bid: event emitted whenever a user submit a new bid to an auction\n    // auction: the address of the auction\n    // bidValue: the eth value of the new standing bid\n    // bidder: the address of the user who just bid\n    event UserBid(address indexed auction, uint256 indexed bidValue, address indexed bidder);\n\n    // CancelBid: event emitted whenever a user manually cancel a bid\n    // auction: the address of the auction\n    // bidder: the address of the user who just cancelled his bid\n    event UserCancelledBid(address indexed auction, address indexed bidder);\n\n    // Win: event emitted whenever a user win an auction\n    // auction: the address of the auction\n    // bidValue: the eth value of the winning bid\n    // bidder: the address of the user who just won the auction his bid\n    event UserWin(address indexed auction, uint256 indexed bidValue, address indexed bidder);\n\n    // UserSell: event emitted whenever a user trigger a sale at an auction\n    // auction: the address of the auction\n    event UserSell(address indexed auction);\n\n    // UserSellingPriceAdjust: event emitted whenever a user adjust the selling price of an auction\n    // auction: the address of the auction\n    // value : the new adjusted price. 0 for disabled\n    event UserSellingPriceAdjust(address indexed auction, uint256 indexed value);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Auction House Storage Internal\n/// @notice Contain all the storage of the auction house declared in a way that does not generate getters for Proxy use\ncontract AuctionHouseStorageInternalV1 {\n    bool internal initialized; //Bool to check if the index have been initialized\n    address internal factory; //The factory smart contract (proxy) that will publish the cryptographs\n    address internal index; //The index smart contract that maps cryptographs and their auctions\n    mapping (address => uint) internal pendingWithdrawals;  //How much money each user owns on the smart contract\n\n    address internal ERC2665Lieutenant;\n    address internal kycContract;\n}\n\n\n/// @author Guillaume Gonnaud\n/// @title Auction House Storage Public\n/// @notice Contain all the storage of the auction house declared in a way that generates getters for Logic Code use\ncontract AuctionHouseStoragePublicV1 {\n    bool public initialized; //Bool to check if the index have been initialized\n    address public factory; //The factory smart contract (proxy) that will publish the cryptographs\n    address public index; //The index smart contract that maps cryptographs and their auctions\n    mapping (address => uint) public pendingWithdrawals;  //How much money each user owns on the smart contract\n\n    address public ERC2665Lieutenant;\n    address public kycContract;\n\n}"},"browser/BidLink.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title BidLink Ordered Data Structure\n/// @notice Classical double linked array data structure that allow us to not have to sort() stuff at the cost of instancing more + proper maintenance\ncontract BidLink{\n\n    address public mintingAuction; //The Minting auction the BidLink is associated with\n    address public bidder; //Our bidder\n    uint256 public bidAmount; //How big is our bid\n    address public above;  //BidLink with a bigger bid\n    address public below;  //BidLink with a smaller bid\n\n    modifier restrictedToAuction(){\n        require((msg.sender == mintingAuction), \"Only the auction contract can call this function\");\n        _;\n    }\n\n    constructor (address _bidder, uint256 _bidAmount) public\n    {\n        mintingAuction = msg.sender;\n        bidder = _bidder;\n        bidAmount = _bidAmount;\n    }\n\n    //Function used to reset and reuse a link rather than having to reinstance its bytecode\n    function reset(address _bidder, uint256 _bidAmount) external restrictedToAuction(){\n        delete above;\n        delete below;\n        bidder = _bidder;\n        bidAmount = _bidAmount;\n    }\n\n    function setBidAmount(uint256 _bidAmount) external restrictedToAuction(){\n        bidAmount = _bidAmount;\n    }\n\n    function setAbove(address _above) external restrictedToAuction(){\n        above = _above;\n    }\n\n    function setBelow(address _below) external restrictedToAuction(){\n        below = _below;\n    }\n\n}\n"},"browser/BidLinkSimple.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title BidLink Ordered Data Structure (no bidAmount)\n/// @notice Classical double linked array data structure that allow us to not have to sort() stuff at the cost of instancing more + proper maintenance\ncontract BidLinkSimple{\n\n    address public auction; //The Minting auction the BidLink is associated with\n    address public bidder; //Our bidder\n    address public above;  //BidLink with a bigger bid\n    address public below;  //BidLink with a smaller bid\n\n    modifier restrictedToAuction(){\n        require((msg.sender == auction), \"Only the auction contract can call this function\");\n        _;\n    }\n\n    constructor (address _bidder) public\n    {\n        auction = msg.sender;\n        bidder = _bidder;\n    }\n\n    //Function used to reset and reuse a link rather than having to reinstance its bytecode\n    function reset(address _bidder) external restrictedToAuction(){\n        delete above;\n        delete below;\n        bidder = _bidder;\n    }\n\n    function setAbove(address _above) external restrictedToAuction(){\n        above = _above;\n    }\n\n    function setBelow(address _below) external restrictedToAuction(){\n        below = _below;\n    }\n\n}\n"},"browser/CryptographFactoryLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./CryptographFactoryV1.sol\";\nimport \"./TheCryptographProxiedV1.sol\";\nimport \"./TheCryptographLogicV1.sol\";\nimport \"./SingleAuctionProxiedV1.sol\";\nimport \"./SingleAuctionLogicV1.sol\";\nimport \"./CryptographIndexLogicV1.sol\";\nimport \"./AuctionHouseLogicV1.sol\";\nimport \"./MintingAuctionLogicV1.sol\";\nimport \"./MintingAuctionProxiedV1.sol\";\nimport \"./CryptographInitiator.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title Cryptograph Factory Logic Code\n/// @notice The main contract used by publisher to release and edit cryptographs. Cast this smart contract on the proxy address for interaction.\ncontract CryptographFactoryLogicV1 is VCProxyData, CryptographFactoryHeaderV1, CryptographFactoryStoragePublicV1 {\n\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    /// @notice Init function of the Cryptograph Factory\n    /// @dev Callable only once after deployment\n    /// @param _officialPublisher The address that perpetual altruism will be using consistently through all deployments\n    /// @param _targetVC The address of the proxied Version Control\n    /// @param _targetAuctionHouse The address of the proxied Auction House\n    /// @param _targetIndex The address of the proxied Index\n    /// @param _targetCryLogicVersion The code index of TheCryptographLogicV1 in the version control\n    /// @param _targetAuctionLogicVersion  The code index of SingleAuctionLogicV1 in the version control\n    /// @param _targetAuctionBidLogicVersion  The code index of SingleAuctionBidLogicV1 in the version control\n    /// @param _targetMintingAuctionLogicVersion  The code index of MintingAuctionLogicV1 in the version control\n    function init(\n        address _officialPublisher,\n        address _targetVC,\n        address _targetAuctionHouse,\n        address _targetIndex,\n        uint256 _targetCryLogicVersion,\n        uint256 _targetAuctionLogicVersion,\n        uint256 _targetAuctionBidLogicVersion,\n        uint256 _targetMintingAuctionLogicVersion\n    ) external {\n\n        require(!initialized, \"The Cryptograph Factory has already been initialized\");\n        initialized = true;\n        officialPublisher = _officialPublisher;\n        targetVC = _targetVC;\n        targetAuctionHouse = _targetAuctionHouse;\n        targetIndex = _targetIndex;\n        targetCryLogicVersion = _targetCryLogicVersion;\n        targetAuctionLogicVersion = _targetAuctionLogicVersion;\n        targetAuctionBidLogicVersion = _targetAuctionBidLogicVersion;\n        targetMintingAuctionLogicVersion = _targetMintingAuctionLogicVersion;\n        communityMintable = false;\n    }\n\n    /// @notice Create a Cryptograph\n    /// @dev emit CryptographCreated event. Official cryptographs need their auction locked-in afterwards.\n    /// @param _cryInitiator The cryptograph Initiator object\n    /// @return The issue number of the newly created Cryptograph\n    function createCryptograph (address _cryInitiator) external returns (uint256){\n\n        bool offi = msg.sender == officialPublisher;\n\n        require(communityMintable || offi, \"Community Cryptographs can't be created at the moment\");\n\n        //Instance the Cryptograph\n        address newCryptographProxied;\n        address newSingleAuctionProxiedV1;\n        (newCryptographProxied, newSingleAuctionProxiedV1) = instanceCryptograph(_cryInitiator, offi);\n\n        //Book the Cryptograph into the index and get the issue #, then init\n        uint256 _issue;\n        if(offi){\n            //Inserting an official Cryptograph\n            _issue = CryptographIndexLogicV1(targetIndex).insertACryptograph(newCryptographProxied);\n        } else {\n             //Inserting a community Cryptograph\n            _issue = CryptographIndexLogicV1(targetIndex).insertACommunityCryptograph(newCryptographProxied);\n        }\n\n        TheCryptographLogicV1(newCryptographProxied).initCry(\n                _issue, 0, offi, newSingleAuctionProxiedV1, _cryInitiator, address(0)\n            );\n\n        //Setting hash and url\n        TheCryptographLogicV1(newCryptographProxied).setMediaHash(\n            CryptographInitiator(_cryInitiator).mediaHash()\n        );\n        TheCryptographLogicV1(newCryptographProxied).setMediaUrl(\n            CryptographInitiator(_cryInitiator).mediaUrl()\n        );\n\n        emit CryptographCreated(_issue, newCryptographProxied, offi);\n        return _issue;\n    }\n\n    /// @notice Create an edition\n    /// @dev emit CryptographEditionAdded event\n    /// @param _editionSize How many cryptographs can be minted in this edition\n    /// @return The Cryptograph issue # of the newly created Cryptograph Edition\n    function createEdition(uint256 _editionSize) external returns (uint256){\n\n        uint256 _issue;\n\n        bool offi = msg.sender == officialPublisher;\n\n        require(communityMintable || offi, \"community Cryptographs can't be created at the moment\");\n\n        //Book the edition into the index and get the issue #\n        if(offi){\n            //Inserting an official Cryptograph\n            _issue = CryptographIndexLogicV1(targetIndex).createAnEdition(msg.sender, _editionSize);\n        } else {\n            //Inserting a community Cryptograph\n            _issue = CryptographIndexLogicV1(targetIndex).createACommunityEdition(msg.sender, _editionSize);\n        }\n        emit CryptographEditionAdded(_issue, _editionSize, offi);\n        return _issue;\n    }\n\n    /// @notice Mint a Cryptograph that is part of an edition.\n    /// @dev emit CryptographEditionMinted event. Only callable by the original edition creator. Official cryptographs need their auction locked-in afterwards.\n    /// @param _cryInitiator The cryptograph Initiator for the edition\n    /// @return The serial number of the newly created Cryptograph edition member\n    function mintEdition (address _cryInitiator) external returns (uint256){\n\n        bool offi = msg.sender == officialPublisher;\n\n        uint256 _issue = CryptographInitiator(_cryInitiator).cryptographIssue();\n\n        //Check that we are properly minting an Edition and not a GGBMA/Unique cryptograph\n        require(\n            CryptographIndexLogicV1(targetIndex).getCryptograph(_issue, offi, 0) == address(0x0),\n            \"Can't manually mint a GGBMA\");\n\n        //Instance the Cryptograph\n        address newCryptographProxied;\n        address newSingleAuctionProxiedV1;\n        (newCryptographProxied, newSingleAuctionProxiedV1) = instanceCryptograph(_cryInitiator, offi);\n\n        //Book the Cryptograph into the index and get the serial #\n        uint256 _editionSerial;\n        _editionSerial = CryptographIndexLogicV1(targetIndex).mintAnEdition(\n            msg.sender,\n            _issue,\n            offi,\n            address(newCryptographProxied)\n        );\n\n        //Init the Cryptograph\n        TheCryptographLogicV1(address(newCryptographProxied)).initCry(\n            _issue, _editionSerial, offi, address(newSingleAuctionProxiedV1), _cryInitiator, address(0)\n        );\n        emit CryptographEditionMinted(\n            _issue,\n            _editionSerial,\n            newCryptographProxied,\n            offi\n        );\n\n        //Setting hash and url\n        TheCryptographLogicV1(newCryptographProxied).setMediaHash(\n            CryptographInitiator(_cryInitiator).mediaHash()\n        );\n        TheCryptographLogicV1(newCryptographProxied).setMediaUrl(\n            CryptographInitiator(_cryInitiator).mediaUrl()\n        );\n\n        return _editionSerial;\n    }\n\n\n    /// @notice ReInitialize an already created Cryptograph\n    /// @dev This permit to release nameless cryptograph at a specific serial #, only to name them properly later (up until the auction start)\n    /// If auction started but is not locked, use reinitAuction.\n    /// @param _CryptographToEdit The address of the cryptograph you want to re-init\n    /// @param _cryInitiator The Cryptograph initator with the name to be changed\n    function reInitCryptograph(address _CryptographToEdit, address _cryInitiator)  external {\n        require(msg.sender == officialPublisher, \"Only official Cryptographs can be edited after serial # reservation\");\n        TheCryptographLogicV1(_CryptographToEdit).initCry(\n            TheCryptographLogicV1(_CryptographToEdit).issue(),\n            TheCryptographLogicV1(_CryptographToEdit).serial(),\n            true,\n            TheCryptographLogicV1(_CryptographToEdit).myAuction(),\n            _cryInitiator,\n            address(0)\n        );\n    }\n\n\n    /// @notice ReInitialize an already created Auction. Not possible after locking.\n    /// @dev Auction re-initializable until locked. No bid accepted if unlocked.\n    /// @param _auctionToEdit The address of the auction you want to edit\n    /// @param _cryInitiator The desired unix (seconds) timestamp at which the initial auction should start\n    /// @param _lock Shall further re-initilization be allowed ?\n    function reInitAuction(\n        address _auctionToEdit,\n        address _cryInitiator,\n        bool _lock\n    ) external {\n        require(msg.sender == officialPublisher, \"Only PA can reinit auctions\");\n\n        //Call init\n        SingleAuctionLogicV1(_auctionToEdit).initAuction(\n            SingleAuctionLogicV1(_auctionToEdit).myCryptograph(),\n            _cryInitiator,\n            _lock\n        );\n    }\n\n    /// @notice Lock an auction to prevent anyone from re-editing it and allow bidding\n    /// @dev When releasing ready-to launch cryptographs, you should lock ASAP\n    /// @param _cryptographIssue The issue # of the Cryptograph auction you want to lock\n    /// @param _editionSerial If locking auction on an edition, specify it's specific edition serial # here\n    function lockAuction(uint256 _cryptographIssue, uint256 _editionSerial) external {\n        require(msg.sender == officialPublisher, \"Only Perpetual Altruism can lock an auction\");\n        SingleAuctionLogicV1(\n            TheCryptographLogicV1(\n                CryptographIndexLogicV1(targetIndex).getCryptograph(\n                    _cryptographIssue, true, _editionSerial)\n            ).myAuction()\n        ).lock();\n    }\n\n    /// @notice Set the media hash for a cryptograph\n    /// @dev emit the MediaHash event in the cryptograph instance for  web3 retrieval. It's best practice to call this function soon after cryptograph creation\n    /// @param _cryptographIssue The issue # of the Cryptograph you want to set the media hash for\n    /// @param _editionSerial If setting hash on an edition, specify its specific edition serial # here\n    function setMediaHash(uint256 _cryptographIssue, uint256 _editionSerial, string calldata _mediaHash) external{\n        TheCryptographLogicV1 _cry = TheCryptographLogicV1(CryptographIndexLogicV1(targetIndex).getCryptograph(\n                    _cryptographIssue, true, _editionSerial)\n            );\n        require(msg.sender == SingleAuctionLogicV1(_cry.myAuction()).publisher(),\n            \"Only the publisher of a Cryptograph can edit its media hash\"\n        );\n\n        _cry.setMediaHash(_mediaHash);\n    }\n\n    /// @notice Set the media url for a cryptograph\n    /// @dev emit the MediaUrl event in the cryptograph instance for  web3 retrieval. It's best practice to call this function soon after cryptograph creation\n    /// @param _cryptographIssue The issue # of the Cryptograph you want to set the media url for\n    /// @param _editionSerial If setting url on an edition, specify its specific edition serial # here\n    function setMediaUrl(uint256 _cryptographIssue, uint256 _editionSerial, string calldata _mediaUrl) external{\n        TheCryptographLogicV1 _cry = TheCryptographLogicV1(CryptographIndexLogicV1(targetIndex).getCryptograph(\n                    _cryptographIssue, true, _editionSerial)\n            );\n        require(msg.sender == SingleAuctionLogicV1(_cry.myAuction()).publisher(), \"Only the publisher of a Cryptograph can edit its media URL\");\n\n        _cry.setMediaUrl(_mediaUrl);\n    }\n\n    /// @notice Instance a Cryptograph\n    /// @dev The SingleAuction is init() but TheCryptograph is not\n    /// @param _cryInitiator The Cryptograph Iniator address\n    /// @return (new CryptographAddress, new SingleAuctionAddress)\n    function instanceCryptograph( address _cryInitiator, bool _official) internal returns (address, address){\n\n        //Instance a new Cryptograph\n        TheCryptographProxiedV1 newCryptographProxied = new TheCryptographProxiedV1(targetCryLogicVersion, targetVC);\n\n        //Instance a new auction\n        SingleAuctionProxiedV1 newSingleAuctionProxiedV1 = new SingleAuctionProxiedV1(targetAuctionLogicVersion, targetVC, targetAuctionBidLogicVersion);\n\n        //-----------------------\n        //Init the auction\n        SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).initAuction(\n            address(newCryptographProxied),\n            _cryInitiator,\n            !_official //Will lock the auction setup if not an official Cryptograph\n        );\n\n        //-----------------------\n\n        //Checking any bamboozling with the fees\n        if(!_official){\n                assert(SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).perpetualAltruismCut() >= 25000);\n            }\n\n        assert(\n            SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).perpetualAltruismCut() +\n            SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).publisherCut() +\n            SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).charityCut() +\n            SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).thirdPartyCut() == 100000\n            );\n\n        assert(SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).startTime() <=\n        SingleAuctionLogicV1(address(newSingleAuctionProxiedV1)).endTime());\n\n        return (address(newCryptographProxied), address(newSingleAuctionProxiedV1));\n\n    }\n\n    /*\n    ====================================================\n                    GENERALIZED GBM STUFF\n    ====================================================\n    */\n\n    /*\n        The processus for holding a Generalized GBM Auction (GGBMA) is as follow :\n        -Call \"createGGBMA\" to create a generalized GBM auction\n            -> It will have a cryptograph template that will be copied at minting time\n            -> Edition serial is 0 (prototype) for get purposes.\n            -> Reminder that once instanced, changes to the prototype don't carry over to copies.\n        -\"reInitCryptograph\", \"setMediaHash\", \"setMediaURL\" works on the GGBMA prototype and copies just like a normal cryptograph\n        -\"reInitAuction\", \"lockAuction\" allows to interact with a GGBMA just like a normal auction.\n        -Once the auction is over, bidders calling win() on the auction serial #0 will instead mint a new cryptograph/Single auction pair\n            -> This pair is initiated to be past their initial auction already and to have the bidder as the new owner.\n    */\n\n    /// @notice Create a Cryptograph\n    /// @dev emit CryptographCreated event. Official cryptographs need their auction locked-in afterwards.\n    /// @param _cryInitiator The cryptograph initiator for the desired GGBMA\n    /// @return The serial number of the newly created Cryptograph\n    function createGGBMA (address _cryInitiator) external returns (uint256){\n\n        require(false, \"GGBMA creation is disabled for launch, they will need an update approved by the senate\");\n\n        uint256 _issue; //The issue # we will get\n\n        bool offi = msg.sender == officialPublisher;\n\n        require(communityMintable || offi, \"community Cryptographs can't be created at the moment\");\n\n        //Book the edition into the index and get the issue #\n        if(offi){\n            //Inserting an official Cryptograph\n            _issue = CryptographIndexLogicV1(targetIndex).createAGGBMA(msg.sender, CryptographInitiator(_cryInitiator).maxSupply());\n        } else {\n            //Inserting a community Cryptograph\n            _issue = CryptographIndexLogicV1(targetIndex).createACommunityGGBMA(msg.sender, CryptographInitiator(_cryInitiator).maxSupply());\n        }\n        emit CryptographEditionAdded(_issue, CryptographInitiator(_cryInitiator).maxSupply(), offi);\n\n        //Instance the Cryptograph and the auction\n        address newCryptographProxied;\n        address newMintingAuctionProxiedV1;\n        (newCryptographProxied, newMintingAuctionProxiedV1) = instanceCryptographGGBMA(_cryInitiator, _issue);\n\n        //Book the prototype at index0 of the edition\n\n        CryptographIndexLogicV1(targetIndex).mintAnEditionAt(\n            _issue,\n            0,\n            offi,\n            address(newCryptographProxied)\n        );\n\n        emit CryptographCreated(_issue, newCryptographProxied, offi);\n        mintingAuctionSupply[newMintingAuctionProxiedV1] = CryptographInitiator(_cryInitiator).maxSupply();\n\n        return _issue;\n    }\n\n    /// @notice Instance a Cryptograph/Minting Auction pair\n    /// @dev The MintingAuction is init() but TheCryptograph is not\n    /// @param _cryInitiator The cryptograph Initator the GGBMA will be created after\n    /// @return (new CryptographAddress, new MintingAuctionAddress)\n    function instanceCryptographGGBMA(address _cryInitiator, uint256 _issue) internal returns (address, address){\n\n\n        //Is the GGBMA published by PA or a third paty ?\n        bool _official; //Set to false by default\n        if(msg.sender == officialPublisher){\n            _official = true;\n        }\n\n        require(communityMintable || _official, \"community Cryptographs can't be created at the moment\");\n\n        //Instance a new Cryptograph\n        address newCryptographProxied = address(new TheCryptographProxiedV1(targetCryLogicVersion, targetVC));\n\n        //Instance a new auction\n        address newMintingAuctionProxiedV1 = address(new MintingAuctionProxiedV1(targetMintingAuctionLogicVersion, targetVC));\n\n        //-----------------------\n\n        TheCryptographLogicV1(address(newCryptographProxied)).initCry(\n                _issue, 0, _official, newMintingAuctionProxiedV1, _cryInitiator, address(0)\n            );\n\n        //Init the auction\n        MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).initAuction(\n            newCryptographProxied,\n            _cryInitiator,\n            !_official //Will lock the auction setup if not an official Cryptograph\n        );\n        //-----------------------\n\n        //Setting hash and url\n        TheCryptographLogicV1(newCryptographProxied).setMediaHash(\n            CryptographInitiator(_cryInitiator).mediaHash()\n        );\n        TheCryptographLogicV1(newCryptographProxied).setMediaUrl(\n            CryptographInitiator(_cryInitiator).mediaUrl()\n        );\n\n        //Checking any bamboozling with the fees\n        if(!_official){\n                assert(MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).perpetualAltruismCut() >= 25000);\n            }\n\n        assert(\n            MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).perpetualAltruismCut() +\n            MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).publisherCut() +\n            MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).charityCut() +\n            MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).thirdPartyCut() == 100000\n            );\n\n        assert(MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).startTime() <=\n            MintingAuctionLogicV1(address(newMintingAuctionProxiedV1)).endTime());\n\n\n        return (address(newCryptographProxied), address(newMintingAuctionProxiedV1));\n    }\n\n    /// @notice Mint a Cryptograph/SA pair initialized to a GGBMA winner\n    /// @dev To be called BEFORE the bid funds are distributed to the publisher\n    /// @param _issue The issue number of the GGBMA\n    /// @param _isOfficial Is it an official or community GGBMA ?\n    /// @param _winner The address of someone eligible to win the auction\n    function mintGGBMA(uint256 _issue, bool _isOfficial, address _winner) external returns(bool){\n        require(msg.sender == targetAuctionHouse, \"Only the auction house can ask the factory to mint new copies for a GGBMA\");\n\n        //Grabbing the GGBMA\n        address _ggbma = TheCryptographLogicV1(\n                CryptographIndexLogicV1(targetIndex).getCryptograph(_issue, _isOfficial, 0)\n            ).myAuction();\n\n        //Calculating the claimant ranking\n        uint256 positionInAuction; //0\n\n        //Browse the BidLink chain until the link above us has a bid greater or equal to us\n        address currentLink = MintingAuctionLogicV1(_ggbma).bidLinks(MintingAuctionLogicV1(_ggbma).highestBidder());\n        bool stop = currentLink == address(0x0); //Do not even enter the loop if there is no highest bidder\n        while(!stop){\n            if(BidLink(currentLink).bidder() == _winner){\n                positionInAuction++; //Increasing the count (serial # start at 1 while counter start at 0)\n                stop = true;\n            } else if(BidLink(currentLink).below() == address(0x0)){ //Checking if we have reached the bottom\n                positionInAuction = 0; //We were not a bidder...\n                stop = true;\n            } else {\n                //Going down\n                positionInAuction++;\n                currentLink = BidLink(currentLink).below();\n            }\n        }\n\n        require(positionInAuction != 0, \"Could not find your bid in this auction\");\n\n        //Checking if we can mint. No refunds as those are handled by the auction itself.\n        //The way we check for minting available is by checking if there is a standing bid.\n        require(MintingAuctionLogicV1(_ggbma).currentBids(_winner) != 0, \"You already minted your cryptograph\");\n\n        /*\n        Double entry attack possible here on third parties minted cryptographs, as initiators are user instanced.\n\n        Limitation of exploit :\n        -only \"views\" are called (so no state-changing gas stealing)\n        -only on community GGBMA\n\n        Consequence at worst inside cryptograph ecosystem : The attacker (who is the original creator of the GGBMA)\n        can make changes to each newly minted cryptograph (so that they are not all unique).\n\n        => Not a bug. It's a feature.\n\n        */\n\n        //Instance the Cryptograph\n        address newCryptographProxied;\n        address newSingleAuctionProxiedV1;\n        address initiator = MintingAuctionLogicV1(_ggbma).initiator();\n\n        (newCryptographProxied, newSingleAuctionProxiedV1) = instanceCryptograph(initiator, _isOfficial);\n\n        //Book the Cryptograph into the index\n        CryptographIndexLogicV1(targetIndex).mintAnEditionAt(\n            _issue, // Issue #\n            positionInAuction, // Serial #\n            _isOfficial,\n            address(newCryptographProxied)\n        );\n\n        //Init the cryptograph\n        TheCryptographLogicV1(newCryptographProxied).initCry(\n                _issue, positionInAuction, _isOfficial, newSingleAuctionProxiedV1, initiator, _winner\n            );\n\n        //Setting hash and url\n        TheCryptographLogicV1(newCryptographProxied).setMediaHash(\n            CryptographInitiator(initiator).mediaHash()\n        );\n        TheCryptographLogicV1(newCryptographProxied).setMediaUrl(\n            CryptographInitiator(initiator).mediaUrl()\n        );\n\n        //Locking the auction\n        SingleAuctionLogicV1(newSingleAuctionProxiedV1).lock();\n    }\n\n    /// @notice Set the ability for third parties to create their own cryptographs.\n    /// @dev False at creation\n    /// @param _communityMintable Are community Cryptographs mintable ?\n    function setCommunityMintable(bool _communityMintable) external {\n\n        require(msg.sender == officialPublisher, \"Only Perpetual Altruism can set communityMintable\");\n\n        communityMintable = _communityMintable;\n    }\n}\n"},"browser/CryptographFactoryV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Factory Header\n/// @notice Contain all the events emitted by the factory\ncontract CryptographFactoryHeaderV1 {\n    event CryptographCreated(uint256 indexed cryptographIssue, address indexed cryptographAddress, bool indexed official);\n    event CryptographEditionAdded(uint256 indexed cryptographIssue, uint256 indexed editionSize, bool indexed official);\n    event CryptographEditionMinted(uint256 indexed cryptographIssue, uint256 indexed editionIssue, address cryptographAddress, bool indexed official);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Factory Storage Internal\n/// @notice Contain all the storage of the Factory declared in a way that does not generate getters for Proxy use\ncontract CryptographFactoryStorageInternalV1 {\n\n    bool internal initialized; //A bool controlling if we have been initialized or not\n\n    address internal officialPublisher; //The address that is allowed to publish the official (i.e. non-community) cryptographs\n\n    /*\n    ==================================================\n                    Linking section\n    ==================================================\n    Those are the addresses of other smart contracts in the ecosystem and relevant value to them\n    */\n    address internal targetVC; //Address of the version control that the Cryptograph should use (potentially different than ours)\n    address internal targetAuctionHouse; //Address of the Auction house used by Cryptograph\n    address internal targetIndex; //Address of the Cryptograph library storing both fan made and public cryptographs\n\n    // DO NOT PUT THE CRYPTOGRAPH PROXY CODE ADDRESS IN HERE, it needs to be in the logic code of the factory\n    // IDEM FOR SINGLE AUCTION PROXY CODE\n    uint256 internal targetCryLogicVersion; //Which version of the logic code in the Version Control array the cryptographs should use\n    //Which version of the logic code in the Version Control array the Single Auction should use\n    uint256 internal targetAuctionLogicVersion;\n    //Which version of the logic code in the Version Control array the Single Auction Bid should use\n    uint256 internal targetAuctionBidLogicVersion;\n    //Which version of the logic code in the Version Control array the Minting Auction should use\n    uint256 internal targetMintingAuctionLogicVersion;\n\n    //Actual data storage section\n    mapping (address => uint256) internal mintingAuctionSupply; //How much token can be created by each MintingAuction\n\n    //Are Community cryptographs allowed to be minted ?\n    bool internal communityMintable;\n\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Factory Storage Public\n/// @notice Contain all the storage of the Factory declared in a way that generates getters for Logic use\ncontract CryptographFactoryStoragePublicV1 {\n\n    bool public initialized; //A bool controlling if we have been initialized or not\n\n    address public officialPublisher; //The address that is allowed to publish the non-community cryptographs\n\n    /*\n    ==================================================\n                    Linking section\n    ==================================================\n    Those are the addresses of other smart contracts in the ecosystem and the relevant Version Control index value to them\n    */\n    address public targetVC; //Address of the version control the cryptographs should use\n    address public targetAuctionHouse; //Address of the Auction house used by cryptograph\n    address public targetIndex; //Address of the Cryptograph library storing both fan made and public cryptographs\n\n    uint256 public targetCryLogicVersion; //Which version of the logic code in the Version Control array the cryptographs should use\n    uint256 public targetAuctionLogicVersion; //Which version of the logic code in the Version Control array the Single Auction should use\n    //Which version of the logic code in the Version Control array the Single Auction Bid should use\n    uint256 public targetAuctionBidLogicVersion;\n    //Which version of the logic code in the Version Control array the Minting Auction should use\n    uint256 public targetMintingAuctionLogicVersion;\n\n    //Actual data storage section\n    mapping (address => uint256) public mintingAuctionSupply; //How much token can be created by each MintingAuction\n\n    //Are Community cryptographs allowed to be minted ?\n    bool public communityMintable;\n}"},"browser/CryptographIndexLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./CryptographIndexV1.sol\";\nimport \"./EditionIndexerProxiedV1.sol\";\nimport \"./EditionIndexerLogicV1.sol\";\nimport \"./ERC2665LogicV1.sol\";\n\n///@title Cryptograph Index Logic Contract\n///@author Guillaume Gonnaud\n///@notice Provide the logic code related to remembering the address of all the published cryptographs. Cast this contract on the proxy.\n///@dev This contract and its functions should be called by the relevant proxy smart contract only\ncontract CryptographIndexLogicV1 is VCProxyData, CryptographIndexHeaderV1, CryptographIndexStoragePublicV1  {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence it's memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that requires to be called only by the cryptograph factory\n    modifier restrictedToFactory(){\n        require((msg.sender == factory), \"Only the cryptograph factory smart contract can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the Index\n    /// @dev Callable only once after deployment\n    /// @param _factory The address of the CryptographFactory Instance\n    /// @param _indexerLogicCodeIndex The index in the VC of editionIndexers logic code\n    /// @param _ERC2665Lieutenant The address of the ERC721 Instance\n    function init(address _factory, uint256 _indexerLogicCodeIndex, address _ERC2665Lieutenant) external returns(bool){\n        require(!initialized, \"The cryptograph index has already been initialized\");\n        factory = _factory;\n        indexerLogicCodeIndex = _indexerLogicCodeIndex;\n        initialized = true;\n        cryptographs.push(address(0x0));\n        communityCryptographs.push(address(0x0));\n        ERC2665Lieutenant = _ERC2665Lieutenant;\n        return true;\n    }\n\n\n    /// @notice Insert a cryptograph in the array and return the new index position\n    /// @dev Only callable by Factory\n    /// @param _cryptograph The address of the cryptograph to insert in the index\n    /// @return (uint) The new index position in the cryptograph array\n    function insertACryptograph(address _cryptograph) external restrictedToFactory() returns(uint){\n\n        //Update the ERC2665\n        ERC2665LogicV1(ERC2665Lieutenant).MintACryptograph(_cryptograph);\n        cryptographs.push(_cryptograph);\n        return (cryptographs.length - 1); //Inserting the cryptograph and returning the position in the array\n    }\n\n\n    /// @notice Insert a community cryptograph in the array and return the new index position\n    /// @dev Only callable by Factory\n    /// @param _communityCryptograph The address of the community cryptograph to insert in the index\n    /// @return (uint) The new index position in the community cryptograph array\n    function insertACommunityCryptograph(address _communityCryptograph) external restrictedToFactory() returns(uint){\n\n        //Update the ERC2665\n        ERC2665LogicV1(ERC2665Lieutenant).MintACryptograph(_communityCryptograph);\n\n        communityCryptographs.push(_communityCryptograph);\n        return (communityCryptographs.length - 1); //Inserting the community cryptograph and returning new position in array\n    }\n\n\n    /// @notice Create a new cryptograph edition and return the new index position\n    /// @dev Only callable by Factory\n    /// @param _minter The address of the user wallet that will have the responsability to mint all the editions\n    /// @param _editionSize The maximum number of cryptograph that can be minted in the edition\n    /// @return (uint) The new index position in the cryptograph array\n    function createAnEdition(address _minter, uint256 _editionSize) external restrictedToFactory() returns(uint){\n        require(_minter != address(0) && _editionSize != 0,\n            \"Minter address and edition size must be greater than 0\"\n        );\n\n        //Create a new indexer for the edition\n        EditionIndexerProxiedV1 _proxied = new EditionIndexerProxiedV1(indexerLogicCodeIndex, vc);\n\n        //Initializing the indexer\n        EditionIndexerLogicV1(address(_proxied)).init(address(this), _minter, _editionSize);\n\n        //Adding the indexer to the mapping\n        editionSizes[address(_proxied)] = _editionSize;\n\n        //Indicate our type as edition\n        cryptographType[address(_proxied)] = 1;\n\n        //Inserting the edition and returning the position in the array\n        cryptographs.push(address(_proxied));\n        return (cryptographs.length - 1);\n    }\n\n\n    /// @notice Create a new cryptograph edition starting at 0 and return the new index position\n    /// @dev Only callable by Factory\n    /// @param _minter The address of the user wallet that will have the responsability to mint all the editions\n    /// @param _editionSize The maximum number of cryptograph that can be minted in the edition\n    /// @return (uint) The new index position in the cryptograph array\n    function createAGGBMA(address _minter, uint256 _editionSize) external restrictedToFactory() returns(uint){\n        require(_minter != address(0) && _editionSize != 0,\n            \"Minter address and edition size must be greater than 0\"\n        );\n\n        //Create a new indexer for the edition\n        EditionIndexerProxiedV1 _proxied = new EditionIndexerProxiedV1(indexerLogicCodeIndex, vc);\n\n        //Initializing the indexer\n        EditionIndexerLogicV1(address(_proxied)).init0(address(this), _minter, _editionSize+1);\n\n        //Adding the indexer to the mapping\n        editionSizes[address(_proxied)] = _editionSize;\n\n        //Indicate our type as edition\n        cryptographType[address(_proxied)] = 1;\n\n        //Inserting the edition and returning the position in the array\n        cryptographs.push(address(_proxied));\n        return (cryptographs.length - 1);\n    }\n\n\n    /// @notice Create a new community edition and return the new index position\n    /// @dev Only callable by Factory\n    /// @param _minter The address of the user wallet that will have the responsability to mint all the editions\n    /// @param _editionSize The maximum number of community cryptograph that can be minted in the edition\n    /// @return (uint) The new index position in the cryptograph community array\n    function createACommunityEdition(address _minter, uint256 _editionSize) external restrictedToFactory() returns(uint){\n        //Create a new indexer for the edition\n        EditionIndexerProxiedV1 _proxied = new EditionIndexerProxiedV1(indexerLogicCodeIndex, vc);\n\n        //Initializing the indexer\n        EditionIndexerLogicV1(address(_proxied)).init(address(this), _minter, _editionSize);\n\n        //Adding the indexer to the mapping\n        editionSizes[address(_proxied)] = _editionSize;\n\n        //Indicate our type as edition\n        cryptographType[address(_proxied)] = 1;\n\n        //Inserting the edition and returning the position in the array\n        communityCryptographs.push(address(_proxied));\n        return (communityCryptographs.length - 1);\n    }\n\n\n    /// @notice Create a new cryptograph community edition starting at 0 and return the new index position\n    /// @dev Only callable by Factory\n    /// @param _minter The address of the user wallet that will have the responsability to mint all the editions\n    /// @param _editionSize The maximum number of cryptograph that can be minted in the edition\n    /// @return (uint) The new index position in the community cryptograph array\n    function createACommunityGGBMA(address _minter, uint256 _editionSize) external restrictedToFactory() returns(uint){\n        //Create a new indexer for the edition\n        EditionIndexerProxiedV1 _proxied = new EditionIndexerProxiedV1(indexerLogicCodeIndex, vc);\n\n        //Initializing the indexer\n        EditionIndexerLogicV1(address(_proxied)).init0(address(this), _minter, _editionSize+1); //One more for the prototype\n\n        //Adding the indexer to the mapping\n        editionSizes[address(_proxied)] = _editionSize;\n\n        //Indicate our type as edition\n        cryptographType[address(_proxied)] = 1;\n\n        //Inserting the edition and returning the position in the array\n        communityCryptographs.push(address(_proxied));\n        return (communityCryptographs.length - 1);\n    }\n\n\n    /// @notice Mint an Edition Cryptograph\n    /// @dev Only callable by Factory\n    /// @param _minter The address of the user wallet that is minting the cryptograph\n    /// @param _cryptographIssue The issue # of the edition we are minting a new member of\n    /// @param _isOfficial Is it a community edition or not ?\n    /// @param _cryptograph The address of the cryptograph we are inserting in the edition indexer\n    /// @return (uint) The serial of the newly inserted cryptograph\n    function mintAnEdition(\n        address _minter,\n        uint256 _cryptographIssue,\n        bool _isOfficial,\n        address _cryptograph\n    ) external restrictedToFactory() returns(uint){\n\n\n        //Update the ERC2665\n        ERC2665LogicV1(ERC2665Lieutenant).MintACryptograph(_cryptograph);\n\n        //Indicate our type as edition\n        cryptographType[_cryptograph] = 1;\n\n        if(_isOfficial){\n            uint256 edIdx = EditionIndexerLogicV1(cryptographs[_cryptographIssue]).insertACryptograph(_cryptograph, _minter);\n            return edIdx;\n        } else {\n            uint256 edIdx = EditionIndexerLogicV1(communityCryptographs[_cryptographIssue]).insertACryptograph(_cryptograph, _minter);\n            return edIdx;\n        }\n    }\n\n\n    /// @notice Mint an Edition Cryptograph with a specific serial\n    /// @dev Only callable by Factory\n    /// @param _cryptographIssue The issue # of the edition we are minting a new member of\n    /// @param _cryptographSerial The serial # we want to insert in the edition\n    /// @param _isOfficial Is it a community edition or not ?\n    /// @param _cryptograph The address of the cryptograph we are inserting in the edition indexer\n    function mintAnEditionAt(\n        uint256 _cryptographIssue,\n        uint256 _cryptographSerial,\n        bool _isOfficial,\n        address _cryptograph\n    ) external restrictedToFactory(){\n\n\n        //Update the ERC2665\n        ERC2665LogicV1(ERC2665Lieutenant).MintACryptograph(_cryptograph);\n\n        //Indicate our type as edition\n        cryptographType[_cryptograph] = 1;\n\n        if(_isOfficial){\n            EditionIndexerLogicV1(cryptographs[_cryptographIssue]).insertACryptographAt(_cryptograph, _cryptographSerial);\n        } else {\n            EditionIndexerLogicV1(communityCryptographs[_cryptographIssue]).insertACryptographAt(_cryptograph, _cryptographSerial);\n        }\n    }\n\n\n    /// @notice Return the address of a Cryptograph using it's parameters\n    /// @dev You can then cast this address as a Cryptograph to recover the single auction associated\n    /// @param _cryptographIssue The issue # of the Cryptograph\n    /// @param _isOfficial True if official Cryptograph, false if community Cryptograph\n    /// @param _editionSerial The edition serial # of the Cryptograph. Ignored if the Cryptograph is not an edition\n    /// @return The address of the grabbed cryptograph\n    function getCryptograph(uint256 _cryptographIssue, bool _isOfficial, uint256 _editionSerial) external view returns(address){\n        if(_isOfficial){\n            if(cryptographType[address(cryptographs[_cryptographIssue])] == 0){\n                //We are unique\n                return(address(cryptographs[_cryptographIssue]));\n            } else {\n                //We are an edition/GGBMA\n                return(address(EditionIndexerLogicV1(cryptographs[_cryptographIssue]).cryptographs(_editionSerial)));\n            }\n        } else {\n            if(cryptographType[address(communityCryptographs[_cryptographIssue])] == 0){\n               //We are unique\n                return(address(communityCryptographs[_cryptographIssue]));\n            } else {\n                //We are an edition/GGBMA\n                return(address(EditionIndexerLogicV1(communityCryptographs[_cryptographIssue]).cryptographs(_editionSerial)));\n            }\n        }\n    }\n\n}\n\n"},"browser/CryptographIndexV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Cryptoraph Indexer Header\n/// @notice Contain all the events emitted by the Cryptoraph Indexer\ncontract CryptographIndexHeaderV1 {\n}\n\n/// @author Guillaume Gonnaud 2019\n/// @title Cryptograph Indexer Storage Internal\n/// @notice Contain all the storage of the Cryptograph Indexer declared in a way that don't generate getters for Proxy use\ncontract CryptographIndexStorageInternalV1 {\n    bool internal initialized; //Bool to check if the index has been initialized\n    address internal factory; //The factory smart contract (proxy) that will publish the cryptographs\n    address[] internal cryptographs;\n    address[] internal communityCryptographs;\n    mapping (address => uint) internal editionSizes; //Set to 0 if unique (not edition)\n    mapping (address => uint) internal cryptographType; //0 = Unique, 1 = Edition, 2 = Minting\n    uint256 internal indexerLogicCodeIndex; //The index in the Version Control of the logic code\n\n    address internal ERC2665Lieutenant;\n}\n\n/// @author Guillaume Gonnaud 2019\n/// @title Cryptograph Indexer Storage Public\n/// @notice Contain all the storage of the Cryptograph Indexer declared in a way that generates getters for logic use\ncontract CryptographIndexStoragePublicV1 {\n    bool public initialized; //Bool to check if the index has been initialized\n    address public factory; //The factory smart contract (proxy) that will publish the cryptographs\n    address[] public cryptographs;\n    address[] public communityCryptographs;\n    mapping (address => uint) public editionSizes; //Set to 0 if unique (not edition)\n    mapping (address => uint) public cryptographType; //0 = Unique, 1 = Edition, 2 = Minting\n    uint256 public indexerLogicCodeIndex; //The index in the VC of the logic code\n\n    address public ERC2665Lieutenant;\n}\n\n"},"browser/CryptographInitiator.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud\n/// @title Cryptograph Initiator\n/// @notice Basically a solidity bean so that we can pass it as argument without hitting stack too deep errors when creating a cryptograph\ncontract CryptographInitiator{\n    address public owner; // The desired owner of the Cryptograph\n    string public name; // The desired name of the Cryptograph\n    string public creator; // The desired creatpr of the Cryptograph\n    uint256 public auctionStartTime; //The desired unix (seconds) timestamp at which the initial auction should start\n    uint256 public auctionSecondsDuration; // The duration in seconds of the initial auction\n    address public publisher; // The address of the publisher. Can edit media url and hash for a cryptograph.\n    uint256 public publisherCut; // How much out of 100k parts of profits should the publisher get. e.g. publisherCut = 25000 means 1/4\n    address public charity; // The address of the charity\n    uint256 public charityCut; // The charity cut out of 100k\n    address public thirdParty; // The address of a third party\n    uint256 public thirdPartyCut; // The third party cut out of 100k\n    uint256 public perpetualAltruismCut; // Will always be set to 25k except very special occasions.\n    uint256 public maxSupply; // How many of these cryptographs should be minted maximum\n    uint256 public startingPrice; // The Starting price of the auction\n    uint256 public cryptographIssue; // The desired issue of the cryptograph (only for editions)\n    string public mediaHash; // The desired media hash of the cryptograph\n    string public mediaUrl; // The desired media url of the cryptograph\n\n    /// @param _name The desired name of the Cryptograph\n    /// @param _auctionStartTime The desired unix (seconds) timestamp at which the initial auction should start\n    /// @param _auctionSecondsDuration The duration in seconds of the initial auction\n    /// @param _publisher The address of the publisher. Can edit media url and hash for a cryptograph.\n    /// @param _publisherCut How much out of 100k parts of profits should the publisher get. e.g. _publisherCut = 25000 mean 1/4 of all profits\n    /// @param _charity The address of the charity\n    /// @param _charityCut The charity cut out of 100k\n    /// @param _thirdParty The address of a third party\n    /// @param _thirdPartyCut The third party cut out of 100k\n    /// @param _perpetualAltruismCut Will always be set to 25k except very special occasions.\n    /// @param _maxSupply How many of these cryptographs should be minted maximum\n    /// @param _startingPrice The Starting price of the auction\n    /// @param _cryptographIssue The desired issue of the cryptograph (only for editions)\n    constructor (\n                string memory _name,\n                uint256 _auctionStartTime,\n                uint256 _auctionSecondsDuration,\n                address _publisher,\n                uint256 _publisherCut,\n                address _charity,\n                uint256 _charityCut,\n                address _thirdParty,\n                uint256 _thirdPartyCut,\n                uint256 _perpetualAltruismCut,\n                uint256 _maxSupply,\n                uint256 _startingPrice,\n                uint256 _cryptographIssue\n    ) public{\n        owner = msg.sender;\n        name = _name;\n        auctionStartTime = _auctionStartTime;\n        auctionSecondsDuration = _auctionSecondsDuration;\n        publisher = _publisher;\n        publisherCut = _publisherCut;\n        charity = _charity;\n        charityCut = _charityCut;\n        thirdParty = _thirdParty;\n        thirdPartyCut = _thirdPartyCut;\n        perpetualAltruismCut = _perpetualAltruismCut;\n        maxSupply = _maxSupply;\n        startingPrice = _startingPrice;\n        cryptographIssue = _cryptographIssue;\n\n    }\n\n    modifier restrictedToOwner(){\n        require((msg.sender == owner), \"Only the creator of this Contract can modify its memory\");\n        _;\n    }\n\n    function setName(string calldata _name) external restrictedToOwner(){\n        name = _name;\n    }\n\n    function setAuctionStartTime(uint256 _auctionStartTime) external restrictedToOwner(){\n        auctionStartTime = _auctionStartTime;\n    }\n\n    function setAuctionSecondsDuration(uint256 _auctionSecondsDuration) external restrictedToOwner(){\n        auctionSecondsDuration = _auctionSecondsDuration;\n    }\n\n    function setPublisher(address _publisher) external restrictedToOwner(){\n        publisher = _publisher;\n    }\n\n    function setPublisherCut(uint256 _publisherCut) external restrictedToOwner(){\n        publisherCut = _publisherCut;\n    }\n\n    function setCharity(address _charity) external restrictedToOwner(){\n        charity = _charity;\n    }\n\n    function setCharityCut(uint256 _charityCut) external restrictedToOwner(){\n        charityCut = _charityCut;\n    }\n\n    function setThirdParty(address _thirdParty) external restrictedToOwner(){\n        thirdParty = _thirdParty;\n    }\n\n    function setThirdPartyCut(uint256 _thirdPartyCut) external restrictedToOwner(){\n        thirdPartyCut = _thirdPartyCut;\n    }\n\n    function setPerpetualAltruismCut(uint256 _perpetualAltruismCut) external restrictedToOwner(){\n        perpetualAltruismCut = _perpetualAltruismCut;\n    }\n\n    function setMaxSupply(uint256 _maxSupply) external restrictedToOwner(){\n        maxSupply = _maxSupply;\n    }\n\n    function setStartingPrice(uint256 _startingPrice) external restrictedToOwner(){\n        startingPrice = _startingPrice;\n    }\n\n    function setCryptographIssue(uint256 _cryptographIssue) external restrictedToOwner(){\n        cryptographIssue = _cryptographIssue;\n    }\n\n    function setMediaHash(string calldata _mediahash) external restrictedToOwner(){\n        mediaHash = _mediahash;\n    }\n\n    function setMediaUrl(string calldata _mediaUrl) external restrictedToOwner(){\n        mediaUrl = _mediaUrl;\n    }\n\n    function setCreator(string calldata _creator) external restrictedToOwner(){\n        creator = _creator;\n    }\n\n}"},"browser/CryptographKYCLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./CryptographKYCV1.sol\";\n\n/// @title Cryptograph KYC Logic Contract\n/// @author Guillaume Gonnaud 2020\n/// @notice Provides the logic code for the KYC of bidders\n/// @dev Price feed is in ETH and NOT an oracle because it's a KYC price feed (We have to verify transaction above a certain GBP amount)\ncontract CryptographKYCLogicV1 is VCProxyData, CryptographKYCHeaderV1, CryptographKYCStoragePublicV1  {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    modifier restrictedToOperators(){\n        require((msg.sender == perpetualAltruism || authorizedOperators[msg.sender]), \"Only operators can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the KYC contract\n    /// @dev Callable only once after deployment\n    function init() external {\n        require(perpetualAltruism == address(0), \"Already initalized\");\n        perpetualAltruism = msg.sender;\n        priceLimit = uint256(0) - uint256(1);\n        emit PriceLimit(priceLimit);\n    }\n\n    /// @notice Used to allow other wallets to manage the KYC\n    /// @dev Only callable by Perpetual Altruism/Other operators\n    /// @param _operator The address of the operator\n    /// @param _operating If the operator is allowed to operate\n    function setOperator(address _operator, bool _operating) external restrictedToOperators(){\n        authorizedOperators[_operator] = _operating;\n    }\n\n\n    /// @notice Used to set a price limit above which wallets need to be KYCed\n    /// @dev Only callable by Perpetual Altruism/Other operators\n    /// @param _newPrice The new price limit\n    function setPriceLimit(uint256 _newPrice) external restrictedToOperators(){\n        priceLimit = _newPrice;\n        emit PriceLimit(_newPrice);\n    }\n\n    /// @notice Used to allow other wallets to manage the KYC\n    /// @dev Only callable by Perpetual Altruism/Other operators\n    /// @param _user The address of the user\n    /// @param _kyc Is the user allowed to bid for any amount ?\n    function setKyc(address _user, bool _kyc) external restrictedToOperators(){\n        kycUsers[_user] = _kyc;\n        emit KYCed(_user, _kyc);\n    }\n\n\n    /// @notice Check if a user is allowed to transact this amount\n    /// @dev Anyone can check\n    /// @param _user The address of the user\n    /// @param _amount The amount of the bid\n    function checkKyc(address _user, uint256 _amount) external view returns(bool){\n        return (_amount <= priceLimit || kycUsers[_user]);\n    }\n\n}"},"browser/CryptographKYCV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n\n/// @author Guillaume Gonnaud 2020\n/// @title Cryptograph KYC header\n/// @notice Contain all the events emitted by the Cryptograph KYC\ncontract CryptographKYCHeaderV1 {\n\n    /// @dev Event fired whenever a wallet address is added or removed from the list of KYCED wallet\n    event KYCed(address indexed _user, bool indexed _isValid);\n\n    /// @dev Event fired whenever a new price (in wei) is set for the KYC limit\n    event PriceLimit(uint256 indexed _newPrice);\n}\n\n\n\n/// @author Guillaume Gonnaud 2020\n/// @title Cryptograph KYC  Storage Internal\n/// @notice Contain all the storage of the Cryptograph KYC  declared in a way that don't generate getters for Proxy use\ncontract CryptographKYCStorageInternalV1 {\n\n    //Perpetual Altruism, the creator of this smart contract\n    address internal perpetualAltruism;\n\n    //The list of wallets that can publish a new price limit  & add/remove wallets from the kyc\n    mapping(address => bool) internal authorizedOperators;\n\n    //The price in wei above which a transaction need a KYC. set to 0 to refuse all transactions, to UINT256MAX to allow all.\n    uint256 internal priceLimit;\n\n    //The mapping of KYCED users\n    mapping(address => bool) internal kycUsers;\n\n}\n\n/// @author Guillaume Gonnaud 2020\n/// @title Cryptograph KYC  Storage Internal\n/// @notice Contain all the storage of the Cryptograph KYC  declared in a way that don't generate getters for Proxy use\ncontract CryptographKYCStoragePublicV1 {\n\n    //Perpetual Altruism, the creator of this smart contract\n    address public perpetualAltruism;\n\n    //The list of wallets that can publish a new price limit  & add/remove wallets from the kyc\n    mapping(address => bool) public authorizedOperators;\n\n    //The price in wei above which a transaction need a KYC. set to 0 to refuse all transactions, to UINT256MAX to allow all.\n    uint256 public priceLimit;\n\n    //The mapping of KYCED users\n    mapping(address => bool) public kycUsers;\n}"},"browser/ERC2665LogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./ERC2665V1.sol\";\nimport \"./TheCryptographLogicV1.sol\";\n\n/// @author Guillaume Gonnaud 2020\n/// @title  Cryptograph ERC2665 Mimic Smart Contract\n/// @notice Provide the logic code for third parties to read cryptographs as if they were ERC2665 tokens (they are not, hence no \"write\" interactions are enabled)\ncontract ERC2665LogicV1 is VCProxyData, ERC2665HeaderV1, ERC2665StoragePublicV1 {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor() public {\n        //Self intialize (nothing)\n    }\n\n    function init(address _auctionHouse, address _indexCry) external{\n        require(auctionHouse == address(0), \"Already initialized\");\n        auctionHouse = payable(_auctionHouse);\n        indexCry = _indexCry;\n    }\n\n    /// @notice Transfer a cryptograph in the ERC2665 proxy\n    /// @dev Call the internal transfer function\n    /// @param _from The address of the previous owner\n    /// @param _to The address of the new owner\n    /// @param _cryptograph The address of the cryptrograph\n    /// @param _lastSoldFor The amount of the last cryptograph platform transaction for this cryptograph\n    function transferACryptograph(address _from, address _to, address _cryptograph, uint256 _lastSoldFor ) external {\n        require((msg.sender == auctionHouse), \"Only the cryptograph auction house smart contract can call this function\");\n        transferACryptographInternal(_from, _to, _cryptograph, _lastSoldFor);\n    }\n\n\n    //Called by the Index when a minting is happening\n    function MintACryptograph(address _newCryptograph) external {\n        require((msg.sender == indexCry), \"Only the cryptograph index smart contract can call this function\");\n        index2665ToAddress[totalSupplyVar] = _newCryptograph;\n        totalSupplyVar++;\n        balanceOfVar[address(0)] = balanceOfVar[address(0)] + 1;\n        isACryptograph[_newCryptograph] = true;\n\n        //Weakness in ERC-721 spec : Created and assigned to address 0.\n        //Meaning : let's not emit event\n        // emit Transfer(address(0), address(0), uint256(_newCryptograph));\n    }\n\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external pure returns(bool) {\n\n        return (\n            interfaceID == 0x80ac58cd || //ERC721\n            interfaceID == 0x5b5e139f || //metadata extension\n            interfaceID == 0x780e9d63 || //enumeration extension\n            interfaceID == 0x509ffea4 //ERC2665\n        );\n        \n    }\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256){\n        require(_owner != address(0), \"ERC721 NFTs assigned to the zero address are considered invalid\");\n        return balanceOfVar[_owner];\n    }\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address){\n        require(isACryptograph[address(_tokenId)], \"_tokenId is not a Valid Cryptograph\");\n        address retour = TheCryptographLogicV1(address(_tokenId)).owner();\n        require(retour != address(0),\n            \"ERC721 NFTs assigned to the zero address are considered invalid\");\n        return retour;\n    }\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `msg.value` < `getTransferFee(_tokenId)`.\n    ///  If the fee is not to be paid in ETH, then token publishers SHOULD provide a way to pay the\n    ///  fee when calling this function or it's overloads, and throwing if said fee is not paid.\n    ///  Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.\n    ///  When transfer is complete, this function checks if `_to` is a smart\n    ///  contract (code size > 0). If so, it calls `onERC2665Received` on `_to`\n    ///  and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC2665Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable{\n        transferFromInternal(_from, _to, _tokenId, msg.sender, msg.value);\n\n        require(_to != address(0));\n        if(isContract(_to)){\n            //bytes4(keccak256(\"onERC2665Received(address,address,uint256,bytes)\")) == bytes4(0xac3cf292)\n            require(ERC2665TokenReceiver(_to).onERC2665Received(msg.sender, _from, _tokenId, data) == bytes4(0xac3cf292));\n        }\n    }\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable{\n        transferFromInternal(_from, _to, _tokenId, msg.sender, msg.value);\n\n        require(_to != address(0));\n        if(isContract(_to)){\n            //bytes4(keccak256(\"onERC2665Received(address,address,uint256,bytes)\")) == bytes4(0xac3cf292)\n            require(ERC2665TokenReceiver(_to).onERC2665Received(msg.sender, _from, _tokenId, \"\") ==  bytes4(0xac3cf292));\n        }\n    }\n\n   /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. Throws if `msg.value` < `getTransferFee(_tokenId)`.\n    ///  If the fee is not to be paid in ETH, then token publishers SHOULD provide a way to pay the\n    ///  fee when calling this function and throw if said fee is not paid.\n    ///  Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable{\n        transferFromInternal(_from, _to, _tokenId, msg.sender, msg.value);\n    }\n\n\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner. After a successful call and if\n    ///  `msg.value == getTransferFee(_tokenId)`, then a subsequent atomic call to\n    ///  `getTransferFee(_tokenId)` would eval to 0. If the fee is not to be paid in ETH,\n    ///  then token publishers MUST provide a way to pay the fee when calling this function,\n    ///  and throw if the fee is not paid.\n    ///  Any ETH sent to this function will be used to pay the transfer fee, and if the\n    ///  ETH sent is twice (or more) the non-0 current transfer fee, the next transfer fee \n    ///  will be prepaid as well.  \n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable{\n\n        address owner = TheCryptographLogicV1(address(_tokenId)).owner();\n        require(msg.sender == owner || approvedOperator[owner][msg.sender], \"Only the owner or an operator can approve a token transfer\");\n        require(isACryptograph[address(_tokenId)], \"_tokenId is not a Valid Cryptograph\");\n\n        //Reset the renatus timer\n        TheCryptographLogicV1(address(_tokenId)).renatus();\n\n        uint256 leftover = msg.value;\n\n        //If the transfer fee is being paid\n        if(leftover >= transferFees[_tokenId]){\n\n            leftover =  leftover - transferFees[_tokenId];\n            transferFees[_tokenId] = 0;\n            \n            //Prepay the next subsequent transfer\n            if(leftover >= (lastSoldFor[_tokenId] * 15 /100)){\n                leftover = leftover -  (lastSoldFor[_tokenId] * 15 /100);\n                transferFeePrepaid[_tokenId] = true;\n            }\n\n        }\n\n        //Marking the auction has now being handled by ERC2665\n        AuctionHouseLogicV1(auctionHouse).approveERC2665{value: msg.value - leftover }(address(_tokenId), msg.sender, _approved);\n\n        if(leftover != 0){\n            //Send back the extra money to the payer\n            (bool trashBool, ) = msg.sender.call{value:leftover}(\"\");\n            require(trashBool, \"Could not send the leftover money back\");\n        }\n\n        approvedTransferAddress[_tokenId] = _approved; \n\n        emit Approval(msg.sender, _approved, _tokenId);\n\n    }\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external {\n        approvedOperator[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address){\n        require(isACryptograph[address(_tokenId)], \"_tokenId is not a Valid Cryptograph\");\n\n        return approvedTransferAddress[_tokenId];\n    }\n  \n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool){\n        return approvedOperator[_owner][_operator];\n    }\n\n    /// @notice Query what is the transfer fee for a specific token\n    /// @dev If a call would returns 0, then any subsequent calls witht the same argument\n    /// must also return 0 until the Transfer event has been emitted.\n    /// @param _tokenId The NFT to find the Transfer Fee amount for\n    /// @return The amount of Wei that need to be sent along a call to a transfer function\n    function getTransferFee(uint256 _tokenId) external view returns (uint256){\n        return transferFees[_tokenId];\n    }\n\n\n    /// @notice Query what is the transfer fee for a specific token if the fee is to be paid\n    /// @dev If a call would returns 0, then any subsequent calls with the same arguments\n    /// must also return 0 until the Transfer event has been emitted. If _currencySymbol == 'ETH',\n    /// then this function must return the same result as if `getTransferFee(uint256 _tokenId)` was called.\n    /// @param _tokenId The NFT to find the Transfer Fee amount for\n    /// @param _currencySymbol The currency in which the fee is to be paid\n    /// @return The amount of Wei that need to be sent along a call to a transfer function\n    function getTransferFee(uint256 _tokenId, string calldata _currencySymbol) external view returns (uint256){\n        //keccak256(bytes(\"ETH\")) == bytes32(0xaaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff4)\n        if(bytes32(0xaaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff4) == keccak256(bytes(_currencySymbol))){\n            return transferFees[_tokenId];\n        } else {\n            return 0;\n        }\n    }\n\n\n    function name() external pure returns(string memory _name){\n        return \"Cryptograph\";\n    }\n\n    function symbol() external pure returns(string memory _symbol){\n        return \"Cryptograph\";\n    }\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns(string memory){\n        require(isACryptograph[address(_tokenId)], \"_tokenId is not a Valid Cryptograph\");\n   \n        return string(abi.encodePacked(\"https://cryptograph.co/tokenuri/\", addressToString(address(_tokenId))));\n    }\n\n\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256){\n        return totalSupplyVar;\n    }\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256){\n        require(_index < totalSupplyVar, \"index >= totalSupply()\");\n        return uint256(index2665ToAddress[_index]);\n    }\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    ///  `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\n        require(_owner != address(0), \"_owner == 0\");\n        require(_index < balanceOfVar[_owner], \"_index >= balanceOf(_owner)\");\n\n        return indexedOwnership[_owner][_index];\n    }\n\n    /// @notice Get the address of a Cryptograph from their tokenID\n    /// @dev literally just a typecast\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the Cryptograph that would be associated with this ID\n    function addressFromTokenId(uint256 _tokenId) external pure returns (address){\n            return address(_tokenId);\n    }\n\n    /// @notice Get the tokenID of a Cryptograph from their address\n    /// @dev literally just a typecast\n    /// @param _tokenAddress The address for a Cryptograph\n    /// @return The tokenId of the Cryptograph that would be associated with this address\n    function tokenIdFromAddress(address _tokenAddress) external pure returns (uint256){\n            return uint256(_tokenAddress);\n    }\n\n    /// @notice Extend the renatus timer for a cryptograph\n    /// @dev only callable by approved operators or the owner\n    /// @param _tokenId The identifier for an NFT\n    function renatus(uint256 _tokenId) public {\n        require(isACryptograph[address(_tokenId)], \"renatus need to be called for a Valid Cryptograph\");\n\n        address owner = TheCryptographLogicV1(address(_tokenId)).owner();\n        require(approvedOperator[owner][msg.sender] || owner == msg.sender);\n\n        //Extending the renatus timer\n        TheCryptographLogicV1(address(_tokenId)).renatus();\n    }\n\n    /// @notice Emit a Renatus transfer event destroying the token for it to be reborn later\n    /// @dev only callable by the token itself\n    function triggerRenatus() public{\n        require(isACryptograph[msg.sender], \"Only the token itself can notify us of a renatus hapenning\");\n        emit Transfer(TheCryptographLogicV1(address(msg.sender)).owner(), address(0), uint256(msg.sender));\n    }\n    \n    /// @notice Transfer a cryptograph in the ERC2665 proxy\n    /// @dev Will fire the Transfer event and update the enumerable arrays, as well as setting the new transfer fee\n    /// @param _from The address of the previous owner\n    /// @param _to The address of the new owner\n    /// @param _cryptograph The address of the cryptrograph\n    /// @param _lastSoldFor The amount of the last cryptograph platform transaction for this cryptograph\n    function transferACryptographInternal(address _from, address _to, address _cryptograph, uint256 _lastSoldFor) internal{\n\n        //Check that the Cryptograph exist\n         require(isACryptograph[_cryptograph], \n            \"Only minted cryptogrtaphs can be transferred\");\n\n        //Adjusting the last sold and transfer fees\n        if(_lastSoldFor != lastSoldFor[uint256(_cryptograph)]){\n            lastSoldFor[uint256(_cryptograph)] = _lastSoldFor;\n        }\n\n        //Checking if the fee was prepaid\n        if(!transferFeePrepaid[uint256(_cryptograph)]){\n            transferFees[uint256(_cryptograph)] = (_lastSoldFor * 15) / 100; //15% transfer fee\n        } else {\n            transferFees[uint256(_cryptograph)] = 0;\n        }\n        transferFeePrepaid[uint256(_cryptograph)] = false;\n  \n\n        //Reseting the approved address\n        approvedTransferAddress[uint256(_cryptograph)] = address(0);\n\n\n        //Emitting the event\n        emit Transfer(_from, _to, uint256(_cryptograph));\n\n        uint256 posInArray;\n\n        //Adjusting the ownership array of the actors\n        if(_from != address(0x0)){\n\n            if(balanceOfVar[_from] != 1){\n\n                //Case where we still have more cryptographs in the index.\n\n                //Grabbing the position of the transferred cryptograph in the previous owner ownership array\n                posInArray = cryptographPositionInOwnershipArray[uint256(_cryptograph)];\n\n                //Replacing this position content with the content of the last element in the owner array;\n                indexedOwnership[_from][posInArray] = indexedOwnership[_from][balanceOfVar[_from]-1];\n\n                //Updating the last element new index position\n                cryptographPositionInOwnershipArray[indexedOwnership[_from][posInArray]] = posInArray;\n\n                //refund some gas\n                delete indexedOwnership[_from][balanceOfVar[_from]-1];\n\n            }  else {\n                //refund some gas\n                delete indexedOwnership[_from][0];\n            }\n        }\n\n        //Some caching\n        posInArray = balanceOfVar[_to];\n\n        //Adjusting the arrays of the receiver\n        if(_to != address(0x0)){\n\n            if(indexedOwnership[_to].length < posInArray + 1){\n                indexedOwnership[_to].push(uint256(_cryptograph));\n            } else {\n                indexedOwnership[_to][posInArray] = uint256(_cryptograph);\n            }\n\n            cryptographPositionInOwnershipArray[uint256(_cryptograph)] = posInArray;\n        }\n\n        //Adjusting the balance of the actors\n        balanceOfVar[_from] = balanceOfVar[_from] - 1;\n        balanceOfVar[_to] = balanceOfVar[_to] + 1;\n\n    }\n\n\n    /// @notice transferACryptograph following a TransferFrom call to an ERC2665 endpoint\n    /// @dev Will call the transferInternal as part of the process as well as notify the ecosystem of necessary changes.\n    /// @param _from The address of the previous owner\n    /// @param _to The address of the new owner\n    /// @param _tokenId The tokenID of the cryptrograph\n    /// @param _sender The adress of the msg.sender of the endpoint\n    /// @param _value The amount of ETH paid with the endpoint call\n    function transferFromInternal(address _from, address _to, uint256 _tokenId, address _sender, uint256 _value) internal{\n\n        //Check that the fee is being paid\n        require(_value >= transferFees[_tokenId], \n            \"The transfer fee must be paid\");\n\n        //Check that the _from token owner is correct\n        address owner = TheCryptographLogicV1(address(_tokenId)).owner();\n        require(owner == _from,\n            \"The owner of the token and _from did not match\");\n\n        //Check that the msg.sender is legitimate to manipulate the token\n        require(_sender == owner || approvedOperator[owner][_sender] || approvedTransferAddress[_tokenId] == _sender, \"The caller is not allowed to transfer the token\");\n\n        //Calculate how much extra fee was sent\n        uint256 leftover = _value - transferFees[_tokenId];\n\n        //ERC2665 Transfer\n        transferACryptographInternal(_from, _to, address(_tokenId), lastSoldFor[_tokenId]);\n\n        //Actual Transfer will also check that there is no auction going on\n        AuctionHouseLogicV1(auctionHouse).transferERC2665{value:  _value - leftover}(address(_tokenId), _sender, _to);\n\n        //Check if the next fee is also paid\n        if(leftover >= transferFees[_tokenId]){\n            //pay the next transfer fee\n            leftover =  leftover - transferFees[_tokenId];\n            transferFees[_tokenId] = 0;\n        }\n\n        if(leftover != 0){\n            //Send back the extra money to the payer\n            (bool trashBool, ) = _sender.call{value:leftover}(\"\");\n            require(trashBool, \"Could not send the leftover money back\");\n        }\n    }\n\n\n    /// @notice Convert an Ethereum address to a human readable string\n    /// @param _addr The adress you want to convert\n    /// @return The address in 0x... format\n    function addressToString(address _addr) internal pure returns(string memory)\n    {\n        bytes32 addr32 = bytes32(uint256(_addr)); //Put the address 20 byte address in a bytes32 word\n        bytes memory alphabet = \"0123456789abcdef\";  //What are our allowed characters ?\n\n        //Initializing the array that is gonna get returned\n        bytes memory str = new bytes(42);\n\n        //Prefixing\n        str[0] = '0';\n        str[1] = 'x';\n\n        for (uint256 i = 0; i < 20; i++) { //iterating over the actual address\n\n            /*\n                proper offset : output starting at 2 because of '0X' prefix, 1 hexa char == 2 bytes.\n                input starting at 12 because of 12 bytes of padding, byteshifted because 2byte == 1char\n            */\n            str[2+i*2] = alphabet[uint8(addr32[i + 12] >> 4)];\n            str[3+i*2] = alphabet[uint8(addr32[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    /// @notice Check if an address is a contract\n    /// @param _address The adress you want to test\n    /// @return true if the address has bytecode, false if not\n    function isContract(address _address) internal view returns(bool){\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(_address) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n}\n"},"browser/ERC2665V1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity ^0.6.6;\n\n/// @title ERC-2665 NFT Transfer Fee Extension\n/// @dev See https://github.com/ethereum/EIPs/issues/2665\n///  Note: the ERC-165 identifier for this interface is 0x509ffea4.\n///  Note: you must also implement the ERC-165 identifier of ERC-721, which is 0x80ac58cd.\ninterface ERC2665 /* is ERC165, is ERC721 but overide it's Design by contract specifications */ {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `msg.value` < `getTransferFee(_tokenId)`.\n    ///  If the fee is not to be paid in ETH, then token publishers SHOULD provide a way to pay the\n    ///  fee when calling this function or it's overloads, and throwing if said fee is not paid.\n    ///  Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.\n    ///  When transfer is complete, this function checks if `_to` is a smart\n    ///  contract (code size > 0). If so, it calls `onERC2665Received` on `_to`\n    ///  and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC2665Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. Throws if `msg.value` < `getTransferFee(_tokenId)`.\n    ///  If the fee is not to be paid in ETH, then token publishers SHOULD provide a way to pay the\n    ///  fee when calling this function and throw if said fee is not paid.\n    ///  Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner. After a successful call and if\n    ///  `msg.value == getTransferFee(_tokenId)`, then a subsequent atomic call to\n    ///  `getTransferFee(_tokenId)` would eval to 0. If the fee is not to be paid in ETH,\n    ///  then token publishers MUST provide a way to pay the fee when calling this function,\n    ///  and throw if the fee is not paid.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n\n    /// @notice Query what is the transfer fee for a specific token\n    /// @dev If a call would returns 0, then any subsequent calls witht the same argument\n    /// must also return 0 until the Transfer event has been emitted.\n    /// @param _tokenId The NFT to find the Transfer Fee amount for\n    /// @return The amount of Wei that need to be sent along a call to a transfer function\n    function getTransferFee(uint256 _tokenId) external view returns (uint256);\n\n    /// @notice Query what is the transfer fee for a specific token if the fee is to be paid\n    /// @dev If a call would returns 0, then any subsequent calls with the same arguments\n    /// must also return 0 until the Transfer event has been emitted. If _currencySymbol == 'ETH',\n    /// then this function must return the same result as if `getTransferFee(uint256 _tokenId)` was called.\n    /// @param _tokenId The NFT to find the Transfer Fee amount for\n    /// @param _currencySymbol The currency in which the fee is to be paid\n    /// @return The amount of Wei that need to be sent along a call to a transfer function\n    function getTransferFee(uint256 _tokenId, string calldata _currencySymbol) external view returns (uint256);\n\n}\n\n\ninterface ERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0xac3cf292.\ninterface ERC2665TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC2665 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC2665Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC2665Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface ERC721Metadata /* is ERC721 */ {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns(string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns(string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n    ///  Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns(string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface ERC721Enumerable /* is ERC721 */ {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    ///  them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    ///  (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    ///  `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    ///   (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n\ncontract ERC2665HeaderV1 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved);\n}\n\ncontract ERC2665StorageInternalV1 {\n    address payable internal auctionHouse;\n    address internal indexCry;\n\n    mapping(address => bool) internal isACryptograph;\n\n    mapping(address => uint256) internal balanceOfVar;\n\n    uint256 internal totalSupplyVar;\n    mapping(uint256 => address) internal index2665ToAddress;\n\n    mapping(address => uint256[]) internal indexedOwnership; //[Owner][index] = cryptographID\n    mapping(uint256 => uint256) internal cryptographPositionInOwnershipArray; // [cryptographID] = index\n    mapping(uint256 => uint256) internal lastSoldFor; //Value last sold on the cryptograph platform\n    mapping(uint256 => uint256) internal transferFees; //Pending transfer fee\n    mapping(uint256 => bool) internal transferFeePrepaid; //Have the next transfer fee be prepaid ?\n    mapping(uint256 => address) public approvedTransferAddress; //Address allowed to Transfer a token\n    mapping(address => mapping(address => bool)) internal approvedOperator; //Approved operators mapping\n\n}\n\ncontract ERC2665StoragePublicV1 {\n    address payable public auctionHouse;\n    address public indexCry;\n\n    mapping(address => bool) public isACryptograph;\n\n    mapping(address => uint256) public balanceOfVar;\n\n    uint256 public totalSupplyVar;\n    mapping(uint256 => address) public index2665ToAddress;\n\n    mapping(address => uint256[]) public indexedOwnership; //[Owner][index] = cryptographID\n    mapping(uint256 => uint256) public cryptographPositionInOwnershipArray; // [cryptographID] = index\n    mapping(uint256 => uint256) public lastSoldFor; // Value last sold on the cryptograph platform\n    mapping(uint256 => uint256) public transferFees; // Pending transfer fee\n    mapping(uint256 => bool) public transferFeePrepaid; //Have the next transfer fee be prepaid ?\n    mapping(uint256 => address) public approvedTransferAddress; //Address allowed to Transfer a token\n    mapping(address => mapping(address => bool)) public approvedOperator; //Approved operators mapping\n}\n"},"browser/EditionIndexerLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./EditionIndexerV1.sol\";\n\n/// @title Edition Indexer Logic Contract\n/// @author Guillaume Gonnaud\n/// @notice Provides the logic code for publishing and interacting with editions, nested into the Cryptograph Indexer\n/// @dev This contract and its functions should be called by the relevant proxy smart contract only\ncontract EditionIndexerLogicV1 is VCProxyData, EditionIndexerHeaderV1, EditionIndexerStoragePublicV1  {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that require to be called only by the index\n    modifier restrictedToIndex(){\n        require((msg.sender == index), \"Only the cryptograph index smart contract can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the Indexer, starting at index 1\n    /// @dev Callable only once after instanciation\n    /// @param _index The address of the parent, main indexer\n    /// @param _minter The address of the minter for this edition\n    /// @param _editionSize The maximum number of cryptographs in this edition\n    /// @return true\n    function init(address _index, address _minter, uint256 _editionSize) external returns(bool){\n        require(!initialized, \"This Edition Indexer has already been initialized\");\n        index = _index;\n        minter = _minter;\n        editionSize = _editionSize;\n        initialized = true;\n        cryptographs.push(address(0x0)); //There is no cryptograph edition with serial 0\n        return true;\n    }\n\n    /// @notice Init function of the Indexer, starting at index 0\n    /// @dev Callable only once after instanciation\n    /// @param _index The address of the parent, main indexer\n    /// @param _minter The address of the minter for this edition\n    /// @param _editionSize The maximum number of cryptographs in this edition\n    /// @return true\n    function init0(address _index, address _minter, uint256 _editionSize) external returns(bool){\n        require(!initialized, \"This Edition Indexer has already been initialized\");\n        index = _index;\n        minter = _minter;\n        editionSize = _editionSize;\n        initialized = true;\n        return true;\n    }\n\n    /// @notice Insert a cryptograph in the array and return the new index position\n    /// @dev Callable only by the index\n    /// @param _cryptograph The address of the inserted cryptograph\n    /// @param _minter The address of the minter for this cryptograph\n    /// @return The new position in the array\n    function insertACryptograph(address _cryptograph, address _minter) external restrictedToIndex() returns(uint){\n        require(cryptographs.length <= editionSize, \"The full amount of Cryptographs for this edition has been published\");\n        require(_minter == minter, \"Only the publisher can mint new Cryptographs for this edition\");\n        cryptographs.push(_cryptograph);\n        return (cryptographs.length - 1); //Inserting the cryptograph and returning the position in the array\n    }\n\n    /// @notice Insert a cryptograph in the array at a specific position\n    /// @dev Callable only by the index. Must be smaller than edition size. HAS A LOOP.\n    /// @param _cryptograph The address of the inserted cryptograph\n    /// @param _index The desired position\n    function insertACryptographAt(address _cryptograph, uint256 _index) external restrictedToIndex(){\n\n        if(cryptographs.length <= _index){\n            while(cryptographs.length <= _index){\n                cryptographs.push();\n            }\n        }\n        cryptographs[_index] = _cryptograph; //Inserting the cryptograph\n    }\n\n}\n\n"},"browser/EditionIndexerProxiedV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./EditionIndexerV1.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title  Cryptograph Edition Indexer Proxy Smart Contract\n/// @notice The proxied Edition Indexer : this is the contract that will be instancied on the blockchain. Cast this as the logic contract to interact with it.\ncontract EditionIndexerProxiedV1 is VCProxy, EditionIndexerHeaderV1, EditionIndexerStorageInternalV1  {\n\n    constructor(uint256 _version, address _vc)  public\n    VCProxy(_version, _vc) //Calls the VC proxy constructor so that we know where our logic code is\n    {\n        //Self intialize (nothing)\n    }\n\n    //No other logic code as it is all proxied\n\n}\n\n\n\n"},"browser/EditionIndexerV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Edition Indexer Header\n/// @notice Contain all the events emitted by the Edition Indexer\ncontract EditionIndexerHeaderV1 {\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Edition Indexer Storage Internal\n/// @notice Contain all the storage of the Edition Indexer declared in a way that don't generate getters for Proxy use\ncontract EditionIndexerStorageInternalV1 {\n    bool internal initialized; //Bool to check if the indexer have been initialized\n    address internal minter; //The address of the minter, the only person allowed to add new cryptographs\n    address internal index; //The address of the index, the only address allowed to interact with the publishing functions\n    uint256 internal editionSize; //The total amount of cryptographs to be minted in this edition\n    address[] internal cryptographs;\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Edition Indexer Storage Public\n/// @notice Contain all the storage of the Edition Indexer declared in a way that generate getters for Logic use\ncontract EditionIndexerStoragePublicV1 {\n    bool public initialized; //Bool to check if the index has been initialized\n    address public minter; //The address of the minter, only person allowed to add new cryptographs\n    address public index; //The address of the index, only address allowed to interact with the publishing functions\n    uint256 public editionSize; //The total amount of cryptographs to be minted in this edition\n    address[] public cryptographs;\n}\n\n"},"browser/MintingAuctionLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./MintingAuctionV1.sol\";\nimport \"./CryptographFactoryV1.sol\";\nimport \"./AuctionHouseLogicV1.sol\";\nimport \"./TheCryptographLogicV1.sol\";\nimport \"./CryptographInitiator.sol\";\nimport \"./BidLink.sol\";\n\n/*\n    This contract idea is rather complex.\n    => Implement a Generalized GBM Auction (GGBMA) for initial supply of a series of limited editions within the same auction (instead of each token being sold independantly)\n\n    >During the initial sale, everyone can place a bid at any amount of money (one exception, see below)\n    >You can't retract your bid\n    >You can only have one active bid, and can only re-bid higher than YOUR previous bid\n    >If you want to place a bid higher than the current highest bid, it need to be at least 5% higher\n    >When the top bid is being displaced by a new bid, the previous top bid owner receive GBM incentives. All others bidders don't\n    >No new bid can be placed after the initial period\n    >At the end of the auction, you can mint a cryptograph where the serial # match your position in the auction\n        -> Highest bidder get #1, second highest get #2, etc...\n    >If there was a limited supply, any bidder that was ranked below the supply amount can cancel their bid and recover the eth\n\n*/\n\n/// @author Guillaume Gonnaud 2019\n/// @title Minting Auction Logic Code\n/// @notice Based on the Single Auction smart contracts but with overrides\ncontract MintingAuctionLogicV1 is VCProxyData, MintingAuctionHeaderV1, MintingAuctionStoragePublicV1 {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall hence its memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that requires to be called only by the Auction house\n    modifier restrictedToAuctionHouse(){\n        require((msg.sender == auctionHouse), \"Only the auction house smart contract can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the MintingAuction\n    /// @param _myCryptograph The address of the cryptograph this auction is paired with\n    /// @param _cryInitiator The address of the initator containing the details of our auction\n    /// @param _initialize true => can't change any spec afterward. false => can initialize again.\n    function initAuction(\n            address _myCryptograph,\n            address _cryInitiator,\n            bool _initialize\n        ) public {\n\n        require(!initialized, \"This auction is already initialized\");\n        initialized = _initialize; //Are we locking ?\n\n        //we must be either perpetual altruism OR never inited before\n        require(auctionHouse == address(0) || msg.sender == cryFactory,\"Only Perpetual altruism can change a yet to be locked auction\");\n        cryFactory = msg.sender;\n\n        /*\n        ==================================================\n                            Bidding section\n        ==================================================\n        */\n\n        startingPrice = CryptographInitiator(_cryInitiator).startingPrice(); //The first bid that needs to be outbid is 1 Wei\n        sellingPrice = 0; //A newly minted Cryptograph does not have an owner willing to sell\n\n        /*\n        ==================================================\n                        Calculations section\n        ==================================================\n        */\n        bid_Decimals = 100000;  //100k, or 100%\n        bid_incMax = 10000; //10k, or 10%\n        bid_incMin = 1000; //1k, or 1%\n        bid_stepMin = 10500; //10.5k, or 10.5%\n        bid_cutOthers = 500; // 500, or 0.5%\n        bid_multiplier = 9000; //9000 = Doubling bid yield max gain (1%+9% = 10%)\n\n        /*\n        ==================================================\n                            Money section\n        ==================================================\n        */\n        //Setting up money flow\n        perpertualAltruism = CryptographFactoryStoragePublicV1(cryFactory).officialPublisher();\n        perpetualAltruismCut = CryptographInitiator(_cryInitiator).perpetualAltruismCut();\n        publisher = CryptographInitiator(_cryInitiator).publisher();\n        publisherCut = CryptographInitiator(_cryInitiator).publisherCut();\n        charity = CryptographInitiator(_cryInitiator).charity();\n        charityCut = CryptographInitiator(_cryInitiator).charityCut();\n        thirdParty = CryptographInitiator(_cryInitiator).thirdParty();\n        thirdPartyCut = CryptographInitiator(_cryInitiator).thirdPartyCut();\n        maxSupply = CryptographInitiator(_cryInitiator).maxSupply();\n\n        //Setting up timings\n\n        startTime = CryptographInitiator(_cryInitiator).auctionStartTime();\n        endTime = CryptographInitiator(_cryInitiator).auctionStartTime() + CryptographInitiator(_cryInitiator).auctionSecondsDuration();\n\n        auctionHouse = CryptographFactoryStoragePublicV1(cryFactory).targetAuctionHouse();\n        myCryptograph = _myCryptograph;\n        initiator = _cryInitiator;\n    }\n\n    /// @notice Make an official auction unmodifiable once we are certain the parameters are correct\n    /// @dev Only callable by perpetual altruism\n    function lock() external{\n        require(msg.sender == cryFactory, \"Only Perpetual altruism can lock the initialization\");\n        initialized = true;\n    }\n\n    /// @notice Place a bid to own a cryptograph and distribute the incentives\n    /// @dev Only callable by the Auction House\n    /// @param _newBidAmount The amount of the new bid\n    /// @param _newBidder The address of the bidder\n    function bid(uint256 _newBidAmount, address _newBidder) external payable restrictedToAuctionHouse(){\n\n        /*\n        ========================== money check ==========================\n        */\n\n        //Unitiliazed cryptographs can't be bid upon\n        require(initialized, \"This auction has not been properly set up yet\");\n        //Did we send the proper amount of money, are we allowed to bid ?\n        require(_newBidAmount == msg.value + currentBids[_newBidder], \"Amount of money sent incorrect\"); //Also protects from self-underbiding\n        //check to be made : is the new bid big enough ?\n        require(numberOfBids != maxSupply || currentBids[tailBidder] < _newBidAmount, \"Your bid is lower than the lowest bid\");\n\n        require( //Either fresh bid OR meeting the standing bid * the step OR below highest bidder\n                    ( (highestBidder == address(0)) && startingPrice <= _newBidAmount ) ||\n                    ( (highestBidder != address(0)) && (currentBids[highestBidder] * (bid_Decimals + bid_stepMin) <= (_newBidAmount * bid_Decimals) )) ||\n                    (  (highestBidder != address(0)) && (currentBids[highestBidder] >= _newBidAmount) ),\n                \"New bid amount does not meet an authorized amount\");\n\n        /*\n        ========================== Timing check ==========================\n        */\n\n        //We must be past the initial auction start\n        require(now >= startTime, \"You can only bid once the initial auction has started\");\n        require(now < endTime, \"GGMBA do not allow bidding past the ending time\");\n\n        //Emit the bid acceptance event before triggering the payouts\n        emit BidAccepted(_newBidAmount, _newBidder);\n\n        /*\n        ========================== Payouts ==========================\n        */\n\n        uint256 duePay;\n        //if we are not an underbidder...\n        if((currentBids[highestBidder] < _newBidAmount)){\n            //In a GGBMA, every new highest bidder pays a 0.5% fee\n            duePay = (_newBidAmount * bid_cutOthers)/bid_Decimals;\n            unsettledPayouts += duePay;\n            distributeStakeholdersPayouts(duePay, _newBidder);\n            //Send the payout to the previous highest bidder\n            if(highestBidder != address(0)){\n                duePay = duePayout[highestBidder];\n                if(duePay != 0){\n                    unsettledPayouts += duePay;\n                    emit Payout(duePay,  highestBidder,  _newBidder);\n                    AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: duePay }(highestBidder, _newBidder);\n                }\n            }\n\n            /*\n            ========================== Reward ==========================\n            */\n\n            //Set the new payout amount we will receive when outbid (Only for new highest bidders)\n            calculateReward(_newBidAmount, _newBidder);\n        }\n\n        /*\n        ===================== Bid Cancellation And Registering =====================\n        */\n        uint256 toSend;\n\n        //We need to cancel our own previous lower bid OR to update the number of bids\n        if(currentBids[_newBidder] != 0){\n\n            BidLink(bidLinks[_newBidder]).setBidAmount(_newBidAmount); //Updating our bid amount\n\n            //Updating our neigbors link\n            if( BidLink(bidLinks[_newBidder]).above() != address(0x0)){\n                BidLink(BidLink(bidLinks[_newBidder]).above()).setBelow(BidLink(bidLinks[_newBidder]).below()); //Unlinking above us\n            }\n\n            if( BidLink(bidLinks[_newBidder]).below() != address(0x0)){\n                BidLink(BidLink(bidLinks[_newBidder]).below()).setAbove(BidLink(bidLinks[_newBidder]).above()); //Unlinking below us\n            }\n            emit BidCancelled(currentBids[_newBidder], currentBids[_newBidder], _newBidder); //Emitting the event\n\n        } else {\n            //Create a bid link\n            bidLinks[_newBidder] = address(new BidLink(_newBidder, _newBidAmount));\n\n            //Refunding/Setting the tail.\n            if(numberOfBids == maxSupply && maxSupply != 0){\n                //Max number of bids reached, refunding the tail bid\n                toSend = currentBids[tailBidder];\n                currentBids[tailBidder] = 0;\n                if(toSend != 0){\n                    //Send back all the money : no payout settlement required\n                    emit BidCancelled(toSend, toSend, tailBidder);\n                    AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(tailBidder, tailBidder);\n                }\n                //Updating the tail bid\n                BidLink(BidLink(bidLinks[tailBidder]).above()).setBelow(address(0x0)); //Unlinking\n                tailBidder = BidLink(BidLink(bidLinks[tailBidder]).above()).bidder(); //Updating the tail\n\n\n            } else {\n                //Max not reached\n                numberOfBids++;\n            }\n        }\n\n\n\n        currentBids[_newBidder] = _newBidAmount; //Set the amount of the bid\n\n        //Browse the BidLink chain until the link above us have a bid greater or equal to us\n        address currentLink = bidLinks[highestBidder];\n\n        if(currentLink == address(0x0)){\n            tailBidder = _newBidder; //We are the only bidder = we are also the lowest bidder\n        } else {\n            //Browsing down the linked list\n            while( BidLink(currentLink).below() != address(0x0) && BidLink(BidLink(currentLink).below()).bidAmount() >= _newBidAmount){\n                    currentLink = BidLink(currentLink).below(); //Browse the chain\n            }\n        }\n\n        //Are we the new highest bidder ?\n        if(currentBids[highestBidder] < _newBidAmount){\n            highestBidder = _newBidder; //We are the highest bidder\n            BidLink(bidLinks[_newBidder]).setBelow(currentLink); //Setting ourselves as above the old head\n            if(currentLink != address(0x0)){    //Only if there is a previous head\n                BidLink(currentLink).setAbove(bidLinks[_newBidder]); //Setting the old head as below us\n            }\n        } else { //Normally inserting ourself in the chain\n            BidLink(bidLinks[_newBidder]).setAbove(currentLink); //Above us is the current link\n            BidLink(bidLinks[_newBidder]).setBelow(BidLink(currentLink).below()); //Below us is the previous tail of the current link\n            if(BidLink(bidLinks[_newBidder]).below() != address(0x0)){  //If we have a new tail\n                BidLink(BidLink(bidLinks[_newBidder]).below()).setAbove(bidLinks[_newBidder]); //We are above our new tail\n            } else {\n                //We are the new tail\n                tailBidder = _newBidder;\n            }\n            //We should always have a new head (as we are not highest bidder)\n            BidLink(BidLink(bidLinks[_newBidder]).above()).setBelow(bidLinks[_newBidder]); //Our new head has us as a tail\n        }\n\n        //The chainlink is now ordered properly\n\n    }\n\n    /// @notice USed to check which can of auction we are\n    /// @dev Only callable by the Auction House.\n    /// @param _newOwner The address of the bidder wishing to mint a new cryptograph\n    /// @return 0 if a normal auction, 1 if a minting auction\n    function win(address _newOwner) external restrictedToAuctionHouse() view returns(uint){\n        require(currentBids[_newOwner] != 0, \"You don't have any active bid on this auction\");\n        require(now > endTime, \"The initial auction is not over yet\");\n\n        return 1;\n    }\n\n    /// @notice Distribute the bid of an auction winner\n    /// @dev Only callable by the Auction House.\n    /// @param _newOwner The address of the bidder wishing to mint a new cryptograph\n    function distributeBid(address _newOwner) external restrictedToAuctionHouse(){\n\n         if(_newOwner == highestBidder){\n            distributeStakeholdersPayouts(currentBids[highestBidder] - unsettledPayouts, _newOwner); //Payouts are deduced from the highest bid\n        } else {\n            distributeStakeholdersPayouts(currentBids[_newOwner], _newOwner);\n        }\n\n        currentBids[_newOwner] = 0;\n    }\n\n    /// @notice Function used to distribute an arbitrary amount of money among non-bidders\n    /// @dev Only callable internally\n    /// @param _amount The amount of money to spread\n    /// @param _contributor The address of the gracious donor\n    function distributeStakeholdersPayouts(uint256 _amount, address _contributor) internal{\n        uint256 toDistribute = _amount;\n        uint256 toSend;\n\n        //Pay the charity\n        toSend = (charityCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  charity,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(charity, _contributor);\n        }\n\n        //Pay the publisher\n        toSend = (publisherCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  publisher,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(publisher, _contributor);\n        }\n\n        //Pay the thirdParty\n        toSend = (thirdPartyCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  thirdParty,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(thirdParty, _contributor);\n        }\n\n        //Pay perpetual Altruism the reminder (25%). only non-null guaranteed address, so send any rounding errors there\n        toSend = toDistribute;\n        if(toSend != 0){\n            emit Payout(toSend,  perpertualAltruism,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(perpertualAltruism, _contributor);\n        }\n    }\n\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\n    /// @dev Only callable internally\n    /// @param _newBid The amount of money in the new bid\n    /// @param _bidder The address of the new bidder\n    function calculateReward(uint256 _newBid, address _bidder) internal{\n\n        //Calculating how much payout we will receive if we are outbid\n\n        //Init the baseline bid we need to perform against\n        uint256 baseBid = currentBids[highestBidder] * (bid_Decimals + bid_stepMin) / bid_Decimals;\n        if(baseBid == 0){\n            baseBid = startingPrice;\n\n            //Do not divide by 0\n            if(baseBid == 0){\n                baseBid = 1;\n            }\n        }\n\n        //We calculate our baseline reward. We square the decimals to guarantee a granularity of at least 1/bid_Decimals instead of 1/bid_multiplier\n        //This also somewhat limits the hardcap for a reward to max_UInt256/10^11 => Not a problem as this amount of eth will not be minted\n        uint256 decimaledRatio = ((bid_Decimals * bid_multiplier * (_newBid - baseBid) ) / baseBid) + bid_incMin * bid_Decimals;\n\n        //If we go over the maximum payout, we set the reward to the maximum payout\n        if(decimaledRatio > (bid_Decimals * bid_incMax)){\n            decimaledRatio = bid_Decimals * bid_incMax;\n        }\n\n        duePayout[_bidder] = (_newBid * decimaledRatio)/(bid_Decimals*bid_Decimals);\n    }\n}\n"},"browser/MintingAuctionProxiedV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./MintingAuctionV1.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title  Minting Auction Proxy Smart Contract\n/// @notice The Minting Auction proxy : this is this contract that will be instancied on the blockchain. Cast this as the logic contract to interact with it.\ncontract MintingAuctionProxiedV1 is VCProxy, MintingAuctionHeaderV1, MintingAuctionStorageInternalV1  {\n\n    constructor(uint256 _version, address _vc)  public\n    VCProxy(_version, _vc) //Call the VC proxy constructor so that we know where our logic code is\n    {\n        //Self intialize (nothing)\n    }\n\n}\n\n"},"browser/MintingAuctionV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Minting Auction Header\n/// @notice Contain all the events emitted by the Minting Auction\ncontract MintingAuctionHeaderV1 {\n    event BidAccepted(uint256 bidValue, address bidder);\n    event Payout(uint256 amount, address beneficiary, address contributor);\n    event BidCancelled(uint256 bidValue, uint256 ethReturned, address bidder);\n    event SaleStarted(address seller, uint256 hammerTime, uint256 hammerBlock);\n    event SellingPriceAdjusted(address seller, uint256 amount);\n    event Win(address buyer, address seller, uint256 bidValue);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Minting Auction Storage Internal\n/// @notice Contain all the storage of the Minting Auction declared in a way that don't generate getters for Proxy use\ncontract MintingAuctionStorageInternalV1 {\n\n     /*\n    ==================================================\n                        Bidding section\n    ==================================================\n    */\n\n    //The current bids made by each address\n    mapping (address => uint) internal currentBids;\n\n    //The current amount of wei each address receive when outbid as the highest bid.\n    mapping (address => uint) internal duePayout; //How much the bidder make\n\n    //The current highest bidder;\n    address internal highestBidder;\n\n    //The current amount of unsettled payouts distributed for the current bidding process\n    uint256 internal unsettledPayouts;\n\n    //The default starting price\n    uint256 internal startingPrice;\n\n    //The current selling price\n    uint256 internal sellingPrice;\n\n    /*\n    ==================================================\n                        Calculations section\n    ==================================================\n    */\n\n    /*\n    For a standing bid s and a new bid n, we express the return on the new bid as:\n\n    incentive(n,s) % = min[ incmax , incmin + m * (n- s * (1+ stepmin)) / (s * (1+ stepmin))]\n\n    Where:\n    stepmin is the minimum bid increment, expressed as a fraction of the current standing bid (ex : 0.01 for 1/10 or 10%)\n    incmin is the minimum incentive, expressed as a fraction\n    incmax is the maximum incentive, expressed as a fraction\n    m is the multiplier effect, expressed as a positive real number\n\n    */\n\n    //Values used to calculate the payouts.\n    uint256 internal bid_Decimals; //100k, or 100%\n    uint256 internal bid_incMax; //4.5k, or 4.5%\n    uint256 internal bid_incMin; //1k, or 1%\n    uint256 internal bid_stepMin; //5k, or 5%\n    uint256 internal bid_cutOthers; // 500, or 0.5%\n\n    uint256 internal bid_multiplier; //Will be divided by 100 for the calulations. 100 mean that doubling the bid mean 1% extra return\n\n    /*\n    ==================================================\n                        Money section\n    ==================================================\n    */\n\n    address internal publisher; //The address of the publisher of the cryptograph. Can edit media url and hash.\n    address internal charity; //The address to which the chartity cut is being sent to\n    address internal thirdParty; //The address of any third party taking a cut\n    address internal perpertualAltruism; //The perpetual altruism address\n\n    //The granularity of the redistribution is 0.001%. 100 000 = all the money\n    uint256 internal publisherCut;\n    uint256 internal charityCut;\n    uint256 internal thirdPartyCut;\n    uint256 internal perpetualAltruismCut;\n\n    /*\n    ==================================================\n                        Timing section\n    ==================================================\n    */\n    uint256 internal startTime; //The start date of the initial auction\n    uint256 internal endTime; //The end date of the initial auction\n\n    /*\n    ==================================================\n                        Binding section\n    ==================================================\n    */\n    address internal auctionHouse; //The address of the auction house\n    address internal myCryptograph; //The address of the Cryptograph I'm administrating\n    address internal cryFactory; //The address of the cryptograph Factory\n\n    bool internal initialized;\n\n    //A mapping associating each bidder with their associated chainLink\n    mapping (address => address) internal bidLinks;\n\n    address internal initiator; //We keep the address of our initator for future minting\n\n    uint256 internal numberOfBids; //Current number of standing bids\n    uint256 internal maxSupply; //Maximum number of bid to keep\n    address internal tailBidder; //The address of the current bottom bidder\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Minting Auction Storage Public\n/// @notice Contain all the storage of the Minting Auction declared in a way that generate getters for Logic use\ncontract MintingAuctionStoragePublicV1 {\n      /*\n    ==================================================\n                        Bidding section\n    ==================================================\n    */\n\n    //The current bids made by each address\n    mapping (address => uint) public currentBids;\n\n    //The current amount of wei each address receive when outbid as the highest bid.\n    mapping (address => uint) public duePayout; //How much the bidder make\n\n    //The current highest bidder;\n    address public highestBidder;\n\n    //The current amount of unsettled payouts distributed for the current bidding process\n    uint256 public unsettledPayouts;\n\n    //The default starting price\n    uint256 public startingPrice;\n\n    //The current selling price\n    uint256 public sellingPrice;\n\n    /*\n    ==================================================\n                        Calculations section\n    ==================================================\n    */\n\n    /*\n    For a standing bid s and a new bid n, we express the return on the new bid as:\n\n    incentive(n,s) % = min[ incmax , incmin + m * (n- s * (1+ stepmin)) / (s * (1+ stepmin))]\n\n    Where:\n    stepmin is the minimum bid increment, expressed as a fraction of the current standing bid (ex : 0.01 for 1/10 or 10%)\n    incmin is the minimum incentive, expressed as a fraction\n    incmax is the maximum incentive, expressed as a fraction\n    m is the multiplier effect, expressed as a positive real number\n\n    */\n\n    //Values used to calculate the payouts.\n    uint256 public bid_Decimals; //100k, or 100%\n    uint256 public bid_incMax; //4.5k, or 4.5%\n    uint256 public bid_incMin; //1k, or 1%\n    uint256 public bid_stepMin; //5k, or 5%\n    uint256 public bid_cutOthers; // 500, or 0.5%\n\n    uint256 public bid_multiplier; //Will be divided by 100 for the calulations. 100 mean that doubling the bid mean 1% extra return\n\n    /*\n    ==================================================\n                        Money section\n    ==================================================\n    */\n\n    address public publisher; //The address of the publisher of the cryptograph. Can edit media url and hash.\n    address public charity; //The address to which the chartity cut is being sent to\n    address public thirdParty; //The address of any third party taking a cut\n    address public perpertualAltruism; //The perpetual altruism address\n\n    //The granularity of the redistribution is 0.001%. 100 000 = all the money\n    uint256 public publisherCut;\n    uint256 public charityCut;\n    uint256 public thirdPartyCut;\n    uint256 public perpetualAltruismCut;\n\n    /*\n    ==================================================\n                        Timing section\n    ==================================================\n    */\n    uint256 public startTime; //The start date of the initial auction\n    uint256 public endTime; //The end date of the initial auction\n\n    /*\n    ==================================================\n                        Binding section\n    ==================================================\n    */\n    address public auctionHouse; //The address of the auction house\n    address public myCryptograph; //The address of the Cryptograph I'm administrating\n    address public cryFactory; //The address of the cryptograph Factory\n\n    bool public initialized;\n\n    //A mapping associating each bidder with their associated chainLink\n    mapping (address => address) public bidLinks;\n\n    address public initiator; //We keep the address of our initator for future minting\n\n    uint256 public numberOfBids; //Current number of standing bids\n    uint256 public maxSupply; //Maximum number of bids to keep\n    address public tailBidder; //The address of the current bottom bidder\n\n}\n\n"},"browser/SingleAuctionBidLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./SingleAuctionV1.sol\";\nimport \"./CryptographFactoryV1.sol\";\nimport \"./AuctionHouseLogicV1.sol\";\nimport \"./TheCryptographLogicV1.sol\";\nimport \"./CryptographInitiator.sol\";\nimport \"./BidLinkSimple.sol\";\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Single Auction Bid Logic Code\n/// @notice Implements a GBM auction bid function. See white paper for the details. Logic code, to be casted on a proxy.\ncontract SingleAuctionBidLogicV1 is VCProxyData, SingleAuctionHeaderV1, SingleAuctionStorageInternalV1  {\n\n    //Modifier for functions that requires to be called only by the Auction house\n    modifier restrictedToAuctionHouse(){\n        require((msg.sender == auctionHouse), \"Only the auction house smart contract can call this function\");\n        _;\n    }\n\n\n    /// @notice Place a bid to own a cryptograph and distribute the incentives\n    /// @dev Only callable by the Auction House\n    /// @param _newBidAmount The amount of the new bid\n    /// @param _newBidder The address of the bidder\n    function bid(uint256 _newBidAmount, address _newBidder) external payable restrictedToAuctionHouse(){\n\n        /*\n        ========================== money check ==========================\n        */\n\n        //uninitialized  cryptographs can't be bid upon\n        require(initialized, \"This auction has not been properly setup yet\");\n\n        //Did we send the proper amount of money ?\n        require(_newBidAmount == msg.value + currentBids[_newBidder], \"Amount of money sent incorrect\");\n\n        //check to be made : is the new bid big enough ?\n        require( //Either fresh bid or meeting the standing bid * the step\n            ((highestBidder == address(0)) && startingPrice <= _newBidAmount) ||\n            ( (highestBidder != address(0)) && (currentBids[highestBidder] * (bid_Decimals + bid_stepMin) <= (_newBidAmount * bid_Decimals) )),\n            \"New bid amount does not meet the minimal new bid amount\");\n\n        /*\n        ========================== Timing check ==========================\n        */\n\n        //We must be past the initial auction start\n        require(now >= startTime, \"You can only bid once the initial auction has started\");\n\n        //Checking if an auction is not over\n        require((now < endTime && TheCryptographLogicV1(myCryptograph).owner() == address(0x0)) ||\n        (TheCryptographLogicV1(myCryptograph).owner() != address(0x0) && (hammerTime == 0 || now < hammerTime)),\n        \"The auction is over, the bid was rejected\");\n\n        //Extending the time at the end of the initial auction\n        if(endTime < now + 600 && TheCryptographLogicV1(myCryptograph).owner() == address(0x0)){\n            endTime = now + 600;\n        }\n\n        //If hammer time is non-zero, we must be before the end of hammerTime\n        //This allow potential bidders to come in.\n        if(hammerTime != 0 && now + 600 > hammerTime){\n            hammerTime = now + 600; //Extend the hammertime auction by 600s\n            hammerBlock = block.number + 4; //Extend the number of minimum elapsed block by 4\n        }\n\n\n        //Emit the bid acceptance event before triggering the payouts\n        emit BidAccepted(_newBidAmount, _newBidder);\n\n        /*\n        ========================== Payouts ==========================\n        */\n\n        //0.5% of the bid is sent to third parties\n        uint256 duePay;\n\n        //The first bid in perpetual trading is exempted from bidding fees\n        if(!(highestBidder == address(0) && TheCryptographLogicV1(myCryptograph).owner() != address(0))){\n            //If not, a bidding fee is taken and distrubuted\n            duePay = (_newBidAmount * bid_cutOthers)/bid_Decimals;\n            unsettledPayouts += duePay;\n            distributeStakeholdersPayouts(duePay, _newBidder);\n        }\n\n        //Send his payout to the previous highest bidder\n        duePay = duePayout[highestBidder];\n        if(duePay != 0){\n            unsettledPayouts += duePay;\n            emit Payout(duePay,  highestBidder,  _newBidder);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: duePay }(highestBidder, _newBidder);\n        }\n\n        /*\n        ========================== Reward ==========================\n        */\n\n        //Set the new payout amount we will receive when outbid\n        calculateReward(_newBidAmount, _newBidder);\n\n        /*\n        ===================== Bid Cancellation =====================\n        */\n        uint256 toSend;\n\n        if ( hammerTime != 0 || TheCryptographLogicV1(myCryptograph).owner() == address(0)) { //Ongoing sale\n            \n            if(highestBidder != _newBidder){\n                //We cancel and withdraw the current highest standing bid\n                toSend = currentBids[highestBidder];\n                if(toSend != 0){ //For the case of the first ever bid on an auction : address 0x0 is not cancelling anything...\n                    //Send back all the money : no payout settlement required\n                    emit BidCancelled(toSend, toSend, highestBidder);\n                    AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(highestBidder, highestBidder);\n                    //Edge case because of renatus : we may have a link of bids to maintain, so no reseting links\n                    delete currentBids[highestBidder];\n                    delete duePayout[highestBidder];\n                }\n            }\n        }\n\n            \n        if(currentBids[_newBidder] != 0){\n            emit BidCancelled(currentBids[_newBidder], 0, _newBidder);\n            //No need to send any back money to a self outbidder : this smart contract only receive the extra required amount\n\n            //Updating our neigbors link\n            if( BidLinkSimple(bidLinks[_newBidder]).above() != address(0x0)){\n                  BidLinkSimple(BidLinkSimple(bidLinks[_newBidder]).above()).setBelow(BidLinkSimple(bidLinks[_newBidder]).below()); //Unlinking above us\n            }\n\n            //We don't need to update the link below us if we are already the highest bidder\n            if(highestBidder != _newBidder){\n                if( BidLinkSimple(bidLinks[_newBidder]).below() != address(0x0)){\n                    BidLinkSimple(BidLinkSimple(bidLinks[_newBidder]).below()).setAbove(BidLinkSimple(bidLinks[_newBidder]).above()); //Unlinking below us\n                }\n            }\n        }\n        \n\n        /*\n        ===================== Bid Registering =====================\n        */\n\n        //Check if the bidder already had a link. Create one if not\n        if(bidLinks[_newBidder] == address(0x0)){\n            bidLinks[_newBidder] = address(new BidLinkSimple(_newBidder));\n        }\n\n        //Link our bidlink to the previous head, if it's not already us (which would mean no changes)\n        if(_newBidder != highestBidder){\n\n            //There is no one above us\n            BidLinkSimple(bidLinks[_newBidder]).setAbove(address(0x0));\n\n            if( hammerTime == 0 && TheCryptographLogicV1(myCryptograph).owner() != address(0)){ //We did not cancel the previous highest bidder\n                //The Link below us is the previous highest bidder\n                BidLinkSimple(bidLinks[_newBidder]).setBelow(bidLinks[highestBidder]);\n\n                //We are above the link below us\n                if(highestBidder != address(0x0)){\n                    BidLinkSimple(bidLinks[highestBidder]).setAbove(bidLinks[_newBidder]);\n                }\n\n            } else { //We just cancelled the previous highest bidder\n\n                //If said highest bidder existed\n                if(highestBidder != address(0x0)){\n\n                    //The bid below us is the bid that is currently below the still registered previous highest bidder\n                    BidLinkSimple(bidLinks[_newBidder]).setBelow(BidLinkSimple(bidLinks[highestBidder]).below());\n\n                    //We are also above said bid\n                    if(BidLinkSimple(bidLinks[highestBidder]).below() != address(0x0)){\n                       BidLinkSimple(BidLinkSimple(bidLinks[highestBidder]).below()).setAbove(bidLinks[_newBidder]);\n                    }\n\n\n                } else {\n                    //There is no one below us\n                    BidLinkSimple(bidLinks[_newBidder]).setBelow(address(0x0));\n                }\n            }\n        }\n\n        //Set the amount of the new highest bid\n        currentBids[_newBidder] = _newBidAmount;\n        highestBidder = _newBidder; //We are the new highest bidder\n\n        /*\n        ===================== Sales Trigger =====================\n        */\n\n        //If a selling price have been met, trigger a sale\n        if( sellingPrice != 0 && _newBidAmount >= sellingPrice && hammerTime == 0){\n            hammerTime = now + hammerTimeDuration;\n            hammerBlock = block.number + hammerBlockDuration;\n            emit SaleStarted(_newBidder, hammerTime, hammerBlock);\n        }\n    }\n\n    /// @notice Function used to distribute an arbitrary amount of money among non-bidders\n    /// @dev Only callable internally\n    /// @param _amount The amount of money to spread\n    /// @param _contributor The address of the source of the money\n    function distributeStakeholdersPayouts(uint256 _amount, address _contributor) internal{\n        uint256 toDistribute = _amount;\n        uint256 toSend;\n\n        //Pay the charity\n        toSend = (charityCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  charity,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(charity, _contributor);\n        }\n\n        //Pay the publisher\n        toSend = (publisherCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  publisher,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(publisher, _contributor);\n        }\n\n        //Pay the thirdParty account\n        toSend = (thirdPartyCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  thirdParty,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(thirdParty, _contributor);\n        }\n\n        //Pay perpetual Altruism the reminder (25%). only non-null guaranteed address, so send any rounding errors there\n        toSend = toDistribute;\n        if(toSend != 0){\n            emit Payout(toSend,  perpertualAltruism,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(perpertualAltruism, _contributor);\n        }\n    }\n\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\n    /// @dev Only callable internally\n    /// @param _newBid The amount of money in the new bid\n    /// @param _bidder The address of the new bidder\n    function calculateReward(uint256 _newBid, address _bidder) internal{\n\n        //Calculating how much payout we will receive if we are outbid\n\n        //Init the baseline bid we need to perform against\n        uint256 baseBid = currentBids[highestBidder] * (bid_Decimals + bid_stepMin) / bid_Decimals;\n        if(baseBid == 0){\n            baseBid = startingPrice;\n\n            //Do not divide by 0\n            if(baseBid == 0){\n                baseBid = 1;\n            }\n        }\n\n        //We calculate our baseline reward. We square the decimals to guarantee a granularity of at least 1/bid_Decimals instead of 1/bid_multiplier\n        //This also somewhat limit the hardcap for a reward to max_UInt256/10^11 => Not a problem as this amount of eth will not be minted\n        uint256 decimaledRatio = ((bid_Decimals * bid_multiplier * (_newBid - baseBid) ) / baseBid) + bid_incMin * bid_Decimals;\n\n        //If we go over the maximum payout, we set the reward to the maximum payout\n        if(decimaledRatio > (bid_Decimals * bid_incMax)){\n            decimaledRatio = bid_Decimals * bid_incMax;\n        }\n\n        duePayout[_bidder] = (_newBid * decimaledRatio)/(bid_Decimals*bid_Decimals);\n    }\n\n}\n\n"},"browser/SingleAuctionLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./SingleAuctionV1.sol\";\nimport \"./CryptographFactoryV1.sol\";\nimport \"./AuctionHouseLogicV1.sol\";\nimport \"./TheCryptographLogicV1.sol\";\nimport \"./CryptographInitiator.sol\";\nimport \"./BidLinkSimple.sol\";\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Single Auction Logic Code\n/// @notice Implements a GBM auction. See white paper for the details. Logic code, to be casted on a proxy.\ncontract SingleAuctionLogicV1 is VCProxyData, SingleAuctionHeaderV1, SingleAuctionStoragePublicV1  {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor () public\n    {\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that requires to be called only by the Auction house\n    modifier restrictedToAuctionHouse(){\n        require((msg.sender == auctionHouse), \"Only the auction house smart contract can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the MintingAuction\n    /// @param _myCryptograph The address of the cryptograph this auction is paired with\n    /// @param _cryInitiator The address of the initator containing the details of our auction\n    /// @param _initialize true => can't change any spec afterward. false => can initialize again.\n    function initAuction(\n            address _myCryptograph,\n            address _cryInitiator,\n            bool _initialize\n        ) public {\n\n        require(!initialized, \"This auction is already initialized\");\n        initialized = _initialize; //Are we locking ?\n\n        //we must be either perpetual altruism OR never inited before\n        require(auctionHouse == address(0) || msg.sender == cryFactory,\"Only Perpetual altruism can change a yet to be locked auction\");\n        cryFactory = msg.sender;\n\n        /*\n        ==================================================\n                            Bidding section\n        ==================================================\n        */\n\n        startingPrice = CryptographInitiator(_cryInitiator).startingPrice(); //The first bid that need to be outbid is 1 Wei\n        sellingPrice = 0; //A newly minted cryptograph doesn't have an owner willing to sell\n\n        /*\n        ==================================================\n                        Calculations section\n        ==================================================\n        */\n        bid_Decimals = 100000;  //100k, or 100%\n        bid_incMax = 10000; //10k, or 10%\n        bid_incMin = 1000; //1k, or 1%\n        bid_stepMin = 10500; //10.5k, or 10.5%\n        bid_cutOthers = 500; // 500, or 0.5%\n        bid_multiplier = 11120; // 9000 = Doubling step min bid yield max gain (1%+9% = 10%). \n\n        sale_fee = 10000; //10k, or 10%\n\n         /*\n        ==================================================\n                            Money section\n        ==================================================\n        */\n        //Setting up money flow\n        perpertualAltruism = CryptographFactoryStoragePublicV1(cryFactory).officialPublisher();\n        perpetualAltruismCut = CryptographInitiator(_cryInitiator).perpetualAltruismCut();\n        publisher = CryptographInitiator(_cryInitiator).publisher();\n        publisherCut = CryptographInitiator(_cryInitiator).publisherCut();\n        charity = CryptographInitiator(_cryInitiator).charity();\n        charityCut = CryptographInitiator(_cryInitiator).charityCut();\n        thirdParty = CryptographInitiator(_cryInitiator).thirdParty();\n        thirdPartyCut = CryptographInitiator(_cryInitiator).thirdPartyCut();\n\n        //Setting up timings\n        startTime = CryptographInitiator(_cryInitiator).auctionStartTime();\n        endTime = CryptographInitiator(_cryInitiator).auctionStartTime() + CryptographInitiator(_cryInitiator).auctionSecondsDuration();\n\n        hammerBlockDuration = 10; //Minimum 10 blocks\n        hammerTimeDuration = 36*60*60; //The new perpetual auction will last for 36 hours at least\n        delete hammerBlock;\n        delete hammerTime;\n\n        auctionHouse = CryptographFactoryStoragePublicV1(cryFactory).targetAuctionHouse();\n        myCryptograph = _myCryptograph;\n    }\n\n    /// @notice Make an official auction unmodifiable once we are certain the parameters are correct\n    /// @dev Only callable by perpetual altruism\n    function lock() external{\n        require(msg.sender == cryFactory, \"Only Perpetual altruism can lock the initialization\");\n        initialized = true;\n    }\n\n    /// @notice Place a bid to own a cryptograph and distribute the incentives\n    /// @dev Only callable by the Auction House\n    /// @param _newBidAmount The amount of the new bid\n    /// @param _newBidder The address of the bidder\n    function bid(uint256 _newBidAmount, address _newBidder) external payable restrictedToAuctionHouse(){\n        //Empty, as we are supposed to execute SingleAuctionBidLogic bid function but better have this function in the ABI\n    }\n\n    /// @notice Cancel a bid placed previously by a bidder\n    /// @dev Only callable by the Auction House\n    /// @param _bidder The address of the bidder wanting to cancel his bid\n    function cancelBid(address _bidder) external restrictedToAuctionHouse(){\n\n        //We can only cancel existing bids\n        require(currentBids[_bidder] != 0, \"Can't cancel a bid that does not exist\");\n\n        //We can only cancel past the initial auction\n        require(TheCryptographLogicV1(myCryptograph).owner() != address(0), \"Bids cannot be manually cancelled during the initial auction\");\n\n        //We can't cancel during hammerTime if we are the highest bidder\n        require(hammerTime == 0 || _bidder != highestBidder, \"The highest bid cannot be cancelled once a seller accepted a sale\");\n\n        uint256 toSend = currentBids[_bidder];\n\n        //If we are the highest bidder we have to settle the payouts before cancelling\n        //unsettledPayouts = 0 for the highest bidder if either first bidder or someone cancelled above\n        if(_bidder == highestBidder ){\n            //Deduce from amount of money we get back the unsettled payout\n            toSend -= unsettledPayouts;\n            unsettledPayouts = 0;\n\n            //Finding the new highest bidder :\n            //Explore the below link of the highest bidder. (We are cancelling a bid, so a highest bidder exist)\n            address _linkHighest = BidLinkSimple(bidLinks[_bidder]).below();\n            //If the below link exist, then the associated bidder is the next highest bidder\n            if(_linkHighest != address(0x0)){\n                highestBidder = BidLinkSimple(_linkHighest).bidder();\n            } else {\n                //No more bidders : we are cancelling ourselves\n                delete highestBidder;\n            }\n        }\n\n        //Emit the cancellation event\n        emit BidCancelled(currentBids[_bidder], toSend, _bidder);\n\n        //Reset our bid related variables\n        currentBids[_bidder] = 0;\n        duePayout[_bidder] = 0;\n\n\n        //Updating our neigbors link\n        if( BidLinkSimple(bidLinks[_bidder]).above() != address(0x0)){\n            BidLinkSimple(BidLinkSimple(bidLinks[_bidder]).above()).setBelow(BidLinkSimple(bidLinks[_bidder]).below()); //Unlinking above us\n        }\n\n        if( BidLinkSimple(bidLinks[_bidder]).below() != address(0x0)){\n            BidLinkSimple(BidLinkSimple(bidLinks[_bidder]).below()).setAbove(BidLinkSimple(bidLinks[_bidder]).above()); //Unlinking below us\n        }\n\n        //Finally, we send the funds back to the auction house\n        AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(_bidder, _bidder);\n\n    }\n\n    /// @notice Set an instant sale price. If set to 0, instant sale can't be triggered.\n    /// @dev Only callable by the Auction House. Can't be cancelled\n    /// @param _seller The address of the owner wishing to sell the Cryptograph\n    /// @param _sellPrice The minimum amount of eth the seller wants to get\n    function setSellingPrice(address _seller, uint256 _sellPrice) external restrictedToAuctionHouse(){\n\n        require(!isBeingERC2665Approved, \"You can't auction a cryptograph that a third party can reclaim\");\n\n        require(_seller == TheCryptographLogicV1(myCryptograph).owner(), \"The seller can only be the owner\");\n        require(hammerTime == 0, \"A sale is already in progress\");\n\n        sellingPrice = _sellPrice;\n\n        emit SellingPriceAdjusted(_seller, _sellPrice);\n\n        if(currentBids[highestBidder] >= _sellPrice && _sellPrice != 0){ //Start a sale if the selling price is already met by the highest bidder\n            hammerTime = now + hammerTimeDuration;\n            hammerBlock = block.number + hammerBlockDuration;\n            emit SaleStarted(_seller, hammerTime, hammerBlock);\n        }\n\n        //Resetting Renatus timer\n        TheCryptographLogicV1(myCryptograph).renatus();\n\n    }\n\n    /// @notice Assign the cryptograph to its new legitmate owner. Only callable after the initial Auction or HammerTime\n    /// @dev Only callable by the Auction House.\n    /// @param _newOwner The address of the bidder wishing to win the cryptograph\n    /// @return 0 if a normal auction, 1 if a minting auction\n    function win(address _newOwner) external restrictedToAuctionHouse() returns(uint){\n\n        //Only the highest bidder can win a cryptograph\n        require(_newOwner == highestBidder, \"Only the highest bidder can win the Cryptograph\");\n     \n        //startingPrice being reset to 1 wei\n        if(startingPrice != 1){\n            startingPrice = 1;\n        }\n\n        //Fire the transfer following a win event\n        emit Win(_newOwner, TheCryptographLogicV1(myCryptograph).owner(), currentBids[highestBidder]);\n\n        uint256 toSend;\n\n        //If there is no owner yet\n        if(TheCryptographLogicV1(myCryptograph).owner() == address(0)){\n            //We are in the initial sale process\n            require(now > endTime, \"The initial auction is not over yet\");\n\n            //All the proceeds of the sale are distributed to third parties\n            distributeStakeholdersPayouts(currentBids[highestBidder] - unsettledPayouts, _newOwner);\n\n        } else {\n            //We are in the perpetual sale process\n\n            //A sale must be happening and other bidders must have had an opportunity to place their own bids\n            require(hammerTime != 0, \"No sales are happening right now\");\n            require(now > hammerTime, \"Not enough time has elapsed since the seller accepted the sale\");\n            require(block.number > hammerBlock, \"Not enough blocks have been mined since the seller accepted the sale\");\n\n            delete hammerBlock; //Reset the minimal sale block\n            delete hammerTime; //Reset the minmimal sale time\n\n            //10% of the seller proceed is distributed to third parties\n            toSend = ((currentBids[highestBidder] - unsettledPayouts ) * sale_fee) / bid_Decimals;\n            distributeStakeholdersPayouts(toSend, _newOwner);\n\n            //The remainder of the money is then sent to the seller\n            toSend = currentBids[highestBidder] - unsettledPayouts - toSend;\n            emit Payout(toSend, TheCryptographLogicV1(myCryptograph).owner(), _newOwner);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(TheCryptographLogicV1(myCryptograph).owner(), _newOwner);\n        }\n\n        delete unsettledPayouts; //Reset the payouts\n\n        /*\n            Find the new highest bidder\n         */\n\n        //Reset our bid related variables\n        currentBids[_newOwner] = 0;\n        duePayout[_newOwner] = 0;\n\n        //Finding the new highest bidder :\n        //Explore the below link of the highest bidder.\n        address _linkHighest = BidLinkSimple(bidLinks[highestBidder]).below();\n\n        //Deleting  our link\n        delete bidLinks[highestBidder];\n\n        //If the below link exist, then the associated bidder is the next highest bidder\n        if(_linkHighest != address(0x0)){\n            highestBidder = BidLinkSimple(_linkHighest).bidder();\n            BidLinkSimple(_linkHighest).setAbove(address(0x0)); //Our below neighbor is the new highest bidder\n        } else {\n            //No more bidders : we are cancelling ourselves\n            delete highestBidder;\n        }\n\n\n        //Reset the selling price\n        sellingPrice = 0;\n        emit SellingPriceAdjusted(_newOwner, 0);\n\n        //Actually transfer the cryptograph\n        TheCryptographLogicV1(myCryptograph).transfer(_newOwner);\n\n        return 0;\n    }\n\n    /// @notice Function used to distribute an arbitrary amount of money among non-bidders\n    /// @dev Only callable internally\n    /// @param _amount The amount of money to spread\n    /// @param _contributor The address of the source of the money\n    function distributeStakeholdersPayouts(uint256 _amount, address _contributor) internal{\n        uint256 toDistribute = _amount;\n        uint256 toSend;\n\n        //Pay the charity\n        toSend = (charityCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  charity,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(charity, _contributor);\n        }\n\n        //Pay the publisher\n        toSend = (publisherCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  publisher,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(publisher, _contributor);\n        }\n\n        //Pay the thirdParty account\n        toSend = (thirdPartyCut * _amount) / bid_Decimals;\n        toDistribute -= toSend;\n        if(toSend != 0){\n            emit Payout(toSend,  thirdParty,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(thirdParty, _contributor);\n        }\n\n        //Pay perpetual Altruism the reminder (25%). only non-null guaranteed address, so send any rounding errors there\n        toSend = toDistribute;\n        if(toSend != 0){\n            emit Payout(toSend,  perpertualAltruism,  _contributor);\n            AuctionHouseLogicV1(address(uint160(auctionHouse))).addFundsFor{value: toSend }(perpertualAltruism, _contributor);\n        }\n    }\n\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\n    /// @dev Only callable internally\n    /// @param _newBid The amount of money in the new bid\n    /// @param _bidder The address of the new bidder\n    function calculateReward(uint256 _newBid, address _bidder) internal{\n\n        //Calculating how much payout we will receive if we are outbid\n\n        //Init the baseline bid we need to perform against\n        uint256 baseBid = currentBids[highestBidder] * (bid_Decimals + bid_stepMin) / bid_Decimals;\n        if(baseBid == 0){\n            baseBid = startingPrice;\n\n            //Do not divide by 0\n            if(baseBid == 0){\n                baseBid = 1;\n            }\n        }\n\n        //We calculate our baseline reward. We square the decimals to guarantee a granularity of at least 1/bid_Decimals instead of 1/bid_multiplier\n        //This also somewhat limit the hardcap for a reward to max_UInt256/10^11 => Not a problem as this amount of eth will not be minted\n        uint256 decimaledRatio = ((bid_Decimals * bid_multiplier * (_newBid - baseBid) ) / baseBid) + bid_incMin * bid_Decimals;\n\n        //If we go over the maximum payout, we set the reward to the maximum payout\n        if(decimaledRatio > (bid_Decimals * bid_incMax)){\n            decimaledRatio = bid_Decimals * bid_incMax;\n        }\n\n        duePayout[_bidder] = (_newBid * decimaledRatio)/(bid_Decimals*bid_Decimals);\n    }\n\n    /// @notice resetting an auction starting in two weeks with the initial auction parameters. No changes to the existing bids.\n    /// @dev Only callable by our own cryptograph\n    function renatus() external{\n\n        require(msg.sender == myCryptograph, \"Only callable by the paired Cryptograph\");\n\n        delete hammerBlock; //Reset the minimal sale block\n        delete hammerTime; //Reset the minmimal sale time\n        delete sellingPrice; //Reset the selling price\n\n        //Reset the auction end/start time to be same duration as initial auction but starting in 14 days\n        endTime = now + 60*60*24*14 + endTime - startTime;\n        startTime = now + 60*60*24*14;\n\n        //Actually transfer the cryptograph \n        TheCryptographLogicV1(myCryptograph).transfer(address(0));\n    }\n\n    /// @notice transfer following the ERC2665 standard\n    /// @dev Only callable by the auction house\n    /// @param _contributor The operator paying the transfer fee\n    /// @param _to The address of the new owner\n    function transferERC2665(address _contributor, address _to) external payable restrictedToAuctionHouse() {\n\n         if(msg.value != 0){\n            //Distributing the transfer fee\n            distributeStakeholdersPayouts(msg.value, _contributor);\n        }\n\n        //Checking that no auctions are running\n        require(hammerTime == 0, \"Can't transfer a cryptograph under sale\");\n   \n        //Reset the selling price\n        if(sellingPrice != 0){\n            sellingPrice = 0;\n            emit SellingPriceAdjusted(_contributor, 0);\n        }\n\n        //Actually transfer the cryptograph\n        TheCryptographLogicV1(myCryptograph).transfer(_to);\n\n        //New owner mean no approval\n        isBeingERC2665Approved = false;\n\n    }\n\n    \n    /// @notice Approve following the ERC2665\n    /// @dev Only callable by the auction house\n    /// @param _contributor The operator paying the transfer fee\n    /// @param _approvedAddress The address of the new approved address\n    function approveERC2665(address _contributor, address _approvedAddress) external payable restrictedToAuctionHouse(){\n\n        if(msg.value != 0){\n            //Distributing the transfer fee\n            distributeStakeholdersPayouts(msg.value, _contributor);\n        }\n      \n\n        //Checking that no auctions are running\n        require(hammerTime == 0, \"Can't approve a cryptograph under sale\");\n\n        //Reset the selling price\n        if(sellingPrice != 0){\n            sellingPrice = 0;\n            emit SellingPriceAdjusted(_contributor, 0);\n        }\n        \n        //Checking address approval\n        if(_approvedAddress == address(0) || _approvedAddress == TheCryptographLogicV1(myCryptograph).owner()){\n            isBeingERC2665Approved = false;\n        } else {\n            isBeingERC2665Approved = true;\n        }\n\n    }\n\n}\n\n"},"browser/SingleAuctionProxiedV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./SingleAuctionV1.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title  Single Auction Proxy Smart Contract\n/// @notice The Single Auction proxy : this is the contract that will be instancied on the blockchain. Cast this as the logic contract to interact with it.\ncontract SingleAuctionProxiedV1 is VCProxy, SingleAuctionHeaderV1, SingleAuctionStorageInternalV1  {\n\n    constructor(uint256 _version, address _vc, uint256 _versionBid)  public\n    VCProxy(_version, _vc) //Call the VC proxy constructor so that we know where our logic code is\n    {\n        versionBid = _versionBid;\n    }\n\n    //Routing the bid function to a separate smart contract than the regular version, with proper Bid ABI\n    function bid(uint256 , address) external payable {\n\n        address addr = VersionControlStoragePublic(vc).code(versionBid);\n        assembly {\n            let freememstart := mload(0x40)\n            calldatacopy(freememstart, 0, calldatasize())\n            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)\n            returndatacopy(freememstart, 0, returndatasize())\n            switch success\n            case 0 { revert(freememstart, returndatasize()) }\n            default { return(freememstart, returndatasize()) }\n        }\n    }\n\n\n}\n\n\n"},"browser/SingleAuctionV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Single Auction Header\n/// @notice Contain all the events emitted by the Single Auction\ncontract SingleAuctionHeaderV1 {\n    event BidAccepted(uint256 bidValue, address indexed bidder);\n    event Payout(uint256 amount, address indexed beneficiary, address indexed contributor);\n    event BidCancelled(uint256 bidValue, uint256 ethReturned, address indexed bidder);\n    event SaleStarted(address indexed seller, uint256 hammerTime, uint256 hammerBlock);\n    event SellingPriceAdjusted(address indexed seller, uint256 amount);\n    event Win(address indexed buyer, address indexed seller, uint256 bidValue);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Single Auction Storage Internal\n/// @notice Contain all the storage of the Single Auction declared in a way that does not generate getters for Proxy use\ncontract SingleAuctionStorageInternalV1 {\n\n    //Used to store the index number of the bidding logic contract\n    uint256 internal versionBid;\n\n    /*\n    ==================================================\n                        Bidding section\n    ==================================================\n    */\n\n    //The current bids made by each address\n    mapping (address => uint) internal currentBids;\n\n    //The current amount of wei each address receive when outbid as the highest bid.\n    mapping (address => uint) internal duePayout; //How much the bidder make\n\n    //The current highest bidder;\n    address internal highestBidder;\n\n    //The current amount of unsettled payouts distributed for the current bidding process\n    uint256 internal unsettledPayouts;\n\n    //The default starting price\n    uint256 internal startingPrice;\n\n    //The current selling price\n    uint256 internal sellingPrice;\n\n    //A mapping associating each bidder with their associated chainLink\n    mapping (address => address) internal bidLinks;\n\n    /*\n    ==================================================\n                        Calculations section\n    ==================================================\n    */\n\n    /*\n    For a standing bid s and a new bid n, we express the return on the new bid as:\n\n    incentive(n,s) % = min[ incmax , incmin + m * (n- s * (1+ stepmin)) / (s * (1+ stepmin))]\n\n    Where:\n    stepmin is the minimum bid increment, expressed as a fraction of the current standing bid (ex : 0.01 for 1/10 or 10%)\n    incmin is the minimum incentive, expressed as a fraction\n    incmax is the maximum incentive, expressed as a fraction\n    m is the multiplier effect, expressed as a positive real number\n\n    */\n\n    //Values used to calculate the payouts.\n    uint256 internal bid_Decimals; //100k, or 100%\n    uint256 internal bid_incMax; //10k, or 10%\n    uint256 internal bid_incMin; //1k, or 1%\n    uint256 internal bid_stepMin; // 10.5k, or 10.5%\n    uint256 internal bid_cutOthers; // 500, or 0.5%\n\n    uint256 internal bid_multiplier; //Will be divided by 100 for the calulations. 100 means that doubling the bid leads to 1% extra return\n\n    uint256 internal sale_fee; //Proportion of the bid_Decimals taken as a selling fee. 10% = 10k\n\n\n    /*\n    ==================================================\n                        Money section\n    ==================================================\n    */\n\n    address internal publisher; //The address of the publisher of the cryptograph. Can edit media url and hash.\n    address internal charity; //The address to which the chartity cut is being sent to. No special rights.\n    address internal thirdParty; //The address of any third party taking a cut. No special rights.\n    //The perpetual altruism address. Always take 25%+ for community cryptographs. Same as publisher for official cryptographs.\n    address internal perpertualAltruism;\n\n    //The granularity of the redistribution is 0.001%. 100 000 = all the money\n    uint256 internal publisherCut;\n    uint256 internal charityCut;\n    uint256 internal thirdPartyCut;\n    uint256 internal perpetualAltruismCut;\n\n    /*\n    ==================================================\n                        Timing section\n    ==================================================\n    */\n    uint256 internal startTime; //The start date of the initial auction\n    uint256 internal endTime; //The end date of the initial auction\n\n    uint256 internal hammerBlockDuration; //The minium number of blocks for which other bidder can come in after a winning offer\n    uint256 internal hammerTimeDuration; //The  number of seconds for which other bidder can come in after a winning offer\n    uint256 internal hammerBlock; //The block number after which a winning offer can claim a cryptograph\n    uint256 internal hammerTime; //The date after which a winning offer can claim a cryptograph\n\n    /*\n    ==================================================\n                        Binding section\n    ==================================================\n    */\n    address internal auctionHouse; //The address of the auction house\n    address internal myCryptograph; //The address of the Cryptograph I'm administrating\n    address internal cryFactory; //The address of the cryptograph Factory\n\n    bool internal initialized;\n    bool internal isBeingERC2665Approved; //If set to true, a potential new owner has been approved in ERC2665\n\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Single Auction Storage Public\n/// @notice Contain all the storage of the Single Auction declared in a way that generates getters for Logic use\ncontract SingleAuctionStoragePublicV1 {\n\n    //Used to store the VC index number of the bidding logic conctract\n    uint256 internal versionBid;\n\n    /*\n    ==================================================\n                        Bidding section\n    ==================================================\n    */\n\n    //The current bids made by each address\n    mapping (address => uint) public currentBids;\n\n    //The current amount of wei each address receive when outbid as the highest bid.\n    mapping (address => uint) public duePayout; //How much the bidder make\n\n    //The current highest bidder;\n    address public highestBidder;\n\n    //The current amount of unsettled payouts distributed for the current bidding process\n    uint256 public unsettledPayouts;\n\n    //The default starting price\n    uint256 public startingPrice;\n\n    //The current selling price\n    uint256 public sellingPrice;\n\n    //A mapping associating each bidder with their associated chainLink\n    mapping (address => address) public bidLinks;\n\n    /*\n    ==================================================\n                        Calculations section\n    ==================================================\n    */\n\n    /*\n    For a standing bid s and a new bid n, we express the return on the new bid as:\n\n    incentive(n,s) % = min[ incmax , incmin + m * (n- s * (1+ stepmin)) / (s * (1+ stepmin))]\n\n    Where:\n    stepmin is the minimum bid increment, expressed as a fraction of the current standing bid (ex : 0.01 for 1/10 or 10%)\n    incmin is the minimum incentive, expressed as a fraction\n    incmax is the maximum incentive, expressed as a fraction\n    m is the multiplier effect, expressed as a positive real number\n\n    */\n\n    //Values used to calculate the payouts.\n    uint256 public bid_Decimals; //100k, or 100%\n    uint256 public bid_incMax; //10k, or 10%\n    uint256 public bid_incMin; //1k, or 1%\n    uint256 public bid_stepMin; // 10.5k, or 10.5%\n    uint256 public bid_cutOthers; // 500, or 0.5%\n\n    uint256 public bid_multiplier; //Will be divided by 100 for the calulations. 100 mean that doubling the bid mean 1% extra return\n\n    uint256 public sale_fee; //Proportion of the bid_Decimals taken as a selling fee. 10% = 10k\n\n    /*\n    ==================================================\n                        Money section\n    ==================================================\n    */\n\n    address public publisher; //The address of the publisher of the cryptograph. Can edit media url and hash.\n    address public charity; //The address to which the chartity cut is being sent to\n    address public thirdParty; //The address of any third party taking a cut\n    address public perpertualAltruism; //The perpetual altruism address\n\n    //The granularity of the redistribution is 0.001%. 100 000 = all the money\n    uint256 public publisherCut;\n    uint256 public charityCut;\n    uint256 public thirdPartyCut;\n    uint256 public perpetualAltruismCut;\n\n    /*\n    ==================================================\n                        Timing section\n    ==================================================\n    */\n    uint256 public startTime; //The start date of the initial auction\n    uint256 public endTime; //The end date of the initial auction\n\n    uint256 public hammerBlockDuration; //The minium number of blocks for which other bidder can come in after a winning offer\n    uint256 public hammerTimeDuration; //The  number of seconds for which other bidder can come in after a winning offer\n    uint256 public hammerBlock; //The block number after which a winning offer can claim a cryptograph\n    uint256 public hammerTime; //The date after which a winning offer can claim a cryptograph\n\n    /*\n    ==================================================\n                        Binding section\n    ==================================================\n    */\n    address public auctionHouse; //The address of the auction house\n    address public myCryptograph; //The address of the Cryptograph I'm administrating\n    address public cryFactory; //The address of the cryptograph Factory\n\n    bool public initialized;\n    bool public isBeingERC2665Approved; //If set to true, a potential new owner has been approved in ERC2665\n}\n\n"},"browser/TheCryptographLogicV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./TheCryptographV1.sol\";\n\nimport \"./CryptographFactoryV1.sol\";\nimport \"./AuctionHouseV1.sol\";\nimport \"./ERC2665LogicV1.sol\";\nimport \"./SingleAuctionLogicV1.sol\";\nimport \"./CryptographInitiator.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title TheCryptograph Logic Code\n/// @notice Represent a single Cryptograph. Contain provenance, ownership and renatus.\ncontract TheCryptographLogicV1 is VCProxyData, TheCryptographHeaderV1, TheCryptographStoragePublicV1 {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor()public{\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that requires to be called only by the Factory\n    modifier restrictedToFactory() {\n        require(SingleAuctionLogicV1(myAuction).cryFactory() == msg.sender, \"Only callable by the factory\");\n        _;\n    }\n\n    /// @notice Init function of TheCryptograph\n    /// @param _issue The issue # of this cryptograph\n    /// @param _serial The serial # of this cryptograph (only relevant for editions and GGBMA)\n    /// @param _official Is it an official or a community cryptograph ?\n    /// @param _myAuction The address of our paired auction\n    /// @param _cryInitiator The address of the initiator we are gonna grab name and media hash/url from\n    /// @param _owner The initial owner. Always 0x0 except for GGBMA minted.\n    function initCry(\n        uint256 _issue, uint256 _serial, bool _official, address _myAuction, address _cryInitiator, address _owner) external {\n\n        //Can only init if we are either (never init before) or if (we are official, before the auction starting time, and not under renatus)\n        require(\n            myAuction == address(0) ||\n            (\n                official &&\n                !hasCurrentOwnerMarked &&\n                SingleAuctionLogicV1(myAuction).cryFactory() == msg.sender &&\n                SingleAuctionLogicV1(myAuction).startTime() > now),\n            \"This Cryptograph has already been initialized\");\n        //When renatus is happening, hasCurrentOwnerMarked should be set to true so that perpetual Altruism can't edit again the cryptograph\n\n        //Setting up cryptograph identity related vars\n        name = CryptographInitiator(_cryInitiator).name();\n        creator = CryptographInitiator(_cryInitiator).creator();\n\n        emit Named(name);\n\n        mediaHash = CryptographInitiator(_cryInitiator).mediaHash();\n        emit MediaHash(mediaHash);\n\n        mediaUrl = CryptographInitiator(_cryInitiator).mediaUrl();\n        emit MediaUrl(mediaUrl);\n\n        serial = _serial;\n        issue = _issue;\n\n        official = _official;\n\n        //Setting up initial owner (nobody EXCEPT GGBMA minting)\n        owner = _owner;\n\n        //Linking the auction\n        myAuction = _myAuction;\n\n    }\n\n    /// @notice Set the media hash of the Cryptograph\n    /// @dev Advanced requirement checks should be done on the factory side\n    /// @param _mediaHash A string containing the media hash\n    function setMediaHash(string calldata _mediaHash) external restrictedToFactory() {\n        mediaHash = _mediaHash;\n        emit MediaHash(_mediaHash);\n    }\n\n    /// @notice Set the media url of the Cryptograph\n    /// @dev Advanced requirement checks should be done on the factory side\n    /// @param _mediaUrl A string containing the media url\n    function setMediaUrl(string calldata _mediaUrl)external restrictedToFactory() {\n        mediaUrl = _mediaUrl;\n        emit MediaUrl(_mediaUrl);\n    }\n\n    /// @notice Transfer ownership of the token\n    /// @dev only callable by the associated GBM auction instance\n    /// @param _newOwner The address of the account to become the new owner\n    function transfer(address _newOwner) external {\n        require(msg.sender == myAuction, \"The auction is the only way to set a new owner\");\n        emit Transferred(owner, _newOwner);\n        owner = _newOwner;\n        hasCurrentOwnerMarked = false;\n\n        //Resetting renatus timer\n        lastOwnerInteraction = now;\n        renatusTimeStamp = 0;\n    }\n\n    /// @notice Mark a cryptograph\n    /// @dev only callable by the current owner if he has not done it since he gained ownership\n    /// @param _mark A 3 Character long string containing the mark\n    function mark(string calldata _mark) external {\n        require(msg.sender == owner, \"Only the owner can set a mark on a cryptograph\");\n        require(!hasCurrentOwnerMarked, \"The cryptograph has already been marked by the owner\");\n        require(bytes(_mark).length <= 3, \"You can only inscribe at most 3 characters at a time\"); //In Utf8, strlenght <= bytelength.\n\n        hasCurrentOwnerMarked = true; //Setting the current owner has having marked\n\n        marks.push(_mark); //Inscribing the mark\n        markers.push(owner); //Associating the owner\n\n        emit Marked(owner, _mark); //Emitting the event\n\n        //Resetting renatus timer\n        lastOwnerInteraction = now;\n        renatusTimeStamp = 0;\n    }\n\n    /// @notice Prevent burning cryptographs by putting them back to auctions if abandoned by their owners\n    /// @dev If called by the owner, and ERC-2665 operator of perpetual altruism refresh ownership for 5 years\n    function renatus() external {\n        if (msg.sender == owner ||\n            msg.sender == myAuction ||\n            msg.sender == SingleAuctionLogicV1(myAuction).publisher() ||\n            msg.sender == AuctionHouseStoragePublicV1(SingleAuctionLogicV1(myAuction).auctionHouse()).ERC2665Lieutenant()) {\n            lastOwnerInteraction = now; //If the owner/operator/Pa call, reset the renatus call\n            renatusTimeStamp = 0;\n            emit Renatus(0);\n        } else {\n            require(now >= lastOwnerInteraction + 60 * 60 * 24 * 366 * 5, \"Five years have not yet elapsed since last owner interaction\");\n\n            // Set up a 31 day deadline for the owner to claim their Cryptograph again\n            if (renatusTimeStamp == 0) {\n                renatusTimeStamp = now + 60 * 60 * 24 * 31;\n                //Emit the event\n                emit Renatus(renatusTimeStamp);\n            } else {\n                require(now > renatusTimeStamp, \"31 days since renatus was called have not elapsed yet\");\n\n                SingleAuctionLogicV1(myAuction).renatus();\n\n                //Notify the ERC2665 contract\n                ERC2665LogicV1(AuctionHouseStoragePublicV1(SingleAuctionLogicV1(myAuction).auctionHouse()).ERC2665Lieutenant()).triggerRenatus();\n                hasCurrentOwnerMarked = true; //Prevent publisher meddling\n            }\n        }\n    }\n\n}\n"},"browser/TheCryptographProxiedV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./TheCryptographV1.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title  TheCryptograph Proxy Smart Contract\n/// @notice TheCryptograph proxy : this is this contract that will be instancied on the blockchain. Cast this as the logic contract to interact with it.\ncontract TheCryptographProxiedV1 is VCProxy, TheCryptographHeaderV1, TheCryptographStorageInternalV1  {\n\n    constructor(uint256 _version, address _vc)  public\n    VCProxy(_version, _vc) //Call the VC proxy constructor so that we know where our logic code is\n    {\n        //Self intialize (nothing)\n    }\n\n    //No other logic code as it is all proxied\n\n}\n\n\n\n\n"},"browser/TheCryptographV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title TheCryptograph Header\n/// @notice Contain all the events emitted by TheCryptograph\ncontract TheCryptographHeaderV1 {\n    event Named(string name);\n    event MediaHash(string mediaHash);\n    event MediaUrl(string mediaUrl);\n    event Transferred(address indexed previousOwner, address indexed newOwner);\n    event Marked (address indexed Marker, string indexed Mark);\n    event Renatus(uint256 endtime);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title TheCryptograph Storage Internal\n/// @notice Contain all the storage of TheCryptograph declared in a way that don't generate getters for Proxy use\ncontract TheCryptographStorageInternalV1 {\n\n    /*\n    ==================================================\n                    Identity Section\n    ==================================================\n    */\n    string internal name; //The name of this cryptograph\n    string internal creator; //The creator of this cryptograph\n    string internal mediaHash; //The hash of the cryptograph media\n    string internal mediaUrl; //An url where the cryptograph media is accessible\n    uint256 internal serial; //The serial number of this cryptograph (position in the index)\n    uint256 internal issue; //The numbered minting of this specific cryptograph.\n    bool internal hasCurrentOwnerMarked; //Each subsequent owner can only leave its mark once\n    string[] internal marks; //Each owner can leave its mark on the cryptograph\n    address[] internal markers; //List of owners that have left a mark\n\n    /*\n    ==================================================\n                        Ownership section\n    ==================================================\n    */\n    address internal owner; //The current owner of the cryptograph\n\n    /*\n    ==================================================\n                    Auction Section\n    ==================================================\n    */\n    address internal myAuction; //Address of the running auction associated with this Cryptograph\n    bool internal official; //Are we an official cryptograph ?\n\n    /*\n    ==================================================\n                    Renatus Section\n    ==================================================\n    */\n    uint256 internal lastOwnerInteraction; //When was the last time the owner interacted with the cryptograph ?\n    uint256 internal renatusTimeStamp; //When was the last time someone wanted to check if the owner was still owning it's private key ?\n\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title TheCryptograph Storage Public\n/// @notice Contain all the storage of TheCryptograph declared in a way that generates getters for Logic use\ncontract TheCryptographStoragePublicV1 {\n\n    /*\n    ==================================================\n                    Identity Section\n    ==================================================\n    */\n    string public name; //The name of this cryptograph\n    string public creator; //The creator of this cryptograph\n    string public mediaHash; //The hash of the cryptograph media\n    string public mediaUrl; //An url where the cryptograph media is accessible\n    uint256 public serial; //The serial number of this cryptograph (position in the index)\n    uint256 public issue;\n    bool public hasCurrentOwnerMarked; //Each subsequent owner can only leave its mark once\n    string[] public marks; //Each owner can leave its mark on the cryptograph\n    address[] public markers; //List of owners that have left a mark\n\n    /*\n    ==================================================\n                        Ownership Section\n    ==================================================\n    */\n    address public owner; //The current owner of the cryptograph\n\n    /*\n    ==================================================\n                    Auction Section\n    ==================================================\n    */\n    address public myAuction; //Address of the running auction associated with this Cryptograph\n    bool public official; //Are we an official cryptograph ?\n\n    /*\n    ==================================================\n                    Renatus Section\n    ==================================================\n    */\n    uint256 public lastOwnerInteraction; //When was the last time the owner interacted with the cryptograph ?\n    uint256 public renatusTimeStamp; //When was the last time someone wanted to check if the owner was still owning it's private key ?\n\n}\n\n"},"browser/VCProxy.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/* Based on a variation of https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201\nThis generic proxy is gonna ask a version control smart contract for its logic code instead\nof storing the remote address himself\n*/\n\n/*\nSmart contract only containing a public array named the same as VC so that the compiler call the proper\nfunction signature in our generic proxy\n*/\ncontract VersionControlStoragePublic {\n    address[] public code;\n}\n\n\n/*\nStorage stack of a proxy contract. VCproxy inherit this, as well as ALL logic contracts associated to a proxy for storage alignment reasons.\n*/\ncontract VCProxyData {\n    address internal vc; //Version Control Smart Contract Address\n    uint256 internal version; //The index of our logic code in the Version Control array.\n}\n\n\n/*\nLogic of a proxy contract. EVERY proxied contract inherit this\n*/\ncontract VCProxy is VCProxyData {\n    constructor(uint256 _version, address _vc) public {\n        version = _version;\n        vc = _vc;\n    }\n\n    fallback () virtual external payable {\n\n        address addr = VersionControlStoragePublic(vc).code(version);\n        assembly {\n            let freememstart := mload(0x40)\n            calldatacopy(freememstart, 0, calldatasize())\n            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)\n            returndatacopy(freememstart, 0, returndatasize())\n            switch success\n            case 0 { revert(freememstart, returndatasize()) }\n            default { return(freememstart, returndatasize()) }\n        }\n    }\n\n    \n    /// @notice Generic catch-all function that refuse payments to prevent accidental Eth burn.\n    receive() virtual external payable{\n       require(false, \"Do not send me Eth without a reason\");\n    }\n}"}}}