{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BasedGold.sol":{"content":"/**\r\n°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\r\n°°°           ---------->> Based Gold - BGLD (v2) <<----------          °°°                        \r\n°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\r\n-->> BGLD contract address (v2): 0x4b4fa17f83c09873cb5b4e0023f25d4f533fc9ba\r\n***************************************************************************\r\n---------------->>  Telegram:https://t.me/BGLDofficial  <<----------------\r\n---------------->>  Website: https://www.BGLD.it  <<-----------------------\r\n---------------->>  Twitter: https://twitter.com/Basedgoldbgld  <<---------\r\n***************************************************************************\r\n***************************************************************************\r\nLinks to Based Gold (v2):\r\nhttps://etherscan.io/address/0x4b4fa17f83c09873cb5b4e0023f25d4f533fc9ba\r\nhttps://www.dextools.io/app/ether/pair-explorer/0x4233b83f3D5Bc39770fb7a456EF85B7eEC26fe14        \r\n\r\n                                                                              \r\n██████╗  █████╗ ███████╗███████╗██████╗      ██████╗  ██████╗ ██╗     ██████╗ \r\n██╔══██╗██╔══██╗██╔════╝██╔════╝██╔══██╗    ██╔════╝ ██╔═══██╗██║     ██╔══██╗\r\n██████╔╝███████║███████╗█████╗  ██║  ██║    ██║  ███╗██║   ██║██║     ██║  ██║\r\n██╔══██╗██╔══██║╚════██║██╔══╝  ██║  ██║    ██║   ██║██║   ██║██║     ██║  ██║\r\n██████╔╝██║  ██║███████║███████╗██████╔╝    ╚██████╔╝╚██████╔╝███████╗██████╔╝\r\n╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝      ╚═════╝  ╚═════╝ ╚══════╝╚═════╝ \r\n                                                                              \r\n██████╗  ██████╗ ██╗     ██████╗                                              \r\n██╔══██╗██╔════╝ ██║     ██╔══██╗                                             \r\n██████╔╝██║  ███╗██║     ██║  ██║                                             \r\n██╔══██╗██║   ██║██║     ██║  ██║                                             \r\n██████╔╝╚██████╔╝███████╗██████╔╝                                             \r\n╚═════╝  ╚═════╝ ╚══════╝╚═════╝                                                                                                                                                 \r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.10;        \r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    }\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ncontract BasedGold {           \r\n    IUniswapV2Router02 private _uniswapV2Router; \r\n    string  private _name = 'Based Gold';\r\n    string  private _symbol = 'BGLD';\r\n\r\n    // Max total supply 88 800 000 BGLD tokens\r\n    uint256 private _totalSupply = 88800000000000000000000000;  \r\n    uint8   private _decimals = 18;  \r\n    address private _owner;\r\n      \r\n    address public uniswapPair;\r\n    address public marketingWallet;\r\n    address public devWallet;  \r\n\r\n    // Initial minimum liquidation threshold 100000.42006904200690420069 BGLD tokens\r\n    // Initial maximum liquidation threshold 200000.42006904200690420069 BGLD tokens\r\n    uint256 public minLiquidationThreshold = 100000420690420690420069;                                                        \r\n    uint256 public maxLiquidationThreshold = 200000420690420690420069; \r\n    \r\n    // To keep track of BGLD tokens accumulated in the contract (from fees)\r\n    uint256 public accMarketingFee = 1;                                                                             \r\n    uint256 public accDevFee = 1; \r\n\r\n    // Fees are multiplied by 100 for accuracy --> 200 = 2.00%\r\n    uint256 public buyMarketingFee = 200;    \r\n    uint256 public buyDevFee = 100;\r\n    uint256 public totalBuyFees = 300;                                          \r\n    \r\n    uint256 public sellMarketingFee = 300;\r\n    uint256 public sellDevFee = 200;\r\n    uint256 public totalSellFees = 500;\r\n    \r\n    uint256 private botMarketingFee = 4925;                          \r\n    uint256 private botDevFee = 4925;\r\n    uint256 private totalBotFees = 9850;\r\n    uint256 private lastBotBlock;\r\n\r\n    bool public tradingIsOpen;\r\n    bool public distributeTokens = true;\r\n\r\n    mapping(address => bool) public automatedMarketMakerPairs;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping(address => uint256)) private _allowances;\r\n    mapping (address => uint256) private lastBuyBlock;\r\n    mapping (address => bool) private _isExcludedFromFees;\r\n    mapping (address => bool) private canTransferBeforeTradingIsOpen;\r\n    mapping (address => bool) public _isBotListed;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);                                   \r\n    event Approve(address indexed owner, address indexed spender, uint256 value);\r\n    event TradingIsOpen(bool status);                                      \r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"BGLD: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwnerOrDev() {\r\n        require(devWallet == msg.sender || _owner == msg.sender, \"BGLD: caller is not the owner or the dev\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDevOrMarketing() {\r\n        require(marketingWallet == msg.sender || devWallet == msg.sender, \"BGLD: caller is not the marketing or the dev wallet\");\r\n        _;\r\n    }\r\n\r\n    constructor() {                                                                                                               \r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B), msg.sender);                                                                \r\n\r\n        canTransferBeforeTradingIsOpen[_owner] = true;\r\n\r\n        _balances[_owner] = _totalSupply;                             \r\n        emit Transfer(address(0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B), _owner, _totalSupply);\r\n \r\n        _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); \r\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        automatedMarketMakerPairs[uniswapPair] = true;   \r\n\r\n        _isExcludedFromFees[address(this)] = true;\r\n        _isExcludedFromFees[_owner] = true;  \r\n        _isExcludedFromFees[address(_uniswapV2Router)] = true;                                        \r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function burnedSupply() public view virtual returns (uint256) {\r\n        return balanceOf(address(0xdEaD)) + balanceOf(address(0));\r\n    }\r\n\r\n    function dilutedSupply() public view virtual returns (uint256) {\r\n        return _totalSupply - balanceOf(address(0xdEaD)); \r\n    }\r\n    \r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"BGLD: new owner is the zero address\");\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {                                   \r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address holder, address spender) public view virtual returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"BGLD: transfer amount exceeds allowance\");\r\n\r\n        _transfer(sender, recipient, amount);\r\n    unchecked { _approve(sender, msg.sender, currentAllowance - amount); }\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"BGLD: decreased allowance below zero\");\r\n\r\n    unchecked { _approve(msg.sender, spender, currentAllowance - subtractedValue); }\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address holder,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(holder != address(0), \"BGLD: approve from the zero address\");\r\n        require(spender != address(0), \"BGLD: approve to the zero address\");\r\n\r\n        _allowances[holder][spender] = amount;\r\n        emit Approve(holder, spender, amount);                                                                     \r\n    }\r\n\r\n    // Boolean createPair defines whether or not to create a new uniswapPair on the new router\r\n    function updateUniswapRouter(address newAddress, bool createPair) external onlyOwnerOrDev {                               \r\n        _uniswapV2Router = IUniswapV2Router02(newAddress);\r\n\r\n        if (createPair) {\r\n            uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n            automatedMarketMakerPairs[uniswapPair] = true;\r\n        }                     \r\n    }\r\n    \r\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwnerOrDev {\r\n        if (pair != uniswapPair) {\r\n            automatedMarketMakerPairs[pair] = value;\r\n            emit SetAutomatedMarketMakerPair(pair, value);\r\n        }\r\n    }\r\n\r\n    function updateUniswapPairAddress(address newUniswapPairAddress) external onlyOwnerOrDev {                                         \r\n        uniswapPair = newUniswapPairAddress;\r\n    }\r\n    \r\n    function SetAccumulatedContractFees(uint256 newAccMarketing, uint256 newAccDev) external onlyOwnerOrDev {                          \r\n        accMarketingFee = newAccMarketing;                                                                             \r\n        accDevFee = newAccDev;\r\n    }\r\n\r\n    // If uniswapPair [AMM] address(es) is(are) excludedFromFees \r\n    // --> 0% fees on buys & sells + NO SwapToDistributeETH (contract sells nor distributes tokens)\r\n    function ExcludeFromFees(address account, bool excludeOrInclude_TrueOrFalse) external onlyOwnerOrDev {                                 \r\n        _isExcludedFromFees[account] = excludeOrInclude_TrueOrFalse;\r\n    }\r\n\r\n    function ExcludeMultipleAccountsFromFees(address[] calldata accounts, bool excludeOrInclude_TrueOrFalse) external onlyOwnerOrDev {                                   \r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n            _isExcludedFromFees[accounts[i]] = excludeOrInclude_TrueOrFalse;\r\n        }\r\n    }\r\n\r\n    function SetLiquidationThresholds(uint256 newMinimumThreshold, uint256 newMaximumThreshold) external onlyDevOrMarketing {     \r\n        minLiquidationThreshold = newMinimumThreshold;\r\n        maxLiquidationThreshold = newMaximumThreshold;\r\n    }\r\n\r\n    // Configures whether the contract sends tokens to marketing & dev directly (true)\r\n    // OR whether the contract swaps them for ETH before sending (false)\r\n    function SetDistributeTokens(bool trueOrFalse) external onlyDevOrMarketing {     \r\n        distributeTokens = trueOrFalse;\r\n    }\r\n\r\n    // Total buy fees and total sell fees MUST each be <15.00% (this way trading can never be blocked)\r\n    function SetFees(uint256 newBuyMarketingFee, uint256 newBuyDevFee, uint256 newSellMarketingFee, uint256 newSellDevFee) external onlyOwnerOrDev {\r\n        totalBuyFees = newBuyMarketingFee + newBuyDevFee;\r\n        totalSellFees = newSellMarketingFee + newSellDevFee;\r\n\r\n        if (totalBuyFees < 1501 && totalSellFees < 1501) {\r\n            buyMarketingFee = newBuyMarketingFee;\r\n            buyDevFee = newBuyDevFee;\r\n            sellMarketingFee = newSellMarketingFee;\r\n            sellDevFee = newSellDevFee;\r\n        }\r\n    }\r\n\r\n    function SetBotfees(uint256 newBotMarketingFee, uint256 newBotDevFee) external onlyOwnerOrDev {\r\n        totalBotFees = newBotMarketingFee + newBotDevFee;\r\n\r\n        if (totalBotFees < 9999) {\r\n            botMarketingFee = newBotMarketingFee;\r\n            botDevFee = newBotDevFee;\r\n        }\r\n    }\r\n\r\n    // Add to or remove an address from BotList\r\n    function BotListAddress(address account, bool trueOrFalse) external onlyDevOrMarketing {                        \r\n        if (trueOrFalse) {\r\n\r\n            if (account != address(this) && account != marketingWallet \r\n            && account != devWallet && !(automatedMarketMakerPairs[account])) {\r\n                _isBotListed[account] = trueOrFalse;                                         \r\n            }\r\n        } else {\r\n            _isBotListed[account] = trueOrFalse;\r\n        }\r\n    }\r\n\r\n    // Safety feature to prevent scammers from stealing funds from marketing deals\r\n    // Requires a manual call to remove from BotlistAddress(...) before recipient can sell or transfer to EOA\r\n    function MarketingTransfer(address to, uint256 amount) external onlyDevOrMarketing {\r\n        _transfer(msg.sender, to, amount);\r\n\r\n        if (to != address(this) && to != marketingWallet && to != devWallet && !(automatedMarketMakerPairs[to])) {\r\n            _isBotListed[to] = true;                                         \r\n        }\r\n    }\r\n\r\n    function SetWallets(address payable newMarketingWallet, address payable newDevWallet) external onlyOwnerOrDev {   \r\n        if (newDevWallet != address(0)) {                \r\n            marketingWallet = newMarketingWallet;\r\n            devWallet = newDevWallet;\r\n            _isExcludedFromFees[newMarketingWallet] = true;\r\n            _isExcludedFromFees[newDevWallet] = true;\r\n        }\r\n    }\r\n\r\n    function SetCanTransferBeforeTradingIsOpen(address account, bool trueOrFalse) external onlyOwnerOrDev {          \r\n        canTransferBeforeTradingIsOpen[account] = trueOrFalse;\r\n    }\r\n\r\n    // --- NO DEV ACCES ---\r\n    // If contract ownership renounced\r\n    // --> trading can NEVER be disabled again this way\r\n    function OpenTrading(bool status, uint256 blocks) external onlyOwner {    \r\n        if (status) {\r\n        unchecked {\r\n            uint256 launchblock = block.number; \r\n            uint256 blockUntil = 1 + launchblock; \r\n            lastBotBlock = blocks + blockUntil; \r\n            }   \r\n        }\r\n        tradingIsOpen = status;\r\n\r\n        emit TradingIsOpen(status);\r\n    }\r\n\r\n    function _transfer(                           \r\n        address from,       \r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        if(!tradingIsOpen) { \r\n            require(canTransferBeforeTradingIsOpen[from], \"BGLD: You are too early! Trading has not been enabled yet\"); \r\n        }\r\n\r\n        uint256 senderBalance = _balances[from];\r\n        require(senderBalance >= amount, \"BGLD: transfer amount exceeds balance\");\r\n    unchecked { _balances[from] = senderBalance - amount; }\r\n\r\n        if(_isBotListed[from]) { \r\n            \r\n            if (!(block.number <= lastBotBlock)) {      \r\n\r\n                if (to != address(this) && to != marketingWallet && to != devWallet) {\r\n                    uint256 marketingTokens = amount * botMarketingFee / 10000;\r\n                    uint256 devTokens = amount * botDevFee / 10000;\r\n                    amount = ProcessFees(from, amount, marketingTokens, devTokens);\r\n\r\n                    if (balanceOf(address(this)) > minLiquidationThreshold) {   \r\n                        SwapToDistributeETH();\r\n                    }\r\n                    _balances[to] += amount;\r\n                    emit Transfer(from, to, amount);\r\n                    return;\r\n                }\r\n            }                       \r\n        }\r\n\r\n        if(block.number <= lastBotBlock) {            \r\n\r\n            if (to != address(this) && to != marketingWallet && to != devWallet && !(automatedMarketMakerPairs[to])) {\r\n                _isBotListed[to] = true;                                         \r\n            }\r\n        }                                    \r\n\r\n        bool takeFee = (_isExcludedFromFees[from] || _isExcludedFromFees[to]) ? false : true;\r\n\r\n        if(takeFee) { \r\n\r\n            if (automatedMarketMakerPairs[from]) { // Buy transactions   \r\n                lastBuyBlock[to] = block.number;    \r\n         \r\n                if (totalBuyFees > 0) {\r\n\r\n            unchecked {\r\n                uint256 marketingTokens = amount * buyMarketingFee / 10000;\r\n                uint256 devTokens = amount * buyDevFee / 10000;\r\n                amount = ProcessFees(from, amount, marketingTokens, devTokens); }\r\n                }\r\n\r\n            } else { // Sells & transfer transactions\r\n\r\n                if (lastBuyBlock[from] == block.number) {\r\n\r\n                    if (from != address(this) && from != marketingWallet && from != devWallet && !(automatedMarketMakerPairs[from])) {\r\n                        _isBotListed[from] = true;\r\n\r\n                        if (to != address(this) && to != marketingWallet && to != devWallet) {\r\n                            uint256 marketingTokens = amount * botMarketingFee / 10000;\r\n                            uint256 devTokens = amount * botDevFee / 10000;\r\n                            amount = ProcessFees(from, amount, marketingTokens, devTokens);\r\n\r\n                            if (balanceOf(address(this)) > minLiquidationThreshold) {   \r\n                                SwapToDistributeETH();\r\n                            }\r\n                            _balances[to] += amount;\r\n                            emit Transfer(from, to, amount);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                if (totalSellFees > 0) {\r\n            unchecked { \r\n                uint256 marketingTokens = amount * sellMarketingFee / 10000;                   \r\n                uint256 devTokens = amount * sellDevFee / 10000;\r\n                amount = ProcessFees(from, amount, marketingTokens, devTokens); }                \r\n                }\r\n\r\n                if (balanceOf(address(this)) > minLiquidationThreshold) {   \r\n                    SwapToDistributeETH();\r\n                }\r\n            }        \r\n        }\r\n\r\n        _balances[to] += amount;\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function ProcessFees(address from, uint256 amount, uint256 marketingTokens, uint256 devTokens) private returns(uint256) {\r\n        unchecked { \r\n            if (distributeTokens) {\r\n                amount = amount - marketingTokens - devTokens;\r\n                _balances[marketingWallet] += marketingTokens;         \r\n\r\n                emit Transfer(from, marketingWallet, marketingTokens);\r\n                _balances[devWallet] += devTokens;\r\n\r\n                emit Transfer(from, devWallet, devTokens);\r\n\r\n            } else {\r\n                accMarketingFee += marketingTokens;                            \r\n                accDevFee += devTokens;\r\n                uint256 fees = marketingTokens + devTokens;\r\n                amount -= fees;\r\n\r\n                _balances[address(this)] += fees;\r\n\r\n                emit Transfer(from, address(this), fees);\r\n            }\r\n\r\n            return amount;\r\n        }\r\n    }\r\n\r\n    function swapTokensForETH(uint256 tokenAmount) private {       \r\n        // Generate the uniswap pair path of BGLD -> WETH\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(_uniswapV2Router), tokenAmount);\r\n\r\n        _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(       \r\n            tokenAmount,\r\n            0, // Accept any amount of ETH\r\n            path,\r\n            address(this),                                                          \r\n            block.timestamp\r\n        );\r\n    }                                  \r\n\r\n    function SwapToDistributeETH() private { \r\n    unchecked {                                         \r\n        uint256 accTokensToSwap = accMarketingFee + accDevFee;    \r\n        uint256 tokensToSwap = balanceOf(address(this));                     \r\n\r\n        if (tokensToSwap > maxLiquidationThreshold) {       \r\n            tokensToSwap = maxLiquidationThreshold;\r\n            swapTokensForETH(tokensToSwap); \r\n\r\n            uint256 ethBalance = address(this).balance;                                             \r\n            uint256 ethToMarketing = ethBalance * accMarketingFee / accTokensToSwap;                  \r\n            \r\n            (bool success, ) = payable(address(marketingWallet)).call{value: ethToMarketing}(\"\");\r\n\r\n            if(success) {                                                                \r\n                accMarketingFee = accMarketingFee - (tokensToSwap * accMarketingFee / accTokensToSwap);                                                         \r\n            }\r\n\r\n            uint256 ethToDev = address(this).balance;\r\n            (success, ) = payable(address(devWallet)).call{value: ethToDev}(\"\");\r\n\r\n            if(success) {\r\n                accDevFee = accDevFee - (tokensToSwap * accDevFee / accTokensToSwap);\r\n            }\r\n\r\n        } else {\r\n            swapTokensForETH(tokensToSwap); \r\n\r\n            uint256 ethBalance = address(this).balance;                                             \r\n            uint256 ethToMarketing = ethBalance * accMarketingFee / accTokensToSwap;                  \r\n\r\n            (bool success, ) = payable(address(marketingWallet)).call{value: ethToMarketing}(\"\");\r\n\r\n            if(success) {                                                                \r\n                accMarketingFee = 1;                                                          \r\n            }\r\n\r\n            uint256 ethToDev = address(this).balance;\r\n            (success, ) = payable(address(devWallet)).call{value: ethToDev}(\"\");\r\n\r\n            if(success) {\r\n                accDevFee = 1;\r\n            }\r\n        } }\r\n    }\r\n   \r\n    // Withdraw ETH that's potentially stuck in the BGLD contract\r\n    function recoverETHfromContract() external onlyOwnerOrDev {\r\n        payable(devWallet).transfer(address(this).balance);\r\n    }\r\n\r\n    // Withdraw ERC20 tokens that are potentially stuck in the BGLD contract                            \r\n    function recoverTokensFromContract(address _tokenAddress, uint256 _amount) external onlyOwnerOrDev {                           \r\n        // Update the contract's accumulated token balances accordingly\r\n        if (_tokenAddress == address(this)) {\r\n            \r\n            if (balanceOf(address(this)) == _amount) { \r\n                accMarketingFee = 1;\r\n                accDevFee = 1;\r\n            } else { \r\n                accMarketingFee = accMarketingFee - (_amount * accMarketingFee / (accMarketingFee + accDevFee));\r\n                accDevFee = accDevFee - (_amount * accDevFee / (accMarketingFee + accDevFee));          \r\n            }\r\n        }\r\n        IERC20(_tokenAddress).transfer(devWallet, _amount);\r\n    }\r\n}\r\n\r\n/*\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \r\n ███████████                                 █████      █████████           ████      █████\r\n░░███░░░░░███                               ░░███      ███░░░░░███         ░░███     ░░███ \r\n ░███    ░███  ██████    █████   ██████   ███████     ███     ░░░   ██████  ░███   ███████ \r\n ░██████████  ░░░░░███  ███░░   ███░░███ ███░░███    ░███          ███░░███ ░███  ███░░███ \r\n ░███░░░░░███  ███████ ░░█████ ░███████ ░███ ░███    ░███    █████░███ ░███ ░███ ░███ ░███ \r\n ░███    ░███ ███░░███  ░░░░███░███░░░  ░███ ░███    ░░███  ░░███ ░███ ░███ ░███ ░███ ░███ \r\n ███████████ ░░████████ ██████ ░░██████ ░░████████    ░░█████████ ░░██████  █████░░████████\r\n░░░░░░░░░░░   ░░░░░░░░ ░░░░░░   ░░░░░░   ░░░░░░░░      ░░░░░░░░░   ░░░░░░  ░░░░░  ░░░░░░░░ \r\n                                                                                           \r\n                                                                                           \r\n                                                                                           \r\n ███████████    █████████  █████       ██████████                                          \r\n░░███░░░░░███  ███░░░░░███░░███       ░░███░░░░███                                         \r\n ░███    ░███ ███     ░░░  ░███        ░███   ░░███                                        \r\n ░██████████ ░███          ░███        ░███    ░███                                        \r\n ░███░░░░░███░███    █████ ░███        ░███    ░███                                        \r\n ░███    ░███░░███  ░░███  ░███      █ ░███    ███                                         \r\n ███████████  ░░█████████  ███████████ ██████████                                          \r\n░░░░░░░░░░░    ░░░░░░░░░  ░░░░░░░░░░░ ░░░░░░░░░░ \r\n\r\n*/"}}}