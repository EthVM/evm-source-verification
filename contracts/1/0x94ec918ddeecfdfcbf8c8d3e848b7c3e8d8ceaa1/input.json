{"language":"Solidity","settings":{"evmVersion":"byzantium","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"WrappedZynecoin.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-09-20\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t * @dev Multiplies two numbers, reverts on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b > 0); // Solidity only automatically asserts when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t*/\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Adds two numbers, reverts on overflow.\r\n\t*/\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n\t* reverts when dividing by zero.\r\n\t\t*/\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\ncontract ERC20 {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping (address => uint256) private _balances;\r\n\r\n\tmapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n\tuint256 private _totalSupply;\r\n\t\r\n\tstring private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 value\r\n\t);\r\n\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n\r\n\tconstructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n\t/**\r\n\t* @dev Total number of tokens in existence\r\n\t*/\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Gets the balance of the specified address.\r\n\t* @param owner The address to query the balance of.\r\n\t* @return An uint256 representing the amount owned by the passed address.\r\n\t */\r\n\tfunction balanceOf(address owner) public view returns (uint256) {\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t* @param owner address The address which owns the funds.\r\n\t* @param spender address The address which will spend the funds.\r\n\t* @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t */\r\n\tfunction allowance(\r\n\t\t\taddress owner,\r\n\t\t\taddress spender\r\n\t\t\t)\r\n\t\tpublic\r\n\t\tview\r\n\t\treturns (uint256)\r\n\t\t{\r\n\t\t\treturn _allowed[owner][spender];\r\n\t\t}\r\n\r\n\t/**\r\n\t* @dev Transfer token for a specified address\r\n\t* @param to The address to transfer to.\r\n\t* @param value The amount to be transferred.\r\n\t */\r\n\tfunction transfer(address to, uint256 value) public returns (bool) {\r\n\t\t_transfer(msg.sender, to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n\t* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n\t* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n\t* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n\t* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t* @param spender The address which will spend the funds.\r\n\t* @param value The amount of tokens to be spent.\r\n\t */\r\n\tfunction approve(address spender, uint256 value) public returns (bool) {\r\n\t\trequire(spender != address(0));\r\n\r\n\t_allowed[msg.sender][spender] = value;\r\n\temit Approval(msg.sender, spender, value);\r\n\treturn true;\r\n}\r\n\r\n/**\r\n* @dev Transfer tokens from one address to another\r\n* @param from address The address which you want to send tokens from\r\n* @param to address The address which you want to transfer to\r\n* @param value uint256 the amount of tokens to be transferred\r\n */\r\nfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t\t)\r\n\tpublic\r\nreturns (bool)\r\n{\r\n\trequire(value <= _allowed[from][msg.sender]);\r\n\r\n_allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n_transfer(from, to, value);\r\nreturn true;\r\n  }\r\n\r\n  /**\r\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n  * approve should be called when allowed_[_spender] == 0. To increment\r\n  * allowed value is better to use this function to avoid 2 calls (and wait until\r\n  * the first transaction is mined)\r\n  * From MonolithDAO Token.sol\r\n  * @param spender The address which will spend the funds.\r\n  * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n\t  address spender,\r\n\t  uint256 addedValue\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n\t  require(spender != address(0));\r\n\r\n\t  _allowed[msg.sender][spender] = (\r\n\t\t  _allowed[msg.sender][spender].add(addedValue));\r\n\t\t  emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n\t\t  return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n  * approve should be called when allowed_[_spender] == 0. To decrement\r\n  * allowed value is better to use this function to avoid 2 calls (and wait until\r\n  * the first transaction is mined)\r\n  * From MonolithDAO Token.sol\r\n  * @param spender The address which will spend the funds.\r\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n\t  address spender,\r\n\t  uint256 subtractedValue\r\n  )\r\n  public\r\n  returns (bool)\r\n  {\r\n\t  require(spender != address(0));\r\n\r\n\t  _allowed[msg.sender][spender] = (\r\n\t\t  _allowed[msg.sender][spender].sub(subtractedValue));\r\n\t\t  emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n\t\t  return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer token for a specified addresses\r\n   * @param from The address to transfer from.\r\n   * @param to The address to transfer to.\r\n   * @param value The amount to be transferred.\r\n   */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n\t  require(value <= _balances[from]);\r\n\t  require(to != address(0));\r\n\r\n\t  _balances[from] = _balances[from].sub(value);\r\n\t  _balances[to] = _balances[to].add(value);\r\n\t  emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n\t  require(account != address(0));\r\n\t  _totalSupply = _totalSupply.add(value);\r\n\t  _balances[account] = _balances[account].add(value);\r\n\t  emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function that burns an amount of the token of a given\r\n  * account.\r\n  * @param account The account whose tokens will be burnt.\r\n  * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n\t  require(account != address(0));\r\n\t  require(value <= _balances[account]);\r\n\r\n\t  _totalSupply = _totalSupply.sub(value);\r\n\t  _balances[account] = _balances[account].sub(value);\r\n\t  emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n  * @dev Internal function that burns an amount of the token of a given\r\n  * account, deducting from the sender's allowance for said account. Uses the\r\n  * internal burn function.\r\n  * @param account The account whose tokens will be burnt.\r\n  * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n\t  require(value <= _allowed[account][msg.sender]);\r\n\r\n\t  // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n\t  // this function needs to emit an event with the updated approval.\r\n\t  _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n\t\t  value);\r\n\t\t  _burn(account, value);\r\n  }\r\n}\r\n\r\n\r\ncontract WrappedZynecoin is ERC20 {\r\n    /*\r\n     *  Events\r\n     */\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n    event TokenBurn(uint256 indexed burnID, address indexed burner, uint256 value, bytes data);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n    uint public WITHDRAW_FEE = 0;\r\n    \r\n    /*\r\n     *  Storage\r\n     */\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    address public issuer;\r\n    uint public required;\r\n    uint public transactionCount;\r\n    TokenBurnData[] public burnList;\r\n\r\n    //id hash Mapping\r\n    mapping(uint256 => bytes32) public idHashMapping;\r\n\r\n    struct TokenBurnData {\r\n        uint256 value;\r\n        address burner;\r\n        bytes data;\r\n    }\r\n    \r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data; //data is used in transactions altering owner list\r\n        bool executed;\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        require(ownerCount <= MAX_OWNER_COUNT\r\n        && _required <= ownerCount\r\n        && _required != 0\r\n        && ownerCount != 0);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIssuer() {\r\n        require(msg.sender == issuer);\r\n        _;\r\n    }\r\n    \r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    constructor (address[] _owners,\r\n                 uint _required, string memory _name,\r\n                 string memory _symbol, uint8 _decimals,\r\n                 uint256 cap,\r\n                 uint256 withdrawFee\r\n                ) ERC20(_name, _symbol, _decimals) public validRequirement(_owners.length, _required) {\r\n        _mint(msg.sender, cap);\r\n        issuer = msg.sender;\r\n        WITHDRAW_FEE = withdrawFee;\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner) \r\n    public\r\n    onlyWallet\r\n    ownerDoesNotExist(owner)\r\n    notNull(owner)\r\n    validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        emit OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param newOwner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        emit OwnerRemoval(owner);\r\n        emit OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n    public\r\n    onlyWallet\r\n    validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data, bytes32 txHash) \r\n    public\r\n    returns (uint transactionId)\r\n    {\r\n        //transaction is considered as minting if no data provided, otherwise it's owner changing transaction\r\n        transactionId = addTransaction(destination, value, data, txHash);\r\n        confirmTransaction(transactionId);\r\n    }\r\n    \r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows an user to burn the token.\r\n    function burn(uint value, bytes data)\r\n    public\r\n    {\r\n        require(value > WITHDRAW_FEE);\r\n        super._burn(msg.sender, value);\r\n        \r\n        if (WITHDRAW_FEE > 0) {\r\n            super._mint(issuer, WITHDRAW_FEE);\r\n        }\r\n        uint256 burnValue = value.sub(WITHDRAW_FEE);\r\n        burnList.push(TokenBurnData({\r\n            value: burnValue,\r\n            burner: msg.sender,\r\n            data: data \r\n        }));\r\n        emit TokenBurn(burnList.length - 1, msg.sender, burnValue, data);\r\n\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n\r\n            // just need multisig for minting - freely burn\r\n            if (txn.data.length == 0) {\r\n                //execute minting transaction\r\n                txn.value = txn.value;\r\n                super._mint(txn.destination, txn.value);\r\n                emit Execution(transactionId);\r\n            } else {\r\n                //transaction that alters the owners list\r\n                if (txn.destination.call.value(txn.value)(txn.data))\r\n                    emit Execution(transactionId);\r\n                else {\r\n                    emit ExecutionFailure(transactionId);\r\n                    txn.executed = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n    public\r\n    constant\r\n    returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data, bytes32 txHash)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        //update idHashMapping\r\n        idHashMapping[transactionId] = txHash;\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n            || executed && transactions[i].executed)\r\n                count += 1;\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners()\r\n    public\r\n    constant\r\n    returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n    public\r\n    constant\r\n    returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint[] _transactionIds)\r\n    {\r\n        uint end = to > transactionCount? transactionCount: to;\r\n        uint[] memory transactionIdsTemp = new uint[](end - from);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = from; i < to; i++) {\r\n            if ((pending && !transactions[i].executed)\r\n                || (executed && transactions[i].executed))\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        }\r\n        _transactionIds = new uint[](count);\r\n        for (i = 0; i < count; i++)\r\n            _transactionIds[i] = transactionIdsTemp[i];\r\n    }\r\n    \r\n    function getBurnCount() public view returns (uint256) {\r\n        return burnList.length;\r\n    }\r\n\r\n    function getBurn(uint burnId) public view returns (address _burner, uint256 _value, bytes _data) {\r\n        _burner = burnList[burnId].burner;\r\n        _value = burnList[burnId].value;\r\n        _data = burnList[burnId].data;\r\n    }\r\n    \r\n    /// @dev Allows to tramsfer contact issuer\r\n    function transferIssuer(address newIssuer) \r\n    public\r\n    onlyIssuer\r\n    notNull(newIssuer)\r\n    {\r\n        issuer = newIssuer;\r\n    }\r\n\r\n    function setWithdrawFee(uint256 withdrawFee) public onlyIssuer {\r\n        WITHDRAW_FEE = withdrawFee;\r\n    }\r\n\r\n}"}}}