{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"WrapAndUnWrap.sol":{"content":"/*\r\n_____  _\r\n|  __ \\| |\r\n| |__) | | _____  ___   _ ___\r\n|  ___/| |/ _ \\ \\/ / | | / __|\r\n| |    | |  __/>  <| |_| \\__ \\\r\n|_|   _|_|\\___/_/\\_\\\\__,_|___/            _      _____   __          __\r\n| |  | |     (_)                         | |    |  __ \\  \\ \\        / /\r\n| |  | |_ __  _ _____      ____ _ _ __   | |    | |__) |  \\ \\  /\\  / / __ __ _ _ __  _ __   ___ _ __\r\n| |  | | '_ \\| / __\\ \\ /\\ / / _` | '_ \\  | |    |  ___/    \\ \\/  \\/ / '__/ _` | '_ \\| '_ \\ / _ \\ '__|\r\n| |__| | | | | \\__ \\\\ V  V / (_| | |_) | | |____| |         \\  /\\  /| | | (_| | |_) | |_) |  __/ |\r\n \\____/|_| |_|_|___/ \\_/\\_/ \\__,_| .__/  |______|_|          \\/  \\/ |_|  \\__,_| .__/| .__/ \\___|_|\r\n                                 | |                                          | |   | |\r\n                                 |_|                                          |_|   |_|\r\n\r\n*/\r\n\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n//Github: https://github.com/stimuluspackage/PlexusContracts/blob/master/contracts/wrapper.sol\r\n\r\npragma solidity 0.7.4;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface WrappedETH {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n\r\n}\r\n\r\ninterface UniswapFactory{\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n\r\n\r\ninterface UniswapV2{\r\n\r\n\r\n   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\r\n   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\r\n   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\r\n   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\r\n\r\n   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract WrapAndUnWrap{\r\n\r\n  using SafeMath\r\n    for uint256;\r\n\r\n  address payable public owner;\r\n  //placehodler token address for specifying eth tokens\r\n  address public ETH_TOKEN_ADDRESS  = address(0x0);\r\n  address public WETH_TOKEN_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  WrappedETH wethToken = WrappedETH(WETH_TOKEN_ADDRESS);\r\n  uint256 approvalAmount = 1000000000000000000000000000000;\r\n  uint256 longTimeFromNow = 1000000000000000000000000000;\r\n  address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n  address uniFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n  UniswapV2 uniswapExchange = UniswapV2(uniAddress);\r\n  UniswapFactory factory = UniswapFactory(uniFactoryAddress);\r\n  mapping (address => address[]) public lpTokenAddressToPairs;\r\n  mapping(string=>address) public stablecoins;\r\n  mapping(address=>mapping(address=>address[])) public presetPaths;\r\n  bool public changeRecpientIsOwner;\r\n   \r\n    \r\n\r\n  modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only owner can call this function.\"\r\n        );\r\n        _;\r\n}\r\n\r\n    fallback() external payable {\r\n\r\n\r\n    }\r\n\r\n  constructor() public payable {\r\n         stablecoins[\"DAI\"] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n         stablecoins[\"USDT\"] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n         stablecoins[\"USDC\"] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n         changeRecpientIsOwner = false;\r\n        owner= msg.sender;\r\n\r\n  }\r\n\r\n\r\n  function wrap(address sourceToken, address[] memory destinationTokens, uint256 amount) public payable returns(address, uint256){\r\n\r\n\r\n    ERC20 sToken = ERC20(sourceToken);\r\n    ERC20 dToken = ERC20(destinationTokens[0]);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n      if(destinationTokens.length==1){\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer 1\");\r\n          sToken.approve(uniAddress, approvalAmount);\r\n        }\r\n\r\n        conductUniswap(sourceToken, destinationTokens[0], amount);\r\n        uint256 thisBalance = dToken.balanceOf(address(this));\r\n        dToken.transfer(msg.sender, thisBalance);\r\n        return (destinationTokens[0], thisBalance);\r\n\r\n      }\r\n\r\n      else{\r\n\r\n        bool updatedweth =false;\r\n        if(sourceToken == ETH_TOKEN_ADDRESS){\r\n          WrappedETH sToken1 = WrappedETH(WETH_TOKEN_ADDRESS);\r\n          sToken1.deposit{value:msg.value}();\r\n          sToken = ERC20(WETH_TOKEN_ADDRESS);\r\n          amount = msg.value;\r\n          sourceToken = WETH_TOKEN_ADDRESS;\r\n          updatedweth =true;\r\n        }\r\n\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS && updatedweth==false){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  2\");\r\n          sToken.approve(uniAddress, approvalAmount);\r\n        }\r\n\r\n        if(destinationTokens[0] == ETH_TOKEN_ADDRESS){\r\n              destinationTokens[0] = WETH_TOKEN_ADDRESS;\r\n        }\r\n        if(destinationTokens[1] == ETH_TOKEN_ADDRESS){\r\n            destinationTokens[1] = WETH_TOKEN_ADDRESS;\r\n        }\r\n\r\n\r\n\r\n        if(sourceToken !=destinationTokens[0]){\r\n            conductUniswap(sourceToken, destinationTokens[0], amount.div(2));\r\n        }\r\n        if(sourceToken !=destinationTokens[1]){\r\n\r\n            conductUniswap(sourceToken, destinationTokens[1], amount.div(2));\r\n        }\r\n\r\n        ERC20 dToken2 = ERC20(destinationTokens[1]);\r\n        uint256 dTokenBalance = dToken.balanceOf(address(this));\r\n        uint256 dTokenBalance2 = dToken2.balanceOf(address(this));\r\n\r\n        dToken.approve(uniAddress, approvalAmount);\r\n        dToken2.approve(uniAddress, approvalAmount);\r\n\r\n\r\n\r\n\r\n\r\n        (,,uint liquidityCoins)  = uniswapExchange.addLiquidity(destinationTokens[0],destinationTokens[1], dTokenBalance, dTokenBalance2, 1,1, address(this), longTimeFromNow);\r\n\r\n\r\n        address thisPairAddress = factory.getPair(destinationTokens[0],destinationTokens[1]);\r\n        ERC20 lpToken = ERC20(thisPairAddress);\r\n        lpTokenAddressToPairs[thisPairAddress] =[destinationTokens[0], destinationTokens[1]];\r\n        uint256 thisBalance =lpToken.balanceOf(address(this));\r\n        lpToken.transfer(msg.sender, thisBalance);\r\n        \r\n        //transfer any change to changeRecipient (from a pair imbalance. Should never be more than a few basis points)\r\n        address changeRecipient = msg.sender;\r\n        if(changeRecpientIsOwner == true){\r\n            changeRecipient = owner;\r\n        }\r\n        if(dToken.balanceOf(address(this)) >0){\r\n            dToken.transfer(changeRecipient, dToken.balanceOf(address(this)));\r\n        }\r\n        if(dToken2.balanceOf(address(this)) >0){\r\n            dToken2.transfer(changeRecipient, dToken2.balanceOf(address(this)));\r\n        }\r\n        \r\n        return (thisPairAddress,thisBalance) ;\r\n      }\r\n\r\n\r\n\r\n    }\r\n    \r\n    function updateStableCoinAddress(string memory coinName, address newAddress) public onlyOwner returns(bool){\r\n        stablecoins[coinName] = newAddress;\r\n        return true;\r\n        \r\n    }\r\n    \r\n    function updatePresetPaths(address sellToken, address buyToken, address[] memory newPath ) public onlyOwner returns(bool){\r\n        presetPaths[sellToken][buyToken] = newPath;\r\n        return true;\r\n    }\r\n    \r\n    //owner can turn on ability to collect a small fee from trade imbalances on LP conversions\r\n    function updateChangeRecipientBool(bool changeRecpientIsOwnerBool ) public onlyOwner returns(bool){\r\n        changeRecpientIsOwner = changeRecpientIsOwnerBool;\r\n        return true;\r\n    }\r\n    \r\n    \r\n\r\n      function unwrap(address sourceToken, address destinationToken, uint256 amount) public payable returns( uint256){\r\n        \r\n        address originalDestinationToken = destinationToken;\r\n        ERC20 sToken = ERC20(sourceToken);\r\n        if(destinationToken == ETH_TOKEN_ADDRESS){\r\n            destinationToken = WETH_TOKEN_ADDRESS;\r\n        }\r\n        ERC20 dToken = ERC20(destinationToken);\r\n\r\n\r\n\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  3 unwrapping\");\r\n        }\r\n\r\n        \r\n        \r\n          if(lpTokenAddressToPairs[sourceToken].length !=0){\r\n            sToken.approve(uniAddress, approvalAmount);\r\n          uniswapExchange.removeLiquidity(lpTokenAddressToPairs[sourceToken][0], lpTokenAddressToPairs[sourceToken][1], amount, 0,0, address(this), longTimeFromNow);\r\n\r\n          ERC20 pToken1 = ERC20(lpTokenAddressToPairs[sourceToken][0]);\r\n          ERC20 pToken2 = ERC20(lpTokenAddressToPairs[sourceToken][1]);\r\n\r\n          uint256 pTokenBalance = pToken1.balanceOf(address(this));\r\n          uint256 pTokenBalance2 = pToken2.balanceOf(address(this));\r\n          pToken1.approve(uniAddress, approvalAmount);\r\n          pToken2.approve(uniAddress, approvalAmount);\r\n          if(lpTokenAddressToPairs[sourceToken][0] != destinationToken){\r\n              conductUniswap(lpTokenAddressToPairs[sourceToken][0], destinationToken, pTokenBalance);\r\n          }\r\n          if(lpTokenAddressToPairs[sourceToken][1] != destinationToken){\r\n              conductUniswap(lpTokenAddressToPairs[sourceToken][1], destinationToken, pTokenBalance2);\r\n          }\r\n\r\n\r\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\r\n          \r\n          if(originalDestinationToken == ETH_TOKEN_ADDRESS){\r\n              wethToken.withdraw(destinationTokenBalance);\r\n              msg.sender.transfer(address(this).balance);\r\n          }\r\n          else{\r\n               dToken.transfer(msg.sender, destinationTokenBalance);\r\n          }\r\n          \r\n         \r\n          return destinationTokenBalance;\r\n\r\n        }\r\n        \r\n        else{\r\n\r\n            sToken.approve(uniAddress, approvalAmount);\r\n            if(sourceToken != destinationToken){\r\n                conductUniswap(sourceToken, destinationToken, amount);\r\n            }\r\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\r\n          dToken.transfer(msg.sender, destinationTokenBalance);\r\n          return destinationTokenBalance;\r\n        }\r\n\r\n    \r\n    \r\n  \r\n        \r\n\r\n\r\n\r\n\r\n\r\n      }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function updateOwnerAddress(address payable newOwner) onlyOwner public returns (bool){\r\n     owner = newOwner;\r\n     return true;\r\n   }\r\n\r\n   function updateUniswapExchange(address newAddress ) public onlyOwner returns (bool){\r\n\r\n    uniswapExchange = UniswapV2( newAddress);\r\n    uniAddress = newAddress;\r\n    return true;\r\n\r\n  }\r\n\r\n  function updateUniswapFactory(address newAddress ) public onlyOwner returns (bool){\r\n\r\n   factory = UniswapFactory( newAddress);\r\n   uniFactoryAddress = newAddress;\r\n   return true;\r\n\r\n }\r\n\r\n\r\n\r\n  function conductUniswap(address sellToken, address buyToken, uint amount) internal returns (uint256 amounts1){\r\n\r\n            if(sellToken ==ETH_TOKEN_ADDRESS && buyToken == WETH_TOKEN_ADDRESS){\r\n                wethToken.deposit{value:msg.value}();\r\n            }\r\n            else if(sellToken == address(0x0)){\r\n                \r\n               // address [] memory addresses = new address[](2);\r\n               address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\r\n                //addresses[0] = WETH_TOKEN_ADDRESS;\r\n                //addresses[1] = buyToken;\r\n                uniswapExchange.swapExactETHForTokens{value:msg.value}(0, addresses, address(this), 1000000000000000 );\r\n\r\n            }\r\n\r\n            else if(sellToken == WETH_TOKEN_ADDRESS){\r\n                wethToken.withdraw(amount);\r\n\r\n                //address [] memory addresses = new address[](2);\r\n                address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\r\n                //addresses[0] = WETH_TOKEN_ADDRESS;\r\n                //addresses[1] = buyToken;\r\n                uniswapExchange.swapExactETHForTokens{value:amount}(0, addresses, address(this), 1000000000000000 );\r\n\r\n            }\r\n\r\n\r\n\r\n            else{\r\n          //address [] memory addresses = new address[](2);\r\n         // addresses[0] = sellToken;\r\n          //addresses[1] = buyToken;\r\n          address [] memory addresses = getBestPath(sellToken, buyToken, amount);\r\n           uint256 [] memory amounts = conductUniswapT4T(addresses, amount );\r\n           uint256 resultingTokens = amounts[amounts.length-1];\r\n           return resultingTokens;\r\n            }\r\n    }\r\n    \r\n    \r\n    //gets the best path to route the transaction on Uniswap\r\n    function getBestPath(address sellToken, address buyToken, uint256 amount) public view returns (address[] memory){\r\n        \r\n        address [] memory defaultPath =new address[](2);\r\n        defaultPath[0]=sellToken;\r\n        defaultPath[1] = buyToken;\r\n        \r\n       \r\n        if(presetPaths[sellToken][buyToken].length !=0){\r\n            return presetPaths[sellToken][buyToken];\r\n        }\r\n        \r\n        \r\n        if(sellToken == stablecoins[\"DAI\"] || sellToken == stablecoins[\"USDC\"] || sellToken == stablecoins[\"USDT\"]){\r\n            return defaultPath;\r\n        }\r\n        if(buyToken == stablecoins[\"DAI\"] || buyToken == stablecoins[\"USDC\"] || buyToken == stablecoins[\"USDT\"]){\r\n            return defaultPath;\r\n        }\r\n        \r\n        \r\n        \r\n        address[] memory daiPath = new address[](3); \r\n        address[] memory usdcPath =new address[](3);\r\n        address[] memory usdtPath =new address[](3);\r\n        \r\n        daiPath[0] = sellToken;\r\n        daiPath[1] = stablecoins[\"DAI\"];\r\n        daiPath[2] = buyToken;\r\n        \r\n        usdcPath[0] = sellToken;\r\n        usdcPath[1] = stablecoins[\"USDC\"];\r\n        usdcPath[2] = buyToken;\r\n        \r\n        usdtPath[0] = sellToken;\r\n        usdtPath[1] = stablecoins[\"USDT\"];\r\n        usdtPath[2] = buyToken;\r\n        \r\n        \r\n        uint256 directPathOutput =  getPriceFromUniswap(defaultPath, amount)[1];\r\n        \r\n        \r\n        uint256[] memory daiPathOutputRaw = getPriceFromUniswap(daiPath, amount);\r\n        uint256[]  memory usdtPathOutputRaw = getPriceFromUniswap(usdtPath, amount);\r\n        uint256[]  memory usdcPathOutputRaw = getPriceFromUniswap(usdcPath, amount);\r\n        \r\n        //uint256 directPathOutput = directPathOutputRaw[directPathOutputRaw.length-1];\r\n        uint256 daiPathOutput = daiPathOutputRaw[daiPathOutputRaw.length-1];\r\n        uint256 usdtPathOutput = usdtPathOutputRaw[usdtPathOutputRaw.length-1];\r\n        uint256 usdcPathOutput = usdcPathOutputRaw[usdcPathOutputRaw.length-1];\r\n        \r\n        uint256 bestPathOutput = directPathOutput;\r\n        address[] memory bestPath = new address[](2);\r\n        address[] memory bestPath3 = new address[](3);\r\n        //return defaultPath;\r\n        bestPath = defaultPath;\r\n        \r\n        bool isTwoPath = true;\r\n        \r\n        if(directPathOutput < daiPathOutput){\r\n            isTwoPath=false;\r\n            bestPathOutput = daiPathOutput;\r\n            bestPath3 = daiPath;\r\n        }\r\n        if(bestPathOutput < usdcPathOutput){\r\n            isTwoPath=false;\r\n            bestPathOutput = usdcPathOutput;\r\n            bestPath3 = usdcPath;\r\n        }\r\n         if(bestPathOutput < usdtPathOutput){\r\n             isTwoPath=false;\r\n            bestPathOutput = usdtPathOutput;\r\n            bestPath3 = usdtPath;\r\n        }\r\n        \r\n        require(bestPathOutput >0, \"This trade will result in getting zero tokens back. Reverting\");\r\n        \r\n        if(isTwoPath==true){\r\n              return bestPath;\r\n        }\r\n        else{\r\n            return bestPath3;\r\n        }\r\n      \r\n        \r\n        \r\n    }\r\n    \r\n    function getPriceFromUniswap(address  [] memory theAddresses, uint amount) public view returns (uint256[] memory amounts1){  \r\n       \r\n           \r\n        try uniswapExchange.getAmountsOut(amount,theAddresses ) returns (uint256[] memory amounts){\r\n            return amounts;\r\n        }\r\n        catch  {\r\n            uint256 [] memory amounts2= new uint256[](2);\r\n            amounts2[0]=0;\r\n            amounts2[1]=0;\r\n            return amounts2;\r\n            \r\n        }\r\n       \r\n        //return amounts;\r\n          \r\n    }\r\n\r\n    function conductUniswapT4T(address  [] memory theAddresses, uint amount) internal returns (uint256[] memory amounts1){\r\n\r\n           uint256 deadline = 1000000000000000;\r\n           uint256 [] memory amounts =  uniswapExchange.swapExactTokensForTokens(amount, 0, theAddresses, address(this),deadline );\r\n           return amounts;\r\n\r\n    }\r\n\r\n    function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\r\n\r\n      if (address(token) == ETH_TOKEN_ADDRESS) {\r\n          destination.transfer(amount);\r\n      }\r\n      else {\r\n          ERC20 tokenToken = ERC20(token);\r\n          require(tokenToken.transfer(destination, amount));\r\n      }\r\n      return true;\r\n  }\r\n\r\n\r\n  //this function is here for easy testing in production on a sandbox\r\n   function getUserTokenBalance(address userAddress, address tokenAddress) public view returns (uint256){\r\n    ERC20 token = ERC20(tokenAddress);\r\n    return token.balanceOf(userAddress);\r\n\r\n  }\r\n\r\n  function kill() virtual public onlyOwner {\r\n         selfdestruct(owner);\r\n  }\r\n\r\n}"}}}