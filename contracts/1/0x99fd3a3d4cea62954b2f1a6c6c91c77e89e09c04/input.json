{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/tibia.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nlibrary Strings {\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract CryptoItems is ERC165, IERC721, IERC721Metadata {\r\n\r\n    using Address for address;\r\n    using Strings for uint256;\r\n   \r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n \r\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\r\n    \r\n    string private _baseURI;\r\n    address payable public author;\r\n\r\n\tstring constant public _name = \"CryptoTibia\";\r\n\tstring constant public _symbol = \"TIBIA\";\r\n\tuint256 public _totalSupply = 1000;\r\n\t\r\n    uint public itemsRemainingToAssign = 0;\r\n    \r\n    struct Offer {\r\n        bool isForSale;\r\n        uint itemsIndex;\r\n        address seller;\r\n        uint minValue;      \r\n        address onlySellTo;     \r\n    }\r\n\r\n    struct Bid {\r\n        bool hasBid;\r\n        uint itemsIndex;\r\n        address bidder;\r\n        uint value;\r\n    }\r\n    \r\n    struct Info {\r\n        uint itemsIndex;\r\n        string authorInfo;\r\n        string publicInfo;\r\n    }\r\n    \r\n    mapping (uint256 => string) private _tokenURIs;\r\n        \r\n    mapping (address => uint256) public _balances;\r\n    mapping (uint => address) public _owners;\r\n\r\n    mapping (uint => Offer) public itemsOfferedForSale;\r\n    mapping (uint => Bid) public itemsBids;\r\n    mapping (uint => Info) public itemsInfo;\r\n\r\n    mapping (address => uint) public pendingWithdrawals;\r\n    mapping (uint256 => address) public _tokenApprovals;\r\n    mapping (address => mapping (address => bool)) public _operatorApprovals;\r\n    \r\n    event ItemsTransferAllowance(uint256 indexed itemsIndex, address indexed fromAddress, address indexed toAddress);\r\n    event ItemsTransferAllowanceForAll(address indexed fromAddress, address indexed toAddress, bool indexed approved);\r\n    event AssignItems(uint256 indexed itemsIndex, address indexed toAddress);\r\n    event ItemsTransfer(uint256 indexed itemsIndex, address indexed fromAddress, address indexed toAddress);\r\n    event ItemsOffered(uint indexed itemsIndex, uint minValue, address indexed toAddress);\r\n    event ItemsBidEntered(uint indexed itemsIndex, uint value, address indexed fromAddress);\r\n    event ItemsBidWithdrawn(uint indexed itemsIndex, uint value, address indexed fromAddress);\r\n    event ItemsBought(uint indexed itemsIndex, uint value, address indexed fromAddress, address indexed toAddress);\r\n    event ItemsNoLongerForSaleEvent(uint indexed itemsIndex);\r\n    \r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return _owners[tokenId];\r\n    }\r\n    \r\n    function getAllOwnerOf() public view returns (address[] memory _holder) {\r\n        address[] memory holders = new address[](totalSupply());\r\n         \r\n        for(uint i = 0; i < totalSupply(); i++) {\r\n            holders[i] = _owners[i];\r\n        }\r\n        \r\n        return (holders);\r\n    }\r\n    \r\n    function getItemsOfferedForSale() public view returns (bool[] memory _isForSale, uint[] memory _itemsIndex, address[] memory _seller, uint[] memory _minValue, address[] memory _onlySellTo) {\r\n        bool[] memory isForSale = new bool[](totalSupply());\r\n        uint[] memory itemsIndex = new uint[](totalSupply());\r\n        address[] memory seller = new address[](totalSupply());\r\n        uint[] memory minValue = new uint[](totalSupply());\r\n        address[] memory onlySellTo = new address[](totalSupply());\r\n        \r\n        for(uint i = 0; i < totalSupply(); i++) {\r\n            isForSale[i] = itemsOfferedForSale[i].isForSale;\r\n            itemsIndex[i] = itemsOfferedForSale[i].itemsIndex;\r\n            seller[i] = itemsOfferedForSale[i].seller;\r\n            minValue[i] = itemsOfferedForSale[i].minValue;\r\n            onlySellTo[i] = itemsOfferedForSale[i].onlySellTo;\r\n        }\r\n        \r\n        return (isForSale, itemsIndex, seller, minValue, onlySellTo);\r\n    }\r\n\r\n    function getItemsBids() public view returns (bool[] memory _hasBid, uint[] memory _itemsIndex, address[] memory _bidder, uint[] memory _value) {\r\n        bool[] memory hasBid = new bool[](totalSupply());\r\n        uint[] memory itemsIndex = new uint[](totalSupply());\r\n        address[] memory bidder = new address[](totalSupply());\r\n        uint[] memory value = new uint[](totalSupply());\r\n         \r\n        for(uint i = 0; i < totalSupply(); i++) {\r\n            hasBid[i] = itemsBids[i].hasBid;\r\n            itemsIndex[i] = itemsBids[i].itemsIndex;\r\n            bidder[i] = itemsBids[i].bidder;\r\n            value[i] = itemsBids[i].value;\r\n        }\r\n        \r\n        return (hasBid, itemsIndex, bidder, value);\r\n    }\r\n    \r\n     function getItemsInfo() public view returns (uint[] memory _itemsIndex, string[] memory _authorInfo, string[] memory _publicInfo) {\r\n\r\n        uint[] memory itemsIndex = new uint[](totalSupply());\r\n        string[] memory authorInfo = new string[](totalSupply());\r\n        string[] memory publicInfo = new string[](totalSupply());\r\n         \r\n        for(uint i = 0; i < totalSupply(); i++) {\r\n            itemsIndex[i] = itemsInfo[i].itemsIndex;\r\n            authorInfo[i] = itemsInfo[i].authorInfo;\r\n            publicInfo[i] = itemsInfo[i].publicInfo;\r\n        }\r\n        \r\n        return (itemsIndex, authorInfo, publicInfo);\r\n    }\r\n    \r\n    constructor() {\r\n        author = msg.sender;\r\n        itemsRemainingToAssign = totalSupply();\r\n        \r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\r\n    }\r\n\r\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) public virtual {\r\n         require (author == msg.sender);\r\n\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n    \r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n    \r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\r\n    \r\n    function setBaseURI(string memory baseURI_) public virtual {\r\n         require (author == msg.sender);\r\n        _baseURI = baseURI_;\r\n    }\r\n    \r\n      function baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\r\n    \r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = _owners[tokenId];\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n        _approve(to, tokenId);\r\n    }\r\n    \r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit ItemsTransferAllowance(tokenId, _owners[tokenId], to);\r\n        emit Approval(_owners[tokenId], to, tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != msg.sender);\r\n\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ItemsTransferAllowanceForAll(msg.sender, operator, approved);\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n    \r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n   \r\n        return _tokenApprovals[tokenId];\r\n    }\r\n    \r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n    \r\n     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n      \r\n        address owner = _owners[tokenId];\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }  \r\n  \r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n      \r\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n        _transferItems(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n \r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        private returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\r\n            IERC721Receiver(to).onERC721Received.selector,\r\n            msg.sender,\r\n            from,\r\n            tokenId,\r\n            _data\r\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n        bytes4 retval = abi.decode(returndata, (bytes4));\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n    \r\n    function transfer(address to, uint itemsIndex) public {\r\n        _transferItems(msg.sender, to, itemsIndex);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n        _transferItems(from, to, tokenId);\r\n    }\r\n    \r\n    function _transferItems(address from, address to, uint itemsIndex) public {\r\n        require (_owners[itemsIndex] == from);\r\n        require (itemsIndex < totalSupply());\r\n        if (itemsOfferedForSale[itemsIndex].isForSale) {\r\n            itemsNoLongerForSale(itemsIndex);\r\n        }\r\n        \r\n        _approve(address(0), itemsIndex);\r\n        \r\n        _owners[itemsIndex] = to;\r\n        _balances[from]--;\r\n        _balances[to]++;\r\n        emit Transfer(from, to, itemsIndex);\r\n        emit ItemsTransfer(itemsIndex, from, to);\r\n\r\n        Bid memory bid = itemsBids[itemsIndex];\r\n        if (bid.bidder == to) {\r\n  \r\n            pendingWithdrawals[to] += bid.value;\r\n            itemsBids[itemsIndex] = Bid(false, itemsIndex, address(0), 0);\r\n        }\r\n    }\r\n\r\n    function itemsNoLongerForSale(uint itemsIndex) public {\r\n        require (_owners[itemsIndex] == msg.sender);\r\n        require (itemsIndex < totalSupply());\r\n        itemsOfferedForSale[itemsIndex] = Offer(false, itemsIndex, msg.sender, 0, address(0));\r\n        emit ItemsNoLongerForSaleEvent(itemsIndex);\r\n    }\r\n\r\n    function offerItemsForSale(uint itemsIndex, uint minSalePriceInWei) public {\r\n        require (_owners[itemsIndex] == msg.sender);\r\n        require (itemsIndex < totalSupply());\r\n        itemsOfferedForSale[itemsIndex] = Offer(true, itemsIndex, msg.sender, minSalePriceInWei, address(0));\r\n        emit ItemsOffered(itemsIndex, minSalePriceInWei, address(0));\r\n    }\r\n\r\n    function offerItemsForSaleToAddress(uint itemsIndex, uint minSalePriceInWei, address toAddress) public {\r\n        require (_owners[itemsIndex] == msg.sender);\r\n        require (itemsIndex < totalSupply());\r\n        itemsOfferedForSale[itemsIndex] = Offer(true, itemsIndex, msg.sender, minSalePriceInWei, toAddress);\r\n        emit ItemsOffered(itemsIndex, minSalePriceInWei, toAddress);\r\n    }\r\n\r\n    function buyItems(uint itemsIndex) payable public {\r\n        Offer memory offer = itemsOfferedForSale[itemsIndex];\r\n        require (itemsIndex < totalSupply());\r\n        require (offer.isForSale);              \r\n        require (offer.onlySellTo == address(0) || offer.onlySellTo == msg.sender);  \r\n        require (msg.value >= offer.minValue);    \r\n        require (offer.seller == _owners[itemsIndex]); \r\n\r\n        address seller = offer.seller;\r\n\r\n        _owners[itemsIndex] = msg.sender;\r\n        _balances[seller]--;\r\n        _balances[msg.sender]++;\r\n        emit Transfer(seller, msg.sender, itemsIndex);\r\n\r\n        itemsNoLongerForSale(itemsIndex);\r\n        pendingWithdrawals[seller] += msg.value;\r\n        emit ItemsBought(itemsIndex, msg.value, seller, msg.sender);\r\n\r\n        Bid memory bid = itemsBids[itemsIndex];\r\n        if (bid.bidder == msg.sender) {\r\n            pendingWithdrawals[msg.sender] += bid.value;\r\n            itemsBids[itemsIndex] = Bid(false, itemsIndex, address(0), 0);\r\n        }\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint amount = pendingWithdrawals[msg.sender];\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function enterBidForItems(uint itemsIndex) payable public {\r\n        require (itemsIndex < totalSupply());\r\n        require (_owners[itemsIndex] != address(0));\r\n        require (_owners[itemsIndex] != msg.sender);\r\n        require (msg.value != 0);\r\n        Bid memory existing = itemsBids[itemsIndex];\r\n        require (msg.value > existing.value);\r\n        if (existing.value > 0) {\r\n            pendingWithdrawals[existing.bidder] += existing.value;\r\n        }\r\n        itemsBids[itemsIndex] = Bid(true, itemsIndex, msg.sender, msg.value);\r\n        emit ItemsBidEntered(itemsIndex, msg.value, msg.sender);\r\n    }\r\n\r\n    function acceptBidForItems(uint itemsIndex, uint minPrice) public {\r\n        require (itemsIndex < totalSupply());\r\n        require (_owners[itemsIndex] == msg.sender);\r\n        address seller = msg.sender;\r\n        Bid memory bid = itemsBids[itemsIndex];\r\n        require (bid.value != 0);\r\n        require (bid.value >= minPrice);\r\n\r\n        _owners[itemsIndex] = bid.bidder;\r\n        _balances[seller]--;\r\n        _balances[bid.bidder]++;\r\n        emit Transfer(seller, bid.bidder, itemsIndex);\r\n\r\n        itemsOfferedForSale[itemsIndex] = Offer(false, itemsIndex, bid.bidder, 0, address(0));\r\n        uint amount = bid.value;\r\n        itemsBids[itemsIndex] = Bid(false, itemsIndex, address(0), 0);\r\n        pendingWithdrawals[seller] += amount;\r\n        emit ItemsBought(itemsIndex, bid.value, seller, bid.bidder);\r\n    }\r\n\r\n    function withdrawBidForItems(uint itemsIndex) public {\r\n        require (itemsIndex < totalSupply());\r\n        require (_owners[itemsIndex] != address(0));\r\n        require (_owners[itemsIndex] != msg.sender);\r\n        Bid memory bid = itemsBids[itemsIndex];\r\n        require (bid.bidder == msg.sender);\r\n        emit ItemsBidWithdrawn(itemsIndex, bid.value, msg.sender);\r\n        uint amount = bid.value;\r\n        itemsBids[itemsIndex] = Bid(false, itemsIndex, address(0), 0);\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function addItemsInformation(uint itemsIndex, string memory authorInfo, string memory publicInfo) public {\r\n        require (itemsIndex < totalSupply());\r\n        require (_owners[itemsIndex] == msg.sender || author == msg.sender);\r\n      \r\n        if(msg.sender == author){\r\n            itemsInfo[itemsIndex] = Info(itemsIndex, authorInfo, publicInfo);\r\n        }else{\r\n            itemsInfo[itemsIndex] = Info(itemsIndex, \"\", publicInfo);\r\n        }\r\n    }\r\n    \r\n    function offerItemsForSaleInBatch(uint[] memory itemsIndex, uint[] memory minSalePriceInWei) public {\r\n        require (msg.sender == author);\r\n        uint n = itemsIndex.length;\r\n        for (uint i = 0; i < n; i++) {\r\n            offerItemsForSale(itemsIndex[i], minSalePriceInWei[i]);\r\n        }\r\n    }\r\n    \r\n    function getItems(uint itemsIndex) public payable {\r\n        require (itemsRemainingToAssign != 0);\r\n        require (_owners[itemsIndex] == address(0));\r\n        \r\n        if(msg.sender != author)\r\n        {\r\n            require (itemsIndex < totalSupply() - 100);\r\n            require(msg.value >= 0.05 ether);\r\n            \r\n            author.transfer(msg.value);\r\n        }\r\n                \r\n        _owners[itemsIndex] = msg.sender;\r\n        _balances[msg.sender]++;\r\n        itemsRemainingToAssign--;\r\n        emit AssignItems(itemsIndex, msg.sender);\r\n        emit Transfer(address(0), msg.sender, itemsIndex);\r\n    }\r\n}\r\n"}}}