{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/winorlose.sol":{"content":"pragma solidity 0.6.0;\r\n\r\ncontract WinOrLose {\r\n    mapping(uint=> uint) public bets;\r\n    Bet[] public activeBets;\r\n    Bet[] private winners;\r\n    string public contractWebsite  = \"www.winorlose.live\";\r\n    address payable owner;\r\n    uint public min = 50000000000000000;\r\n    uint public betCount = 0;\r\n    bool lock= false;\r\n    uint8 public fees=2;\r\n    struct Bet{\r\n        uint id;\r\n        uint price;\r\n        uint8 coinSide;\r\n        address payable b1;\r\n    }\r\n\r\n    event Win(\r\n        uint8 win\r\n    );\r\n    \r\n    event BetCanceled(\r\n        uint id\r\n    );\r\n    \r\n    event BetCreated(\r\n        uint id,\r\n        uint price,\r\n        uint8 coinSide,\r\n        address creator\r\n    );\r\n    \r\n    event BetWinner(\r\n        uint id,\r\n        uint price,\r\n        uint8 coinSide,\r\n        address winner\r\n    );\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this method\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address payable _owner) public{\r\n        owner=_owner;\r\n    }\r\n    \r\n    function createBet(uint _price,uint8 coinSide) external payable {\r\n        require(min <= _price, \"Minimum bet price is Eth 0.01\");\r\n        require(_price <= msg.value, \"Price is greater than sending price\");\r\n        betCount++;\r\n        activeBets.push(Bet(betCount, _price, coinSide,msg.sender));\r\n        bets[betCount] = activeBets.length-1;\r\n        emit BetCreated(betCount,_price,coinSide,msg.sender);\r\n    }\r\n    \r\n    function getWinnerCount() external view returns(uint count) {\r\n        return winners.length;\r\n    }\r\n    \r\n    function getActiveCount() external view returns(uint count) {\r\n        return activeBets.length;\r\n    }\r\n    \r\n    function getWinner(uint index) external view returns(uint id, uint price, address winner,uint8 coin) {\r\n        return (winners[index].id, winners[index].price, winners[index].b1, winners[index].coinSide);\r\n    }\r\n    \r\n    function cancelBet(uint _id) external {\r\n        require(!lock);\r\n        lock=true;\r\n        require(_id>0 &&  _id<= betCount ,'ID is not valid');\r\n        Bet memory bet = activeBets[bets[_id]];\r\n        require(bet.id==_id,'Bet ID is not matched');\r\n        require(bet.b1==msg.sender,'Bet is not started by you');\r\n        activeBets[bets[_id]] = activeBets[activeBets.length-1];\r\n        activeBets.pop();\r\n        delete bets[_id];\r\n        bets[betCount]=bets[_id];\r\n         emit BetCanceled(_id);\r\n        bet.b1.transfer(bet.price);\r\n        lock=false;\r\n    }\r\n    \r\n    function joinBet(uint _id) external payable{\r\n        require(!lock);\r\n        lock=true;\r\n        require(_id>0 &&  _id<= betCount ,'ID is not valid');\r\n        Bet memory bet = activeBets[bets[_id]];\r\n        require(bet.id==_id,'Bet ID is not matched');\r\n        require(msg.value>=bet.price,'Sent Value is less than bet price');\r\n        require(bet.b1!=msg.sender,'You can not join your own bet');\r\n        require(tx.origin==msg.sender,\"Don't try to hack\");\r\n        uint flip=(gasleft()%10) + (now%10);\r\n        if(flip%2==1){\r\n            bet.b1=msg.sender;\r\n            bet.coinSide=bet.coinSide==1?2:1;\r\n            emit Win(1);\r\n        }else{\r\n            emit Win(0);\r\n        }\r\n        activeBets[bets[_id]] = activeBets[activeBets.length-1];\r\n        activeBets.pop();\r\n        delete bets[_id];\r\n        bets[betCount]=bets[_id];\r\n        winners.push(bet);\r\n        emit BetWinner(_id,bet.price,bet.coinSide,bet.b1);\r\n        uint256 total=bet.price *2;\r\n        uint256 commission = ((total)*fees)/100;\r\n        owner.transfer(commission);\r\n        bet.b1.transfer(total-commission);\r\n        lock=false;\r\n    }\r\n    \r\n    //this will be used for migration of latest version contract or to resolve any discrepancy\r\n    function withdraw(uint val) onlyOwner external{\r\n        owner.transfer(val);\r\n    }\r\n\r\n    // Contract may be destroyed only when there are no active bets\r\n    function kill() external onlyOwner {\r\n        require (activeBets.length == 0, \"All bets should be processed (complete or canceled) before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    // Fees will be down in future if platform works well\r\n    function feesDown(uint8 newFees) external onlyOwner {\r\n        require (activeBets.length == 0, \"All bets should be processed (complete or canceled) before Fees changes.\");\r\n        fees=newFees;\r\n    }\r\n    \r\n    // Min bet will be down in future if platform works well\r\n    function minDown(uint newMin) external onlyOwner {\r\n        min=newMin;\r\n    }\r\n\r\n    \r\n    fallback() external payable {  }\r\n}"}}}