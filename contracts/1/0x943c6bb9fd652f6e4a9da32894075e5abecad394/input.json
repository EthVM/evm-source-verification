{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/geb-proxy-auction-actions.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.6.7;\n\ninterface DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) external view returns (bool);\n}\n\nabstract contract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        virtual\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        virtual\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) virtual internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n\n\n\n/// GebProxyActions.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.7;\n\nabstract contract CollateralLike {\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract ManagerLike {\n    function safeCan(address, uint, address) virtual public view returns (uint);\n    function collateralTypes(uint) virtual public view returns (bytes32);\n    function ownsSAFE(uint) virtual public view returns (address);\n    function safes(uint) virtual public view returns (address);\n    function safeEngine() virtual public view returns (address);\n    function openSAFE(bytes32, address) virtual public returns (uint);\n    function transferSAFEOwnership(uint, address) virtual public;\n    function allowSAFE(uint, address, uint) virtual public;\n    function allowHandler(address, uint) virtual public;\n    function modifySAFECollateralization(uint, int, int) virtual public;\n    function transferCollateral(uint, address, uint) virtual public;\n    function transferInternalCoins(uint, address, uint) virtual public;\n    function quitSystem(uint, address) virtual public;\n    function enterSystem(address, uint) virtual public;\n    function moveSAFE(uint, uint) virtual public;\n    function protectSAFE(uint, address, address) virtual public;\n}\n\nabstract contract SAFEEngineLike {\n    function canModifySAFE(address, address) virtual public view returns (uint);\n    function collateralTypes(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\n    function coinBalance(address) virtual public view returns (uint);\n    function safes(bytes32, address) virtual public view returns (uint, uint);\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\n    function approveSAFEModification(address) virtual public;\n    function transferInternalCoins(address, address, uint) virtual public;\n}\n\nabstract contract CollateralJoinLike {\n    function decimals() virtual public returns (uint);\n    function collateral() virtual public returns (CollateralLike);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\nabstract contract GNTJoinLike {\n    function bags(address) virtual public view returns (address);\n    function make(address) virtual public returns (address);\n}\n\nabstract contract DSTokenLike {\n    function balanceOf(address) virtual public view returns (uint);\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public returns (bool);\n    function transferFrom(address, address, uint) virtual public returns (bool);\n}\n\nabstract contract WethLike {\n    function balanceOf(address) virtual public view returns (uint);\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract CoinJoinLike {\n    function safeEngine() virtual public returns (SAFEEngineLike);\n    function systemCoin() virtual public returns (DSTokenLike);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\nabstract contract ApproveSAFEModificationLike {\n    function approveSAFEModification(address) virtual public;\n    function denySAFEModification(address) virtual public;\n}\n\nabstract contract GlobalSettlementLike {\n    function collateralCashPrice(bytes32) virtual public view returns (uint);\n    function redeemCollateral(bytes32, uint) virtual public;\n    function freeCollateral(bytes32) virtual public;\n    function prepareCoinsForRedeeming(uint) virtual public;\n    function processSAFE(bytes32, address) virtual public;\n}\n\nabstract contract TaxCollectorLike {\n    function taxSingle(bytes32) virtual public returns (uint);\n}\n\nabstract contract CoinSavingsAccountLike {\n    function savings(address) virtual public view returns (uint);\n    function updateAccumulatedRate() virtual public returns (uint);\n    function deposit(uint) virtual public;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract ProxyRegistryLike {\n    function proxies(address) virtual public view returns (address);\n    function build(address) virtual public returns (address);\n}\n\nabstract contract ProxyLike {\n    function owner() virtual public view returns (address);\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ncontract Common {\n    uint256 constant RAY = 10 ** 27;\n\n    // Internal functions\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    function _coinJoin_join(address apt, address safeHandler, uint wad) internal {\n        // Approves adapter to take the COIN amount\n        CoinJoinLike(apt).systemCoin().approve(apt, wad);\n        // Joins COIN into the safeEngine\n        CoinJoinLike(apt).join(safeHandler, wad);\n    }\n\n    // Public functions\n    function coinJoin_join(address apt, address safeHandler, uint wad) public {\n        // Gets COIN from the user's wallet\n        CoinJoinLike(apt).systemCoin().transferFrom(msg.sender, address(this), wad);\n\n        _coinJoin_join(apt, safeHandler, wad);\n    }\n}\n\ncontract BasicActions is Common {\n    // Internal functions\n\n    /// @notice Safe subtraction\n    /// @dev Reverts on overflows\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    /// @notice Safe conversion uint -> int\n    /// @dev Reverts on overflows\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    /// @notice Converts a wad (18 decimal places) to rad (45 decimal places)\n    function toRad(uint wad) internal pure returns (uint rad) {\n        rad = multiply(wad, 10 ** 27);\n    }\n\n    function convertTo18(address collateralJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have other than 18 decimals precision we need to do the conversion before passing to modifySAFECollateralization function\n        // Adapters will automatically handle the difference of precision\n        uint decimals = CollateralJoinLike(collateralJoin).decimals();\n        wad = amt;\n        if (decimals < 18) {\n          wad = multiply(\n              amt,\n              10 ** (18 - decimals)\n          );\n        } else if (decimals > 18) {\n          wad = amt / 10 ** (decimals - 18);\n        }\n    }\n\n    /// @notice Gets delta debt generated (Total Safe debt minus available safeHandler COIN balance)\n    /// @param safeEngine address\n    /// @param taxCollector address\n    /// @param safeHandler address\n    /// @param collateralType bytes32\n    /// @return deltaDebt\n    function _getGeneratedDeltaDebt(\n        address safeEngine,\n        address taxCollector,\n        address safeHandler,\n        bytes32 collateralType,\n        uint wad\n    ) internal returns (int deltaDebt) {\n        // Updates stability fee rate\n        uint rate = TaxCollectorLike(taxCollector).taxSingle(collateralType);\n        require(rate > 0, \"invalid-collateral-type\");\n\n        // Gets COIN balance of the handler in the safeEngine\n        uint coin = SAFEEngineLike(safeEngine).coinBalance(safeHandler);\n\n        // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n        if (coin < multiply(wad, RAY)) {\n            // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n            deltaDebt = toInt(subtract(multiply(wad, RAY), coin) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n            deltaDebt = multiply(uint(deltaDebt), rate) < multiply(wad, RAY) ? deltaDebt + 1 : deltaDebt;\n        }\n    }\n\n    /// @notice Gets repaid delta debt generated (rate adjusted debt)\n    /// @param safeEngine address\n    /// @param coin uint amount\n    /// @param safe uint - safeId\n    /// @param collateralType bytes32\n        /// @return deltaDebt\n    function _getRepaidDeltaDebt(\n        address safeEngine,\n        uint coin,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (int deltaDebt) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,) = SAFEEngineLike(safeEngine).collateralTypes(collateralType);\n        require(rate > 0, \"invalid-collateral-type\");\n\n        // Gets actual generatedDebt value of the safe\n        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safe);\n\n        // Uses the whole coin balance in the safeEngine to reduce the debt\n        deltaDebt = toInt(coin / rate);\n        // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n        deltaDebt = uint(deltaDebt) <= generatedDebt ? - deltaDebt : - toInt(generatedDebt);\n    }\n\n    /// @notice Gets repaid debt (rate adjusted rate minus COIN balance available in usr's address)\n    /// @param safeEngine address\n    /// @param usr address\n    /// @param safe uint\n    /// @param collateralType address\n    /// @return wad\n    function _getRepaidAlDebt(\n        address safeEngine,\n        address usr,\n        address safe,\n        bytes32 collateralType\n    ) internal view returns (uint wad) {\n        // Gets actual rate from the safeEngine\n        (, uint rate,,,) = SAFEEngineLike(safeEngine).collateralTypes(collateralType);\n        // Gets actual generatedDebt value of the safe\n        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safe);\n        // Gets actual coin amount in the safe\n        uint coin = SAFEEngineLike(safeEngine).coinBalance(usr);\n\n        uint rad = subtract(multiply(generatedDebt, rate), coin);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = multiply(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n    /// @notice Generates Debt (and sends coin balance to address to)\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param coinJoin address\n    /// @param safe uint\n    /// @param wad uint - amount of debt to be generated\n    /// @param to address - receiver of the balance of generated COIN\n    function _generateDebt(address manager, address taxCollector, address coinJoin, uint safe, uint wad, address to) internal {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        // Generates debt in the SAFE\n        modifySAFECollateralization(manager, safe, 0, _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, wad));\n        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, safe, address(this), toRad(wad));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (SAFEEngineLike(safeEngine).canModifySAFE(address(this), address(coinJoin)) == 0) {\n            SAFEEngineLike(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits COIN to this contract\n        CoinJoinLike(coinJoin).exit(to, wad);\n    }\n\n    /// @notice Generates Debt (and sends coin balance to address to)\n    /// @param manager address\n    /// @param ethJoin address\n    /// @param safe uint\n    /// @param value uint - amount of ETH to be locked in the Safe.\n    /// @dev Proxy needs to have enough balance (> value), public functions should handle this.\n    function _lockETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        uint value\n    ) internal {\n        // Receives ETH amount, converts it to WETH and joins it into the safeEngine\n        ethJoin_join(ethJoin, address(this), value);\n        // Locks WETH amount into the SAFE\n        SAFEEngineLike(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n            ManagerLike(manager).collateralTypes(safe),\n            ManagerLike(manager).safes(safe),\n            address(this),\n            address(this),\n            toInt(value),\n            0\n        );\n    }\n\n    /// @notice Repays debt\n    /// @param manager address\n    /// @param coinJoin address\n    /// @param safe uint\n    /// @param wad uint - amount of debt to be repayed\n    function _repayDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        uint wad,\n        bool transferFromCaller\n    ) internal {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n\n        address own = ManagerLike(manager).ownsSAFE(safe);\n        if (own == address(this) || ManagerLike(manager).safeCan(own, safe, address(this)) == 1) {\n            // Joins COIN amount into the safeEngine\n            if (transferFromCaller) coinJoin_join(coinJoin, safeHandler, wad);\n            else _coinJoin_join(coinJoin, safeHandler, wad);\n            // // Paybacks debt to the SAFE\n            modifySAFECollateralization(manager, safe, 0, _getRepaidDeltaDebt(safeEngine, SAFEEngineLike(safeEngine).coinBalance(safeHandler), safeHandler, collateralType));\n        } else {\n             // Joins COIN amount into the safeEngine\n            if (transferFromCaller) coinJoin_join(coinJoin, address(this), wad);\n            else _coinJoin_join(coinJoin, address(this), wad);\n            // Paybacks debt to the SAFE\n            SAFEEngineLike(safeEngine).modifySAFECollateralization(\n                collateralType,\n                safeHandler,\n                address(this),\n                address(this),\n                0,\n                _getRepaidDeltaDebt(safeEngine, wad * RAY, safeHandler, collateralType)\n            );\n        }\n    }\n\n    /// @notice Repays debt and frees collateral ETH\n    /// @param manager address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param safe uint\n    /// @param collateralWad uint - amount of ETH to free\n    /// @param deltaWad uint - amount of debt to be repayed\n    /// @param transferFromCaller True if transferring coin from caller, false if balance in the proxy\n    function _repayDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralWad,\n        uint deltaWad,\n        bool transferFromCaller\n    ) internal {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        // Joins COIN amount into the safeEngine\n        if (transferFromCaller) coinJoin_join(coinJoin, safeHandler, deltaWad);\n        else _coinJoin_join(coinJoin, safeHandler, deltaWad);\n        // Paybacks debt to the SAFE and unlocks WETH amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SAFEEngineLike(ManagerLike(manager).safeEngine()).coinBalance(safeHandler), safeHandler, ManagerLike(manager).collateralTypes(safe))\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), collateralWad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(collateralWad);\n    }\n\n    // Public functions\n\n    /// @notice ERC20 transfer\n    /// @param collateral address - address of ERC20 collateral\n    /// @param dst address - Transfer destination\n    /// @param amt address - Amount to transfer\n    function transfer(address collateral, address dst, uint amt) external {\n        CollateralLike(collateral).transfer(dst, amt);\n    }\n\n    /// @notice Joins the system with the full msg.value\n    /// @param apt address - Address of the adapter\n    /// @param safe uint - Safe Id\n    function ethJoin_join(address apt, address safe) external payable {\n        ethJoin_join(apt, safe, msg.value);\n    }\n\n    /// @notice Joins the system with the a specified value\n    /// @param apt address - Address of the adapter\n    /// @param safe uint - Safe Id\n    /// @param value uint - Value to join\n    function ethJoin_join(address apt, address safe, uint value) public payable {\n        // Wraps ETH in WETH\n        CollateralJoinLike(apt).collateral().deposit{value: value}();\n        // Approves adapter to take the WETH amount\n        CollateralJoinLike(apt).collateral().approve(address(apt), value);\n        // Joins WETH collateral into the safeEngine\n        CollateralJoinLike(apt).join(safe, value);\n    }\n\n    /// @notice Approves an address to modify the Safe\n    /// @param safeEngine address\n    /// @param usr address - Address allowed to modify Safe\n    function approveSAFEModification(\n        address safeEngine,\n        address usr\n    ) external {\n        ApproveSAFEModificationLike(safeEngine).approveSAFEModification(usr);\n    }\n\n    /// @notice Denies an address to modify the Safe\n    /// @param safeEngine address\n    /// @param usr address - Address disallowed to modify Safe\n    function denySAFEModification(\n        address safeEngine,\n        address usr\n    ) external {\n        ApproveSAFEModificationLike(safeEngine).denySAFEModification(usr);\n    }\n\n    /// @notice Opens a brand new Safe\n    /// @param manager address - Safe Manager\n    /// @param collateralType bytes32 - collateral type\n    /// @param usr address - Owner of the safe\n    function openSAFE(\n        address manager,\n        bytes32 collateralType,\n        address usr\n    ) public returns (uint safe) {\n        safe = ManagerLike(manager).openSAFE(collateralType, usr);\n    }\n\n    /// @notice Transfer the ownership of a proxy owned Safe\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param usr address - Owner of the safe\n    function transferSAFEOwnership(\n        address manager,\n        uint safe,\n        address usr\n    ) public {\n        ManagerLike(manager).transferSAFEOwnership(safe, usr);\n    }\n\n    /// @notice Transfer the ownership to a new proxy owned by a different address\n    /// @param proxyRegistry address - Safe Manager\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst address - Owner of the new proxy\n    function transferSAFEOwnershipToProxy(\n        address proxyRegistry,\n        address manager,\n        uint safe,\n        address dst\n    ) external {\n        // Gets actual proxy address\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n        // Checks if the proxy address already existed and dst address is still the owner\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n            uint csize;\n            assembly {\n                csize := extcodesize(dst)\n            }\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the SAFE\n            require(csize == 0, \"dst-is-a-contract\");\n            // Creates the proxy for the dst address\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n        }\n        // Transfers SAFE to the dst proxy\n        transferSAFEOwnership(manager, safe, proxy);\n    }\n\n    /// @notice Allow/disallow a usr address to manage the safe\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param usr address - usr address\n    /// uint ok - 1 for allowed\n    function allowSAFE(\n        address manager,\n        uint safe,\n        address usr,\n        uint ok\n    ) external {\n        ManagerLike(manager).allowSAFE(safe, usr, ok);\n    }\n\n    /// @notice Allow/disallow a usr address to quit to the sender handler\n    /// @param manager address - Safe Manager\n    /// @param usr address - usr address\n    /// uint ok - 1 for allowed\n    function allowHandler(\n        address manager,\n        address usr,\n        uint ok\n    ) external {\n        ManagerLike(manager).allowHandler(usr, ok);\n    }\n\n    /// @notice Transfer wad amount of safe collateral from the safe address to a dst address.\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst address - destination address\n    /// uint wad - amount\n    function transferCollateral(\n        address manager,\n        uint safe,\n        address dst,\n        uint wad\n    ) public {\n        ManagerLike(manager).transferCollateral(safe, dst, wad);\n    }\n\n    /// @notice Transfer rad amount of COIN from the safe address to a dst address.\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst address - destination address\n    /// uint rad - amount\n    function transferInternalCoins(\n        address manager,\n        uint safe,\n        address dst,\n        uint rad\n    ) public {\n        ManagerLike(manager).transferInternalCoins(safe, dst, rad);\n    }\n\n\n    /// @notice Modify a SAFE's collateralization ratio while keeping the generated COIN or collateral freed in the SAFE handler address.\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param deltaCollateral - int\n    /// @param deltaDebt - int\n    function modifySAFECollateralization(\n        address manager,\n        uint safe,\n        int deltaCollateral,\n        int deltaDebt\n    ) public {\n        ManagerLike(manager).modifySAFECollateralization(safe, deltaCollateral, deltaDebt);\n    }\n\n    /// @notice Quit the system, migrating the safe (lockedCollateral, generatedDebt) to a different dst handler\n    /// @param manager address - Safe Manager\n    /// @param safe uint - Safe Id\n    /// @param dst - destination handler\n    function quitSystem(\n        address manager,\n        uint safe,\n        address dst\n    ) external {\n        ManagerLike(manager).quitSystem(safe, dst);\n    }\n\n    /// @notice Import a position from src handler to the handler owned by safe\n    /// @param manager address - Safe Manager\n    /// @param src - source handler\n    /// @param safe uint - Safe Id\n    function enterSystem(\n        address manager,\n        address src,\n        uint safe\n    ) external {\n        ManagerLike(manager).enterSystem(src, safe);\n    }\n\n    /// @notice Move a position from safeSrc handler to the safeDst handler\n    /// @param manager address - Safe Manager\n    /// @param safeSrc uint - Source Safe Id\n    /// @param safeDst uint - Destination Safe Id\n    function moveSAFE(\n        address manager,\n        uint safeSrc,\n        uint safeDst\n    ) external {\n        ManagerLike(manager).moveSAFE(safeSrc, safeDst);\n    }\n\n    /// @notice Lock ETH (msg.value) as collateral in safe\n    /// @param manager address - Safe Manager\n    /// @param ethJoin address\n    /// @param safe uint - Safe Id\n    function lockETH(\n        address manager,\n        address ethJoin,\n        uint safe\n    ) public payable {\n        _lockETH(manager, ethJoin, safe, msg.value);\n    }\n\n    /// @notice Free ETH (wad) from safe and sends it to msg.sender\n    /// @param manager address - Safe Manager\n    /// @param ethJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function freeETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        uint wad\n    ) public {\n        // Unlocks WETH amount from the SAFE\n        modifySAFECollateralization(manager, safe, -toInt(wad), 0);\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n\n    /// @notice Exits ETH (wad) from balance available in the handler\n    /// @param manager address - Safe Manager\n    /// @param ethJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function exitETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        uint wad\n    ) external {\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    /// @notice Generates debt and sends COIN amount to msg.sender\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function generateDebt(\n        address manager,\n        address taxCollector,\n        address coinJoin,\n        uint safe,\n        uint wad\n    ) public {\n        _generateDebt(manager, taxCollector, coinJoin, safe, wad, msg.sender);\n    }\n\n    /// @notice Repays debt\n    /// @param manager address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param wad uint - Amount\n    function repayDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        uint wad\n    ) public {\n        _repayDebt(manager, coinJoin, safe, wad, true);\n    }\n\n    /// @notice Locks Eth, generates debt and sends COIN amount (deltaWad) to msg.sender\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param deltaWad uint - Amount\n    function lockETHAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint deltaWad\n    ) public payable {\n        _lockETH(manager, ethJoin, safe, msg.value);\n        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, msg.sender);\n    }\n\n    /// @notice Opens Safe, locks Eth, generates debt and sends COIN amount (deltaWad) to msg.sender\n    /// @param manager address\n    /// @param taxCollector address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param deltaWad uint - Amount\n    function openLockETHAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint deltaWad\n    ) external payable returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, safe, deltaWad);\n    }\n\n    /// @notice Repays debt and frees ETH (sends it to msg.sender)\n    /// @param manager address\n    /// @param ethJoin address\n    /// @param coinJoin address\n    /// @param safe uint - Safe Id\n    /// @param collateralWad uint - Amount of collateral to free\n    /// @param deltaWad uint - Amount of debt to repay\n    function repayDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralWad,\n        uint deltaWad\n    ) external {\n        _repayDebtAndFreeETH(manager, ethJoin, coinJoin, safe, collateralWad, deltaWad, true);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(collateralWad);\n    }    \n}\n\ncontract GebProxyActions is BasicActions {\n\n    function tokenCollateralJoin_join(address apt, address safe, uint amt, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            CollateralJoinLike(apt).collateral().transferFrom(msg.sender, address(this), amt);\n            // Approves adapter to take the token amount\n            CollateralJoinLike(apt).collateral().approve(apt, amt);\n        }\n        // Joins token collateral into the safeEngine\n        CollateralJoinLike(apt).join(safe, amt);\n    }\n\n    function protectSAFE(\n        address manager,\n        uint safe,\n        address liquidationEngine,\n        address saviour\n    ) public {\n        ManagerLike(manager).protectSAFE(safe, liquidationEngine, saviour);\n    }\n\n    function makeCollateralBag(\n        address collateralJoin\n    ) public returns (address bag) {\n        bag = GNTJoinLike(collateralJoin).make(address(this));\n    }\n\n    function safeLockETH(\n        address manager,\n        address ethJoin,\n        uint safe,\n        address owner\n    ) public payable {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        lockETH(manager, ethJoin, safe);\n    }\n\n    function lockTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt,\n        bool transferFrom\n    ) public {\n        // Takes token amount from user's wallet and joins into the safeEngine\n        tokenCollateralJoin_join(collateralJoin, address(this), amt, transferFrom);\n        // Locks token amount into the SAFE\n        SAFEEngineLike(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n            ManagerLike(manager).collateralTypes(safe),\n            ManagerLike(manager).safes(safe),\n            address(this),\n            address(this),\n            toInt(convertTo18(collateralJoin, amt)),\n            0\n        );\n    }\n\n    function safeLockTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt,\n        bool transferFrom,\n        address owner\n    ) public {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        lockTokenCollateral(manager, collateralJoin, safe, amt, transferFrom);\n    }\n\n    function freeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt\n    ) public {\n        uint wad = convertTo18(collateralJoin, amt);\n        // Unlocks token amount from the SAFE\n        modifySAFECollateralization(manager, safe, -toInt(wad), 0);\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), wad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function exitTokenCollateral(\n        address manager,\n        address collateralJoin,\n        uint safe,\n        uint amt\n    ) public {\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), convertTo18(collateralJoin, amt));\n\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function generateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address coinJoin,\n        uint safe,\n        uint wad,\n        address liquidationEngine,\n        address saviour\n    ) external {\n        generateDebt(manager, taxCollector, coinJoin, safe, wad);\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function safeRepayDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        uint wad,\n        address owner\n    ) public {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        repayDebt(manager, coinJoin, safe, wad);\n    }\n\n    function repayAllDebt(\n        address manager,\n        address coinJoin,\n        uint safe\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safeHandler);\n\n        address own = ManagerLike(manager).ownsSAFE(safe);\n        if (own == address(this) || ManagerLike(manager).safeCan(own, safe, address(this)) == 1) {\n            // Joins COIN amount into the safeEngine\n            coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n            // Paybacks debt to the SAFE\n            modifySAFECollateralization(manager, safe, 0, -int(generatedDebt));\n        } else {\n            // Joins COIN amount into the safeEngine\n            coinJoin_join(coinJoin, address(this), _getRepaidAlDebt(safeEngine, address(this), safeHandler, collateralType));\n            // Paybacks debt to the SAFE\n            SAFEEngineLike(safeEngine).modifySAFECollateralization(\n                collateralType,\n                safeHandler,\n                address(this),\n                address(this),\n                0,\n                -int(generatedDebt)\n            );\n        }\n    }\n\n    function safeRepayAllDebt(\n        address manager,\n        address coinJoin,\n        uint safe,\n        address owner\n    ) public {\n        require(ManagerLike(manager).ownsSAFE(safe) == owner, \"owner-missmatch\");\n        repayAllDebt(manager, coinJoin, safe);\n    }\n\n    function openLockETHGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address ethJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint deltaWad,\n        address liquidationEngine,\n        address saviour\n    ) public payable returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, safe, deltaWad);\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function lockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom\n    ) public {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        address safeEngine = ManagerLike(manager).safeEngine();\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        // Takes token amount from user's wallet and joins into the safeEngine\n        tokenCollateralJoin_join(collateralJoin, safeHandler, collateralAmount, transferFrom);\n        // Locks token amount into the SAFE and generates debt\n        modifySAFECollateralization(manager, safe, toInt(convertTo18(collateralJoin, collateralAmount)), _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, deltaWad));\n        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n        transferInternalCoins(manager, safe, address(this), toRad(deltaWad));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (SAFEEngineLike(safeEngine).canModifySAFE(address(this), address(coinJoin)) == 0) {\n            SAFEEngineLike(safeEngine).approveSAFEModification(coinJoin);\n        }\n        // Exits COIN to the user's wallet as a token\n        CoinJoinLike(coinJoin).exit(msg.sender, deltaWad);\n    }\n\n    function lockTokenCollateralGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom,\n        address liquidationEngine,\n        address saviour\n    ) public {\n        lockTokenCollateralAndGenerateDebt(\n          manager,\n          taxCollector,\n          collateralJoin,\n          coinJoin,\n          safe,\n          collateralAmount,\n          deltaWad,\n          transferFrom\n        );\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function openLockTokenCollateralAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom\n    ) public returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, safe, collateralAmount, deltaWad, transferFrom);\n    }\n\n    function openLockTokenCollateralGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address collateralJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad,\n        bool transferFrom,\n        address liquidationEngine,\n        address saviour\n    ) public returns (uint safe) {\n        safe = openSAFE(manager, collateralType, address(this));\n        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, safe, collateralAmount, deltaWad, transferFrom);\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function openLockGNTAndGenerateDebt(\n        address manager,\n        address taxCollector,\n        address gntJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad\n    ) public returns (address bag, uint safe) {\n        // Creates bag (if doesn't exist) to hold GNT\n        bag = GNTJoinLike(gntJoin).bags(address(this));\n        if (bag == address(0)) {\n            bag = makeCollateralBag(gntJoin);\n        }\n        // Transfer funds to the funds which previously were sent to the proxy\n        CollateralLike(CollateralJoinLike(gntJoin).collateral()).transfer(bag, collateralAmount);\n        safe = openLockTokenCollateralAndGenerateDebt(manager, taxCollector, gntJoin, coinJoin, collateralType, collateralAmount, deltaWad, false);\n    }\n\n    function openLockGNTGenerateDebtAndProtectSAFE(\n        address manager,\n        address taxCollector,\n        address gntJoin,\n        address coinJoin,\n        bytes32 collateralType,\n        uint collateralAmount,\n        uint deltaWad,\n        address liquidationEngine,\n        address saviour\n    ) public returns (address bag, uint safe) {\n        (bag, safe) = openLockGNTAndGenerateDebt(\n          manager,\n          taxCollector,\n          gntJoin,\n          coinJoin,\n          collateralType,\n          collateralAmount,\n          deltaWad\n        );\n        protectSAFE(manager, safe, liquidationEngine, saviour);\n    }\n\n    function repayAllDebtAndFreeETH(\n        address manager,\n        address ethJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralWad\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safeHandler);\n\n        // Joins COIN amount into the safeEngine\n        coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n        // Paybacks debt to the SAFE and unlocks WETH amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            -int(generatedDebt)\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), collateralWad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(collateralWad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(collateralWad);\n    }\n\n    function repayDebtAndFreeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount,\n        uint deltaWad\n    ) external {\n        address safeHandler = ManagerLike(manager).safes(safe);\n        // Joins COIN amount into the safeEngine\n        coinJoin_join(coinJoin, safeHandler, deltaWad);\n        uint collateralWad = convertTo18(collateralJoin, collateralAmount);\n        // Paybacks debt to the SAFE and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SAFEEngineLike(ManagerLike(manager).safeEngine()).coinBalance(safeHandler), safeHandler, ManagerLike(manager).collateralTypes(safe))\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, collateralAmount);\n    }\n\n    function repayAllDebtAndFreeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address coinJoin,\n        uint safe,\n        uint collateralAmount\n    ) public {\n        address safeEngine = ManagerLike(manager).safeEngine();\n        address safeHandler = ManagerLike(manager).safes(safe);\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safeHandler);\n\n        // Joins COIN amount into the safeEngine\n        coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n        uint collateralWad = convertTo18(collateralJoin, collateralAmount);\n        // Paybacks debt to the SAFE and unlocks token amount from it\n        modifySAFECollateralization(\n            manager,\n            safe,\n            -toInt(collateralWad),\n            -int(generatedDebt)\n        );\n        // Moves the amount from the SAFE handler to proxy's address\n        transferCollateral(manager, safe, address(this), collateralWad);\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, collateralAmount);\n    }\n}\n\ncontract GebProxyActionsGlobalSettlement is Common {\n\n    // Internal functions\n    function _freeCollateral(\n        address manager,\n        address globalSettlement,\n        uint safe\n    ) internal returns (uint lockedCollateral) {\n        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n        address safeHandler = ManagerLike(manager).safes(safe);\n        SAFEEngineLike safeEngine = SAFEEngineLike(ManagerLike(manager).safeEngine());\n        uint generatedDebt;\n        (lockedCollateral, generatedDebt) = safeEngine.safes(collateralType, safeHandler);\n\n        // If SAFE still has debt, it needs to be paid\n        if (generatedDebt > 0) {\n            GlobalSettlementLike(globalSettlement).processSAFE(collateralType, safeHandler);\n            (lockedCollateral,) = safeEngine.safes(collateralType, safeHandler);\n        }\n        // Approves the manager to transfer the position to proxy's address in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(manager)) == 0) {\n            safeEngine.approveSAFEModification(manager);\n        }\n        // Transfers position from SAFE to the proxy address\n        ManagerLike(manager).quitSystem(safe, address(this));\n        // Frees the position and recovers the collateral in the safeEngine registry\n        GlobalSettlementLike(globalSettlement).freeCollateral(collateralType);\n    }\n\n    // Public functions\n    function freeETH(\n        address manager,\n        address ethJoin,\n        address globalSettlement,\n        uint safe\n    ) external {\n        uint wad = _freeCollateral(manager, globalSettlement, safe);\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    function freeTokenCollateral(\n        address manager,\n        address collateralJoin,\n        address globalSettlement,\n        uint safe\n    ) public {\n        uint amt = _freeCollateral(manager, globalSettlement, safe) / 10 ** (18 - CollateralJoinLike(collateralJoin).decimals());\n        // Exits token amount to the user's wallet as a token\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n\n    function prepareCoinsForRedeeming(\n        address coinJoin,\n        address globalSettlement,\n        uint wad\n    ) public {\n        coinJoin_join(coinJoin, address(this), wad);\n        SAFEEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Approves the globalSettlement to take out COIN from the proxy's balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(globalSettlement)) == 0) {\n            safeEngine.approveSAFEModification(globalSettlement);\n        }\n        GlobalSettlementLike(globalSettlement).prepareCoinsForRedeeming(wad);\n    }\n\n    function redeemETH(\n        address ethJoin,\n        address globalSettlement,\n        bytes32 collateralType,\n        uint wad\n    ) public {\n        GlobalSettlementLike(globalSettlement).redeemCollateral(collateralType, wad);\n        uint collateralWad = multiply(wad, GlobalSettlementLike(globalSettlement).collateralCashPrice(collateralType)) / RAY;\n        // Exits WETH amount to proxy address as a token\n        CollateralJoinLike(ethJoin).exit(address(this), collateralWad);\n        // Converts WETH to ETH\n        CollateralJoinLike(ethJoin).collateral().withdraw(collateralWad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(collateralWad);\n    }\n\n    function redeemTokenCollateral(\n        address collateralJoin,\n        address globalSettlement,\n        bytes32 collateralType,\n        uint wad\n    ) public {\n        GlobalSettlementLike(globalSettlement).redeemCollateral(collateralType, wad);\n        // Exits token amount to the user's wallet as a token\n        uint amt = multiply(wad, GlobalSettlementLike(globalSettlement).collateralCashPrice(collateralType)) / RAY / 10 ** (18 - CollateralJoinLike(collateralJoin).decimals());\n        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n    }\n}\n\ncontract GebProxyActionsCoinSavingsAccount is Common {\n\n    function deposit(\n        address coinJoin,\n        address coinSavingsAccount,\n        uint wad\n    ) public {\n        SAFEEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to get the accumulatedRates updated to latestUpdateTime == now, otherwise join will fail\n        uint accumulatedRates = CoinSavingsAccountLike(coinSavingsAccount).updateAccumulatedRate();\n        // Joins wad amount to the safeEngine balance\n        coinJoin_join(coinJoin, address(this), wad);\n        // Approves the coinSavingsAccount to take out COIN from the proxy's balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinSavingsAccount)) == 0) {\n            safeEngine.approveSAFEModification(coinSavingsAccount);\n        }\n        // Joins the savings value (equivalent to the COIN wad amount) in the coinSavingsAccount\n        CoinSavingsAccountLike(coinSavingsAccount).deposit(multiply(wad, RAY) / accumulatedRates);\n    }\n\n    function withdraw(\n        address coinJoin,\n        address coinSavingsAccount,\n        uint wad\n    ) public {\n        SAFEEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to count the savings accumulated until this moment\n        uint accumulatedRates = CoinSavingsAccountLike(coinSavingsAccount).updateAccumulatedRate();\n        // Calculates the savings value in the coinSavingsAccount equivalent to the COIN wad amount\n        uint savings = multiply(wad, RAY) / accumulatedRates;\n        // Exits COIN from the coinSavingsAccount\n        CoinSavingsAccountLike(coinSavingsAccount).withdraw(savings);\n        // Checks the actual balance of COIN in the safeEngine after the coinSavingsAccount exit\n        uint bal = CoinJoinLike(coinJoin).safeEngine().coinBalance(address(this));\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // It is necessary to check if due rounding the exact wad amount can be exited by the adapter.\n        // Otherwise it will do the minimum COIN balance in the safeEngine\n        CoinJoinLike(coinJoin).exit(\n            msg.sender,\n            bal >= multiply(wad, RAY) ? wad : bal / RAY\n        );\n    }\n\n    function withdrawAll(\n        address coinJoin,\n        address coinSavingsAccount\n    ) public {\n        SAFEEngineLike safeEngine = CoinJoinLike(coinJoin).safeEngine();\n        // Executes updateAccumulatedRate to count the savings accumulated until this moment\n        uint accumulatedRates = CoinSavingsAccountLike(coinSavingsAccount).updateAccumulatedRate();\n        // Gets the total savings belonging to the proxy address\n        uint savings = CoinSavingsAccountLike(coinSavingsAccount).savings(address(this));\n        // Exits COIN from the coinSavingsAccount\n        CoinSavingsAccountLike(coinSavingsAccount).withdraw(savings);\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(coinJoin);\n        }\n        // Exits the COIN amount corresponding to the value of savings\n        CoinJoinLike(coinJoin).exit(msg.sender, multiply(accumulatedRates, savings) / RAY);\n    }\n}\n\n\n\n\n/// GebProxyAuctionActions.sol\n\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.7;\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nabstract contract AccountingEngineLike {\n    function debtAuctionHouse() external virtual returns (address);\n    function surplusAuctionHouse() external virtual returns (address);\n    function auctionDebt() external virtual returns (uint256);\n    function auctionSurplus() external virtual returns (uint256);\n}\n\nabstract contract DebtAuctionHouseLike {\n    function bids(uint) external virtual returns (uint, uint, address, uint48, uint48);\n    function decreaseSoldAmount(uint256, uint256, uint256) external virtual;\n    function restartAuction(uint256) external virtual;\n    function settleAuction(uint256) external virtual;\n    function protocolToken() external virtual returns (address);\n}\n\nabstract contract SurplusAuctionHouseLike {\n    function bids(uint) external virtual returns (uint, uint, address, uint48, uint48);\n    function increaseBidSize(uint256 id, uint256 amountToBuy, uint256 bid) external virtual;\n    function restartAuction(uint256) external virtual;\n    function settleAuction(uint256) external virtual;\n    function protocolToken() external virtual returns (address);\n}\n\ncontract AuctionCommon {\n\n    /// @notice Claims the full balance of any ERC20 token from the proxy\n    /// @param tokenAddress Address of the token\n    function claimProxyFunds(address tokenAddress) public {\n        DSTokenLike token = DSTokenLike(tokenAddress);\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    /// @notice Claims the full balance of several ERC20 tokens from the proxy\n    /// @param tokenAddresses Addresses of the tokens\n    function claimProxyFunds(address[] memory tokenAddresses) public {\n        for (uint i = 0; i < tokenAddresses.length; i++)\n            claimProxyFunds(tokenAddresses[i]);\n    }\n\n    // --- Utils ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    function toWad(uint rad) internal pure returns (uint wad) {\n        wad = rad / 10**27;\n    }\n}\n\ncontract GebProxyDebtAuctionActions is Common, AuctionCommon {\n\n    /// @notice Starts auction and bids\n    /// @param coinJoin CoinJoin contract\n    /// @param accountingEngineAddress AccountingEngine contract\n    /// @param amountToBuy Amount to buy\n    function startAndDecreaseSoldAmount(address coinJoin, address accountingEngineAddress, uint amountToBuy) public {\n        AccountingEngineLike accountingEngine = AccountingEngineLike(accountingEngineAddress);\n        DebtAuctionHouseLike debtAuctionHouse = DebtAuctionHouseLike(accountingEngine.debtAuctionHouse());\n        SAFEEngineLike safeEngine = SAFEEngineLike(CoinJoinLike(coinJoin).safeEngine());\n\n        // Starts auction\n        uint auctionId = accountingEngine.auctionDebt();\n        (uint bidAmount,,,,) = debtAuctionHouse.bids(auctionId);\n        // Joins system coins\n        coinJoin_join(coinJoin, address(this), toWad(bidAmount));\n        // Allows auction house to access to proxy's COIN balance in the SAFEEngine\n        if (safeEngine.canModifySAFE(address(this), address(debtAuctionHouse)) == 0) {\n            safeEngine.approveSAFEModification(address(debtAuctionHouse));\n        }\n        // Bid\n        debtAuctionHouse.decreaseSoldAmount(auctionId, amountToBuy, bidAmount);\n    }\n\n    /// @notice Bids in auction. Restarts the auction if necessary\n    /// @param coinJoin CoinJoin contract\n    /// @param auctionHouse Auction house address\n    /// @param auctionId Auction ID\n    /// @param amountToBuy Amount to buy\n    function decreaseSoldAmount(address coinJoin, address auctionHouse, uint auctionId, uint amountToBuy) public {\n        DebtAuctionHouseLike debtAuctionHouse = DebtAuctionHouseLike(auctionHouse);\n        SAFEEngineLike safeEngine = SAFEEngineLike(CoinJoinLike(coinJoin).safeEngine());\n\n        (uint bidAmount,,, uint48 bidExpiry, uint48 auctionDeadline) = debtAuctionHouse.bids(auctionId);\n        // Joins system coins\n        coinJoin_join(coinJoin, address(this), toWad(bidAmount));\n        // Allows auction house to access to proxy's COIN balance in the SAFEEngine\n        if (safeEngine.canModifySAFE(address(this), address(debtAuctionHouse)) == 0) {\n            safeEngine.approveSAFEModification(address(debtAuctionHouse));\n        }\n        // Restarts auction if inactive\n        if (both(auctionDeadline < now, bidExpiry == 0)) {\n            debtAuctionHouse.restartAuction(auctionId);\n        }\n        // Bid\n        debtAuctionHouse.decreaseSoldAmount(auctionId, amountToBuy, bidAmount);\n    }\n\n    /// @notice Mints protocol tokens for your proxy and then the proxy sends all of its balance to msg.sender\n    /// @param coinJoin CoinJoin\n    /// @param auctionHouse Auction house address\n    /// @param auctionId Auction ID\n    function settleAuction(address coinJoin, address auctionHouse, uint auctionId) public {\n        DebtAuctionHouseLike debtAuctionHouse = DebtAuctionHouseLike(auctionHouse);\n        debtAuctionHouse.settleAuction(auctionId);\n        claimProxyFunds(address(CoinJoinLike(coinJoin).systemCoin()));\n        claimProxyFunds(debtAuctionHouse.protocolToken());\n    }\n\n    /// @notice Exits Coin to proxy owner\n    /// @param coinJoin CoinJoin\n    /// @param wad Amount to exit\n    function exitCoin(address coinJoin, uint wad) public {\n        // Allows adapter to access to proxy's COIN balance in the safeEngine\n        if (CoinJoinLike(coinJoin).safeEngine().canModifySAFE(address(this), address(coinJoin)) == 0) {\n            CoinJoinLike(coinJoin).safeEngine().approveSAFEModification(coinJoin);\n        }\n        CoinJoinLike(coinJoin).exit(msg.sender, wad);\n    }\n\n    /// @notice Exits full Coin balance to proxy owner\n    /// @param coinJoin CoinJoin\n    function exitAllCoin(address coinJoin) public {\n        exitCoin(coinJoin, CoinJoinLike(coinJoin).safeEngine().coinBalance(address(this)) / RAY);\n    }\n}\n\ncontract GebProxySurplusAuctionActions is Common, AuctionCommon {\n\n    /// @notice Starts surplus auction and bids\n    /// @param accountingEngineAddress AccountingEngine contract\n    /// @param bidSize Bid size\n    function startAndIncreaseBidSize(address accountingEngineAddress, uint bidSize) public {\n        AccountingEngineLike accountingEngine = AccountingEngineLike(accountingEngineAddress);\n        SurplusAuctionHouseLike surplusAuctionHouse = SurplusAuctionHouseLike(accountingEngine.surplusAuctionHouse());\n        DSTokenLike protocolToken = DSTokenLike(surplusAuctionHouse.protocolToken());\n\n        // Starts auction\n        uint auctionId = accountingEngine.auctionSurplus();\n        require(protocolToken.transferFrom(msg.sender, address(this), bidSize), \"geb-proxy-auction-actions/transfer-from-failed\");\n        protocolToken.approve(address(surplusAuctionHouse), bidSize);\n        (, uint amountToSell,,,) = surplusAuctionHouse.bids(auctionId);\n        // Bids\n        surplusAuctionHouse.increaseBidSize(auctionId, amountToSell, bidSize);\n    }\n\n    /// @notice Bids in auction. Restarts the auction if necessary\n    /// @param auctionHouse Auction house address\n    /// @param auctionId Auction ID\n    /// @param bidSize Bid size\n    function increaseBidSize(address auctionHouse, uint auctionId, uint bidSize) public {\n        SurplusAuctionHouseLike surplusAuctionHouse = SurplusAuctionHouseLike(auctionHouse);\n        DSTokenLike protocolToken = DSTokenLike(surplusAuctionHouse.protocolToken());\n\n        require(protocolToken.transferFrom(msg.sender, address(this), bidSize), \"geb-proxy-auction-actions/transfer-from-failed\");\n        protocolToken.approve(address(surplusAuctionHouse), bidSize);\n        // Restarts auction if inactive\n        (, uint amountToSell,, uint48 bidExpiry, uint48 auctionDeadline) = surplusAuctionHouse.bids(auctionId);\n        if (auctionDeadline < now && bidExpiry == 0) {\n            surplusAuctionHouse.restartAuction(auctionId);\n        }\n        // Bid\n        surplusAuctionHouse.increaseBidSize(auctionId, amountToSell, bidSize);\n    }\n\n    /// @notice Mints system coins for your proxy and then the proxy sends all of its balance to msg.sender\n    /// @param coinJoin CoinJoin contract\n    /// @param auctionHouse Auction house address\n    /// @param auctionId Auction ID\n    function settleAuction(address coinJoin, address auctionHouse, uint auctionId) public {\n        SurplusAuctionHouseLike surplusAuctionHouse = SurplusAuctionHouseLike(auctionHouse);\n        SAFEEngineLike safeEngine = SAFEEngineLike(CoinJoinLike(coinJoin).safeEngine());\n        (, uint amountToBuy,,,) = surplusAuctionHouse.bids(auctionId);\n        // Settle auction\n        surplusAuctionHouse.settleAuction(auctionId);\n        // Allows coinJoin to access to proxy's COIN balance in the SAFEEngine\n        if (safeEngine.canModifySAFE(address(this), address(coinJoin)) == 0) {\n            safeEngine.approveSAFEModification(address(coinJoin));\n        }\n        // Sends system coins and protocol tokens to the owner\n        CoinJoinLike(coinJoin).exit(msg.sender, toWad(amountToBuy));\n        claimProxyFunds(surplusAuctionHouse.protocolToken());\n    }\n}\n"}}}