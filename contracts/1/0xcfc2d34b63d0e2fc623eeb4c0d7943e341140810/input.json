{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.5.0;\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "ERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "ERC20Capped.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20Mintable.sol\";\n\n/**\n * @dev Extension of {ERC20Mintable} that adds a cap to the supply of tokens.\n */\ncontract ERC20Capped is ERC20Mintable {\n    uint256 private _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor (uint256 cap) public {\n        require(cap > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20Mintable-mint}.\n     *\n     * Requirements:\n     *\n     * - `value` must not cause the total supply to go over the cap.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(totalSupply().add(value) <= _cap, \"ERC20Capped: cap exceeded\");\n        super._mint(account, value);\n    }\n}\n"
    },
    "ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./MinterRole.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "ERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./Counters.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"
    },
    "ERC721Enumerable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC165.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Constructor function.\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens.\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {ERC721-_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner.\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n"
    },
    "ERC721Full.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\n\n/**\n * @title Full ERC721 Token\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology.\n *\n * See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "ERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./ERC165.sol\";\n\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Base URI\n    string private _baseURI;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the URI for a given token ID. May return an empty string.\n     *\n     * If the token's URI is non-empty and a base URI was set (via\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\n     *\n     * Reverts if the token ID does not exist.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\n        if (bytes(_tokenURI).length == 0) {\n            return \"\";\n        } else {\n            // abi.encodePacked is being used to concatenate strings\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     *\n     * Reverts if the token ID does not exist.\n     *\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\n     * it and save gas.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI}.\n     *\n     * _Available since v2.5.0._\n     */\n    function _setBaseURI(string memory baseURI) internal {\n        _baseURI = baseURI;\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a preffix in {tokenURI} to each token's URI, when\n    * they are non-empty.\n    *\n    * _Available since v2.5.0._\n    */\n    function baseURI() external view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "IERC165.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "IERC721.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"
    },
    "IERC721Enumerable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n"
    },
    "IERC721Metadata.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "IERC721Receiver.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"
    },
    "MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\nimport \"./Roles.sol\";\n\ncontract MinterRole is Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(_msgSender());\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "MorpheusGameController.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./MorpheusToken.sol\";\nimport \"./Rabbits.sol\";\nimport \"./randomOracle.sol\";\n\n// GameController Contract\n// It is a ownable contract. It meens that some function can only be call by the owner/creator of contract\n// Ownable will be transfer to a DAO after 3 months of production\n\ncontract MorpheusGameController is Ownable {\n    using SafeMath for uint256;\n    \n    constructor(randomOracle _oracle, address _oracleAddress)\n        public\n    {\n        // init first instance of game\n        _lastRewardTime = now;\n        beginningTime = now;\n        \n                //init oracle\n        oracle = _oracle;\n        oracleAddress = _oracleAddress;\n    }\n\n    // Tokens used in game\n    MorpheusToken public morpheus;\n    Rabbits public rabbits;\n    randomOracle public oracle;\n    \n    // Oracle Address is an external smart contract providing a random result for the game.\n    address public oracleAddress;\n    \n    // Beginning game time\n    uint256 public beginningTime;\n\n    // Rewards\n    uint256 private _lastRewardTime;\n    // Total quantity of tokens in the reward pool\n    uint256 private _rewardPool;\n\n    // number of period / claim\n    uint256 private _numberOfPeriod = 1;\n\n    // Total value played\n    uint256 private _totalValuePlayed;\n    // Total value burned\n    uint256 private _totalValueBurned;\n    \n    // Total period value played\n    uint256 private _totalValuePlayedOnPeriod;\n    \n    //Minimum balance you need to activate claim function\n    uint256 public minimumBalanceForClaim = 10000*1E18;\n\n    // All players from a period between 2 claims\n    // Reload each time globalClaim is activated\n    address[] public _playersFromPeriod;\n\n    // Addresses of Zion stackers. \n    // Reload each time globalClaim is activated\n    address[] private _zionStackers;\n\n    // Reward part for each players, used for calculate proportion reward\n\n    // Reward that player can claim\n    mapping(address => uint256) private _myRewardTokens;\n\n    // Values used for calculate who are Kings and proportionnal of the reward pool\n    mapping(address => uint256) private _myPeriodLoss;\n    mapping(address => uint256) private _myPeriodBets;\n\n    // King ot the mountain is the player who have done the most bets value in a period\n    // There is only one King of the mountain, if someone got the same bets value,\n    // he can't dethrone the king, only a bigger bets value can dethrone the actual king\n    address public kingOfTheMountain;\n\n    // alert event needed for alert of any provableAPI problem\n    event alertEvent(string alert);\n    \n    event rewardClaimed(address claimer,uint256 claimerGain,uint256 burntValue);\n    event newKingOfTheMountain(address king);\n    // need for result of playing instance 1 = win : 2 =Lost\n    event gotAResult(address _player, uint8 _result);\n    \n\n    // =========================================================================================\n    // Settings Functions  that only owner can call\n    // =========================================================================================\n    \n\n    // Set the MorpheusToken address\n    function setMorpheusToken(MorpheusToken _morpheusToken) public onlyOwner() {\n        morpheus = _morpheusToken;\n        emit alertEvent(\"Morpheus token has been set\");\n    }\n\n    // Set the RabbitToken address\n    function setRabbitsToken(Rabbits _rabbits) public onlyOwner() {\n        rabbits = _rabbits;\n        emit alertEvent(\"Rabbits token has been set\");\n    }\n    \n    // set minimum balance for claimerGain\n    function setMinimumBalanceForClaim(uint256 _amount) public onlyOwner() {\n        minimumBalanceForClaim = _amount.mul(1E18);\n        emit alertEvent(\"Minimum balance for claim has been updated\");\n    }\n    \n    \n    // =========================================================================================\n    // Zion stackers\n    // =========================================================================================\n    \n    uint256 _zionStackingValue = 50000;\n    \n    function setStackingValue(uint256 _amount) public onlyOwner(){\n        _zionStackingValue = _amount;\n    }\n    \n    function getZionStackersNumber() public view returns(uint256 _numberOfStackers){\n        return(_zionStackers.length);\n    }\n\n    // add Zion stacker Addresse\n    function becomeZionStacker() public {\n        require(morpheus.balanceOf(msg.sender)>_zionStackingValue.mul(1E18),\"Not enough balance\");\n        require(!isStacker(msg.sender),\"Already a Zion stacker\");\n        require(_zionStackers.length<50, \"There's no place place for you\");\n        morpheus.transferFrom(msg.sender, address(this), _zionStackingValue.mul(1E18));\n        _zionStackers.push(msg.sender);\n    }\n    \n    // reload Zion stackers\n    function _eraseZionStackers() private {\n        address[] memory _emptyArray;\n        _zionStackers = _emptyArray;\n    }\n    \n    // check if already stackers\n    function isStacker(address _user) public view returns(bool){\n        bool _isStacker = false;\n        for(uint256 i = 0 ; i<_zionStackers.length ; i++){\n            if(_zionStackers[i] == _user){\n                _isStacker = true;\n                break;\n            }\n        }\n        return _isStacker;\n    }\n\n\n    // =========================================================================================\n    // Get Functions\n    // =========================================================================================\n\n    // Get game infos\n    function getGameData()\n        public\n        view\n        returns (\n            uint256 totalPeriod,\n            uint256 totalValuePlayed,\n            uint256 totalValuePlayedOnPeriod,\n            uint256 totalValueBurned,\n            uint256 lastRewardTime,\n            uint256 actualPool,\n            uint256 totalPlayersForThosePeriod\n        )\n    {\n        return (\n            _numberOfPeriod,\n            _totalValuePlayed,\n            _totalValuePlayedOnPeriod,\n            _totalValueBurned,\n            _lastRewardTime,\n            _rewardPool,\n            _playersFromPeriod.length\n        );\n    }\n\n    // Get personnal game infos\n    function getPersonnalData(address _user)\n        public\n        view\n        returns (\n            uint256 playerRewardTokens,\n            uint256 playerPeriodLoss,\n            uint256 playerPeriodBets\n        )\n    {\n        return (\n            _myRewardTokens[_user],\n            _myPeriodLoss[_user],\n            _myPeriodBets[_user]\n        );\n    }\n\n    // =========================================================================================\n    // Play Functions\n    // =========================================================================================\n\n    // Frontend will send the color choice of player. For code simplicity,\n    // the color is hard coding by a number value\n    // Blue is 0 and Red is 1\n\n    struct gameInstance {\n        address player;\n        uint8 choice;\n        uint256 amount;\n    }\n    \n    // Variable used for prevent any claim before gameInstance isn't finished\n    // meens the time before the choose pills action and the return of oracle random number\n    uint256 public gameInstanceNumber = 0;\n\n    mapping(bytes32 => gameInstance) gamesInstances;\n\n    function choosePils(uint256 amount, uint8 _choice) public payable {\n        require(amount > 0 && amount <= 250000,\"Your bet must be between 0 to 250 000 MGT\");\n        uint256 _amount = amount.mul(1E18);\n        // Need to have found amount\n        require(morpheus.balanceOf(msg.sender) > _amount, \"You don't have suffisant balance\");\n        // 0 = Blue or 1 = Red\n        require(_choice == 0 || _choice == 1, \"Choice must be 0 or 1\" );\n\n        // First transfer tokens played in the contract\n        morpheus.transferFrom(msg.sender, address(this), _amount);\n        \n        // Add 1 to game instances number\n        gameInstanceNumber = gameInstanceNumber.add(1);\n         \n        // Add player to list\n        if(!_isPlayerInList(msg.sender)){\n          _playersFromPeriod.push(msg.sender);\n        }\n\n        // Update total value played by all players\n        _totalValuePlayed = _totalValuePlayed.add(_amount);\n        \n        _totalValuePlayedOnPeriod = _totalValuePlayedOnPeriod.add(_amount);\n\n        // Update value of total played by the player\n        _myPeriodBets[msg.sender] = _myPeriodBets[msg.sender].add(_amount);\n\n         // Update king of the mountain if needed\n        if (_myPeriodBets[msg.sender] > _myPeriodBets[kingOfTheMountain]) {\n            kingOfTheMountain = msg.sender;\n            emit newKingOfTheMountain(msg.sender);\n        }\n\n        // init an bytes32 id \n        bytes32 _id = keccak256(abi.encodePacked(\n            _rewardPool.add(1),\n            _totalValuePlayed,\n            _lastRewardTime,\n            _totalValueBurned.add(1)\n            ));\n            \n        gamesInstances[_id] = gameInstance(msg.sender, _choice, _amount);\n        oracle.getRandom(_id);\n    }\n\n    // Call back function used by proableAPI\n    function callback(bytes32 _id,uint _result) external {\n        // Only provable address can call this function\n        require(msg.sender == oracleAddress, \"Callback doesn't come from good Oracle\");\n        require(gamesInstances[_id].player != address(0x0), \"Instance dosn't exist\");\n\n            // If color is the same played by player\n            if (_result == gamesInstances[_id].choice) {\n                //Mint token in contract \n                morpheus.mintTokensForWinner(gamesInstances[_id].amount);\n                //Then send it to player\n                morpheus.transfer(\n                    gamesInstances[_id].player,\n                    gamesInstances[_id].amount.mul(2)\n                );\n                emit gotAResult(gamesInstances[_id].player,1);\n                    \n            //If player loose\n            } else {\n                // Update loss of player\n                _myPeriodLoss[gamesInstances[_id].player] = (_myPeriodLoss[gamesInstances[_id].player]).add(gamesInstances[_id].amount);\n    \n                // Update reward pool\n                _rewardPool = _rewardPool.add(gamesInstances[_id].amount);\n    \n                emit gotAResult(gamesInstances[_id].player, 0);\n                \n            }\n\n        delete gamesInstances[_id];\n        gameInstanceNumber = gameInstanceNumber.sub(1);\n    }\n    \n    // Checking if player is on the players list \n    function _isPlayerInList(address _player) internal view returns (bool) {\n        bool exist = false;\n        for (uint8 i = 0; i < _playersFromPeriod.length; i++) {\n            if (_playersFromPeriod[i] == _player) {\n                exist = true;\n                break;\n            }\n        }\n        return exist;\n    }\n\n    // Providing king of loosers address\n    function _getKingOfLoosers() public view returns (address) {\n        address _kingOfLoosers;\n        uint256 _valueLost = 0;\n        for (uint256 i = 0; i < _playersFromPeriod.length; i++) {\n            // If player got loss\n            if (\n                _myPeriodBets[_playersFromPeriod[i]].div(2) <\n                _myPeriodLoss[_playersFromPeriod[i]]\n            ) {\n                // Calculate total loss by player\n                uint256 _lostByi = _myPeriodLoss[_playersFromPeriod[i]].sub(\n                    _myPeriodBets[_playersFromPeriod[i]].div(2)\n                );\n                // There can be only one King of loosers\n                // If draw, player whos has reached the first is the king\n                if (_valueLost < _lostByi) {\n                    _valueLost = _lostByi;\n                    _kingOfLoosers = _playersFromPeriod[i];\n                }\n            }\n        }\n        return (_kingOfLoosers);\n    }\n\n    // =========================================================================================\n    // Rewards Functions\n    // =========================================================================================\n\n    function claimRewards() public {\n        require(gameInstanceNumber == 0, \"There is a game instance pending please wait\");\n        require(_rewardPool > 0,\"Reward pool is empty !!!\");\n        require(morpheus.balanceOf(msg.sender)>minimumBalanceForClaim,\"You don't have enough MGT for call this function\");\n\n        // Security re entry\n        uint256 _tempRewardPool = _rewardPool;\n        uint256 _originalLostValue = _rewardPool;\n        _rewardPool = 0;\n        _totalValuePlayedOnPeriod = 0;\n        _lastRewardTime = now;\n\n        // update number of period \n        _numberOfPeriod = _numberOfPeriod.add(1);\n\n        // First rewarding kings and claimer\n        uint256 rewardForKings = (_tempRewardPool.mul(100)).div(10000);\n        _transferToKingOfMountain(rewardForKings);\n        \n        // It is possible there is no king of loosers \n        if(_getKingOfLoosers() != address(0x0)){\n            _transferToKingOfLoosers(rewardForKings);\n        }\n\n        \n        // Because solidity don't know floating number, 0.5 % will be 50/10000\n        uint256 _claimerPercentage = _getClaimerPercentage();\n        uint256 rewardForClaimer = (_tempRewardPool.mul(_claimerPercentage)).div(10000);\n        morpheus.transfer(msg.sender, rewardForClaimer);\n\n        // then Burning\n        uint256 burnPercentage = _getBurnPercentage();\n        uint256 totalToBurn = (_tempRewardPool.mul(burnPercentage)).div(10000);\n        morpheus.burnTokens(totalToBurn);\n        _totalValueBurned = _totalValueBurned.add(totalToBurn);\n\n        // Update temp reward pool\n        // If there is there is king of loosers\n        if(_getKingOfLoosers() != address(0x0)){\n            _tempRewardPool = _tempRewardPool.sub(rewardForKings);\n        }\n        _tempRewardPool = _tempRewardPool.sub(rewardForKings);\n        _tempRewardPool = _tempRewardPool.sub(rewardForClaimer);\n        _tempRewardPool = _tempRewardPool.sub(totalToBurn);\n\n        // Zion stackers rewards 10%\n        if(_zionStackers.length>0){\n            \n            uint256 rewardForZionStackers = (_tempRewardPool.mul(1000)).div(10000);\n            _transferToZionStackers(rewardForZionStackers);\n\n            // update _rewardPool\n            _tempRewardPool = _tempRewardPool.sub(rewardForZionStackers);\n        }\n\n        // Update rewards and refresh period .\n        _setRewards(_tempRewardPool,_originalLostValue);\n\n        emit rewardClaimed(msg.sender, rewardForClaimer, totalToBurn);\n    }\n\n    // After claimRewards, players can manualy claim them part of MGT\n    function claimMyReward() public {\n        require(_myRewardTokens[msg.sender] > 0, \"You don't have any token to claim\");\n        // Re entry secure\n        uint256 _myTempRewardTokens = _myRewardTokens[msg.sender];\n        _myRewardTokens[msg.sender] = 0;\n        morpheus.transfer(msg.sender, _myTempRewardTokens);\n    }\n    \n    function _getClaimerPercentage() public view returns (uint256) {\n        uint256 _timeSinceLastReward = now.sub(_lastRewardTime);\n        // 50 meens 0.5% => it will be divid by 10000\n        uint256 _claimPercentage = 50;\n\n        if (_timeSinceLastReward > 1 days && _timeSinceLastReward < 2 days) {\n            _claimPercentage = 100;\n        }\n        if (_timeSinceLastReward >= 2 days && _timeSinceLastReward < 3 days) {\n            _claimPercentage = 150;\n        }\n        if (_timeSinceLastReward >= 3 days && _timeSinceLastReward < 4 days) {\n            _claimPercentage = 200;\n        }\n        if (_timeSinceLastReward >= 4 days && _timeSinceLastReward < 5 days) {\n            _claimPercentage = 250;\n        }\n        if (_timeSinceLastReward >= 5 days) {\n            _claimPercentage = 300;\n        }\n        return _claimPercentage;\n    }\n\n    function _getBurnPercentage() public view returns (uint256) {\n        uint256 _timeSinceLastReward = now.sub(_lastRewardTime);\n        uint256 _burnPercentage = 8950;\n\n        if (_timeSinceLastReward > 1 days && _timeSinceLastReward < 2 days) {\n            _burnPercentage = 7900;\n        }\n        if (_timeSinceLastReward >= 2 days && _timeSinceLastReward < 3 days) {\n            _burnPercentage = 6850;\n        }\n        if (_timeSinceLastReward >= 3 days && _timeSinceLastReward < 4 days) {\n            _burnPercentage = 5800;\n        }\n        if (_timeSinceLastReward >= 4 days && _timeSinceLastReward < 5 days) {\n            _burnPercentage = 4750;\n        }\n        if (_timeSinceLastReward >= 5 days ) {\n            _burnPercentage = 3700;\n        }\n        return _burnPercentage;\n    }\n\n    function _setRewards(uint256 _rewardAmmount, uint256 _originalLostValue) private {\n        require(_originalLostValue > 0 && _playersFromPeriod.length > 0);\n        // Reentry secure\n        uint256 _tempTotalRewardPart = _originalLostValue.mul(100);\n\n        for (uint256 i = 0; i < _playersFromPeriod.length; i++) {\n            // Check if player got reward part\n            if (_myPeriodLoss[_playersFromPeriod[i]] > 0) {\n                // Reentry secure\n                uint256 _myTempRewardPart\n                 = _myPeriodLoss[_playersFromPeriod[i]].mul(100);\n                _myPeriodLoss[_playersFromPeriod[i]] = 0;\n\n                uint256 _oldPersonnalReward\n                 = _myRewardTokens[_playersFromPeriod[i]];\n                _myRewardTokens[_playersFromPeriod[i]] = 0;\n\n                // Calculate personnal reward to add\n                uint256 personnalReward = (\n                    _rewardAmmount.mul(_myTempRewardPart)\n                )\n                    .div(_tempTotalRewardPart);\n\n                //  Add to old rewards\n                _myRewardTokens[_playersFromPeriod[i]] = _oldPersonnalReward\n                    .add(personnalReward);\n            }\n        }\n        _deleteAllPlayersFromPeriod();\n    }\n\n    // update players of the period\n    function _deleteAllPlayersFromPeriod() private {\n        for (uint256 i = 0; i < _playersFromPeriod.length; i++) {\n            _myPeriodLoss[_playersFromPeriod[i]] = 0;\n            _myPeriodBets[_playersFromPeriod[i]] = 0;\n        }\n        address[] memory _newArray;\n        _playersFromPeriod =_newArray;\n    }\n\n    function _transferToZionStackers(uint256 _amount) private {\n        // To be sure to have a valid uint we substract modulo of matrixRunners number to amount\n        uint256 amountModuloStackersNumber = _amount.sub(_amount % _zionStackers.length);\n        // calculate value to transfer\n        uint256 _toTransfer = amountModuloStackersNumber.div(_zionStackers.length);\n        // + add stacking tokens\n        _toTransfer = _toTransfer.add(_zionStackingValue.mul(1E18));\n        for (uint256 i = 0; i < _zionStackers.length; i++) {\n            morpheus.transfer(\n                _zionStackers[i],\n                _toTransfer\n            );\n        }\n        _eraseZionStackers();\n    }\n\n    function _transferToKingOfMountain(uint256 _amount) private {\n        require(kingOfTheMountain != address(0x0), \"There is no king of the mountain \");\n        // Re entry secure\n        address _kingOfTheMountain = kingOfTheMountain;\n        kingOfTheMountain = address(0x0);\n\n        morpheus.transfer(_kingOfTheMountain, _amount);\n    }\n\n    function _transferToKingOfLoosers(uint256 _amount) private {\n        if(_getKingOfLoosers() != address(0x0)){\n            morpheus.transfer(_getKingOfLoosers(), _amount);           \n        }\n    }\n\n    // =========================================================================================\n    // Rabbits Functions\n    // =========================================================================================\n    \n\n    // superclaim is the function who can only call the owner of 3 rabbits (3 different colors)\n    // Those 3 rabbits will be burn and 50% of the reward pool wll be transfer to claimer\n    // Rabbits must be approvedForAll by the owner for contract of gameAddress\n    function superClaim(\n        uint256 _id1,\n        uint256 _id2,\n        uint256 _id3\n    ) public {\n        require(gameInstanceNumber == 0, \"There is a game instance pending please wait\");\n        require(_rewardPool > 0, \"There is no reward on pool\");\n        // Can't be called before 30 days \n        require(now.sub(beginningTime) >= 40 days);\n        require(\n            (rabbits.ownerOf(_id1) == msg.sender &&\n            rabbits.ownerOf(_id2) == msg.sender &&\n            rabbits.ownerOf(_id3) == msg.sender),\n            \"You don't have the required Rabbits !!!\"\n        );\n        // Re entry secure\n        uint256 _tempRewardPool = _rewardPool;\n        _rewardPool = 0;\n        \n        // Update number of periods of clock\n        _numberOfPeriod = _numberOfPeriod.add(1);\n        _lastRewardTime = now;\n        \n        // Reward kings\n        uint256 rewardForKings = (_tempRewardPool.mul(1)).div(100);\n        _transferToKingOfMountain(rewardForKings);\n        _transferToKingOfLoosers(rewardForKings);\n        \n        // Reward superClaimer\n        uint256 rewardForClaimer = _tempRewardPool.div(2);\n        morpheus.transfer(msg.sender, rewardForClaimer);\n        \n        // update reward to burn\n        _tempRewardPool = _tempRewardPool.sub(rewardForClaimer);\n        _tempRewardPool = _tempRewardPool.sub(rewardForKings.mul(2));\n        \n        // Burn tokens\n        morpheus.burnTokens(_tempRewardPool);\n        _totalValueBurned = _totalValueBurned.add(_tempRewardPool);\n\n        // Burn Rabbits\n        rabbits.burnRabbitsTrilogy(msg.sender, _id1, _id2, _id3);\n        // Update players for period.\n        _deleteAllPlayersFromPeriod();\n\n    }\n    \n\n}\n"
    },
    "MorpheusToken.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"./ERC20Detailed.sol\";\nimport \"./ERC20Capped.sol\";\n\ncontract MorpheusToken is ERC20, ERC20Detailed, ERC20Capped {\n    \n    address public deployerAddress;\n    address public gameControllerAddress;\n    \n    bool public locked = true; \n    \n    // MorpheusGameController will be deployed before the token.\n    // We'll deliver the contract game address on deployment of the token \n    // Nobody can change this game address after deployment    \n\n    \n    constructor(address _deployer, address _gameAddress) public ERC20Detailed(\"MorpheusGameToken\", \"MGT\", 18) ERC20Capped(500000000*1E18) {\n              deployerAddress =_deployer;\n              gameControllerAddress = _gameAddress;\n    }\n\n    modifier onlyGameController() {\n        require(msg.sender == gameControllerAddress);\n        _;\n    }\n    \n    modifier onlyDeployer() {\n        require(msg.sender == deployerAddress);\n        _;\n    }\n    \n    // Function who will be called after the init of gameControllerAddress\n    // After this, token won't have any other controller\n    function eraseDeployerAddress() public onlyDeployer(){\n        deployerAddress = address(0x0);\n    }\n    \n    \n    // Tokens will be locked untill the liquity added in uniswap\n    function unlock() public onlyDeployer {\n        locked = false;\n    } \n    \n    function _isLocked() private view returns(bool) {\n        // if crowdsale is finished + 1H ( December 12 - 16h UTC)\n        // token are automaticly unlock\n        if(now > 1607788800){\n            return true;\n        }\n        else{\n            return locked;\n        } \n    }\n\n    \n    function transfer(address to, uint256 amount) public returns(bool) {\n        if(_isLocked()) {\n            require(msg.sender == deployerAddress,\"Token is locked until December 12 2020 at 16h UTC\");\n            super.transfer(to, amount);\n        } else{\n            super.transfer(to, amount);\n        }\n\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public returns(bool) {\n        if(_isLocked()) {\n            require(msg.sender == deployerAddress,\"Token is locked until December 12 2020 at 16h UTC\");\n            super.transferFrom(from, to, amount);\n        } else{\n            super.transferFrom(from, to, amount); \n        }\n\n    }\n\n\n    function burnTokens(uint256 _amount) public  {\n        _burn(msg.sender, _amount);\n    }\n\n    // This is the function used by the gameController Contract for minting token who will be send to the user\n    // ONLY GameController can call this function.\n    // AND the gameController have only one reference to THIS function (line 288 in GameController.sol):\n    // In the __callback()  (line 228 in GameController.sol) \n    // This __callback() function can only be called by provableAPI Address. This meens that only return of ORACLE can return a token minting\n    function mintTokensForWinner(uint256 _amount) public onlyGameController() {\n        _mint(gameControllerAddress, _amount);\n    }\n}\n"
    },
    "Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "Rabbits.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"./ERC721Full.sol\";\nimport \"./Ownable.sol\";\n\n//NFT Contract\n\n\ncontract Rabbits is ERC721Full, Ownable {\n    // All 160 Rabbits got color White, Blue and Red\n    mapping(uint256 => string) public colorRabbit;\n\n    // Only gameAddress can burn Rabbits\n    address public gameControllerAddress;\n    // Only farming can mint Rabbits\n    address public farmControllerAddress;\n\n    constructor() public ERC721Full(\"RabbitsToken\", \"RBTS\") {\n        // Rabbits Colors init\n\n        // id 1 to 10 (10 Rabbits) are \"White Rabbits\"\n        for (uint256 i = 1; i < 11; i++) {\n            colorRabbit[i] = \"White\";\n        }\n\n        // id 11 to 60 (50 Rabbits) are \"Blue Rabbits\"\n        for (uint256 i = 11; i < 61; i++) {\n            colorRabbit[i] = \"Blue\";\n        }\n\n        // id 61 to 160 (100 Rabbits) are \"Red Rabbits\"\n        for (uint256 i = 61; i < 161; i++) {\n            colorRabbit[i] = \"Red\";\n        }\n    }\n\n    modifier onlyGameController() {\n        require(msg.sender == gameControllerAddress);\n        _;\n    }\n    \n    modifier onlyFarmingController() {\n        require(msg.sender == farmControllerAddress);\n        _;\n    }\n\n    // events for prevent Players from any change\n    event GameAddressChanged(address newGameAddress);\n    \n    // events for prevent Players from any change\n    event FarmAddressChanged(address newFarmAddress);\n    \n\n    // init game smart contract address\n    function setGameAddress(address _gameAddress) public onlyOwner() {\n        gameControllerAddress = _gameAddress;\n        emit GameAddressChanged(_gameAddress);\n    }\n    \n        // init farming smart contract address\n    function setFarmingAddress(address _farmAddress) public onlyOwner() {\n        farmControllerAddress = _farmAddress;\n        emit FarmAddressChanged(_farmAddress);\n    }\n\n    // Function that only farming smart contract address can call for mint a Rabbit\n    function mintRabbit(address _to, uint256 _id) public onlyFarmingController() {\n        _mint(_to, _id);\n    }\n\n    // Function that only game smart contract address can call for burn Rabbits trilogy\n    // Rabbits must be approvedForAll by the owner for contract of gameAddress\n    function burnRabbitsTrilogy(\n        address _ownerOfRabbit,\n        uint256 _id1,\n        uint256 _id2,\n        uint256 _id3\n    ) public onlyGameController() {\n        require(\n            keccak256(abi.encodePacked(colorRabbit[_id1])) ==\n                keccak256(abi.encodePacked(\"White\")) &&\n                keccak256(abi.encodePacked(colorRabbit[_id2])) ==\n                keccak256(abi.encodePacked(\"Blue\")) &&\n                keccak256(abi.encodePacked(colorRabbit[_id3])) ==\n                keccak256(abi.encodePacked(\"Red\"))\n        );\n        _burn(_ownerOfRabbit, _id1);\n        _burn(_ownerOfRabbit, _id2);\n        _burn(_ownerOfRabbit, _id3);\n    }\n}\n"
    },
    "Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "randomOracle.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"./MorpheusGameController.sol\";\nimport \"./SafeMath.sol\";\n\n\ncontract randomOracle {\n\n    address public gameAddress;\n    MorpheusGameController public game;\n    uint256 nonce = 17;\n    uint8 mod = 2;\n    address public deployer;\n    \n    using SafeMath for uint256;\n    \n   constructor() public{\n    deployer = msg.sender;\n    }\n    \n    modifier onlyGame() {\n        require(msg.sender == gameAddress);\n        _;\n    }\n    \n    function setGame(MorpheusGameController _game, address _gameAddress) public{\n        require(msg.sender==deployer,\"Not your Oracle\");\n        game = _game;\n        gameAddress = _gameAddress;\n    }\n    \n    function getRandom(bytes32 _id) external onlyGame() returns(uint){\n        return _getRandom(_id);\n    }\n    \n    \n    function _getRandom(bytes32 _id) private returns(uint256){\n        uint256 _random = (uint256(keccak256(abi.encodePacked(now,_id, block.difficulty,nonce,block.number)))) % mod; \n        nonce = nonce.add(1);\n        returnResult(_id,_random);\n    }\n    \n    \n    function returnResult(bytes32 _id, uint _result) private{\n        game.callback(_id,_result);\n    }\n    \n    \n}\n"
    }
  }
}