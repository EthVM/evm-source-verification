{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"EthRewardsManager.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n/**\r\n* @title Checkpointing - Library to handle a historic set of numeric values\r\n*/\r\nlibrary Checkpointing {\r\n    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\r\n\r\n    string private constant ERROR_VALUE_TOO_BIG = \"CHECKPOINT_VALUE_TOO_BIG\";\r\n    string private constant ERROR_CANNOT_ADD_PAST_VALUE = \"CHECKPOINT_CANNOT_ADD_PAST_VALUE\";\r\n\r\n    /**\r\n    * @dev To specify a value at a given point in time, we need to store two values:\r\n    *      - `time`: unit-time value to denote the first time when a value was registered\r\n    *      - `value`: a positive numeric value to registered at a given point in time\r\n    *\r\n    *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\r\n    *      for it like block numbers, terms, etc.\r\n    */\r\n    struct Checkpoint {\r\n        uint64 time;\r\n        uint192 value;\r\n    }\r\n\r\n    /**\r\n    * @dev A history simply denotes a list of checkpoints\r\n    */\r\n    struct History {\r\n        Checkpoint[] history;\r\n    }\r\n\r\n    /**\r\n    * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\r\n    *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\r\n    *      will be updated.\r\n    * @param self Checkpoints history to be altered\r\n    * @param _time Point in time to register the given value\r\n    * @param _value Numeric value to be registered at the given point in time\r\n    */\r\n    function add(History storage self, uint64 _time, uint256 _value) internal {\r\n        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\r\n        _add192(self, _time, uint192(_value));\r\n    }\r\n\r\n    /**\r\n    * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\r\n    * @param self Checkpoints history to be queried\r\n    */\r\n    function getLast(History storage self) internal view returns (uint256) {\r\n        uint256 length = self.history.length;\r\n        if (length > 0) {\r\n            return uint256(self.history[length - 1].value);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\r\n    *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\r\n    *      previous to the first registered value.\r\n    *      It uses a binary search.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function get(History storage self, uint64 _time) internal view returns (uint256) {\r\n        return _binarySearch(self, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Fetch the most recent registered past value of a history based on a given point in time. It will return zero\r\n    *      if there is no registered value or if given time is previous to the first registered value.\r\n    *      It uses a linear search starting from the end.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function getRecent(History storage self, uint64 _time) internal view returns (uint256) {\r\n        return _backwardsLinearSearch(self, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\r\n    *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\r\n    *      registered value, it will be updated.\r\n    * @param self Checkpoints history to be altered\r\n    * @param _time Point in time to register the given value\r\n    * @param _value Numeric value to be registered at the given point in time\r\n    */\r\n    function _add192(History storage self, uint64 _time, uint192 _value) private {\r\n        uint256 length = self.history.length;\r\n        if (length == 0 || self.history[self.history.length - 1].time < _time) {\r\n            // If there was no value registered or the given point in time is after the latest registered value,\r\n            // we can insert it to the history directly.\r\n            self.history.push(Checkpoint(_time, _value));\r\n        } else {\r\n            // If the point in time given for the new value is not after the latest registered value, we must ensure\r\n            // we are only trying to update the latest value, otherwise we would be changing past data.\r\n            Checkpoint storage currentCheckpoint = self.history[length - 1];\r\n            require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);\r\n            currentCheckpoint.value = _value;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Private function to execute a backwards linear search to find the most recent registered past value of a\r\n    *      history based on a given point in time. It will return zero if there is no registered value or if given time\r\n    *      is previous to the first registered value. Note that this function will be more suitable when we already know\r\n    *      that the time used to index the search is recent in the given history.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function _backwardsLinearSearch(History storage self, uint64 _time) private view returns (uint256) {\r\n        // If there was no value registered for the given history return simply zero\r\n        uint256 length = self.history.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 index = length - 1;\r\n        Checkpoint storage checkpoint = self.history[index];\r\n        while (index > 0 && checkpoint.time > _time) {\r\n            index--;\r\n            checkpoint = self.history[index];\r\n        }\r\n\r\n        return checkpoint.time > _time ? 0 : uint256(checkpoint.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Private function execute a binary search to find the most recent registered past value of a history based on\r\n    *      a given point in time. It will return zero if there is no registered value or if given time is previous to\r\n    *      the first registered value. Note that this function will be more suitable when don't know how recent the\r\n    *      time used to index may be.\r\n    * @param self Checkpoints history to be queried\r\n    * @param _time Point in time to query the most recent registered past value of\r\n    */\r\n    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\r\n        // If there was no value registered for the given history return simply zero\r\n        uint256 length = self.history.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // If the requested time is equal to or after the time of the latest registered value, return latest value\r\n        uint256 lastIndex = length - 1;\r\n        if (_time >= self.history[lastIndex].time) {\r\n            return uint256(self.history[lastIndex].value);\r\n        }\r\n\r\n        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\r\n        if (_time < self.history[0].time) {\r\n            return 0;\r\n        }\r\n\r\n        // Execute a binary search between the checkpointed times of the history\r\n        uint256 low = 0;\r\n        uint256 high = lastIndex;\r\n\r\n        while (high > low) {\r\n            // No need for SafeMath: for this to overflow array size should be ~2^255\r\n            uint256 mid = (high + low + 1) / 2;\r\n            Checkpoint storage checkpoint = self.history[mid];\r\n            uint64 midTime = checkpoint.time;\r\n\r\n            if (_time > midTime) {\r\n                low = mid;\r\n            } else if (_time < midTime) {\r\n                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\r\n                high = mid - 1;\r\n            } else {\r\n                return uint256(checkpoint.value);\r\n            }\r\n        }\r\n\r\n        return uint256(self.history[low].value);\r\n    }\r\n}\r\n\r\n\r\nlibrary Uint256Helpers {\r\n    uint256 private constant MAX_UINT8 = uint8(-1);\r\n    uint256 private constant MAX_UINT64 = uint64(-1);\r\n\r\n    string private constant ERROR_UINT8_NUMBER_TOO_BIG = \"UINT8_NUMBER_TOO_BIG\";\r\n    string private constant ERROR_UINT64_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\r\n\r\n    function toUint8(uint256 a) internal pure returns (uint8) {\r\n        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\r\n        return uint8(a);\r\n    }\r\n\r\n    function toUint64(uint256 a) internal pure returns (uint64) {\r\n        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\r\n        return uint64(a);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following \r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool isTopLevelCall = !initializing;\r\n    if (isTopLevelCall) {\r\n      initializing = true;\r\n      initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      initializing = false;\r\n    }\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    address self = address(this);\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(self) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context is Initializable {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract MinterRole is Initializable, Context {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private _minters;\r\n\r\n    function initialize(address sender) public initializer {\r\n        if (!isMinter(sender)) {\r\n            _addMinter(sender);\r\n        }\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return _minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(_msgSender());\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        _minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        _minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Initializable, Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\ncontract ERC20Burnable is Initializable, Context, ERC20 {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_burnFrom}.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public {\r\n        _burnFrom(account, amount);\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\r\n * which have permission to mint (create) new tokens as they see fit.\r\n *\r\n * At construction, the deployer of the contract is the only minter.\r\n */\r\ncontract ERC20Mintable is Initializable, ERC20, MinterRole {\r\n    function initialize(address sender) public initializer {\r\n        MinterRole.initialize(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the {MinterRole}.\r\n     */\r\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// Interface for interaction with Wormhole v2 TokenBridge\r\n// https://github.com/certusone/wormhole/blob/7e2cf1f9818099c63c21d101afbfedb1903ee9ba/ethereum/contracts/bridge/Bridge.sol#L93\r\ninterface Wormhole {\r\n    function transferTokens(\r\n        address token,\r\n        uint256 amount,\r\n        uint16 recipientChain,\r\n        bytes32 recipient,\r\n        uint256 arbiterFee,\r\n        uint32 nonce\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Wrapper around OpenZeppelin's Initializable contract.\r\n * Exposes initialized state management to ensure logic contract functions cannot be called before initialization.\r\n * This is needed because OZ's Initializable contract no longer exposes initialized state variable.\r\n * https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.8.0/packages/lib/contracts/Initializable.sol\r\n */\r\ncontract InitializableV2 is Initializable {\r\n    bool private isInitialized;\r\n\r\n    string private constant ERROR_NOT_INITIALIZED = \"InitializableV2: Not initialized\";\r\n\r\n    /**\r\n     * @notice wrapper function around parent contract Initializable's `initializable` modifier\r\n     *      initializable modifier ensures this function can only be called once by each deployed child contract\r\n     *      sets isInitialized flag to true to which is used by _requireIsInitialized()\r\n     */\r\n    function initialize() public initializer {\r\n        isInitialized = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts transaction if isInitialized is false. Used by child contracts to ensure\r\n     *      contract is initialized before functions can be called.\r\n     */\r\n    function _requireIsInitialized() internal view {\r\n        require(isInitialized == true, ERROR_NOT_INITIALIZED);\r\n    }\r\n\r\n    /**\r\n     * @notice Exposes isInitialized bool var to child contracts with read-only access\r\n     */\r\n    function _isInitialized() internal view returns (bool) {\r\n        return isInitialized;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Staking is InitializableV2 {\r\n    using SafeMath for uint256;\r\n    using Uint256Helpers for uint256;\r\n    using Checkpointing for Checkpointing.History;\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_TOKEN_NOT_CONTRACT = \"Staking: Staking token is not a contract\";\r\n    string private constant ERROR_AMOUNT_ZERO = \"Staking: Zero amount not allowed\";\r\n    string private constant ERROR_ONLY_GOVERNANCE = \"Staking: Only governance\";\r\n    string private constant ERROR_ONLY_DELEGATE_MANAGER = (\r\n      \"Staking: Only callable from DelegateManager\"\r\n    );\r\n    string private constant ERROR_ONLY_SERVICE_PROVIDER_FACTORY = (\r\n      \"Staking: Only callable from ServiceProviderFactory\"\r\n    );\r\n\r\n    address private governanceAddress;\r\n    address private claimsManagerAddress;\r\n    address private delegateManagerAddress;\r\n    address private serviceProviderFactoryAddress;\r\n\r\n    /// @dev stores the history of staking and claims for a given address\r\n    struct Account {\r\n        Checkpointing.History stakedHistory;\r\n        Checkpointing.History claimHistory;\r\n    }\r\n\r\n    /// @dev ERC-20 token that will be used to stake with\r\n    ERC20 internal stakingToken;\r\n\r\n    /// @dev maps addresses to staking and claims history\r\n    mapping (address => Account) internal accounts;\r\n\r\n    /// @dev total staked tokens at a given block\r\n    Checkpointing.History internal totalStakedHistory;\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 total);\r\n    event Unstaked(address indexed user, uint256 amount, uint256 total);\r\n    event Slashed(address indexed user, uint256 amount, uint256 total);\r\n\r\n    /**\r\n     * @notice Function to initialize the contract\r\n     * @dev claimsManagerAddress must be initialized separately after ClaimsManager contract is deployed\r\n     * @dev delegateManagerAddress must be initialized separately after DelegateManager contract is deployed\r\n     * @dev serviceProviderFactoryAddress must be initialized separately after ServiceProviderFactory contract is deployed\r\n     * @param _tokenAddress - address of ERC20 token that will be staked\r\n     * @param _governanceAddress - address for Governance proxy contract\r\n     */\r\n    function initialize(\r\n        address _tokenAddress,\r\n        address _governanceAddress\r\n    ) public initializer\r\n    {\r\n        require(Address.isContract(_tokenAddress), ERROR_TOKEN_NOT_CONTRACT);\r\n        stakingToken = ERC20(_tokenAddress);\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Governance address\r\n     * @dev Only callable by Governance address\r\n     * @param _governanceAddress - address for new Governance contract\r\n     */\r\n    function setGovernanceAddress(address _governanceAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        _updateGovernanceAddress(_governanceAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ClaimsManaager address\r\n     * @dev Only callable by Governance address\r\n     * @param _claimsManager - address for new ClaimsManaager contract\r\n     */\r\n    function setClaimsManagerAddress(address _claimsManager) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        claimsManagerAddress = _claimsManager;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ServiceProviderFactory address\r\n     * @dev Only callable by Governance address\r\n     * @param _spFactory - address for new ServiceProviderFactory contract\r\n     */\r\n    function setServiceProviderFactoryAddress(address _spFactory) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        serviceProviderFactoryAddress = _spFactory;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the DelegateManager address\r\n     * @dev Only callable by Governance address\r\n     * @param _delegateManager - address for new DelegateManager contract\r\n     */\r\n    function setDelegateManagerAddress(address _delegateManager) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        delegateManagerAddress = _delegateManager;\r\n    }\r\n\r\n    /* External functions */\r\n\r\n    /**\r\n     * @notice Funds `_amount` of tokens from ClaimsManager to target account\r\n     * @param _amount - amount of rewards to  add to stake\r\n     * @param _stakerAccount - address of staker\r\n     */\r\n    function stakeRewards(uint256 _amount, address _stakerAccount) external {\r\n        _requireIsInitialized();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == claimsManagerAddress,\r\n            \"Staking: Only callable from ClaimsManager\"\r\n        );\r\n        _stakeFor(_stakerAccount, msg.sender, _amount);\r\n\r\n        this.updateClaimHistory(_amount, _stakerAccount);\r\n    }\r\n\r\n    /**\r\n     * @notice Update claim history by adding an event to the claim history\r\n     * @param _amount - amount to add to claim history\r\n     * @param _stakerAccount - address of staker\r\n     */\r\n    function updateClaimHistory(uint256 _amount, address _stakerAccount) external {\r\n        _requireIsInitialized();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == claimsManagerAddress || msg.sender == address(this),\r\n            \"Staking: Only callable from ClaimsManager or Staking.sol\"\r\n        );\r\n\r\n        // Update claim history even if no value claimed\r\n        accounts[_stakerAccount].claimHistory.add(block.number.toUint64(), _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Slashes `_amount` tokens from _slashAddress\r\n     * @dev Callable from DelegateManager\r\n     * @param _amount - Number of tokens slashed\r\n     * @param _slashAddress - Address being slashed\r\n     */\r\n    function slash(\r\n        uint256 _amount,\r\n        address _slashAddress\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requireDelegateManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == delegateManagerAddress,\r\n            ERROR_ONLY_DELEGATE_MANAGER\r\n        );\r\n\r\n        // Burn slashed tokens from account\r\n        _burnFor(_slashAddress, _amount);\r\n\r\n        emit Slashed(\r\n            _slashAddress,\r\n            _amount,\r\n            totalStakedFor(_slashAddress)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes `_amount` tokens, transferring them from _accountAddress, and assigns them to `_accountAddress`\r\n     * @param _accountAddress - The final staker of the tokens\r\n     * @param _amount - Number of tokens staked\r\n     */\r\n    function stakeFor(\r\n        address _accountAddress,\r\n        uint256 _amount\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == serviceProviderFactoryAddress,\r\n            ERROR_ONLY_SERVICE_PROVIDER_FACTORY\r\n        );\r\n        _stakeFor(\r\n            _accountAddress,\r\n            _accountAddress,\r\n            _amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes `_amount` tokens, returning them to the desired account.\r\n     * @param _accountAddress - Account unstaked for, and token recipient\r\n     * @param _amount - Number of tokens staked\r\n     */\r\n    function unstakeFor(\r\n        address _accountAddress,\r\n        uint256 _amount\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == serviceProviderFactoryAddress,\r\n            ERROR_ONLY_SERVICE_PROVIDER_FACTORY\r\n        );\r\n        _unstakeFor(\r\n            _accountAddress,\r\n            _accountAddress,\r\n            _amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes `_amount` tokens, transferring them from `_delegatorAddress` to `_accountAddress`,\r\n               only callable by DelegateManager\r\n     * @param _accountAddress - The final staker of the tokens\r\n     * @param _delegatorAddress - Address from which to transfer tokens\r\n     * @param _amount - Number of tokens staked\r\n     */\r\n    function delegateStakeFor(\r\n        address _accountAddress,\r\n        address _delegatorAddress,\r\n        uint256 _amount\r\n    ) external {\r\n        _requireIsInitialized();\r\n        _requireDelegateManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == delegateManagerAddress,\r\n            ERROR_ONLY_DELEGATE_MANAGER\r\n        );\r\n        _stakeFor(\r\n            _accountAddress,\r\n            _delegatorAddress,\r\n            _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes '_amount` tokens, transferring them from `_accountAddress` to `_delegatorAddress`,\r\n               only callable by DelegateManager\r\n     * @param _accountAddress - The staker of the tokens\r\n     * @param _delegatorAddress - Address from which to transfer tokens\r\n     * @param _amount - Number of tokens unstaked\r\n     */\r\n    function undelegateStakeFor(\r\n        address _accountAddress,\r\n        address _delegatorAddress,\r\n        uint256 _amount\r\n    ) external {\r\n        _requireIsInitialized();\r\n        _requireDelegateManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == delegateManagerAddress,\r\n            ERROR_ONLY_DELEGATE_MANAGER\r\n        );\r\n        _unstakeFor(\r\n            _accountAddress,\r\n            _delegatorAddress,\r\n            _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token used by the contract for staking and locking\r\n     * @return The token used by the contract for staking and locking\r\n     */\r\n    function token() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return address(stakingToken);\r\n    }\r\n\r\n    /**\r\n     * @notice Check whether it supports history of stakes\r\n     * @return Always true\r\n     */\r\n    function supportsHistory() external view returns (bool) {\r\n        _requireIsInitialized();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get last time `_accountAddress` modified its staked balance\r\n     * @param _accountAddress - Account requesting for\r\n     * @return Last block number when account's balance was modified\r\n     */\r\n    function lastStakedFor(address _accountAddress) external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        uint256 length = accounts[_accountAddress].stakedHistory.history.length;\r\n        if (length > 0) {\r\n            return uint256(accounts[_accountAddress].stakedHistory.history[length - 1].time);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Get last time `_accountAddress` claimed a staking reward\r\n     * @param _accountAddress - Account requesting for\r\n     * @return Last block number when claim requested\r\n     */\r\n    function lastClaimedFor(address _accountAddress) external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        uint256 length = accounts[_accountAddress].claimHistory.history.length;\r\n        if (length > 0) {\r\n            return uint256(accounts[_accountAddress].claimHistory.history[length - 1].time);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by `_accountAddress` at block number `_blockNumber`\r\n     * @param _accountAddress - Account requesting for\r\n     * @param _blockNumber - Block number at which we are requesting\r\n     * @return The amount of tokens staked by the account at the given block number\r\n     */\r\n    function totalStakedForAt(\r\n        address _accountAddress,\r\n        uint256 _blockNumber\r\n    ) external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        return accounts[_accountAddress].stakedHistory.get(_blockNumber.toUint64());\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by all users at block number `_blockNumber`\r\n     * @param _blockNumber - Block number at which we are requesting\r\n     * @return The amount of tokens staked at the given block number\r\n     */\r\n    function totalStakedAt(uint256 _blockNumber) external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        return totalStakedHistory.get(_blockNumber.toUint64());\r\n    }\r\n\r\n    /// @notice Get the Governance address\r\n    function getGovernanceAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return governanceAddress;\r\n    }\r\n\r\n    /// @notice Get the ClaimsManager address\r\n    function getClaimsManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return claimsManagerAddress;\r\n    }\r\n\r\n    /// @notice Get the ServiceProviderFactory address\r\n    function getServiceProviderFactoryAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderFactoryAddress;\r\n    }\r\n\r\n    /// @notice Get the DelegateManager address\r\n    function getDelegateManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return delegateManagerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function wrapped around totalStakedFor. Checks whether _accountAddress\r\n            is currently a valid staker with a non-zero stake\r\n     * @param _accountAddress - Account requesting for\r\n     * @return Boolean indicating whether account is a staker\r\n     */\r\n    function isStaker(address _accountAddress) external view returns (bool) {\r\n        _requireIsInitialized();\r\n\r\n        return totalStakedFor(_accountAddress) > 0;\r\n    }\r\n\r\n    /* Public functions */\r\n\r\n    /**\r\n     * @notice Get the amount of tokens staked by `_accountAddress`\r\n     * @param _accountAddress - The owner of the tokens\r\n     * @return The amount of tokens staked by the given account\r\n     */\r\n    function totalStakedFor(address _accountAddress) public view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        // we assume it's not possible to stake in the future\r\n        return accounts[_accountAddress].stakedHistory.getLast();\r\n    }\r\n\r\n    /**\r\n     * @notice Get the total amount of tokens staked by all users\r\n     * @return The total amount of tokens staked by all users\r\n     */\r\n    function totalStaked() public view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        // we assume it's not possible to stake in the future\r\n        return totalStakedHistory.getLast();\r\n    }\r\n\r\n    // ========================================= Internal Functions =========================================\r\n\r\n    /**\r\n     * @notice Adds stake from a transfer account to the stake account\r\n     * @param _stakeAccount - Account that funds will be staked for\r\n     * @param _transferAccount - Account that funds will be transferred from\r\n     * @param _amount - amount to stake\r\n     */\r\n    function _stakeFor(\r\n        address _stakeAccount,\r\n        address _transferAccount,\r\n        uint256 _amount\r\n    ) internal\r\n    {\r\n        // staking 0 tokens is invalid\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // Checkpoint updated staking balance\r\n        _modifyStakeBalance(_stakeAccount, _amount, true);\r\n\r\n        // checkpoint total supply\r\n        _modifyTotalStaked(_amount, true);\r\n\r\n        // pull tokens into Staking contract\r\n        stakingToken.safeTransferFrom(_transferAccount, address(this), _amount);\r\n\r\n        emit Staked(\r\n            _stakeAccount,\r\n            _amount,\r\n            totalStakedFor(_stakeAccount));\r\n    }\r\n\r\n    /**\r\n     * @notice Unstakes tokens from a stake account to a transfer account\r\n     * @param _stakeAccount - Account that staked funds will be transferred from\r\n     * @param _transferAccount - Account that funds will be transferred to\r\n     * @param _amount - amount to unstake\r\n     */\r\n    function _unstakeFor(\r\n        address _stakeAccount,\r\n        address _transferAccount,\r\n        uint256 _amount\r\n    ) internal\r\n    {\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // checkpoint updated staking balance\r\n        _modifyStakeBalance(_stakeAccount, _amount, false);\r\n\r\n        // checkpoint total supply\r\n        _modifyTotalStaked(_amount, false);\r\n\r\n        // transfer tokens\r\n        stakingToken.safeTransfer(_transferAccount, _amount);\r\n\r\n        emit Unstaked(\r\n            _stakeAccount,\r\n            _amount,\r\n            totalStakedFor(_stakeAccount)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Burn tokens for a given staker\r\n     * @dev Called when slash occurs\r\n     * @param _stakeAccount - Account for which funds will be burned\r\n     * @param _amount - amount to burn\r\n     */\r\n    function _burnFor(address _stakeAccount, uint256 _amount) internal {\r\n        // burning zero tokens is not allowed\r\n        require(_amount > 0, ERROR_AMOUNT_ZERO);\r\n\r\n        // checkpoint updated staking balance\r\n        _modifyStakeBalance(_stakeAccount, _amount, false);\r\n\r\n        // checkpoint total supply\r\n        _modifyTotalStaked(_amount, false);\r\n\r\n        // burn\r\n        ERC20Burnable(address(stakingToken)).burn(_amount);\r\n\r\n        /** No event emitted since token.burn() call already emits a Transfer event */\r\n    }\r\n\r\n    /**\r\n     * @notice Increase or decrease the staked balance for an account\r\n     * @param _accountAddress - Account to modify\r\n     * @param _by - amount to modify\r\n     * @param _increase - true if increase in stake, false if decrease\r\n     */\r\n    function _modifyStakeBalance(address _accountAddress, uint256 _by, bool _increase) internal {\r\n        uint256 currentInternalStake = accounts[_accountAddress].stakedHistory.getLast();\r\n\r\n        uint256 newStake;\r\n        if (_increase) {\r\n            newStake = currentInternalStake.add(_by);\r\n        } else {\r\n            require(\r\n                currentInternalStake >= _by,\r\n                \"Staking: Cannot decrease greater than current balance\");\r\n            newStake = currentInternalStake.sub(_by);\r\n        }\r\n\r\n        // add new value to account history\r\n        accounts[_accountAddress].stakedHistory.add(block.number.toUint64(), newStake);\r\n    }\r\n\r\n    /**\r\n     * @notice Increase or decrease the staked balance across all accounts\r\n     * @param _by - amount to modify\r\n     * @param _increase - true if increase in stake, false if decrease\r\n     */\r\n    function _modifyTotalStaked(uint256 _by, bool _increase) internal {\r\n        uint256 currentStake = totalStaked();\r\n\r\n        uint256 newStake;\r\n        if (_increase) {\r\n            newStake = currentStake.add(_by);\r\n        } else {\r\n            newStake = currentStake.sub(_by);\r\n        }\r\n\r\n        // add new value to total history\r\n        totalStakedHistory.add(block.number.toUint64(), newStake);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the governance address after confirming contract identity\r\n     * @param _governanceAddress - Incoming governance address\r\n     */\r\n    function _updateGovernanceAddress(address _governanceAddress) internal {\r\n        require(\r\n            Governance(_governanceAddress).isGovernanceAddress() == true,\r\n            \"Staking: _governanceAddress is not a valid governance contract\"\r\n        );\r\n        governanceAddress = _governanceAddress;\r\n    }\r\n\r\n    // ========================================= Private Functions =========================================\r\n\r\n    function _requireClaimsManagerAddressIsSet() private view {\r\n        require(claimsManagerAddress != address(0x00), \"Staking: claimsManagerAddress is not set\");\r\n    }\r\n\r\n    function _requireDelegateManagerAddressIsSet() private view {\r\n        require(\r\n            delegateManagerAddress != address(0x00),\r\n            \"Staking: delegateManagerAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireServiceProviderFactoryAddressIsSet() private view {\r\n        require(\r\n            serviceProviderFactoryAddress != address(0x00),\r\n            \"Staking: serviceProviderFactoryAddress is not set\"\r\n        );\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ServiceTypeManager is InitializableV2 {\r\n    address governanceAddress;\r\n\r\n    string private constant ERROR_ONLY_GOVERNANCE = (\r\n        \"ServiceTypeManager: Only callable by Governance contract\"\r\n    );\r\n\r\n    /**\r\n     * @dev - mapping of serviceType - serviceTypeVersion\r\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\r\n     */\r\n    mapping(bytes32 => bytes32[]) private serviceTypeVersions;\r\n\r\n    /**\r\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\r\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\r\n     */\r\n    mapping(bytes32 => mapping(bytes32 => bool)) private serviceTypeVersionInfo;\r\n\r\n    /// @dev List of valid service types\r\n    bytes32[] private validServiceTypes;\r\n\r\n    /// @dev Struct representing service type info\r\n    struct ServiceTypeInfo {\r\n        bool isValid;\r\n        uint256 minStake;\r\n        uint256 maxStake;\r\n    }\r\n\r\n    /// @dev mapping of service type info\r\n    mapping(bytes32 => ServiceTypeInfo) private serviceTypeInfo;\r\n\r\n    event SetServiceVersion(\r\n        bytes32 indexed _serviceType,\r\n        bytes32 indexed _serviceVersion\r\n    );\r\n\r\n    event ServiceTypeAdded(\r\n        bytes32 indexed _serviceType,\r\n        uint256 indexed _serviceTypeMin,\r\n        uint256 indexed _serviceTypeMax\r\n    );\r\n\r\n    event ServiceTypeRemoved(bytes32 indexed _serviceType);\r\n\r\n    /**\r\n     * @notice Function to initialize the contract\r\n     * @param _governanceAddress - Governance proxy address\r\n     */\r\n    function initialize(address _governanceAddress) public initializer\r\n    {\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    /// @notice Get the Governance address\r\n    function getGovernanceAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return governanceAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Governance address\r\n     * @dev Only callable by Governance address\r\n     * @param _governanceAddress - address for new Governance contract\r\n     */\r\n    function setGovernanceAddress(address _governanceAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        _updateGovernanceAddress(_governanceAddress);\r\n    }\r\n\r\n    // ========================================= Service Type Logic =========================================\r\n\r\n    /**\r\n     * @notice Add a new service type\r\n     * @param _serviceType - type of service to add\r\n     * @param _serviceTypeMin - minimum stake for service type\r\n     * @param _serviceTypeMax - maximum stake for service type\r\n     */\r\n    function addServiceType(\r\n        bytes32 _serviceType,\r\n        uint256 _serviceTypeMin,\r\n        uint256 _serviceTypeMax\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        require(\r\n            !this.serviceTypeIsValid(_serviceType),\r\n            \"ServiceTypeManager: Already known service type\"\r\n        );\r\n        require(\r\n            _serviceTypeMax > _serviceTypeMin,\r\n            \"ServiceTypeManager: Max stake must be non-zero and greater than min stake\"\r\n        );\r\n\r\n        // Ensure serviceType cannot be re-added if it previously existed and was removed\r\n        // stored maxStake > 0 means it was previously added and removed\r\n        require(\r\n            serviceTypeInfo[_serviceType].maxStake == 0,\r\n            \"ServiceTypeManager: Cannot re-add serviceType after it was removed.\"\r\n        );\r\n\r\n        validServiceTypes.push(_serviceType);\r\n        serviceTypeInfo[_serviceType] = ServiceTypeInfo({\r\n            isValid: true,\r\n            minStake: _serviceTypeMin,\r\n            maxStake: _serviceTypeMax\r\n        });\r\n\r\n        emit ServiceTypeAdded(_serviceType, _serviceTypeMin, _serviceTypeMax);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove an existing service type\r\n     * @param _serviceType - name of service type to remove\r\n     */\r\n    function removeServiceType(bytes32 _serviceType) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        uint256 serviceIndex = 0;\r\n        bool foundService = false;\r\n        for (uint256 i = 0; i < validServiceTypes.length; i ++) {\r\n            if (validServiceTypes[i] == _serviceType) {\r\n                serviceIndex = i;\r\n                foundService = true;\r\n                break;\r\n            }\r\n        }\r\n        require(foundService == true, \"ServiceTypeManager: Invalid service type, not found\");\r\n        // Overwrite service index\r\n        uint256 lastIndex = validServiceTypes.length - 1;\r\n        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\r\n        validServiceTypes.length--;\r\n\r\n        // Mark as invalid\r\n        serviceTypeInfo[_serviceType].isValid = false;\r\n        // Note - stake bounds are not reset so they can be checked to prevent serviceType from being re-added\r\n        emit ServiceTypeRemoved(_serviceType);\r\n    }\r\n\r\n    /**\r\n     * @notice Get isValid, min and max stake for a given service type\r\n     * @param _serviceType - type of service\r\n     * @return isValid, min and max stake for type\r\n     */\r\n    function getServiceTypeInfo(bytes32 _serviceType)\r\n    external view returns (bool isValid, uint256 minStake, uint256 maxStake)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return (\r\n            serviceTypeInfo[_serviceType].isValid,\r\n            serviceTypeInfo[_serviceType].minStake,\r\n            serviceTypeInfo[_serviceType].maxStake\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get list of valid service types\r\n     */\r\n    function getValidServiceTypes()\r\n    external view returns (bytes32[] memory)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return validServiceTypes;\r\n    }\r\n\r\n    /**\r\n     * @notice Return indicating whether this is a valid service type\r\n     */\r\n    function serviceTypeIsValid(bytes32 _serviceType)\r\n    external view returns (bool)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return serviceTypeInfo[_serviceType].isValid;\r\n    }\r\n\r\n    // ========================================= Service Version Logic =========================================\r\n\r\n    /**\r\n     * @notice Add new version for a serviceType\r\n     * @param _serviceType - type of service\r\n     * @param _serviceVersion - new version of service to add\r\n     */\r\n    function setServiceVersion(\r\n        bytes32 _serviceType,\r\n        bytes32 _serviceVersion\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        require(this.serviceTypeIsValid(_serviceType), \"ServiceTypeManager: Invalid service type\");\r\n        require(\r\n            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\r\n            \"ServiceTypeManager: Already registered\"\r\n        );\r\n\r\n         // Update array of known versions for type\r\n        serviceTypeVersions[_serviceType].push(_serviceVersion);\r\n\r\n        // Update status for this specific service version\r\n        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\r\n\r\n        emit SetServiceVersion(_serviceType, _serviceVersion);\r\n    }\r\n\r\n    /**\r\n     * @notice Get a version for a service type given it's index\r\n     * @param _serviceType - type of service\r\n     * @param _versionIndex - index in list of service versions\r\n     * @return bytes32 value for serviceVersion\r\n     */\r\n    function getVersion(bytes32 _serviceType, uint256 _versionIndex)\r\n    external view returns (bytes32)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            serviceTypeVersions[_serviceType].length > _versionIndex,\r\n            \"ServiceTypeManager: No registered version of serviceType\"\r\n        );\r\n        return (serviceTypeVersions[_serviceType][_versionIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Get curent version for a service type\r\n     * @param _serviceType - type of service\r\n     * @return Returns current version of service\r\n     */\r\n    function getCurrentVersion(bytes32 _serviceType)\r\n    external view returns (bytes32)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            serviceTypeVersions[_serviceType].length >= 1,\r\n            \"ServiceTypeManager: No registered version of serviceType\"\r\n        );\r\n        uint256 latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\r\n        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Get total number of versions for a service type\r\n     * @param _serviceType - type of service\r\n     */\r\n    function getNumberOfVersions(bytes32 _serviceType)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return serviceTypeVersions[_serviceType].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Return boolean indicating whether given version is valid for given type\r\n     * @param _serviceType - type of service\r\n     * @param _serviceVersion - version of service to check\r\n     */\r\n    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\r\n    external view returns (bool)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\r\n    }\r\n\r\n    /**\r\n     * @notice Set the governance address after confirming contract identity\r\n     * @param _governanceAddress - Incoming governance address\r\n     */\r\n    function _updateGovernanceAddress(address _governanceAddress) internal {\r\n        require(\r\n            Governance(_governanceAddress).isGovernanceAddress() == true,\r\n            \"ServiceTypeManager: _governanceAddress is not a valid governance contract\"\r\n        );\r\n        governanceAddress = _governanceAddress;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @notice ERC20 imported via Staking.sol\r\n/// @notice SafeERC20 imported via Staking.sol\r\n/// @notice Governance imported via Staking.sol\r\n/// @notice SafeMath imported via ServiceProviderFactory.sol\r\n\r\n\r\n/**\r\n * Designed to automate claim funding, minting tokens as necessary\r\n * @notice - will call InitializableV2 constructor\r\n */\r\ncontract ClaimsManager is InitializableV2 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_ONLY_GOVERNANCE = (\r\n        \"ClaimsManager: Only callable by Governance contract\"\r\n    );\r\n\r\n    address private governanceAddress;\r\n    address private stakingAddress;\r\n    address private serviceProviderFactoryAddress;\r\n    address private delegateManagerAddress;\r\n\r\n    /**\r\n      * @notice - Minimum number of blocks between funding rounds\r\n      *       604800 seconds / week\r\n      *       Avg block time - 13s\r\n      *       604800 / 13 = 46523.0769231 blocks\r\n      */\r\n    uint256 private fundingRoundBlockDiff;\r\n\r\n    /**\r\n      * @notice - Configures the current funding amount per round\r\n      *  Weekly rounds, 7% PA inflation = 70,000,000 new tokens in first year\r\n      *                                 = 70,000,000/365*7 (year is slightly more than a week)\r\n      *                                 = 1342465.75342 new AUDS per week\r\n      *                                 = 1342465753420000000000000 new wei units per week\r\n      * @dev - Past a certain block height, this schedule will be updated\r\n      *      - Logic determining schedule will be sourced from an external contract\r\n      */\r\n    uint256 private fundingAmount;\r\n\r\n    // Denotes current round\r\n    uint256 private roundNumber;\r\n\r\n    // Staking contract ref\r\n    ERC20Mintable private audiusToken;\r\n\r\n    /// @dev - Address to which recurringCommunityFundingAmount is transferred at funding round start\r\n    address private communityPoolAddress;\r\n\r\n    /// @dev - Reward amount transferred to communityPoolAddress at funding round start\r\n    uint256 private recurringCommunityFundingAmount;\r\n\r\n    // Struct representing round state\r\n    // 1) Block at which round was funded\r\n    // 2) Total funded for this round\r\n    // 3) Total claimed in round\r\n    struct Round {\r\n        uint256 fundedBlock;\r\n        uint256 fundedAmount;\r\n        uint256 totalClaimedInRound;\r\n    }\r\n\r\n    // Current round information\r\n    Round private currentRound;\r\n\r\n    event RoundInitiated(\r\n      uint256 indexed _blockNumber,\r\n      uint256 indexed _roundNumber,\r\n      uint256 indexed _fundAmount\r\n    );\r\n\r\n    event ClaimProcessed(\r\n      address indexed _claimer,\r\n      uint256 indexed _rewards,\r\n      uint256 _oldTotal,\r\n      uint256 indexed _newTotal\r\n    );\r\n\r\n    event CommunityRewardsTransferred(\r\n      address indexed _transferAddress,\r\n      uint256 indexed _amount\r\n    );\r\n\r\n    event FundingAmountUpdated(uint256 indexed _amount);\r\n    event FundingRoundBlockDiffUpdated(uint256 indexed _blockDifference);\r\n    event GovernanceAddressUpdated(address indexed _newGovernanceAddress);\r\n    event StakingAddressUpdated(address indexed _newStakingAddress);\r\n    event ServiceProviderFactoryAddressUpdated(address indexed _newServiceProviderFactoryAddress);\r\n    event DelegateManagerAddressUpdated(address indexed _newDelegateManagerAddress);\r\n    event RecurringCommunityFundingAmountUpdated(uint256 indexed _amount);\r\n    event CommunityPoolAddressUpdated(address indexed _newCommunityPoolAddress);\r\n\r\n    /**\r\n     * @notice Function to initialize the contract\r\n     * @dev stakingAddress must be initialized separately after Staking contract is deployed\r\n     * @dev serviceProviderFactoryAddress must be initialized separately after ServiceProviderFactory contract is deployed\r\n     * @dev delegateManagerAddress must be initialized separately after DelegateManager contract is deployed\r\n     * @param _tokenAddress - address of ERC20 token that will be claimed\r\n     * @param _governanceAddress - address for Governance proxy contract\r\n     */\r\n    function initialize(\r\n        address _tokenAddress,\r\n        address _governanceAddress\r\n    ) public initializer\r\n    {\r\n        _updateGovernanceAddress(_governanceAddress);\r\n\r\n        audiusToken = ERC20Mintable(_tokenAddress);\r\n\r\n        fundingRoundBlockDiff = 46523;\r\n        fundingAmount = 1342465753420000000000000; // 1342465.75342 AUDS\r\n        roundNumber = 0;\r\n\r\n        currentRound = Round({\r\n            fundedBlock: 0,\r\n            fundedAmount: 0,\r\n            totalClaimedInRound: 0\r\n        });\r\n\r\n        // Community pool funding amount and address initialized to zero\r\n        recurringCommunityFundingAmount = 0;\r\n        communityPoolAddress = address(0x0);\r\n\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    /// @notice Get the duration of a funding round in blocks\r\n    function getFundingRoundBlockDiff() external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return fundingRoundBlockDiff;\r\n    }\r\n\r\n    /// @notice Get the last block where a funding round was initiated\r\n    function getLastFundedBlock() external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return currentRound.fundedBlock;\r\n    }\r\n\r\n    /// @notice Get the amount funded per round in wei\r\n    function getFundsPerRound() external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return fundingAmount;\r\n    }\r\n\r\n    /// @notice Get the total amount claimed in the current round\r\n    function getTotalClaimedInRound() external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return currentRound.totalClaimedInRound;\r\n    }\r\n\r\n    /// @notice Get the Governance address\r\n    function getGovernanceAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return governanceAddress;\r\n    }\r\n\r\n    /// @notice Get the ServiceProviderFactory address\r\n    function getServiceProviderFactoryAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderFactoryAddress;\r\n    }\r\n\r\n    /// @notice Get the DelegateManager address\r\n    function getDelegateManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return delegateManagerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the Staking address\r\n     */\r\n    function getStakingAddress() external view returns (address)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return stakingAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the community pool address\r\n     */\r\n    function getCommunityPoolAddress() external view returns (address)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return communityPoolAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the community funding amount\r\n     */\r\n    function getRecurringCommunityFundingAmount() external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return recurringCommunityFundingAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Governance address\r\n     * @dev Only callable by Governance address\r\n     * @param _governanceAddress - address for new Governance contract\r\n     */\r\n    function setGovernanceAddress(address _governanceAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        emit GovernanceAddressUpdated(_governanceAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Staking address\r\n     * @dev Only callable by Governance address\r\n     * @param _stakingAddress - address for new Staking contract\r\n     */\r\n    function setStakingAddress(address _stakingAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        stakingAddress = _stakingAddress;\r\n        emit StakingAddressUpdated(_stakingAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ServiceProviderFactory address\r\n     * @dev Only callable by Governance address\r\n     * @param _serviceProviderFactoryAddress - address for new ServiceProviderFactory contract\r\n     */\r\n    function setServiceProviderFactoryAddress(address _serviceProviderFactoryAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        serviceProviderFactoryAddress = _serviceProviderFactoryAddress;\r\n        emit ServiceProviderFactoryAddressUpdated(_serviceProviderFactoryAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the DelegateManager address\r\n     * @dev Only callable by Governance address\r\n     * @param _delegateManagerAddress - address for new DelegateManager contract\r\n     */\r\n    function setDelegateManagerAddress(address _delegateManagerAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        delegateManagerAddress = _delegateManagerAddress;\r\n        emit DelegateManagerAddressUpdated(_delegateManagerAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Start a new funding round\r\n     * @dev Permissioned to be callable by stakers or governance contract\r\n     */\r\n    function initiateRound() external {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n\r\n        require(\r\n            block.number.sub(currentRound.fundedBlock) > fundingRoundBlockDiff,\r\n            \"ClaimsManager: Required block difference not met\"\r\n        );\r\n\r\n        currentRound = Round({\r\n            fundedBlock: block.number,\r\n            fundedAmount: fundingAmount,\r\n            totalClaimedInRound: 0\r\n        });\r\n\r\n        roundNumber = roundNumber.add(1);\r\n\r\n        /*\r\n         * Transfer community funding amount to community pool address, if set\r\n         */\r\n        if (recurringCommunityFundingAmount > 0 && communityPoolAddress != address(0x0)) {\r\n            // ERC20Mintable always returns true\r\n            audiusToken.mint(address(this), recurringCommunityFundingAmount);\r\n\r\n            // Approve transfer to community pool address\r\n            audiusToken.approve(communityPoolAddress, recurringCommunityFundingAmount);\r\n\r\n            // Transfer to community pool address\r\n            ERC20(address(audiusToken)).safeTransfer(communityPoolAddress, recurringCommunityFundingAmount);\r\n\r\n            emit CommunityRewardsTransferred(communityPoolAddress, recurringCommunityFundingAmount);\r\n        }\r\n\r\n        emit RoundInitiated(\r\n            currentRound.fundedBlock,\r\n            roundNumber,\r\n            currentRound.fundedAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Mints and stakes tokens on behalf of ServiceProvider + delegators\r\n     * @dev Callable through DelegateManager by Service Provider\r\n     * @param _claimer  - service provider address\r\n     * @param _totalLockedForSP - amount of tokens locked up across DelegateManager + ServiceProvider\r\n     * @return minted rewards for this claimer\r\n     */\r\n    function processClaim(\r\n        address _claimer,\r\n        uint256 _totalLockedForSP\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireDelegateManagerAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == delegateManagerAddress,\r\n            \"ClaimsManager: ProcessClaim only accessible to DelegateManager\"\r\n        );\r\n\r\n        Staking stakingContract = Staking(stakingAddress);\r\n        // Prevent duplicate claim\r\n        uint256 lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);\r\n        require(\r\n            lastUserClaimBlock <= currentRound.fundedBlock,\r\n            \"ClaimsManager: Claim already processed for user\"\r\n        );\r\n        uint256 totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt(\r\n            _claimer,\r\n            currentRound.fundedBlock);\r\n\r\n        (,,bool withinBounds,,,) = (\r\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer)\r\n        );\r\n\r\n        // Once they claim the zero reward amount, stake can be modified once again\r\n        // Subtract total locked amount for SP from stake at fund block\r\n        uint256 totalActiveClaimerStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);\r\n        uint256 totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundedBlock);\r\n\r\n        // Calculate claimer rewards\r\n        uint256 rewardsForClaimer = (\r\n          totalActiveClaimerStake.mul(fundingAmount)\r\n        ).div(totalStakedAtFundBlock);\r\n\r\n        // For a claimer violating bounds, no new tokens are minted\r\n        // Claim history is marked to zero and function is short-circuited\r\n        // Total rewards can be zero if all stake is currently locked up\r\n        if (!withinBounds || rewardsForClaimer == 0) {\r\n            stakingContract.updateClaimHistory(0, _claimer);\r\n            emit ClaimProcessed(\r\n                _claimer,\r\n                0,\r\n                totalStakedAtFundBlockForClaimer,\r\n                totalActiveClaimerStake\r\n            );\r\n            return 0;\r\n        }\r\n\r\n        // ERC20Mintable always returns true\r\n        audiusToken.mint(address(this), rewardsForClaimer);\r\n\r\n        // Approve transfer to staking address for claimer rewards\r\n        // ERC20 always returns true\r\n        audiusToken.approve(stakingAddress, rewardsForClaimer);\r\n\r\n        // Transfer rewards\r\n        stakingContract.stakeRewards(rewardsForClaimer, _claimer);\r\n\r\n        // Update round claim value\r\n        currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);\r\n\r\n        // Update round claim value\r\n        uint256 newTotal = stakingContract.totalStakedFor(_claimer);\r\n\r\n        emit ClaimProcessed(\r\n            _claimer,\r\n            rewardsForClaimer,\r\n            totalStakedAtFundBlockForClaimer,\r\n            newTotal\r\n        );\r\n\r\n        return rewardsForClaimer;\r\n    }\r\n\r\n    /**\r\n     * @notice Modify funding amount per round\r\n     * @param _newAmount - new amount to fund per round in wei\r\n     */\r\n    function updateFundingAmount(uint256 _newAmount) external\r\n    {\r\n        _requireIsInitialized();\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        fundingAmount = _newAmount;\r\n        emit FundingAmountUpdated(_newAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean indicating whether a claim is considered pending\r\n     * @dev Note that an address with no endpoints can never have a pending claim\r\n     * @param _sp - address of the service provider to check\r\n     * @return true if eligible for claim, false if not\r\n     */\r\n    function claimPending(address _sp) external view returns (bool) {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n\r\n        uint256 lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);\r\n        (,,,uint256 numEndpoints,,) = (\r\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp)\r\n        );\r\n        return (lastClaimedForSP < currentRound.fundedBlock && numEndpoints > 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Modify minimum block difference between funding rounds\r\n     * @param _newFundingRoundBlockDiff - new min block difference to set\r\n     */\r\n    function updateFundingRoundBlockDiff(uint256 _newFundingRoundBlockDiff) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        emit FundingRoundBlockDiffUpdated(_newFundingRoundBlockDiff);\r\n        fundingRoundBlockDiff = _newFundingRoundBlockDiff;\r\n    }\r\n\r\n    /**\r\n     * @notice Modify community funding amound for each round\r\n     * @param _newRecurringCommunityFundingAmount - new reward amount transferred to\r\n     *          communityPoolAddress at funding round start\r\n     */\r\n    function updateRecurringCommunityFundingAmount(\r\n        uint256 _newRecurringCommunityFundingAmount\r\n    ) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        recurringCommunityFundingAmount = _newRecurringCommunityFundingAmount;\r\n        emit RecurringCommunityFundingAmountUpdated(_newRecurringCommunityFundingAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Modify community pool address\r\n     * @param _newCommunityPoolAddress - new address to which recurringCommunityFundingAmount\r\n     *          is transferred at funding round start\r\n     */\r\n    function updateCommunityPoolAddress(address _newCommunityPoolAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        communityPoolAddress = _newCommunityPoolAddress;\r\n        emit CommunityPoolAddressUpdated(_newCommunityPoolAddress);\r\n    }\r\n\r\n    // ========================================= Private Functions =========================================\r\n\r\n    /**\r\n     * @notice Set the governance address after confirming contract identity\r\n     * @param _governanceAddress - Incoming governance address\r\n     */\r\n    function _updateGovernanceAddress(address _governanceAddress) private {\r\n        require(\r\n            Governance(_governanceAddress).isGovernanceAddress() == true,\r\n            \"ClaimsManager: _governanceAddress is not a valid governance contract\"\r\n        );\r\n        governanceAddress = _governanceAddress;\r\n    }\r\n\r\n    function _requireStakingAddressIsSet() private view {\r\n        require(stakingAddress != address(0x00), \"ClaimsManager: stakingAddress is not set\");\r\n    }\r\n\r\n    function _requireDelegateManagerAddressIsSet() private view {\r\n        require(\r\n            delegateManagerAddress != address(0x00),\r\n            \"ClaimsManager: delegateManagerAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireServiceProviderFactoryAddressIsSet() private view {\r\n        require(\r\n            serviceProviderFactoryAddress != address(0x00),\r\n            \"ClaimsManager: serviceProviderFactoryAddress is not set\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n/// @notice Governance imported via Staking.sol\r\n\r\n\r\ncontract ServiceProviderFactory is InitializableV2 {\r\n    using SafeMath for uint256;\r\n\r\n    /// @dev - denominator for deployer cut calculations\r\n    /// @dev - user values are intended to be x/DEPLOYER_CUT_BASE\r\n    uint256 private constant DEPLOYER_CUT_BASE = 100;\r\n\r\n    string private constant ERROR_ONLY_GOVERNANCE = (\r\n        \"ServiceProviderFactory: Only callable by Governance contract\"\r\n    );\r\n    string private constant ERROR_ONLY_SP_GOVERNANCE = (\r\n        \"ServiceProviderFactory: Only callable by Service Provider or Governance\"\r\n    );\r\n\r\n    address private stakingAddress;\r\n    address private delegateManagerAddress;\r\n    address private governanceAddress;\r\n    address private serviceTypeManagerAddress;\r\n    address private claimsManagerAddress;\r\n\r\n    /// @notice Period in blocks that a decrease stake operation is delayed.\r\n    ///         Must be greater than governance votingPeriod + executionDelay in order to\r\n    ///         prevent pre-emptive withdrawal in anticipation of a slash proposal\r\n    uint256 private decreaseStakeLockupDuration;\r\n\r\n    /// @notice Period in blocks that an update deployer cut operation is delayed.\r\n    ///         Must be greater than funding round block diff in order\r\n    ///         to prevent manipulation around a funding round\r\n    uint256 private deployerCutLockupDuration;\r\n\r\n    /// @dev - Stores following entities\r\n    ///        1) Directly staked amount by SP, not including delegators\r\n    ///        2) % Cut of delegator tokens taken during reward\r\n    ///        3) Bool indicating whether this SP has met min/max requirements\r\n    ///        4) Number of endpoints registered by SP\r\n    ///        5) Minimum deployer stake for this service provider\r\n    ///        6) Maximum total stake for this account\r\n    struct ServiceProviderDetails {\r\n        uint256 deployerStake;\r\n        uint256 deployerCut;\r\n        bool validBounds;\r\n        uint256 numberOfEndpoints;\r\n        uint256 minAccountStake;\r\n        uint256 maxAccountStake;\r\n    }\r\n\r\n    /// @dev - Data structure for time delay during withdrawal\r\n    struct DecreaseStakeRequest {\r\n        uint256 decreaseAmount;\r\n        uint256 lockupExpiryBlock;\r\n    }\r\n\r\n    /// @dev - Data structure for time delay during deployer cut update\r\n    struct UpdateDeployerCutRequest {\r\n        uint256 newDeployerCut;\r\n        uint256 lockupExpiryBlock;\r\n    }\r\n\r\n    /// @dev - Struct maintaining information about sp\r\n    /// @dev - blocknumber is block.number when endpoint registered\r\n    struct ServiceEndpoint {\r\n        address owner;\r\n        string endpoint;\r\n        uint256 blocknumber;\r\n        address delegateOwnerWallet;\r\n    }\r\n\r\n    /// @dev - Mapping of service provider address to details\r\n    mapping(address => ServiceProviderDetails) private spDetails;\r\n\r\n    /// @dev - Uniquely assigned serviceProvider ID, incremented for each service type\r\n    /// @notice - Keeps track of the total number of services registered regardless of\r\n    ///           whether some have been deregistered since\r\n    mapping(bytes32 => uint256) private serviceProviderTypeIDs;\r\n\r\n    /// @dev - mapping of (serviceType -> (serviceInstanceId <-> serviceProviderInfo))\r\n    /// @notice - stores the actual service provider data like endpoint and owner wallet\r\n    ///           with the ability lookup by service type and service id */\r\n    mapping(bytes32 => mapping(uint256 => ServiceEndpoint)) private serviceProviderInfo;\r\n\r\n    /// @dev - mapping of keccak256(endpoint) to uint256 ID\r\n    /// @notice - used to check if a endpoint has already been registered and also lookup\r\n    /// the id of an endpoint\r\n    mapping(bytes32 => uint256) private serviceProviderEndpointToId;\r\n\r\n    /// @dev - mapping of address -> sp id array */\r\n    /// @notice - stores all the services registered by a provider. for each address,\r\n    /// provides the ability to lookup by service type and see all registered services\r\n    mapping(address => mapping(bytes32 => uint256[])) private serviceProviderAddressToId;\r\n\r\n    /// @dev - Mapping of service provider -> decrease stake request\r\n    mapping(address => DecreaseStakeRequest) private decreaseStakeRequests;\r\n\r\n    /// @dev - Mapping of service provider -> update deployer cut requests\r\n    mapping(address => UpdateDeployerCutRequest) private updateDeployerCutRequests;\r\n\r\n    event RegisteredServiceProvider(\r\n      uint256 indexed _spID,\r\n      bytes32 indexed _serviceType,\r\n      address indexed _owner,\r\n      string _endpoint,\r\n      uint256 _stakeAmount\r\n    );\r\n\r\n    event DeregisteredServiceProvider(\r\n      uint256 indexed _spID,\r\n      bytes32 indexed _serviceType,\r\n      address indexed _owner,\r\n      string _endpoint,\r\n      uint256 _unstakeAmount\r\n    );\r\n\r\n    event IncreasedStake(\r\n      address indexed _owner,\r\n      uint256 indexed _increaseAmount,\r\n      uint256 indexed _newStakeAmount\r\n    );\r\n\r\n    event DecreaseStakeRequested(\r\n      address indexed _owner,\r\n      uint256 indexed _decreaseAmount,\r\n      uint256 indexed _lockupExpiryBlock\r\n    );\r\n\r\n    event DecreaseStakeRequestCancelled(\r\n      address indexed _owner,\r\n      uint256 indexed _decreaseAmount,\r\n      uint256 indexed _lockupExpiryBlock\r\n    );\r\n\r\n    event DecreaseStakeRequestEvaluated(\r\n      address indexed _owner,\r\n      uint256 indexed _decreaseAmount,\r\n      uint256 indexed _newStakeAmount\r\n    );\r\n\r\n    event EndpointUpdated(\r\n      bytes32 indexed _serviceType,\r\n      address indexed _owner,\r\n      string _oldEndpoint,\r\n      string _newEndpoint,\r\n      uint256 indexed _spID\r\n    );\r\n\r\n    event DelegateOwnerWalletUpdated(\r\n      address indexed _owner,\r\n      bytes32 indexed _serviceType,\r\n      uint256 indexed _spID,\r\n      address _updatedWallet\r\n    );\r\n\r\n    event DeployerCutUpdateRequested(\r\n      address indexed _owner,\r\n      uint256 indexed _updatedCut,\r\n      uint256 indexed _lockupExpiryBlock\r\n    );\r\n\r\n    event DeployerCutUpdateRequestCancelled(\r\n      address indexed _owner,\r\n      uint256 indexed _requestedCut,\r\n      uint256 indexed _finalCut\r\n    );\r\n\r\n    event DeployerCutUpdateRequestEvaluated(\r\n      address indexed _owner,\r\n      uint256 indexed _updatedCut\r\n    );\r\n\r\n    event DecreaseStakeLockupDurationUpdated(uint256 indexed _lockupDuration);\r\n    event UpdateDeployerCutLockupDurationUpdated(uint256 indexed _lockupDuration);\r\n    event GovernanceAddressUpdated(address indexed _newGovernanceAddress);\r\n    event StakingAddressUpdated(address indexed _newStakingAddress);\r\n    event ClaimsManagerAddressUpdated(address indexed _newClaimsManagerAddress);\r\n    event DelegateManagerAddressUpdated(address indexed _newDelegateManagerAddress);\r\n    event ServiceTypeManagerAddressUpdated(address indexed _newServiceTypeManagerAddress);\r\n\r\n    /**\r\n     * @notice Function to initialize the contract\r\n     * @dev stakingAddress must be initialized separately after Staking contract is deployed\r\n     * @dev delegateManagerAddress must be initialized separately after DelegateManager contract is deployed\r\n     * @dev serviceTypeManagerAddress must be initialized separately after ServiceTypeManager contract is deployed\r\n     * @dev claimsManagerAddress must be initialized separately after ClaimsManager contract is deployed\r\n     * @param _governanceAddress - Governance proxy address\r\n     */\r\n    function initialize (\r\n        address _governanceAddress,\r\n        address _claimsManagerAddress,\r\n        uint256 _decreaseStakeLockupDuration,\r\n        uint256 _deployerCutLockupDuration\r\n    ) public initializer\r\n    {\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        claimsManagerAddress = _claimsManagerAddress;\r\n        _updateDecreaseStakeLockupDuration(_decreaseStakeLockupDuration);\r\n        _updateDeployerCutLockupDuration(_deployerCutLockupDuration);\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    /**\r\n     * @notice Register a new endpoint to the account of msg.sender\r\n     * @dev Transfers stake from service provider into staking pool\r\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\r\n     * @param _endpoint - url of the service to register - url of the service to register\r\n     * @param _stakeAmount - amount to stake, must be within bounds in ServiceTypeManager\r\n     * @param _delegateOwnerWallet - wallet to delegate some permissions for some basic management properties\r\n     * @return New service provider ID for this endpoint\r\n     */\r\n    function register(\r\n        bytes32 _serviceType,\r\n        string calldata _endpoint,\r\n        uint256 _stakeAmount,\r\n        address _delegateOwnerWallet\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceTypeManagerAddressIsSet();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        require(\r\n            ServiceTypeManager(serviceTypeManagerAddress).serviceTypeIsValid(_serviceType),\r\n            \"ServiceProviderFactory: Valid service type required\");\r\n\r\n        // Stake token amount from msg.sender\r\n        if (_stakeAmount > 0) {\r\n            require(\r\n                !_claimPending(msg.sender),\r\n                \"ServiceProviderFactory: No pending claim expected\"\r\n            );\r\n            Staking(stakingAddress).stakeFor(msg.sender, _stakeAmount);\r\n        }\r\n\r\n        require (\r\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] == 0,\r\n            \"ServiceProviderFactory: Endpoint already registered\");\r\n\r\n        uint256 newServiceProviderID = serviceProviderTypeIDs[_serviceType].add(1);\r\n        serviceProviderTypeIDs[_serviceType] = newServiceProviderID;\r\n\r\n        // Index spInfo\r\n        serviceProviderInfo[_serviceType][newServiceProviderID] = ServiceEndpoint({\r\n            owner: msg.sender,\r\n            endpoint: _endpoint,\r\n            blocknumber: block.number,\r\n            delegateOwnerWallet: _delegateOwnerWallet\r\n        });\r\n\r\n        // Update endpoint mapping\r\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = newServiceProviderID;\r\n\r\n        // Update (address -> type -> ids[])\r\n        serviceProviderAddressToId[msg.sender][_serviceType].push(newServiceProviderID);\r\n\r\n        // Increment number of endpoints for this address\r\n        spDetails[msg.sender].numberOfEndpoints = spDetails[msg.sender].numberOfEndpoints.add(1);\r\n\r\n        // Update deployer total\r\n        spDetails[msg.sender].deployerStake = (\r\n            spDetails[msg.sender].deployerStake.add(_stakeAmount)\r\n        );\r\n\r\n        // Update min and max totals for this service provider\r\n        (, uint256 typeMin, uint256 typeMax) = ServiceTypeManager(\r\n            serviceTypeManagerAddress\r\n        ).getServiceTypeInfo(_serviceType);\r\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.add(typeMin);\r\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.add(typeMax);\r\n\r\n        // Confirm both aggregate account balance and directly staked amount are valid\r\n        this.validateAccountStakeBalance(msg.sender);\r\n        uint256 currentlyStakedForOwner = Staking(stakingAddress).totalStakedFor(msg.sender);\r\n\r\n\r\n        // Indicate this service provider is within bounds\r\n        spDetails[msg.sender].validBounds = true;\r\n\r\n        emit RegisteredServiceProvider(\r\n            newServiceProviderID,\r\n            _serviceType,\r\n            msg.sender,\r\n            _endpoint,\r\n            currentlyStakedForOwner\r\n        );\r\n\r\n        return newServiceProviderID;\r\n    }\r\n\r\n    /**\r\n     * @notice Deregister an endpoint from the account of msg.sender\r\n     * @dev Unstakes all tokens for service provider if this is the last endpoint\r\n     * @param _serviceType - type of service to deregister\r\n     * @param _endpoint - endpoint to deregister\r\n     * @return spId of the service that was deregistered\r\n     */\r\n    function deregister(\r\n        bytes32 _serviceType,\r\n        string calldata _endpoint\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceTypeManagerAddressIsSet();\r\n\r\n        // Unstake on deregistration if and only if this is the last service endpoint\r\n        uint256 unstakeAmount = 0;\r\n        bool unstaked = false;\r\n        // owned by the service provider\r\n        if (spDetails[msg.sender].numberOfEndpoints == 1) {\r\n            unstakeAmount = spDetails[msg.sender].deployerStake;\r\n\r\n            // Submit request to decrease stake, overriding any pending request\r\n            decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\r\n                decreaseAmount: unstakeAmount,\r\n                lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration)\r\n            });\r\n\r\n            unstaked = true;\r\n        }\r\n\r\n        require (\r\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] != 0,\r\n            \"ServiceProviderFactory: Endpoint not registered\");\r\n\r\n        // Cache invalided service provider ID\r\n        uint256 deregisteredID = serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\r\n\r\n        // Update endpoint mapping\r\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = 0;\r\n\r\n        require(\r\n            keccak256(bytes(serviceProviderInfo[_serviceType][deregisteredID].endpoint)) == keccak256(bytes(_endpoint)),\r\n            \"ServiceProviderFactory: Invalid endpoint for service type\");\r\n\r\n        require (\r\n            serviceProviderInfo[_serviceType][deregisteredID].owner == msg.sender,\r\n            \"ServiceProviderFactory: Only callable by endpoint owner\");\r\n\r\n        // Update info mapping\r\n        delete serviceProviderInfo[_serviceType][deregisteredID];\r\n        // Reset id, update array\r\n        uint256 spTypeLength = serviceProviderAddressToId[msg.sender][_serviceType].length;\r\n        for (uint256 i = 0; i < spTypeLength; i ++) {\r\n            if (serviceProviderAddressToId[msg.sender][_serviceType][i] == deregisteredID) {\r\n                // Overwrite element to be deleted with last element in array\r\n                serviceProviderAddressToId[msg.sender][_serviceType][i] = serviceProviderAddressToId[msg.sender][_serviceType][spTypeLength - 1];\r\n                // Reduce array size, exit loop\r\n                serviceProviderAddressToId[msg.sender][_serviceType].length--;\r\n                // Confirm this ID has been found for the service provider\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Decrement number of endpoints for this address\r\n        spDetails[msg.sender].numberOfEndpoints -= 1;\r\n\r\n        // Update min and max totals for this service provider\r\n        (, uint256 typeMin, uint256 typeMax) = ServiceTypeManager(\r\n            serviceTypeManagerAddress\r\n        ).getServiceTypeInfo(_serviceType);\r\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.sub(typeMin);\r\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.sub(typeMax);\r\n\r\n        emit DeregisteredServiceProvider(\r\n            deregisteredID,\r\n            _serviceType,\r\n            msg.sender,\r\n            _endpoint,\r\n            unstakeAmount);\r\n\r\n        // Confirm both aggregate account balance and directly staked amount are valid\r\n        // Only if unstake operation has not occurred\r\n        if (!unstaked) {\r\n            this.validateAccountStakeBalance(msg.sender);\r\n            // Indicate this service provider is within bounds\r\n            spDetails[msg.sender].validBounds = true;\r\n        }\r\n\r\n        return deregisteredID;\r\n    }\r\n\r\n    /**\r\n     * @notice Increase stake for service provider\r\n     * @param _increaseStakeAmount - amount to increase staked amount by\r\n     * @return New total stake for service provider\r\n     */\r\n    function increaseStake(\r\n        uint256 _increaseStakeAmount\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        // Confirm owner has an endpoint\r\n        require(\r\n            spDetails[msg.sender].numberOfEndpoints > 0,\r\n            \"ServiceProviderFactory: Registered endpoint required to increase stake\"\r\n        );\r\n        require(\r\n            !_claimPending(msg.sender),\r\n            \"ServiceProviderFactory: No claim expected to be pending prior to stake transfer\"\r\n        );\r\n\r\n        Staking stakingContract = Staking(\r\n            stakingAddress\r\n        );\r\n\r\n        // Stake increased token amount for msg.sender\r\n        stakingContract.stakeFor(msg.sender, _increaseStakeAmount);\r\n\r\n        uint256 newStakeAmount = stakingContract.totalStakedFor(msg.sender);\r\n\r\n        // Update deployer total\r\n        spDetails[msg.sender].deployerStake = (\r\n            spDetails[msg.sender].deployerStake.add(_increaseStakeAmount)\r\n        );\r\n\r\n        // Confirm both aggregate account balance and directly staked amount are valid\r\n        this.validateAccountStakeBalance(msg.sender);\r\n\r\n        // Indicate this service provider is within bounds\r\n        spDetails[msg.sender].validBounds = true;\r\n\r\n        emit IncreasedStake(\r\n            msg.sender,\r\n            _increaseStakeAmount,\r\n            newStakeAmount\r\n        );\r\n\r\n        return newStakeAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Request to decrease stake. This sets a lockup for decreaseStakeLockupDuration after\r\n               which the actual decreaseStake can be called\r\n     * @dev Decreasing stake is only processed if a service provider is within valid bounds\r\n     * @param _decreaseStakeAmount - amount to decrease stake by in wei\r\n     * @return New total stake amount after the lockup\r\n     */\r\n    function requestDecreaseStake(uint256 _decreaseStakeAmount)\r\n    external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        require(\r\n            _decreaseStakeAmount > 0,\r\n            \"ServiceProviderFactory: Requested stake decrease amount must be greater than zero\"\r\n        );\r\n        require(\r\n            !_claimPending(msg.sender),\r\n            \"ServiceProviderFactory: No claim expected to be pending prior to stake transfer\"\r\n        );\r\n\r\n        Staking stakingContract = Staking(\r\n            stakingAddress\r\n        );\r\n\r\n        uint256 currentStakeAmount = stakingContract.totalStakedFor(msg.sender);\r\n\r\n        // Prohibit decreasing stake to invalid bounds\r\n        _validateBalanceInternal(msg.sender, (currentStakeAmount.sub(_decreaseStakeAmount)));\r\n\r\n        uint256 expiryBlock = block.number.add(decreaseStakeLockupDuration);\r\n        decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\r\n            decreaseAmount: _decreaseStakeAmount,\r\n            lockupExpiryBlock: expiryBlock\r\n        });\r\n\r\n        emit DecreaseStakeRequested(msg.sender, _decreaseStakeAmount, expiryBlock);\r\n        return currentStakeAmount.sub(_decreaseStakeAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel a decrease stake request during the lockup\r\n     * @dev Either called by the service provider via DelegateManager or governance\r\n            during a slash action\r\n     * @param _account - address of service provider\r\n     */\r\n    function cancelDecreaseStakeRequest(address _account) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requireDelegateManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == _account || msg.sender == delegateManagerAddress,\r\n            \"ServiceProviderFactory: Only owner or DelegateManager\"\r\n        );\r\n        require(\r\n            _decreaseRequestIsPending(_account),\r\n            \"ServiceProviderFactory: Decrease stake request must be pending\"\r\n        );\r\n\r\n        DecreaseStakeRequest memory cancelledRequest = decreaseStakeRequests[_account];\r\n\r\n        // Clear decrease stake request\r\n        decreaseStakeRequests[_account] = DecreaseStakeRequest({\r\n            decreaseAmount: 0,\r\n            lockupExpiryBlock: 0\r\n        });\r\n\r\n        emit DecreaseStakeRequestCancelled(\r\n            _account,\r\n            cancelledRequest.decreaseAmount,\r\n            cancelledRequest.lockupExpiryBlock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Called by user to decrease a stake after waiting the appropriate lockup period.\r\n     * @return New total stake after decrease\r\n     */\r\n    function decreaseStake() external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n\r\n        require(\r\n            _decreaseRequestIsPending(msg.sender),\r\n            \"ServiceProviderFactory: Decrease stake request must be pending\"\r\n        );\r\n        require(\r\n            decreaseStakeRequests[msg.sender].lockupExpiryBlock <= block.number,\r\n            \"ServiceProviderFactory: Lockup must be expired\"\r\n        );\r\n\r\n        Staking stakingContract = Staking(\r\n            stakingAddress\r\n        );\r\n\r\n        uint256 decreaseAmount = decreaseStakeRequests[msg.sender].decreaseAmount;\r\n        // Decrease staked token amount for msg.sender\r\n        stakingContract.unstakeFor(msg.sender, decreaseAmount);\r\n\r\n        // Query current stake\r\n        uint256 newStakeAmount = stakingContract.totalStakedFor(msg.sender);\r\n\r\n        // Update deployer total\r\n        spDetails[msg.sender].deployerStake = (\r\n            spDetails[msg.sender].deployerStake.sub(decreaseAmount)\r\n        );\r\n\r\n        // Confirm both aggregate account balance and directly staked amount are valid\r\n        // During registration this validation is bypassed since no endpoints remain\r\n        if (spDetails[msg.sender].numberOfEndpoints > 0) {\r\n            this.validateAccountStakeBalance(msg.sender);\r\n        }\r\n\r\n        // Indicate this service provider is within bounds\r\n        spDetails[msg.sender].validBounds = true;\r\n\r\n        // Clear decrease stake request\r\n        delete decreaseStakeRequests[msg.sender];\r\n\r\n        emit DecreaseStakeRequestEvaluated(msg.sender, decreaseAmount, newStakeAmount);\r\n        return newStakeAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Update delegate owner wallet for a given endpoint\r\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\r\n     * @param _endpoint - url of the service to register - url of the service to register\r\n     * @param _updatedDelegateOwnerWallet - address of new delegate wallet\r\n     */\r\n    function updateDelegateOwnerWallet(\r\n        bytes32 _serviceType,\r\n        string calldata _endpoint,\r\n        address _updatedDelegateOwnerWallet\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        uint256 spID = this.getServiceProviderIdFromEndpoint(_endpoint);\r\n\r\n        require(\r\n            serviceProviderInfo[_serviceType][spID].owner == msg.sender,\r\n            \"ServiceProviderFactory: Invalid update operation, wrong owner\"\r\n        );\r\n\r\n        serviceProviderInfo[_serviceType][spID].delegateOwnerWallet = _updatedDelegateOwnerWallet;\r\n        emit DelegateOwnerWalletUpdated(\r\n            msg.sender,\r\n            _serviceType,\r\n            spID,\r\n            _updatedDelegateOwnerWallet\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update the endpoint for a given service\r\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\r\n     * @param _oldEndpoint - old endpoint currently registered\r\n     * @param _newEndpoint - new endpoint to replace old endpoint\r\n     * @return ID of updated service provider\r\n     */\r\n    function updateEndpoint(\r\n        bytes32 _serviceType,\r\n        string calldata _oldEndpoint,\r\n        string calldata _newEndpoint\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        uint256 spId = this.getServiceProviderIdFromEndpoint(_oldEndpoint);\r\n        require (\r\n            spId != 0,\r\n            \"ServiceProviderFactory: Could not find service provider with that endpoint\"\r\n        );\r\n\r\n        ServiceEndpoint memory serviceEndpoint = serviceProviderInfo[_serviceType][spId];\r\n\r\n        require(\r\n            serviceEndpoint.owner == msg.sender,\r\n            \"ServiceProviderFactory: Invalid update endpoint operation, wrong owner\"\r\n        );\r\n        require(\r\n            keccak256(bytes(serviceEndpoint.endpoint)) == keccak256(bytes(_oldEndpoint)),\r\n            \"ServiceProviderFactory: Old endpoint doesn't match what's registered for the service provider\"\r\n        );\r\n\r\n        // invalidate old endpoint\r\n        serviceProviderEndpointToId[keccak256(bytes(serviceEndpoint.endpoint))] = 0;\r\n\r\n        // update to new endpoint\r\n        serviceEndpoint.endpoint = _newEndpoint;\r\n        serviceProviderInfo[_serviceType][spId] = serviceEndpoint;\r\n        serviceProviderEndpointToId[keccak256(bytes(_newEndpoint))] = spId;\r\n\r\n        emit EndpointUpdated(_serviceType, msg.sender, _oldEndpoint, _newEndpoint, spId);\r\n        return spId;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the deployer cut for a given service provider\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _cut - new value for deployer cut\r\n     */\r\n    function requestUpdateDeployerCut(address _serviceProvider, uint256 _cut) external\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            msg.sender == _serviceProvider || msg.sender == governanceAddress,\r\n            ERROR_ONLY_SP_GOVERNANCE\r\n        );\r\n\r\n        require(\r\n            (updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock == 0) &&\r\n            (updateDeployerCutRequests[_serviceProvider].newDeployerCut == 0),\r\n            \"ServiceProviderFactory: Update deployer cut operation pending\"\r\n        );\r\n\r\n        require(\r\n            _cut <= DEPLOYER_CUT_BASE,\r\n            \"ServiceProviderFactory: Service Provider cut cannot exceed base value\"\r\n        );\r\n\r\n        uint256 expiryBlock = block.number + deployerCutLockupDuration;\r\n        updateDeployerCutRequests[_serviceProvider] = UpdateDeployerCutRequest({\r\n            lockupExpiryBlock: expiryBlock,\r\n            newDeployerCut: _cut\r\n        });\r\n\r\n        emit DeployerCutUpdateRequested(_serviceProvider, _cut, expiryBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel a pending request to update deployer cut\r\n     * @param _serviceProvider - address of service provider\r\n     */\r\n    function cancelUpdateDeployerCut(address _serviceProvider) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requirePendingDeployerCutOperation(_serviceProvider);\r\n\r\n        require(\r\n            msg.sender == _serviceProvider || msg.sender == governanceAddress,\r\n            ERROR_ONLY_SP_GOVERNANCE\r\n        );\r\n\r\n        UpdateDeployerCutRequest memory cancelledRequest = (\r\n            updateDeployerCutRequests[_serviceProvider]\r\n        );\r\n\r\n        // Zero out request information\r\n        delete updateDeployerCutRequests[_serviceProvider];\r\n        emit DeployerCutUpdateRequestCancelled(\r\n            _serviceProvider,\r\n            cancelledRequest.newDeployerCut,\r\n            spDetails[_serviceProvider].deployerCut\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Evalue request to update service provider cut of claims\r\n     * @notice Update service provider cut as % of delegate claim, divided by the deployerCutBase.\r\n     * @dev SPs will interact with this value as a percent, value translation done client side\r\n       @dev A value of 5 dictates a 5% cut, with ( 5 / 100 ) * delegateReward going to an SP from each delegator each round.\r\n     */\r\n    function updateDeployerCut(address _serviceProvider) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requirePendingDeployerCutOperation(_serviceProvider);\r\n\r\n        require(\r\n            msg.sender == _serviceProvider || msg.sender == governanceAddress,\r\n            ERROR_ONLY_SP_GOVERNANCE\r\n        );\r\n\r\n        require(\r\n            updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock <= block.number,\r\n            \"ServiceProviderFactory: Lockup must be expired\"\r\n        );\r\n\r\n        spDetails[_serviceProvider].deployerCut = (\r\n            updateDeployerCutRequests[_serviceProvider].newDeployerCut\r\n        );\r\n\r\n        // Zero out request information\r\n        delete updateDeployerCutRequests[_serviceProvider];\r\n\r\n        emit DeployerCutUpdateRequestEvaluated(\r\n            _serviceProvider,\r\n            spDetails[_serviceProvider].deployerCut\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update service provider balance\r\n     * @dev Called by DelegateManager by functions modifying entire stake like claim and slash\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _amount - new amount of direct state for service provider\r\n     */\r\n    function updateServiceProviderStake(\r\n        address _serviceProvider,\r\n        uint256 _amount\r\n     ) external\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireDelegateManagerAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == delegateManagerAddress,\r\n            \"ServiceProviderFactory: only callable by DelegateManager\"\r\n        );\r\n        // Update SP tracked total\r\n        spDetails[_serviceProvider].deployerStake = _amount;\r\n        _updateServiceProviderBoundStatus(_serviceProvider);\r\n    }\r\n\r\n    /// @notice Update service provider lockup duration\r\n    function updateDecreaseStakeLockupDuration(uint256 _duration) external {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            msg.sender == governanceAddress,\r\n            ERROR_ONLY_GOVERNANCE\r\n        );\r\n\r\n        _updateDecreaseStakeLockupDuration(_duration);\r\n        emit DecreaseStakeLockupDurationUpdated(_duration);\r\n    }\r\n\r\n    /// @notice Update service provider lockup duration\r\n    function updateDeployerCutLockupDuration(uint256 _duration) external {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            msg.sender == governanceAddress,\r\n            ERROR_ONLY_GOVERNANCE\r\n        );\r\n\r\n        _updateDeployerCutLockupDuration(_duration);\r\n        emit UpdateDeployerCutLockupDurationUpdated(_duration);\r\n    }\r\n\r\n    /// @notice Get denominator for deployer cut calculations\r\n    function getServiceProviderDeployerCutBase()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return DEPLOYER_CUT_BASE;\r\n    }\r\n\r\n    /// @notice Get current deployer cut update lockup duration\r\n    function getDeployerCutLockupDuration()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return deployerCutLockupDuration;\r\n    }\r\n\r\n    /// @notice Get total number of service providers for a given serviceType\r\n    function getTotalServiceTypeProviders(bytes32 _serviceType)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderTypeIDs[_serviceType];\r\n    }\r\n\r\n    /// @notice Get service provider id for an endpoint\r\n    function getServiceProviderIdFromEndpoint(string calldata _endpoint)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\r\n    }\r\n\r\n    /**\r\n     * @notice Get service provider ids for a given service provider and service type\r\n     * @return List of service ids of that type for a service provider\r\n     */\r\n    function getServiceProviderIdsFromAddress(address _ownerAddress, bytes32 _serviceType)\r\n    external view returns (uint256[] memory)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderAddressToId[_ownerAddress][_serviceType];\r\n    }\r\n\r\n    /**\r\n     * @notice Get information about a service endpoint given its service id\r\n     * @param _serviceType - type of service, must be a valid service from ServiceTypeManager\r\n     * @param _serviceId - id of service\r\n     */\r\n    function getServiceEndpointInfo(bytes32 _serviceType, uint256 _serviceId)\r\n    external view returns (address owner, string memory endpoint, uint256 blockNumber, address delegateOwnerWallet)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        ServiceEndpoint memory serviceEndpoint = serviceProviderInfo[_serviceType][_serviceId];\r\n        return (\r\n            serviceEndpoint.owner,\r\n            serviceEndpoint.endpoint,\r\n            serviceEndpoint.blocknumber,\r\n            serviceEndpoint.delegateOwnerWallet\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get information about a service provider given their address\r\n     * @param _serviceProvider - address of service provider\r\n     */\r\n    function getServiceProviderDetails(address _serviceProvider)\r\n    external view returns (\r\n        uint256 deployerStake,\r\n        uint256 deployerCut,\r\n        bool validBounds,\r\n        uint256 numberOfEndpoints,\r\n        uint256 minAccountStake,\r\n        uint256 maxAccountStake)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return (\r\n            spDetails[_serviceProvider].deployerStake,\r\n            spDetails[_serviceProvider].deployerCut,\r\n            spDetails[_serviceProvider].validBounds,\r\n            spDetails[_serviceProvider].numberOfEndpoints,\r\n            spDetails[_serviceProvider].minAccountStake,\r\n            spDetails[_serviceProvider].maxAccountStake\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get information about pending decrease stake requests for service provider\r\n     * @param _serviceProvider - address of service provider\r\n     */\r\n    function getPendingDecreaseStakeRequest(address _serviceProvider)\r\n    external view returns (uint256 amount, uint256 lockupExpiryBlock)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return (\r\n            decreaseStakeRequests[_serviceProvider].decreaseAmount,\r\n            decreaseStakeRequests[_serviceProvider].lockupExpiryBlock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get information about pending decrease stake requests for service provider\r\n     * @param _serviceProvider - address of service provider\r\n     */\r\n    function getPendingUpdateDeployerCutRequest(address _serviceProvider)\r\n    external view returns (uint256 newDeployerCut, uint256 lockupExpiryBlock)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return (\r\n            updateDeployerCutRequests[_serviceProvider].newDeployerCut,\r\n            updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock\r\n        );\r\n    }\r\n\r\n    /// @notice Get current unstake lockup duration\r\n    function getDecreaseStakeLockupDuration()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return decreaseStakeLockupDuration;\r\n    }\r\n\r\n    /**\r\n     * @notice Validate that the total service provider balance is between the min and max stakes\r\n               for all their registered services and validate  direct stake for sp is above minimum\r\n     * @param _serviceProvider - address of service provider\r\n     */\r\n    function validateAccountStakeBalance(address _serviceProvider)\r\n    external view\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n\r\n        _validateBalanceInternal(\r\n            _serviceProvider,\r\n            Staking(stakingAddress).totalStakedFor(_serviceProvider)\r\n        );\r\n    }\r\n\r\n    /// @notice Get the Governance address\r\n    function getGovernanceAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return governanceAddress;\r\n    }\r\n\r\n    /// @notice Get the Staking address\r\n    function getStakingAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return stakingAddress;\r\n    }\r\n\r\n    /// @notice Get the DelegateManager address\r\n    function getDelegateManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return delegateManagerAddress;\r\n    }\r\n\r\n    /// @notice Get the ServiceTypeManager address\r\n    function getServiceTypeManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return serviceTypeManagerAddress;\r\n    }\r\n\r\n    /// @notice Get the ClaimsManager address\r\n    function getClaimsManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return claimsManagerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Governance address\r\n     * @dev Only callable by Governance address\r\n     * @param _governanceAddress - address for new Governance contract\r\n     */\r\n    function setGovernanceAddress(address _governanceAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        emit GovernanceAddressUpdated(_governanceAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Staking address\r\n     * @dev Only callable by Governance address\r\n     * @param _address - address for new Staking contract\r\n     */\r\n    function setStakingAddress(address _address) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        stakingAddress = _address;\r\n        emit StakingAddressUpdated(_address);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the DelegateManager address\r\n     * @dev Only callable by Governance address\r\n     * @param _address - address for new DelegateManager contract\r\n     */\r\n    function setDelegateManagerAddress(address _address) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        delegateManagerAddress = _address;\r\n        emit DelegateManagerAddressUpdated(_address);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ServiceTypeManager address\r\n     * @dev Only callable by Governance address\r\n     * @param _address - address for new ServiceTypeManager contract\r\n     */\r\n    function setServiceTypeManagerAddress(address _address) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        serviceTypeManagerAddress = _address;\r\n        emit ServiceTypeManagerAddressUpdated(_address);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ClaimsManager address\r\n     * @dev Only callable by Governance address\r\n     * @param _address - address for new ClaimsManager contract\r\n     */\r\n    function setClaimsManagerAddress(address _address) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        claimsManagerAddress = _address;\r\n        emit ClaimsManagerAddressUpdated(_address);\r\n    }\r\n\r\n    // ========================================= Internal Functions =========================================\r\n\r\n    /**\r\n     * @notice Update status in spDetails if the bounds for a service provider is valid\r\n     */\r\n    function _updateServiceProviderBoundStatus(address _serviceProvider) internal {\r\n        // Validate bounds for total stake\r\n        uint256 totalSPStake = Staking(stakingAddress).totalStakedFor(_serviceProvider);\r\n        if (totalSPStake < spDetails[_serviceProvider].minAccountStake ||\r\n            totalSPStake > spDetails[_serviceProvider].maxAccountStake) {\r\n            // Indicate this service provider is out of bounds\r\n            spDetails[_serviceProvider].validBounds = false;\r\n        } else {\r\n            // Indicate this service provider is within bounds\r\n            spDetails[_serviceProvider].validBounds = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set the governance address after confirming contract identity\r\n     * @param _governanceAddress - Incoming governance address\r\n     */\r\n    function _updateGovernanceAddress(address _governanceAddress) internal {\r\n        require(\r\n            Governance(_governanceAddress).isGovernanceAddress() == true,\r\n            \"ServiceProviderFactory: _governanceAddress is not a valid governance contract\"\r\n        );\r\n        governanceAddress = _governanceAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the deployer cut lockup duration\r\n     * @param _duration - incoming duration\r\n     */\r\n    function _updateDeployerCutLockupDuration(uint256 _duration) internal\r\n    {\r\n        require(\r\n            ClaimsManager(claimsManagerAddress).getFundingRoundBlockDiff() < _duration,\r\n            \"ServiceProviderFactory: Incoming duration must be greater than funding round block diff\"\r\n        );\r\n        deployerCutLockupDuration = _duration;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the decrease stake lockup duration\r\n     * @param _duration - incoming duration\r\n     */\r\n    function _updateDecreaseStakeLockupDuration(uint256 _duration) internal\r\n    {\r\n        Governance governance = Governance(governanceAddress);\r\n        require(\r\n            _duration > governance.getVotingPeriod() + governance.getExecutionDelay(),\r\n            \"ServiceProviderFactory: decreaseStakeLockupDuration duration must be greater than governance votingPeriod + executionDelay\"\r\n        );\r\n        decreaseStakeLockupDuration = _duration;\r\n    }\r\n\r\n    /**\r\n     * @notice Compare a given amount input against valid min and max bounds for service provider\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _amount - amount in wei to compare\r\n     */\r\n    function _validateBalanceInternal(address _serviceProvider, uint256 _amount) internal view\r\n    {\r\n        require(\r\n            _amount <= spDetails[_serviceProvider].maxAccountStake,\r\n            \"ServiceProviderFactory: Maximum stake amount exceeded\"\r\n        );\r\n        require(\r\n            spDetails[_serviceProvider].deployerStake >= spDetails[_serviceProvider].minAccountStake,\r\n            \"ServiceProviderFactory: Minimum stake requirement not met\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get whether a decrease request has been initiated for service provider\r\n     * @param _serviceProvider - address of service provider\r\n     * return Boolean of whether decrease request has been initiated\r\n     */\r\n    function _decreaseRequestIsPending(address _serviceProvider)\r\n    internal view returns (bool)\r\n    {\r\n        return (\r\n            (decreaseStakeRequests[_serviceProvider].lockupExpiryBlock > 0) &&\r\n            (decreaseStakeRequests[_serviceProvider].decreaseAmount > 0)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Boolean indicating whether a claim is pending for this service provider\r\n     */\r\n     /**\r\n     * @notice Get whether a claim is pending for this service provider\r\n     * @param _serviceProvider - address of service provider\r\n     * return Boolean of whether claim is pending\r\n     */\r\n    function _claimPending(address _serviceProvider) internal view returns (bool) {\r\n        return ClaimsManager(claimsManagerAddress).claimPending(_serviceProvider);\r\n    }\r\n\r\n    // ========================================= Private Functions =========================================\r\n    function _requirePendingDeployerCutOperation (address _serviceProvider) private view {\r\n        require(\r\n            (updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock != 0),\r\n            \"ServiceProviderFactory: No update deployer cut operation pending\"\r\n        );\r\n    }\r\n\r\n    function _requireStakingAddressIsSet() private view {\r\n        require(\r\n            stakingAddress != address(0x00),\r\n            \"ServiceProviderFactory: stakingAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireDelegateManagerAddressIsSet() private view {\r\n        require(\r\n            delegateManagerAddress != address(0x00),\r\n            \"ServiceProviderFactory: delegateManagerAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireServiceTypeManagerAddressIsSet() private view {\r\n        require(\r\n            serviceTypeManagerAddress != address(0x00),\r\n            \"ServiceProviderFactory: serviceTypeManagerAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireClaimsManagerAddressIsSet() private view {\r\n        require(\r\n            claimsManagerAddress != address(0x00),\r\n            \"ServiceProviderFactory: claimsManagerAddress is not set\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/// @notice SafeMath imported via ServiceProviderFactory.sol\r\n/// @notice Governance imported via Staking.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Designed to manage delegation to staking contract\r\n */\r\ncontract DelegateManager is InitializableV2 {\r\n    using SafeMath for uint256;\r\n\r\n    string private constant ERROR_ONLY_GOVERNANCE = (\r\n        \"DelegateManager: Only callable by Governance contract\"\r\n    );\r\n    string private constant ERROR_MINIMUM_DELEGATION = (\r\n        \"DelegateManager: Minimum delegation amount required\"\r\n    );\r\n    string private constant ERROR_ONLY_SP_GOVERNANCE = (\r\n        \"DelegateManager: Only callable by target SP or governance\"\r\n    );\r\n    string private constant ERROR_DELEGATOR_STAKE = (\r\n        \"DelegateManager: Delegator must be staked for SP\"\r\n    );\r\n\r\n    address private governanceAddress;\r\n    address private stakingAddress;\r\n    address private serviceProviderFactoryAddress;\r\n    address private claimsManagerAddress;\r\n\r\n    /**\r\n     * Period in  blocks an undelegate operation is delayed.\r\n     * The undelegate operation speed bump is to prevent a delegator from\r\n     *      attempting to remove their delegation in anticipation of a slash.\r\n     * @notice Must be greater than governance votingPeriod + executionDelay\r\n     */\r\n    uint256 private undelegateLockupDuration;\r\n\r\n    /// @notice Maximum number of delegators a single account can handle\r\n    uint256 private maxDelegators;\r\n\r\n    /// @notice Minimum amount of delegation allowed\r\n    uint256 private minDelegationAmount;\r\n\r\n    /**\r\n     * Lockup duration for a remove delegator request.\r\n     * The remove delegator speed bump is to prevent a service provider from maliciously\r\n     *     removing a delegator prior to the evaluation of a proposal.\r\n     * @notice Must be greater than governance votingPeriod + executionDelay\r\n     */\r\n    uint256 private removeDelegatorLockupDuration;\r\n\r\n    /**\r\n     * Evaluation period for a remove delegator request\r\n     * @notice added to expiry block calculated for removeDelegatorLockupDuration\r\n     */\r\n    uint256 private removeDelegatorEvalDuration;\r\n\r\n    // Staking contract ref\r\n    ERC20Mintable private audiusToken;\r\n\r\n    // Struct representing total delegated to SP and list of delegators\r\n    struct ServiceProviderDelegateInfo {\r\n        uint256 totalDelegatedStake;\r\n        uint256 totalLockedUpStake;\r\n        address[] delegators;\r\n    }\r\n\r\n    // Data structures for lockup during withdrawal\r\n    struct UndelegateStakeRequest {\r\n        address serviceProvider;\r\n        uint256 amount;\r\n        uint256 lockupExpiryBlock;\r\n    }\r\n\r\n    // Service provider address -> ServiceProviderDelegateInfo\r\n    mapping (address => ServiceProviderDelegateInfo) private spDelegateInfo;\r\n\r\n    // Delegator stake by address delegated to\r\n    // delegator -> (service provider -> delegatedStake)\r\n    mapping (address => mapping(address => uint256)) private delegateInfo;\r\n\r\n    // Delegator stake total by address\r\n    // delegator -> (totalDelegated)\r\n    // Note - delegator properties are maintained in a mapping instead of struct\r\n    // in order to facilitate extensibility in the future.\r\n    mapping (address => uint256) private delegatorTotalStake;\r\n\r\n    // Requester to pending undelegate request\r\n    mapping (address => UndelegateStakeRequest) private undelegateRequests;\r\n\r\n    // Pending remove delegator requests\r\n    // service provider -> (delegator -> lockupExpiryBlock)\r\n    mapping (address => mapping (address => uint256)) private removeDelegatorRequests;\r\n\r\n    event IncreaseDelegatedStake(\r\n        address indexed _delegator,\r\n        address indexed _serviceProvider,\r\n        uint256 indexed _increaseAmount\r\n    );\r\n\r\n    event UndelegateStakeRequested(\r\n        address indexed _delegator,\r\n        address indexed _serviceProvider,\r\n        uint256 indexed _amount,\r\n        uint256 _lockupExpiryBlock\r\n    );\r\n\r\n    event UndelegateStakeRequestCancelled(\r\n        address indexed _delegator,\r\n        address indexed _serviceProvider,\r\n        uint256 indexed _amount\r\n    );\r\n\r\n    event UndelegateStakeRequestEvaluated(\r\n        address indexed _delegator,\r\n        address indexed _serviceProvider,\r\n        uint256 indexed _amount\r\n    );\r\n\r\n    event Claim(\r\n        address indexed _claimer,\r\n        uint256 indexed _rewards,\r\n        uint256 indexed _newTotal\r\n    );\r\n\r\n    event Slash(\r\n        address indexed _target,\r\n        uint256 indexed _amount,\r\n        uint256 indexed _newTotal\r\n    );\r\n\r\n    event RemoveDelegatorRequested(\r\n        address indexed _serviceProvider,\r\n        address indexed _delegator,\r\n        uint256 indexed _lockupExpiryBlock\r\n    );\r\n\r\n    event RemoveDelegatorRequestCancelled(\r\n        address indexed _serviceProvider,\r\n        address indexed _delegator\r\n    );\r\n\r\n    event RemoveDelegatorRequestEvaluated(\r\n        address indexed _serviceProvider,\r\n        address indexed _delegator,\r\n        uint256 indexed _unstakedAmount\r\n    );\r\n\r\n    event MaxDelegatorsUpdated(uint256 indexed _maxDelegators);\r\n    event MinDelegationUpdated(uint256 indexed _minDelegationAmount);\r\n    event UndelegateLockupDurationUpdated(uint256 indexed _undelegateLockupDuration);\r\n    event GovernanceAddressUpdated(address indexed _newGovernanceAddress);\r\n    event StakingAddressUpdated(address indexed _newStakingAddress);\r\n    event ServiceProviderFactoryAddressUpdated(address indexed _newServiceProviderFactoryAddress);\r\n    event ClaimsManagerAddressUpdated(address indexed _newClaimsManagerAddress);\r\n    event RemoveDelegatorLockupDurationUpdated(uint256 indexed _removeDelegatorLockupDuration);\r\n    event RemoveDelegatorEvalDurationUpdated(uint256 indexed _removeDelegatorEvalDuration);\r\n\r\n    /**\r\n     * @notice Function to initialize the contract\r\n     * @dev stakingAddress must be initialized separately after Staking contract is deployed\r\n     * @dev serviceProviderFactoryAddress must be initialized separately after ServiceProviderFactory contract is deployed\r\n     * @dev claimsManagerAddress must be initialized separately after ClaimsManager contract is deployed\r\n     * @param _tokenAddress - address of ERC20 token that will be claimed\r\n     * @param _governanceAddress - Governance proxy address\r\n     */\r\n    function initialize (\r\n        address _tokenAddress,\r\n        address _governanceAddress,\r\n        uint256 _undelegateLockupDuration\r\n    ) public initializer\r\n    {\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        audiusToken = ERC20Mintable(_tokenAddress);\r\n        maxDelegators = 175;\r\n        // Default minimum delegation amount set to 100AUD\r\n        minDelegationAmount = 100 * 10**uint256(18);\r\n        InitializableV2.initialize();\r\n\r\n        _updateUndelegateLockupDuration(_undelegateLockupDuration);\r\n\r\n        // 1 week = 168hrs * 60 min/hr * 60 sec/min / ~13 sec/block = 46523 blocks\r\n        _updateRemoveDelegatorLockupDuration(46523);\r\n\r\n        // 24hr * 60min/hr * 60sec/min / ~13 sec/block = 6646 blocks\r\n        removeDelegatorEvalDuration = 6646;\r\n    }\r\n\r\n    /**\r\n     * @notice Allow a delegator to delegate stake to a service provider\r\n     * @param _targetSP - address of service provider to delegate to\r\n     * @param _amount - amount in wei to delegate\r\n     * @return Updated total amount delegated to the service provider by delegator\r\n     */\r\n    function delegateStake(\r\n        address _targetSP,\r\n        uint256 _amount\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        require(\r\n            !_claimPending(_targetSP),\r\n            \"DelegateManager: Delegation not permitted for SP pending claim\"\r\n        );\r\n        address delegator = msg.sender;\r\n        Staking stakingContract = Staking(stakingAddress);\r\n\r\n        // Stake on behalf of target service provider\r\n        stakingContract.delegateStakeFor(\r\n            _targetSP,\r\n            delegator,\r\n            _amount\r\n        );\r\n\r\n        // Update list of delegators to SP if necessary\r\n        if (!_delegatorExistsForSP(delegator, _targetSP)) {\r\n            // If not found, update list of delegates\r\n            spDelegateInfo[_targetSP].delegators.push(delegator);\r\n            require(\r\n                spDelegateInfo[_targetSP].delegators.length <= maxDelegators,\r\n                \"DelegateManager: Maximum delegators exceeded\"\r\n            );\r\n        }\r\n\r\n        // Update following values in storage through helper\r\n        // totalServiceProviderDelegatedStake = current sp total + new amount,\r\n        // totalStakedForSpFromDelegator = current delegator total for sp + new amount,\r\n        // totalDelegatorStake = current delegator total + new amount\r\n        _updateDelegatorStake(\r\n            delegator,\r\n            _targetSP,\r\n            spDelegateInfo[_targetSP].totalDelegatedStake.add(_amount),\r\n            delegateInfo[delegator][_targetSP].add(_amount),\r\n            delegatorTotalStake[delegator].add(_amount)\r\n        );\r\n\r\n        require(\r\n            delegateInfo[delegator][_targetSP] >= minDelegationAmount,\r\n            ERROR_MINIMUM_DELEGATION\r\n        );\r\n\r\n        // Validate balance\r\n        ServiceProviderFactory(\r\n            serviceProviderFactoryAddress\r\n        ).validateAccountStakeBalance(_targetSP);\r\n\r\n        emit IncreaseDelegatedStake(\r\n            delegator,\r\n            _targetSP,\r\n            _amount\r\n        );\r\n\r\n        // Return new total\r\n        return delegateInfo[delegator][_targetSP];\r\n    }\r\n\r\n    /**\r\n     * @notice Submit request for undelegation\r\n     * @param _target - address of service provider to undelegate stake from\r\n     * @param _amount - amount in wei to undelegate\r\n     * @return Updated total amount delegated to the service provider by delegator\r\n     */\r\n    function requestUndelegateStake(\r\n        address _target,\r\n        uint256 _amount\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        require(\r\n            _amount > 0,\r\n            \"DelegateManager: Requested undelegate stake amount must be greater than zero\"\r\n        );\r\n        require(\r\n            !_claimPending(_target),\r\n            \"DelegateManager: Undelegate request not permitted for SP pending claim\"\r\n        );\r\n        address delegator = msg.sender;\r\n        require(\r\n            _delegatorExistsForSP(delegator, _target),\r\n            ERROR_DELEGATOR_STAKE\r\n        );\r\n\r\n        // Confirm no pending delegation request\r\n        require(\r\n            !_undelegateRequestIsPending(delegator),\r\n            \"DelegateManager: No pending lockup expected\"\r\n        );\r\n\r\n        // Ensure valid bounds\r\n        uint256 currentlyDelegatedToSP = delegateInfo[delegator][_target];\r\n        require(\r\n            _amount <= currentlyDelegatedToSP,\r\n            \"DelegateManager: Cannot decrease greater than currently staked for this ServiceProvider\"\r\n        );\r\n\r\n        // Submit updated request for sender, with target sp, undelegate amount, target expiry block\r\n        uint256 lockupExpiryBlock = block.number.add(undelegateLockupDuration);\r\n        _updateUndelegateStakeRequest(\r\n            delegator,\r\n            _target,\r\n            _amount,\r\n            lockupExpiryBlock\r\n        );\r\n        // Update total locked for this service provider, increasing by unstake amount\r\n        _updateServiceProviderLockupAmount(\r\n            _target,\r\n            spDelegateInfo[_target].totalLockedUpStake.add(_amount)\r\n        );\r\n\r\n        emit UndelegateStakeRequested(delegator, _target, _amount, lockupExpiryBlock);\r\n        return delegateInfo[delegator][_target].sub(_amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel undelegation request\r\n     */\r\n    function cancelUndelegateStakeRequest() external {\r\n        _requireIsInitialized();\r\n\r\n        address delegator = msg.sender;\r\n        // Confirm pending delegation request\r\n        require(\r\n            _undelegateRequestIsPending(delegator),\r\n            \"DelegateManager: Pending lockup expected\"\r\n        );\r\n        uint256 unstakeAmount = undelegateRequests[delegator].amount;\r\n        address unlockFundsSP = undelegateRequests[delegator].serviceProvider;\r\n        // Update total locked for this service provider, decreasing by unstake amount\r\n        _updateServiceProviderLockupAmount(\r\n            unlockFundsSP,\r\n            spDelegateInfo[unlockFundsSP].totalLockedUpStake.sub(unstakeAmount)\r\n        );\r\n        // Remove pending request\r\n        _resetUndelegateStakeRequest(delegator);\r\n        emit UndelegateStakeRequestCancelled(delegator, unlockFundsSP, unstakeAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Finalize undelegation request and withdraw stake\r\n     * @return New total amount currently staked after stake has been undelegated\r\n     */\r\n    function undelegateStake() external returns (uint256) {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        address delegator = msg.sender;\r\n\r\n        // Confirm pending delegation request\r\n        require(\r\n            _undelegateRequestIsPending(delegator),\r\n            \"DelegateManager: Pending lockup expected\"\r\n        );\r\n\r\n        // Confirm lockup expiry has expired\r\n        require(\r\n            undelegateRequests[delegator].lockupExpiryBlock <= block.number,\r\n            \"DelegateManager: Lockup must be expired\"\r\n        );\r\n\r\n        // Confirm no pending claim for this service provider\r\n        require(\r\n            !_claimPending(undelegateRequests[delegator].serviceProvider),\r\n            \"DelegateManager: Undelegate not permitted for SP pending claim\"\r\n        );\r\n\r\n        address serviceProvider = undelegateRequests[delegator].serviceProvider;\r\n        uint256 unstakeAmount = undelegateRequests[delegator].amount;\r\n\r\n        // Unstake on behalf of target service provider\r\n        Staking(stakingAddress).undelegateStakeFor(\r\n            serviceProvider,\r\n            delegator,\r\n            unstakeAmount\r\n        );\r\n\r\n        // Update total delegated for SP\r\n        // totalServiceProviderDelegatedStake - total amount delegated to service provider\r\n        // totalStakedForSpFromDelegator - amount staked from this delegator to targeted service provider\r\n        _updateDelegatorStake(\r\n            delegator,\r\n            serviceProvider,\r\n            spDelegateInfo[serviceProvider].totalDelegatedStake.sub(unstakeAmount),\r\n            delegateInfo[delegator][serviceProvider].sub(unstakeAmount),\r\n            delegatorTotalStake[delegator].sub(unstakeAmount)\r\n        );\r\n\r\n        require(\r\n            (delegateInfo[delegator][serviceProvider] >= minDelegationAmount ||\r\n             delegateInfo[delegator][serviceProvider] == 0),\r\n            ERROR_MINIMUM_DELEGATION\r\n        );\r\n\r\n        // Remove from delegators list if no delegated stake remaining\r\n        if (delegateInfo[delegator][serviceProvider] == 0) {\r\n            _removeFromDelegatorsList(serviceProvider, delegator);\r\n        }\r\n\r\n        // Update total locked for this service provider, decreasing by unstake amount\r\n        _updateServiceProviderLockupAmount(\r\n            serviceProvider,\r\n            spDelegateInfo[serviceProvider].totalLockedUpStake.sub(unstakeAmount)\r\n        );\r\n        // Reset undelegate request\r\n        _resetUndelegateStakeRequest(delegator);\r\n\r\n        emit UndelegateStakeRequestEvaluated(\r\n            delegator,\r\n            serviceProvider,\r\n            unstakeAmount\r\n        );\r\n\r\n        // Return new total\r\n        return delegateInfo[delegator][serviceProvider];\r\n    }\r\n\r\n    /**\r\n     * @notice Claim and distribute rewards to delegators and service provider as necessary\r\n     * @param _serviceProvider - Provider for which rewards are being distributed\r\n     * @dev Factors in service provider rewards from delegator and transfers deployer cut\r\n     */\r\n    function claimRewards(address _serviceProvider) external {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireClaimsManagerAddressIsSet();\r\n\r\n        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\r\n\r\n        // Total rewards = (balance in staking) - ((balance in sp factory) + (balance in delegate manager))\r\n        (\r\n            uint256 totalBalanceInStaking,\r\n            uint256 totalBalanceInSPFactory,\r\n            uint256 totalActiveFunds,\r\n            uint256 totalRewards,\r\n            uint256 deployerCut\r\n        ) = _validateClaimRewards(spFactory, _serviceProvider);\r\n\r\n        // No-op if balance is already equivalent\r\n        // This case can occur if no rewards due to bound violation or all stake is locked\r\n        if (totalRewards == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 totalDelegatedStakeIncrease = _distributeDelegateRewards(\r\n            _serviceProvider,\r\n            totalActiveFunds,\r\n            totalRewards,\r\n            deployerCut,\r\n            spFactory.getServiceProviderDeployerCutBase()\r\n        );\r\n\r\n        // Update total delegated to this SP\r\n        spDelegateInfo[_serviceProvider].totalDelegatedStake = (\r\n            spDelegateInfo[_serviceProvider].totalDelegatedStake.add(totalDelegatedStakeIncrease)\r\n        );\r\n\r\n        // spRewardShare represents rewards directly allocated to service provider for their stake\r\n        // Value is computed as the remainder of total minted rewards after distribution to\r\n        // delegators, eliminating any potential for precision loss.\r\n        uint256 spRewardShare = totalRewards.sub(totalDelegatedStakeIncrease);\r\n\r\n        // Adding the newly calculated reward share to current balance\r\n        uint256 newSPFactoryBalance = totalBalanceInSPFactory.add(spRewardShare);\r\n\r\n        require(\r\n            totalBalanceInStaking == newSPFactoryBalance.add(spDelegateInfo[_serviceProvider].totalDelegatedStake),\r\n            \"DelegateManager: claimRewards amount mismatch\"\r\n        );\r\n\r\n        spFactory.updateServiceProviderStake(\r\n            _serviceProvider,\r\n            newSPFactoryBalance\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Reduce current stake amount\r\n     * @dev Only callable by governance. Slashes service provider and delegators equally\r\n     * @param _amount - amount in wei to slash\r\n     * @param _slashAddress - address of service provider to slash\r\n     */\r\n    function slash(uint256 _amount, address _slashAddress)\r\n    external\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        Staking stakingContract = Staking(stakingAddress);\r\n        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\r\n\r\n        // Amount stored in staking contract for owner\r\n        uint256 totalBalanceInStakingPreSlash = stakingContract.totalStakedFor(_slashAddress);\r\n        require(\r\n            (totalBalanceInStakingPreSlash >= _amount),\r\n            \"DelegateManager: Cannot slash more than total currently staked\"\r\n        );\r\n\r\n        // Cancel any withdrawal request for this service provider\r\n        (uint256 spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_slashAddress);\r\n        if (spLockedStake > 0) {\r\n            spFactory.cancelDecreaseStakeRequest(_slashAddress);\r\n        }\r\n\r\n        // Amount in sp factory for slash target\r\n        (uint256 totalBalanceInSPFactory,,,,,) = (\r\n            spFactory.getServiceProviderDetails(_slashAddress)\r\n        );\r\n        require(\r\n            totalBalanceInSPFactory > 0,\r\n            \"DelegateManager: Service Provider stake required\"\r\n        );\r\n\r\n        // Decrease value in Staking contract\r\n        // A value of zero slash will fail in staking, reverting this transaction\r\n        stakingContract.slash(_amount, _slashAddress);\r\n        uint256 totalBalanceInStakingAfterSlash = stakingContract.totalStakedFor(_slashAddress);\r\n\r\n        // Emit slash event\r\n        emit Slash(_slashAddress, _amount, totalBalanceInStakingAfterSlash);\r\n\r\n        uint256 totalDelegatedStakeDecrease = 0;\r\n        // For each delegator and deployer, recalculate new value\r\n        // newStakeAmount = newStakeAmount * (oldStakeAmount / totalBalancePreSlash)\r\n        for (uint256 i = 0; i < spDelegateInfo[_slashAddress].delegators.length; i++) {\r\n            address delegator = spDelegateInfo[_slashAddress].delegators[i];\r\n            uint256 preSlashDelegateStake = delegateInfo[delegator][_slashAddress];\r\n            uint256 newDelegateStake = (\r\n             totalBalanceInStakingAfterSlash.mul(preSlashDelegateStake)\r\n            ).div(totalBalanceInStakingPreSlash);\r\n            // slashAmountForDelegator = preSlashDelegateStake - newDelegateStake;\r\n            delegateInfo[delegator][_slashAddress] = (\r\n                delegateInfo[delegator][_slashAddress].sub(preSlashDelegateStake.sub(newDelegateStake))\r\n            );\r\n            // Update total stake for delegator\r\n            _updateDelegatorTotalStake(\r\n                delegator,\r\n                delegatorTotalStake[delegator].sub(preSlashDelegateStake.sub(newDelegateStake))\r\n            );\r\n            // Update total decrease amount\r\n            totalDelegatedStakeDecrease = (\r\n                totalDelegatedStakeDecrease.add(preSlashDelegateStake.sub(newDelegateStake))\r\n            );\r\n            // Check for any locked up funds for this slashed delegator\r\n            // Slash overrides any pending withdrawal requests\r\n            if (undelegateRequests[delegator].amount != 0) {\r\n                address unstakeSP = undelegateRequests[delegator].serviceProvider;\r\n                uint256 unstakeAmount = undelegateRequests[delegator].amount;\r\n                // Remove pending request\r\n                _updateServiceProviderLockupAmount(\r\n                    unstakeSP,\r\n                    spDelegateInfo[unstakeSP].totalLockedUpStake.sub(unstakeAmount)\r\n                );\r\n                _resetUndelegateStakeRequest(delegator);\r\n            }\r\n        }\r\n\r\n        // Update total delegated to this SP\r\n        spDelegateInfo[_slashAddress].totalDelegatedStake = (\r\n            spDelegateInfo[_slashAddress].totalDelegatedStake.sub(totalDelegatedStakeDecrease)\r\n        );\r\n\r\n        // Remaining decrease applied to service provider\r\n        uint256 totalStakeDecrease = (\r\n            totalBalanceInStakingPreSlash.sub(totalBalanceInStakingAfterSlash)\r\n        );\r\n        uint256 totalSPFactoryBalanceDecrease = (\r\n            totalStakeDecrease.sub(totalDelegatedStakeDecrease)\r\n        );\r\n        spFactory.updateServiceProviderStake(\r\n            _slashAddress,\r\n            totalBalanceInSPFactory.sub(totalSPFactoryBalanceDecrease)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Initiate forcible removal of a delegator\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _delegator - address of delegator\r\n     */\r\n    function requestRemoveDelegator(address _serviceProvider, address _delegator) external {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            msg.sender == _serviceProvider || msg.sender == governanceAddress,\r\n            ERROR_ONLY_SP_GOVERNANCE\r\n        );\r\n\r\n        require(\r\n            removeDelegatorRequests[_serviceProvider][_delegator] == 0,\r\n            \"DelegateManager: Pending remove delegator request\"\r\n        );\r\n\r\n        require(\r\n            _delegatorExistsForSP(_delegator, _serviceProvider),\r\n            ERROR_DELEGATOR_STAKE\r\n        );\r\n\r\n        // Update lockup\r\n        removeDelegatorRequests[_serviceProvider][_delegator] = (\r\n            block.number + removeDelegatorLockupDuration\r\n        );\r\n\r\n        emit RemoveDelegatorRequested(\r\n            _serviceProvider,\r\n            _delegator,\r\n            removeDelegatorRequests[_serviceProvider][_delegator]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel pending removeDelegator request\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _delegator - address of delegator\r\n     */\r\n    function cancelRemoveDelegatorRequest(address _serviceProvider, address _delegator) external {\r\n        require(\r\n            msg.sender == _serviceProvider || msg.sender == governanceAddress,\r\n            ERROR_ONLY_SP_GOVERNANCE\r\n        );\r\n        require(\r\n            removeDelegatorRequests[_serviceProvider][_delegator] != 0,\r\n            \"DelegateManager: No pending request\"\r\n        );\r\n        // Reset lockup expiry\r\n        removeDelegatorRequests[_serviceProvider][_delegator] = 0;\r\n        emit RemoveDelegatorRequestCancelled(_serviceProvider, _delegator);\r\n    }\r\n\r\n    /**\r\n     * @notice Evaluate removeDelegator request\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _delegator - address of delegator\r\n     * @return Updated total amount delegated to the service provider by delegator\r\n     */\r\n    function removeDelegator(address _serviceProvider, address _delegator) external {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n\r\n        require(\r\n            msg.sender == _serviceProvider || msg.sender == governanceAddress,\r\n            ERROR_ONLY_SP_GOVERNANCE\r\n        );\r\n\r\n        require(\r\n            removeDelegatorRequests[_serviceProvider][_delegator] != 0,\r\n            \"DelegateManager: No pending request\"\r\n        );\r\n\r\n        // Enforce lockup expiry block\r\n        require(\r\n            block.number >= removeDelegatorRequests[_serviceProvider][_delegator],\r\n            \"DelegateManager: Lockup must be expired\"\r\n        );\r\n\r\n        // Enforce evaluation window for request\r\n        require(\r\n            block.number < removeDelegatorRequests[_serviceProvider][_delegator] + removeDelegatorEvalDuration,\r\n            \"DelegateManager: RemoveDelegator evaluation window expired\"\r\n        );\r\n\r\n        uint256 unstakeAmount = delegateInfo[_delegator][_serviceProvider];\r\n        // Unstake on behalf of target service provider\r\n        Staking(stakingAddress).undelegateStakeFor(\r\n            _serviceProvider,\r\n            _delegator,\r\n            unstakeAmount\r\n        );\r\n        // Update total delegated for SP\r\n        // totalServiceProviderDelegatedStake - total amount delegated to service provider\r\n        // totalStakedForSpFromDelegator - amount staked from this delegator to targeted service provider\r\n        _updateDelegatorStake(\r\n            _delegator,\r\n            _serviceProvider,\r\n            spDelegateInfo[_serviceProvider].totalDelegatedStake.sub(unstakeAmount),\r\n            delegateInfo[_delegator][_serviceProvider].sub(unstakeAmount),\r\n            delegatorTotalStake[_delegator].sub(unstakeAmount)\r\n        );\r\n\r\n        if (\r\n            _undelegateRequestIsPending(_delegator) &&\r\n            undelegateRequests[_delegator].serviceProvider == _serviceProvider\r\n        ) {\r\n            // Remove pending request information\r\n            _updateServiceProviderLockupAmount(\r\n                _serviceProvider,\r\n                spDelegateInfo[_serviceProvider].totalLockedUpStake.sub(undelegateRequests[_delegator].amount)\r\n            );\r\n            _resetUndelegateStakeRequest(_delegator);\r\n        }\r\n\r\n        // Remove from list of delegators\r\n        _removeFromDelegatorsList(_serviceProvider, _delegator);\r\n\r\n        // Reset lockup expiry\r\n        removeDelegatorRequests[_serviceProvider][_delegator] = 0;\r\n        emit RemoveDelegatorRequestEvaluated(_serviceProvider, _delegator, unstakeAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Update duration for undelegate request lockup\r\n     * @param _duration - new lockup duration\r\n     */\r\n    function updateUndelegateLockupDuration(uint256 _duration) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        _updateUndelegateLockupDuration(_duration);\r\n        emit UndelegateLockupDurationUpdated(_duration);\r\n    }\r\n\r\n    /**\r\n     * @notice Update maximum delegators allowed\r\n     * @param _maxDelegators - new max delegators\r\n     */\r\n    function updateMaxDelegators(uint256 _maxDelegators) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        maxDelegators = _maxDelegators;\r\n        emit MaxDelegatorsUpdated(_maxDelegators);\r\n    }\r\n\r\n    /**\r\n     * @notice Update minimum delegation amount\r\n     * @param _minDelegationAmount - min new min delegation amount\r\n     */\r\n    function updateMinDelegationAmount(uint256 _minDelegationAmount) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        minDelegationAmount = _minDelegationAmount;\r\n        emit MinDelegationUpdated(_minDelegationAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Update remove delegator lockup duration\r\n     * @param _duration - new lockup duration\r\n     */\r\n    function updateRemoveDelegatorLockupDuration(uint256 _duration) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        _updateRemoveDelegatorLockupDuration(_duration);\r\n        emit RemoveDelegatorLockupDurationUpdated(_duration);\r\n    }\r\n\r\n    /**\r\n     * @notice Update remove delegator evaluation window duration\r\n     * @param _duration - new window duration\r\n     */\r\n    function updateRemoveDelegatorEvalDuration(uint256 _duration) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        removeDelegatorEvalDuration = _duration;\r\n        emit RemoveDelegatorEvalDurationUpdated(_duration);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Governance address\r\n     * @dev Only callable by Governance address\r\n     * @param _governanceAddress - address for new Governance contract\r\n     */\r\n    function setGovernanceAddress(address _governanceAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        governanceAddress = _governanceAddress;\r\n        emit GovernanceAddressUpdated(_governanceAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Staking address\r\n     * @dev Only callable by Governance address\r\n     * @param _stakingAddress - address for new Staking contract\r\n     */\r\n    function setStakingAddress(address _stakingAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        stakingAddress = _stakingAddress;\r\n        emit StakingAddressUpdated(_stakingAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ServiceProviderFactory address\r\n     * @dev Only callable by Governance address\r\n     * @param _spFactory - address for new ServiceProviderFactory contract\r\n     */\r\n    function setServiceProviderFactoryAddress(address _spFactory) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        serviceProviderFactoryAddress = _spFactory;\r\n        emit ServiceProviderFactoryAddressUpdated(_spFactory);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ClaimsManager address\r\n     * @dev Only callable by Governance address\r\n     * @param _claimsManagerAddress - address for new ClaimsManager contract\r\n     */\r\n    function setClaimsManagerAddress(address _claimsManagerAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        claimsManagerAddress = _claimsManagerAddress;\r\n        emit ClaimsManagerAddressUpdated(_claimsManagerAddress);\r\n    }\r\n\r\n    // ========================================= View Functions =========================================\r\n\r\n    /**\r\n     * @notice Get list of delegators for a given service provider\r\n     * @param _sp - service provider address\r\n     */\r\n    function getDelegatorsList(address _sp)\r\n    external view returns (address[] memory)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return spDelegateInfo[_sp].delegators;\r\n    }\r\n\r\n    /**\r\n     * @notice Get total delegation from a given address\r\n     * @param _delegator - delegator address\r\n     */\r\n    function getTotalDelegatorStake(address _delegator)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return delegatorTotalStake[_delegator];\r\n    }\r\n\r\n    /// @notice Get total amount delegated to a service provider\r\n    function getTotalDelegatedToServiceProvider(address _sp)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return spDelegateInfo[_sp].totalDelegatedStake;\r\n    }\r\n\r\n    /// @notice Get total delegated stake locked up for a service provider\r\n    function getTotalLockedDelegationForServiceProvider(address _sp)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return spDelegateInfo[_sp].totalLockedUpStake;\r\n    }\r\n\r\n    /// @notice Get total currently staked for a delegator, for a given service provider\r\n    function getDelegatorStakeForServiceProvider(address _delegator, address _serviceProvider)\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return delegateInfo[_delegator][_serviceProvider];\r\n    }\r\n\r\n    /**\r\n     * @notice Get status of pending undelegate request for a given address\r\n     * @param _delegator - address of the delegator\r\n     */\r\n    function getPendingUndelegateRequest(address _delegator)\r\n    external view returns (address target, uint256 amount, uint256 lockupExpiryBlock)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        UndelegateStakeRequest memory req = undelegateRequests[_delegator];\r\n        return (req.serviceProvider, req.amount, req.lockupExpiryBlock);\r\n    }\r\n\r\n    /**\r\n     * @notice Get status of pending remove delegator request for a given address\r\n     * @param _serviceProvider - address of the service provider\r\n     * @param _delegator - address of the delegator\r\n     * @return - current lockup expiry block for remove delegator request\r\n     */\r\n    function getPendingRemoveDelegatorRequest(\r\n        address _serviceProvider,\r\n        address _delegator\r\n    ) external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return removeDelegatorRequests[_serviceProvider][_delegator];\r\n    }\r\n\r\n    /// @notice Get current undelegate lockup duration\r\n    function getUndelegateLockupDuration()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return undelegateLockupDuration;\r\n    }\r\n\r\n    /// @notice Current maximum delegators\r\n    function getMaxDelegators()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return maxDelegators;\r\n    }\r\n\r\n    /// @notice Get minimum delegation amount\r\n    function getMinDelegationAmount()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return minDelegationAmount;\r\n    }\r\n\r\n    /// @notice Get the duration for remove delegator request lockup\r\n    function getRemoveDelegatorLockupDuration()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return removeDelegatorLockupDuration;\r\n    }\r\n\r\n    /// @notice Get the duration for evaluation of remove delegator operations\r\n    function getRemoveDelegatorEvalDuration()\r\n    external view returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return removeDelegatorEvalDuration;\r\n    }\r\n\r\n    /// @notice Get the Governance address\r\n    function getGovernanceAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return governanceAddress;\r\n    }\r\n\r\n    /// @notice Get the ServiceProviderFactory address\r\n    function getServiceProviderFactoryAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderFactoryAddress;\r\n    }\r\n\r\n    /// @notice Get the ClaimsManager address\r\n    function getClaimsManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return claimsManagerAddress;\r\n    }\r\n\r\n    /// @notice Get the Staking address\r\n    function getStakingAddress() external view returns (address)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        return stakingAddress;\r\n    }\r\n\r\n    // ========================================= Internal functions =========================================\r\n\r\n    /**\r\n     * @notice Helper function for claimRewards to get balances from Staking contract\r\n               and do validation\r\n     * @param spFactory - reference to ServiceProviderFactory contract\r\n     * @param _serviceProvider - address for which rewards are being claimed\r\n     * @return (totalBalanceInStaking, totalBalanceInSPFactory, totalActiveFunds, spLockedStake, totalRewards, deployerCut)\r\n     */\r\n    function _validateClaimRewards(ServiceProviderFactory spFactory, address _serviceProvider)\r\n    internal returns (\r\n        uint256 totalBalanceInStaking,\r\n        uint256 totalBalanceInSPFactory,\r\n        uint256 totalActiveFunds,\r\n        uint256 totalRewards,\r\n        uint256 deployerCut\r\n    )\r\n    {\r\n        // Account for any pending locked up stake for the service provider\r\n        (uint256 spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_serviceProvider);\r\n        uint256 totalLockedUpStake = (\r\n            spDelegateInfo[_serviceProvider].totalLockedUpStake.add(spLockedStake)\r\n        );\r\n\r\n        // Process claim for msg.sender\r\n        // Total locked parameter is equal to delegate locked up stake + service provider locked up stake\r\n        uint256 mintedRewards = ClaimsManager(claimsManagerAddress).processClaim(\r\n            _serviceProvider,\r\n            totalLockedUpStake\r\n        );\r\n\r\n        // Amount stored in staking contract for owner\r\n        totalBalanceInStaking = Staking(stakingAddress).totalStakedFor(_serviceProvider);\r\n\r\n        // Amount in sp factory for claimer\r\n        (\r\n            totalBalanceInSPFactory,\r\n            deployerCut,\r\n            ,,,\r\n        ) = spFactory.getServiceProviderDetails(_serviceProvider);\r\n        // Require active stake to claim any rewards\r\n\r\n        // Amount in delegate manager staked to service provider\r\n        uint256 totalBalanceOutsideStaking = (\r\n            totalBalanceInSPFactory.add(spDelegateInfo[_serviceProvider].totalDelegatedStake)\r\n        );\r\n\r\n        totalActiveFunds = totalBalanceOutsideStaking.sub(totalLockedUpStake);\r\n\r\n        require(\r\n            mintedRewards == totalBalanceInStaking.sub(totalBalanceOutsideStaking),\r\n            \"DelegateManager: Reward amount mismatch\"\r\n        );\r\n\r\n        // Emit claim event\r\n        emit Claim(_serviceProvider, totalRewards, totalBalanceInStaking);\r\n\r\n        return (\r\n            totalBalanceInStaking,\r\n            totalBalanceInSPFactory,\r\n            totalActiveFunds,\r\n            mintedRewards,\r\n            deployerCut\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Perform state updates when a delegate stake has changed\r\n     * @param _delegator - address of delegator\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _totalServiceProviderDelegatedStake - total delegated to this service provider\r\n     * @param _totalStakedForSpFromDelegator - total delegated to this service provider by delegator\r\n     * @param _totalDelegatorStake - total delegated from this delegator address\r\n     */\r\n    function _updateDelegatorStake(\r\n        address _delegator,\r\n        address _serviceProvider,\r\n        uint256 _totalServiceProviderDelegatedStake,\r\n        uint256 _totalStakedForSpFromDelegator,\r\n        uint256 _totalDelegatorStake\r\n    ) internal\r\n    {\r\n        // Update total delegated for SP\r\n        spDelegateInfo[_serviceProvider].totalDelegatedStake = _totalServiceProviderDelegatedStake;\r\n\r\n        // Update amount staked from this delegator to targeted service provider\r\n        delegateInfo[_delegator][_serviceProvider] = _totalStakedForSpFromDelegator;\r\n\r\n        // Update total delegated from this delegator\r\n        _updateDelegatorTotalStake(_delegator, _totalDelegatorStake);\r\n    }\r\n\r\n    /**\r\n     * @notice Reset pending undelegate stake request\r\n     * @param _delegator - address of delegator\r\n     */\r\n    function _resetUndelegateStakeRequest(address _delegator) internal\r\n    {\r\n        _updateUndelegateStakeRequest(_delegator, address(0), 0, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Perform updates when undelegate request state has changed\r\n     * @param _delegator - address of delegator\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _amount - amount being undelegated\r\n     * @param _lockupExpiryBlock - block at which stake can be undelegated\r\n     */\r\n    function _updateUndelegateStakeRequest(\r\n        address _delegator,\r\n        address _serviceProvider,\r\n        uint256 _amount,\r\n        uint256 _lockupExpiryBlock\r\n    ) internal\r\n    {\r\n        // Update lockup information\r\n        undelegateRequests[_delegator] = UndelegateStakeRequest({\r\n            lockupExpiryBlock: _lockupExpiryBlock,\r\n            amount: _amount,\r\n            serviceProvider: _serviceProvider\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Update total amount delegated from an address\r\n     * @param _delegator - address of service provider\r\n     * @param _amount - updated delegator total\r\n     */\r\n    function _updateDelegatorTotalStake(address _delegator, uint256 _amount) internal\r\n    {\r\n        delegatorTotalStake[_delegator] = _amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Update amount currently locked up for this service provider\r\n     * @param _serviceProvider - address of service provider\r\n     * @param _updatedLockupAmount - updated lock up amount\r\n     */\r\n    function _updateServiceProviderLockupAmount(\r\n        address _serviceProvider,\r\n        uint256 _updatedLockupAmount\r\n    ) internal\r\n    {\r\n        spDelegateInfo[_serviceProvider].totalLockedUpStake = _updatedLockupAmount;\r\n    }\r\n\r\n    function _removeFromDelegatorsList(address _serviceProvider, address _delegator) internal\r\n    {\r\n        for (uint256 i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {\r\n            if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {\r\n                // Overwrite and shrink delegators list\r\n                spDelegateInfo[_serviceProvider].delegators[i] = spDelegateInfo[_serviceProvider].delegators[spDelegateInfo[_serviceProvider].delegators.length - 1];\r\n                spDelegateInfo[_serviceProvider].delegators.length--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to distribute rewards to any delegators\r\n     * @param _sp - service provider account tracked in staking\r\n     * @param _totalActiveFunds - total funds minus any locked stake\r\n     * @param _totalRewards - total rewaards generated in this round\r\n     * @param _deployerCut - service provider cut of delegate rewards, defined as deployerCut / deployerCutBase\r\n     * @param _deployerCutBase - denominator value for calculating service provider cut as a %\r\n     * @return (totalBalanceInStaking, totalBalanceInSPFactory, totalBalanceOutsideStaking)\r\n     */\r\n    function _distributeDelegateRewards(\r\n        address _sp,\r\n        uint256 _totalActiveFunds,\r\n        uint256 _totalRewards,\r\n        uint256 _deployerCut,\r\n        uint256 _deployerCutBase\r\n    )\r\n    internal returns (uint256 totalDelegatedStakeIncrease)\r\n    {\r\n        // Traverse all delegates and calculate their rewards\r\n        // As each delegate reward is calculated, increment SP cut reward accordingly\r\n        for (uint256 i = 0; i < spDelegateInfo[_sp].delegators.length; i++) {\r\n            address delegator = spDelegateInfo[_sp].delegators[i];\r\n            uint256 delegateStakeToSP = delegateInfo[delegator][_sp];\r\n\r\n            // Subtract any locked up stake\r\n            if (undelegateRequests[delegator].serviceProvider == _sp) {\r\n                delegateStakeToSP = delegateStakeToSP.sub(undelegateRequests[delegator].amount);\r\n            }\r\n\r\n            // Calculate rewards by ((delegateStakeToSP / totalActiveFunds) * totalRewards)\r\n            uint256 rewardsPriorToSPCut = (\r\n              delegateStakeToSP.mul(_totalRewards)\r\n            ).div(_totalActiveFunds);\r\n\r\n            // Multiply by deployer cut fraction to calculate reward for SP\r\n            // Operation constructed to perform all multiplication prior to division\r\n            // uint256 spDeployerCut = (rewardsPriorToSPCut * deployerCut ) / (deployerCutBase);\r\n            //                    = ((delegateStakeToSP * totalRewards) / totalActiveFunds) * deployerCut ) / (deployerCutBase);\r\n            //                    = ((delegateStakeToSP * totalRewards * deployerCut) / totalActiveFunds ) / (deployerCutBase);\r\n            //                    = (delegateStakeToSP * totalRewards * deployerCut) / (deployerCutBase * totalActiveFunds);\r\n            uint256 spDeployerCut = (\r\n                (delegateStakeToSP.mul(_totalRewards)).mul(_deployerCut)\r\n            ).div(\r\n                _totalActiveFunds.mul(_deployerCutBase)\r\n            );\r\n            // Increase total delegate reward in DelegateManager\r\n            // Subtract SP reward from rewards to calculate delegate reward\r\n            // delegateReward = rewardsPriorToSPCut - spDeployerCut;\r\n            delegateInfo[delegator][_sp] = (\r\n                delegateInfo[delegator][_sp].add(rewardsPriorToSPCut.sub(spDeployerCut))\r\n            );\r\n\r\n            // Update total for this delegator\r\n            _updateDelegatorTotalStake(\r\n                delegator,\r\n                delegatorTotalStake[delegator].add(rewardsPriorToSPCut.sub(spDeployerCut))\r\n            );\r\n\r\n            totalDelegatedStakeIncrease = (\r\n                totalDelegatedStakeIncrease.add(rewardsPriorToSPCut.sub(spDeployerCut))\r\n            );\r\n        }\r\n\r\n        return (totalDelegatedStakeIncrease);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the governance address after confirming contract identity\r\n     * @param _governanceAddress - Incoming governance address\r\n     */\r\n    function _updateGovernanceAddress(address _governanceAddress) internal {\r\n        require(\r\n            Governance(_governanceAddress).isGovernanceAddress() == true,\r\n            \"DelegateManager: _governanceAddress is not a valid governance contract\"\r\n        );\r\n        governanceAddress = _governanceAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the remove delegator lockup duration after validating against governance\r\n     * @param _duration - Incoming remove delegator duration value\r\n     */\r\n    function _updateRemoveDelegatorLockupDuration(uint256 _duration) internal {\r\n        Governance governance = Governance(governanceAddress);\r\n        require(\r\n            _duration > governance.getVotingPeriod() + governance.getExecutionDelay(),\r\n            \"DelegateManager: removeDelegatorLockupDuration duration must be greater than governance votingPeriod + executionDelay\"\r\n        );\r\n        removeDelegatorLockupDuration = _duration;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the undelegate lockup duration after validating against governance\r\n     * @param _duration - Incoming undelegate lockup duration value\r\n     */\r\n    function _updateUndelegateLockupDuration(uint256 _duration) internal {\r\n        Governance governance = Governance(governanceAddress);\r\n        require(\r\n            _duration > governance.getVotingPeriod() + governance.getExecutionDelay(),\r\n            \"DelegateManager: undelegateLockupDuration duration must be greater than governance votingPeriod + executionDelay\"\r\n        );\r\n        undelegateLockupDuration = _duration;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns if delegator has delegated to a service provider\r\n     * @param _delegator - address of delegator\r\n     * @param _serviceProvider - address of service provider\r\n     * @return boolean indicating whether delegator exists for service provider\r\n     */\r\n    function _delegatorExistsForSP(\r\n        address _delegator,\r\n        address _serviceProvider\r\n    ) internal view returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {\r\n            if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {\r\n                return true;\r\n            }\r\n        }\r\n        // Not found\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Determine if a claim is pending for this service provider\r\n     * @param _sp - address of service provider\r\n     * @return boolean indicating whether a claim is pending\r\n     */\r\n    function _claimPending(address _sp) internal view returns (bool) {\r\n        ClaimsManager claimsManager = ClaimsManager(claimsManagerAddress);\r\n        return claimsManager.claimPending(_sp);\r\n    }\r\n\r\n    /**\r\n     * @notice Determine if a decrease request has been initiated\r\n     * @param _delegator - address of delegator\r\n     * @return boolean indicating whether a decrease request is pending\r\n     */\r\n    function _undelegateRequestIsPending(address _delegator) internal view returns (bool)\r\n    {\r\n        return (\r\n            (undelegateRequests[_delegator].lockupExpiryBlock != 0) &&\r\n            (undelegateRequests[_delegator].amount != 0) &&\r\n            (undelegateRequests[_delegator].serviceProvider != address(0))\r\n        );\r\n    }\r\n\r\n    // ========================================= Private Functions =========================================\r\n\r\n    function _requireStakingAddressIsSet() private view {\r\n        require(\r\n            stakingAddress != address(0x00),\r\n            \"DelegateManager: stakingAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireServiceProviderFactoryAddressIsSet() private view {\r\n        require(\r\n            serviceProviderFactoryAddress != address(0x00),\r\n            \"DelegateManager: serviceProviderFactoryAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireClaimsManagerAddressIsSet() private view {\r\n        require(\r\n            claimsManagerAddress != address(0x00),\r\n            \"DelegateManager: claimsManagerAddress is not set\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Initializable, Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize(address sender) public initializer {\r\n        _owner = sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Central hub for Audius protocol. It stores all contract addresses to facilitate\r\n*   external access and enable version management.\r\n*/\r\ncontract Registry is InitializableV2, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev addressStorage mapping allows efficient lookup of current contract version\r\n     *      addressStorageHistory maintains record of all contract versions\r\n     */\r\n    mapping(bytes32 => address) private addressStorage;\r\n    mapping(bytes32 => address[]) private addressStorageHistory;\r\n\r\n    event ContractAdded(\r\n        bytes32 indexed _name,\r\n        address indexed _address\r\n    );\r\n\r\n    event ContractRemoved(\r\n        bytes32 indexed _name,\r\n        address indexed _address\r\n    );\r\n\r\n    event ContractUpgraded(\r\n        bytes32 indexed _name,\r\n        address indexed _oldAddress,\r\n        address indexed _newAddress\r\n    );\r\n\r\n    function initialize() public initializer {\r\n        /// @notice Ownable.initialize(address _sender) sets contract owner to _sender.\r\n        Ownable.initialize(msg.sender);\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    // ========================================= Setters =========================================\r\n\r\n    /**\r\n     * @notice addContract registers contract name to address mapping under given registry key\r\n     * @param _name - registry key that will be used for lookups\r\n     * @param _address - address of contract\r\n     */\r\n    function addContract(bytes32 _name, address _address) external onlyOwner {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            addressStorage[_name] == address(0x00),\r\n            \"Registry: Contract already registered with given name.\"\r\n        );\r\n        require(\r\n            _address != address(0x00),\r\n            \"Registry: Cannot register zero address.\"\r\n        );\r\n\r\n        setAddress(_name, _address);\r\n\r\n        emit ContractAdded(_name, _address);\r\n    }\r\n\r\n    /**\r\n     * @notice removes contract address registered under given registry key\r\n     * @param _name - registry key for lookup\r\n     */\r\n    function removeContract(bytes32 _name) external onlyOwner {\r\n        _requireIsInitialized();\r\n\r\n        address contractAddress = addressStorage[_name];\r\n        require(\r\n            contractAddress != address(0x00),\r\n            \"Registry: Cannot remove - no contract registered with given _name.\"\r\n        );\r\n\r\n        setAddress(_name, address(0x00));\r\n\r\n        emit ContractRemoved(_name, contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice replaces contract address registered under given key with provided address\r\n     * @param _name - registry key for lookup\r\n     * @param _newAddress - new contract address to register under given key\r\n     */\r\n    function upgradeContract(bytes32 _name, address _newAddress) external onlyOwner {\r\n        _requireIsInitialized();\r\n\r\n        address oldAddress = addressStorage[_name];\r\n        require(\r\n            oldAddress != address(0x00),\r\n            \"Registry: Cannot upgrade - no contract registered with given _name.\"\r\n        );\r\n        require(\r\n            _newAddress != address(0x00),\r\n            \"Registry: Cannot upgrade - cannot register zero address.\"\r\n        );\r\n\r\n        setAddress(_name, _newAddress);\r\n\r\n        emit ContractUpgraded(_name, oldAddress, _newAddress);\r\n    }\r\n\r\n    // ========================================= Getters =========================================\r\n\r\n    /**\r\n     * @notice returns contract address registered under given registry key\r\n     * @param _name - registry key for lookup\r\n     * @return contractAddr - address of contract registered under given registry key\r\n     */\r\n    function getContract(bytes32 _name) external view returns (address contractAddr) {\r\n        _requireIsInitialized();\r\n\r\n        return addressStorage[_name];\r\n    }\r\n\r\n    /// @notice overloaded getContract to return explicit version of contract\r\n    function getContract(bytes32 _name, uint256 _version) external view\r\n    returns (address contractAddr)\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        // array length for key implies version number\r\n        require(\r\n            _version <= addressStorageHistory[_name].length,\r\n            \"Registry: Index out of range _version.\"\r\n        );\r\n        return addressStorageHistory[_name][_version.sub(1)];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of versions for a contract key\r\n     * @param _name - registry key for lookup\r\n     * @return number of contract versions\r\n     */\r\n    function getContractVersionCount(bytes32 _name) external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        return addressStorageHistory[_name].length;\r\n    }\r\n\r\n    // ========================================= Private functions =========================================\r\n\r\n    /**\r\n     * @param _key the key for the contract address\r\n     * @param _value the contract address\r\n     */\r\n    function setAddress(bytes32 _key, address _value) private {\r\n        // main map for cheap lookup\r\n        addressStorage[_key] = _value;\r\n        // keep track of contract address history\r\n        addressStorageHistory[_key].push(_value);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Governance is InitializableV2 {\r\n    using SafeMath for uint256;\r\n\r\n    string private constant ERROR_ONLY_GOVERNANCE = (\r\n        \"Governance: Only callable by self\"\r\n    );\r\n    string private constant ERROR_INVALID_VOTING_PERIOD = (\r\n        \"Governance: Requires non-zero _votingPeriod\"\r\n    );\r\n    string private constant ERROR_INVALID_REGISTRY = (\r\n        \"Governance: Requires non-zero _registryAddress\"\r\n    );\r\n    string private constant ERROR_INVALID_VOTING_QUORUM = (\r\n        \"Governance: Requires _votingQuorumPercent between 1 & 100\"\r\n    );\r\n\r\n    /**\r\n     * @notice Address and contract instance of Audius Registry. Used to ensure this contract\r\n     *      can only govern contracts that are registered in the Audius Registry.\r\n     */\r\n    Registry private registry;\r\n\r\n    /// @notice Address of Audius staking contract, used to permission Governance method calls\r\n    address private stakingAddress;\r\n\r\n    /// @notice Address of Audius ServiceProvider contract, used to permission Governance method calls\r\n    address private serviceProviderFactoryAddress;\r\n\r\n    /// @notice Address of Audius DelegateManager contract, used to permission Governance method calls\r\n    address private delegateManagerAddress;\r\n\r\n    /// @notice Period in blocks for which a governance proposal is open for voting\r\n    uint256 private votingPeriod;\r\n\r\n    /// @notice Number of blocks that must pass after votingPeriod has expired before proposal can be evaluated/executed\r\n    uint256 private executionDelay;\r\n\r\n    /// @notice Required minimum percentage of total stake to have voted to consider a proposal valid\r\n    ///         Percentaged stored as a uint256 between 0 & 100\r\n    ///         Calculated as: 100 * sum of voter stakes / total staked in Staking (at proposal submission block)\r\n    uint256 private votingQuorumPercent;\r\n\r\n    /// @notice Max number of InProgress proposals possible at once\r\n    /// @dev uint16 gives max possible value of 65,535\r\n    uint16 private maxInProgressProposals;\r\n\r\n    /**\r\n     * @notice Address of account that has special Governance permissions. Can veto proposals\r\n     *      and execute transactions directly on contracts.\r\n     */\r\n    address private guardianAddress;\r\n\r\n    /***** Enums *****/\r\n\r\n    /**\r\n     * @notice All Proposal Outcome states.\r\n     *      InProgress - Proposal is active and can be voted on.\r\n     *      Rejected - Proposal votingPeriod has closed and vote failed to pass. Proposal will not be executed.\r\n     *      ApprovedExecuted - Proposal votingPeriod has closed and vote passed. Proposal was successfully executed.\r\n     *      QuorumNotMet - Proposal votingPeriod has closed and votingQuorumPercent was not met. Proposal will not be executed.\r\n     *      ApprovedExecutionFailed - Proposal vote passed, but transaction execution failed.\r\n     *      Evaluating - Proposal vote passed, and evaluateProposalOutcome function is currently running.\r\n     *          This status is transiently used inside that function to prevent re-entrancy.\r\n     *      Vetoed - Proposal was vetoed by Guardian.\r\n     *      TargetContractAddressChanged - Proposal considered invalid since target contract address changed\r\n     *      TargetContractCodeHashChanged - Proposal considered invalid since code has at target contract address has changed\r\n     */\r\n    enum Outcome {\r\n        InProgress,\r\n        Rejected,\r\n        ApprovedExecuted,\r\n        QuorumNotMet,\r\n        ApprovedExecutionFailed,\r\n        Evaluating,\r\n        Vetoed,\r\n        TargetContractAddressChanged,\r\n        TargetContractCodeHashChanged\r\n    }\r\n\r\n    /**\r\n     * @notice All Proposal Vote states for a voter.\r\n     *      None - The default state, for any account that has not previously voted on this Proposal.\r\n     *      No - The account voted No on this Proposal.\r\n     *      Yes - The account voted Yes on this Proposal.\r\n     * @dev Enum values map to uints, so first value in Enum always is 0.\r\n     */\r\n    enum Vote {None, No, Yes}\r\n\r\n    struct Proposal {\r\n        uint256 proposalId;\r\n        address proposer;\r\n        uint256 submissionBlockNumber;\r\n        bytes32 targetContractRegistryKey;\r\n        address targetContractAddress;\r\n        uint256 callValue;\r\n        string functionSignature;\r\n        bytes callData;\r\n        Outcome outcome;\r\n        uint256 voteMagnitudeYes;\r\n        uint256 voteMagnitudeNo;\r\n        uint256 numVotes;\r\n        mapping(address => Vote) votes;\r\n        mapping(address => uint256) voteMagnitudes;\r\n        bytes32 contractHash;\r\n    }\r\n\r\n    /***** Proposal storage *****/\r\n\r\n    /// @notice ID of most recently created proposal. Ids are monotonically increasing and 1-indexed.\r\n    uint256 lastProposalId = 0;\r\n\r\n    /// @notice mapping of proposalId to Proposal struct with all proposal state\r\n    mapping(uint256 => Proposal) proposals;\r\n\r\n    /// @notice array of proposals with InProgress state\r\n    uint256[] inProgressProposals;\r\n\r\n\r\n    /***** Events *****/\r\n    event ProposalSubmitted(\r\n        uint256 indexed _proposalId,\r\n        address indexed _proposer,\r\n        string _name,\r\n        string _description\r\n    );\r\n    event ProposalVoteSubmitted(\r\n        uint256 indexed _proposalId,\r\n        address indexed _voter,\r\n        Vote indexed _vote,\r\n        uint256 _voterStake\r\n    );\r\n    event ProposalVoteUpdated(\r\n        uint256 indexed _proposalId,\r\n        address indexed _voter,\r\n        Vote indexed _vote,\r\n        uint256 _voterStake,\r\n        Vote _previousVote\r\n    );\r\n    event ProposalOutcomeEvaluated(\r\n        uint256 indexed _proposalId,\r\n        Outcome indexed _outcome,\r\n        uint256 _voteMagnitudeYes,\r\n        uint256 _voteMagnitudeNo,\r\n        uint256 _numVotes\r\n    );\r\n    event ProposalTransactionExecuted(\r\n        uint256 indexed _proposalId,\r\n        bool indexed _success,\r\n        bytes _returnData\r\n    );\r\n    event GuardianTransactionExecuted(\r\n        address indexed _targetContractAddress,\r\n        uint256 _callValue,\r\n        string indexed _functionSignature,\r\n        bytes indexed _callData,\r\n        bytes _returnData\r\n    );\r\n    event ProposalVetoed(uint256 indexed _proposalId);\r\n    event RegistryAddressUpdated(address indexed _newRegistryAddress);\r\n    event GuardianshipTransferred(address indexed _newGuardianAddress);\r\n    event VotingPeriodUpdated(uint256 indexed _newVotingPeriod);\r\n    event ExecutionDelayUpdated(uint256 indexed _newExecutionDelay);\r\n    event VotingQuorumPercentUpdated(uint256 indexed _newVotingQuorumPercent);\r\n    event MaxInProgressProposalsUpdated(uint256 indexed _newMaxInProgressProposals);\r\n\r\n    /**\r\n     * @notice Initialize the Governance contract\r\n     * @dev _votingPeriod <= DelegateManager.undelegateLockupDuration\r\n     * @dev stakingAddress must be initialized separately after Staking contract is deployed\r\n     * @param _registryAddress - address of the registry proxy contract\r\n     * @param _votingPeriod - period in blocks for which a governance proposal is open for voting\r\n     * @param _executionDelay - number of blocks that must pass after votingPeriod has expired before proposal can be evaluated/executed\r\n     * @param _votingQuorumPercent - required minimum percentage of total stake to have voted to consider a proposal valid\r\n     * @param _maxInProgressProposals - max number of InProgress proposals possible at once\r\n     * @param _guardianAddress - address of account that has special Governance permissions\r\n     */\r\n    function initialize(\r\n        address _registryAddress,\r\n        uint256 _votingPeriod,\r\n        uint256 _executionDelay,\r\n        uint256 _votingQuorumPercent,\r\n        uint16 _maxInProgressProposals,\r\n        address _guardianAddress\r\n    ) public initializer {\r\n        require(_registryAddress != address(0x00), ERROR_INVALID_REGISTRY);\r\n        registry = Registry(_registryAddress);\r\n\r\n        require(_votingPeriod > 0, ERROR_INVALID_VOTING_PERIOD);\r\n        votingPeriod = _votingPeriod;\r\n\r\n        // executionDelay does not have to be non-zero\r\n        executionDelay = _executionDelay;\r\n\r\n        require(\r\n            _maxInProgressProposals > 0,\r\n            \"Governance: Requires non-zero _maxInProgressProposals\"\r\n        );\r\n        maxInProgressProposals = _maxInProgressProposals;\r\n\r\n        require(\r\n            _votingQuorumPercent > 0 && _votingQuorumPercent <= 100,\r\n            ERROR_INVALID_VOTING_QUORUM\r\n        );\r\n        votingQuorumPercent = _votingQuorumPercent;\r\n\r\n        require(\r\n            _guardianAddress != address(0x00),\r\n            \"Governance: Requires non-zero _guardianAddress\"\r\n        );\r\n        guardianAddress = _guardianAddress;  //Guardian address becomes the only party\r\n\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    // ========================================= Governance Actions =========================================\r\n\r\n    /**\r\n     * @notice Submit a proposal for vote. Only callable by addresses with non-zero total active stake.\r\n     *      total active stake = total active deployer stake + total active delegator stake\r\n     *\r\n     * @dev _name and _description length is not enforced since they aren't stored on-chain and only event emitted\r\n     *\r\n     * @param _targetContractRegistryKey - Registry key for the contract concerning this proposal\r\n     * @param _callValue - amount of wei to pass with function call if a token transfer is involved\r\n     * @param _functionSignature - function signature of the function to be executed if proposal is successful\r\n     * @param _callData - encoded value(s) to call function with if proposal is successful\r\n     * @param _name - Text name of proposal to be emitted in event\r\n     * @param _description - Text description of proposal to be emitted in event\r\n     *\r\n     * @return - ID of new proposal\r\n     */\r\n    function submitProposal(\r\n        bytes32 _targetContractRegistryKey,\r\n        uint256 _callValue,\r\n        string calldata _functionSignature,\r\n        bytes calldata _callData,\r\n        string calldata _name,\r\n        string calldata _description\r\n    ) external returns (uint256)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireDelegateManagerAddressIsSet();\r\n\r\n        address proposer = msg.sender;\r\n\r\n        // Require all InProgress proposals that can be evaluated have been evaluated before new proposal submission\r\n        require(\r\n            this.inProgressProposalsAreUpToDate(),\r\n            \"Governance: Cannot submit new proposal until all evaluatable InProgress proposals are evaluated.\"\r\n        );\r\n\r\n        // Require new proposal submission would not push number of InProgress proposals over max number\r\n        require(\r\n            inProgressProposals.length < maxInProgressProposals,\r\n            \"Governance: Number of InProgress proposals already at max. Please evaluate if possible, or wait for current proposals' votingPeriods to expire.\"\r\n        );\r\n\r\n        // Require proposer has non-zero total active stake or is guardian address\r\n        require(\r\n            _calculateAddressActiveStake(proposer) > 0 || proposer == guardianAddress,\r\n            \"Governance: Proposer must be address with non-zero total active stake or be guardianAddress.\"\r\n        );\r\n\r\n        // Require _targetContractRegistryKey points to a valid registered contract\r\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\r\n        require(\r\n            targetContractAddress != address(0x00),\r\n            \"Governance: _targetContractRegistryKey must point to valid registered contract\"\r\n        );\r\n\r\n        // Signature cannot be empty\r\n        require(\r\n            bytes(_functionSignature).length != 0,\r\n            \"Governance: _functionSignature cannot be empty.\"\r\n        );\r\n\r\n        // Require non-zero description length\r\n        require(bytes(_description).length > 0, \"Governance: _description length must be > 0\");\r\n\r\n        // Require non-zero name length\r\n        require(bytes(_name).length > 0, \"Governance: _name length must be > 0\");\r\n\r\n        // set proposalId\r\n        uint256 newProposalId = lastProposalId.add(1);\r\n\r\n        // Store new Proposal obj in proposals mapping\r\n        proposals[newProposalId] = Proposal({\r\n            proposalId: newProposalId,\r\n            proposer: proposer,\r\n            submissionBlockNumber: block.number,\r\n            targetContractRegistryKey: _targetContractRegistryKey,\r\n            targetContractAddress: targetContractAddress,\r\n            callValue: _callValue,\r\n            functionSignature: _functionSignature,\r\n            callData: _callData,\r\n            outcome: Outcome.InProgress,\r\n            voteMagnitudeYes: 0,\r\n            voteMagnitudeNo: 0,\r\n            numVotes: 0,\r\n            contractHash: _getCodeHash(targetContractAddress)\r\n            /* votes: mappings are auto-initialized to default state */\r\n            /* voteMagnitudes: mappings are auto-initialized to default state */\r\n        });\r\n\r\n        // Append new proposalId to inProgressProposals array\r\n        inProgressProposals.push(newProposalId);\r\n\r\n        emit ProposalSubmitted(\r\n            newProposalId,\r\n            proposer,\r\n            _name,\r\n            _description\r\n        );\r\n\r\n        lastProposalId = newProposalId;\r\n\r\n        return newProposalId;\r\n    }\r\n\r\n    /**\r\n     * @notice Vote on an active Proposal. Only callable by addresses with non-zero active stake.\r\n     * @param _proposalId - id of the proposal this vote is for\r\n     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\r\n     */\r\n    function submitVote(uint256 _proposalId, Vote _vote) external {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireDelegateManagerAddressIsSet();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        address voter = msg.sender;\r\n\r\n        // Require proposal votingPeriod is still active\r\n        uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;\r\n        uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod);\r\n        require(\r\n            block.number > submissionBlockNumber && block.number <= endBlockNumber,\r\n            \"Governance: Proposal votingPeriod has ended\"\r\n        );\r\n\r\n        // Require voter has non-zero total active stake\r\n        uint256 voterActiveStake = _calculateAddressActiveStake(voter);\r\n        require(\r\n            voterActiveStake > 0,\r\n            \"Governance: Voter must be address with non-zero total active stake.\"\r\n        );\r\n\r\n        // Require previous vote is None\r\n        require(\r\n            proposals[_proposalId].votes[voter] == Vote.None,\r\n            \"Governance: To update previous vote, call updateVote()\"\r\n        );\r\n\r\n        // Require vote is either Yes or No\r\n        require(\r\n            _vote == Vote.Yes || _vote == Vote.No,\r\n            \"Governance: Can only submit a Yes or No vote\"\r\n        );\r\n\r\n        // Record vote\r\n        proposals[_proposalId].votes[voter] = _vote;\r\n\r\n        // Record voteMagnitude for voter\r\n        proposals[_proposalId].voteMagnitudes[voter] = voterActiveStake;\r\n\r\n        // Update proposal cumulative vote magnitudes\r\n        if (_vote == Vote.Yes) {\r\n            _increaseVoteMagnitudeYes(_proposalId, voterActiveStake);\r\n        } else {\r\n            _increaseVoteMagnitudeNo(_proposalId, voterActiveStake);\r\n        }\r\n\r\n        // Increment proposal numVotes\r\n        proposals[_proposalId].numVotes = proposals[_proposalId].numVotes.add(1);\r\n\r\n        emit ProposalVoteSubmitted(\r\n            _proposalId,\r\n            voter,\r\n            _vote,\r\n            voterActiveStake\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update previous vote on an active Proposal. Only callable by addresses with non-zero active stake.\r\n     * @param _proposalId - id of the proposal this vote is for\r\n     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\r\n     */\r\n    function updateVote(uint256 _proposalId, Vote _vote) external {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireDelegateManagerAddressIsSet();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        address voter = msg.sender;\r\n\r\n        // Require proposal votingPeriod is still active\r\n        uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;\r\n        uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod);\r\n        require(\r\n            block.number > submissionBlockNumber && block.number <= endBlockNumber,\r\n            \"Governance: Proposal votingPeriod has ended\"\r\n        );\r\n\r\n        // Retrieve previous vote\r\n        Vote previousVote = proposals[_proposalId].votes[voter];\r\n\r\n        // Require previous vote is not None\r\n        require(\r\n            previousVote != Vote.None,\r\n            \"Governance: To submit new vote, call submitVote()\"\r\n        );\r\n\r\n        // Require vote is either Yes or No\r\n        require(\r\n            _vote == Vote.Yes || _vote == Vote.No,\r\n            \"Governance: Can only submit a Yes or No vote\"\r\n        );\r\n\r\n        // Record updated vote\r\n        proposals[_proposalId].votes[voter] = _vote;\r\n\r\n        // Update vote magnitudes, using vote magnitude from when previous vote was submitted\r\n        uint256 voteMagnitude = proposals[_proposalId].voteMagnitudes[voter];\r\n        if (previousVote == Vote.Yes && _vote == Vote.No) {\r\n            _decreaseVoteMagnitudeYes(_proposalId, voteMagnitude);\r\n            _increaseVoteMagnitudeNo(_proposalId, voteMagnitude);\r\n        } else if (previousVote == Vote.No && _vote == Vote.Yes) {\r\n            _decreaseVoteMagnitudeNo(_proposalId, voteMagnitude);\r\n            _increaseVoteMagnitudeYes(_proposalId, voteMagnitude);\r\n        }\r\n        // If _vote == previousVote, no changes needed to vote magnitudes.\r\n\r\n        // Do not update numVotes\r\n\r\n        emit ProposalVoteUpdated(\r\n            _proposalId,\r\n            voter,\r\n            _vote,\r\n            voteMagnitude,\r\n            previousVote\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Once the voting period + executionDelay for a proposal has ended, evaluate the outcome and\r\n     *      execute the proposal if voting quorum met & vote passes.\r\n     *      To pass, stake-weighted vote must be > 50% Yes.\r\n     * @dev Requires that caller is an active staker at the time the proposal is created\r\n     * @param _proposalId - id of the proposal\r\n     * @return Outcome of proposal evaluation\r\n     */\r\n    function evaluateProposalOutcome(uint256 _proposalId)\r\n    external returns (Outcome)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireStakingAddressIsSet();\r\n        _requireServiceProviderFactoryAddressIsSet();\r\n        _requireDelegateManagerAddressIsSet();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        // Require proposal has not already been evaluated.\r\n        require(\r\n            proposals[_proposalId].outcome == Outcome.InProgress,\r\n            \"Governance: Can only evaluate InProgress proposal.\"\r\n        );\r\n\r\n        // Re-entrancy should not be possible here since this switches the status of the\r\n        // proposal to 'Evaluating' so it should fail the status is 'InProgress' check\r\n        proposals[_proposalId].outcome = Outcome.Evaluating;\r\n\r\n        // Require proposal votingPeriod + executionDelay have ended.\r\n        uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;\r\n        uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod).add(executionDelay);\r\n        require(\r\n            block.number > endBlockNumber,\r\n            \"Governance: Proposal votingPeriod & executionDelay must end before evaluation.\"\r\n        );\r\n\r\n        address targetContractAddress = registry.getContract(\r\n            proposals[_proposalId].targetContractRegistryKey\r\n        );\r\n\r\n        Outcome outcome;\r\n\r\n        // target contract address changed -> close proposal without execution.\r\n        if (targetContractAddress != proposals[_proposalId].targetContractAddress) {\r\n            outcome = Outcome.TargetContractAddressChanged;\r\n        }\r\n        // target contract code hash changed -> close proposal without execution.\r\n        else if (_getCodeHash(targetContractAddress) != proposals[_proposalId].contractHash) {\r\n            outcome = Outcome.TargetContractCodeHashChanged;\r\n        }\r\n        // voting quorum not met -> close proposal without execution.\r\n        else if (_quorumMet(proposals[_proposalId], Staking(stakingAddress)) == false) {\r\n            outcome = Outcome.QuorumNotMet;\r\n        }\r\n        // votingQuorumPercent met & vote passed -> execute proposed transaction & close proposal.\r\n        else if (\r\n            proposals[_proposalId].voteMagnitudeYes > proposals[_proposalId].voteMagnitudeNo\r\n        ) {\r\n            (bool success, bytes memory returnData) = _executeTransaction(\r\n                targetContractAddress,\r\n                proposals[_proposalId].callValue,\r\n                proposals[_proposalId].functionSignature,\r\n                proposals[_proposalId].callData\r\n            );\r\n\r\n            emit ProposalTransactionExecuted(\r\n                _proposalId,\r\n                success,\r\n                returnData\r\n            );\r\n\r\n            // Proposal outcome depends on success of transaction execution.\r\n            if (success) {\r\n                outcome = Outcome.ApprovedExecuted;\r\n            } else {\r\n                outcome = Outcome.ApprovedExecutionFailed;\r\n            }\r\n        }\r\n        // votingQuorumPercent met & vote did not pass -> close proposal without transaction execution.\r\n        else {\r\n            outcome = Outcome.Rejected;\r\n        }\r\n\r\n        // This records the final outcome in the proposals mapping\r\n        proposals[_proposalId].outcome = outcome;\r\n\r\n        // Remove from inProgressProposals array\r\n        _removeFromInProgressProposals(_proposalId);\r\n\r\n        emit ProposalOutcomeEvaluated(\r\n            _proposalId,\r\n            outcome,\r\n            proposals[_proposalId].voteMagnitudeYes,\r\n            proposals[_proposalId].voteMagnitudeNo,\r\n            proposals[_proposalId].numVotes\r\n        );\r\n\r\n        return outcome;\r\n    }\r\n\r\n    /**\r\n     * @notice Action limited to the guardian address that can veto a proposal\r\n     * @param _proposalId - id of the proposal\r\n     */\r\n    function vetoProposal(uint256 _proposalId) external {\r\n        _requireIsInitialized();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        require(\r\n            msg.sender == guardianAddress,\r\n            \"Governance: Only guardian can veto proposals.\"\r\n        );\r\n\r\n        require(\r\n            proposals[_proposalId].outcome == Outcome.InProgress,\r\n            \"Governance: Cannot veto inactive proposal.\"\r\n        );\r\n\r\n        proposals[_proposalId].outcome = Outcome.Vetoed;\r\n\r\n        // Remove from inProgressProposals array\r\n        _removeFromInProgressProposals(_proposalId);\r\n\r\n        emit ProposalVetoed(_proposalId);\r\n    }\r\n\r\n    // ========================================= Config Setters =========================================\r\n\r\n    /**\r\n     * @notice Set the Staking address\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _stakingAddress - address for new Staking contract\r\n     */\r\n    function setStakingAddress(address _stakingAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(_stakingAddress != address(0x00), \"Governance: Requires non-zero _stakingAddress\");\r\n        stakingAddress = _stakingAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the ServiceProviderFactory address\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _serviceProviderFactoryAddress - address for new ServiceProviderFactory contract\r\n     */\r\n    function setServiceProviderFactoryAddress(address _serviceProviderFactoryAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(\r\n            _serviceProviderFactoryAddress != address(0x00),\r\n            \"Governance: Requires non-zero _serviceProviderFactoryAddress\"\r\n        );\r\n        serviceProviderFactoryAddress = _serviceProviderFactoryAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the DelegateManager address\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _delegateManagerAddress - address for new DelegateManager contract\r\n     */\r\n    function setDelegateManagerAddress(address _delegateManagerAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(\r\n            _delegateManagerAddress != address(0x00),\r\n            \"Governance: Requires non-zero _delegateManagerAddress\"\r\n        );\r\n        delegateManagerAddress = _delegateManagerAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the voting period for a Governance proposal\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _votingPeriod - new voting period\r\n     */\r\n    function setVotingPeriod(uint256 _votingPeriod) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(_votingPeriod > 0, ERROR_INVALID_VOTING_PERIOD);\r\n        votingPeriod = _votingPeriod;\r\n        emit VotingPeriodUpdated(_votingPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the voting quorum percentage for a Governance proposal\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _votingQuorumPercent - new voting period\r\n     */\r\n    function setVotingQuorumPercent(uint256 _votingQuorumPercent) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(\r\n            _votingQuorumPercent > 0 && _votingQuorumPercent <= 100,\r\n            ERROR_INVALID_VOTING_QUORUM\r\n        );\r\n        votingQuorumPercent = _votingQuorumPercent;\r\n        emit VotingQuorumPercentUpdated(_votingQuorumPercent);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Registry address\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _registryAddress - address for new Registry contract\r\n     */\r\n    function setRegistryAddress(address _registryAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(_registryAddress != address(0x00), ERROR_INVALID_REGISTRY);\r\n\r\n        registry = Registry(_registryAddress);\r\n\r\n        emit RegistryAddressUpdated(_registryAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the max number of concurrent InProgress proposals\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _newMaxInProgressProposals - new value for maxInProgressProposals\r\n     */\r\n    function setMaxInProgressProposals(uint16 _newMaxInProgressProposals) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        require(\r\n            _newMaxInProgressProposals > 0,\r\n            \"Governance: Requires non-zero _newMaxInProgressProposals\"\r\n        );\r\n        maxInProgressProposals = _newMaxInProgressProposals;\r\n        emit MaxInProgressProposalsUpdated(_newMaxInProgressProposals);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the execution delay for a proposal\r\n     * @dev Only callable by self via _executeTransaction\r\n     * @param _newExecutionDelay - new value for executionDelay\r\n     */\r\n    function setExecutionDelay(uint256 _newExecutionDelay) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\r\n        // executionDelay does not have to be non-zero\r\n        executionDelay = _newExecutionDelay;\r\n        emit ExecutionDelayUpdated(_newExecutionDelay);\r\n    }\r\n\r\n    // ========================================= Guardian Actions =========================================\r\n\r\n    /**\r\n     * @notice Allows the guardianAddress to execute protocol actions\r\n     * @param _targetContractRegistryKey - key in registry of target contract\r\n     * @param _callValue - amount of wei if a token transfer is involved\r\n     * @param _functionSignature - function signature of the function to be executed if proposal is successful\r\n     * @param _callData - encoded value(s) to call function with if proposal is successful\r\n     */\r\n    function guardianExecuteTransaction(\r\n        bytes32 _targetContractRegistryKey,\r\n        uint256 _callValue,\r\n        string calldata _functionSignature,\r\n        bytes calldata _callData\r\n    ) external\r\n    {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            msg.sender == guardianAddress,\r\n            \"Governance: Only guardian.\"\r\n        );\r\n\r\n        // _targetContractRegistryKey must point to a valid registered contract\r\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\r\n        require(\r\n            targetContractAddress != address(0x00),\r\n            \"Governance: _targetContractRegistryKey must point to valid registered contract\"\r\n        );\r\n\r\n        // Signature cannot be empty\r\n        require(\r\n            bytes(_functionSignature).length != 0,\r\n            \"Governance: _functionSignature cannot be empty.\"\r\n        );\r\n\r\n        (bool success, bytes memory returnData) = _executeTransaction(\r\n            targetContractAddress,\r\n            _callValue,\r\n            _functionSignature,\r\n            _callData\r\n        );\r\n\r\n        require(success, \"Governance: Transaction failed.\");\r\n\r\n        emit GuardianTransactionExecuted(\r\n            targetContractAddress,\r\n            _callValue,\r\n            _functionSignature,\r\n            _callData,\r\n            returnData\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Change the guardian address\r\n     * @dev Only callable by current guardian\r\n     * @param _newGuardianAddress - new guardian address\r\n     */\r\n    function transferGuardianship(address _newGuardianAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(\r\n            msg.sender == guardianAddress,\r\n            \"Governance: Only guardian.\"\r\n        );\r\n\r\n        guardianAddress = _newGuardianAddress;\r\n\r\n        emit GuardianshipTransferred(_newGuardianAddress);\r\n    }\r\n\r\n    // ========================================= Getter Functions =========================================\r\n\r\n    /**\r\n     * @notice Get proposal information by proposal Id\r\n     * @param _proposalId - id of proposal\r\n     */\r\n    function getProposalById(uint256 _proposalId)\r\n    external view returns (\r\n        uint256 proposalId,\r\n        address proposer,\r\n        uint256 submissionBlockNumber,\r\n        bytes32 targetContractRegistryKey,\r\n        address targetContractAddress,\r\n        uint256 callValue,\r\n        string memory functionSignature,\r\n        bytes memory callData,\r\n        Outcome outcome,\r\n        uint256 voteMagnitudeYes,\r\n        uint256 voteMagnitudeNo,\r\n        uint256 numVotes\r\n    )\r\n    {\r\n        _requireIsInitialized();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        Proposal memory proposal = proposals[_proposalId];\r\n        return (\r\n            proposal.proposalId,\r\n            proposal.proposer,\r\n            proposal.submissionBlockNumber,\r\n            proposal.targetContractRegistryKey,\r\n            proposal.targetContractAddress,\r\n            proposal.callValue,\r\n            proposal.functionSignature,\r\n            proposal.callData,\r\n            proposal.outcome,\r\n            proposal.voteMagnitudeYes,\r\n            proposal.voteMagnitudeNo,\r\n            proposal.numVotes\r\n            /** @notice - votes mapping cannot be returned by external function */\r\n            /** @notice - voteMagnitudes mapping cannot be returned by external function */\r\n            /** @notice - returning contractHash leads to stack too deep compiler error, see getProposalTargetContractHash() */\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get proposal target contract hash by proposalId\r\n     * @dev This is a separate function because the getProposalById returns too many\r\n            variables already and by adding more, you get the error\r\n            `InternalCompilerError: Stack too deep, try using fewer variables`\r\n     * @param _proposalId - id of proposal\r\n     */\r\n    function getProposalTargetContractHash(uint256 _proposalId)\r\n    external view returns (bytes32)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        return (proposals[_proposalId].contractHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Get vote direction and vote magnitude for a given proposal and voter\r\n     * @param _proposalId - id of the proposal\r\n     * @param _voter - address of the voter we want to check\r\n     * @return returns vote direction and magnitude if valid vote, else default values\r\n     */\r\n    function getVoteInfoByProposalAndVoter(uint256 _proposalId, address _voter)\r\n    external view returns (Vote vote, uint256 voteMagnitude)\r\n    {\r\n        _requireIsInitialized();\r\n        _requireValidProposalId(_proposalId);\r\n\r\n        return (\r\n            proposals[_proposalId].votes[_voter],\r\n            proposals[_proposalId].voteMagnitudes[_voter]\r\n        );\r\n    }\r\n\r\n    /// @notice Get the contract Guardian address\r\n    function getGuardianAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return guardianAddress;\r\n    }\r\n\r\n    /// @notice Get the Staking address\r\n    function getStakingAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return stakingAddress;\r\n    }\r\n\r\n    /// @notice Get the ServiceProviderFactory address\r\n    function getServiceProviderFactoryAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return serviceProviderFactoryAddress;\r\n    }\r\n\r\n    /// @notice Get the DelegateManager address\r\n    function getDelegateManagerAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return delegateManagerAddress;\r\n    }\r\n\r\n    /// @notice Get the contract voting period\r\n    function getVotingPeriod() external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        return votingPeriod;\r\n    }\r\n\r\n    /// @notice Get the contract voting quorum percent\r\n    function getVotingQuorumPercent() external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        return votingQuorumPercent;\r\n    }\r\n\r\n    /// @notice Get the registry address\r\n    function getRegistryAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return address(registry);\r\n    }\r\n\r\n    /// @notice Used to check if is governance contract before setting governance address in other contracts\r\n    function isGovernanceAddress() external pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /// @notice Get the max number of concurrent InProgress proposals\r\n    function getMaxInProgressProposals() external view returns (uint16) {\r\n        _requireIsInitialized();\r\n\r\n        return maxInProgressProposals;\r\n    }\r\n\r\n    /// @notice Get the proposal execution delay\r\n    function getExecutionDelay() external view returns (uint256) {\r\n        _requireIsInitialized();\r\n\r\n        return executionDelay;\r\n    }\r\n\r\n    /// @notice Get the array of all InProgress proposal Ids\r\n    function getInProgressProposals() external view returns (uint256[] memory) {\r\n        _requireIsInitialized();\r\n\r\n        return inProgressProposals;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns false if any proposals in inProgressProposals array are evaluatable\r\n     *          Evaluatable = proposals with closed votingPeriod\r\n     * @dev Is public since its called internally in `submitProposal()` as well as externally in UI\r\n     */\r\n    function inProgressProposalsAreUpToDate() external view returns (bool) {\r\n        _requireIsInitialized();\r\n\r\n        // compare current block number against endBlockNumber of each proposal\r\n        for (uint256 i = 0; i < inProgressProposals.length; i++) {\r\n            if (\r\n                block.number >\r\n                (proposals[inProgressProposals[i]].submissionBlockNumber).add(votingPeriod).add(executionDelay)\r\n            ) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // ========================================= Internal Functions =========================================\r\n\r\n    /**\r\n     * @notice Execute a transaction attached to a governance proposal\r\n     * @dev We are aware of both potential re-entrancy issues and the risks associated with low-level solidity\r\n     *      function calls here, but have chosen to keep this code with those issues in mind. All governance\r\n     *      proposals go through a voting process, and all will be reviewed carefully to ensure that they\r\n     *      adhere to the expected behaviors of this call - but adding restrictions here would limit the ability\r\n     *      of the governance system to do required work in a generic way.\r\n     * @param _targetContractAddress - address of registry proxy contract to execute transaction on\r\n     * @param _callValue - amount of wei if a token transfer is involved\r\n     * @param _functionSignature - function signature of the function to be executed if proposal is successful\r\n     * @param _callData - encoded value(s) to call function with if proposal is successful\r\n     */\r\n    function _executeTransaction(\r\n        address _targetContractAddress,\r\n        uint256 _callValue,\r\n        string memory _functionSignature,\r\n        bytes memory _callData\r\n    ) internal returns (bool success, bytes memory returnData)\r\n    {\r\n        bytes memory encodedCallData = abi.encodePacked(\r\n            bytes4(keccak256(bytes(_functionSignature))),\r\n            _callData\r\n        );\r\n        (success, returnData) = (\r\n            // solium-disable-next-line security/no-call-value\r\n            _targetContractAddress.call.value(_callValue)(encodedCallData)\r\n        );\r\n\r\n        return (success, returnData);\r\n    }\r\n\r\n    function _increaseVoteMagnitudeYes(uint256 _proposalId, uint256 _voterStake) internal {\r\n        proposals[_proposalId].voteMagnitudeYes = (\r\n            proposals[_proposalId].voteMagnitudeYes.add(_voterStake)\r\n        );\r\n    }\r\n\r\n    function _increaseVoteMagnitudeNo(uint256 _proposalId, uint256 _voterStake) internal {\r\n        proposals[_proposalId].voteMagnitudeNo = (\r\n            proposals[_proposalId].voteMagnitudeNo.add(_voterStake)\r\n        );\r\n    }\r\n\r\n    function _decreaseVoteMagnitudeYes(uint256 _proposalId, uint256 _voterStake) internal {\r\n        proposals[_proposalId].voteMagnitudeYes = (\r\n            proposals[_proposalId].voteMagnitudeYes.sub(_voterStake)\r\n        );\r\n    }\r\n\r\n    function _decreaseVoteMagnitudeNo(uint256 _proposalId, uint256 _voterStake) internal {\r\n        proposals[_proposalId].voteMagnitudeNo = (\r\n            proposals[_proposalId].voteMagnitudeNo.sub(_voterStake)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Can make O(1) by storing index pointer in proposals mapping.\r\n     *      Requires inProgressProposals to be 1-indexed, since all proposals that are not present\r\n     *          will have pointer set to 0.\r\n     */\r\n    function _removeFromInProgressProposals(uint256 _proposalId) internal {\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < inProgressProposals.length; i++) {\r\n            if (inProgressProposals[i] == _proposalId) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Swap proposalId to end of array + pop (deletes last elem + decrements array length)\r\n        inProgressProposals[index] = inProgressProposals[inProgressProposals.length - 1];\r\n        inProgressProposals.pop();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if voting quorum percentage met for proposal, else false.\r\n     * @dev Quorum is met if total voteMagnitude * 100 / total active stake in Staking\r\n     * @dev Eventual multiplication overflow:\r\n     *      (proposal.voteMagnitudeYes + proposal.voteMagnitudeNo), with 100% staking participation,\r\n     *          can sum to at most the entire token supply of 10^27\r\n     *      With 7% annual token supply inflation, multiplication can overflow ~1635 years at the earliest:\r\n     *      log(2^256/(10^27*100))/log(1.07) ~= 1635\r\n     *\r\n     * @dev Note that quorum is evaluated based on total staked at proposal submission\r\n     *      not total staked at proposal evaluation, this is expected behavior\r\n     */\r\n    function _quorumMet(Proposal memory proposal, Staking stakingContract)\r\n    internal view returns (bool)\r\n    {\r\n        uint256 participation = (\r\n            (proposal.voteMagnitudeYes + proposal.voteMagnitudeNo)\r\n            .mul(100)\r\n            .div(stakingContract.totalStakedAt(proposal.submissionBlockNumber))\r\n        );\r\n        return participation >= votingQuorumPercent;\r\n    }\r\n\r\n    // ========================================= Private Functions =========================================\r\n\r\n    function _requireStakingAddressIsSet() private view {\r\n        require(\r\n            stakingAddress != address(0x00),\r\n            \"Governance: stakingAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireServiceProviderFactoryAddressIsSet() private view {\r\n        require(\r\n            serviceProviderFactoryAddress != address(0x00),\r\n            \"Governance: serviceProviderFactoryAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireDelegateManagerAddressIsSet() private view {\r\n        require(\r\n            delegateManagerAddress != address(0x00),\r\n            \"Governance: delegateManagerAddress is not set\"\r\n        );\r\n    }\r\n\r\n    function _requireValidProposalId(uint256 _proposalId) private view {\r\n        require(\r\n            _proposalId <= lastProposalId && _proposalId > 0,\r\n            \"Governance: Must provide valid non-zero _proposalId\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns active stake for address\r\n     *\r\n     * Active stake = (active deployer stake + active delegator stake)\r\n     *      active deployer stake = (direct deployer stake - locked deployer stake)\r\n     *          locked deployer stake = amount of pending decreaseStakeRequest for address\r\n     *      active delegator stake = (total delegator stake - locked delegator stake)\r\n     *          locked delegator stake = amount of pending undelegateRequest for address\r\n     */\r\n    function _calculateAddressActiveStake(address _address) private view returns (uint256) {\r\n        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\r\n        DelegateManager delegateManager = DelegateManager(delegateManagerAddress);\r\n\r\n        // Amount directly staked by address, if any, in ServiceProviderFactory\r\n        (uint256 directDeployerStake,,,,,) = spFactory.getServiceProviderDetails(_address);\r\n        // Amount of pending decreasedStakeRequest for address, if any, in ServiceProviderFactory\r\n        (uint256 lockedDeployerStake,) = spFactory.getPendingDecreaseStakeRequest(_address);\r\n        // active deployer stake = (direct deployer stake - locked deployer stake)\r\n        uint256 activeDeployerStake = directDeployerStake.sub(lockedDeployerStake);\r\n\r\n        // Total amount delegated by address, if any, in DelegateManager\r\n        uint256 totalDelegatorStake = delegateManager.getTotalDelegatorStake(_address);\r\n        // Amount of pending undelegateRequest for address, if any, in DelegateManager\r\n        (,uint256 lockedDelegatorStake, ) = delegateManager.getPendingUndelegateRequest(_address);\r\n        // active delegator stake = (total delegator stake - locked delegator stake)\r\n        uint256 activeDelegatorStake = totalDelegatorStake.sub(lockedDelegatorStake);\r\n\r\n        // activeStake = (activeDeployerStake + activeDelegatorStake)\r\n        uint256 activeStake = activeDeployerStake.add(activeDelegatorStake);\r\n\r\n        return activeStake;\r\n    }\r\n\r\n    // solium-disable security/no-inline-assembly\r\n    /**\r\n     * @notice Helper function to generate the code hash for a contract address\r\n     * @return contract code hash\r\n     */\r\n    function _getCodeHash(address _contract) private view returns (bytes32) {\r\n        bytes32 contractHash;\r\n        assembly {\r\n          contractHash := extcodehash(_contract)\r\n        }\r\n        return contractHash;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract EthRewardsManager is InitializableV2 {\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_TOKEN_NOT_CONTRACT = (\r\n        \"EthRewardsManager: token is not a contract\"\r\n    );\r\n    string private constant ERROR_WORMHOLE_NOT_CONTRACT = (\r\n        \"EthRewardsManager: wormhole is not a contract\"\r\n    );\r\n    string private constant ERROR_ONLY_GOVERNANCE = (\r\n        \"EthRewardsManager: Only governance\"\r\n    );\r\n\r\n    address private governanceAddress;\r\n\r\n    /// @dev ERC-20 token that will be used to stake with\r\n    ERC20 internal audiusToken;\r\n    Wormhole internal wormhole;\r\n    bytes32 internal recipient;\r\n\r\n    address[] internal antiAbuseOracleAddresses;\r\n\r\n    /**\r\n     * @notice Function to initialize the contract\r\n     * @param _tokenAddress - address of ERC20 token\r\n     * @param _governanceAddress - address for Governance proxy contract\r\n     * @param _wormholeAddress - address for Wormhole contract\r\n     * @param _recipient - solana address of recipient\r\n     * @param _antiAbuseOracleAddresses - addresses for anti abuse oracle\r\n     */\r\n    function initialize(\r\n        address _tokenAddress,\r\n        address _governanceAddress,\r\n        address _wormholeAddress,\r\n        bytes32 _recipient,\r\n        address[] memory _antiAbuseOracleAddresses\r\n    ) public initializer {\r\n        require(Address.isContract(_tokenAddress), ERROR_TOKEN_NOT_CONTRACT);\r\n        require(\r\n            Address.isContract(_wormholeAddress),\r\n            ERROR_WORMHOLE_NOT_CONTRACT\r\n        );\r\n        audiusToken = ERC20(_tokenAddress);\r\n        wormhole = Wormhole(_wormholeAddress);\r\n        recipient = _recipient;\r\n        antiAbuseOracleAddresses = _antiAbuseOracleAddresses;\r\n        _updateGovernanceAddress(_governanceAddress);\r\n        InitializableV2.initialize();\r\n    }\r\n\r\n    /**\r\n     * @notice Set the Governance address\r\n     * @dev Only callable by Governance address\r\n     * @param _governanceAddress - address for new Governance contract\r\n     */\r\n    function setGovernanceAddress(address _governanceAddress) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        _updateGovernanceAddress(_governanceAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the recipient address\r\n     * @dev Only callable by Governance address\r\n     * @param _recipient - address for new recipient\r\n     */\r\n    function setRecipientAddress(bytes32 _recipient) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        recipient = _recipient;\r\n    }\r\n\r\n    /**\r\n     * @notice Set antiAbuseOracleAddresses\r\n     * @dev Only callable by Governance address\r\n     * @param _antiAbuseOracleAddresses - values of new anti abuse oracle addresses\r\n     */\r\n    function setAntiAbuseOracleAddresses(address[] calldata _antiAbuseOracleAddresses) external {\r\n        _requireIsInitialized();\r\n\r\n        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\r\n        antiAbuseOracleAddresses = _antiAbuseOracleAddresses;\r\n    }\r\n\r\n    /* External functions */\r\n\r\n    /**\r\n     * @notice Transfers to solana\r\n     * @param arbiterFee - fee to pay wormhole arbiter\r\n     * @param _nonce - nonce for wormhole\r\n     */\r\n    function transferToSolana(uint256 arbiterFee, uint32 _nonce) external {\r\n        _requireIsInitialized();\r\n\r\n        uint256 balance = audiusToken.balanceOf(address(this));\r\n        audiusToken.approve(address(wormhole), balance);\r\n\r\n        wormhole.transferTokens(\r\n            address(audiusToken),\r\n            balance,\r\n            1,\r\n            recipient,\r\n            arbiterFee,\r\n            _nonce\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token used by the contract\r\n     * @return The token used by the contract\r\n     */\r\n    function token() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return address(audiusToken);\r\n    }\r\n\r\n    /// @notice Get the Governance address\r\n    function getGovernanceAddress() external view returns (address) {\r\n        _requireIsInitialized();\r\n\r\n        return governanceAddress;\r\n    }\r\n\r\n    /// @notice Get the recipient address\r\n    function getRecipientAddress() external view returns (bytes32) {\r\n        _requireIsInitialized();\r\n\r\n        return recipient;\r\n    }\r\n\r\n    /// @notice Get the anti abuse oracle addresses\r\n    function getAntiAbuseOracleAddresses() external view returns (address[] memory) {\r\n        _requireIsInitialized();\r\n\r\n        return antiAbuseOracleAddresses;\r\n    }\r\n\r\n    // ========================================= Internal Functions =========================================\r\n\r\n    /**\r\n     * @notice Set the governance address after confirming contract identity\r\n     * @param _governanceAddress - Incoming governance address\r\n     */\r\n    function _updateGovernanceAddress(address _governanceAddress) internal {\r\n        require(\r\n            Governance(_governanceAddress).isGovernanceAddress() == true,\r\n            \"EthRewardsManager: _governanceAddress is not a valid governance contract\"\r\n        );\r\n        governanceAddress = _governanceAddress;\r\n    }\r\n}"}}}