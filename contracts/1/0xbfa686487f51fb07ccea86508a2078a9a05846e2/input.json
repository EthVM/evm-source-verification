{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"AvsBGame.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity ^0.8.11;\r\n\r\n// @title AvsBGame\r\n/// @notice A Liar's Game: Vote by putting ETH behind A or B ... the side with the least votes gets all the ETH\r\n/// @author AvsB Team\r\n/// @dev Built using a Commit-Reveal scheme\r\ncontract AvsBGame {\r\n    /// ============ Types ============\r\n\r\n    // Possible votes (and Hidden before votes are revealed)\r\n    enum Choice {\r\n        Hidden,\r\n        A,\r\n        B\r\n    }\r\n\r\n    // A cryptographic committment to a certain vote\r\n    struct VoteCommit {\r\n        bytes32 commitment;\r\n        uint256 amount;\r\n        Choice choice;\r\n    }\r\n\r\n    /// ============ Immutable storage ============\r\n\r\n    uint256 public immutable voteDeadline = 1643702400; // Vote phase ends Feb 1, 2022\r\n    uint256 public immutable revealDeadline = 1643702400; // Reveal phase ends Feb 15, 2022\r\n    uint256 public immutable minVoteIncrement = 5e15; // 0.005 ETH\r\n    uint256 public immutable foundersFee = 20; // 5% fee (1/20th), paid out at reveal\r\n    address public immutable founderAddress =\r\n        0x7B91649D893B2e4Feef78b6891dE383d5a8491eE;\r\n\r\n    /// ============ Mutable storage ============\r\n\r\n    // Tracks vote commitments\r\n    mapping(address => VoteCommit) public votes;\r\n\r\n    // Tracks revealed votes, updated every reveal\r\n    // We need to track these because some votes may remain unrevealed\r\n    uint256 public revealedA = 0;\r\n    uint256 public revealedB = 0;\r\n\r\n    // Stores total prize pool (only updated during payout phase)\r\n    uint256 public prizePool = 0;\r\n\r\n    /// ============ Events ============\r\n\r\n    event Vote(address player, uint256 amount);\r\n    event Reveal(address player, Choice choice);\r\n    event Payout(address player, uint256 amount);\r\n\r\n    constructor() {}\r\n\r\n    /// ============ Functions ============\r\n\r\n    /// @notice Cast a vote without revealing the vote by posting a commitment\r\n    /// @param commitment Commitment to A or B, by commit-reveal scheme\r\n    function castHiddenVote(bytes32 commitment) external payable {\r\n        // Ensure vote is placed before vote deadline\r\n        require(\r\n            block.timestamp <= voteDeadline,\r\n            \"Cannot vote past the vote deadline.\"\r\n        );\r\n\r\n        // Ensure vote is greater than and a multiple of min vote increment\r\n        require(\r\n            msg.value >= minVoteIncrement && msg.value % minVoteIncrement == 0,\r\n            \"Vote value must be greater than and multiple of minimum vote amount.\"\r\n        );\r\n\r\n        // Ensure player has not voted before\r\n        require(votes[msg.sender].amount == 0, \"Cannot vote twice.\");\r\n\r\n        // Store the commitment for the commit-reveal scheme\r\n        votes[msg.sender] = VoteCommit(commitment, msg.value, Choice.Hidden);\r\n\r\n        // Emit Vote event\r\n        emit Vote(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Reveal a vote that was previously commited to\r\n    /// @param choice Choice that is being revealed by sender\r\n    /// @param blindingFactor Salt used by the voter in their previous vote commitment\r\n    function reveal(Choice choice, bytes32 blindingFactor) external {\r\n        // Ensure reveal is before reveal deadline (\"early\" reveals during voting period are technically permitted)\r\n        require(\r\n            block.timestamp <= revealDeadline,\r\n            \"Cannot reveal past the reveal deadline.\"\r\n        );\r\n\r\n        // Ensure reveal is either for choice A or B\r\n        require(\r\n            choice == Choice.A || choice == Choice.B,\r\n            \"Invalid choice, must reveal A or B.\"\r\n        );\r\n\r\n        // Ensure sender has not already revealed\r\n        require(votes[msg.sender].choice == Choice.Hidden, \"Already revealed.\");\r\n\r\n        // Check hash and reveal if correct\r\n        VoteCommit storage vote = votes[msg.sender];\r\n        require(\r\n            keccak256(abi.encodePacked(msg.sender, choice, blindingFactor)) ==\r\n                vote.commitment,\r\n            \"Invalid reveal, hash does not match committment.\"\r\n        );\r\n        vote.choice = choice;\r\n\r\n        // Update revealed vote counts\r\n        if (choice == Choice.A) {\r\n            revealedA += vote.amount;\r\n        } else {\r\n            revealedB += vote.amount;\r\n        }\r\n\r\n        // Emit reveal event\r\n        emit Reveal(msg.sender, choice);\r\n    }\r\n\r\n    /// @notice Claim payout at game end\r\n    function claimPayout() external {\r\n        // Ensure reveal deadline has passed before claiming payout\r\n        require(\r\n            block.timestamp > revealDeadline,\r\n            \"Cannot claim payout before reveal deadline has passed.\"\r\n        );\r\n\r\n        // Require that sender has revealed a vote on the winning side\r\n        VoteCommit memory senderVote = votes[msg.sender];\r\n        require(\r\n            senderVote.choice != Choice.Hidden,\r\n            \"Cannot claim payout since vote was not revealed.\"\r\n        );\r\n\r\n        // If first time being called, choose winner and take founder fee\r\n        Choice winner = getWinner();\r\n\r\n        // Require that sender is winner to claim funds\r\n        // If a tie, winner is returned as Choice.Hidden\r\n        require(\r\n            senderVote.choice == winner || winner == Choice.Hidden,\r\n            \"Cannot claim payout since did not win game.\"\r\n        );\r\n\r\n        // Claim share of winnings\r\n        uint256 denominator;\r\n        if (winner == Choice.A) {\r\n            denominator = revealedA;\r\n        } else if (winner == Choice.B) {\r\n            denominator = revealedB;\r\n        } else {\r\n            // Everybody wins\r\n            denominator = revealedA + revealedB;\r\n        }\r\n        uint256 winnings = (prizePool * senderVote.amount) / denominator;\r\n        payable(msg.sender).transfer(winnings);\r\n\r\n        // Emit payout event\r\n        emit Payout(msg.sender, winnings);\r\n    }\r\n\r\n    /// @notice Returns winner and pays founder's fee if first time, returns Hidden if tie\r\n    function getWinner() private returns (Choice) {\r\n        // Collect founder's fee if first time\r\n        if (prizePool == 0) {\r\n            collectFoundersFee();\r\n            // Set prize pool to be remaining funds in the contract\r\n            prizePool = address(this).balance;\r\n        }\r\n\r\n        // Choose winner\r\n        // In case one side did not reveal any votes, the other side winw\r\n        // One side must have revealed votes as required in claimPayout\r\n        if (revealedA == 0) {\r\n            return Choice.B;\r\n        } else if (revealedB == 0) {\r\n            return Choice.A;\r\n        } else if (revealedA < revealedB) {\r\n            return Choice.A;\r\n        } else if (revealedA > revealedB) {\r\n            return Choice.B;\r\n        } else {\r\n            return Choice.Hidden;\r\n        }\r\n    }\r\n\r\n    /// @notice Collects the founder's fee and updated prizePool, is only be called once\r\n    function collectFoundersFee() private {\r\n        // Collect fee\r\n        uint256 fee = address(this).balance / foundersFee;\r\n        payable(founderAddress).transfer(fee);\r\n\r\n        // Emit payout event\r\n        emit Payout(founderAddress, fee);\r\n    }\r\n}"}}}