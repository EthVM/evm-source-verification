{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "project:/contracts/verifiers/InputRootVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract InputRootVerifier {\n    \n    uint32 constant n =   65536;\n    uint16 constant nPublic =  3;\n    uint16 constant nLagrange = 3;\n    \n    uint256 constant Qmx = 5239641272780661067019647593094433621831784210830188410615579047685606344436;\n    uint256 constant Qmy = 590127180199629078112931406830285923515618198983008711101603993127794340800;\n    uint256 constant Qlx = 14774646374207572617863262573842812969676966463079318956395669870948662070132;\n    uint256 constant Qly = 1445513930834057820566104901947899544437614305699148494988541898566875629073;\n    uint256 constant Qrx = 11946356907798340089802051305703158951065464928066711032170978540302401953698;\n    uint256 constant Qry = 3669484296553414380911113807876415941906142507823260253092031510870156009476;\n    uint256 constant Qox = 1968894667702886147579528624451470356469094674798807957380845479268327010271;\n    uint256 constant Qoy = 19439249992947885592964019733501714331543097516210887875855673024555965930504;\n    uint256 constant Qcx = 3489576522905033842837886114134226953967572596046007833216440131729741226864;\n    uint256 constant Qcy = 15537305448250961154513638188298785740514381416196770199578176676522083791169;\n    uint256 constant S1x = 1910215278526554756770528418298770974914473579495408654104687584985083503671;\n    uint256 constant S1y = 3852535215961989167089764421525704254728279636494964483904878480930117140105;\n    uint256 constant S2x = 5666249636522751886569493329909933248900160180058536916737186399315391660616;\n    uint256 constant S2y = 9507044447973988536841744702016575585939260193171835491127693400464284901658;\n    uint256 constant S3x = 13988496487750665360189564504779534846597942821513475499043169118835894014;\n    uint256 constant S3y = 8368595650749250942194630392249622380165903393737046248499107341115428832183;\n    uint256 constant k1 = 2;\n    uint256 constant k2 = 3;\n    uint256 constant X2x1 = 21831381940315734285607113342023901060522397560371972897001948545212302161822;\n    uint256 constant X2x2 = 17231025384763736816414546592865244497437017442647097510447326538965263639101;\n    uint256 constant X2y1 = 2388026358213174446665280700919698872609886601280537296205114254867301080648;\n    uint256 constant X2y2 = 11507326595632554467052522095592665270651932854513688777769618397986436103170;\n    \n    uint256 constant q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant qf = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 constant w1 = 421743594562400382753388642386256516545992082196004333756405989743524594615;    \n    \n    uint256 constant G1x = 1;\n    uint256 constant G1y = 2;\n    uint256 constant G2x1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant G2x2 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant G2y1 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant G2y2 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint16 constant pA = 32;\n    uint16 constant pB = 96;\n    uint16 constant pC = 160;\n    uint16 constant pZ = 224;\n    uint16 constant pT1 = 288;\n    uint16 constant pT2 = 352;\n    uint16 constant pT3 = 416;\n    uint16 constant pWxi = 480;\n    uint16 constant pWxiw = 544;\n    uint16 constant pEval_a = 608;\n    uint16 constant pEval_b = 640;\n    uint16 constant pEval_c = 672;\n    uint16 constant pEval_s1 = 704;\n    uint16 constant pEval_s2 = 736;\n    uint16 constant pEval_zw = 768;\n    uint16 constant pEval_r = 800;\n    \n    uint16 constant pAlpha = 0;\n    uint16 constant pBeta = 32;\n    uint16 constant pGamma = 64;\n    uint16 constant pXi = 96;\n    uint16 constant pXin = 128;\n    uint16 constant pBetaXi = 160;\n    uint16 constant pV1 = 192;\n    uint16 constant pV2 = 224;\n    uint16 constant pV3 = 256;\n    uint16 constant pV4 = 288;\n    uint16 constant pV5 = 320;\n    uint16 constant pV6 = 352;\n    uint16 constant pU = 384;\n    uint16 constant pPl = 416;\n    uint16 constant pEval_t = 448;\n    uint16 constant pA1 = 480;\n    uint16 constant pB1 = 544;\n    uint16 constant pZh = 608;\n    uint16 constant pZhInv = 640;\n    \n    uint16 constant pEval_l1 = 672;\n    \n    uint16 constant pEval_l2 = 704;\n    \n    uint16 constant pEval_l3 = 736;\n    \n    \n    \n    uint16 constant lastMem = 768;\n\n\n    function verifyProof(bytes memory proof, uint[] memory pubSignals) external view returns (bool) {\n        assembly {\n            /////////\n            // Computes the inverse using the extended euclidean algorithm\n            /////////\n            function inverse(a, q) -> inv {\n                let t := 0     \n                let newt := 1\n                let r := q     \n                let newr := a\n                let quotient\n                let aux\n                \n                for { } newr { } {\n                    quotient := sdiv(r, newr)\n                    aux := sub(t, mul(quotient, newt))\n                    t:= newt\n                    newt:= aux\n                    \n                    aux := sub(r,mul(quotient, newr))\n                    r := newr\n                    newr := aux\n                }\n                \n                if gt(r, 1) { revert(0,0) }\n                if slt(t, 0) { t:= add(t, q) }\n\n                inv := t\n            }\n            \n            ///////\n            // Computes the inverse of an array of values\n            // See https://vitalik.ca/general/2018/07/21/starks_part_3.html in section where explain fields operations\n            //////\n            function inverseArray(pVals, n) {\n    \n                let pAux := mload(0x40)     // Point to the next free position\n                let pIn := pVals\n                let lastPIn := add(pVals, mul(n, 32))  // Read n elemnts\n                let acc := mload(pIn)       // Read the first element\n                pIn := add(pIn, 32)         // Point to the second element\n                let inv\n    \n                \n                for { } lt(pIn, lastPIn) { \n                    pAux := add(pAux, 32) \n                    pIn := add(pIn, 32)\n                } \n                {\n                    mstore(pAux, acc)\n                    acc := mulmod(acc, mload(pIn), q)\n                }\n                acc := inverse(acc, q)\n                \n                // At this point pAux pint to the next free position we substract 1 to point to the last used\n                pAux := sub(pAux, 32)\n                // pIn points to the n+1 element, we substract to point to n\n                pIn := sub(pIn, 32)\n                lastPIn := pVals  // We don't process the first element \n                for { } gt(pIn, lastPIn) { \n                    pAux := sub(pAux, 32) \n                    pIn := sub(pIn, 32)\n                } \n                {\n                    inv := mulmod(acc, mload(pAux), q)\n                    acc := mulmod(acc, mload(pIn), q)\n                    mstore(pIn, inv)\n                }\n                // pIn points to first element, we just set it.\n                mstore(pIn, acc)\n            }\n            \n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n            }\n            \n            function checkInput(pProof) {\n                if iszero(eq(mload(pProof), 800 )) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n                checkField(mload(add(pProof, pEval_a)))\n                checkField(mload(add(pProof, pEval_b)))\n                checkField(mload(add(pProof, pEval_c)))\n                checkField(mload(add(pProof, pEval_s1)))\n                checkField(mload(add(pProof, pEval_s2)))\n                checkField(mload(add(pProof, pEval_zw)))\n                checkField(mload(add(pProof, pEval_r)))\n\n                // Points are checked in the point operations precompiled smart contracts\n            }\n            \n            function calculateChallanges(pProof, pMem) {\n            \n                let a\n                let b\n                \n                b := mod(keccak256(add(pProof, pA), 192), q) \n                mstore( add(pMem, pBeta), b)\n                mstore( add(pMem, pGamma), mod(keccak256(add(pMem, pBeta), 32), q))\n                mstore( add(pMem, pAlpha), mod(keccak256(add(pProof, pZ), 64), q))\n                \n                a := mod(keccak256(add(pProof, pT1), 192), q)\n                mstore( add(pMem, pXi), a)\n                mstore( add(pMem, pBetaXi), mulmod(b, a, q))\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                a:= mulmod(a, a, q)\n                \n                mstore( add(pMem, pXin), a)\n                a:= mod(add(sub(a, 1),q), q)\n                mstore( add(pMem, pZh), a)\n                mstore( add(pMem, pZhInv), a)  // We will invert later together with lagrange pols\n                \n                let v1 := mod(keccak256(add(pProof, pEval_a), 224), q)\n                mstore( add(pMem, pV1), v1)\n                a := mulmod(v1, v1, q)\n                mstore( add(pMem, pV2), a)\n                a := mulmod(a, v1, q)\n                mstore( add(pMem, pV3), a)\n                a := mulmod(a, v1, q)\n                mstore( add(pMem, pV4), a)\n                a := mulmod(a, v1, q)\n                mstore( add(pMem, pV5), a)\n                a := mulmod(a, v1, q)\n                mstore( add(pMem, pV6), a)\n                \n                mstore( add(pMem, pU), mod(keccak256(add(pProof, pWxi), 128), q))\n            }\n            \n            function calculateLagrange(pMem) {\n\n                let w := 1                \n                \n                mstore(\n                    add(pMem, pEval_l1), \n                    mulmod(\n                        n, \n                        mod(\n                            add(\n                                sub(\n                                    mload(add(pMem, pXi)), \n                                    w\n                                ), \n                                q\n                            ),\n                            q\n                        ), \n                        q\n                    )\n                )\n                \n                w := mulmod(w, w1, q)\n                \n                \n                mstore(\n                    add(pMem, pEval_l2), \n                    mulmod(\n                        n, \n                        mod(\n                            add(\n                                sub(\n                                    mload(add(pMem, pXi)), \n                                    w\n                                ), \n                                q\n                            ),\n                            q\n                        ), \n                        q\n                    )\n                )\n                \n                w := mulmod(w, w1, q)\n                \n                \n                mstore(\n                    add(pMem, pEval_l3), \n                    mulmod(\n                        n, \n                        mod(\n                            add(\n                                sub(\n                                    mload(add(pMem, pXi)), \n                                    w\n                                ), \n                                q\n                            ),\n                            q\n                        ), \n                        q\n                    )\n                )\n                \n                \n                \n                inverseArray(add(pMem, pZhInv), 4 )\n                \n                let zh := mload(add(pMem, pZh))\n                w := 1\n                \n                \n                mstore(\n                    add(pMem, pEval_l1 ), \n                    mulmod(\n                        mload(add(pMem, pEval_l1 )),\n                        zh,\n                        q\n                    )\n                )\n                \n                \n                w := mulmod(w, w1, q)\n                \n                \n                \n                mstore(\n                    add(pMem, pEval_l2), \n                    mulmod(\n                        w,\n                        mulmod(\n                            mload(add(pMem, pEval_l2)),\n                            zh,\n                            q\n                        ),\n                        q\n                    )\n                )\n                \n                \n                w := mulmod(w, w1, q)\n                \n                \n                \n                mstore(\n                    add(pMem, pEval_l3), \n                    mulmod(\n                        w,\n                        mulmod(\n                            mload(add(pMem, pEval_l3)),\n                            zh,\n                            q\n                        ),\n                        q\n                    )\n                )\n                \n                \n                \n\n\n            }\n            \n            function calculatePl(pMem, pPub) {\n                let pl := 0\n                \n                 \n                pl := mod(\n                    add(\n                        sub(\n                            pl,  \n                            mulmod(\n                                mload(add(pMem, pEval_l1)),\n                                mload(add(pPub, 32)),\n                                q\n                            )\n                        ),\n                        q\n                    ),\n                    q\n                )\n                 \n                pl := mod(\n                    add(\n                        sub(\n                            pl,  \n                            mulmod(\n                                mload(add(pMem, pEval_l2)),\n                                mload(add(pPub, 64)),\n                                q\n                            )\n                        ),\n                        q\n                    ),\n                    q\n                )\n                 \n                pl := mod(\n                    add(\n                        sub(\n                            pl,  \n                            mulmod(\n                                mload(add(pMem, pEval_l3)),\n                                mload(add(pPub, 96)),\n                                q\n                            )\n                        ),\n                        q\n                    ),\n                    q\n                )\n                \n                \n                mstore(add(pMem, pPl), pl)\n                \n\n            }\n\n            function calculateT(pProof, pMem) {\n                let t\n                let t1\n                let t2\n                t := addmod(\n                    mload(add(pProof, pEval_r)), \n                    mload(add(pMem, pPl)), \n                    q\n                )\n                \n                t1 := mulmod(\n                    mload(add(pProof, pEval_s1)),\n                    mload(add(pMem, pBeta)),\n                    q\n                )\n\n                t1 := addmod(\n                    t1,\n                    mload(add(pProof, pEval_a)),\n                    q\n                )\n                \n                t1 := addmod(\n                    t1,\n                    mload(add(pMem, pGamma)),\n                    q\n                )\n\n                t2 := mulmod(\n                    mload(add(pProof, pEval_s2)),\n                    mload(add(pMem, pBeta)),\n                    q\n                )\n\n                t2 := addmod(\n                    t2,\n                    mload(add(pProof, pEval_b)),\n                    q\n                )\n                \n                t2 := addmod(\n                    t2,\n                    mload(add(pMem, pGamma)),\n                    q\n                )\n                \n                t1 := mulmod(t1, t2, q)\n                \n                t2 := addmod(\n                    mload(add(pProof, pEval_c)),\n                    mload(add(pMem, pGamma)),\n                    q\n                )\n\n                t1 := mulmod(t1, t2, q)\n                t1 := mulmod(t1, mload(add(pProof, pEval_zw)), q)\n                t1 := mulmod(t1, mload(add(pMem, pAlpha)), q)\n                \n                t2 := mulmod(\n                    mload(add(pMem, pEval_l1)), \n                    mload(add(pMem, pAlpha)), \n                    q\n                )\n\n                t2 := mulmod(\n                    t2, \n                    mload(add(pMem, pAlpha)), \n                    q\n                )\n\n                t1 := addmod(t1, t2, q)\n                \n                t := mod(sub(add(t, q), t1), q)\n                t := mulmod(t, mload(add(pMem, pZhInv)), q)\n                \n                mstore( add(pMem, pEval_t) , t)\n\n            }\n            \n            function g1_set(pR, pP) {\n                mstore(pR, mload(pP))\n                mstore(add(pR, 32), mload(add(pP,32)))\n            }\n\n            function g1_acc(pR, pP) {\n                let mIn := mload(0x40)\n                mstore(mIn, mload(pR))\n                mstore(add(mIn,32), mload(add(pR, 32)))\n                mstore(add(mIn,64), mload(pP))\n                mstore(add(mIn,96), mload(add(pP, 32)))\n\n                let success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n                \n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n            }\n\n            function g1_mulAcc(pR, pP, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, mload(pP))\n                mstore(add(mIn,32), mload(add(pP, 32)))\n                mstore(add(mIn,64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n                \n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n                \n                mstore(add(mIn,64), mload(pR))\n                mstore(add(mIn,96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n                \n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n                \n            }\n\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn,32), y)\n                mstore(add(mIn,64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n                \n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n                \n                mstore(add(mIn,64), mload(pR))\n                mstore(add(mIn,96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n                \n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n            }\n\n            function g1_mulSetC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn,32), y)\n                mstore(add(mIn,64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, pR, 64)\n                \n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0,0x20)\n                }\n            }\n\n\n            function calculateA1(pProof, pMem) {\n                let p := add(pMem, pA1)\n                g1_set(p, add(pProof, pWxi))\n                g1_mulAcc(p, add(pProof, pWxiw), mload(add(pMem, pU)))\n            }\n            \n            \n            function calculateB1(pProof, pMem) {\n                let s\n                let s1\n                let p := add(pMem, pB1)\n                \n                // Calculate D\n                s := mulmod( mload(add(pProof, pEval_a)), mload(add(pMem, pV1)), q)\n                g1_mulSetC(p, Qlx, Qly, s)\n\n                s := mulmod( s, mload(add(pProof, pEval_b)), q)                \n                g1_mulAccC(p, Qmx, Qmy, s)\n\n                s := mulmod( mload(add(pProof, pEval_b)), mload(add(pMem, pV1)), q)\n                g1_mulAccC(p, Qrx, Qry, s)\n                \n                s := mulmod( mload(add(pProof, pEval_c)), mload(add(pMem, pV1)), q)\n                g1_mulAccC(p, Qox, Qoy, s)\n\n                s :=mload(add(pMem, pV1))\n                g1_mulAccC(p, Qcx, Qcy, s)\n\n                s := addmod(mload(add(pProof, pEval_a)), mload(add(pMem, pBetaXi)), q)\n                s := addmod(s, mload(add(pMem, pGamma)), q)\n                s1 := mulmod(k1, mload(add(pMem, pBetaXi)), q)\n                s1 := addmod(s1, mload(add(pProof, pEval_b)), q)\n                s1 := addmod(s1, mload(add(pMem, pGamma)), q)\n                s := mulmod(s, s1, q)\n                s1 := mulmod(k2, mload(add(pMem, pBetaXi)), q)\n                s1 := addmod(s1, mload(add(pProof, pEval_c)), q)\n                s1 := addmod(s1, mload(add(pMem, pGamma)), q)\n                s := mulmod(s, s1, q)\n                s := mulmod(s, mload(add(pMem, pAlpha)), q)\n                s := mulmod(s, mload(add(pMem, pV1)), q)\n                s1 := mulmod(mload(add(pMem, pEval_l1)), mload(add(pMem, pAlpha)), q)\n                s1 := mulmod(s1, mload(add(pMem, pAlpha)), q)\n                s1 := mulmod(s1, mload(add(pMem, pV1)), q)\n                s := addmod(s, s1, q)\n                s := addmod(s, mload(add(pMem, pU)), q)\n                g1_mulAcc(p, add(pProof, pZ), s)\n                \n                s := mulmod(mload(add(pMem, pBeta)), mload(add(pProof, pEval_s1)), q)\n                s := addmod(s, mload(add(pProof, pEval_a)), q)\n                s := addmod(s, mload(add(pMem, pGamma)), q)\n                s1 := mulmod(mload(add(pMem, pBeta)), mload(add(pProof, pEval_s2)), q)\n                s1 := addmod(s1, mload(add(pProof, pEval_b)), q)\n                s1 := addmod(s1, mload(add(pMem, pGamma)), q)\n                s := mulmod(s, s1, q)\n                s := mulmod(s, mload(add(pMem, pAlpha)), q)\n                s := mulmod(s, mload(add(pMem, pV1)), q)\n                s := mulmod(s, mload(add(pMem, pBeta)), q)\n                s := mulmod(s, mload(add(pProof, pEval_zw)), q)\n                s := mod(sub(q, s), q)\n                g1_mulAccC(p, S3x, S3y, s)\n\n\n                // calculate F\n                g1_acc(p , add(pProof, pT1))\n\n                s := mload(add(pMem, pXin))\n                g1_mulAcc(p, add(pProof, pT2), s)\n                \n                s := mulmod(s, s, q)\n                g1_mulAcc(p, add(pProof, pT3), s)\n                \n                g1_mulAcc(p, add(pProof, pA), mload(add(pMem, pV2)))\n                g1_mulAcc(p, add(pProof, pB), mload(add(pMem, pV3)))\n                g1_mulAcc(p, add(pProof, pC), mload(add(pMem, pV4)))\n                g1_mulAccC(p, S1x, S1y, mload(add(pMem, pV5)))\n                g1_mulAccC(p, S2x, S2y, mload(add(pMem, pV6)))\n                \n                // calculate E\n                s := mload(add(pMem, pEval_t))\n                s := addmod(s, mulmod(mload(add(pProof, pEval_r)), mload(add(pMem, pV1)), q), q)\n                s := addmod(s, mulmod(mload(add(pProof, pEval_a)), mload(add(pMem, pV2)), q), q)\n                s := addmod(s, mulmod(mload(add(pProof, pEval_b)), mload(add(pMem, pV3)), q), q)\n                s := addmod(s, mulmod(mload(add(pProof, pEval_c)), mload(add(pMem, pV4)), q), q)\n                s := addmod(s, mulmod(mload(add(pProof, pEval_s1)), mload(add(pMem, pV5)), q), q)\n                s := addmod(s, mulmod(mload(add(pProof, pEval_s2)), mload(add(pMem, pV6)), q), q)\n                s := addmod(s, mulmod(mload(add(pProof, pEval_zw)), mload(add(pMem, pU)), q), q)\n                s := mod(sub(q, s), q)\n                g1_mulAccC(p, G1x, G1y, s)\n                \n                \n                // Last part of B\n                s := mload(add(pMem, pXi))\n                g1_mulAcc(p, add(pProof, pWxi), s)\n\n                s := mulmod(mload(add(pMem, pU)), mload(add(pMem, pXi)), q)\n                s := mulmod(s, w1, q)\n                g1_mulAcc(p, add(pProof, pWxiw), s)\n\n            }\n            \n            function checkPairing(pMem) -> isOk {\n                let mIn := mload(0x40)\n                mstore(mIn, mload(add(pMem, pA1)))\n                mstore(add(mIn,32), mload(add(add(pMem, pA1), 32)))\n                mstore(add(mIn,64), X2x2)\n                mstore(add(mIn,96), X2x1)\n                mstore(add(mIn,128), X2y2)\n                mstore(add(mIn,160), X2y1)\n                mstore(add(mIn,192), mload(add(pMem, pB1)))\n                let s := mload(add(add(pMem, pB1), 32))\n                s := mod(sub(qf, s), qf)\n                mstore(add(mIn,224), s)\n                mstore(add(mIn,256), G2x2)\n                mstore(add(mIn,288), G2x1)\n                mstore(add(mIn,320), G2y2)\n                mstore(add(mIn,352), G2y1)\n                \n                let success := staticcall(sub(gas(), 2000), 8, mIn, 384, mIn, 0x20)\n                \n                isOk := and(success, mload(mIn))\n            }\n            \n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, lastMem))\n            \n            checkInput(proof)\n            calculateChallanges(proof, pMem)\n            calculateLagrange(pMem)\n            calculatePl(pMem, pubSignals)\n            calculateT(proof, pMem)\n            calculateA1(proof, pMem)\n            calculateB1(proof, pMem)\n            let isValid := checkPairing(pMem)\n            \n            mstore(0x40, sub(pMem, lastMem))\n            mstore(0, isValid)\n            return(0,0x20)\n        }\n        \n    }\n}\n"
    }
  }
}