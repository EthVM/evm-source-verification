{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/unbase.sol":{"content":"pragma solidity 0.6.12;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 decimals_) internal {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\r\ninterface IUniswapSync {\r\n    function sync() external;\r\n}\r\n\r\n/**\r\n * @title UNBASE ERC20 token\r\n *      UNBASE is a normal ERC20 token, but its supply can be adjusted by splitting \r\n *      tokens proportionally across all wallets (forked Base Protocol's logic), and \r\n *      it reflects a transaction fee directly into all holder's wallet seemlessly \r\n *      without any transfer (forked Reflect's logic).\r\n *\r\n *      UNBASE balances are internally represented with a hidden denomination, 'shares'.\r\n *      The circulating supply of 'shares' decrease over time due to the transaction fee.\r\n *      The UNBASE balance is then reflected from the share balance (using a conversion rate\r\n *      between 'shares' and 'UNBASE' taking into account the circulating supply). Exchanges' \r\n *      wallets such as the Uniswap Pool are excluded from the circulating supply, therefore \r\n *      only holders are earning from the transaction fee. \r\n * \r\n *      We also support splitting the currency in expansion by modifying the UNBASE total supply\r\n *      as well as the excluded wallets' balances, allowing the supply to contract and the price \r\n *      to go up at each rebase event.\r\n */\r\ncontract UnbaseToken is ERC20, Ownable {\r\n    // PLEASE READ BEFORE CHANGING ANY ACCOUNTING OR MATH\r\n    // Anytime there is division, there is a risk of numerical instability from rounding errors. In\r\n    // order to minimize this risk, we adhere to the following guidelines:\r\n    // 1) The conversion rate adopted is the number of shares that equals 1 UNBASE.\r\n    //    The inverse rate must not be used--totalShares is always the numerator and _totalSupply is\r\n    //    always the denominator. (i.e. If you want to convert shares to UNBASE instead of\r\n    //    multiplying by the inverse rate, you should divide by the normal rate)\r\n    // 2) Share balances converted into UnbaseToken are always rounded down (truncated).\r\n    //\r\n    // We make the following guarantees:\r\n    // - If address 'A' transfers x UnbaseToken to address 'B'. A's resulting external balance will\r\n    //   be decreased by precisely x UnbaseToken, and B's external balance will be precisely\r\n    //   increased by x UnbaseToken.\r\n    //\r\n    // We do not guarantee that the sum of all balances equals the result of calling totalSupply().\r\n    // This is because, for any conversion function 'f()' that has non-zero rounding error,\r\n    // f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn).\r\n    using SafeMath for uint256;\r\n\r\n    event LogRebase(uint256 indexed _epoch, uint256 totalSupply);\r\n    event LogUserBanStatusUpdated(address user, bool banned);\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        require(to != address(this));\r\n        _;\r\n    }\r\n\r\n    uint256 private constant DECIMALS = 18;\r\n    uint256 private constant MAX_UINT256 = ~uint256(0);\r\n    uint256 private constant INITIAL_SUPPLY = 1 * 10**6 * 10**DECIMALS;\r\n    uint256 private constant INITIAL_SHARES = (MAX_UINT256) - (MAX_UINT256 % INITIAL_SUPPLY);\r\n\r\n    uint256 private _totalShares;\r\n    uint256 private _totalSupply;\r\n    address public _unbaseUniswapLPContract;\r\n\r\n    uint256 private _epoch; \r\n    uint256 public _unbasePercent = 15;         // 15 = 15%. At each rebase event, _totalSupply is reduced by unbasePercent. Value can be modified by Owner.\r\n    uint256 public _transferFee = 0;            // 3 = 3%. For each transfer, the tax (_transferFee * amount) is reflected seamlessly in all holders' balances. Value can be modified by Owner.\r\n    uint256 private _unbaseFeeTotal;            \r\n    \r\n    mapping(address => uint256) private _shareBalances;\r\n    mapping (address => uint256) private _unbaseBalances;    \r\n    mapping(address => bool) public bannedUsers;\r\n    mapping (address => mapping (address => uint256)) private _allowedUNBASE;       // This is denominated in UnbaseToken, because the shares-UNBASE conversion might change before it's fully paid.\r\n\r\n    uint256 public antiBotTimer;\r\n    bool public transfersPaused;\r\n    bool public rebasesPaused;\r\n\r\n    mapping(address => bool) public transferPauseExemptList;\r\n\r\n    mapping (address => bool) private _isExcluded;\r\n    address[] private _excluded;\r\n\r\n\r\n    constructor() public ERC20(\"Unbase Protocol\", \"UNB\") { \r\n        _totalShares = INITIAL_SHARES;\r\n        _totalSupply = INITIAL_SUPPLY;\r\n        _shareBalances[owner()] = _totalShares;\r\n\r\n        // Ban the Kucoin hacker\r\n        bannedUsers[0xeB31973E0FeBF3e3D7058234a5eBbAe1aB4B8c23] = true;\r\n\r\n        emit Transfer(address(0x0), owner(), _totalSupply);\r\n  }\r\n  \r\n\r\n        \r\n    // After that limit are the functions from Base Protocol's contract,\r\n    // modified to allow a seemless rebase of the supply once a day.\r\n    // The transfer() and transferFrom() functions are not included as \r\n    // they derive mostly from Reflect's logic.\r\n\r\n    function setAntiBotTimer()\r\n        public\r\n        onlyOwner\r\n    {\r\n        antiBotTimer = now;\r\n    }\r\n\r\n    function setTransfersPaused(bool _transfersPaused)\r\n        public\r\n        onlyOwner\r\n    {\r\n        transfersPaused = _transfersPaused;\r\n    }\r\n\r\n    function setTransferPauseExempt(address user, bool exempt)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (exempt) {\r\n            transferPauseExemptList[user] = true;\r\n        } else {\r\n            delete transferPauseExemptList[user];\r\n        }\r\n    }\r\n\r\n    function setRebasesPaused(bool _rebasesPaused)\r\n        public\r\n        onlyOwner\r\n    {\r\n        rebasesPaused = _rebasesPaused;\r\n    }\r\n\r\n    function setUnbasePercent(uint256 _newUnbasePercent)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _unbasePercent = _newUnbasePercent;\r\n    }\r\n    \r\n    function setTransferFee(uint256 _newTransferFee)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _transferFee = _newTransferFee;\r\n    }\r\n    \r\n    function setUnbaseUniswapLPContract(address _newUnbaseUniswapLPContract)\r\n        public\r\n        onlyOwner\r\n    {\r\n        _unbaseUniswapLPContract = _newUnbaseUniswapLPContract;\r\n    }\r\n    \r\n    function rebase()\r\n        public\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        require(!rebasesPaused, \"rebases paused\");\r\n        \r\n        _totalSupply = _totalSupply.sub(_totalSupply.mul(_unbasePercent).div(100));\r\n        _unbaseFeeTotal = _unbaseFeeTotal.sub(_unbaseFeeTotal.mul(_unbasePercent).div(100));\r\n        // We also modify the UNBASE supply held in excluded accounts to correctly reflect the circulating supply after the rebase event //\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_unbaseBalances[_excluded[i]] > 0) {\r\n                _unbaseBalances[_excluded[i]] = _unbaseBalances[_excluded[i]].sub(_unbaseBalances[_excluded[i]].mul(_unbasePercent).div(100));\r\n            }\r\n        }\r\n        _epoch = _epoch.add(1);\r\n\r\n        emit LogRebase(_epoch, _totalSupply);\r\n        IUniswapSync(_unbaseUniswapLPContract).sync();\r\n        return _totalSupply;\r\n    }\r\n\r\n    function getTotalShares()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _totalShares;\r\n    }\r\n\r\n    function sharesOf(address user)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _shareBalances[user];\r\n    }\r\n\r\n    function setUserBanStatus(address user, bool banned)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (banned) {\r\n            bannedUsers[user] = true;\r\n        } else {\r\n            delete bannedUsers[user];\r\n        }\r\n        emit LogUserBanStatusUpdated(user, banned);\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) \r\n        public \r\n        override(ERC20) \r\n        validRecipient(recipient)\r\n        returns (bool) \r\n    {\r\n        require(bannedUsers[msg.sender] == false, \"you are banned\");\r\n        require(!transfersPaused || transferPauseExemptList[msg.sender], \"paused\");\r\n        require(now.sub(antiBotTimer) >= 300 || amount <= 2000 * 10**DECIMALS, \"Max buy 2000 UNB right after launch\");\r\n        \r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner_, address spender)\r\n        public\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowedUNBASE[owner_][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(!transfersPaused || transferPauseExemptList[msg.sender], \"paused\");\r\n\r\n        _allowedUNBASE[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) \r\n        public \r\n        override \r\n        validRecipient(recipient)\r\n        returns (bool) \r\n    {\r\n        require(bannedUsers[msg.sender] == false, \"you are banned\");\r\n        require(!transfersPaused || transferPauseExemptList[msg.sender], \"paused\");\r\n        \r\n        _transfer(sender, recipient, amount);\r\n        approve(sender, _allowedUNBASE[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(!transfersPaused || transferPauseExemptList[msg.sender], \"paused\");\r\n\r\n        _allowedUNBASE[msg.sender][spender] = _allowedUNBASE[msg.sender][spender].add(addedValue);\r\n        emit Approval(msg.sender, spender, _allowedUNBASE[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(!transfersPaused || transferPauseExemptList[msg.sender], \"paused\");\r\n\r\n        uint256 oldValue = _allowedUNBASE[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedUNBASE[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedUNBASE[msg.sender][spender] = oldValue.sub(subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, spender, _allowedUNBASE[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n        \r\n    // After that limit are the functions implementing Reflect's logic to\r\n    // distribute transaction fees to all holders seemlessly.\r\n    // It includes the _transfer() and transferFrom() functions implementing \r\n    // both Base Protocol and Reflect's logic. \r\n    \r\n    \r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _unbaseBalances[account];\r\n        return tokenFromReflection(_shareBalances[account]);\r\n    }\r\n\r\n    function isExcluded(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n\r\n    function totalFees() public view returns (uint256) {\r\n        return _unbaseFeeTotal;\r\n    }\r\n\r\n    function reflect(uint256 unbaseAmount) public {\r\n        address sender = _msgSender();\r\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\r\n        (uint256 shareAmount,,,,) = _getValues(unbaseAmount);\r\n        _shareBalances[sender] = _shareBalances[sender].sub(shareAmount);\r\n        _totalShares = _totalShares.sub(shareAmount);\r\n        _unbaseFeeTotal = _unbaseFeeTotal.add(unbaseAmount);\r\n    }\r\n\r\n    function reflectionFromToken(uint256 unbaseAmount, bool deductTransferFee) public view returns(uint256) {\r\n        require(unbaseAmount <= _totalSupply, \"Amount must be less than supply\");\r\n        if (!deductTransferFee) {\r\n            (uint256 shareAmount,,,,) = _getValues(unbaseAmount);\r\n            return shareAmount;\r\n        } else {\r\n            (,uint256 shareTransferAmount,,,) = _getValues(unbaseAmount);\r\n            return shareTransferAmount;\r\n        }\r\n    }\r\n\r\n    function tokenFromReflection(uint256 shareAmount) public view returns(uint256) {\r\n        require(shareAmount <= _totalShares, \"Amount must be less than _totalShares\");\r\n        uint256 currentRate = _getRateForReflection();\r\n        return shareAmount.div(currentRate);\r\n    }\r\n\r\n    function excludeAccount(address account) external onlyOwner() {\r\n        require(!_isExcluded[account], \"Account is already excluded\");\r\n        if(_shareBalances[account] > 0) {\r\n            _unbaseBalances[account] = tokenFromReflection(_shareBalances[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n    function includeAccount(address account) external onlyOwner() {\r\n        require(_isExcluded[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _unbaseBalances[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal override(ERC20) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n            _transferFromExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n            _transferToExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n            _transferStandard(sender, recipient, amount);\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n            _transferBothExcluded(sender, recipient, amount);\r\n        } else {\r\n            _transferStandard(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 unbaseAmount) private {\r\n        (uint256 shareAmount, uint256 shareTransferAmount, uint256 shareFee, uint256 unbaseTransferAmount, uint256 unbaseFee) = _getValues(unbaseAmount);\r\n        _shareBalances[sender] = _shareBalances[sender].sub(shareAmount);\r\n        _shareBalances[recipient] = _shareBalances[recipient].add(shareTransferAmount);       \r\n        _reflectFee(shareFee, unbaseFee);\r\n        emit Transfer(sender, recipient, unbaseTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 unbaseAmount) private {\r\n        (uint256 shareAmount, uint256 shareTransferAmount, uint256 shareFee, uint256 unbaseTransferAmount, uint256 unbaseFee) = _getValues(unbaseAmount);\r\n        _shareBalances[sender] = _shareBalances[sender].sub(shareAmount);\r\n        _unbaseBalances[recipient] = _unbaseBalances[recipient].add(unbaseTransferAmount);\r\n        _shareBalances[recipient] = _shareBalances[recipient].add(shareTransferAmount);           \r\n        _reflectFee(shareFee, unbaseFee);\r\n        emit Transfer(sender, recipient, unbaseTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 unbaseAmount) private {\r\n        (uint256 shareAmount, uint256 shareTransferAmount, uint256 shareFee, uint256 unbaseTransferAmount, uint256 unbaseFee) = _getValues(unbaseAmount);\r\n        _unbaseBalances[sender] = _unbaseBalances[sender].sub(unbaseAmount);\r\n        _shareBalances[sender] = _shareBalances[sender].sub(shareAmount);\r\n        _shareBalances[recipient] = _shareBalances[recipient].add(shareTransferAmount);   \r\n        _reflectFee(shareFee, unbaseFee);\r\n        emit Transfer(sender, recipient, unbaseTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 unbaseAmount) private {\r\n        (uint256 shareAmount, uint256 shareTransferAmount, uint256 shareFee, uint256 unbaseTransferAmount, uint256 unbaseFee) = _getValues(unbaseAmount);\r\n        _unbaseBalances[sender] = _unbaseBalances[sender].sub(unbaseAmount);\r\n        _shareBalances[sender] = _shareBalances[sender].sub(shareAmount);\r\n        _unbaseBalances[recipient] = _unbaseBalances[recipient].add(unbaseTransferAmount);\r\n        _shareBalances[recipient] = _shareBalances[recipient].add(shareTransferAmount);        \r\n        _reflectFee(shareFee, unbaseFee);\r\n        emit Transfer(sender, recipient, unbaseTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 shareFee, uint256 unbaseFee) private {\r\n        _totalShares = _totalShares.sub(shareFee);\r\n        _unbaseFeeTotal = _unbaseFeeTotal.add(unbaseFee);\r\n    }\r\n\r\n    function _getValues(uint256 unbaseAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\r\n        (uint256 unbaseTransferAmount, uint256 unbaseFee) = _getTValues(unbaseAmount);\r\n        uint256 currentRate =  _getRateForReflection();\r\n        (uint256 shareAmount, uint256 shareTransferAmount, uint256 shareFee) = _getRValues(unbaseAmount, unbaseFee, currentRate);\r\n        return (shareAmount, shareTransferAmount, shareFee, unbaseTransferAmount, unbaseFee);\r\n    }\r\n\r\n    function _getTValues(uint256 unbaseAmount) private view returns (uint256, uint256) {\r\n        uint256 unbaseFee = unbaseAmount.div(100).mul(_transferFee);\r\n        uint256 unbaseTransferAmount = unbaseAmount.sub(unbaseFee);\r\n        return (unbaseTransferAmount, unbaseFee);\r\n    }\r\n\r\n    function _getRValues(uint256 unbaseAmount, uint256 unbaseFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n        uint256 shareAmount = unbaseAmount.mul(currentRate);\r\n        uint256 shareFee = unbaseFee.mul(currentRate);\r\n        uint256 shareTransferAmount = shareAmount.sub(shareFee);\r\n        return (shareAmount, shareTransferAmount, shareFee);\r\n    }\r\n\r\n    function _getRateForReflection() private view returns(uint256) {\r\n        (uint256 shareSupply, uint256 unbaseSupply) = _getCurrentSupplyForReflection();\r\n        return shareSupply.div(unbaseSupply);\r\n    }\r\n\r\n    function _getCurrentSupplyForReflection() private view returns(uint256, uint256) {\r\n        uint256 shareSupply = _totalShares;\r\n        uint256 unbaseSupply = _totalSupply;      \r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_shareBalances[_excluded[i]] > shareSupply || _unbaseBalances[_excluded[i]] > unbaseSupply) return (_totalShares, _totalSupply);\r\n            shareSupply = shareSupply.sub(_shareBalances[_excluded[i]]);\r\n            unbaseSupply = unbaseSupply.sub(_unbaseBalances[_excluded[i]]);\r\n        }\r\n        if (shareSupply < _totalShares.div(_totalSupply)) return (_totalShares, _totalSupply);\r\n        return (shareSupply, unbaseSupply);\r\n    }\r\n}"}}}