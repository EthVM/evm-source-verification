{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/5/Universe.sol":{"content":"// SPDX-License-Identifier: MIT\n//values = [100, 100, 100, 100, 100, 100, 100];\n//stakedTokens = [\"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\", \"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\", \"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\", \"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\", \"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\", \"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\", \"0x34b035b7e7f9cb6f4083672f2d9f679217774fd6\"];\npragma solidity >=0.4.0 <=0.8.0;\n\n// import \"./Oracle_Wrapper.sol\";\n// Oracle_Wrapper_address = 0xB87c7158Cd83FC8f3300802AD9602B5569819f9a;\n\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ninterface Token {\n    function transferOwnership(address newOwner) external;\n    function stop() external;\n    function start() external;\n    function close() external;\n    function decimals() external view returns(uint256);\n    function symbol() external view returns(string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    // function transfer(address to, uint256 value) external;\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function mint( address to, uint256 value ) external returns (bool);\n    function increaseApproval(address spender, uint addedValue) external returns (bool);\n    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\n    function burn(uint256 _value) external;\n    function burnTokens(address who,uint256 _value) external;\n}\n\n//change the name to universe\ncontract Universe {\n    using SafeMath for uint;\n    address public owner;\n    Token token;\n    // OracleWrapper oracle;\n    \n    struct UserDetail {\n        uint256 id;\n        address referrer;\n        uint256 etherReceived;\n        address[] rewardTokenAddresses;\n        mapping (uint8 => LevelDetail) levels;\n        mapping (address => uint256) tokenRewards;\n    }\n    \n    struct LevelDetail {\n        uint256 income;\n        uint256 levelReferrals;\n        mapping (address => bool) isReferral;\n        bool activeStatus;\n    }\n    \n    struct StakingTokenDetail {\n        address tokenAddress;\n        uint256 amountToStake;\n    }\n    \n    struct RewardTokenDetail {\n        uint256 currentBalance;\n        uint256 lastBalance;\n    }\n    \n    uint256 currentUserId;\n    uint8 public Last_Level;\n    uint8 taxPercentage;//check the uint type for this\n    uint8 commission;\n    uint8[] levelRate;\n    uint256 missedEthers;\n    address[] missedTokenAddresses;\n    mapping (address => uint256) missedTokenRewards;\n    address public taxTokenAddress;\n    address public oracleWrapperAddress;\n    mapping (address => UserDetail) public users;\n    mapping (uint256 => address) public userIds;\n    mapping (uint8 => StakingTokenDetail) public stakedTokens;\n    mapping (address => RewardTokenDetail) public rewardTokens;\n    \n    event Registration(address indexed userAddress, address indexed referrerAddress, uint256 userId, uint256 referrerId);\n    event LevelActivated(address indexed userAddress, uint8 level, address indexed tokenStaked, uint256 amount);\n    event TokenUnstaked(address indexed userAddress, uint8 level, address indexed tokenUnstaked, uint256 amount);\n    event LevelIncome(address indexed _from, address indexed receiver, uint8 level, uint256 amount, uint256 levelReferralCount);\n    event IncomeWithdrawn(address indexed receiver, address indexed tokenAddress, uint256 amount);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner has the access\");\n        _;\n    }\n    \n    constructor(address ownerAddress) public {\n        owner = ownerAddress;\n        commission = 10;\n        Last_Level = 7;\n        // oracle = OracleWrapper(oracleWrapperAddress);\n        currentUserId++;\n        levelRate = [30, 20, 10, 10, 10, 10, 10];\n        \n        UserDetail memory user = UserDetail({\n           id: currentUserId,\n           referrer: address(0),\n           etherReceived: uint256(0),\n           rewardTokenAddresses: new address[](0)\n        });\n        \n        users[owner] = user;\n        userIds[currentUserId] = owner;\n        for (uint8 i=1; i<=Last_Level; i++) {\n            users[owner].levels[i].activeStatus = true;\n        }\n        currentUserId++;\n        \n    }\n    \n    receive() external payable {\n        if(msg.data.length == 0) {\n            if (isUserExists(tx.origin)) {\n                levelIncome(tx.origin, users[tx.origin].referrer, address(0), msg.value, true);\n            } else {\n                missedEthers = missedEthers.add(msg.value);\n            }\n        }\n    }\n    \n    function registration(address referrerAddress) external {\n        UserDetail memory user = UserDetail({\n           id: currentUserId,\n           referrer: referrerAddress,\n           etherReceived: uint256(0),\n           rewardTokenAddresses: new address[](0)\n        });\n        \n        users[msg.sender] = user;\n        userIds[currentUserId] = msg.sender;\n        currentUserId++;\n        emit Registration(msg.sender, referrerAddress, users[msg.sender].id, users[referrerAddress].id);\n    }\n    \n    function activateLevelByStaking(uint8 level) external {\n        activateLevel(msg.sender, level);\n    }\n    \n    function activateLevel(address userAddress, uint8 level) private {\n        //add isUserExists check\n        require(!users[userAddress].levels[level].activeStatus, \"Level Already activated\");\n        require(level == 1 || users[userAddress].levels[level-1].activeStatus, \"Please activate immediate higher level\");\n        address tokenAddress = stakedTokens[level].tokenAddress;\n        uint256 amount = stakedTokens[level].amountToStake;\n        \n        Token(tokenAddress).transferFrom(userAddress, address(this), amount);\n        rewardTokens[tokenAddress].lastBalance = rewardTokens[tokenAddress].lastBalance.add(amount); \n        users[userAddress].levels[level].activeStatus = true;\n        \n        emit LevelActivated(userAddress, level, tokenAddress, amount);\n    }\n    \n    function unstakeToken(uint8 level) public returns (bool) {\n        require(users[msg.sender].levels[level].activeStatus, \"Level Not active yet\");\n        address tokenAddress = stakedTokens[level].tokenAddress;\n        uint256 amount = stakedTokens[level].amountToStake;\n        \n        Token(tokenAddress).transfer(msg.sender, amount);\n        rewardTokens[tokenAddress].lastBalance = rewardTokens[tokenAddress].lastBalance.sub(amount);\n        users[msg.sender].levels[level].activeStatus = false;\n        emit TokenUnstaked(msg.sender, level, tokenAddress, amount);\n        return true;\n    }\n    \n    /**\n    * who will send the poolRewards to the contract, user or any \n    * admin\n    */\n    function poolRewards(address[] memory tokenAddressSuper, uint256[] memory totalAmount, address[] memory _from, address[] memory tokenAddress, uint256[] memory amount) external onlyOwner {\n        for (uint256 i=0; i<tokenAddressSuper.length; i++) {\n            require(totalAmount[i] >= Token(tokenAddressSuper[i]).balanceOf(address(this)).sub(rewardTokens[tokenAddressSuper[i]].lastBalance), \"Wrong Balance info\");\n            rewardTokens[tokenAddressSuper[i]].lastBalance = rewardTokens[tokenAddressSuper[i]].lastBalance.add(totalAmount[i]);\n            // oracle.addTypeOneMapping(tokenAddressSuper[i], chainlinkAddress[i]);\n        }\n        \n        //update the last balance whenever user withdraws\n        for (uint256 j=0; j<_from.length; j++) {\n            if (isUserExists(_from[j])) {\n                levelIncome(_from[j], users[_from[j]].referrer, tokenAddress[j], amount[j], false);\n            } else {\n                missedTokenRewards[tokenAddress[j]] = missedTokenRewards[tokenAddress[j]].add(amount[j]);\n                missedTokenAddresses.push(tokenAddress[j]);\n            }\n        }\n    }\n    \n    function levelIncome(address _from, address receiver, address tokenAddress, uint256 amount, bool isEther) private {\n        for (uint8 i=0; i<Last_Level; i++) {\n            uint256 income = (amount.mul(levelRate[i])).div(100);\n            address eligibleReferrer = getEligibleReferrer(receiver, i+1);\n            if (!isEther) {\n                users[eligibleReferrer].tokenRewards[tokenAddress] = users[eligibleReferrer].tokenRewards[tokenAddress].add(income);\n                users[eligibleReferrer].rewardTokenAddresses.push(tokenAddress);\n            } else {\n                users[eligibleReferrer].etherReceived = users[eligibleReferrer].etherReceived.add(income);\n            }\n            \n            if (!users[eligibleReferrer].levels[i+1].isReferral[eligibleReferrer]) {\n                users[eligibleReferrer].levels[i+1].isReferral[eligibleReferrer] = true;\n                users[eligibleReferrer].levels[i+1].levelReferrals++;\n            }\n            \n            emit LevelIncome(_from, receiver, i+1, income, users[eligibleReferrer].levels[i+1].levelReferrals);\n            receiver = users[eligibleReferrer].referrer;\n        }\n    }\n    \n    function withdrawIncome() external {\n        uint256 rewards;\n        address rewardTokenAddress;\n        uint256 size = users[msg.sender].rewardTokenAddresses.length;\n        for (uint8 i=0; i<size; i++) {\n            rewardTokenAddress = users[msg.sender].rewardTokenAddresses[i];\n            rewards = users[msg.sender].tokenRewards[rewardTokenAddress];\n            Token(rewardTokenAddress).transfer(msg.sender, rewards);\n            emit IncomeWithdrawn(msg.sender, rewardTokenAddress, rewards);\n            rewardTokens[rewardTokenAddress].lastBalance = rewardTokens[rewardTokenAddress].lastBalance.sub(rewards);\n            users[msg.sender].tokenRewards[rewardTokenAddress] = users[msg.sender].tokenRewards[rewardTokenAddress].sub(rewards);\n        }\n        \n        users[msg.sender].rewardTokenAddresses = new address[](0);\n        \n        uint256 etherRewards = users[msg.sender].etherReceived;\n        if(etherRewards > address(this).balance) {\n            etherRewards = address(this).balance;\n        }\n        \n        address(uint160(msg.sender)).transfer(etherRewards);\n        users[msg.sender].etherReceived = users[msg.sender].etherReceived.sub(etherRewards);\n    }\n    \n    // function calculateTax(address userAddress) private {\n        \n    // }\n    \n    function checkLevelEligibility(address userAddress, uint8 level) private view returns (bool) {\n        while (level != 0) {\n            if (!users[userAddress].levels[level].activeStatus) {\n                return false;\n            }\n            \n            level--;\n        }\n        \n        return true;\n    }\n    \n    function getEligibleReferrer(address userAddress, uint8 level) private view returns(address) {\n        while (userAddress != address(0)) {\n            if (checkLevelEligibility(userAddress, level)) {\n                return userAddress;\n            }\n            \n            userAddress = users[userAddress].referrer;\n        }\n        \n        return owner;\n    }\n    \n    function isUserExists(address user) public view returns (bool) {\n        return (users[user].id != 0);\n    }\n    \n    function getStakingTokenDetail(uint8 level) public view returns (address, uint256, uint256) {\n        return (\n            stakedTokens[level].tokenAddress,\n            stakedTokens[level].amountToStake,\n            Token(stakedTokens[level].tokenAddress).balanceOf(address(this))\n            );\n    }\n    \n    function getUserDetail(address userAddress, address tokenAddress) public view returns (uint256, address[] memory, uint256) {\n        return (\n            users[userAddress].etherReceived,\n            users[userAddress].rewardTokenAddresses,\n            users[userAddress].tokenRewards[tokenAddress]\n            );\n    }\n    \n    function addStakingToken(address[] memory tokenAddress, uint256[] memory amount) public onlyOwner {\n        for (uint8 i=0; i<tokenAddress.length; i++) {//change this to 7\n            token = Token(tokenAddress[i]);\n            stakedTokens[i+1].tokenAddress = tokenAddress[i];\n            stakedTokens[i+1].amountToStake = amount[i].mul(10**(token.decimals()));\n        }\n    }\n    \n    function changeStakingToken(address tokenAddress, uint8 level) public onlyOwner {\n        stakedTokens[level].tokenAddress = tokenAddress;\n        // oracle.addTypeOneMapping(tokenAddress, chainlinkAddress);\n    }\n    \n    function changeStakingAmount(uint256 amount, uint8 level) public onlyOwner {\n        stakedTokens[level].amountToStake = amount.mul(Token(stakedTokens[level].tokenAddress).decimals());\n    }\n    \n    function updateTaxToken(address tokenAddress) public onlyOwner {\n        taxTokenAddress = tokenAddress;\n        // oracle.addTypeOneMapping(tokenAddress, chainlinkAddress);\n    }\n    \n    function updateCommission(uint8 newCommission) public onlyOwner {\n        commission = newCommission;\n    }\n    \n    function updateTaxPercentage(uint8 percentage) public onlyOwner {\n        taxPercentage = percentage;\n    }\n    \n    function updateOracleWrapperAddress(address newAddress) public onlyOwner {\n        oracleWrapperAddress = newAddress;\n    }\n    \n    function withdrawMissedRewards() public onlyOwner {\n        if (missedEthers > address(this).balance) {\n            missedEthers = address(this).balance;\n        }\n        \n        address(uint160(owner)).transfer(missedEthers);\n        missedEthers = 0;\n        for (uint256 i=0; i<missedTokenAddresses.length; i++) {\n            Token(missedTokenAddresses[i]).transfer(owner, missedTokenRewards[missedTokenAddresses[i]]);\n            missedTokenRewards[missedTokenAddresses[i]] = 0;\n        }\n        \n        missedTokenAddresses = new address[](0);\n    }\n    \n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n    \n}"}}}