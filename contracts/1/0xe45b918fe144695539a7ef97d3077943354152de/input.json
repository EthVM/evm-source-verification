{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":99999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"staking.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity =0.8.3;\r\n\r\ninterface ERC20 {\r\n    function transfer(address to, uint tokens) external;\r\n    function transferFrom(address from, address to, uint tokens) external;\r\n}\r\n\r\nabstract contract Rebaser {\r\n    uint public orbiSupplyTotal;\r\n}\r\n\r\ncontract Staking {\r\n\r\n    address public owner;\r\n    address public tokenAddress;\r\n    address public liquidityAddress;\r\n    uint public creationTime;\r\n    uint public totalStakeDepositsToken;\r\n    uint public totalStakeDepositsLiquidity;\r\n    uint public lastRealTokenEmissionToken;\r\n    uint public lastRealTokenEmissionLiquidity;\r\n    uint public rewardPerStakeTotalToken;\r\n    uint public rewardPerStakeTotalLiquidity;\r\n    uint public currentScaleToken;\r\n    uint public currentScaleLiquidity;\r\n    uint public totalRewardsWithdrawnToken;\r\n    uint public totalRewardsWithdrawnLiquidity;\r\n    uint public rewardMax = 1e16;\r\n    uint public previousRewards;\r\n    uint public distributionConstant = 7008000;\r\n    uint public rewardsLastRewardChange;\r\n    uint public timeStakingInit;\r\n    uint public timeFromInitToLastRewardChange;\r\n    address public rebaserAddress = 0x0ac8F269ED3F8ad1bd6d52866d0bF98838b7257F;\r\n    mapping(address => uint) public stakingBalancesToken;\r\n    mapping(address => uint) public stakingBalancesLiquidity;\r\n    mapping(address => uint) public rewardPerStakeInitsToken;\r\n    mapping(address => uint) public rewardPerStakeInitsLiquidity;\r\n    mapping(address => uint) public availableRewardsToken;\r\n    mapping(address => uint) public availableRewardsLiquidity;\r\n\r\n    constructor() {\r\n        creationTime = block.timestamp;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function changeOwner(address addr) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        owner = addr;\r\n    }\r\n\r\n    function rewardTheoretical() public view returns (uint) {\r\n        if (timeStakingInit == 0)\r\n            return 0;\r\n        return rewardMax - (rewardMax - rewardsLastRewardChange) * distributionConstant / (block.timestamp - timeStakingInit + distributionConstant - timeFromInitToLastRewardChange);\r\n    }\r\n    \r\n    function updateRewardFunction(uint newRewardMax, uint newDistributionConstant) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        rewardsLastRewardChange = rewardTheoretical();\r\n        distributionConstant = newDistributionConstant;\r\n        rewardMax = newRewardMax;\r\n        timeFromInitToLastRewardChange = block.timestamp - timeStakingInit;\r\n    }\r\n    \r\n    function getTheoreticalTokenEmission(bool tokenOrLiquidity) public view returns(uint) {\r\n        if (tokenOrLiquidity)\r\n            return rewardTheoretical() * 2 / 3;\r\n            //return (1e16 - 1e16 * 3504000 / ((block.timestamp - creationTime) + 3504000)) * 5 / 6;\r\n        return rewardTheoretical() / 3;\r\n        //return (1e16 - 1e16 * 3504000 / ((block.timestamp - creationTime) + 3504000)) / 6;\r\n    }\r\n\r\n    function stake(uint pseudoAmount, bool tokenOrLiquidity) public {\r\n        if (timeStakingInit == 0)\r\n            timeStakingInit = block.timestamp;\r\n        distributeRewards(tokenOrLiquidity);\r\n        if (tokenOrLiquidity) {\r\n            require(stakingBalancesLiquidity[msg.sender] == 0, \"Liquidity staking position already exists\");\r\n            ERC20(liquidityAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n            totalStakeDepositsLiquidity += pseudoAmount;\r\n            stakingBalancesLiquidity[msg.sender] = pseudoAmount;\r\n            rewardPerStakeInitsLiquidity[msg.sender] = rewardPerStakeTotalLiquidity;\r\n            return;\r\n        }\r\n        require(stakingBalancesToken[msg.sender] == 0, \"Token staking position already exists\");\r\n        uint amount = pseudoAmount;\r\n        ERC20(tokenAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n        totalStakeDepositsToken += amount;\r\n        stakingBalancesToken[msg.sender] = amount;\r\n        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\r\n    }\r\n\r\n    function unstake(bool tokenOrLiquidity) public {\r\n        withdraw(tokenOrLiquidity);\r\n        if (tokenOrLiquidity) {\r\n            require(stakingBalancesLiquidity[msg.sender] > 0, \"No current liquidity staking position\");\r\n            ERC20(liquidityAddress).transfer(msg.sender, stakingBalancesLiquidity[msg.sender]);\r\n            totalStakeDepositsLiquidity -= stakingBalancesLiquidity[msg.sender];\r\n            stakingBalancesLiquidity[msg.sender] = 0;\r\n            return;\r\n        }\r\n        require(stakingBalancesToken[msg.sender] > 0, \"No current token staking position\");\r\n        ERC20(tokenAddress).transfer(msg.sender, stakingBalancesToken[msg.sender]);\r\n        totalStakeDepositsToken -= stakingBalancesToken[msg.sender];\r\n        stakingBalancesToken[msg.sender] = 0;\r\n    }\r\n\r\n    function withdraw(bool tokenOrLiquidity) public {\r\n        if (tokenOrLiquidity) {\r\n            distributeRewards(tokenOrLiquidity);\r\n            availableRewardsLiquidity[msg.sender] += (rewardPerStakeTotalLiquidity - rewardPerStakeInitsLiquidity[msg.sender]) * stakingBalancesLiquidity[msg.sender] / 10**(currentScaleLiquidity * 18);\r\n            require(stakingBalancesLiquidity[msg.sender] > 0, \"No liquidity rewards to withdraw\");\r\n            rewardPerStakeInitsLiquidity[msg.sender] = rewardPerStakeTotalLiquidity;\r\n            uint withdrawAmountLiquidity = availableRewardsLiquidity[msg.sender];\r\n            totalRewardsWithdrawnLiquidity += withdrawAmountLiquidity;\r\n            ERC20(tokenAddress).transfer(msg.sender, withdrawAmountLiquidity);\r\n            availableRewardsLiquidity[msg.sender] = 0;\r\n            return;\r\n        }\r\n        distributeRewards(tokenOrLiquidity);\r\n        availableRewardsToken[msg.sender] += (rewardPerStakeTotalToken - rewardPerStakeInitsToken[msg.sender]) * stakingBalancesToken[msg.sender] / 10**(currentScaleToken * 18);\r\n        require(stakingBalancesToken[msg.sender] > 0, \"No token rewards to withdraw\");\r\n        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\r\n        uint withdrawAmountToken = availableRewardsToken[msg.sender];\r\n        totalRewardsWithdrawnToken += withdrawAmountToken;\r\n        ERC20(tokenAddress).transfer(msg.sender, withdrawAmountToken);\r\n        availableRewardsToken[msg.sender] = 0;\r\n    }\r\n\r\n    function withdrawAll() public {\r\n        withdraw(false);\r\n        withdraw(true);\r\n    }\r\n\r\n    function updatePosition(uint amount, bool tokenOrLiquidity) public {\r\n        unstake(tokenOrLiquidity);\r\n        if (amount > 0)\r\n            stake(amount, tokenOrLiquidity);\r\n    }\r\n\r\n    function distributeRewards(bool tokenOrLiquidity) internal {\r\n        if (tokenOrLiquidity && totalStakeDepositsLiquidity > 0) {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionLiquidity;\r\n            if (tokenEmissionDelta != 0) {\r\n                while (totalStakeDepositsLiquidity * 1e18 > tokenEmissionDelta * 10**(currentScaleLiquidity * 18)) {\r\n                    currentScaleLiquidity += 1;\r\n                    rewardPerStakeTotalLiquidity *= 1e18;\r\n                }\r\n                rewardPerStakeTotalLiquidity += tokenEmissionDelta * 10**(currentScaleLiquidity * 18) / totalStakeDepositsLiquidity;\r\n                lastRealTokenEmissionLiquidity = getTheoreticalTokenEmission(tokenOrLiquidity);\r\n            }\r\n        }\r\n        if (!tokenOrLiquidity && totalStakeDepositsToken > 0) {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionToken;\r\n            if (tokenEmissionDelta != 0) {\r\n                while (totalStakeDepositsToken * 1e18 > tokenEmissionDelta * 10**(currentScaleToken * 18)) {\r\n                    currentScaleToken += 1;\r\n                    rewardPerStakeTotalToken *= 1e18;\r\n                }\r\n                rewardPerStakeTotalToken += tokenEmissionDelta * 10**(currentScaleToken * 18) / totalStakeDepositsToken;\r\n                lastRealTokenEmissionToken = getTheoreticalTokenEmission(tokenOrLiquidity);\r\n            }\r\n        }\r\n    }\r\n\r\n    function reinvest() public {\r\n        distributeRewards(false);\r\n        availableRewardsToken[msg.sender] += (rewardPerStakeTotalToken - rewardPerStakeInitsToken[msg.sender]) * stakingBalancesToken[msg.sender] / 10**(currentScaleToken * 18);\r\n        require(availableRewardsToken[msg.sender] > 0, \"No rewards to reinvest\");\r\n        totalRewardsWithdrawnToken += availableRewardsToken[msg.sender];\r\n        totalStakeDepositsToken += availableRewardsToken[msg.sender];\r\n        stakingBalancesToken[msg.sender] += availableRewardsToken[msg.sender];\r\n        availableRewardsToken[msg.sender] = 0;\r\n        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\r\n    }\r\n\r\n    function getAmountStaked(bool tokenOrLiquidity, address staker) public view returns(uint) {\r\n        if (tokenOrLiquidity)\r\n            return stakingBalancesLiquidity[staker];\r\n        return stakingBalancesToken[staker];\r\n    }\r\n\r\n    function getAvailableRewards(bool tokenOrLiquidity, address staker) public view returns(uint) {\r\n        if (tokenOrLiquidity) {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionLiquidity;\r\n            uint pseudoTotalStakeDepositsLiquidity = totalStakeDepositsLiquidity;\r\n            uint pseudoCurrentScaleLiquidity = currentScaleLiquidity;\r\n            uint pseudoRewardPerStakeTotalLiquidity = rewardPerStakeTotalLiquidity;\r\n            if (tokenEmissionDelta != 0) {\r\n                while (pseudoTotalStakeDepositsLiquidity * 1e18 > tokenEmissionDelta * 10**(pseudoCurrentScaleLiquidity * 18)) {\r\n                    pseudoCurrentScaleLiquidity += 1;\r\n                    pseudoRewardPerStakeTotalLiquidity *= 1e18;\r\n                }\r\n                pseudoRewardPerStakeTotalLiquidity += tokenEmissionDelta * 10**(pseudoCurrentScaleLiquidity * 18) / pseudoTotalStakeDepositsLiquidity;\r\n            }\r\n            uint pseudoAvailableRewardsLiquidity = availableRewardsLiquidity[staker] + (pseudoRewardPerStakeTotalLiquidity - rewardPerStakeInitsLiquidity[staker]) * stakingBalancesLiquidity[staker] / 10**(pseudoCurrentScaleLiquidity * 18);\r\n            return pseudoAvailableRewardsLiquidity;\r\n        } else {\r\n            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionToken;\r\n            uint pseudoTotalStakeDepositsToken = totalStakeDepositsToken;\r\n            uint pseudoCurrentScaleToken = currentScaleToken;\r\n            uint pseudoRewardPerStakeTotalToken = rewardPerStakeTotalToken;\r\n            if (tokenEmissionDelta != 0) {\r\n                while (pseudoTotalStakeDepositsToken * 1e18 > tokenEmissionDelta * 10**(pseudoCurrentScaleToken * 18)) {\r\n                    pseudoCurrentScaleToken += 1;\r\n                    pseudoRewardPerStakeTotalToken *= 1e18;\r\n                }\r\n            }\r\n            pseudoRewardPerStakeTotalToken += tokenEmissionDelta * 10**(pseudoCurrentScaleToken * 18) / pseudoTotalStakeDepositsToken;\r\n            uint pseudoAvailableRewardsToken = availableRewardsToken[staker] + (pseudoRewardPerStakeTotalToken - rewardPerStakeInitsToken[staker]) * stakingBalancesToken[staker] / 10**(pseudoCurrentScaleToken * 18);\r\n            return pseudoAvailableRewardsToken;\r\n        }\r\n    }\r\n    \r\n    function getAllAvailableRewards(address staker) public view returns(uint) {\r\n        if (totalStakeDepositsToken > 0 && totalStakeDepositsLiquidity > 0)\r\n            return getAvailableRewards(false, staker) + getAvailableRewards(true, staker);\r\n        if (totalStakeDepositsToken > 0)\r\n            return getAvailableRewards(false, staker);\r\n        if (totalStakeDepositsLiquidity > 0)\r\n            return getAvailableRewards(true, staker);\r\n        return 0;\r\n    }\r\n\r\n    function setToken(address _tokenAddress) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n\r\n    function setLiquidity(address _liquidityAddress) public {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        liquidityAddress = _liquidityAddress;\r\n    }\r\n    \r\n    function CALL(bytes memory data, address _address) public returns (bool success) {\r\n        require(msg.sender == owner, \"Only the owner can use this function\");\r\n        (success,) = _address.call(data);\r\n        if (!success) revert();\r\n    }\r\n    \r\n    function stakeFor(address staker, uint pseudoAmount, bool tokenOrLiquidity) public {\r\n        if (timeStakingInit == 0)\r\n            timeStakingInit = block.timestamp;\r\n        distributeRewards(tokenOrLiquidity);\r\n        if (tokenOrLiquidity) {\r\n            require(stakingBalancesLiquidity[staker] == 0, \"Liquidity staking position already exists\");\r\n            ERC20(liquidityAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n            totalStakeDepositsLiquidity += pseudoAmount;\r\n            stakingBalancesLiquidity[staker] = pseudoAmount;\r\n            rewardPerStakeInitsLiquidity[staker] = rewardPerStakeTotalLiquidity;\r\n            return;\r\n        }\r\n        require(stakingBalancesToken[staker] == 0, \"Token staking position already exists\");\r\n        uint amount = pseudoAmount;\r\n        ERC20(tokenAddress).transferFrom(msg.sender, address(this), pseudoAmount);\r\n        totalStakeDepositsToken += amount;\r\n        stakingBalancesToken[staker] = amount;\r\n        rewardPerStakeInitsToken[staker] = rewardPerStakeTotalToken;\r\n    }\r\n\r\n}\r\n"}}}