{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/BlockhashStore.sol":{"content":"\n// File: contracts/dev/BlockhashStore.sol\n\npragma solidity 0.6.6;\n\n/**\n * @title BlockhashStore\n * @notice This contract provides a way to access blockhashes older than\n *   the 256 block limit imposed by the BLOCKHASH opcode.\n *   You may assume that any blockhash stored by the contract is correct.\n *   Note that the contract depends on the format of serialized Ethereum\n *   blocks. If a future hardfork of Ethereum changes that format, the \n *   logic in this contract may become incorrect and an updated version \n *   would have to be deployed.\n */\ncontract BlockhashStore {\n\n  mapping(uint => bytes32) internal s_blockhashes;\n\n  /**\n   * @notice stores blockhash of a given block, assuming it is available through BLOCKHASH\n   * @param n the number of the block whose blockhash should be stored\n   */\n  function store(uint256 n) public {\n    bytes32 h = blockhash(n);\n    require(h != 0x0, \"blockhash(n) failed\");\n    s_blockhashes[n] = h;\n  }\n\n\n  /**\n   * @notice stores blockhash of the earliest block still available through BLOCKHASH.\n   */\n  function storeEarliest() external {\n    store(block.number - 256);\n  }\n\n  /**\n   * @notice stores blockhash after verifying blockheader of child/subsequent block\n   * @param n the number of the block whose blockhash should be stored\n   * @param header the rlp-encoded blockheader of block n+1. We verify its correctness by checking\n   *   that it hashes to a stored blockhash, and then extract parentHash to get the n-th blockhash.\n   */\n  function storeVerifyHeader(uint256 n, bytes memory header) public {\n    require(keccak256(header) == s_blockhashes[n + 1], \"header has unknown blockhash\");\n\n    // At this point, we know that header is the correct blockheader for block n+1.\n\n    // The header is an rlp-encoded list. The head item of that list is the 32-byte blockhash of the parent block.\n    // Based on how rlp works, we know that blockheaders always have the following form:\n    // 0xf9____a0PARENTHASH...\n    //   ^ ^   ^\n    //   | |   |\n    //   | |   +--- PARENTHASH is 32 bytes. rlpenc(PARENTHASH) is 0xa || PARENTHASH.\n    //   | |\n    //   | +--- 2 bytes containing the sum of the lengths of the encoded list items\n    //   |\n    //   +--- 0xf9 because we have a list and (sum of lengths of encoded list items) fits exactly into two bytes.\n    //\n    // As a consequence, the PARENTHASH is always at offset 4 of the rlp-encoded block header.\n\n    bytes32 parentHash;\n    assembly {\n      parentHash := mload(add(header, 36)) // 36 = 32 byte offset for length prefix of ABI-encoded array\n                                           //    +  4 byte offset of PARENTHASH (see above)\n    }\n\n    s_blockhashes[n] = parentHash;\n  }\n\n  /**\n   * @notice gets a blockhash from the store. If no hash is known, this function reverts.\n   * @param n the number of the block whose blockhash should be returned\n   */\n  function getBlockhash(uint256 n) external view returns (bytes32) {\n    bytes32 h = s_blockhashes[n];\n    require(h != 0x0, \"blockhash not found in store\");\n    return h;\n  }\n}\n"}}}