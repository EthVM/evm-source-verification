{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DolomiteDirectV2.sol":{"content":"// File: contracts/dolomite-direct/interfaces/IDepositContractRegistry.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IDepositContractRegistry {\r\n\r\n    function depositAddressOf(address owner) external view returns (address payable);\r\n\r\n    function operatorOf(address owner, address operator) external view returns (bool);\r\n\r\n    function versionOf(address owner) external view returns (address);\r\n\r\n    function isDepositContractCreatedFor(address owner) external view returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/IBrokerRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IBrokerRegistry\r\n/// @dev A broker is an account that can submit orders on behalf of other\r\n///      accounts. When registering a broker, the owner can also specify a\r\n///      pre-deployed BrokerInterceptor to hook into the exchange smart contracts.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IBrokerRegistry {\r\n    event BrokerRegistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event BrokerUnregistered(\r\n        address owner,\r\n        address broker,\r\n        address interceptor\r\n    );\r\n\r\n    event AllBrokersUnregistered(\r\n        address owner\r\n    );\r\n\r\n    /// @dev   Validates if the broker was registered for the order owner and\r\n    ///        returns the possible BrokerInterceptor to be used.\r\n    /// @param owner The owner of the order\r\n    /// @param broker The broker of the order\r\n    /// @return True if the broker was registered for the owner\r\n    ///         and the BrokerInterceptor to use.\r\n    function getBroker(\r\n        address owner,\r\n        address broker\r\n        )\r\n        external\r\n        view\r\n        returns(\r\n            bool registered,\r\n            address interceptor\r\n        );\r\n\r\n    /// @dev   Gets all registered brokers for an owner.\r\n    /// @param owner The owner\r\n    /// @param start The start index of the list of brokers\r\n    /// @param count The number of brokers to return\r\n    /// @return The list of requested brokers and corresponding BrokerInterceptors\r\n    function getBrokers(\r\n        address owner,\r\n        uint    start,\r\n        uint    count\r\n        )\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory brokers,\r\n            address[] memory interceptors\r\n        );\r\n\r\n    /// @dev   Registers a broker for msg.sender and an optional\r\n    ///        corresponding BrokerInterceptor.\r\n    /// @param broker The broker to register\r\n    /// @param interceptor The optional BrokerInterceptor to use (0x0 allowed)\r\n    function registerBroker(\r\n        address broker,\r\n        address interceptor\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters a broker for msg.sender\r\n    /// @param broker The broker to unregister\r\n    function unregisterBroker(\r\n        address broker\r\n        )\r\n        external;\r\n\r\n    /// @dev   Unregisters all brokers for msg.sender\r\n    function unregisterAllBrokers(\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/IBurnRateTable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @author Brecht Devos - <brecht@loopring.org>\r\n/// @title IBurnRateTable - A contract for managing burn rates for tokens\r\ncontract IBurnRateTable {\r\n\r\n    struct TokenData {\r\n        uint    tier;\r\n        uint    validUntil;\r\n    }\r\n\r\n    mapping(address => TokenData) public tokens;\r\n\r\n    uint public constant YEAR_TO_SECONDS = 31556952;\r\n\r\n    // Tiers\r\n    uint8 public constant TIER_4 = 0;\r\n    uint8 public constant TIER_3 = 1;\r\n    uint8 public constant TIER_2 = 2;\r\n    uint8 public constant TIER_1 = 3;\r\n\r\n    uint16 public constant BURN_BASE_PERCENTAGE           =                 100 * 10; // 100%\r\n\r\n    // Cost of upgrading the tier level of a token in a percentage of the total LRC supply\r\n    uint16 public constant TIER_UPGRADE_COST_PERCENTAGE   =                        1; // 0.1%\r\n\r\n    // Burn rates\r\n    // Matching\r\n    uint16 public constant BURN_MATCHING_TIER1            =                       25; // 2.5%\r\n    uint16 public constant BURN_MATCHING_TIER2            =                  15 * 10; //  15%\r\n    uint16 public constant BURN_MATCHING_TIER3            =                  30 * 10; //  30%\r\n    uint16 public constant BURN_MATCHING_TIER4            =                  50 * 10; //  50%\r\n    // P2P\r\n    uint16 public constant BURN_P2P_TIER1                 =                       25; // 2.5%\r\n    uint16 public constant BURN_P2P_TIER2                 =                  15 * 10; //  15%\r\n    uint16 public constant BURN_P2P_TIER3                 =                  30 * 10; //  30%\r\n    uint16 public constant BURN_P2P_TIER4                 =                  50 * 10; //  50%\r\n\r\n    event TokenTierUpgraded(\r\n        address indexed addr,\r\n        uint            tier\r\n    );\r\n\r\n    /// @dev   Returns the P2P and matching burn rate for the token.\r\n    /// @param token The token to get the burn rate for.\r\n    /// @return The burn rate. The P2P burn rate and matching burn rate\r\n    ///         are packed together in the lowest 4 bytes.\r\n    ///         (2 bytes P2P, 2 bytes matching)\r\n    function getBurnRate(\r\n        address token\r\n        )\r\n        external\r\n        view\r\n        returns (uint32 burnRate);\r\n\r\n    /// @dev   Returns the tier of a token.\r\n    /// @param token The token to get the token tier for.\r\n    /// @return The tier of the token\r\n    function getTokenTier(\r\n        address token\r\n        )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    /// @dev   Upgrades the tier of a token. Before calling this function,\r\n    ///        msg.sender needs to approve this contract for the neccessary funds.\r\n    /// @param token The token to upgrade the tier for.\r\n    /// @return True if successful, false otherwise.\r\n    function upgradeTokenTier(\r\n        address token\r\n        )\r\n        external\r\n        returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/IFeeHolder.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>\r\n/// @title IFeeHolder - A contract holding fees.\r\ncontract IFeeHolder {\r\n\r\n    event TokenWithdrawn(\r\n        address owner,\r\n        address token,\r\n        uint value\r\n    );\r\n\r\n    // A map of all fee balances\r\n    mapping(address => mapping(address => uint)) public feeBalances;\r\n\r\n    // A map of all the nonces for a withdrawTokenFor request\r\n    mapping(address => uint) public nonces;\r\n\r\n    /// @dev   Allows withdrawing the tokens to be burned by\r\n    ///        authorized contracts.\r\n    /// @param token The token to be used to burn buy and burn LRC\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawBurned(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds\r\n    ///        msg.sender is the recipient of the fee and the address\r\n    ///        to which the tokens will be sent.\r\n    /// @param token The token to withdraw\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawToken(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds by providing a\r\n    ///        a signature\r\n    function withdrawTokenFor(\r\n      address owner,\r\n      address token,\r\n      uint value,\r\n      address recipient,\r\n      uint feeValue,\r\n      address feeRecipient,\r\n      uint nonce,\r\n      bytes calldata signature\r\n      )\r\n      external\r\n      returns (bool success);\r\n\r\n    function batchAddFeeBalances(\r\n        bytes32[] calldata batch\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/IOrderBook.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IOrderBook\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>.\r\ncontract IOrderBook {\r\n    // The map of registered order hashes\r\n    mapping(bytes32 => bool) public orderSubmitted;\r\n\r\n    /// @dev  Event emitted when an order was successfully submitted\r\n    ///        orderHash      The hash of the order\r\n    ///        orderData      The data of the order as passed to submitOrder()\r\n    event OrderSubmitted(\r\n        bytes32 orderHash,\r\n        bytes   orderData\r\n    );\r\n\r\n    /// @dev   Submits an order to the on-chain order book.\r\n    ///        No signature is needed. The order can only be sumbitted by its\r\n    ///        owner or its broker (the owner can be the address of a contract).\r\n    /// @param orderData The data of the order. Contains all fields that are used\r\n    ///        for the order hash calculation.\r\n    ///        See OrderHelper.updateHash() for detailed information.\r\n    function submitOrder(\r\n        bytes calldata orderData\r\n        )\r\n        external\r\n        returns (bytes32);\r\n}\r\n\r\n// File: contracts/loopring/iface/IOrderRegistry.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title IOrderRegistry\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract IOrderRegistry {\r\n\r\n    /// @dev   Returns wether the order hash was registered in the registry.\r\n    /// @param broker The broker of the order\r\n    /// @param orderHash The hash of the order\r\n    /// @return True if the order hash was registered, else false.\r\n    function isOrderHashRegistered(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev   Registers an order in the registry.\r\n    ///        msg.sender needs to be the broker of the order.\r\n    /// @param orderHash The hash of the order\r\n    function registerOrderHash(\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/impl/BrokerData.sol\r\n\r\npragma solidity ^0.5.7;\r\n\r\nlibrary BrokerData {\r\n\r\n  struct BrokerOrder {\r\n    address owner;\r\n    bytes32 orderHash;\r\n    uint fillAmountB;\r\n    uint requestedAmountS;\r\n    uint requestedFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n  /**\r\n   * The request wraps all broker orders that share the following overall fields. The perspective on these fields is\r\n   * the orders that are passed in. Meaning, `tokenB` is the token being RECEIVED by each owner and `tokenS` is the\r\n   * token being SPENT by each owner. Lastly, `totalRequestedFeeAmount` is the total `feeAmountS` for all brokered\r\n   * orders. If the fees are in `tokenB`, then this amount is always 0.\r\n   */\r\n  struct BrokerApprovalRequest {\r\n    BrokerOrder[] orders;\r\n    // The token output token for the broker at the end of #brokerRequestAllowance.\r\n    address tokenS;\r\n    // The token received by the broker at the start of #brokerRequestAllowance. This token must be internally traded\r\n    // for tokenS.\r\n    address tokenB;\r\n    address feeToken;\r\n    // The amount of tokens that the broker has at the start of the call to #brokerRequestAllowance. This amount needs\r\n    // to be traded within the brokering contract for #totalRequestedAmountS\r\n    uint totalFillAmountB;\r\n    // The amount of tokens that needs be outputted by #brokerRequestAllowance (and therefore traded for INTERNALLY\r\n    // within the contract)\r\n    uint totalRequestedAmountS;\r\n    uint totalRequestedFeeAmount;\r\n  }\r\n\r\n  struct BrokerInterceptorReport {\r\n    address owner;\r\n    address broker;\r\n    bytes32 orderHash;\r\n    address tokenB;\r\n    address tokenS;\r\n    address feeToken;\r\n    uint fillAmountB;\r\n    uint spentAmountS;\r\n    uint spentFeeAmount;\r\n    address tokenRecipient;\r\n    bytes extraData;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/loopring/iface/ILoopringTradeDelegate.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n/// @title ILoopringTradeDelegate\r\n/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\r\n/// versions of Loopring protocol to avoid ERC20 re-authorization.\r\n/// @author Daniel Wang - <daniel@loopring.org>.\r\ncontract ILoopringTradeDelegate {\r\n\r\n    function isTrustedSubmitter(address submitter) public view returns (bool);\r\n\r\n    function addTrustedSubmitter(address submitter) public;\r\n\r\n    function removeTrustedSubmitter(address submitter) public;\r\n\r\n    function batchTransfer(\r\n        bytes32[] calldata batch\r\n    ) external;\r\n\r\n    function brokerTransfer(\r\n        address token,\r\n        address broker,\r\n        address recipient,\r\n        uint amount\r\n    ) external;\r\n\r\n    function proxyBrokerRequestAllowance(\r\n        BrokerData.BrokerApprovalRequest memory request,\r\n        address broker\r\n    ) public returns (bool);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/iface/ITradeHistory.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title ITradeHistory\r\n/// @dev Stores the trade history and cancelled data of orders\r\n/// @author Brecht Devos - <brecht@loopring.org>.\r\ncontract ITradeHistory {\r\n\r\n    // The following map is used to keep trace of order fill and cancellation\r\n    // history.\r\n    mapping (bytes32 => uint) public filled;\r\n\r\n    // This map is used to keep trace of order's cancellation history.\r\n    mapping (address => mapping (bytes32 => bool)) public cancelled;\r\n\r\n    // A map from a broker to its cutoff timestamp.\r\n    mapping (address => uint) public cutoffs;\r\n\r\n    // A map from a broker to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (bytes20 => uint)) public tradingPairCutoffs;\r\n\r\n    // A map from a broker to an order owner to its cutoff timestamp.\r\n    mapping (address => mapping (address => uint)) public cutoffsOwner;\r\n\r\n    // A map from a broker to an order owner to its trading-pair cutoff timestamp.\r\n    mapping (address => mapping (address => mapping (bytes20 => uint))) public tradingPairCutoffsOwner;\r\n\r\n\r\n    function batchUpdateFilled(\r\n        bytes32[] calldata filledInfo\r\n        )\r\n        external;\r\n\r\n    function setCancelled(\r\n        address broker,\r\n        bytes32 orderHash\r\n        )\r\n        external;\r\n\r\n    function setCutoffs(\r\n        address broker,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffs(\r\n        address broker,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function setTradingPairCutoffsOfOwner(\r\n        address broker,\r\n        address owner,\r\n        bytes20 tokenPair,\r\n        uint cutoff\r\n        )\r\n        external;\r\n\r\n    function batchGetFilledAndCheckCancelled(\r\n        bytes32[] calldata orderInfo\r\n        )\r\n        external\r\n        view\r\n        returns (uint[] memory fills);\r\n\r\n\r\n    /// @dev Add a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function authorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    /// @dev Remove a Loopring protocol address.\r\n    /// @param addr A loopring protocol address.\r\n    function deauthorizeAddress(\r\n        address addr\r\n        )\r\n        external;\r\n\r\n    function isAddressAuthorized(\r\n        address addr\r\n        )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n\r\n    function suspend()\r\n        external;\r\n\r\n    function resume()\r\n        external;\r\n\r\n    function kill()\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/impl/Data.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary Data {\r\n\r\n    enum TokenType { ERC20 }\r\n\r\n    struct Header {\r\n        uint version;\r\n        uint numOrders;\r\n        uint numRings;\r\n        uint numSpendables;\r\n    }\r\n\r\n    struct BrokerAction {\r\n        bytes32 hash;\r\n        address broker;\r\n        uint[] orderIndices;\r\n        uint numOrders;\r\n        uint[] transferIndices;\r\n        uint numTransfers;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n        address delegate;\r\n    }\r\n\r\n    struct BrokerTransfer {\r\n        bytes32 hash;\r\n        address token;\r\n        uint amount;\r\n        address recipient;\r\n    }\r\n\r\n    struct Context {\r\n        address lrcTokenAddress;\r\n        ILoopringTradeDelegate delegate;\r\n        ITradeHistory   tradeHistory;\r\n        IBrokerRegistry orderBrokerRegistry;\r\n        IOrderRegistry  orderRegistry;\r\n        IFeeHolder feeHolder;\r\n        IOrderBook orderBook;\r\n        IBurnRateTable burnRateTable;\r\n        uint64 ringIndex;\r\n        uint feePercentageBase;\r\n        bytes32[] tokenBurnRates;\r\n        uint feeData;\r\n        uint feePtr;\r\n        uint transferData;\r\n        uint transferPtr;\r\n        BrokerData.BrokerOrder[] brokerOrders;\r\n        BrokerAction[] brokerActions;\r\n        BrokerTransfer[] brokerTransfers;\r\n        uint numBrokerOrders;\r\n        uint numBrokerActions;\r\n        uint numBrokerTransfers;\r\n    }\r\n\r\n    struct Mining {\r\n        // required fields\r\n        address feeRecipient;\r\n\r\n        // optional fields\r\n        address miner;\r\n        bytes   sig;\r\n\r\n        // computed fields\r\n        bytes32 hash;\r\n        address interceptor;\r\n    }\r\n\r\n    struct Spendable {\r\n        bool initialized;\r\n        uint amount;\r\n        uint reserved;\r\n    }\r\n\r\n    struct Order {\r\n        uint      version;\r\n\r\n        // required fields\r\n        address   owner;\r\n        address   tokenS;\r\n        address   tokenB;\r\n        uint      amountS;\r\n        uint      amountB;\r\n        uint      validSince;\r\n        Spendable tokenSpendableS;\r\n        Spendable tokenSpendableFee;\r\n\r\n        // optional fields\r\n        address   dualAuthAddr;\r\n        address   broker;\r\n        Spendable brokerSpendableS;\r\n        Spendable brokerSpendableFee;\r\n        address   orderInterceptor;\r\n        address   wallet;\r\n        uint      validUntil;\r\n        bytes     sig;\r\n        bytes     dualAuthSig;\r\n        bool      allOrNone;\r\n        address   feeToken;\r\n        uint      feeAmount;\r\n        int16     waiveFeePercentage;\r\n        uint16    tokenSFeePercentage;    // Pre-trading\r\n        uint16    tokenBFeePercentage;   // Post-trading\r\n        address   tokenRecipient;\r\n        uint16    walletSplitPercentage;\r\n\r\n        // computed fields\r\n        bool    P2P;\r\n        bytes32 hash;\r\n        address brokerInterceptor;\r\n        uint    filledAmountS;\r\n        uint    initialFilledAmountS;\r\n        bool    valid;\r\n\r\n        TokenType tokenTypeS;\r\n        TokenType tokenTypeB;\r\n        TokenType tokenTypeFee;\r\n        bytes32 trancheS;\r\n        bytes32 trancheB;\r\n        uint    maxPrimaryFillAmount;\r\n        bool    transferFirstAsMaker;\r\n        bytes   transferDataS;\r\n    }\r\n\r\n    struct Participation {\r\n        // required fields\r\n        Order order;\r\n\r\n        // computed fields\r\n        uint splitS;\r\n        uint feeAmount;\r\n        uint feeAmountS;\r\n        uint feeAmountB;\r\n        uint rebateFee;\r\n        uint rebateS;\r\n        uint rebateB;\r\n        uint fillAmountS;\r\n        uint fillAmountB;\r\n    }\r\n\r\n    struct Ring {\r\n        uint size;\r\n        Participation[] participations;\r\n        bytes32 hash;\r\n        uint minerFeesToOrdersPercentage;\r\n        bool valid;\r\n    }\r\n\r\n    struct RingIndices {\r\n        uint index0;\r\n        uint index1;\r\n    }\r\n\r\n    struct FeeContext {\r\n        Data.Ring ring;\r\n        Data.Context ctx;\r\n        address feeRecipient;\r\n        uint walletPercentage;\r\n        int16 waiveFeePercentage;\r\n        address owner;\r\n        address wallet;\r\n        bool P2P;\r\n    }\r\n\r\n//    struct SubmitRingsRequest {\r\n//        Data.Mining  mining;\r\n//        Data.Order[] orders;\r\n//        Data.RingIndices[]  ringIndices;\r\n//    }\r\n\r\n}\r\n\r\n// File: contracts/dolomite-margin/external/ExternalDefinitions.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n// ---------------------------------\r\n// Dolomite Direct Includes\r\n\r\ninterface IDolomiteDirect {\r\n    function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n}\r\n\r\n// ---------------------------------\r\n// DyDx Includes\r\n\r\nlibrary DyDxTypes {\r\n    enum AssetDenomination {Wei, Par}\r\n    enum AssetReference {Delta, Target}\r\n\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    /*\r\n     * The price of a base-unit of an asset.\r\n     */\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n\r\n    /*\r\n     * Total value of an some amount of an asset. Equal to (price * amount).\r\n     */\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n\r\n}\r\n\r\nlibrary DyDxPosition {\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\nlibrary DyDxActions {\r\n    enum ActionType {Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call}\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        DyDxTypes.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n\r\ninterface IDyDxExchangeWrapper {\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes calldata orderData\r\n    ) external returns (uint256);\r\n\r\n    // Unused by our contract, does not need to be implemented\r\n    // function getExchangeCost(\r\n    //   address makerToken,\r\n    //   address takerToken,\r\n    //   uint256 desiredMakerToken,\r\n    //   bytes calldata orderData\r\n    // ) external view returns (uint256);\r\n}\r\n\r\ninterface IDyDxCallee {\r\n    function callFunction(address sender, DyDxPosition.Info calldata accountInfo, bytes calldata data) external;\r\n}\r\n\r\ncontract IDyDxProtocol {\r\n    struct OperatorArg {\r\n        address operator;\r\n        bool trusted;\r\n    }\r\n\r\n    function operate(\r\n        DyDxPosition.Info[] calldata accounts,\r\n        DyDxActions.ActionArgs[] calldata actions\r\n    ) external;\r\n\r\n    function getNumMarkets() public view returns (uint256);\r\n\r\n    function getMarketTokenAddress(uint256 marketId) external view returns (address);\r\n\r\n    function getMarketPrice(uint256 marketId) external view returns (DyDxTypes.Price memory);\r\n\r\n    function getAccountWei(DyDxPosition.Info calldata account, uint256 marketId) external view returns (DyDxTypes.Wei memory);\r\n\r\n}\r\n\r\n// ---------------------------------\r\n// Loopring Includes\r\n\r\nlibrary LoopringTypes {\r\n    struct BrokerApprovalRequest {\r\n        BrokerOrder[] orders;\r\n        address tokenS;\r\n        address tokenB;\r\n        address feeToken;\r\n        uint totalFillAmountB;\r\n        uint totalRequestedAmountS;\r\n        uint totalRequestedFeeAmount;\r\n    }\r\n\r\n    struct BrokerOrder {\r\n        address owner;\r\n        bytes32 orderHash;\r\n        uint fillAmountB;\r\n        uint requestedAmountS;\r\n        uint requestedFeeAmount;\r\n        address tokenRecipient;\r\n        bytes extraData;\r\n    }\r\n\r\n    struct BrokerInterceptorReport {\r\n        address owner;\r\n        address broker;\r\n        bytes32 orderHash;\r\n        address tokenB;\r\n        address tokenS;\r\n        address feeToken;\r\n        uint fillAmountB;\r\n        uint spentAmountS;\r\n        uint spentFeeAmount;\r\n        address tokenRecipient;\r\n        bytes extraData;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/LoopringTradeDelegateHelper.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.13;\r\n\r\n\r\n\r\nlibrary LoopringTradeDelegateHelper {\r\n\r\n    function transferTokenFrom(\r\n        ILoopringTradeDelegate self,\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bytes32[] memory transferData = new bytes32[](4);\r\n        transferData[0] = addressToBytes32(token);\r\n        transferData[1] = addressToBytes32(from);\r\n        transferData[2] = addressToBytes32(to);\r\n        transferData[3] = bytes32(amount);\r\n\r\n        self.batchTransfer(transferData);\r\n    }\r\n\r\n    function addressToBytes32(address addr) private pure returns (bytes32) {\r\n        return bytes32(uint256(addr));\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-margin/external/ExternalHelpers.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\nlibrary Logger {\r\n    function revertAddress(address addr) internal pure {\r\n        revert(_addressToString(addr));\r\n    }\r\n\r\n    function revertUint(uint num) internal pure {\r\n        revert(_uintToString(num));\r\n    }\r\n\r\n    // -----------------------------\r\n\r\n    function _addressToString(address _addr) private pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(51);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2 + i * 2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3 + i * 2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function _uintToString(uint num) internal pure returns (string memory) {\r\n        if (num == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = num;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (num != 0) {\r\n            bstr[k--] = byte(uint8(48 + num % 10));\r\n            num /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n}\r\n\r\nlibrary DyDxActionBuilder {\r\n\r\n    function Deposit(uint positionIndex, uint marketId, uint amount, address from)\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory depositAction)\r\n    {\r\n        depositAction.actionType = DyDxActions.ActionType.Deposit;\r\n        depositAction.accountId = positionIndex;\r\n        depositAction.primaryMarketId = marketId;\r\n        depositAction.otherAddress = from;\r\n        depositAction.amount = DyDxTypes.AssetAmount({\r\n            sign : true,\r\n            denomination : DyDxTypes.AssetDenomination.Wei,\r\n            ref : DyDxTypes.AssetReference.Delta,\r\n            value : amount\r\n            });\r\n    }\r\n\r\n    // The only way to deposit a variable amount into dYdX during the execution of an \"operate\" call is\r\n    // to perform a \"sell\" action sending 0 wei and then the implementor of IExchangeWrapper returns the amount that\r\n    // will be deposited. The 1 wei is an unfortunate side effect, however it is a very negligible amount. If, in a\r\n    // future version of dYdX a DepositAll action is added, this would remove the need for this weird mechanic.\r\n    function DepositAll(uint positionIndex, uint marketId, uint burnMarketId, address controller, bytes32 orderHash)\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory action)\r\n    {\r\n        action.actionType = DyDxActions.ActionType.Sell;\r\n        action.accountId = positionIndex;\r\n        action.otherAddress = controller;\r\n        action.data = abi.encode(orderHash);\r\n        action.primaryMarketId = burnMarketId;\r\n        action.secondaryMarketId = marketId;\r\n        action.amount = DyDxTypes.AssetAmount({\r\n            sign : false,\r\n            denomination : DyDxTypes.AssetDenomination.Wei,\r\n            ref : DyDxTypes.AssetReference.Delta,\r\n            value : 0\r\n            });\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    function Withdraw(uint positionIndex, uint marketId, uint amount, address to)\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory withdrawAction)\r\n    {\r\n        withdrawAction.actionType = DyDxActions.ActionType.Withdraw;\r\n        withdrawAction.accountId = positionIndex;\r\n        withdrawAction.primaryMarketId = marketId;\r\n        withdrawAction.otherAddress = to;\r\n        withdrawAction.amount = DyDxTypes.AssetAmount({\r\n            sign : false,\r\n            denomination : DyDxTypes.AssetDenomination.Wei,\r\n            ref : DyDxTypes.AssetReference.Delta,\r\n            value : amount\r\n            });\r\n    }\r\n\r\n    function WithdrawAll(uint positionIndex, uint marketId, address to)\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory withdrawAction)\r\n    {\r\n        withdrawAction.actionType = DyDxActions.ActionType.Withdraw;\r\n        withdrawAction.accountId = positionIndex;\r\n        withdrawAction.primaryMarketId = marketId;\r\n        withdrawAction.otherAddress = to;\r\n        withdrawAction.amount = DyDxTypes.AssetAmount({\r\n            sign : true,\r\n            denomination : DyDxTypes.AssetDenomination.Wei,\r\n            ref : DyDxTypes.AssetReference.Target,\r\n            value : 0\r\n            });\r\n    }\r\n\r\n    // ---------------------------------\r\n\r\n    // function Liquidation() {\r\n\r\n    // }\r\n\r\n    // ---------------------------------\r\n\r\n    function SetExpiry(uint positionIndex, address expiry, uint marketId, uint expiryTime)\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory)\r\n    {\r\n        return ExternalCall({\r\n            positionIndex : positionIndex,\r\n            callee : expiry,\r\n            data : abi.encode(marketId, expiryTime)\r\n            });\r\n    }\r\n\r\n    function LoopringSettlement(\r\n        bytes memory settlementData,\r\n        address settlementCaller,\r\n        uint positionIndex\r\n    )\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory)\r\n    {\r\n        return ExternalCall({\r\n            positionIndex : positionIndex,\r\n            callee : settlementCaller,\r\n            data : settlementData\r\n            });\r\n    }\r\n\r\n    function ExternalCall(uint positionIndex, address callee, bytes memory data)\r\n    internal\r\n    pure\r\n    returns (DyDxActions.ActionArgs memory callAction)\r\n    {\r\n        callAction.actionType = DyDxActions.ActionType.Call;\r\n        callAction.accountId = positionIndex;\r\n        callAction.otherAddress = callee;\r\n        callAction.data = data;\r\n    }\r\n}\r\n\r\nlibrary LoopringOrderDecoder {\r\n\r\n    function decodeLoopringOrders(bytes memory ringData, uint[] memory indices) internal pure returns (Data.Order[] memory orders) {\r\n        uint numOrders = bytesToUint16(ringData, 2);\r\n        uint numRings = bytesToUint16(ringData, 4);\r\n        uint numSpendables = bytesToUint16(ringData, 6);\r\n\r\n        uint dataPtr;\r\n        assembly {dataPtr := ringData}\r\n        uint orderDataPtr = (dataPtr + 8) + 3 * 2;\r\n        uint ringDataPtr = orderDataPtr + (32 * numOrders) * 2;\r\n        uint dataBlobPtr = ringDataPtr + (numRings * 9) + 32;\r\n\r\n        // orders = new LoopringOrder[](indices.length);\r\n        orders = new Data.Order[](indices.length);\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            orders[i] = _decodeLoopringOrderAtIndex(dataBlobPtr, orderDataPtr + 2, numSpendables, indices[i]);\r\n        }\r\n    }\r\n\r\n    // ----------------------------\r\n\r\n    function _decodeLoopringOrderAtIndex(uint data, uint tablesPtr, uint numSpendables, uint orderIndex) private pure returns (Data.Order memory order) {\r\n        tablesPtr += 64 * orderIndex;\r\n\r\n        uint offset;\r\n        bytes memory emptyBytes = new bytes(0);\r\n        address lrcTokenAddress = address(0);\r\n        Data.Spendable[] memory spendableList = new Data.Spendable[](numSpendables);\r\n        uint orderStructSize = 40 * 32;\r\n\r\n        assembly {\r\n            order := mload(0x40)\r\n            mstore(0x40, add(order, orderStructSize)) // Reserve memory for the order struct\r\n\r\n        // order.version\r\n            offset := and(mload(add(tablesPtr, 0)), 0xFFFF)\r\n            mstore(\r\n            add(order, 0),\r\n            offset\r\n            )\r\n\r\n        // order.owner\r\n            offset := mul(and(mload(add(tablesPtr, 2)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 32),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.tokenS\r\n            offset := mul(and(mload(add(tablesPtr, 4)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 64),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.tokenB\r\n            offset := mul(and(mload(add(tablesPtr, 6)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 96),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.amountS\r\n            offset := mul(and(mload(add(tablesPtr, 8)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 128),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.amountB\r\n            offset := mul(and(mload(add(tablesPtr, 10)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 160),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.validSince\r\n            offset := mul(and(mload(add(tablesPtr, 12)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 192),\r\n            and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)\r\n            )\r\n\r\n        // order.tokenSpendableS\r\n            offset := and(mload(add(tablesPtr, 14)), 0xFFFF)\r\n        // Force the spendable index to 0 if it's invalid\r\n            offset := mul(offset, lt(offset, numSpendables))\r\n            mstore(\r\n            add(order, 224),\r\n            mload(add(spendableList, mul(add(offset, 1), 32)))\r\n            )\r\n\r\n        // order.tokenSpendableFee\r\n            offset := and(mload(add(tablesPtr, 16)), 0xFFFF)\r\n        // Force the spendable index to 0 if it's invalid\r\n            offset := mul(offset, lt(offset, numSpendables))\r\n            mstore(\r\n            add(order, 256),\r\n            mload(add(spendableList, mul(add(offset, 1), 32)))\r\n            )\r\n\r\n        // order.dualAuthAddr\r\n            offset := mul(and(mload(add(tablesPtr, 18)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 288),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.broker\r\n            offset := mul(and(mload(add(tablesPtr, 20)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 320),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.orderInterceptor\r\n            offset := mul(and(mload(add(tablesPtr, 22)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 416),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.wallet\r\n            offset := mul(and(mload(add(tablesPtr, 24)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 448),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // order.validUntil\r\n            offset := mul(and(mload(add(tablesPtr, 26)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 480),\r\n            and(mload(add(add(data, 4), offset)), 0xFFFFFFFF)\r\n            )\r\n\r\n        // Default to empty bytes array for value sig and dualAuthSig\r\n            mstore(add(data, 32), emptyBytes)\r\n\r\n        // order.sig\r\n            offset := mul(and(mload(add(tablesPtr, 28)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 512),\r\n            add(data, add(offset, 32))\r\n            )\r\n\r\n        // order.dualAuthSig\r\n            offset := mul(and(mload(add(tablesPtr, 30)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 544),\r\n            add(data, add(offset, 32))\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 32), 0)\r\n\r\n        // order.allOrNone\r\n            offset := and(mload(add(tablesPtr, 32)), 0xFFFF)\r\n            mstore(\r\n            add(order, 576),\r\n            gt(offset, 0)\r\n            )\r\n\r\n        // lrcTokenAddress is the default value for feeToken\r\n            mstore(add(data, 20), lrcTokenAddress)\r\n\r\n        // order.feeToken\r\n            offset := mul(and(mload(add(tablesPtr, 34)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 608),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n        // order.feeAmount\r\n            offset := mul(and(mload(add(tablesPtr, 36)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 640),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.waiveFeePercentage\r\n            offset := and(mload(add(tablesPtr, 38)), 0xFFFF)\r\n            mstore(\r\n            add(order, 672),\r\n            offset\r\n            )\r\n\r\n        // order.tokenSFeePercentage\r\n            offset := and(mload(add(tablesPtr, 40)), 0xFFFF)\r\n            mstore(\r\n            add(order, 704),\r\n            offset\r\n            )\r\n\r\n        // order.tokenBFeePercentage\r\n            offset := and(mload(add(tablesPtr, 42)), 0xFFFF)\r\n            mstore(\r\n            add(order, 736),\r\n            offset\r\n            )\r\n\r\n        // The owner is the default value of tokenRecipient\r\n        // order.owner\r\n            mstore(add(data, 20), mload(add(order, 32)))\r\n\r\n        // order.tokenRecipient\r\n            offset := mul(and(mload(add(tablesPtr, 44)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 768),\r\n            and(mload(add(add(data, 20), offset)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n        // order.walletSplitPercentage\r\n            offset := and(mload(add(tablesPtr, 46)), 0xFFFF)\r\n            mstore(\r\n            add(order, 800),\r\n            offset\r\n            )\r\n\r\n        // order.tokenTypeS\r\n            offset := and(mload(add(tablesPtr, 48)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1024),\r\n            offset\r\n            )\r\n\r\n        // order.tokenTypeB\r\n            offset := and(mload(add(tablesPtr, 50)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1056),\r\n            offset\r\n            )\r\n\r\n        // order.tokenTypeFee\r\n            offset := and(mload(add(tablesPtr, 52)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1088),\r\n            offset\r\n            )\r\n\r\n        // order.trancheS\r\n            offset := mul(and(mload(add(tablesPtr, 54)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1120),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.trancheB\r\n            offset := mul(and(mload(add(tablesPtr, 56)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1152),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 20), 0)\r\n\r\n        // order.maxPrimaryFillAmount\r\n            offset := mul(and(mload(add(tablesPtr, 58)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1184),\r\n            mload(add(add(data, 32), offset))\r\n            )\r\n\r\n        // order.allOrNone\r\n            offset := and(mload(add(tablesPtr, 60)), 0xFFFF)\r\n            mstore(\r\n            add(order, 1216),\r\n            gt(offset, 0)\r\n            )\r\n\r\n        // Default to empty bytes array for transferDataS\r\n            mstore(add(data, 32), emptyBytes)\r\n\r\n        // order.transferDataS\r\n            offset := mul(and(mload(add(tablesPtr, 62)), 0xFFFF), 4)\r\n            mstore(\r\n            add(order, 1248),\r\n            add(data, add(offset, 32))\r\n            )\r\n\r\n        // Restore default to 0\r\n            mstore(add(data, 32), 0)\r\n\r\n        // Set default  values\r\n            mstore(add(order, 832), 0)         // order.P2P\r\n            mstore(add(order, 864), 0)         // order.hash\r\n            mstore(add(order, 896), 0)         // order.brokerInterceptor\r\n            mstore(add(order, 928), 0)         // order.filledAmountS\r\n            mstore(add(order, 960), 0)         // order.initialFilledAmountS\r\n            mstore(add(order, 992), 1)         // order.valid\r\n\r\n        }\r\n    }\r\n\r\n    function bytesToUintX(bytes memory b, uint offset, uint numBytes) private pure returns (uint data) {\r\n        require(b.length >= offset + numBytes, \"INVALID_SIZE\");\r\n        assembly {data := mload(add(add(b, numBytes), offset))}\r\n    }\r\n\r\n    function bytesToUint16(bytes memory b, uint offset) private pure returns (uint16) {\r\n        return uint16(bytesToUintX(b, offset, 2) & 0xFFFF);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/loopring/iface/IBrokerDelegate.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\ninterface IBrokerDelegate {\r\n\r\n  /*\r\n   * Loopring requests an allowance be set on a given token for a specified amount. Order details\r\n   * are provided (tokenS, totalAmountS, tokenB, totalAmountB, orderTokenRecipient, extraOrderData)\r\n   * to aid in any calculations or on-chain exchange of assets that may be required. The last 4\r\n   * parameters concern the actual token approval being requested of the broker.\r\n   *\r\n   * @returns Whether or not onOrderFillReport should be called for orders using this broker\r\n   */\r\n  function brokerRequestAllowance(BrokerData.BrokerApprovalRequest calldata request) external returns (bool);\r\n\r\n  /*\r\n   * After Loopring performs all of the transfers necessary to complete all the submitted\r\n   * rings it will call this function for every order's brokerInterceptor (if set) passing\r\n   * along the final fill counts for tokenB, tokenS and feeToken. This allows actions to be\r\n   * performed on a per-order basis after all tokenS/feeToken funds have left the order owner's\r\n   * possession and the tokenB funds have been transferred to the order owner's intended recipient\r\n   */\r\n  function onOrderFillReport(BrokerData.BrokerInterceptorReport calldata fillReport) external;\r\n\r\n  /*\r\n   * Get the available token balance controlled by the broker on behalf of an address (owner)\r\n   */\r\n  function brokerBalanceOf(address owner, address token) external view returns (uint);\r\n}\r\n\r\n// File: contracts/dolomite-direct/interfaces/IDepositContract.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\ninterface IDepositContract {\r\n\r\n    function perform(\r\n        address addr,\r\n        string calldata signature,\r\n        bytes calldata encodedParams,\r\n        uint value\r\n    ) external returns (bytes memory);\r\n\r\n}\r\n\r\n// File: contracts/dolomite-direct/interfaces/IVersionable.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\ninterface IVersionable {\r\n\r\n  /*\r\n   * Is called by IDepositContractRegistry when this version\r\n   * is being upgraded to. Will call `versionEndUsage` on the\r\n   * old contract before calling this one\r\n   */\r\n  function versionBeginUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address oldVersion,\r\n    bytes calldata additionalData\r\n  ) external;\r\n\r\n  /*\r\n   * Is called by IDepositContractRegistry when this version is\r\n   * being upgraded from. IDepositContractRegistry will then call\r\n   * `versionBeginUsage` on the new contract\r\n   */\r\n  function versionEndUsage(\r\n    address owner,\r\n    address payable depositAddress,\r\n    address newVersion,\r\n    bytes calldata additionalData\r\n  ) external;\r\n\r\n}\r\n\r\n// File: contracts/dolomite-direct/interfaces/IDolomiteMarginTradingBroker.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\ninterface IDolomiteMarginTradingBroker {\r\n\r\n    function brokerMarginRequestApproval(address owner, address token, uint amount) external;\r\n\r\n    function brokerMarginGetTrader(address owner, bytes calldata orderData) external view returns (address);\r\n}\r\n\r\n// File: contracts/dolomite-direct/lib/DepositContractImpl.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\nlibrary DepositContractImpl {\r\n\r\n    function wrapAndTransferToken(\r\n        IDepositContract self,\r\n        address token,\r\n        address recipient,\r\n        uint amount,\r\n        address wethAddress\r\n    ) internal {\r\n        if (token == wethAddress) {\r\n            uint etherBalance = address(self).balance;\r\n            if (etherBalance > 0) {\r\n                wrapEth(self, token, etherBalance);\r\n            }\r\n        }\r\n        transferToken(self, token, recipient, amount);\r\n    }\r\n\r\n    function transferToken(IDepositContract self, address token, address recipient, uint amount) internal {\r\n        self.perform(token, \"transfer(address,uint256)\", abi.encode(recipient, amount), 0);\r\n    }\r\n\r\n    function transferEth(IDepositContract self, address recipient, uint amount) internal {\r\n        self.perform(recipient, \"\", abi.encode(), amount);\r\n    }\r\n\r\n    function approveToken(IDepositContract self, address token, address broker, uint amount) internal {\r\n        self.perform(token, \"approve(address,uint256)\", abi.encode(broker, amount), 0);\r\n    }\r\n\r\n    function wrapEth(IDepositContract self, address wethToken, uint amount) internal {\r\n        self.perform(wethToken, \"deposit()\", abi.encode(), amount);\r\n    }\r\n\r\n    function unwrapWeth(IDepositContract self, address wethToken, uint amount) internal {\r\n        self.perform(wethToken, \"withdraw(uint256)\", abi.encode(amount), 0);\r\n    }\r\n\r\n    function setDyDxOperator(IDepositContract self, address dydxContract, address operator) internal {\r\n        bytes memory encodedParams = abi.encode(\r\n            bytes32(0x0000000000000000000000000000000000000000000000000000000000000020),\r\n            bytes32(0x0000000000000000000000000000000000000000000000000000000000000001),\r\n            operator,\r\n            bytes32(0x0000000000000000000000000000000000000000000000000000000000000001)\r\n        );\r\n        self.perform(dydxContract, \"setOperators((address,bool)[])\", encodedParams, 0);\r\n    }\r\n}\r\n\r\n// File: contracts/dolomite-direct/lib/Types.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\nlibrary Types {\r\n\r\n    struct RequestFee {\r\n        address feeRecipient;\r\n        address feeToken;\r\n        uint feeAmount;\r\n    }\r\n\r\n    struct RequestSignature {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    enum RequestType {Update, Transfer, Approve, Perform, DepositCollateral, WithdrawCollateral}\r\n\r\n    struct Request {\r\n        address owner;\r\n        address target;\r\n        RequestType requestType;\r\n        bytes payload;\r\n        uint nonce;\r\n        RequestFee fee;\r\n        RequestSignature signature;\r\n    }\r\n\r\n    struct TransferRequest {\r\n        address token;\r\n        address recipient;\r\n        uint amount;\r\n        bool unwrap;\r\n    }\r\n\r\n    struct UpdateRequest {\r\n        address version;\r\n        bytes additionalData;\r\n    }\r\n\r\n    struct ApproveRequest {\r\n        address operator;\r\n        bool canOperate;\r\n    }\r\n\r\n    struct PerformRequest {\r\n        address to;\r\n        string functionSignature;\r\n        bytes encodedParams;\r\n        uint value;\r\n    }\r\n\r\n    struct DepositCollateralRequest {\r\n        uint positionId;\r\n        uint tokenId;\r\n        uint amount;\r\n    }\r\n\r\n    struct WithdrawCollateralRequest {\r\n        uint positionId;\r\n        uint tokenId;\r\n        uint amount;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/dolomite-direct/lib/RequestImpl.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\nlibrary RequestImpl {\r\n\r\n    bytes constant personalPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n    function getSigner(Types.Request memory self) internal pure returns (address) {\r\n        bytes32 messageHash = keccak256(abi.encode(\r\n                self.owner,\r\n                self.target,\r\n                self.requestType,\r\n                self.payload,\r\n                self.nonce,\r\n                abi.encode(self.fee.feeRecipient, self.fee.feeToken, self.fee.feeAmount)\r\n            ));\r\n\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(personalPrefix, messageHash));\r\n        return ecrecover(prefixedHash, self.signature.v, self.signature.r, self.signature.s);\r\n    }\r\n\r\n    function decodeTransferRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.TransferRequest memory){\r\n        require(self.requestType == Types.RequestType.Transfer, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        address token,\r\n        address recipient,\r\n        uint amount,\r\n        bool unwrap\r\n        ) = abi.decode(self.payload, (address, address, uint, bool));\r\n\r\n        return Types.TransferRequest({\r\n        token : token,\r\n        recipient : recipient,\r\n        amount : amount,\r\n        unwrap : unwrap\r\n        });\r\n    }\r\n\r\n    function decodeDepositCollateralRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.DepositCollateralRequest memory){\r\n        require(self.requestType == Types.RequestType.DepositCollateral, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount\r\n        ) = abi.decode(self.payload, (uint, uint, uint));\r\n\r\n        return Types.DepositCollateralRequest({\r\n        positionId: positionId,\r\n        tokenId: tokenId,\r\n        amount: amount\r\n        });\r\n    }\r\n\r\n    function decodeWithdrawCollateralRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.WithdrawCollateralRequest memory){\r\n        require(self.requestType == Types.RequestType.WithdrawCollateral, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount\r\n        ) = abi.decode(self.payload, (uint, uint, uint));\r\n\r\n        return Types.WithdrawCollateralRequest({\r\n        positionId: positionId,\r\n        tokenId: tokenId,\r\n        amount: amount\r\n        });\r\n    }\r\n\r\n    function decodeUpdateRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.UpdateRequest memory updateRequest)\r\n    {\r\n        require(self.requestType == Types.RequestType.Update, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        updateRequest.version,\r\n        updateRequest.additionalData\r\n        ) = abi.decode(self.payload, (address, bytes));\r\n    }\r\n\r\n    function decodeApproveRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.ApproveRequest memory approveRequest)\r\n    {\r\n        require(self.requestType == Types.RequestType.Approve, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        approveRequest.operator,\r\n        approveRequest.canOperate\r\n        ) = abi.decode(self.payload, (address, bool));\r\n    }\r\n\r\n    function decodePerformRequest(Types.Request memory self)\r\n    internal\r\n    pure\r\n    returns (Types.PerformRequest memory performRequest)\r\n    {\r\n        require(self.requestType == Types.RequestType.Perform, \"INVALID_REQUEST_TYPE\");\r\n\r\n        (\r\n        performRequest.to,\r\n        performRequest.functionSignature,\r\n        performRequest.encodedParams,\r\n        performRequest.value\r\n        ) = abi.decode(self.payload, (address, string, bytes, uint));\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/dolomite-direct/Requestable.sol\r\n\r\ncontract Requestable {\r\n\r\n    using RequestImpl for Types.Request;\r\n\r\n    mapping(address => uint) nonces;\r\n\r\n    function validateRequest(Types.Request memory request) internal {\r\n        require(request.target == address(this), \"INVALID_TARGET\");\r\n        require(request.getSigner() == request.owner, \"INVALID_SIGNATURE\");\r\n        require(nonces[request.owner] + 1 == request.nonce, \"INVALID_NONCE\");\r\n\r\n        if (request.fee.feeAmount > 0) {\r\n            require(balanceOf(request.owner, request.fee.feeToken) >= request.fee.feeAmount, \"INSUFFICIENT_FEE_BALANCE\");\r\n        }\r\n\r\n        nonces[request.owner] += 1;\r\n    }\r\n\r\n    function completeRequest(Types.Request memory request) internal {\r\n        if (request.fee.feeAmount > 0) {\r\n            _payRequestFee(request.owner, request.fee.feeToken, request.fee.feeRecipient, request.fee.feeAmount);\r\n        }\r\n    }\r\n\r\n    function nonceOf(address owner) public view returns (uint) {\r\n        return nonces[owner];\r\n    }\r\n\r\n    // Abtract functions\r\n    function balanceOf(address owner, address token) public view returns (uint);\r\n    function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal;\r\n}\r\n\r\n// File: contracts/dolomite-direct/DolomiteDirectV1.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DolomiteDirectV1\r\n * @author Zack Rubenstein from Dolomite\r\n *\r\n * Interfaces with the IDepositContractRegistry and individual \r\n * IDepositContracts to enable smart-wallet functionality as well\r\n * as spot and margin trading on Dolomite (through Loopring & dYdX)\r\n */\r\ncontract DolomiteDirectV1 is Requestable, IVersionable, IDolomiteMarginTradingBroker {\r\n    using DepositContractImpl for IDepositContract;\r\n    using SafeMath for uint;\r\n\r\n    IDepositContractRegistry public registry;\r\n    address public loopringDelegate;\r\n    address public dolomiteMarginProtocolAddress;\r\n    address public dydxProtocolAddress;\r\n    address public wethTokenAddress;\r\n\r\n    constructor(\r\n        address _depositContractRegistry,\r\n        address _loopringDelegate,\r\n        address _dolomiteMarginProtocol,\r\n        address _dydxProtocolAddress,\r\n        address _wethTokenAddress\r\n    ) public {\r\n        registry = IDepositContractRegistry(_depositContractRegistry);\r\n        loopringDelegate = _loopringDelegate;\r\n        dolomiteMarginProtocolAddress = _dolomiteMarginProtocol;\r\n        dydxProtocolAddress = _dydxProtocolAddress;\r\n        wethTokenAddress = _wethTokenAddress;\r\n    }\r\n\r\n    /*\r\n     * Returns the available balance for an owner that this contract manages.\r\n     * If the token is WETH, it returns the sum of the ETH and WETH balance,\r\n     * as ETH is automatically wrapped upon transfers (unless the unwrap option is\r\n     * set to true in the transfer request)\r\n     */\r\n    function balanceOf(address owner, address token) public view returns (uint) {\r\n        address depositAddress = registry.depositAddressOf(owner);\r\n        uint tokenBalance = IERC20(token).balanceOf(depositAddress);\r\n        if (token == wethTokenAddress) tokenBalance = tokenBalance.add(depositAddress.balance);\r\n        return tokenBalance;\r\n    }\r\n\r\n    /*\r\n     * Send up a signed transfer request and the given amount tokens\r\n     * is transferred to the specified recipient.\r\n     */\r\n    function transfer(Types.Request memory request) public {\r\n        validateRequest(request);\r\n\r\n        Types.TransferRequest memory transferRequest = request.decodeTransferRequest();\r\n        address payable depositAddress = registry.depositAddressOf(request.owner);\r\n\r\n        _transfer(\r\n            transferRequest.token,\r\n            depositAddress,\r\n            transferRequest.recipient,\r\n            transferRequest.amount,\r\n            transferRequest.unwrap\r\n        );\r\n\r\n        completeRequest(request);\r\n    }\r\n\r\n    // =============================\r\n\r\n    function _transfer(address token, address payable depositAddress, address recipient, uint amount, bool unwrap) internal {\r\n        IDepositContract depositContract = IDepositContract(depositAddress);\r\n\r\n        if (token == wethTokenAddress && unwrap) {\r\n            if (depositAddress.balance < amount) {\r\n                depositContract.unwrapWeth(wethTokenAddress, amount.sub(depositAddress.balance));\r\n            }\r\n\r\n            depositContract.transferEth(recipient, amount);\r\n            return;\r\n        }\r\n\r\n        depositContract.wrapAndTransferToken(token, recipient, amount, wethTokenAddress);\r\n    }\r\n\r\n    // -----------------------------\r\n    // Loopring Broker Delegate\r\n\r\n    function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public returns (bool) {\r\n        require(msg.sender == loopringDelegate);\r\n\r\n        BrokerData.BrokerOrder[] memory mergedOrders = new BrokerData.BrokerOrder[](request.orders.length);\r\n        uint numMergedOrders = 1;\r\n\r\n        mergedOrders[0] = request.orders[0];\r\n\r\n        if (request.orders.length > 1) {\r\n            for (uint i = 1; i < request.orders.length; i++) {\r\n                bool isDuplicate = false;\r\n\r\n                for (uint b = 0; b < numMergedOrders; b++) {\r\n                    if (request.orders[i].owner == mergedOrders[b].owner) {\r\n                        mergedOrders[b].requestedAmountS += request.orders[i].requestedAmountS;\r\n                        mergedOrders[b].requestedFeeAmount += request.orders[i].requestedFeeAmount;\r\n                        isDuplicate = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!isDuplicate) {\r\n                    mergedOrders[numMergedOrders] = request.orders[i];\r\n                    numMergedOrders += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (uint j = 0; j < numMergedOrders; j++) {\r\n            BrokerData.BrokerOrder memory order = mergedOrders[j];\r\n            address payable depositAddress = registry.depositAddressOf(order.owner);\r\n\r\n            _transfer(request.tokenS, depositAddress, address(this), order.requestedAmountS, false);\r\n            if (order.requestedFeeAmount > 0) _transfer(request.feeToken, depositAddress, address(this), order.requestedFeeAmount, false);\r\n        }\r\n\r\n        return false;\r\n        // Does not use onOrderFillReport\r\n    }\r\n\r\n    function onOrderFillReport(BrokerData.BrokerInterceptorReport memory fillReport) public {\r\n        // Do nothing\r\n    }\r\n\r\n    function brokerBalanceOf(address owner, address tokenAddress) public view returns (uint) {\r\n        return balanceOf(owner, tokenAddress);\r\n    }\r\n\r\n    // ----------------------------\r\n    // Dolomite Margin Trading Broker\r\n\r\n    function brokerMarginRequestApproval(address owner, address token, uint amount) public {\r\n        require(msg.sender == dolomiteMarginProtocolAddress || msg.sender == loopringDelegate, \"brokerMarginRequestApproval: INVALID_SENDER\");\r\n\r\n        address payable depositAddress = registry.depositAddressOf(owner);\r\n        _transfer(token, depositAddress, address(this), amount, false);\r\n    }\r\n\r\n    function brokerMarginGetTrader(address owner, bytes memory orderData) public view returns (address) {\r\n        return registry.depositAddressOf(owner);\r\n    }\r\n\r\n    // -----------------------------\r\n    // Requestable\r\n\r\n    function _payRequestFee(address owner, address feeToken, address feeRecipient, uint feeAmount) internal {\r\n        _transfer(feeToken, registry.depositAddressOf(owner), feeRecipient, feeAmount, false);\r\n    }\r\n\r\n    // -----------------------------\r\n    // Versionable\r\n\r\n    function versionBeginUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address oldVersion,\r\n        bytes calldata additionalData\r\n    ) external {\r\n        // Approve the DolomiteMarginProtocol as an operator for the deposit contract's dYdX account\r\n        IDepositContract(depositAddress).setDyDxOperator(dydxProtocolAddress, dolomiteMarginProtocolAddress);\r\n    }\r\n\r\n    function versionEndUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address newVersion,\r\n        bytes calldata additionalData\r\n    ) external {/* do nothing */}\r\n\r\n\r\n    // =============================\r\n    // Administrative\r\n\r\n    /*\r\n     * Tokens are held in individual deposit contracts, the only time a trader's\r\n     * funds are held by this contract is when Loopring or dYdX requests a trader's\r\n     * tokens, and immediately upon this contract moving funds into itself, Loopring\r\n     * or dYdX will move the funds out and into themselves. Thus, we can open this\r\n     * function up for anyone to call to set or reset the approval for Loopring and\r\n     * dYdX for a given token. The reason these approvals are set globally and not\r\n     * on an as-needed (per fill) basis is to reduce gas costs.\r\n     */\r\n    function enableTrading(address token) public {\r\n        IERC20(token).approve(loopringDelegate, uint(- 1));\r\n        IERC20(token).approve(dolomiteMarginProtocolAddress, uint(- 1));\r\n    }\r\n\r\n    function enableTrading(address[] calldata tokens) external {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            enableTrading(tokens[i]);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/dolomite-direct/DolomiteDirectV2.sol\r\n\r\n/*\r\n * Copyright 2020 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.7;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DolomiteDirectV2\r\n */\r\ncontract DolomiteDirectV2 is DolomiteDirectV1 {\r\n\r\n    constructor(\r\n        address _depositContractRegistry,\r\n        address _loopringDelegate,\r\n        address _dolomiteMarginProtocol,\r\n        address _dydxProtocolAddress,\r\n        address _wethTokenAddress\r\n    ) public DolomiteDirectV1(\r\n        _depositContractRegistry,\r\n        _loopringDelegate,\r\n        _dolomiteMarginProtocol,\r\n        _dydxProtocolAddress,\r\n        _wethTokenAddress\r\n    ) {\r\n    }\r\n\r\n    function depositCollateral(Types.Request memory request) public {\r\n        validateRequest(request);\r\n\r\n        Types.DepositCollateralRequest memory depositCollateralRequest = request.decodeDepositCollateralRequest();\r\n        address payable depositAddress = registry.depositAddressOf(request.owner);\r\n\r\n        address token = IDyDxProtocol(dydxProtocolAddress).getMarketTokenAddress(depositCollateralRequest.tokenId);\r\n\r\n        uint amount;\r\n        if (depositCollateralRequest.amount == uint(- 1)) {\r\n            amount = IERC20(token).balanceOf(depositAddress);\r\n        } else {\r\n            amount = depositCollateralRequest.amount;\r\n        }\r\n\r\n        _transfer(\r\n            token,\r\n            depositAddress,\r\n            address(this),\r\n            amount,\r\n            false\r\n        );\r\n\r\n        _depositCollateralIntoDyDx(\r\n            depositAddress,\r\n            depositCollateralRequest.positionId,\r\n            depositCollateralRequest.tokenId,\r\n            amount\r\n        );\r\n\r\n        completeRequest(request);\r\n    }\r\n\r\n    function withdrawCollateral(Types.Request memory request) public {\r\n        validateRequest(request);\r\n\r\n        Types.WithdrawCollateralRequest memory withdrawCollateralRequest = request.decodeWithdrawCollateralRequest();\r\n        address payable depositAddress = registry.depositAddressOf(request.owner);\r\n\r\n        _withdrawCollateralFromDyDx(\r\n            depositAddress,\r\n            withdrawCollateralRequest.positionId,\r\n            withdrawCollateralRequest.tokenId,\r\n            withdrawCollateralRequest.amount\r\n        );\r\n\r\n        completeRequest(request);\r\n    }\r\n\r\n    function versionBeginUsage(\r\n        address owner,\r\n        address payable depositAddress,\r\n        address oldVersion,\r\n        bytes calldata additionalData\r\n    ) external {\r\n        // Approve the this address as an operator for the deposit contract's dYdX account\r\n        IDepositContract(depositAddress).setDyDxOperator(dydxProtocolAddress, address(this));\r\n    }\r\n\r\n    // *************************\r\n    // ***** Internal Functions\r\n    // *************************\r\n\r\n    function _depositCollateralIntoDyDx(\r\n        address depositAddress,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount\r\n    ) internal {\r\n        DyDxPosition.Info[] memory infos = new DyDxPosition.Info[](1);\r\n        infos[0] = DyDxPosition.Info(depositAddress, positionId);\r\n\r\n        DyDxActions.ActionArgs[] memory args = new DyDxActions.ActionArgs[](1);\r\n        args[0] = DyDxActionBuilder.Deposit(0, tokenId, amount, /* from */ address(this));\r\n\r\n        IDyDxProtocol(dydxProtocolAddress).operate(infos, args);\r\n    }\r\n\r\n    function _withdrawCollateralFromDyDx(\r\n        address depositAddress,\r\n        uint positionId,\r\n        uint tokenId,\r\n        uint amount\r\n    ) internal {\r\n        DyDxPosition.Info[] memory infos = new DyDxPosition.Info[](1);\r\n        infos[0] = DyDxPosition.Info(depositAddress, positionId);\r\n\r\n        DyDxActions.ActionArgs[] memory args = new DyDxActions.ActionArgs[](1);\r\n        if (amount == uint(- 1)) {\r\n            args[0] = DyDxActionBuilder.WithdrawAll(0, tokenId, /* to */ depositAddress);\r\n        } else {\r\n            args[0] = DyDxActionBuilder.Withdraw(0, tokenId, amount, /* to */ depositAddress);\r\n        }\r\n\r\n        IDyDxProtocol(dydxProtocolAddress).operate(infos, args);\r\n    }\r\n\r\n}\r\n\r\n// function depositCollateral(uint positionId, uint tokenId, uint amount)\r\n// function withdrawCollateral(uint positionId, uint tokenId, uint amount)"}}}