{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MetaWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function approve(address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract MetaWallet {\r\n    \r\n    string public constant name = \"MetaWallet\";\r\n    \r\n    address private _owner0;\r\n    address private _owner1;\r\n    \r\n    address private _pendingOwner0;\r\n    address private _pendingOwner1;\r\n    \r\n    constructor(address owner0, address owner1) public {\r\n        _owner0 = owner0;\r\n        _owner1 = owner1;\r\n    }\r\n    \r\n    // @notice The EIP-712 typehash for the contract's domain\r\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint chainId,address verifyingContract)\");\r\n\r\n    /// @notice The EIP-712 typehash for the execute struct used by the contract\r\n    bytes32 public constant EXECUTE_TYPEHASH = keccak256(\"Execute(address to,uint value,bytes data,uint nonces,uint deadline)\");\r\n\r\n    /// @notice The EIP-712 typehash for the send struct used by the contract\r\n    bytes32 public constant SEND_TYPEHASH = keccak256(\"Send(address to,uint value,uint nonces,uint deadline)\");\r\n\r\n    /// @notice The EIP-712 typehash for the transfer struct used by the contract\r\n    bytes32 public constant TRANSFER_TYPEHASH = keccak256(\"Transfer(address token,address to,uint value,uint nonces,uint deadline)\");\r\n\r\n    /// @notice The EIP-712 typehash for the approve struct used by the contract\r\n    bytes32 public constant APPROVE_TYPEHASH = keccak256(\"Approve(address token,address to,uint value,uint nonces,uint deadline)\");\r\n    \r\n    function transferOwnership(address _newOwner) external {\r\n        require(msg.sender == _owner0 || msg.sender == _owner1, \"MetaWallet::transferOwnership: !owner\");\r\n        if (msg.sender == _owner0) {\r\n            _pendingOwner0 = _newOwner;\r\n        } else if (msg.sender == _owner1) {\r\n            _pendingOwner1 = _newOwner;\r\n        }\r\n    }\r\n    \r\n    function acceptOwnership() external {\r\n        require(msg.sender == _pendingOwner0 || msg.sender == _pendingOwner1, \"MetaWallet::acceptOwnership: !pendingOwner\");\r\n        if (msg.sender == _pendingOwner0) {\r\n            _owner0 = _pendingOwner0;\r\n        } else if (msg.sender == _pendingOwner1) {\r\n            _owner1 = _pendingOwner1;\r\n        }\r\n    }\r\n    \r\n    /// @notice A record of states for signing / validating signatures\r\n    uint public nonces;\r\n    \r\n    fallback() external {}\r\n    \r\n    function send(address payable to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool, bytes memory) {\r\n        require(_verify(keccak256(abi.encode(SEND_TYPEHASH, to, value, nonces++, deadline)), deadline, v, r, s));\r\n        return to.call{value: value}(\"\");\r\n    }\r\n    \r\n    function transfer(address token, address to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {\r\n        require(_verify(keccak256(abi.encode(TRANSFER_TYPEHASH, token, to, value, nonces++, deadline)), deadline, v, r, s));\r\n        return IERC20(token).transfer(to, value);\r\n    }\r\n    \r\n    function approve(address token, address to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {\r\n        require(_verify(keccak256(abi.encode(APPROVE_TYPEHASH, token, to, value, nonces++, deadline)), deadline, v, r, s));\r\n        return IERC20(token).approve(to, value);\r\n    }\r\n    \r\n    function _verify(bytes32 structHash, uint deadline, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this)));\r\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        return ((signatory == _owner0 || signatory == _owner1) && now <= deadline);\r\n    }\r\n    \r\n    struct stack {\r\n        address recipients;\r\n        uint values;\r\n        bytes datas;\r\n        uint deadlines; \r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n    \r\n    function batch(stack[] calldata stacks) external returns (bool[] memory results, bytes[] memory responses) {\r\n        for (uint i = 0; i < stacks.length; i++) {\r\n            (results[i], responses[i]) = _exec(stacks[i].recipients, stacks[i].values, stacks[i].datas, stacks[i].deadlines, stacks[i].v, stacks[i].r, stacks[i].s);\r\n        }\r\n    }\r\n    \r\n    function execute(address to, uint value, bytes calldata data, uint deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool, bytes memory) {\r\n        return _exec(to, value, data, deadline, v, r, s);\r\n    }\r\n    \r\n    function _exec(address to, uint value, bytes memory data, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool, bytes memory) {\r\n        require(_verify(keccak256(abi.encode(EXECUTE_TYPEHASH, to, value, data, nonces++, deadline)), deadline, v, r, s));\r\n        return to.call{value: value}(data);\r\n    }\r\n    \r\n    function _getChainId() internal pure returns (uint) {\r\n        uint chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n}\r\n\r\ncontract MetaWalletFactory {\r\n    \r\n    struct stack {\r\n        address wallet;\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n        uint deadline; \r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n    \r\n    struct id {\r\n        uint index0;\r\n        address owner0;\r\n        uint index1;\r\n        address owner1;\r\n    }\r\n    \r\n    mapping(address => address[]) public lookups;\r\n    mapping(address => id) public indexes;\r\n    \r\n    function lookup(address wallet) external view returns (uint index0, address owner0, uint index1, address owner1) {\r\n        return (indexes[wallet].index0, indexes[wallet].owner0, indexes[wallet].index1, indexes[wallet].owner1);\r\n    }\r\n    \r\n    function wallet(address owner, uint index) external view returns (address) {\r\n        return lookups[owner][index];\r\n    }\r\n    \r\n    function wallets(address owner) external view returns (address[] memory) {\r\n        return lookups[owner];\r\n    }\r\n    \r\n    function createWallet(address _owner0, address _owner1) external {\r\n        address _wallet = address(new MetaWallet(_owner0, _owner1));\r\n        indexes[_wallet] = id(lookups[_owner0].length, _owner0, lookups[_owner1].length, _owner1);\r\n        lookups[_owner0].push(_wallet);\r\n        lookups[_owner1].push(_wallet);\r\n        \r\n    }\r\n    \r\n    function batch(stack[] calldata stacks) external returns (bool[] memory results, bytes[] memory responses) {\r\n        for (uint i = 0; i < stacks.length; i++) {\r\n            (results[i], responses[i]) = MetaWallet(stacks[i].wallet).execute(stacks[i].to, stacks[i].value, stacks[i].data, stacks[i].deadline, stacks[i].v, stacks[i].r, stacks[i].s);\r\n        }\r\n    }\r\n}"
    }
  }
}