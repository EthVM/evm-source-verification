{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/AssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport './Outcome.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport './interfaces/IAssetHolder.sol';\n\n/**\n * @dev An implementation of the IAssetHolder interface. The AssetHolder contract escrows ETH or tokens against state channels. It allows assets to be internally accounted for, and ultimately prepared for transfer from one channel to other channel and/or external destinations, as well as for guarantees to be claimed. Note there is no deposit function and the _transferAsset function is unimplemented; inheriting contracts should implement these functions in a manner appropriate to the asset type (e.g. ETH or ERC20 tokens).\n */\ncontract AssetHolder is IAssetHolder {\n    using SafeMath for uint256;\n\n    address public AdjudicatorAddress;\n\n    mapping(bytes32 => uint256) public holdings;\n\n    mapping(bytes32 => bytes32) public assetOutcomeHashes;\n\n    // **************\n    // External methods\n    // **************\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to.\n     */\n    function transfer(\n        bytes32 fromChannelId,\n        bytes calldata allocationBytes,\n        uint256[] memory indices\n    ) external override {\n        // checks\n        _requireIncreasingIndices(indices);\n        _requireCorrectAllocationHash(fromChannelId, allocationBytes);\n        // effects and interactions\n        _transfer(fromChannelId, allocationBytes, indices);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. Checks against the storage in this contract.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. Checks against the storage in this contract.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAll(bytes32 channelId, bytes calldata allocationBytes) external {\n        // checks\n        _requireCorrectAllocationHash(channelId, allocationBytes);\n        // effects and interactions\n        _transfer(channelId, allocationBytes, new uint256[](0));\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @dev Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     * @param destination External destination or channel to transfer funds *to*.\n     */\n    function claim(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes,\n        bytes32 destination\n    ) external {\n        // checks\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\n        // effects and interactions\n        _claim(guarantorChannelId, guarantee, allocationBytes, destination);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Checks against the storage in this contract.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function claimAll(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes\n    ) external override {\n        // checks\n        _requireCorrectGuaranteeHash(guarantorChannelId, guaranteeBytes);\n        Outcome.Guarantee memory guarantee = abi.decode(guaranteeBytes, (Outcome.Guarantee));\n        _requireCorrectAllocationHash(guarantee.targetChannelId, allocationBytes);\n        // effects and interactions\n        _claimAll(guarantorChannelId, guarantee, allocationBytes);\n    }\n\n    // **************\n    // Permissioned methods\n    // **************\n\n    modifier AdjudicatorOnly {\n        require(msg.sender == AdjudicatorAddress, 'Only NitroAdjudicator authorized');\n        _;\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `channelId` to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\n     * @dev Transfers the funds escrowed against `channelId` and transfers them to the beneficiaries of that channel. No checks performed against storage in this contract. Permissioned.\n     * @param channelId Unique identifier for a state channel.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     */\n    function transferAllAdjudicatorOnly(bytes32 channelId, bytes calldata allocationBytes)\n        external\n        virtual\n        AdjudicatorOnly\n    {\n        // no checks\n        //\n        // effects and interactions\n        _transfer(channelId, allocationBytes, new uint256[](0));\n    }\n\n    /**\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping.\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash)\n        external\n        AdjudicatorOnly\n    {\n        _setAssetOutcomeHash(channelId, assetOutcomeHash);\n    }\n\n    // **************\n    // Internal methods\n    // **************\n\n    function _computeNewAllocation(\n        uint256 initialHoldings,\n        Outcome.AllocationItem[] memory allocation,\n        uint256[] memory indices\n    )\n        internal\n        pure\n        returns (\n            Outcome.AllocationItem[] memory newAllocation,\n            bool safeToDelete,\n            uint256[] memory payouts,\n            uint256 totalPayouts\n        )\n    {\n        // `indices == []` means \"pay out to all\"\n        // Note: by initializing payouts to be an array of fixed length, its entries are initialized to be `0`\n        payouts = new uint256[](indices.length > 0 ? indices.length : allocation.length);\n        totalPayouts = 0;\n        newAllocation = new Outcome.AllocationItem[](allocation.length);\n        safeToDelete = true; // switched to false if there is an item remaining with amount > 0\n        uint256 surplus = initialHoldings; // virtual funds available during calculation\n        uint256 k = 0; // indexes the `indices` array\n\n        // loop over allocations and decrease surplus\n        for (uint256 i = 0; i < allocation.length; i++) {\n            // copy destination part\n            newAllocation[i].destination = allocation[i].destination;\n            // compute new amount part\n            uint256 affordsForDestination = min(allocation[i].amount, surplus);\n            if ((indices.length == 0) || ((k < indices.length) && (indices[k] == i))) {\n                // found a match\n                // reduce the current allocationItem.amount\n                newAllocation[i].amount = allocation[i].amount - affordsForDestination;\n                // increase the relevant payout\n                payouts[k] = affordsForDestination;\n                totalPayouts += affordsForDestination;\n                // move on to the next supplied index\n                ++k;\n            } else {\n                newAllocation[i].amount = allocation[i].amount;\n            }\n            if (newAllocation[i].amount != 0) safeToDelete = false;\n            // decrease surplus by the current amount if possible, else surplus goes to zero\n            surplus -= affordsForDestination;\n        }\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries. Does not check allocationBytes against on chain storage.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to. Should be in increasing order.\n     */\n    function _transfer(\n        bytes32 fromChannelId,\n        bytes memory allocationBytes,\n        uint256[] memory indices\n    ) internal {\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        );\n        uint256 initialHoldings = holdings[fromChannelId];\n\n        (\n            Outcome.AllocationItem[] memory newAllocation,\n            bool safeToDelete,\n            uint256[] memory payouts,\n            uint256 totalPayouts\n        ) = _computeNewAllocation(initialHoldings, allocation, indices);\n\n        // *******\n        // EFFECTS\n        // *******\n\n        holdings[fromChannelId] = initialHoldings.sub(totalPayouts); // expect gas rebate if this is set to 0\n\n        if (safeToDelete) {\n            delete assetOutcomeHashes[fromChannelId];\n        } else {\n            assetOutcomeHashes[fromChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        }\n\n        // *******\n        // INTERACTIONS\n        // *******\n\n        for (uint256 j = 0; j < payouts.length; j++) {\n            if (payouts[j] > 0) {\n                bytes32 destination = allocation[indices.length > 0 ? indices[j] : j].destination;\n                // storage updated BEFORE external contracts called (prevent reentrancy attacks)\n                if (_isExternalDestination(destination)) {\n                    _transferAsset(_bytes32ToAddress(destination), payouts[j]);\n                } else {\n                    holdings[destination] += payouts[j];\n                }\n                // Event emitted\n                emit AssetTransferred(fromChannelId, destination, payouts[j]);\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel.  Does not check allocationBytes or guarantee against on chain storage.\n     * @dev Transfers as many funds escrowed against `guarantorChannelId` as can be afforded for a specific destination in the beneficiaries of the __target__ of that channel.  Does not check allocationBytes or guarantee against on chain storage.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guarantee The guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     * @param destination External destination or channel to transfer funds *to*.\n     */\n    function _claim(\n        bytes32 guarantorChannelId,\n        Outcome.Guarantee memory guarantee,\n        bytes memory allocationBytes,\n        bytes32 destination\n    ) internal {\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        );\n        uint256 balance = holdings[guarantorChannelId];\n        uint256 affordsForDestination;\n        uint256 residualAllocationAmount;\n        uint256 i; // indexes target allocations\n\n        for (uint256 j = 0; j < guarantee.destinations.length; j++) {\n            if (balance == 0) {\n                revert('_claim : guarantorChannel affords 0 for destination');\n            }\n            // for each destination in the guarantee,\n            // find the first corresponding allocationItem in the target allocation\n            bytes32 guaranteeDestination = guarantee.destinations[j];\n            for (i = 0; i < allocation.length; i++) {\n                if (allocation[i].destination == guaranteeDestination) {\n                    // decrease balance\n                    uint256 _amount = allocation[i].amount;\n                    if (balance < _amount) {\n                        if (guaranteeDestination == destination) {\n                            affordsForDestination = balance;\n                            residualAllocationAmount = _amount - balance;\n                            break;\n                            // i will point to index that should be modified or removed in the target outcome\n                        }\n                        balance = 0; // this isn't used after we break\n                    } else {\n                        if (guaranteeDestination == destination) {\n                            affordsForDestination = _amount;\n                            residualAllocationAmount = 0;\n                            break;\n                            // i will point to index that should be modified or removed in the target outcome\n                        }\n                        balance = balance.sub(_amount); // this isn't used after we break\n                    }\n                    break;\n                }\n            }\n            if (affordsForDestination > 0) {\n                // stop lopping as soon as we found the destination in both outcomes such that we can pay something out\n                break;\n            }\n        }\n\n        require(affordsForDestination > 0, '_claim | guarantor affords 0 for destination');\n\n        // effects\n        holdings[guarantorChannelId] -= affordsForDestination;\n\n        // construct new outcome for target\n        if (residualAllocationAmount > 0) {\n            // new allocation identical save for a single entry\n            Outcome.AllocationItem[] memory newAllocation = new Outcome.AllocationItem[](\n                allocation.length\n            );\n            for (uint256 k = 0; k < allocation.length; k++) {\n                newAllocation[k] = allocation[k];\n                if (k == i) {\n                    newAllocation[k].amount = residualAllocationAmount;\n                    break;\n                }\n            }\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        }\n\n        if (residualAllocationAmount == 0) {\n            // We want to splice a shorter outcome\n            if (allocation.length == 1) {\n                // special case there are no allocations left in the target's outcome\n                delete assetOutcomeHashes[guarantee.targetChannelId];\n                delete assetOutcomeHashes[guarantorChannelId];\n            } else {\n                Outcome.AllocationItem[] memory splicedAllocation = new Outcome.AllocationItem[](\n                    allocation.length - 1\n                );\n                for (uint256 k = 0; k < i; k++) {\n                    splicedAllocation[k] = allocation[k];\n                }\n                for (uint256 k = i + 1; k < allocation.length; k++) {\n                    splicedAllocation[k - 1] = allocation[k];\n                }\n                assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            abi.encode(splicedAllocation)\n                        )\n                    )\n                );\n            }\n        }\n\n        // storage updated BEFORE external contracts called (prevent reentrancy attacks)\n        if (_isExternalDestination(destination)) {\n            _transferAsset(_bytes32ToAddress(destination), affordsForDestination);\n        } else {\n            holdings[destination] += affordsForDestination;\n        }\n        // Event emitted\n        emit AssetTransferred(guarantorChannelId, destination, affordsForDestination);\n    }\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes or guarantee against on chain storage.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel. Does not check allocationBytes or guarantee against on chain storage.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guarantee The guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function _claimAll(\n        bytes32 guarantorChannelId,\n        Outcome.Guarantee memory guarantee,\n        bytes memory allocationBytes\n    ) internal {\n        uint256 balance = holdings[guarantorChannelId];\n\n        Outcome.AllocationItem[] memory allocation = abi.decode(\n            allocationBytes,\n            (Outcome.AllocationItem[])\n        ); // this remains constant length\n\n        uint256[] memory payouts = new uint256[](allocation.length);\n        uint256 newAllocationLength = allocation.length;\n\n        // first increase payouts according to guarantee\n        for (uint256 i = 0; i < guarantee.destinations.length; i++) {\n            if (balance == 0) {\n                break;\n            }\n            // for each destination in the guarantee\n            bytes32 _destination = guarantee.destinations[i];\n            for (uint256 j = 0; j < allocation.length; j++) {\n                if (balance == 0) {\n                    break;\n                }\n                if (_destination == allocation[j].destination) {\n                    // find amount allocated to that destination (if it exists in channel alllocation)\n                    uint256 _amount = allocation[j].amount;\n                    if (_amount > 0) {\n                        if (balance >= _amount) {\n                            balance = balance.sub(_amount);\n                            allocation[j].amount = 0; // subtract _amount;\n                            newAllocationLength = newAllocationLength.sub(1);\n                            payouts[j] += _amount;\n                            break;\n                        } else {\n                            allocation[j].amount = _amount.sub(balance);\n                            payouts[j] += balance;\n                            balance = 0;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // next, increase payouts according to original allocation order\n        // this block only has an effect if balance > 0\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each entry in the target channel's outcome\n            if (balance == 0) {\n                break;\n            }\n            uint256 _amount = allocation[j].amount;\n            if (_amount > 0) {\n                if (balance >= _amount) {\n                    balance = balance.sub(_amount);\n                    allocation[j].amount = 0; // subtract _amount;\n                    newAllocationLength = newAllocationLength.sub(1);\n                    payouts[j] += _amount;\n                } else {\n                    allocation[j].amount = _amount.sub(balance);\n                    payouts[j] += balance;\n                    balance = 0;\n                }\n            }\n        }\n\n        // EFFECTS\n        holdings[guarantorChannelId] = balance;\n\n        // at this point have payouts array of uint256s, each corresponding to original destinations\n        // and allocations has some zero amounts which we want to prune\n        Outcome.AllocationItem[] memory newAllocation;\n        if (newAllocationLength > 0) {\n            newAllocation = new Outcome.AllocationItem[](newAllocationLength);\n        }\n\n        uint256 k = 0;\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each destination in the target channel's allocation\n            if (allocation[j].amount > 0) {\n                newAllocation[k] = allocation[j];\n                k++;\n            }\n        }\n        assert(k == newAllocationLength);\n\n        if (newAllocationLength > 0) {\n            // store hash\n            assetOutcomeHashes[guarantee.targetChannelId] = keccak256(\n                abi.encode(\n                    Outcome.AssetOutcome(\n                        uint8(Outcome.AssetOutcomeType.Allocation),\n                        abi.encode(newAllocation)\n                    )\n                )\n            );\n        } else {\n            delete assetOutcomeHashes[guarantorChannelId];\n            delete assetOutcomeHashes[guarantee.targetChannelId];\n        }\n\n        // INTERACTIONS\n        for (uint256 j = 0; j < allocation.length; j++) {\n            // for each destination in the target channel's allocation\n            if (payouts[j] > 0) {\n                if (_isExternalDestination(allocation[j].destination)) {\n                    _transferAsset(_bytes32ToAddress(allocation[j].destination), payouts[j]);\n                } else {\n                    holdings[allocation[j].destination] += payouts[j];\n                }\n                emit AssetTransferred(guarantorChannelId, allocation[j].destination, payouts[j]);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\n     * @dev Sets the given assetOutcomeHash for the given channelId in the assetOutcomeHashes storage mapping\n     * @param channelId Unique identifier for a state channel.\n     * @param assetOutcomeHash The keccak256 of the abi.encode of the Outcome.\n     */\n    function _setAssetOutcomeHash(bytes32 channelId, bytes32 assetOutcomeHash) internal {\n        require(assetOutcomeHashes[channelId] == bytes32(0), 'Outcome hash already exists');\n        assetOutcomeHashes[channelId] = assetOutcomeHash;\n    }\n\n    /**\n     * @notice Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @dev Transfers the given amount of this AssetHolders's asset type to a supplied ethereum address.\n     * @param destination ethereum address to be credited.\n     * @param amount Quantity of assets to be transferred.\n     */\n    function _transferAsset(address payable destination, uint256 amount) internal virtual {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @dev Checks if a given destination is external (and can therefore have assets transferred to it) or not.\n     * @param destination Destination to be checked.\n     * @return True if the destination is external, false otherwise.\n     */\n    function _isExternalDestination(bytes32 destination) internal pure returns (bool) {\n        return uint96(bytes12(destination)) == 0;\n    }\n\n    /**\n     * @notice Converts an ethereum address to a nitro external destination.\n     * @dev Converts an ethereum address to a nitro external destination.\n     * @param participant The address to be converted.\n     * @return The input address left-padded with zeros.\n     */\n    function _addressToBytes32(address participant) internal pure returns (bytes32) {\n        return bytes32(uint256(participant));\n    }\n\n    /**\n     * @notice Converts a nitro destination to an ethereum address.\n     * @dev Converts a nitro destination to an ethereum address.\n     * @param destination The destination to be converted.\n     * @return The rightmost 160 bits of the input string.\n     */\n    function _bytes32ToAddress(bytes32 destination) internal pure returns (address payable) {\n        return address(uint160(uint256(destination)));\n    }\n\n    // **************\n    // Requirers\n    // **************\n\n    function _requireCorrectAllocationHash(bytes32 channelId, bytes memory allocationBytes)\n        internal\n        view\n    {\n        require(\n            assetOutcomeHashes[channelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Allocation),\n                            allocationBytes\n                        )\n                    )\n                ),\n            'AssetHolder | submitted allocationBytes data does not match stored assetOutcomeHash'\n        );\n    }\n\n    function _requireCorrectGuaranteeHash(bytes32 guarantorChannelId, bytes memory guaranteeBytes)\n        internal\n        view\n    {\n        require(\n            assetOutcomeHashes[guarantorChannelId] ==\n                keccak256(\n                    abi.encode(\n                        Outcome.AssetOutcome(\n                            uint8(Outcome.AssetOutcomeType.Guarantee),\n                            guaranteeBytes\n                        )\n                    )\n                ),\n            'AssetHolder | submitted guaranteeBytes data does not match stored assetOutcomeHash'\n        );\n    }\n\n    function _requireIncreasingIndices(uint256[] memory indices) internal pure {\n        for (uint256 i = 0; i < indices.length - 1; i++) {\n            require(indices[i] < indices[i + 1], 'Indices must be sorted');\n        }\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n}\n"
    },
    "contracts/ForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/IForceMove.sol';\nimport './interfaces/IForceMoveApp.sol';\n\n/**\n * @dev An implementation of ForceMove protocol, which allows state channels to be adjudicated and finalized.\n */\ncontract ForceMove is IForceMove {\n    mapping(bytes32 => bytes32) public channelStorageHashes;\n\n    // Public methods:\n\n    /**\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @param channelId Unique identifier for a state channel.\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\n     * @return fingerprint Unique identifier for the channel's current state, up to hash collisions.\n     */\n    function getChannelStorage(bytes32 channelId)\n        external\n        view\n        returns (\n            uint48 turnNumRecord,\n            uint48 finalizesAt,\n            uint160 fingerprint\n        )\n    {\n        (turnNumRecord, finalizesAt, fingerprint) = _getChannelStorage(channelId);\n    }\n\n    /**\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update. Length is from 1 to the number of participants (inclusive).\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`. There must be one for each participant, e.g.: [sig-from-p0, sig-from-p1, ...]\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function challenge(\n        FixedPart memory fixedPart,\n        uint48 largestTurnNum,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat,\n        Signature memory challengerSig\n    ) external override {\n        // input type validation\n        requireValidInput(\n            fixedPart.participants.length,\n            variableParts.length,\n            sigs.length,\n            whoSignedWhat.length\n        );\n\n        bytes32 channelId = _getChannelId(fixedPart);\n\n        if (_mode(channelId) == ChannelMode.Open) {\n            _requireNonDecreasedTurnNumber(channelId, largestTurnNum);\n        } else if (_mode(channelId) == ChannelMode.Challenge) {\n            _requireIncreasedTurnNumber(channelId, largestTurnNum);\n        } else {\n            // This should revert.\n            _requireChannelNotFinalized(channelId);\n        }\n        bytes32 supportedStateHash = _requireStateSupportedBy(\n            largestTurnNum,\n            variableParts,\n            isFinalCount,\n            channelId,\n            fixedPart,\n            sigs,\n            whoSignedWhat\n        );\n\n        address challenger = _requireChallengerIsParticipant(\n            supportedStateHash,\n            fixedPart.participants,\n            challengerSig\n        );\n\n        // effects\n\n        emit ChallengeRegistered(\n            channelId,\n            largestTurnNum,\n            uint48(block.timestamp) + fixedPart.challengeDuration, //solhint-disable-line not-rely-on-time\n            // This could overflow, so don't join a channel with a huge challengeDuration\n            challenger,\n            isFinalCount > 0,\n            fixedPart,\n            variableParts,\n            sigs,\n            whoSignedWhat\n        );\n\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(\n                largestTurnNum,\n                uint48(block.timestamp) + fixedPart.challengeDuration, //solhint-disable-line not-rely-on-time\n                supportedStateHash,\n                challenger,\n                keccak256(variableParts[variableParts.length - 1].outcome)\n            )\n        );\n    }\n\n    /**\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\n     * @param challenger The address of the participant whom registered the challenge.\n     * @param isFinalAB An pair of booleans describing if the challenge state and/or the response state have the `isFinal` property set to `true`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\n     * @param sig The responder's signature on the `responseStateHash`.\n     */\n    function respond(\n        address challenger,\n        bool[2] memory isFinalAB,\n        FixedPart memory fixedPart,\n        IForceMoveApp.VariablePart[2] memory variablePartAB,\n        // variablePartAB[0] = challengeVariablePart\n        // variablePartAB[1] = responseVariablePart\n        Signature memory sig\n    ) external override {\n        // No need to validate fixedPart.participants.length here, as that validation would have happened during challenge\n\n        bytes32 channelId = _getChannelId(fixedPart);\n        (uint48 turnNumRecord, uint48 finalizesAt, ) = _getChannelStorage(channelId);\n\n        bytes32 challengeOutcomeHash = keccak256(variablePartAB[0].outcome);\n        bytes32 responseOutcomeHash = keccak256(variablePartAB[1].outcome);\n        bytes32 challengeStateHash = _hashState(\n            turnNumRecord,\n            isFinalAB[0],\n            channelId,\n            fixedPart,\n            variablePartAB[0].appData,\n            challengeOutcomeHash\n        );\n\n        bytes32 responseStateHash = _hashState(\n            turnNumRecord + 1,\n            isFinalAB[1],\n            channelId,\n            fixedPart,\n            variablePartAB[1].appData,\n            responseOutcomeHash\n        );\n\n        // checks\n\n        _requireSpecificChallenge(\n            ChannelData(\n                turnNumRecord,\n                finalizesAt,\n                challengeStateHash,\n                challenger,\n                challengeOutcomeHash\n            ),\n            channelId\n        );\n\n        require(\n            _recoverSigner(responseStateHash, sig) ==\n                fixedPart.participants[(turnNumRecord + 1) % fixedPart.participants.length],\n            'Response not signed by authorized mover'\n        );\n\n        _requireValidTransition(\n            fixedPart.participants.length,\n            isFinalAB,\n            variablePartAB,\n            turnNumRecord + 1,\n            fixedPart.appDefinition\n        );\n\n        // effects\n        _clearChallenge(channelId, turnNumRecord + 1);\n    }\n\n    /**\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     */\n    function checkpoint(\n        FixedPart memory fixedPart,\n        uint48 largestTurnNum,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) external override {\n        // input type validation\n        requireValidInput(\n            fixedPart.participants.length,\n            variableParts.length,\n            sigs.length,\n            whoSignedWhat.length\n        );\n\n        bytes32 channelId = _getChannelId(fixedPart);\n\n        // checks\n        _requireChannelNotFinalized(channelId);\n        _requireIncreasedTurnNumber(channelId, largestTurnNum);\n        _requireStateSupportedBy(\n            largestTurnNum,\n            variableParts,\n            isFinalCount,\n            channelId,\n            fixedPart,\n            sigs,\n            whoSignedWhat\n        );\n\n        // effects\n        _clearChallenge(channelId, largestTurnNum);\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\n     * @dev Finalizes a channel by providing a finalization proof. External wrapper for _conclude.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeHash The keccak256 of the abi.encode of the `outcome`. Applies to all states in the finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function conclude(\n        uint48 largestTurnNum,\n        FixedPart memory fixedPart,\n        bytes32 appPartHash,\n        bytes32 outcomeHash,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) external override {\n        _conclude(\n            largestTurnNum,\n            fixedPart,\n            appPartHash,\n            outcomeHash,\n            numStates,\n            whoSignedWhat,\n            sigs\n        );\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof. Internal method.\n     * @dev Finalizes a channel by providing a finalization proof. Internal method.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeHash The keccak256 of the `outcome`. Applies to all stats in the finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function _conclude(\n        uint48 largestTurnNum,\n        FixedPart memory fixedPart,\n        bytes32 appPartHash,\n        bytes32 outcomeHash,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) internal returns (bytes32 channelId) {\n        channelId = _getChannelId(fixedPart);\n        _requireChannelNotFinalized(channelId);\n\n        // input type validation\n        requireValidInput(\n            fixedPart.participants.length,\n            numStates,\n            sigs.length,\n            whoSignedWhat.length\n        );\n\n        require(\n            largestTurnNum + 1 >= numStates,\n            'largestTurnNum + 1 must be greater than or equal to numStates'\n        );\n        // ^^ SW-C101: prevent underflow\n\n        channelId = _getChannelId(fixedPart);\n        _requireChannelNotFinalized(channelId);\n\n        // By construction, the following states form a valid transition\n        bytes32[] memory stateHashes = new bytes32[](numStates);\n        for (uint48 i = 0; i < numStates; i++) {\n            stateHashes[i] = keccak256(\n                abi.encode(\n                    State(\n                        largestTurnNum + (i + 1) - numStates, // turnNum\n                        // ^^ SW-C101: It is not easy to use SafeMath here, since we are not using uint256s\n                        // Instead, we are protected by the require statement above\n                        true, // isFinal\n                        channelId,\n                        appPartHash,\n                        outcomeHash\n                    )\n                )\n            );\n        }\n\n        // checks\n        require(\n            _validSignatures(\n                largestTurnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures OR isFinal=true expected'\n        );\n\n        // effects\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(0, uint48(block.timestamp), bytes32(0), address(0), outcomeHash) //solhint-disable-line not-rely-on-time\n        );\n        emit Concluded(channelId, uint48(block.timestamp)); //solhint-disable-line not-rely-on-time\n    }\n\n    // Internal methods:\n\n    /**\n     * @notice Checks that the challengerSignature was created by one of the supplied participants.\n     * @dev Checks that the challengerSignature was created by one of the supplied participants.\n     * @param supportedStateHash Forms part of the digest to be signed, along with the string 'forceMove'.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param challengerSignature The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function _requireChallengerIsParticipant(\n        bytes32 supportedStateHash,\n        address[] memory participants,\n        Signature memory challengerSignature\n    ) internal pure returns (address challenger) {\n        challenger = _recoverSigner(\n            keccak256(abi.encode(supportedStateHash, 'forceMove')),\n            challengerSignature\n        );\n        require(_isAddressInArray(challenger, participants), 'Challenger is not a participant');\n    }\n\n    /**\n     * @notice Tests whether a given address is in a given array of addresses.\n     * @dev Tests whether a given address is in a given array of addresses.\n     * @param suspect A single address of interest.\n     * @param addresses A line-up of possible perpetrators.\n     * @return true if the address is in the array, false otherwise\n     */\n    function _isAddressInArray(address suspect, address[] memory addresses)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (suspect == addresses[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @dev Given an array of state hashes, checks the validity of the supplied signatures. Valid means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param participants A list of addresses representing the participants of a channel.\n     * @param stateHashes Array of keccak256(State) submitted in support of a state,\n     * @param sigs Array of Signatures, one for each participant\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return true if the signatures are valid, false otherwise\n     */\n    function _validSignatures(\n        uint48 largestTurnNum,\n        address[] memory participants,\n        bytes32[] memory stateHashes,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat // whoSignedWhat[i] is the index of the state in stateHashes that was signed by participants[i]\n    ) internal pure returns (bool) {\n        uint256 nParticipants = participants.length;\n        uint256 nStates = stateHashes.length;\n\n        require(\n            _acceptableWhoSignedWhat(whoSignedWhat, largestTurnNum, nParticipants, nStates),\n            'Unacceptable whoSignedWhat array'\n        );\n        for (uint256 i = 0; i < nParticipants; i++) {\n            address signer = _recoverSigner(stateHashes[whoSignedWhat[i]], sigs[i]);\n            if (signer != participants[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @dev Given a declaration of which state in the support proof was signed by which participant, check if this declaration is acceptable. Acceptable means there is a signature for each participant, either on the hash of the state for which they are a mover, or on the hash of a state that appears after that state in the array.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param nParticipants Number of participants in the channel\n     * @param nStates Number of states in the support proof\n     * @return true if whoSignedWhat is acceptable, false otherwise\n     */\n    function _acceptableWhoSignedWhat(\n        uint8[] memory whoSignedWhat,\n        uint48 largestTurnNum,\n        uint256 nParticipants,\n        uint256 nStates\n    ) internal pure returns (bool) {\n        require(\n            whoSignedWhat.length == nParticipants,\n            '_validSignatures: whoSignedWhat must be the same length as participants'\n        );\n        for (uint256 i = 0; i < nParticipants; i++) {\n            uint256 offset = (nParticipants + largestTurnNum - i) % nParticipants;\n            // offset is the difference between the index of participant[i] and the index of the participant who owns the largesTurnNum state\n            // the additional nParticipants in the dividend ensures offset always positive\n            if (whoSignedWhat[i] + offset + 1 < nStates) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Given a digest and ethereum digital signature, recover the signer\n     * @dev Given a digest and digital signature, recover the signer\n     * @param _d message digest\n     * @param sig ethereum digital signature\n     * @return signer\n     */\n    function _recoverSigner(bytes32 _d, Signature memory sig) internal pure returns (address) {\n        bytes32 prefixedHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', _d));\n        address a = ecrecover(prefixedHash, sig.v, sig.r, sig.s);\n        require(a != address(0), 'Invalid signature');\n        return (a);\n    }\n\n    /**\n     * @notice Check that the submitted data constitute a support proof.\n     * @dev Check that the submitted data constitute a support proof.\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param variableParts Variable parts of the states in the support proof\n     * @param isFinalCount How many of the states are final? The final isFinalCount states are implied final, the remainder are implied not final.\n     * @param channelId Unique identifier for a channel.\n     * @param fixedPart Fixed Part of the states in the support proof\n     * @param sigs A signature from each participant.\n     * @param whoSignedWhat participant[i] signed stateHashes[whoSignedWhat[i]]\n     * @return The hash of the latest state in the proof, if supported, else reverts.\n     */\n    function _requireStateSupportedBy(\n        uint48 largestTurnNum,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount,\n        bytes32 channelId,\n        FixedPart memory fixedPart,\n        Signature[] memory sigs,\n        uint8[] memory whoSignedWhat\n    ) internal pure returns (bytes32) {\n        bytes32[] memory stateHashes = _requireValidTransitionChain(\n            largestTurnNum,\n            variableParts,\n            isFinalCount,\n            channelId,\n            fixedPart\n        );\n\n        require(\n            _validSignatures(\n                largestTurnNum,\n                fixedPart.participants,\n                stateHashes,\n                sigs,\n                whoSignedWhat\n            ),\n            'Invalid signatures'\n        );\n\n        return stateHashes[stateHashes.length - 1];\n    }\n\n    /**\n     * @notice Check that the submitted states form a chain of valid transitions\n     * @dev Check that the submitted states form a chain of valid transitions\n     * @param largestTurnNum Largest turnNum of the support proof\n     * @param variableParts Variable parts of the states in the support proof\n     * @param isFinalCount How many of the states are final? The final isFinalCount states are implied final, the remainder are implied not final.\n     * @param channelId Unique identifier for a channel.\n     * @param fixedPart Fixed Part of the states in the support proof\n     * @return true if every state is a validTransition from its predecessor, false otherwise.\n     */\n    function _requireValidTransitionChain(\n        // returns stateHashes array if valid\n        // else, reverts\n        uint48 largestTurnNum,\n        IForceMoveApp.VariablePart[] memory variableParts,\n        uint8 isFinalCount,\n        bytes32 channelId,\n        FixedPart memory fixedPart\n    ) internal pure returns (bytes32[] memory) {\n        bytes32[] memory stateHashes = new bytes32[](variableParts.length);\n        uint48 firstFinalTurnNum = largestTurnNum - isFinalCount + 1;\n        uint48 turnNum;\n\n        for (uint48 i = 0; i < variableParts.length; i++) {\n            turnNum = largestTurnNum - uint48(variableParts.length) + 1 + i;\n            stateHashes[i] = _hashState(\n                turnNum,\n                turnNum >= firstFinalTurnNum,\n                channelId,\n                fixedPart,\n                variableParts[i].appData,\n                keccak256(variableParts[i].outcome)\n            );\n            if (turnNum < largestTurnNum) {\n                _requireValidTransition(\n                    fixedPart.participants.length,\n                    [turnNum >= firstFinalTurnNum, turnNum + 1 >= firstFinalTurnNum],\n                    [variableParts[i], variableParts[i + 1]],\n                    turnNum + 1,\n                    fixedPart.appDefinition\n                );\n            }\n        }\n        return stateHashes;\n    }\n\n    enum IsValidTransition {True, NeedToCheckApp}\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition\n    * @dev Check that the submitted pair of states form a valid transition\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param isFinalAB Pair of booleans denoting whether the first and second state (resp.) are final.\n    * @param ab Variable parts of each of the pair of states\n    * @param turnNumB turnNum of the later state of the pair\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\n    */\n    function _requireValidProtocolTransition(\n        uint256 nParticipants,\n        bool[2] memory isFinalAB, // [a.isFinal, b.isFinal]\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        uint48 turnNumB\n    ) internal pure returns (IsValidTransition) {\n        // a separate check on the signatures for the submitted states implies that the following fields are equal for a and b:\n        // chainId, participants, channelNonce, appDefinition, challengeDuration\n        // and that the b.turnNum = a.turnNum + 1\n        if (isFinalAB[1]) {\n            require(\n                _bytesEqual(ab[1].outcome, ab[0].outcome),\n                'InvalidTransitionError: Cannot move to a final state with a different default outcome'\n            );\n        } else {\n            require(\n                !isFinalAB[0],\n                'InvalidTransitionError: Cannot move from a final state to a non final state'\n            );\n            if (turnNumB < 2 * nParticipants) {\n                require(\n                    _bytesEqual(ab[1].outcome, ab[0].outcome),\n                    'InvalidTransitionError: Cannot change the default outcome during setup phase'\n                );\n                require(\n                    _bytesEqual(ab[1].appData, ab[0].appData),\n                    'InvalidTransitionError: Cannot change the appData during setup phase'\n                );\n            } else {\n                return IsValidTransition.NeedToCheckApp;\n            }\n        }\n        return IsValidTransition.True;\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition\n    * @dev Check that the submitted pair of states form a valid transition\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param isFinalAB Pair of booleans denoting whether the first and second state (resp.) are final.\n    * @param ab Variable parts of each of the pair of states\n    * @param turnNumB turnNum of the later state of the pair.\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\n    * @return true if the later state is a validTransition from its predecessor, false otherwise.\n    */\n    function _requireValidTransition(\n        uint256 nParticipants,\n        bool[2] memory isFinalAB, // [a.isFinal, b.isFinal]\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        uint48 turnNumB,\n        address appDefinition\n    ) internal pure returns (bool) {\n        IsValidTransition isValidProtocolTransition = _requireValidProtocolTransition(\n            nParticipants,\n            isFinalAB, // [a.isFinal, b.isFinal]\n            ab, // [a,b]\n            turnNumB\n        );\n\n        if (isValidProtocolTransition == IsValidTransition.NeedToCheckApp) {\n            require(\n                IForceMoveApp(appDefinition).validTransition(ab[0], ab[1], turnNumB, nParticipants),\n                'Invalid ForceMoveApp Transition'\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Check for equality of two byte strings\n     * @dev Check for equality of two byte strings\n     * @param _preBytes One bytes string\n     * @param _postBytes The other bytes string\n     * @return true if the bytes are identical, false otherwise.\n     */\n    function _bytesEqual(bytes memory _preBytes, bytes memory _postBytes)\n        internal\n        pure\n        returns (bool)\n    {\n        // copied from https://www.npmjs.com/package/solidity-bytes-utils/v/0.1.1\n        bool success = true;\n\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n                case 1 {\n                    // cb is a circuit breaker in the for loop since there's\n                    //  no said feature for inline assembly loops\n                    // cb = 1 - don't breaker\n                    // cb = 0 - break\n                    let cb := 1\n\n                    let mc := add(_preBytes, 0x20)\n                    let end := add(mc, length)\n\n                    for {\n                        let cc := add(_postBytes, 0x20)\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                    } eq(add(lt(mc, end), cb), 2) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        // if any of these checks fails then arrays are not equal\n                        if iszero(eq(mload(mc), mload(cc))) {\n                            // unsuccess:\n                            success := 0\n                            cb := 0\n                        }\n                    }\n                }\n                default {\n                    // unsuccess:\n                    success := 0\n                }\n        }\n        /* solhint-disable no-inline-assembly */\n\n        return success;\n    }\n\n    /**\n     * @notice Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\n     * @dev Clears a challenge by updating the turnNumRecord and resetting the remaining channel storage fields, and emits a ChallengeCleared event.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord to overwrite existing value\n     */\n    function _clearChallenge(bytes32 channelId, uint48 newTurnNumRecord) internal {\n        channelStorageHashes[channelId] = _hashChannelData(\n            ChannelData(newTurnNumRecord, 0, bytes32(0), address(0), bytes32(0))\n        );\n        emit ChallengeCleared(channelId, newTurnNumRecord);\n    }\n\n    /**\n     * @notice Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\n     * @dev Checks that the submitted turnNumRecord is strictly greater than the turnNumRecord stored on chain.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\n     */\n    function _requireIncreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord) internal view {\n        (uint48 turnNumRecord, , ) = _getChannelStorage(channelId);\n        require(newTurnNumRecord > turnNumRecord, 'turnNumRecord not increased.');\n    }\n\n    /**\n     * @notice Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\n     * @dev Checks that the submitted turnNumRecord is greater than or equal to the turnNumRecord stored on chain.\n     * @param channelId Unique identifier for a channel.\n     * @param newTurnNumRecord New turnNumRecord intended to overwrite existing value\n     */\n    function _requireNonDecreasedTurnNumber(bytes32 channelId, uint48 newTurnNumRecord)\n        internal\n        view\n    {\n        (uint48 turnNumRecord, , ) = _getChannelStorage(channelId);\n        require(newTurnNumRecord >= turnNumRecord, 'turnNumRecord decreased.');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain, and that the channel is in Challenge mode.\n     * @param data A given ChannelData data structure.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireSpecificChallenge(ChannelData memory data, bytes32 channelId) internal view {\n        _requireMatchingStorage(data, channelId);\n        _requireOngoingChallenge(channelId);\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Challenge mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireOngoingChallenge(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Challenge, 'No ongoing challenge.');\n    }\n\n    /**\n     * @notice Checks that a given channel is NOT in the Finalized mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelNotFinalized(bytes32 channelId) internal view {\n        require(_mode(channelId) != ChannelMode.Finalized, 'Channel finalized.');\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Finalized mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelFinalized(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Finalized, 'Channel not finalized.');\n    }\n\n    /**\n     * @notice Checks that a given channel is in the Open mode.\n     * @dev Checks that a given channel is in the Challenge mode.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireChannelOpen(bytes32 channelId) internal view {\n        require(_mode(channelId) == ChannelMode.Open, 'Channel not open.');\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches the challenge stored on chain.\n     * @dev Checks that a given ChannelData struct matches the challenge stored on chain.\n     * @param data A given ChannelData data structure.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _requireMatchingStorage(ChannelData memory data, bytes32 channelId) internal view {\n        require(\n            _matchesHash(data, channelStorageHashes[channelId]),\n            'Channel storage does not match stored version.'\n        );\n    }\n\n    /**\n     * @notice Computes the ChannelMode for a given channelId.\n     * @dev Computes the ChannelMode for a given channelId.\n     * @param channelId Unique identifier for a channel.\n     */\n    function _mode(bytes32 channelId) internal view returns (ChannelMode) {\n        // Note that _getChannelStorage(someRandomChannelId) returns (0,0,0), which is\n        // correct when nobody has written to storage yet.\n\n        (, uint48 finalizesAt, ) = _getChannelStorage(channelId);\n        if (finalizesAt == 0) {\n            return ChannelMode.Open;\n            // solhint-disable-next-line not-rely-on-time\n        } else if (finalizesAt <= block.timestamp) {\n            return ChannelMode.Finalized;\n        } else {\n            return ChannelMode.Challenge;\n        }\n    }\n\n    /**\n     * @notice Hashes the input data and formats it for on chain storage.\n     * @dev Hashes the input data and formats it for on chain storage.\n     * @param channelData ChannelData data.\n     */\n    function _hashChannelData(ChannelData memory channelData)\n        internal\n        pure\n        returns (bytes32 newHash)\n    {\n        // The hash is constructed from left to right.\n        uint256 result;\n        uint16 cursor = 256;\n\n        // Shift turnNumRecord 208 bits left to fill the first 48 bits\n        result = uint256(channelData.turnNumRecord) << (cursor -= 48);\n\n        // logical or with finalizesAt padded with 160 zeros to get the next 48 bits\n        result |= (uint256(channelData.finalizesAt) << (cursor -= 48));\n\n        // logical or with the last 160 bits of the hash of the encoded storage\n        result |= uint256(uint160(uint256(keccak256(abi.encode(channelData)))));\n\n        newHash = bytes32(result);\n    }\n\n    /**\n     * @notice Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @dev Unpacks turnNumRecord, finalizesAt and fingerprint from the channelStorageHash of a particular channel.\n     * @param channelId Unique identifier for a state channel.\n     * @return turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @return finalizesAt The unix timestamp when `channelId` will finalize.\n     * @return fingerprint Unique identifier for the channel's current state, up to hash collisions.\n     */\n    function _getChannelStorage(bytes32 channelId)\n        internal\n        view\n        returns (\n            uint48 turnNumRecord,\n            uint48 finalizesAt,\n            uint160 fingerprint\n        )\n    {\n        bytes32 storageHash = channelStorageHashes[channelId];\n        uint16 cursor = 256;\n        turnNumRecord = uint48(uint256(storageHash) >> (cursor -= 48));\n        finalizesAt = uint48(uint256(storageHash) >> (cursor -= 48));\n        fingerprint = uint160(uint256(storageHash));\n    }\n\n    /**\n     * @notice Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @dev Checks that a given ChannelData struct matches a supplied bytes32 when formatted for storage.\n     * @param data A given ChannelData data structure.\n     * @param h Some data in on-chain storage format.\n     */\n    function _matchesHash(ChannelData memory data, bytes32 h) internal pure returns (bool) {\n        return _hashChannelData(data) == h;\n    }\n\n    /**\n     * @notice Computes the hash of the state corresponding to the input data.\n     * @dev Computes the hash of the state corresponding to the input data.\n     * @param turnNum Turn number\n     * @param isFinal Is the state final?\n     * @param channelId Unique identifier for the channel\n     * @param fixedPart Part of the state that does not change\n     * @param appData Application specific date\n     * @param outcomeHash Hash of the outcome.\n     * @return The stateHash\n     */\n    function _hashState(\n        uint48 turnNum,\n        bool isFinal,\n        bytes32 channelId,\n        FixedPart memory fixedPart,\n        bytes memory appData,\n        bytes32 outcomeHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    State(\n                        turnNum,\n                        isFinal,\n                        channelId,\n                        keccak256(\n                            abi.encode(\n                                fixedPart.challengeDuration,\n                                fixedPart.appDefinition,\n                                appData\n                            )\n                        ),\n                        outcomeHash\n                    )\n                )\n            );\n    }\n\n    function getChainID() public pure returns (uint256) {\n        uint256 id;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            id := chainid()\n        }\n        /* solhint-disable no-inline-assembly */\n        return id;\n    }\n\n    /**\n     * @notice Computes the unique id of a channel.\n     * @dev Computes the unique id of a channel.\n     * @param fixedPart Part of the state that does not change\n     * @return channelId\n     */\n    function _getChannelId(FixedPart memory fixedPart) internal pure returns (bytes32 channelId) {\n        require(fixedPart.chainId == getChainID(), 'Incorrect chainId');\n        channelId = keccak256(\n            abi.encode(getChainID(), fixedPart.participants, fixedPart.channelNonce)\n        );\n    }\n\n    /**\n     * @notice Validates input for several external methods.\n     * @dev Validates input for several external methods.\n     * @param numParticipants Length of the participants array\n     * @param numStates Number of states submitted\n     * @param numSigs Number of signatures submitted\n     * @param numWhoSignedWhats whoSignedWhat.length\n     */\n    function requireValidInput(\n        uint256 numParticipants,\n        uint256 numStates,\n        uint256 numSigs,\n        uint256 numWhoSignedWhats\n    ) public pure returns (bool) {\n        require(\n            (numParticipants >= numStates) && (numStates > 0),\n            'ForceMove | You must submit at least one but no more than numParticipants states'\n        );\n        require(\n            (numSigs == numParticipants) && (numWhoSignedWhats == numParticipants),\n            'ForceMove | Require exactly 1 signature per participant & who signed what for all participants'\n        );\n        require(numParticipants < type(uint8).max, 'ForceMove | Too many participants!');\n        return true;\n    }\n}\n"
    },
    "contracts/NitroAdjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/IAdjudicator.sol';\nimport './ForceMove.sol';\nimport './Outcome.sol';\nimport './AssetHolder.sol';\n\n/**\n * @dev The NitroAdjudicator contract extends ForceMove and hence inherits all ForceMove methods, and also extends and implements the Adjudicator interface, allowing for a finalized outcome to be pushed to an asset holder.\n */\ncontract NitroAdjudicator is IAdjudicator, ForceMove {\n    /**\n     * @notice Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @dev Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @param channelId Unique identifier for a state channel\n     * @param turnNumRecord A turnNum that (the adjudicator knows and stores) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when this channel will finalize\n     * @param stateHash The keccak256 of the abi.encode of the State (struct) stored by the adjudicator\n     * @param challengerAddress The address of the participant whom registered the challenge, if any.\n     * @param outcomeBytes The encoded Outcome of this state channel.\n     */\n    function pushOutcome(\n        bytes32 channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bytes32 stateHash,\n        address challengerAddress,\n        bytes memory outcomeBytes\n    ) public override {\n        // requirements\n        _requireChannelFinalized(channelId);\n\n        bytes32 outcomeHash = keccak256(outcomeBytes);\n\n        _requireMatchingStorage(\n            ChannelData(turnNumRecord, finalizesAt, stateHash, challengerAddress, outcomeHash),\n            channelId\n        );\n\n        Outcome.OutcomeItem[] memory outcome = abi.decode(outcomeBytes, (Outcome.OutcomeItem[]));\n\n        for (uint256 i = 0; i < outcome.length; i++) {\n            AssetHolder(outcome[i].assetHolderAddress).setAssetOutcomeHash(\n                channelId,\n                keccak256(outcome[i].assetOutcomeBytes)\n            );\n        }\n    }\n\n    /**\n     * @notice Allows a finalized channel's outcome to be decoded and transferAll to be triggered in external Asset Holder contracts.\n     * @dev Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @param channelId Unique identifier for a state channel\n     * @param turnNumRecord A turnNum that (the adjudicator knows and stores) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when this channel will finalize\n     * @param stateHash The keccak256 of the abi.encode of the State (struct) stored by the adjudicator\n     * @param challengerAddress The address of the participant whom registered the challenge, if any.\n     * @param outcomeBytes The encoded Outcome of this state channel.\n     */\n    function pushOutcomeAndTransferAll(\n        bytes32 channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bytes32 stateHash,\n        address challengerAddress,\n        bytes memory outcomeBytes\n    ) public {\n        // requirements\n        _requireChannelFinalized(channelId);\n\n        bytes32 outcomeHash = keccak256(outcomeBytes);\n\n        _requireMatchingStorage(\n            ChannelData(turnNumRecord, finalizesAt, stateHash, challengerAddress, outcomeHash),\n            channelId\n        );\n\n        _transferAllFromAllAssetHolders(channelId, outcomeBytes);\n    }\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof, allows a finalized channel's outcome to be decoded and transferAll to be triggered in external Asset Holder contracts.\n     * @dev Finalizes a channel by providing a finalization proof, allows a finalized channel's outcome to be decoded and transferAll to be triggered in external Asset Holder contracts.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeBytes abi.encode of an array of Outcome.OutcomeItem structs.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function concludePushOutcomeAndTransferAll(\n        uint48 largestTurnNum,\n        FixedPart memory fixedPart,\n        bytes32 appPartHash,\n        bytes memory outcomeBytes,\n        uint8 numStates,\n        uint8[] memory whoSignedWhat,\n        Signature[] memory sigs\n    ) public {\n        bytes32 outcomeHash = keccak256(outcomeBytes);\n        bytes32 channelId = _conclude(\n            largestTurnNum,\n            fixedPart,\n            appPartHash,\n            outcomeHash,\n            numStates,\n            whoSignedWhat,\n            sigs\n        );\n        _transferAllFromAllAssetHolders(channelId, outcomeBytes);\n    }\n\n    /**\n     * @notice Triggers transferAll in all external Asset Holder contracts specified in a given outcome for a given channelId.\n     * @dev Triggers transferAll in  all external Asset Holder contracts specified in a given outcome for a given channelId.\n     * @param channelId Unique identifier for a state channel\n     * @param outcomeBytes abi.encode of an array of Outcome.OutcomeItem structs.\n     */\n    function _transferAllFromAllAssetHolders(bytes32 channelId, bytes memory outcomeBytes)\n        internal\n    {\n        Outcome.OutcomeItem[] memory outcome = abi.decode(outcomeBytes, (Outcome.OutcomeItem[]));\n\n        for (uint256 i = 0; i < outcome.length; i++) {\n            Outcome.AssetOutcome memory assetOutcome = abi.decode(\n                outcome[i].assetOutcomeBytes,\n                (Outcome.AssetOutcome)\n            );\n            if (assetOutcome.assetOutcomeType == uint8(Outcome.AssetOutcomeType.Allocation)) {\n                AssetHolder(outcome[i].assetHolderAddress).transferAllAdjudicatorOnly(\n                    channelId,\n                    assetOutcome.allocationOrGuaranteeBytes\n                );\n            } else {\n                revert('_transferAllFromAllAssetHolders: AssetOutcomeType is not an allocation');\n            }\n        }\n    }\n\n    /**\n    * @notice Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\n    * @dev Check that the submitted pair of states form a valid transition (public wrapper for internal function _requireValidTransition)\n    * @param nParticipants Number of participants in the channel.\n    transition\n    * @param isFinalAB Pair of booleans denoting whether the first and second state (resp.) are final.\n    * @param ab Variable parts of each of the pair of states\n    * @param turnNumB turnNum of the later state of the pair.\n    * @param appDefinition Address of deployed contract containing application-specific validTransition function.\n    * @return true if the later state is a validTransition from its predecessor, reverts otherwise.\n    */\n    function validTransition(\n        uint256 nParticipants,\n        bool[2] memory isFinalAB, // [a.isFinal, b.isFinal]\n        IForceMoveApp.VariablePart[2] memory ab, // [a,b]\n        uint48 turnNumB,\n        address appDefinition\n    ) public pure returns (bool) {\n        return _requireValidTransition(nParticipants, isFinalAB, ab, turnNumB, appDefinition);\n    }\n}\n"
    },
    "contracts/Outcome.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nlibrary Outcome {\n    //An outcome is an array of OutcomeItems\n    // Outcome = OutcomeItem[]\n    // OutcomeItem = (AssetHolderAddress, AssetOutcome)\n    // AssetOutcome = (AssetOutcomeType, Allocation | Guarantee)\n    // Allocation = AllocationItem[]\n    // AllocationItem = (Destination, Amount)\n    // Guarantee = (ChannelAddress, Destination[])\n    // Destination = ChannelAddress | ExternalDestination\n\n    struct OutcomeItem {\n        address assetHolderAddress;\n        bytes assetOutcomeBytes; // abi.encode(AssetOutcome)\n    }\n\n    enum AssetOutcomeType {Allocation, Guarantee}\n\n    struct AssetOutcome {\n        uint8 assetOutcomeType; // AssetOutcomeType.Allocation or AssetOutcomeType.Guarantee\n        bytes allocationOrGuaranteeBytes; // abi.encode(AllocationItem[]) or abi.encode(Guarantee), depending on OutcomeType\n    }\n\n    // reserve Allocation to refer to AllocationItem[]\n    struct AllocationItem {\n        bytes32 destination;\n        uint256 amount;\n    }\n\n    struct Guarantee {\n        bytes32 targetChannelId;\n        bytes32[] destinations;\n    }\n}\n"
    },
    "contracts/interfaces/IAdjudicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev The IAdjudicator Interface calls for a method that allows a finalized outcome to be pushed to an asset holder.\n */\ninterface IAdjudicator {\n    /**\n     * @notice Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @dev Allows a finalized channel's outcome to be decoded and one or more AssetOutcomes registered in external Asset Holder contracts.\n     * @param channelId Unique identifier for a state channel\n     * @param turnNumRecord A turnNum that (the adjudicator knows and stores) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when this channel will finalize\n     * @param stateHash The keccak256 of the abi.encode of the State (struct) stored by the adjudicator\n     * @param challengerAddress The address of the participant whom registered the challenge, if any.\n     * @param outcomeBytes The encoded Outcome of this state channel.\n     */\n    function pushOutcome(\n        bytes32 channelId,\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        bytes32 stateHash,\n        address challengerAddress,\n        bytes calldata outcomeBytes\n    ) external;\n}\n"
    },
    "contracts/interfaces/IAssetHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev The IAssetHolder interface calls for functions that allow assets to be transferred from one channel to other channel and/or external destinations, as well as for guarantees to be claimed.\n */\ninterface IAssetHolder {\n    /**\n     * @notice Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @dev Transfers as many funds escrowed against `channelId` as can be afforded for a specific destination. Assumes no repeated entries.\n     * @param fromChannelId Unique identifier for state channel to transfer funds *from*.\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation\n     * @param indices Array with each entry denoting the index of a destination to transfer funds to.\n     */\n    function transfer(\n        bytes32 fromChannelId,\n        bytes calldata allocationBytes,\n        uint256[] memory indices\n    ) external;\n\n    /**\n     * @notice Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @dev Transfers the funds escrowed against `guarantorChannelId` to the beneficiaries of the __target__ of that channel.\n     * @param guarantorChannelId Unique identifier for a guarantor state channel.\n     * @param guaranteeBytes The abi.encode of Outcome.Guarantee\n     * @param allocationBytes The abi.encode of AssetOutcome.Allocation for the __target__\n     */\n    function claimAll(\n        bytes32 guarantorChannelId,\n        bytes calldata guaranteeBytes,\n        bytes calldata allocationBytes\n    ) external;\n\n    /**\n     * @dev Indicates that `amountDeposited` has been deposited into `destination`.\n     * @param destination The channel being deposited into.\n     * @param amountDeposited The amount being deposited.\n     * @param destinationHoldings The new holdings for `destination`.\n     */\n    event Deposited(\n        bytes32 indexed destination,\n        uint256 amountDeposited,\n        uint256 destinationHoldings\n    );\n\n    /**\n     * @dev Indicates that `amount` assets have been transferred (internally or externally) to the destination denoted by `destination`.\n     * @param channelId The channelId of the funds being withdrawn.\n     * @param destination An internal destination (channelId) of external destination (padded ethereum address)\n     * @param amount Number of assets transferred (wei or tokens).\n     */\n    event AssetTransferred(bytes32 indexed channelId, bytes32 indexed destination, uint256 amount);\n}\n"
    },
    "contracts/interfaces/IForceMove.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport './IForceMoveApp.sol';\n\n/**\n * @dev The IForceMove interface defines the interface that an implementation of ForceMove should implement. ForceMove protocol allows state channels to be adjudicated and finalized.\n */\ninterface IForceMove {\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct FixedPart {\n        uint256 chainId;\n        address[] participants;\n        uint48 channelNonce;\n        address appDefinition;\n        uint48 challengeDuration;\n    }\n\n    struct State {\n        // participants sign the hash of this\n        uint48 turnNum;\n        bool isFinal;\n        bytes32 channelId; // keccack(chainId,participants,channelNonce)\n        bytes32 appPartHash;\n        //     keccak256(abi.encode(\n        //         fixedPart.challengeDuration,\n        //         fixedPart.appDefinition,\n        //         variablePart.appData\n        //     )\n        // )\n        bytes32 outcomeHash;\n    }\n\n    struct ChannelData {\n        uint48 turnNumRecord;\n        uint48 finalizesAt;\n        bytes32 stateHash; // keccak256(abi.encode(State))\n        address challengerAddress;\n        bytes32 outcomeHash;\n    }\n\n    enum ChannelMode {Open, Challenge, Finalized}\n\n    /**\n     * @notice Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @dev Registers a challenge against a state channel. A challenge will either prompt another participant into clearing the challenge (via one of the other methods), or cause the channel to finalize at a specific time.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param challengerSig The signature of a participant on the keccak256 of the abi.encode of (supportedStateHash, 'forceMove').\n     */\n    function challenge(\n        FixedPart calldata fixedPart,\n        uint48 largestTurnNum,\n        IForceMoveApp.VariablePart[] calldata variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] calldata sigs,\n        uint8[] calldata whoSignedWhat,\n        Signature calldata challengerSig\n    ) external;\n\n    /**\n     * @notice Repsonds to an ongoing challenge registered against a state channel.\n     * @dev Repsonds to an ongoing challenge registered against a state channel.\n     * @param challenger The address of the participant whom registered the challenge.\n     * @param isFinalAB An pair of booleans describing if the challenge state and/or the response state have the `isFinal` property set to `true`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variablePartAB An pair of structs, each decribing the properties of the state channel that may change with each state update (for the challenge state and for the response state).\n     * @param sig The responder's signature on the `responseStateHash`.\n     */\n    function respond(\n        address challenger,\n        bool[2] calldata isFinalAB,\n        FixedPart calldata fixedPart,\n        IForceMoveApp.VariablePart[2] calldata variablePartAB,\n        // variablePartAB[0] = challengeVariablePart\n        // variablePartAB[1] = responseVariablePart\n        Signature calldata sig\n    ) external;\n\n    /**\n     * @notice Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @dev Overwrites the `turnNumRecord` stored against a channel by providing a state with higher turn number, supported by a signature from each participant.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param isFinalCount Describes how many of the submitted states have the `isFinal` property set to `true`. It is implied that the rightmost `isFinalCount` states are final, and the rest are not final.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     */\n    function checkpoint(\n        FixedPart calldata fixedPart,\n        uint48 largestTurnNum,\n        IForceMoveApp.VariablePart[] calldata variableParts,\n        uint8 isFinalCount, // how many of the states are final\n        Signature[] calldata sigs,\n        uint8[] calldata whoSignedWhat\n    ) external;\n\n    /**\n     * @notice Finalizes a channel by providing a finalization proof.\n     * @dev Finalizes a channel by providing a finalization proof.\n     * @param largestTurnNum The largest turn number of the submitted states; will overwrite the stored value of `turnNumRecord`.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param appPartHash The keccak256 of the abi.encode of `(challengeDuration, appDefinition, appData)`. Applies to all states in the finalization proof.\n     * @param outcomeHash The keccak256 of the abi.encode of the `outcome`. Applies to all stats in the finalization proof.\n     * @param numStates The number of states in the finalization proof.\n     * @param whoSignedWhat An array denoting which participant has signed which state: `participant[i]` signed the state with index `whoSignedWhat[i]`.\n     * @param sigs An array of signatures that support the state with the `largestTurnNum`.\n     */\n    function conclude(\n        uint48 largestTurnNum,\n        FixedPart calldata fixedPart,\n        bytes32 appPartHash,\n        bytes32 outcomeHash,\n        uint8 numStates,\n        uint8[] calldata whoSignedWhat,\n        Signature[] calldata sigs\n    ) external;\n\n    // events\n\n    /**\n     * @dev Indicates that a challenge has been registered against `channelId`.\n     * @param channelId Unique identifier for a state channel.\n     * @param turnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     * @param finalizesAt The unix timestamp when `channelId` will finalize.\n     * @param challenger The address of the participant whom registered the challenge.\n     * @param isFinal Boolean denoting whether the challenge state is final.\n     * @param fixedPart Data describing properties of the state channel that do not change with state updates.\n     * @param variableParts An ordered array of structs, each decribing the properties of the state channel that may change with each state update.\n     * @param sigs A list of Signatures that supported the challenge\n     * @param whoSignedWhat Indexing information to identify which signature was by which participant\n     */\n    event ChallengeRegistered(\n        bytes32 indexed channelId,\n        // everything needed to respond or checkpoint\n        uint48 turnNumRecord,\n        uint48 finalizesAt,\n        address challenger,\n        bool isFinal,\n        FixedPart fixedPart,\n        IForceMoveApp.VariablePart[] variableParts,\n        Signature[] sigs,\n        uint8[] whoSignedWhat\n    );\n\n    /**\n     * @dev Indicates that a challenge, previously registered against `channelId`, has been cleared.\n     * @param channelId Unique identifier for a state channel.\n     * @param newTurnNumRecord A turnNum that (the adjudicator knows) is supported by a signature from each participant.\n     */\n    event ChallengeCleared(bytes32 indexed channelId, uint48 newTurnNumRecord);\n\n    /**\n     * @dev Indicates that a challenge has been registered against `channelId`.\n     * @param channelId Unique identifier for a state channel.\n     * @param finalizesAt The unix timestamp when `channelId` finalized.\n     */\n    event Concluded(bytes32 indexed channelId, uint48 finalizesAt);\n}\n"
    },
    "contracts/interfaces/IForceMoveApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev The IForceMoveApp interface calls for its children to implement an application-specific validTransition function, defining the state machine of a ForceMove state channel DApp.\n */\ninterface IForceMoveApp {\n    struct VariablePart {\n        bytes outcome;\n        bytes appData;\n    }\n\n    /**\n     * @notice Encodes application-specific rules for a particular ForceMove-compliant state channel.\n     * @dev Encodes application-specific rules for a particular ForceMove-compliant state channel.\n     * @param a State being transitioned from.\n     * @param b State being transitioned to.\n     * @param turnNumB Turn number being transitioned to.\n     * @param nParticipants Number of participants in this state channel.\n     * @return true if the transition conforms to this application's rules, false otherwise\n     */\n    function validTransition(\n        VariablePart calldata a,\n        VariablePart calldata b,\n        uint48 turnNumB,\n        uint256 nParticipants\n    ) external pure returns (bool);\n}\n"
    }
  }
}