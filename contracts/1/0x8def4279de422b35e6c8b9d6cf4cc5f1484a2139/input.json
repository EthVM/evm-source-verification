{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ERC1155Base.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title IERC20\r\n */\r\ninterface IERC20 {\r\n  /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n  function balanceOf(address account) external view returns (uint256);  \r\n\r\n  /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n  function transferFrom(\r\n      address sender,\r\n      address recipient,\r\n      uint256 amount\r\n  ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface IERC165 {\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 {\r\n  /****************************************|\r\n  |                 Events                 |\r\n  |_______________________________________*/\r\n\r\n  /**\r\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\r\n   *   Operator MUST be msg.sender\r\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\r\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\r\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\r\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\r\n   */\r\n  event TransferSingle(\r\n    address indexed _operator,\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _id,\r\n    uint256 _amount\r\n  );\r\n\r\n  /**\r\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\r\n   *   Operator MUST be msg.sender\r\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\r\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\r\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\r\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\r\n   */\r\n  event TransferBatch(\r\n    address indexed _operator,\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256[] _ids,\r\n    uint256[] _amounts\r\n  );\r\n\r\n  /**\r\n   * @dev MUST emit when an approval is updated\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /****************************************|\r\n  |                Functions               |\r\n  |_______________________________________*/\r\n\r\n  /**\r\n   * @notice Transfers amount of an _id from the _from address to the _to address specified\r\n   * @dev MUST emit TransferSingle event on success\r\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\r\n   * MUST throw if `_to` is the zero address\r\n   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\r\n   * MUST throw on any other error\r\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n   * @param _from    Source address\r\n   * @param _to      Target address\r\n   * @param _id      ID of the token type\r\n   * @param _amount  Transfered amount\r\n   * @param _data    Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _id,\r\n    uint256 _amount,\r\n    bytes calldata _data\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n   * @dev MUST emit TransferBatch event on success\r\n   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\r\n   * MUST throw if `_to` is the zero address\r\n   * MUST throw if length of `_ids` is not the same as length of `_amounts`\r\n   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\r\n   * MUST throw on any other error\r\n   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\r\n   * @param _from     Source addresses\r\n   * @param _to       Target addresses\r\n   * @param _ids      IDs of each token type\r\n   * @param _amounts  Transfer amounts per token type\r\n   * @param _data     Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeBatchTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256[] calldata _ids,\r\n    uint256[] calldata _amounts,\r\n    bytes calldata _data\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Get the balance of an account's Tokens\r\n   * @param _owner  The address of the token holder\r\n   * @param _id     ID of the Token\r\n   * @return        The _owner's balance of the Token type requested\r\n   */\r\n  function balanceOf(address _owner, uint256 _id)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the balance of multiple account/token pairs\r\n   * @param _owners The addresses of the token holders\r\n   * @param _ids    ID of the Tokens\r\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n   */\r\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\r\n    external\r\n    view\r\n    returns (uint256[] memory);\r\n\r\n  /**\r\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\r\n   * @dev MUST emit the ApprovalForAll event on success\r\n   * @param _operator  Address to add to the set of authorized operators\r\n   * @param _approved  True if the operator is approved, false to revoke approval\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n  /**\r\n   * @notice Queries the approval status of an operator for a given owner\r\n   * @param _owner     The owner of the Tokens\r\n   * @param _operator  Address of authorized operator\r\n   * @return isOperator True if the operator is approved, false if not\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    external\r\n    view\r\n    returns (bool isOperator);\r\n}\r\n\r\n/**\r\n * @dev ERC-1155 interface for accepting safe transfers.\r\n */\r\ninterface IERC1155TokenReceiver {\r\n  /**\r\n   * @notice Handle the receipt of a single ERC1155 token type\r\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\r\n   * This function MAY throw to revert and reject the transfer\r\n   * Return of other amount than the magic value MUST result in the transaction being reverted\r\n   * Note: The token contract address is always the message sender\r\n   * @param _operator  The address which called the `safeTransferFrom` function\r\n   * @param _from      The address which previously owned the token\r\n   * @param _id        The id of the token being transferred\r\n   * @param _amount    The amount of tokens being transferred\r\n   * @param _data      Additional data with no specified format\r\n   * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n   */\r\n  function onERC1155Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _id,\r\n    uint256 _amount,\r\n    bytes calldata _data\r\n  ) external returns (bytes4);\r\n\r\n  /**\r\n   * @notice Handle the receipt of multiple ERC1155 token types\r\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\r\n   * This function MAY throw to revert and reject the transfer\r\n   * Return of other amount than the magic value WILL result in the transaction being reverted\r\n   * Note: The token contract address is always the message sender\r\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\r\n   * @param _from      The address which previously owned the token\r\n   * @param _ids       An array containing ids of each token being transferred\r\n   * @param _amounts   An array containing amounts of each token being transferred\r\n   * @param _data      Additional data with no specified format\r\n   * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n   */\r\n  function onERC1155BatchReceived(\r\n    address _operator,\r\n    address _from,\r\n    uint256[] calldata _ids,\r\n    uint256[] calldata _amounts,\r\n    bytes calldata _data\r\n  ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n  address private _owner;\r\n\r\n  string private constant ERR = \"Ownable\";\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _transferOwnership(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner() == msg.sender, ERR);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), ERR);\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Internal function without access restriction.\r\n   */\r\n  function _transferOwnership(address newOwner) internal virtual {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n\r\n/**\r\n * @notice Contract that handles metadata related methods.\r\n * @dev Methods assume a deterministic generation of URI based on token IDs.\r\n *      Methods also assume that URI uses hex representation of token IDs.\r\n */\r\ncontract ERC1155Metadata {\r\n  // URI's default URI prefix\r\n  string private baseMetadataURI;\r\n\r\n  /***********************************|\r\n  |     Metadata Public Function s    |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\r\n   * @dev URIs are defined in RFC 3986.\r\n   *      URIs are assumed to be deterministically generated based on token ID\r\n   *      Token IDs are assumed to be represented in their hex format in URIs\r\n   * @return URI string\r\n   */\r\n  function uri(uint256 _id) public view returns (string memory) {\r\n    bytes memory bytesURI = bytes(baseMetadataURI);\r\n    if (bytesURI.length == 0 || bytesURI[bytesURI.length - 1] == '/')\r\n      return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \".json\"));\r\n    else return baseMetadataURI;\r\n  }\r\n\r\n  /**\r\n   * @notice Will update the base URL of token's URI\r\n   * @param _newBaseMetadataURI New base URL of token's URI\r\n   */\r\n  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\r\n    baseMetadataURI = _newBaseMetadataURI;\r\n  }\r\n\r\n  /***********************************|\r\n  |    Utility Internal Functions     |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice Convert uint256 to string\r\n   * @param _i Unsigned integer to convert to string\r\n   */\r\n  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\r\n    if (_i == 0) {\r\n      return \"0\";\r\n    }\r\n\r\n    uint256 j = _i;\r\n    uint256 ii = _i;\r\n    uint256 len;\r\n\r\n    // Get number of bytes\r\n    while (j != 0) {\r\n      len++;\r\n      j /= 10;\r\n    }\r\n\r\n    bytes memory bstr = new bytes(len);\r\n\r\n    // Get each individual ASCII\r\n    while (ii != 0) {\r\n      bstr[--len] = bytes1(uint8(48 + ii % 10));\r\n      ii /= 10;\r\n    }\r\n\r\n    // Convert to string\r\n    return string(bstr);\r\n  }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n  // Booleans are more expensive than uint256 or any type that takes up a full\r\n  // word because each write operation emits an extra SLOAD to first read the\r\n  // slot's contents, replace the bits taken up by the boolean, and then write\r\n  // back. This is the compiler's defense against contract upgrades and\r\n  // pointer aliasing, and it cannot be disabled.\r\n\r\n  // The values being non-zero value makes deployment a bit more expensive,\r\n  // but in exchange the refund on every call to nonReentrant will be lower in\r\n  // amount. Since refunds are capped to a percentage of the total\r\n  // transaction's gas, it is best to keep them low in cases like this one, to\r\n  // increase the likelihood of the full refund coming into effect.\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  string private constant ERR = \"Reentrancy\";\r\n\r\n  uint256 private _status;\r\n\r\n  constructor() {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and making it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    // On the first call to nonReentrant, _notEntered will be true\r\n    require(_status != _ENTERED, ERR);\r\n\r\n    // Any calls to nonReentrant after this point will fail\r\n    _status = _ENTERED;\r\n\r\n    _;\r\n\r\n    // By storing the original value once again, a refund is triggered (see\r\n    // https://eips.ethereum.org/EIPS/eip-2200)\r\n    _status = _NOT_ENTERED;\r\n  }\r\n}\r\n\r\n// OpenSea Registry Proxy\r\ncontract ProxyRegistry {\r\n  mapping(address => address) public proxies;\r\n}\r\n\r\n/**\r\n * @dev Implementation of Multi-Token Standard contract\r\n */\r\ncontract ERC1155Base is IERC1155, IERC165, ERC1155Metadata, Ownable, ReentrancyGuard {\r\n  using Address for address;\r\n\r\n  /***********************************|\r\n  |        Variables and Events       |\r\n  |__________________________________*/\r\n\r\n  // onReceive function signatures\r\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n\r\n  address constant internal NULL_ADDR = address(0);\r\n\r\n  string private constant ERR = \"ERC1155Base\";\r\n\r\n  // Contract name\r\n  string public name;\r\n\r\n  // Contract symbol\r\n  string public symbol;\r\n\r\n  // ProxyRegistry\r\n  address private immutable _proxyRegistry;\r\n\r\n  // initializer\r\n  address private immutable _initializer;\r\n\r\n  // Objects balances\r\n  mapping (address => mapping(uint256 => uint256)) internal balances;\r\n\r\n  // Operator Functions\r\n  mapping (address => mapping(address => bool)) internal operators;\r\n\r\n    // Max mints per transaction\r\n  uint256 private _maxTxMint;\r\n\r\n  // The CAP of mintable tokenIds\r\n  uint256 private _cap;\r\n\r\n  // ETH price of one tokenIds\r\n  uint256 private _tokenPrice;\r\n\r\n  // TokenId counter, 1 minted in ctor\r\n  uint256 private _currentTokenId;\r\n\r\n  // MintAllowed\r\n  uint256 private mintAllowed;\r\n\r\n  // ERC20 mint token\r\n  address private _erc20MintAddress;\r\n\r\n  // ERC20 mint token price per NFT \r\n  uint256 private _erc20MintPrice;\r\n\r\n  /***********************************|\r\n  |             Initialization        |\r\n  |__________________________________*/\r\n\r\n  constructor(address initializer_, address proxyRegistry) {\r\n    _proxyRegistry = proxyRegistry;\r\n    _initializer = initializer_;\r\n  }\r\n\r\n  function initialize(\r\n    address owner_,\r\n    string memory name_,\r\n    string memory symbol_\r\n   ) external\r\n  {\r\n    require(msg.sender == _initializer, ERR);\r\n\r\n    _transferOwnership(owner_);\r\n    name = name_;\r\n    symbol = symbol_;\r\n\r\n    // Mint our first token\r\n    balances[owner_][0] = 1;\r\n    emit TransferSingle(msg.sender, NULL_ADDR, owner(), 0, 1);\r\n  }\r\n\r\n  /**\r\n   * @dev Clone Initialization.\r\n   */\r\n  function initialize(\r\n    address owner_,\r\n    string memory name_,\r\n    string memory symbol_,\r\n    uint256 cap_,\r\n    uint256 maxPerTx_,\r\n    uint256 price_) external\r\n  {\r\n    require(msg.sender == _initializer, ERR);\r\n\r\n    _transferOwnership(owner_);\r\n\r\n    name = name_;\r\n    symbol = symbol_;\r\n    _cap = cap_;\r\n    _maxTxMint = maxPerTx_;\r\n    _tokenPrice = price_;\r\n    // Mint our first token\r\n    balances[owner_][0] = 1;\r\n    _currentTokenId = 1;\r\n    mintAllowed = 1;\r\n    emit TransferSingle(msg.sender, NULL_ADDR, owner_, 0, 1);\r\n  }\r\n\r\n  /***********************************|\r\n  |     Public Transfer Functions     |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\r\n   * @param _from    Source address\r\n   * @param _to      Target address\r\n   * @param _id      ID of the token type\r\n   * @param _amount  Transfered amount\r\n   * @param _data    Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    external override\r\n  {\r\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), ERR);\r\n    require(_to != address(0), ERR);\r\n \r\n    _safeTransferFrom(_from, _to, _id, _amount);\r\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\r\n  }\r\n\r\n  /**\r\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n   * @param _from     Source addresses\r\n   * @param _to       Target addresses\r\n   * @param _ids      IDs of each token type\r\n   * @param _amounts  Transfer amounts per token type\r\n   * @param _data     Additional data with no specified format, sent in call to `_to`\r\n   */\r\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    external override\r\n  {\r\n    // Requirements\r\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), ERR);\r\n    require(_to != address(0), ERR);\r\n\r\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\r\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\r\n  }\r\n\r\n  function unsafeBatchMint(address[] calldata _tos, uint256[] calldata _counts, uint256[] calldata _ids) external onlyOwner {\r\n    uint256 idOffset = 0;\r\n    for (uint256 i = 0; i < _tos.length; ++i) {\r\n      uint256 idOffsetEnd = idOffset + _counts[i];\r\n      require (idOffsetEnd <= _ids.length, ERR);\r\n      {\r\n        uint256 curE = _ids[idOffset] >> 8;\r\n        uint256 mask = 0;\r\n        for (; idOffset < idOffsetEnd; ++idOffset) {\r\n          // Update storage balance of previous bin\r\n          uint256 elem = _ids[idOffset] >> 8;\r\n          uint256 id = uint256(1) << (_ids[idOffset] & 0xFF);\r\n          if (elem != curE) {\r\n            balances[_tos[i]][curE] |= mask;\r\n            curE = elem;\r\n            mask = 0;\r\n          }\r\n          mask |= id;\r\n          emit TransferSingle(_tos[i], NULL_ADDR, _tos[i], _ids[idOffset], 1);\r\n        }\r\n        balances[_tos[i]][curE] |= mask;\r\n      }\r\n\r\n      uint256[] memory amounts = new uint256[](_counts[i]);\r\n      for (uint pos = 0; pos < _counts[i]; ++pos)\r\n        amounts[pos] = 1;\r\n      _callonERC1155BatchReceived(address(0), _tos[i], _ids[idOffsetEnd - _counts[i]:idOffsetEnd], amounts, '');\r\n    }\r\n  }\r\n\r\n  function unsafeBatchMessage(address[] calldata _tos, uint256[] calldata _counts, uint256[] calldata _ids) external onlyOwner {\r\n    uint256 idOffset = 0;\r\n    for (uint256 i = 0; i < _tos.length; ++i) {\r\n      uint256 idOffsetEnd = idOffset + _counts[i];\r\n      require (idOffsetEnd <= _ids.length, ERR);\r\n      for (; idOffset < idOffsetEnd; ++idOffset) {\r\n        emit TransferSingle(_tos[i], NULL_ADDR, _tos[i], _ids[idOffset], 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev mint\r\n   */\r\n  function mint(address to, uint256 numMint, bool erc20) external payable nonReentrant {\r\n    uint256 tid = _currentTokenId;\r\n    uint256 tidEnd = _currentTokenId + numMint;\r\n\r\n    require(mintAllowed != 0 &&\r\n      numMint > 0 &&\r\n      numMint <= _maxTxMint &&\r\n      tidEnd <= _cap, ERR\r\n    );\r\n\r\n    if (erc20) {\r\n      require(msg.value == 0 &&\r\n        _erc20MintAddress != address(0) &&\r\n        IERC20(_erc20MintAddress).transferFrom(msg.sender, address(this), numMint * _erc20MintPrice),\r\n        ERR\r\n      );\r\n    } else {\r\n      require(msg.value >= numMint * _tokenPrice, ERR);\r\n    }\r\n\r\n    {\r\n      uint256 mask = 0;\r\n      uint256 curE = tid >> 8;\r\n      for (; tid < tidEnd; ++tid) {\r\n        // Update storage balance of previous bin\r\n        uint256 elem = tid >> 8;\r\n        uint256 id = uint256(1) << (tid & 0xFF);\r\n        if (elem != curE) {\r\n          balances[to][curE] |= mask;\r\n          curE = elem;\r\n          mask = 0;\r\n        }\r\n        mask |= id;\r\n        emit TransferSingle(msg.sender, NULL_ADDR, to, tid, 1);\r\n      }\r\n      balances[to][curE] |= mask;\r\n      _currentTokenId += numMint;\r\n    }\r\n\r\n    if (!erc20) {\r\n      uint256 dust = msg.value - (numMint * _tokenPrice);\r\n      if (dust > 0) payable(msg.sender).transfer(dust);\r\n    }\r\n\r\n    { \r\n      uint256[] memory ids = new uint256[](numMint);\r\n      uint256[] memory amounts = new uint256[](numMint);\r\n      for (uint256 i = 0; i < numMint; ++i) {\r\n        ids[i] = tid - numMint--;\r\n        amounts[i] = 1;\r\n      }\r\n      _callonERC1155BatchReceived(address(0), to, ids, amounts, '');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Distribute rewards\r\n   */\r\n  function withdraw(bool erc20) external onlyOwner {\r\n    if (erc20) {\r\n      uint256 availableAmount = IERC20(_erc20MintAddress).balanceOf(address(this));\r\n      if (availableAmount > 0) {\r\n        IERC20(_erc20MintAddress).transferFrom(address(this), msg.sender, availableAmount);\r\n      }\r\n    } else {\r\n      uint256 availableAmount = address(this).balance;\r\n      if (availableAmount > 0) {\r\n        payable(msg.sender).transfer(availableAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function setBaseMetadataURI(string memory _newBaseMetadataURI) external onlyOwner {\r\n    _setBaseMetadataURI(_newBaseMetadataURI);\r\n  }\r\n\r\n  function setErc20MintData(address erc20Address, uint256 pricePerNft) external onlyOwner {\r\n    _erc20MintAddress = erc20Address;\r\n    _erc20MintPrice = pricePerNft;\r\n  }\r\n\r\n  /***********************************|\r\n  |    Internal Transfer Functions    |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\r\n   * @param _from    Source address\r\n   * @param _to      Target address\r\n   * @param _id      ID of the token type\r\n   * @param _amount  Transfered amount\r\n   */\r\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\r\n    internal\r\n  {\r\n    require(_amount == 1, ERR);\r\n\r\n    // Update balances\r\n    _transferOwner(_from, _to, _id);\r\n\r\n    // Emit event\r\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\r\n   */\r\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\r\n    internal\r\n  {\r\n    // Check if recipient is contract\r\n    if (_to.isContract()) {\r\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\r\n      require(retval == ERC1155_RECEIVED_VALUE, ERR);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\r\n   * @param _from     Source addresses\r\n   * @param _to       Target addresses\r\n   * @param _ids      IDs of each token type\r\n   * @param _amounts  Transfer amounts per token type\r\n   */\r\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\r\n    internal\r\n  {\r\n    uint256 len = _ids.length;\r\n\r\n    require(len == _amounts.length, ERR);\r\n\r\n    // Executing all transfers\r\n    for (uint256 i = 0; i < len; ++i) {\r\n      require(_amounts[i] == 1, ERR);\r\n      // Update storage balance of previous bin\r\n      _transferOwner(_from, _to, _ids[i]);\r\n    }\r\n\r\n    // Emit event\r\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\r\n  }\r\n\r\n  /**\r\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\r\n   */\r\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    internal\r\n  {\r\n    // Pass data if recipient is contract\r\n    if (_to.isContract()) {\r\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\r\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, ERR);\r\n    }\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |         Operator Functions        |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\r\n   * @param _operator  Address to add to the set of authorized operators\r\n   * @param _approved  True if the operator is approved, false to revoke approval\r\n   */\r\n  function setApprovalForAll(address _operator, bool _approved)\r\n    external override\r\n  {\r\n    // Update operator status\r\n    operators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @notice Queries the approval status of an operator for a given owner\r\n   * @param _owner     The owner of the Tokens\r\n   * @param _operator  Address of authorized operator\r\n   * @return isOperator if the operator is approved, false if not\r\n   */\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view override returns (bool isOperator)\r\n  {\r\n    // Whitelist OpenSea proxy contract for easy trading.\r\n    ProxyRegistry proxyRegistry = ProxyRegistry(_proxyRegistry);\r\n    if (address(proxyRegistry.proxies(_owner)) == _operator) {\r\n      return true;\r\n    }\r\n\r\n    return operators[_owner][_operator];\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |         Balance Functions         |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @notice Get the balance of an account's Tokens\r\n   * @param _owner  The address of the token holder\r\n   * @param _id     ID of the Token\r\n   * @return The _owner's balance of the Token type requested\r\n   */\r\n  function balanceOf(address _owner, uint256 _id)\r\n    public view override returns (uint256)\r\n  {\r\n    return _isOwner(_owner, _id) ? 1 : 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the balance of multiple account/token pairs\r\n   * @param _owners The addresses of the token holders\r\n   * @param _ids    ID of the Tokens\r\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n   */\r\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\r\n    public view override returns (uint256[] memory)\r\n  {\r\n    require(_owners.length == _ids.length, ERR);\r\n\r\n    // Variables\r\n    uint256[] memory batchBalances = new uint256[](_owners.length);\r\n\r\n    // Iterate over each owner and token ID\r\n    for (uint256 i = 0; i < _owners.length; i++) {\r\n      batchBalances[i] = _isOwner(_owners[i], _ids[i]) ? 1 : 0;\r\n    }\r\n\r\n    return batchBalances;\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |          ERC165 Functions         |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @dev INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\r\n   */\r\n  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\r\n\r\n  /**\r\n   *  @dev INTERFACE_SIGNATURE_ERC1155 =\r\n   * bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^\r\n   * bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^\r\n   * bytes4(keccak256(\"balanceOf(address,uint256)\")) ^\r\n   * bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^\r\n   * bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\r\n   * bytes4(keccak256(\"isApprovedForAll(address,address)\"));\r\n   */\r\n  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\r\n   * @return `true` if the contract implements `_interfaceID` and\r\n   */\r\n  function supportsInterface(bytes4 _interfaceID) external pure override returns (bool) {\r\n    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\r\n        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /***********************************|\r\n  |         balance Functions         |\r\n  |__________________________________*/\r\n\r\n  function _isOwner(address _from, uint256 _id) internal view returns (bool) {\r\n    return (balances[_from][_id >> 8] & (uint256(1) << (_id & 0xFF))) != 0;\r\n  }\r\n\r\n  function _transferOwner(address _from, address _to, uint256 _id) internal {\r\n    uint256 elem = _id >> 8;\r\n    uint256 id = uint256(1) << (_id & 0xFF);\r\n\r\n    if (_from != NULL_ADDR) {\r\n      require((balances[_from][elem] & id) != 0, ERR);\r\n      balances[_from][elem] &=~id;\r\n    }\r\n    \r\n    if (_to != NULL_ADDR) {\r\n      balances[_to][elem] |= id;\r\n    }\r\n  }\r\n}"
    }
  }
}