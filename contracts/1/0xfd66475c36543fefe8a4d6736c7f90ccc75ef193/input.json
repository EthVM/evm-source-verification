{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"elbote.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.8;\n\n\ncontract ElBote {\n    \n    //propietario\n    address private owner;\n    \n    //####\n    constructor(){\n        owner = msg.sender;\n    }\n    \n    function changeOwner(address newOwner) public payable {\n        require(msg.value >= min_ether);\n        payable(owner).transfer(msg.value);\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n    \n    //-----------------------------\n    \n    \n    //afiliados\n    struct Afiliado{\n        uint conversiones;\n        uint ingresos;\n        bool joined;\n    }\n    \n    mapping(address => Afiliado) private afiliados;\n    \n    uint constant N = 20;\n    address[N] private topIngresos;\n    address[N] private topConversiones;\n    \n    //####\n    function getAfiliadoInfo () public view returns (uint, uint, bool) {\n        return (afiliados[msg.sender].conversiones, afiliados[msg.sender].ingresos, afiliados[msg.sender].joined);\n    }\n    \n    function pushAfiliado () public payable {\n        require(msg.sender != owner);\n        require(msg.value >= min_ether);\n        require(afiliados[msg.sender].joined==false);\n        afiliados[msg.sender]=Afiliado(0,0, true);\n        payable(owner).transfer(msg.value);\n    }\n    //------------------------------\n    \n    \n    //EL BOTE - ¡¡¡HAGAN SUS APUESTAS!!!\n    uint public balanceTotal;\n    address private winner;\n    uint private winnerValue;\n    uint private winnerBlock;\n    uint private winnerDificulty;\n    uint private winnerTimespam;\n    uint private rand;\n    uint constant MAX_INT = 2**256 - 1; //115792089237316195423570985008687907853269984665640564039457584007913129639935\n    uint constant min_ether = 0.01 ether;\n    uint constant lotes = 0.001 ether; // calcularemos la probabilidad en n uinidades de 0.001 ethers\n    uint constant n_MAX_INT=MAX_INT/lotes;\n    uint constant TIME = 1 days;\n    uint private bonus;\n    uint public level;\n    uint public start;\n    uint public end;\n    uint public bote;\n    uint private apuesta;\n    \n    struct winners_info{\n        address winner;\n        uint start;\n        uint end;\n        uint premio;\n    }\n    \n    winners_info[] private winners;\n    \n    modifier minEther {require(msg.value >= min_ether);_;}\n    \n    modifier onlyOwner {payable(owner).transfer(msg.value * 20 / 100);_;}\n    \n    modifier noEsAfiliadoOwner {require(afiliados[msg.sender].joined==false);require(msg.sender != owner);_;}\n    \n    receive() external payable minEther onlyOwner noEsAfiliadoOwner {jugar();}\n    \n    fallback() external payable minEther onlyOwner noEsAfiliadoOwner {jugar();}\n    \n    event showWinner(address, uint, uint, uint);\n    \n    event showBote(uint, uint, uint);\n    \n    function setAfiliado(address addr_afiliado) external payable minEther noEsAfiliadoOwner {\n        require(afiliados[addr_afiliado].joined==true);\n        uint balance = msg.value * 10 / 100;\n        afiliados[addr_afiliado].conversiones++;\n        afiliados[addr_afiliado].ingresos+=balance;\n        if(afiliados[addr_afiliado].conversiones==5)\n            payable(addr_afiliado).transfer(afiliados[addr_afiliado].ingresos);\n        else if(afiliados[addr_afiliado].conversiones>5)\n            payable(addr_afiliado).transfer(balance);\n        payable(owner).transfer(balance);\n        //actualizar topIngresos\n        for(uint i=0; i<topIngresos.length; i++){\n            if(topIngresos[i]==addr_afiliado){\n                for(uint j=i; j<topIngresos.length-1; j++){\n                    topIngresos[j]=topIngresos[j+1];\n                }\n            }\n        }\n        for(uint i=0; i<topIngresos.length; i++){\n            bool insertar= false;\n            if(afiliados[topIngresos[i]].ingresos<afiliados[addr_afiliado].ingresos){\n                insertar= true;\n                for(uint j=topIngresos.length-1; j>i; j--){\n                    topIngresos[j]=topIngresos[j-1];\n                }\n                topIngresos[i]=addr_afiliado;\n            }\n            if(insertar)\n                break;\n        }\n        //actualizar topConversiones\n        for(uint i=0; i<topConversiones.length; i++){\n            if(topConversiones[i]==addr_afiliado){\n                for(uint j=i; j<topConversiones.length-1; j++){\n                    topConversiones[j]=topConversiones[j+1];\n                }\n            }\n        }\n        for(uint i=0; i<topConversiones.length; i++){\n            bool insertar= false;\n            if(afiliados[topConversiones[i]].conversiones<afiliados[addr_afiliado].conversiones){\n                insertar= true;\n                for(uint j=topConversiones.length-1; j>i; j--){\n                    topConversiones[j]=topConversiones[j-1];\n                }\n                topConversiones[i]=addr_afiliado;\n            }\n            if(insertar)\n                break;\n        }\n        //jugar\n        jugar();\n    }\n    \n    function jugar() private {\n        apuesta = msg.value - (msg.value * 20 / 100);\n        if(balanceTotal==0){\n            sumarApuesta();\n            setWinner();\n            bote = 1 ether; //bote inicial\n            calcularBonus();\n            level = bonus + 1;\n            start = block.timestamp;\n            end = block.timestamp + (level * TIME);\n            setBote();\n        }else{\n            sumarApuesta();\n            uint randHash = uint(blockhash(rand));\n            rand = uint(keccak256(abi.encodePacked(randHash, msg.sender, msg.value, block.number-1, block.difficulty, block.timestamp, winner, winnerValue, winnerBlock, winnerDificulty, winnerTimespam)));\n            uint n_apuesta=apuesta/lotes;\n            uint n_balance=balanceTotal/lotes;\n            uint probabilidad = n_apuesta * n_MAX_INT / n_balance;// no poner n_apuesta / n_balance * n_MAX_INT porque dará 0 siempre\n            uint n_rand = rand/lotes;\n            if(n_rand<=probabilidad)\n                setWinner();\n            calcularBonus();\n            if(bonus > 0){\n                level += bonus;\n                end += bonus * TIME;\n                setBote();\n            }\n            else if(block.timestamp > end){\n                winners.push(winners_info(winner, start, block.timestamp, balanceTotal));\n                uint amount = balanceTotal;\n                balanceTotal=0;\n                level=0;\n                bonus=0;\n                start=0;\n                end=0;\n                bote=0;\n                payable(winner).transfer(amount);\n                emit showWinner(winner, start, block.timestamp, amount);\n            }\n        }\n    }\n    \n    function setWinner() private {\n        winner=msg.sender;\n        winnerBlock=block.number-1;\n        winnerDificulty=block.difficulty;\n        winnerTimespam=block.timestamp;\n    }\n    \n    function setBote() private {\n        bote = 1 ether * (2**(level-1));\n        emit showBote(bote, start, end);\n    }\n    \n    function calcularBonus() private {\n        bonus = balanceTotal / bote;\n    }\n    \n    function sumarApuesta() private {\n        balanceTotal+=apuesta;\n    }\n    \n    function verBonus() public view returns ( uint _balanceTotal,  uint _bote,   uint _bonus, uint _level){\n        return (balanceTotal, bote, bonus, level);\n    }\n    \n    function tiempo() public view returns (uint inicio, uint _final, uint ahora){\n        return (start, end, block.timestamp);\n    }\n    \n    function verGanadores(uint n) public view returns (address _winner, uint _start, uint _end, uint _premio){\n        return (winners[n].winner, winners[n].start, winners[n].end, winners[n].premio);\n    }\n    \n    function verGanadoresLenght() public view returns (uint n){\n        return winners.length;\n    }\n    \n    function returnAfiliadoListaIngresos(uint n) public view returns (address, uint, uint){\n        return (topIngresos[n], afiliados[topIngresos[n]].conversiones, afiliados[topIngresos[n]].ingresos);\n    }\n    \n    function returnAfiliadoListaConversiones(uint n) public view returns (address, uint, uint){\n        return (topConversiones[n], afiliados[topConversiones[n]].conversiones, afiliados[topConversiones[n]].ingresos);\n    }\n    \n}"}}}