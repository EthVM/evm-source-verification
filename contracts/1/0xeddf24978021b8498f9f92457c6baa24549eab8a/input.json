{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/OXStaking.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-09-08\n*/\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address payable public owner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n        owner = _newOwner;\n        emit OwnershipTransferred(msg.sender, _newOwner);\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n *\n*/\n \nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function ceil(uint a, uint m) internal pure returns (uint r) {\n    return (a + m - 1) / m * m;\n  }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// ----------------------------------------------------------------------------\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n    function transfer(address to, uint256 tokens) external returns (bool success);\n    function approve(address spender, uint256 tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}\n\ncontract OXS_Staking is Owned{\n    \n    using SafeMath for uint256;\n\n    uint256 public totalRewards;\n    uint256 public stakingRate = 25; // 25%\n    uint256 public totalStakes;\n    \n    address public OXS = 0x9666007D4f18a3bE889FFc1Ed1fb65764911A376;\n    \n    struct DepositedToken{\n        uint256 activeDeposit;\n        uint256 totalDeposits;\n        uint256 startTime;\n        uint256 pendingGains;\n        uint256 lastClaimedDate;\n        uint256 totalGained;\n    }\n    \n    mapping(address => DepositedToken) users;\n    \n    event StakeStarted(uint256 indexed _amount);\n    event RewardsCollected(uint256 indexed _rewards);\n    event AddedToExistingStake(uint256 indexed tokens);\n    event StakingStopped(uint256 indexed _refunded);\n    \n    //#########################################################################################################################################################//\n    //####################################################FARMING EXTERNAL FUNCTIONS###########################################################################//\n    //#########################################################################################################################################################// \n    \n    // ------------------------------------------------------------------------\n    // Add tokens to stake\n    // @param _amount amount of tokens to stake\n    // ------------------------------------------------------------------------\n    function Stake(uint256 _amount) external{\n        \n        // add to stake\n        _newDeposit(_amount);\n        \n        // transfer tokens from user to the contract balance\n        require(IERC20(OXS).transferFrom(msg.sender, address(this), _amount));\n        \n        emit StakeStarted(_amount);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Add more deposits to already running stake\n    // @param _amount amount of tokens to deposit\n    // ------------------------------------------------------------------------\n    function AddToStake(uint256 _amount) external{\n        \n        _addToExisting(_amount);\n        \n        // move the tokens from the caller to the contract address\n        require(IERC20(OXS).transferFrom(msg.sender,address(this), _amount));\n        \n        emit AddedToExistingStake(_amount);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Withdraw accumulated rewards\n    // ------------------------------------------------------------------------\n    function ClaimReward() external {\n        require(PendingReward(msg.sender) > 0, \"No pending rewards\");\n    \n        uint256 _pendingReward = PendingReward(msg.sender);\n        \n        // Global stats update\n        totalRewards = totalRewards.add(_pendingReward);\n        \n        // update the record\n        users[msg.sender].totalGained = users[msg.sender].totalGained.add(_pendingReward);\n        users[msg.sender].lastClaimedDate = now;\n        users[msg.sender].pendingGains = 0;\n        \n        // mint more tokens inside token contract equivalent to _pendingReward\n        require(IERC20(OXS).transfer(msg.sender, _pendingReward));\n        \n        emit RewardsCollected(_pendingReward);\n    }\n    \n    // ------------------------------------------------------------------------\n    // This will stop the existing staking\n    // ------------------------------------------------------------------------\n    function StopStaking() external {\n        require(users[msg.sender].activeDeposit >= 0, \"No active stake\");\n        uint256 _activeDeposit = users[msg.sender].activeDeposit;\n        \n        // update staking stats\n            // check if we have any pending rewards, add it to previousGains var\n            users[msg.sender].pendingGains = PendingReward(msg.sender);\n            // update amount \n            users[msg.sender].activeDeposit = 0;\n            // reset last claimed figure as well\n            users[msg.sender].lastClaimedDate = now;\n        \n        // withdraw the tokens and move from contract to the caller\n        require(IERC20(OXS).transfer(msg.sender, _activeDeposit));\n        \n        emit StakingStopped(_activeDeposit);\n    }\n    \n    \n    \n    //#########################################################################################################################################################//\n    //##########################################################FARMING QUERIES################################################################################//\n    //#########################################################################################################################################################//\n    \n    // ------------------------------------------------------------------------\n    // Query to get the pending reward\n    // @param _caller address of the staker\n    // ------------------------------------------------------------------------\n    function PendingReward(address _caller) public view returns(uint256 _pendingRewardWeis){\n        uint256 _totalStakingTime = now.sub(users[_caller].lastClaimedDate);\n        \n        uint256 _reward_token_second = ((stakingRate).mul(10 ** 21)).div(365 days); // added extra 10^21\n        \n        uint256 reward = ((users[_caller].activeDeposit).mul(_totalStakingTime.mul(_reward_token_second))).div(10 ** 23); // remove extra 10^21 // 10^2 are for 100 (%)\n        \n        return reward.add(users[_caller].pendingGains);\n    }\n    \n    // ------------------------------------------------------------------------\n    // Query to get the active stake of the user\n    // @param _user wallet address of the staker\n    // ------------------------------------------------------------------------\n    function ActiveStakeDeposit(address _user) external view returns(uint256 _activeDeposit){\n        return users[_user].activeDeposit;\n    }\n    \n    // ------------------------------------------------------------------------\n    // Query to get the total staking of the user\n    // @param _user wallet address of the staker\n    // ------------------------------------------------------------------------\n    function YourTotalStakingTillToday(address _user) external view returns(uint256 _totalStaking){\n        return users[_user].totalDeposits;\n    }\n    \n    // ------------------------------------------------------------------------\n    // Query to get the time of last staking of user\n    // ------------------------------------------------------------------------\n    function LastStakedOn(address _user) external view returns(uint256 _unixLastStakedTime){\n        return users[_user].startTime;\n    }\n    \n    // ------------------------------------------------------------------------\n    // Query to get total earned rewards\n    // @param _user wallet address of the staker\n    // ------------------------------------------------------------------------\n    function TotalStakingRewards(address _user) external view returns(uint256 _totalEarned){\n        return users[_user].totalGained;\n    }\n    \n    //#########################################################################################################################################################//\n    //################################################################COMMON UTILITIES#########################################################################//\n    //#########################################################################################################################################################//    \n    \n    // ------------------------------------------------------------------------\n    // Internal function to add new deposit\n    // ------------------------------------------------------------------------        \n    function _newDeposit(uint256 _amount) internal{\n        require(users[msg.sender].activeDeposit ==  0, \"Already running, use funtion add to stake\");\n        \n        // add that token into the contract balance\n        // check if we have any pending reward, add it to pendingGains variable\n        users[msg.sender].pendingGains = PendingReward(msg.sender);\n            \n        users[msg.sender].activeDeposit = _amount;\n        users[msg.sender].totalDeposits = users[msg.sender].totalDeposits.add(_amount);\n        users[msg.sender].startTime = now;\n        users[msg.sender].lastClaimedDate = now;\n        \n        // update global stats\n        totalStakes = totalStakes.add(_amount);\n    }\n\n    // ------------------------------------------------------------------------\n    // Internal function to add to existing deposit\n    // ------------------------------------------------------------------------        \n    function _addToExisting(uint256 _amount) internal{\n        \n        require(users[msg.sender].activeDeposit > 0, \"no running farming/stake\");\n        \n        // update staking stats\n            // check if we have any pending reward, add it to pendingGains variable\n            users[msg.sender].pendingGains = PendingReward(msg.sender);\n            \n            // update current deposited amount \n            users[msg.sender].activeDeposit = users[msg.sender].activeDeposit.add(_amount);\n            // update total deposits till today\n            users[msg.sender].totalDeposits = users[msg.sender].totalDeposits.add(_amount);\n            // update new deposit start time -- new stake will begin from this time onwards\n            users[msg.sender].startTime = now;\n            // reset last claimed figure as well -- new stake will begin from this time onwards\n            users[msg.sender].lastClaimedDate = now;\n            \n        // update global stats\n        totalStakes = totalStakes.add(_amount);\n    }\n}"}}}