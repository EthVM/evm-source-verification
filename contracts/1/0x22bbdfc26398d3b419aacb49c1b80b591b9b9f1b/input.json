{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AVEC.sol": {
      "content": "pragma solidity^0.6.0;\r\n\r\n/*\r\n* Equitable Builds Inc presents..\r\n* ====================================*\r\n*        _____ ___ _______ ______     *\r\n*       |  _  |  ||  |  __|   __|     *\r\n*       |     |  |  |  __|   |__      *\r\n*       |__|__|_____|____|_____|      *\r\n*                                     *\r\n*        _____ __________ ______      *\r\n*       |     |   | | | ||   __|      *\r\n*       |  |  |     | | ||__   |      *\r\n*       |_____|_|___|___||_____|      *\r\n*                                     *\r\n*        _____ ____________ ___       *\r\n*       |     |  |  |   | ||  |       *\r\n*       |  |  |  |  |     ||  |       *\r\n*       |_____|_|_|_|_|___||__|       *\r\n*                                     *\r\n* ====================================*\r\n*/\r\n\r\ncontract AVEC{\r\n\r\n    /*=================================\r\n\r\n    =            MODIFIERS            =\r\n\r\n    =================================*/\r\n\r\n    //verify caller address members_ = true\r\n\r\n    modifier onlyMembers(address _customerAddress) {\r\n\r\n        require(\r\n\r\n                // is the customer in the member whitelist?\r\n\r\n                members_[_customerAddress] == true\r\n\r\n            );\r\n\r\n            // execute\r\n\r\n        _;\r\n\r\n    }\r\n\r\n    //verify caller address founderdevelopers_ = true\r\n\r\n    modifier onlyFounderDevelopers(address _customerAddress) {\r\n\r\n        require(\r\n\r\n                // is the customer in the Founder Developer whitelist?\r\n\r\n                founderdevelopers_[_customerAddress] == true\r\n\r\n            );\r\n\r\n            // execute\r\n\r\n        _;\r\n\r\n    }\r\n\r\n    //verify caller address ceva_ = true\r\n\r\n    modifier onlyCEVA(address _customerAddress) {\r\n\r\n        require(\r\n\r\n                // is the customer in the ceva whitelist?\r\n\r\n                ceva_[_customerAddress] == true\r\n\r\n            );\r\n\r\n            // execute\r\n\r\n        _;\r\n\r\n    }\r\n\r\n    //verify caller address ceva_ = true\r\n    \r\n    modifier onlyAdministrator(address _customerAddress){\r\n\r\n        require(\r\n\r\n            administrators[_customerAddress] == true\r\n\r\n            );\r\n\r\n        _;\r\n\r\n    }\r\n\r\n    /*==============================\r\n\r\n    =            EVENTS            =\r\n\r\n    ==============================*/\r\n\r\n    //Emit and Event to the blockcahin for AVECtoONUS\r\n    \r\n    event AVECtoONUS(\r\n\r\n        address indexed MemberAddress,\r\n\r\n        uint256 tokensConverted\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for ONUStoAVEC\r\n    \r\n    event ONUStoAVEC(\r\n\r\n        address indexed MemberAddress,\r\n\r\n        uint256 tokensConverted\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for OnWithdraw\r\n    \r\n    event OnWithdraw(\r\n\r\n        address indexed MemberAddress,\r\n\r\n        uint256 tokensWithdrawn,\r\n\r\n        uint8 envelopeNumber\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for Transfer\r\n    // ERC20\r\n\r\n    event Transfer(\r\n\r\n        address indexed from,\r\n\r\n        address indexed to,\r\n\r\n        uint256 value\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for PropertyTransfer\r\n    \r\n    event PropertyTransfer(\r\n\r\n        address indexed from,\r\n\r\n        address indexed to,\r\n\r\n        uint256 value,\r\n\r\n        bytes32 property\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for Burn\r\n    \r\n    event Burn(\r\n\r\n        address indexed from,\r\n\r\n        uint256 tokens,\r\n\r\n        uint256 propertyValue\r\n\r\n    );\r\n\r\n    // ERC20\r\n    //Emit and Event to the blockcahin for Approval\r\n    \r\n    event Approval(\r\n\r\n        address indexed _owner,\r\n\r\n        address indexed _spender,\r\n\r\n        uint256 _value\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for PropertyValuation\r\n    \r\n    event PropertyValuation(\r\n\r\n        address indexed from,\r\n\r\n        bytes32 _propertyUniqueID,\r\n\r\n        uint256 propertyValue\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for PropertyWhitelisted\r\n    \r\n    event PropertyWhitelisted(\r\n\r\n        address indexed from,\r\n\r\n        bytes32 _propertyUniqueID,\r\n\r\n        bool _trueFalse\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for MemberWhitelisted\r\n    \r\n    event MemberWhitelisted(\r\n\r\n        address indexed from,\r\n\r\n        address indexed to,\r\n\r\n        bool _trueFalse\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for FounderDeveloperWhitelisted\r\n    \r\n    event FounderDeveloperWhitelisted(\r\n\r\n        address indexed from,\r\n\r\n        address indexed to,\r\n\r\n        bool _trueFalse\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for CEVAWhitelisted\r\n    \r\n    event CEVAWhitelisted(\r\n\r\n        address indexed from,\r\n\r\n        address indexed to,\r\n\r\n        bool _trueFalse\r\n\r\n    );\r\n\r\n    //Emit and Event to the blockcahin for AdminWhitelisted\r\n    \r\n    event AdminWhitelisted(\r\n\r\n        address indexed from,\r\n\r\n        address indexed to,\r\n\r\n        bool _trueFalse\r\n\r\n    );\r\n\r\n    /*=====================================\r\n\r\n    =            CONFIGURABLES            =\r\n\r\n    =====================================*/\r\n\r\n    string public name = \"AlternateVirtualEquityCredits\";\r\n    \r\n    string public symbol = \"AVEC\";\r\n\r\n    uint8 public decimals = 18;\r\n    \r\n    //Setting to change for whoaaddress_\r\n\r\n    address internal whoaaddress_ = 0x314d0ED76d866826C809fb6a51d63642b2E9eC3e;\r\n    \r\n    //Global porfolio owner address\r\n    \r\n    address internal whoaaddressValue_ = 0x314d0ED76d866826C809fb6a51d63642b2E9eC3e;\r\n    \r\n    //Setting to change for whoamaintenanceaddress_\r\n\r\n    address internal whoamaintenanceaddress_ = 0x2722B426B11978c29660e8395a423Ccb93AE0403;\r\n    \r\n    //Setting to change for whoarewardsaddress_\r\n\r\n    address internal whoarewardsaddress_ = 0xA9d241b568DF9E8A7Ec9e44737f29a8Ee00bfF53;\r\n    \r\n    //Setting to change for cevaaddress_\r\n\r\n    address internal cevaaddress_ = 0xdE281c22976dE2E9b3f4F87bEB60aE9E67DFf5C4;\r\n    \r\n    //Setting to change for credibleyouaddress_\r\n\r\n    address internal credibleyouaddress_ = 0xc9c1Ffd6B4014232Ef474Daa4CA1506A6E39Be89;\r\n    \r\n    //Setting to change for techaddress_\r\n\r\n    address internal techaddress_ = 0xB6148C62e6A6d48f41241D01e3C4841139144ABa;\r\n    \r\n    //Setting to change for existcryptoaddress_\r\n\r\n    address internal existholdingsaddress_ = 0xac1B6580a175C1f2a4e3220A24e6f65fF3AB8A03;\r\n    \r\n    //Setting to change for existcryptoaddress_\r\n\r\n    address internal existcryptoaddress_ = 0xb8C098eE976f1162aD277936a5D1BCA7a8Fe61f5;\r\n\r\n    // members address whitelist archive\r\n\r\n    mapping(address => bool) internal members_;\r\n\r\n    // founder developers whitelist address archive\r\n\r\n    mapping(address => bool) internal founderdevelopers_;\r\n\r\n    // ceva whitelist address archive\r\n\r\n    mapping(address => bool) internal ceva_;\r\n\r\n    // administrator list (see above on what they can do)\r\n\r\n    mapping(address => bool) internal administrators;\r\n\r\n    // setting for allowance function determines amount of tokens address can spend from mapped address\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    // array mapping the mint request whitelist to keep track of all mint requests approved or disapproved by ceva\r\n    \r\n    mapping (address => mapping(bytes32 => bool)) internal mintrequestwhitelist_;\r\n    \r\n    // array mapping the burn request whitelist to keep track of all the token burnings made by ceva\r\n\r\n    mapping (address => mapping(bytes32 => bool)) internal burnrequestwhitelist_;\r\n    \r\n    // array mapping the property whitelist to keep track of all properties on the platform\r\n\r\n    mapping (address => mapping(bytes32 => bool)) internal propertywhitelist_;\r\n    \r\n    // array mapping the property Balance Ledger of a members current properties\r\n\r\n    mapping (bytes32 => mapping(address => uint256)) internal propertyBalanceLedger_;\r\n    \r\n    // array mapping the property Last Known Value for members current properties\r\n\r\n    mapping (bytes32 => mapping(address => uint256)) internal propertyLastKnownValue_;\r\n    \r\n    // array mapping the property value to keep track current property value \r\n\r\n    mapping (address => mapping(bytes32 => uint256)) internal propertyvalue_;\r\n    \r\n    // array mapping the old property value to keep track of the value previous to the current ceva value adjustment\r\n\r\n    mapping (address => mapping(bytes32 => uint256)) internal propertyvalueOld_;\r\n    \r\n    // array mapping the property Price Update Count for a Members current properties\r\n\r\n    mapping (address => mapping(bytes32 => uint256)) internal propertyPriceUpdateCountMember_;\r\n    \r\n    // array mapping the property Price Updates of the Asset to keep track of the number of times its been update\r\n    \r\n    mapping(bytes32 => uint256) internal propertyPriceUpdateCountAsset_;\r\n    \r\n    // array mapping the property Global Balance to keep track of all AVEC that is available for conversion into ONUS on a specific property\r\n\r\n    mapping(bytes32 => uint256) internal propertyGlobalBalance_;\r\n    \r\n    // array mapping the property Owner to keep track of all related properties\r\n\r\n    mapping(bytes32 => address) internal propertyOwner_;\r\n    \r\n    // array mapping the last Minting Price of any given minted property\r\n\r\n    mapping(bytes32 => uint256) internal lastMintingPrice_;\r\n    \r\n    // array mapping the transfering Property id of members intended as a setting to move the different kinds of token value\r\n\r\n    mapping(address => bytes32) internal transferingPropertyid_;\r\n    \r\n    // array mapping the working Property id's of founder developers and ceva to keep track of currently related working Property id's\r\n\r\n    mapping(address => bytes32) internal workingPropertyid_;\r\n    \r\n    // array mapping the working Mint Request id's to keep track of all related working Mint Request id's\r\n\r\n    mapping(address => bytes32) internal workingMintRequestid_;\r\n    \r\n    // array mapping the working Burn Request id's to keep track of all related working Burn Request id's\r\n\r\n    mapping(address => bytes32) internal workingBurnRequestid_;\r\n\r\n   /*================================\r\n\r\n    =            DATASETS            =\r\n\r\n    ================================*/\r\n    \r\n    //mapping the value of a wallets token balance ledger\r\n\r\n    mapping(address => uint256) internal tokenBalanceLedger_ ;\r\n    \r\n    //mapping the amount of deposits a wallet has received for the purpose of \r\n    //valuating the amount of dividends they are entitled to for their respective envelope hold shareholds\r\n\r\n    mapping(address => uint256) internal mintingDepositsOf_;\r\n    \r\n    //mapping to compare against the minting deposits of an address in order to determine amount of \r\n    //dividends they are enitled to\r\n\r\n    mapping(address => uint256) internal amountCirculated_;\r\n\r\n    mapping(address => uint256) internal taxesFeeTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal taxesPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal taxesFeeSharehold_;\r\n\r\n    mapping(address => uint256) internal insuranceFeeTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal insurancePreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal insuranceFeeSharehold_;\r\n\r\n    mapping(address => uint256) internal maintenanceFeeTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal maintenancePreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal maintenanceFeeSharehold_;\r\n\r\n    mapping(address => uint256) internal waECOFeeTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal waECOPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal waECOFeeSharehold_;\r\n\r\n    mapping(address => uint256) internal holdoneTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal holdonePreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal holdoneSharehold_;\r\n\r\n    mapping(address => uint256) internal holdtwoTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal holdtwoPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal holdtwoSharehold_;\r\n\r\n    mapping(address => uint256) internal holdthreeTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal holdthreePreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal holdthreeSharehold_;\r\n\r\n    mapping(address => uint256) internal rewardsTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal rewardsPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal rewardsSharehold_;\r\n\r\n    mapping(address => uint256) internal techTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal techPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal techSharehold_;\r\n\r\n    mapping(address => uint256) internal existholdingsTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal existholdingsPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal existholdingsSharehold_;\r\n\r\n    mapping(address => uint256) internal existcryptoTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal existcryptoPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal existcryptoSharehold_;\r\n\r\n    mapping(address => uint256) internal whoaTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal whoaPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal whoaSharehold_;\r\n\r\n    mapping(address => uint256) internal credibleyouTotalWithdrawn_;\r\n\r\n    mapping(address => uint256) internal credibleyouPreviousWithdrawn_;\r\n\r\n    mapping(address => uint256) internal credibleyouSharehold_;\r\n    \r\n    //mapping to keep track of number of whitelisted proofs on different events\r\n\r\n    mapping(address => uint256) internal numberofmintingrequestswhitelisted_;\r\n\r\n    mapping(address => uint256) internal numberofpropertieswhitelisted_;\r\n\r\n    mapping(address => uint256) internal numberofburnrequestswhitelisted_;\r\n    \r\n    //mapping to keep track of transfering from wallet to ensure values arent changed during crucial processes\r\n\r\n    mapping(address => uint256) internal transferingFromWallet_;\r\n    \r\n    //mapping to keeep track of the transfer type IE AVEC/ONUS/OMNI = 1/2/3\r\n    \r\n    mapping(address => uint8) internal transferType_;\r\n    \r\n    //property id that represents ONUS tokens property balance ledgers\r\n    \r\n    bytes32 internal onusCode_ = 0x676c6f62616c0000000000000000000000000000000000000000000000000000;\r\n    \r\n    //property id that represents OMNI tokens property balance ledgers\r\n    \r\n    bytes32 internal omniCode_ = 0x4f4d4e4900000000000000000000000000000000000000000000000000000000;\r\n    \r\n    //Total supply variable to keep track of all token minting\r\n    \r\n    uint256 public totalSupply;\r\n    \r\n    //Total Amount of Holds in existence\r\n\r\n    uint256 internal feeTotalHolds_;\r\n    \r\n    //The total deposited over time into the global fee ledger\r\n\r\n    uint256 internal globalFeeLedger_;\r\n    \r\n    //The total number of holds in each envelope\r\n\r\n    uint256 internal taxesfeeTotalHolds_;\r\n\r\n    uint256 internal insurancefeeTotalHolds_;\r\n\r\n    uint256 internal maintencancefeeTotalHolds_;\r\n\r\n    uint256 internal waECOfeeTotalHolds_;\r\n\r\n    uint256 internal holdonefeeTotalHolds_;\r\n\r\n    uint256 internal holdtwofeeTotalHolds_;\r\n\r\n    uint256 internal holdthreefeeTotalHolds_;\r\n\r\n    uint256 internal rewardsfeeTotalHolds_;\r\n\r\n    uint256 internal techfeeTotalHolds_;\r\n\r\n    uint256 internal existholdingsfeeTotalHolds_;\r\n\r\n    uint256 internal existcryptofeeTotalHolds_;\r\n\r\n    uint256 internal whoafeeTotalHolds_;\r\n\r\n    uint256 internal credibleyoufeeTotalHolds_;\r\n\r\n    /*=======================================\r\n\r\n    =            MEMBER FUNCTIONS            =\r\n\r\n    =======================================*/\r\n\r\n    /*\r\n\r\n    * -- APPLICATION ENTRY POINTS --\r\n\r\n    */\r\n\r\n    constructor()\r\n\r\n        public\r\n\r\n    {\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    * -- APPLICATION ENTRY POINTS --\r\n\r\n    */\r\n\r\n    function adminInitialSet()\r\n\r\n        public\r\n\r\n    {\r\n\r\n        // add the first users\r\n        \r\n        propertyOwner_[0x676c6f62616c0000000000000000000000000000000000000000000000000000] = whoaaddress_;\r\n\r\n        //James Admin\r\n\r\n        administrators[0xA9873d93db3BCA9F68aDfEAb226Fa9189641069A] \r\n        = true;\r\n\r\n        //Brenden Admin\r\n\r\n        administrators[0x27851761A8fBC03f57965b42528B39af07cdC42b] \r\n        = true;\r\n\r\n        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] \r\n        = true;\r\n\r\n        members_[0x2722B426B11978c29660e8395a423Ccb93AE0403] \r\n        = true;\r\n\r\n        members_[0x27851761A8fBC03f57965b42528B39af07cdC42b] \r\n        = true;\r\n\r\n        members_[0xA9873d93db3BCA9F68aDfEAb226Fa9189641069A] \r\n        = true;\r\n\r\n        members_[0xdE281c22976dE2E9b3f4F87bEB60aE9E67DFf5C4] \r\n        = true;\r\n\r\n        members_[0xc9c1Ffd6B4014232Ef474Daa4CA1506A6E39Be89] \r\n        = true;\r\n\r\n        members_[0xac1B6580a175C1f2a4e3220A24e6f65fF3AB8A03] \r\n        = true;\r\n\r\n        members_[0xB6148C62e6A6d48f41241D01e3C4841139144ABa] \r\n        = true;\r\n\r\n        members_[0xb8C098eE976f1162aD277936a5D1BCA7a8Fe61f5] \r\n        = true;\r\n\r\n        members_[0xA9d241b568DF9E8A7Ec9e44737f29a8Ee00bfF53] \r\n        = true;\r\n\r\n        members_[0x27851761A8fBC03f57965b42528B39af07cdC42b] \r\n        = true;\r\n\r\n        members_[0xa1Ff1474e0a5db4801E426289DB485b456de7882] \r\n        = true;\r\n\r\n\r\n\r\n    }\r\n    \r\n    /*\r\n\r\n    * -- APPLICATION ENTRY POINTS --\r\n\r\n    */\r\n\r\n    //Function to adjust corporate wallet address only usable by admin\r\n    \r\n    function adminGenesis(address _existcryptoaddress, address _existhooldingsaddress, address _techaddress,\r\n\r\n        address _credibleyouaddress, address _cevaaddress, address _whoaddress, address _whoarewardsaddress, address _whoamaintenanceaddress)\r\n\r\n        public\r\n\r\n        onlyAdministrator(msg.sender)\r\n\r\n    {\r\n\r\n        require(administrators[msg.sender], \"AdminFalse\");\r\n\r\n        // adds the _whoaddress input as the current whoa address\r\n\r\n        whoaaddress_ \r\n        = _whoaddress;\r\n\r\n        // adds the _whoamaintenanceaddress input as the current whoa maintenence address\r\n\r\n        whoamaintenanceaddress_ \r\n        = _whoamaintenanceaddress;\r\n\r\n        // adds the _whoarewardsaddress input as the current whoa rewards address\r\n\r\n        whoarewardsaddress_ \r\n        = _whoarewardsaddress;\r\n\r\n        // adds the )cevaaddress_ input as the current ceva address\r\n\r\n        cevaaddress_ \r\n        = _cevaaddress;\r\n\r\n        // adds the _credibleyouaddress input as the current credible you address\r\n\r\n        credibleyouaddress_ \r\n        = _credibleyouaddress;\r\n\r\n        // adds the _techaddress input as the current tech address\r\n\r\n        techaddress_ \r\n        = _techaddress;\r\n\r\n        // adds the __existhooldingsaddress input as the current exist holdings address\r\n\r\n        existholdingsaddress_ \r\n        = _existhooldingsaddress;\r\n\r\n        // adds the _existcryptoaddress input as the current exist crypto address\r\n\r\n        existcryptoaddress_ \r\n        = _existcryptoaddress;\r\n        \r\n        numberofburnrequestswhitelisted_[msg.sender] \r\n        = 0;\r\n\r\n        numberofpropertieswhitelisted_[msg.sender] \r\n        = 0;\r\n\r\n        numberofmintingrequestswhitelisted_[msg.sender] \r\n        = 0;\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Function for member to purchase a founder developer license.\r\n     * the fucntion checks if the member has have the required amount of tokens\r\n     * as well as checking if both founder developers are in fact founder developers\r\n     * along with ceva as an additional measure of verification.\r\n\r\n     */\r\n\r\n    function memberBuyFounderDeveloperLicense(address _founderDeveloperOne, address _founderDeveloperTwo, address _ceva)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        returns(bool _success)\r\n\r\n    {\r\n\r\n        require(founderdevelopers_[_founderDeveloperOne] == true \r\n        && ceva_[_ceva] == true \r\n        && founderdevelopers_[_founderDeveloperTwo] == true);\r\n\r\n        // setup data\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n            uint256 _licenseprice \r\n            = 1000 * 1e18;\r\n\r\n            if(tokenBalanceLedger_[_customerAddress] > _licenseprice){\r\n\r\n                propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_ceva] \r\n                = (_licenseprice / 5) + propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_ceva];\r\n\r\n                tokenBalanceLedger_[_ceva] = tokenBalanceLedger_[_ceva] \r\n                + (_licenseprice / 5);\r\n\r\n                propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_founderDeveloperOne] \r\n                =  (_licenseprice / 5) + propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_founderDeveloperOne];\r\n\r\n                tokenBalanceLedger_[_founderDeveloperOne] = tokenBalanceLedger_[_founderDeveloperOne] + (_licenseprice / 5);\r\n\r\n                propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_founderDeveloperTwo] \r\n                =  (_licenseprice / 10) + propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_founderDeveloperTwo];\r\n\r\n                tokenBalanceLedger_[_founderDeveloperTwo] = tokenBalanceLedger_[_founderDeveloperTwo] \r\n                + (_licenseprice / 10);\r\n\r\n                propertyBalanceLedger_[transferingPropertyid_[_customerAddress]][_customerAddress] \r\n                = propertyBalanceLedger_[transferingPropertyid_[_customerAddress]][_customerAddress] - _licenseprice;\r\n\r\n                tokenBalanceLedger_[_customerAddress] \r\n                = tokenBalanceLedger_[_customerAddress] - _licenseprice;\r\n\r\n                founderdevelopers_[_customerAddress] \r\n                = true;\r\n\r\n                return true;\r\n\r\n            } else {\r\n\r\n                return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * withdraw an envelope hold shareholders specific envelope dividends based on the chosen number\r\n     * 1 = Taxes Envelope\r\n     * 2 = Insurance Envelope\r\n     * 3 = Maintenance Envelope\r\n     * 4 = Wealth Architect Equity Coin Operator Envelope\r\n     * 5 = Hold One Envelope\r\n     * 6 = Hold Two Envelope\r\n     * 7 = Hold Three Envelope\r\n     * 8 = Rewards Envelope(OMNI)\r\n     * 9 = Tech Envelope\r\n     * 10 = Exist Holdings Envelope\r\n     * 11 = Exist Crypto Envelope\r\n     * 12 = WHOA Envelope\r\n     * 13 = Credible You Envelope\r\n     */\r\n\r\n    function memberWithdrawDividends(uint8 _envelopeNumber)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n    {\r\n\r\n        // setup data\r\n\r\n        address _customerAddress \r\n        = msg.sender;\r\n\r\n        uint256 _dividends;\r\n\r\n        if(_envelopeNumber == 1){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            taxesFeeTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 2){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            insuranceFeeTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 3){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            maintenanceFeeTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 4){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            waECOFeeTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 5){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            holdoneTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 6){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            holdtwoTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 7){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            holdthreeTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 8){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            rewardsTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n            \r\n            propertyBalanceLedger_[0x4f4d4e4900000000000000000000000000000000000000000000000000000000][_customerAddress] \r\n            +=  _dividends;\r\n\r\n            tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress] +_dividends;\r\n            \r\n            emit OnWithdraw(_customerAddress, _dividends, _envelopeNumber);\r\n\r\n        } else if(_envelopeNumber == 9){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            techTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 10){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            existholdingsTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 11){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            existcryptoTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 12){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            whoaTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        } else if(_envelopeNumber == 13){\r\n\r\n            _dividends \r\n            = checkDividendsOf(msg.sender, _envelopeNumber);\r\n\r\n            credibleyouTotalWithdrawn_[_customerAddress] \r\n            +=  _dividends;\r\n\r\n        }\r\n\r\n        // update dividend tracker\r\n        require(_envelopeNumber != 8);\r\n        \r\n        propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_customerAddress] \r\n        +=  _dividends;\r\n\r\n        tokenBalanceLedger_[_customerAddress] = tokenBalanceLedger_[_customerAddress] +_dividends;\r\n\r\n        // fire event\r\n\r\n        emit OnWithdraw(_customerAddress, _dividends, _envelopeNumber);\r\n\r\n    }\r\n    /**\r\n\r\n     * Transfer tokens from the caller to a new holder.\r\n\r\n     * Remember, there's a 2% fee here as well. members only\r\n\r\n     */\r\n\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n\r\n        public\r\n        \r\n        returns(bool)\r\n\r\n    {\r\n        transferingFromWallet_[msg.sender] = 1;\r\n        \r\n        uint256 _fee = _amountOfTokens / 50;\r\n        \r\n        _amountOfTokens += _fee;\r\n        \r\n        require(_amountOfTokens <= propertyBalanceLedger_[transferingPropertyid_[msg.sender]][msg.sender], \"Not Enough Token\");\r\n        \r\n        _amountOfTokens -= _fee;\r\n        \r\n        if(transferType_[msg.sender] == 1){\r\n        \r\n            require(members_[_toAddress] == true, \"Not a member\");\r\n            \r\n        }\r\n        \r\n        updateRollingPropertyValueMember(_toAddress, transferingPropertyid_[msg.sender]);\r\n        \r\n        uint256 _value \r\n        = _amountOfTokens + _fee;\r\n        \r\n        address _ownerAddress \r\n        = propertyOwner_[transferingPropertyid_[msg.sender]];\r\n\r\n        uint256 _divideby \r\n        = ((((propertyLastKnownValue_[transferingPropertyid_[msg.sender]][msg.sender] * 1e18) / 100) * 1000000) / propertyBalanceLedger_[transferingPropertyid_[msg.sender]][msg.sender]);\r\n\r\n        uint256 _propertyValue \r\n        = ((propertyvalue_[_ownerAddress][transferingPropertyid_[msg.sender]] * 1e18) / 100) * 1000000;\r\n\r\n        uint256 _pCalculate \r\n        = _propertyValue / _divideby;\r\n            \r\n        propertyBalanceLedger_[transferingPropertyid_[msg.sender]][msg.sender] \r\n        = _pCalculate - _value;\r\n        \r\n        propertyPriceUpdateCountMember_[msg.sender][transferingPropertyid_[msg.sender]] \r\n        = propertyPriceUpdateCountAsset_[transferingPropertyid_[msg.sender]];\r\n\r\n        propertyLastKnownValue_[transferingPropertyid_[msg.sender]][msg.sender] \r\n        = propertyvalue_[_ownerAddress][transferingPropertyid_[msg.sender]];\r\n\r\n        tokenBalanceLedger_[_toAddress] \r\n        = tokenBalanceLedger_[_toAddress] + _amountOfTokens;\r\n\r\n        tokenBalanceLedger_[msg.sender] \r\n        -= _value ;\r\n\r\n        propertyBalanceLedger_[transferingPropertyid_[msg.sender]][_toAddress] \r\n        = propertyBalanceLedger_[transferingPropertyid_[msg.sender]][_toAddress] + _amountOfTokens;\r\n\r\n        updateEquityRents(_amountOfTokens);\r\n        \r\n        transferingFromWallet_[msg.sender] = 0;\r\n        \r\n        emit Transfer(msg.sender, _toAddress, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n\r\n     * Convert AVEC into ONUS\r\n\r\n     */\r\n\r\n    function memberConvertAVECtoONUS(uint256 tokens)\r\n\r\n        public\r\n\r\n    {\r\n\r\n        bytes32 _propertyUniqueID \r\n        = transferingPropertyid_[msg.sender];\r\n\r\n        uint256 _propertyBalanceLedger \r\n        = propertyBalanceLedger_[_propertyUniqueID][msg.sender];\r\n\r\n        uint256 _value \r\n        = tokens;\r\n\r\n        updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n\r\n        if(_propertyBalanceLedger >= _value \r\n        && transferingFromWallet_[msg.sender] == 0){\r\n\r\n            // make sure we have the requested tokens\r\n            // setup\r\n            uint256 cValue;\r\n            \r\n            cValue = (propertyvalue_[propertyOwner_[_propertyUniqueID]][_propertyUniqueID] * 1e18) / 100;\r\n            require(members_[msg.sender] == true \r\n            && tokens > 0, \"Member or GlobalBalance\");\r\n\r\n            transferingFromWallet_[msg.sender] \r\n            = 1;\r\n\r\n            //Exchange tokens\r\n\r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][msg.sender] \r\n            += tokens;\r\n            \r\n            propertyBalanceLedger_[_propertyUniqueID][msg.sender] \r\n            -= tokens;\r\n            \r\n            propertyGlobalBalance_[_propertyUniqueID] \r\n            += tokens;\r\n            \r\n            propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n            += (tokens * 100) / 1e18;\r\n            \r\n            propertyLastKnownValue_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][msg.sender] \r\n            = propertyvalue_[propertyOwner_[0x676c6f62616c0000000000000000000000000000000000000000000000000000]][_propertyUniqueID];\r\n\r\n\r\n            transferingFromWallet_[msg.sender] = 0;\r\n\r\n            emit AVECtoONUS(msg.sender, _value);\r\n\r\n        } else {\r\n\r\n            _value \r\n            = 0;\r\n\r\n            emit AVECtoONUS(msg.sender, _value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Convert ONUS into AVEC\r\n\r\n     */\r\n\r\n    function memberConvertONUSintoAVEC(uint256 tokens)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n    {\r\n\r\n        bytes32 _propertyUniqueID \r\n        = transferingPropertyid_[msg.sender];\r\n\r\n        uint256 _propertyBalanceLedger \r\n        = ((propertyvalue_[propertyOwner_[_propertyUniqueID]][_propertyUniqueID] * 1e18) / 100) - propertyGlobalBalance_[_propertyUniqueID];\r\n\r\n        uint256 _value \r\n        = tokens;\r\n\r\n        updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n\r\n        if(_propertyBalanceLedger >= _value \r\n        && transferingFromWallet_[msg.sender] == 0){\r\n\r\n            // make sure we have the requested tokens\r\n            // setup\r\n\r\n            require(members_[msg.sender] == true \r\n            && tokens > 0);\r\n\r\n            transferingFromWallet_[msg.sender] \r\n            = 1;\r\n\r\n            //Exchange tokens\r\n\r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][msg.sender] \r\n            -= tokens;\r\n            propertyBalanceLedger_[_propertyUniqueID][msg.sender] \r\n            += tokens;\r\n            propertyGlobalBalance_[_propertyUniqueID] \r\n            -= tokens;\r\n            propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n            -= (tokens * 100) / 1e18;\r\n            propertyLastKnownValue_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][msg.sender] \r\n            -= propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000];\r\n\r\n\r\n            transferingFromWallet_[msg.sender] = 0;\r\n\r\n            emit ONUStoAVEC(msg.sender, _value);\r\n            \r\n\r\n        } else {\r\n\r\n            _value = 0;\r\n\r\n            emit ONUStoAVEC(msg.sender, _value);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //make an approved transfer from another wallet the transfer will verify \r\n    //based on the transfering ID of the from address input by the user\r\n    \r\n    function transferFrom(address from, address to, uint256 tokens)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        bytes32 _propertyUniqueID \r\n        = transferingPropertyid_[from];\r\n\r\n        uint256 _propertyBalanceLedger \r\n        = propertyBalanceLedger_[_propertyUniqueID][from];\r\n\r\n        uint256 _value \r\n        = tokens + (tokens / 50);\r\n\r\n        updateRollingPropertyValueMember(from, _propertyUniqueID);\r\n\r\n        if(_propertyBalanceLedger >= _value){\r\n\r\n            // setup\r\n\r\n            address _customerAddress = msg.sender;\r\n\r\n            // make sure we have the requested tokens\r\n\r\n            require(members_[to] == true \r\n            && tokens > 0 \r\n            &&from != to \r\n            && _value <= _allowed[from][msg.sender] \r\n            && msg.sender != from \r\n            && transferingFromWallet_[msg.sender] == 0);\r\n\r\n            transferingFromWallet_[msg.sender] \r\n            = 1;\r\n\r\n            updateEquityRents(tokens);\r\n\r\n            //Exchange tokens\r\n\r\n            tokenBalanceLedger_[to] \r\n            = tokenBalanceLedger_[to] + tokens;\r\n\r\n            tokenBalanceLedger_[from] \r\n            -= tokens + (tokens / 50);\r\n\r\n            propertyLastKnownValue_[_propertyUniqueID][msg.sender] \r\n            = propertyvalue_[propertyOwner_[_propertyUniqueID]][_propertyUniqueID];\r\n\r\n            //Reduce Approval Amount\r\n\r\n            _allowed[from][msg.sender] \r\n            -= tokens;\r\n\r\n            amountCirculated_[from] \r\n            += _value;\r\n\r\n            transferingFromWallet_[msg.sender] \r\n            = 0;\r\n\r\n            address _ownerAddress \r\n            = propertyOwner_[_propertyUniqueID];\r\n\r\n            address _holderAddress \r\n            = to;\r\n\r\n            uint256 _divideby \r\n            = ((((propertyLastKnownValue_[_propertyUniqueID][_holderAddress] * 1e18) / 100) * 1000000) / _propertyBalanceLedger);\r\n\r\n            uint256 _propertyValue \r\n            = ((propertyvalue_[_ownerAddress][_propertyUniqueID] * 1e18) / 100) * 1000000;\r\n\r\n            uint256 _pCalculate \r\n            = _propertyValue / _divideby;\r\n\r\n            propertyBalanceLedger_[_propertyUniqueID][_holderAddress] \r\n            = _pCalculate + tokens;\r\n\r\n            propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueID] \r\n            = propertyPriceUpdateCountAsset_[_propertyUniqueID];\r\n\r\n            propertyLastKnownValue_[_propertyUniqueID][_holderAddress] \r\n            = lastMintingPrice_[_propertyUniqueID];\r\n            \r\n            propertyBalanceLedger_[_propertyUniqueID][to] \r\n            = propertyBalanceLedger_[_propertyUniqueID][to] + tokens;\r\n\r\n            transferingFromWallet_[msg.sender] \r\n            = 0;\r\n\r\n            emit Transfer(_customerAddress, to, _value);\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //approve another wallet to spend an amount of funds distributed based on \r\n    //the transfering ID you have set at the time they call the transfeFrom \r\n    //function that will check if you have the available funds in your \r\n    //currently selected property\r\n    \r\n    function approve(address spender, uint256 value)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        returns (bool) {\r\n\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] \r\n        = value;\r\n\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n\r\n    // Returns the amount of tokens approved by the owner that can be\r\n\r\n    // transferred to the spender's account\r\n\r\n    // ------------------------------------------------------------------------\r\n\r\n    function allowance(address tokenOwner, address spender)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        view returns (uint remaining) {\r\n\r\n        return _allowed[tokenOwner][spender];\r\n\r\n    }\r\n\r\n     /**\r\n\r\n     * fucntion to clear the value of a title using a ceva whitelisted account when redemption clause is called.\r\n\r\n     */\r\n\r\n    function cevaClearTitle(uint256 _propertyValue, address _clearFrom)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        uint256 _amountOfTokens = ((_propertyValue * 1e18) / 100);\r\n        \r\n        uint256 _difference = _amountOfTokens - propertyBalanceLedger_[workingPropertyid_[msg.sender]][propertyOwner_[workingPropertyid_[msg.sender]]];\r\n        \r\n        if(workingPropertyid_[msg.sender] != 0x676c6f62616c0000000000000000000000000000000000000000000000000000){\r\n\r\n            require(burnrequestwhitelist_[_clearFrom][transferingPropertyid_[msg.sender]] == true \r\n            && propertywhitelist_[propertyOwner_[workingPropertyid_[msg.sender]]][workingPropertyid_[msg.sender]] == true \r\n            && _difference <= propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] \r\n            && _amountOfTokens >= 0);\r\n\r\n            //Burn Tokens\r\n\r\n            totalSupply\r\n            -= _amountOfTokens;\r\n\r\n            // take tokens out of stockpile\r\n\r\n            //Exchange tokens\r\n\r\n            propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n            -= propertyGlobalBalance_[workingPropertyid_[msg.sender]];\r\n\r\n            tokenBalanceLedger_[propertyOwner_[workingPropertyid_[msg.sender]]] \r\n            -= propertyBalanceLedger_[workingPropertyid_[msg.sender]][propertyOwner_[workingPropertyid_[msg.sender]]];\r\n            \r\n            propertyBalanceLedger_[workingPropertyid_[msg.sender]][propertyOwner_[workingPropertyid_[msg.sender]]]\r\n            = 0;\r\n            \r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_]\r\n            -= _amountOfTokens - propertyBalanceLedger_[workingPropertyid_[msg.sender]][propertyOwner_[workingPropertyid_[msg.sender]]];\r\n\r\n            // returns bool true\r\n\r\n            emit Burn(msg.sender, _amountOfTokens, _propertyValue);\r\n\r\n\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Transfer fee sharehold from the caller to a new holder based on envelope number see memberWithdrawDividends() 1-13 envelope names.\r\n\r\n     */\r\n\r\n    function memberSellFeeSharehold(address _toAddress, uint256 _amount, uint8 _envelopeNumber)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(_amount > 0 \r\n        && _envelopeNumber == 1){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= taxesFeeSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                taxesPreviousWithdrawn_[_toAddress] \r\n                += (taxesFeeTotalWithdrawn_[_customerAddress] / taxesFeeSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                taxesFeeSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                taxesFeeSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 2){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= insuranceFeeSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                insurancePreviousWithdrawn_[_toAddress] \r\n                += (insuranceFeeTotalWithdrawn_[_customerAddress] / insuranceFeeSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                insuranceFeeSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                insuranceFeeSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 3){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= maintenanceFeeSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                maintenancePreviousWithdrawn_[_toAddress] \r\n                += (maintenanceFeeTotalWithdrawn_[_customerAddress] / maintenanceFeeSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                maintenanceFeeSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                maintenanceFeeSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 4){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= waECOFeeSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                waECOPreviousWithdrawn_[_toAddress] \r\n                += (waECOFeeTotalWithdrawn_[_customerAddress] / waECOFeeSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                waECOFeeSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                waECOFeeSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 5){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= holdoneSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                holdonePreviousWithdrawn_[_toAddress] \r\n                += (holdoneTotalWithdrawn_[_customerAddress] / holdoneSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                holdoneSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                holdoneSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 6){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= holdtwoSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                holdtwoPreviousWithdrawn_[_toAddress] \r\n                += (holdtwoTotalWithdrawn_[_customerAddress] / holdtwoSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                holdtwoSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                holdtwoSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 && _envelopeNumber == 7){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= holdthreeSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                holdthreePreviousWithdrawn_[_toAddress] \r\n                += (holdthreeTotalWithdrawn_[_customerAddress] / holdthreeSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                holdthreeSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                holdthreeSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 8){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= rewardsSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                rewardsPreviousWithdrawn_[_toAddress] \r\n                += (rewardsTotalWithdrawn_[_customerAddress] / rewardsSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                rewardsSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                rewardsSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 9){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= techSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                techPreviousWithdrawn_[_toAddress] \r\n                += (techTotalWithdrawn_[_customerAddress] / techSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                techSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                techSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 10){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress \r\n            = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= existholdingsSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                existholdingsPreviousWithdrawn_[_toAddress] \r\n                += (existholdingsTotalWithdrawn_[_customerAddress] / existholdingsSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                existholdingsSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                existholdingsSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 11){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= existcryptoSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                existcryptoPreviousWithdrawn_[_toAddress] \r\n                += (existcryptoTotalWithdrawn_[_customerAddress] / existcryptoSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                existcryptoSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                existcryptoSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 12){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n         address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= whoaSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                whoaPreviousWithdrawn_[_toAddress] \r\n                += (whoaTotalWithdrawn_[_customerAddress] / whoaSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                whoaSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                whoaSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else if(_amount > 0 \r\n        && _envelopeNumber == 13){\r\n\r\n            require(members_[_toAddress] == true);\r\n\r\n        // setup\r\n\r\n            address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested sharehold\r\n\r\n            require(_amount <= credibleyouSharehold_[_customerAddress] \r\n            && _amount >= 0 \r\n            && _toAddress != _customerAddress);\r\n\r\n        //Update fee sharehold previous withdrawals   \r\n\r\n                credibleyouPreviousWithdrawn_[_toAddress] \r\n                += (credibleyouTotalWithdrawn_[_customerAddress] / credibleyouSharehold_[_customerAddress]) * _amount;\r\n\r\n        //Exchange sharehold\r\n\r\n                credibleyouSharehold_[_toAddress] \r\n                += _amount;\r\n\r\n                credibleyouSharehold_[_customerAddress] \r\n                -= _amount;\r\n\r\n                return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check and address to see if it has CEVA privileges or not\r\n\r\n     */\r\n\r\n    function checkCEVA(address _identifier)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(ceva_[_identifier] == true){\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check a property to see its value\r\n\r\n     */\r\n\r\n    function checkPropertyValue(address _ownerAddress, bytes32 _propertyUniqueID)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        if(propertyvalue_[_ownerAddress][_propertyUniqueID] >= 0){\r\n\r\n            return propertyvalue_[_ownerAddress][_propertyUniqueID];\r\n\r\n        } else {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check a property to see its owner\r\n\r\n     */\r\n\r\n    function checkPropertyOwner(bytes32 _propertyUniqueID)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(address)\r\n\r\n    {\r\n\r\n        return propertyOwner_[_propertyUniqueID];\r\n\r\n    }\r\n    \r\n    /**\r\n\r\n     * Check a property to see a related wallets last known value\r\n\r\n     */\r\n\r\n    function checkPropertyLastKnownValue(bytes32 _propertyUniqueID, address _memberWalletAddress)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        return propertyLastKnownValue_[_propertyUniqueID][_memberWalletAddress];\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check an address for its current transfering propety id\r\n\r\n     */\r\n\r\n    function checkTransferingPropertyID(address _ownerAddress)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bytes32)\r\n\r\n    {\r\n\r\n        if(_ownerAddress == msg.sender){\r\n\r\n            return transferingPropertyid_[msg.sender];\r\n\r\n        } else {\r\n\r\n            return transferingPropertyid_[_ownerAddress];\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check the globalFeeLedger_\r\n\r\n     */\r\n\r\n    function checkGlobalFeeLedger()\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        if(globalFeeLedger_ >= 0){\r\n\r\n            return globalFeeLedger_;\r\n\r\n        } else {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check an address to see if it has member privileges\r\n\r\n     */\r\n\r\n    function checkMember(address _identifier)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(members_[_identifier] == true){\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check an address to see is its got founder developer privileges\r\n\r\n     */\r\n\r\n    function checkFounderDeveloper(address _identifier)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(founderdevelopers_[_identifier] == true){\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Check an address to see if it has admin privileges\r\n\r\n     */\r\n\r\n    function checkAdmin(address _identifier)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(administrators[_identifier] == true){\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n\r\n    /**\r\n\r\n     * whitelist Admins admin only\r\n\r\n     */\r\n\r\n    function adminWhitelistAdministrator(address _identifier, bool _status)\r\n\r\n        public\r\n\r\n        onlyAdministrator(msg.sender)\r\n\r\n    {\r\n\r\n        require(msg.sender != _identifier);\r\n\r\n            administrators[_identifier] \r\n            = _status;\r\n\r\n            emit AdminWhitelisted(msg.sender, _identifier, _status);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     *entrypoint to whitelist ceva_ admin only\r\n\r\n     */\r\n\r\n    function adminWhitelistCEVA(address _identifier, bool _status)\r\n\r\n        public\r\n\r\n        onlyAdministrator(msg.sender)\r\n\r\n    {\r\n\r\n        require(msg.sender != _identifier, \"Invalid address\");\r\n\r\n            ceva_[_identifier] \r\n            = _status;\r\n\r\n            numberofburnrequestswhitelisted_[msg.sender] \r\n            = 0;\r\n\r\n            numberofpropertieswhitelisted_[msg.sender] \r\n            = 0;\r\n\r\n            numberofmintingrequestswhitelisted_[msg.sender] \r\n            = 0;\r\n\r\n            emit CEVAWhitelisted(msg.sender, _identifier, _status);\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Whitelist a Mint Request that has been confirmed on the site.. ceva only\r\n\r\n     */\r\n\r\n    function cevaWhitelistMintRequest(address _ownerAddress, bool _trueFalse, bytes32 _mintingRequestUniqueid)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(_mintingRequestUniqueid == workingPropertyid_[msg.sender]){\r\n\r\n            require(msg.sender != _ownerAddress);\r\n\r\n            mintrequestwhitelist_[_ownerAddress][_mintingRequestUniqueid] \r\n            = _trueFalse;\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Whitelist a Burn Request that has been confirmed on the site.. ceva only\r\n\r\n     */\r\n\r\n    function cevaWhitelistBurnRequest(address _ownerAddress, bool _trueFalse, bytes32 _burnrequestUniqueID)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(_burnrequestUniqueID == workingBurnRequestid_[msg.sender]){\r\n\r\n            require(msg.sender != _ownerAddress);\r\n\r\n            burnrequestwhitelist_[_ownerAddress][_burnrequestUniqueID] \r\n            = _trueFalse;\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n\r\n     * Whitelist a Property that has been confirmed on the site.. ceva only\r\n\r\n     */\r\n\r\n    function cevaWhitelistProperty(address _ownerAddress, bool _trueFalse, bytes32 _propertyUniqueID)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(_trueFalse = true){\r\n\r\n            require(workingPropertyid_[msg.sender] == _propertyUniqueID);\r\n\r\n            propertywhitelist_[_ownerAddress][_propertyUniqueID] \r\n            = _trueFalse;\r\n\r\n            propertyOwner_[_propertyUniqueID] \r\n            = _ownerAddress;\r\n\r\n            lastMintingPrice_[_propertyUniqueID] \r\n            = 0 + ((lastMintingPrice_[_propertyUniqueID] + 1) - 1);\r\n            \r\n            propertyPriceUpdateCountAsset_[_propertyUniqueID] \r\n            += 0;\r\n\r\n            emit PropertyWhitelisted(msg.sender, _propertyUniqueID, _trueFalse);\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            propertywhitelist_[_ownerAddress][_propertyUniqueID] \r\n            = _trueFalse;\r\n\r\n            lastMintingPrice_[_propertyUniqueID] \r\n            = 0 + ((lastMintingPrice_[_propertyUniqueID] + 1) - 1);\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Adjust a property value used by ceva for valuation events.. ceva only\r\n\r\n     */\r\n\r\n    function cevaUpdatePropertyValue(address _ownerAddress, uint256 _propertyValue)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n        returns(uint256, uint8)\r\n\r\n    {\r\n\r\n        require(propertywhitelist_[_ownerAddress][workingPropertyid_[msg.sender]] = true \r\n        && _propertyValue >= 0 \r\n        && workingPropertyid_[msg.sender] != 0x676c6f62616c0000000000000000000000000000000000000000000000000000);\r\n\r\n            if(_ownerAddress != msg.sender){\r\n\r\n                address _customerAddress \r\n                = msg.sender;\r\n\r\n                propertyvalueOld_[_ownerAddress][workingPropertyid_[msg.sender]] \r\n                = propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]];\r\n                \r\n                if(propertyPriceUpdateCountAsset_[0x676c6f62616c0000000000000000000000000000000000000000000000000000] >= 0){\r\n                    \r\n                    propertyvalueOld_[_ownerAddress][workingPropertyid_[msg.sender]] \r\n                    = _propertyValue;\r\n                }\r\n\r\n                if(propertyGlobalBalance_[workingPropertyid_[msg.sender]] >= 1e18){\r\n                    \r\n                    propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]] \r\n                    = _propertyValue;\r\n                    \r\n                    uint256 _pCalculate \r\n                    = (((propertyvalueOld_[_ownerAddress][workingPropertyid_[msg.sender]] * 1e18) / 100) * 1000000) / propertyGlobalBalance_[workingPropertyid_[msg.sender]];\r\n                    \r\n                    uint256 _propertyGlobalBalanceOld \r\n                    = propertyGlobalBalance_[workingPropertyid_[msg.sender]];\r\n                    \r\n                    uint256 _qCalculate \r\n                    = ((( propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]] * 1e18) / 100) * 1000000) / _pCalculate;\r\n                    \r\n                    propertyGlobalBalance_[workingPropertyid_[msg.sender]] \r\n                    = _qCalculate;\r\n                    \r\n                    propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n                    += propertyGlobalBalance_[workingPropertyid_[msg.sender]];\r\n                    \r\n                    propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n                    -= _propertyGlobalBalanceOld;\r\n                }\r\n                \r\n\r\n                lastMintingPrice_[workingPropertyid_[msg.sender]] \r\n                = _propertyValue;\r\n                \r\n                propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]] \r\n                = _propertyValue;\r\n                \r\n                uint256 _pValue \r\n                = propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]];\r\n                \r\n                uint256 _pValueOld \r\n                = propertyvalueOld_[_ownerAddress][workingPropertyid_[msg.sender]];\r\n                \r\n                propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]] \r\n                = (_pValue + _propertyValue) - _pValueOld;\r\n\r\n                propertyPriceUpdateCountAsset_[workingPropertyid_[msg.sender]] \r\n                += 1;\r\n\r\n                propertyPriceUpdateCountAsset_[0x676c6f62616c0000000000000000000000000000000000000000000000000000] += 1;\r\n\r\n                if(propertyPriceUpdateCountAsset_[workingPropertyid_[msg.sender]] >= 1){\r\n\r\n                    totalSupply \r\n                    = (totalSupply - ((propertyvalueOld_[_ownerAddress][workingPropertyid_[msg.sender]] * 1e18) / 100)) + ((propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]] * 1e18) / 100);\r\n\r\n                    propertyPriceUpdateCountAsset_[0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n                    = propertyPriceUpdateCountAsset_[0x676c6f62616c0000000000000000000000000000000000000000000000000000];\r\n\r\n                }\r\n\r\n                emit PropertyValuation(_customerAddress, workingPropertyid_[msg.sender], propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]]);\r\n\r\n                return (propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]], 1);\r\n\r\n            } else {\r\n\r\n                return (propertyvalue_[_ownerAddress][workingPropertyid_[msg.sender]], 2);\r\n\r\n            }\r\n\r\n    }\r\n\r\n    //update a members last known property value in order to keep supply current based on previously unknown value adjustments made by ceva\r\n    \r\n    function updateRollingPropertyValueMember(address _holderAddress, bytes32 _propertyUniqueId)\r\n\r\n        internal\r\n\r\n    {\r\n\r\n        address _ownerAddress \r\n        = propertyOwner_[_propertyUniqueId];\r\n\r\n        uint256 _propertyBalanceLedger \r\n        = propertyBalanceLedger_[_propertyUniqueId][_holderAddress];\r\n\r\n        if(propertyPriceUpdateCountAsset_[_propertyUniqueId] > propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId] \r\n        && propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId] == 0) {\r\n            \r\n            propertyLastKnownValue_[_propertyUniqueId][_holderAddress] \r\n            = propertyvalue_[_ownerAddress][_propertyUniqueId];\r\n\r\n            propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId] \r\n            = propertyPriceUpdateCountAsset_[_propertyUniqueId];\r\n            \r\n        } else if(propertyPriceUpdateCountAsset_[_propertyUniqueId] > propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]){\r\n            \r\n            uint256 _divideby \r\n            = ((((propertyLastKnownValue_[_propertyUniqueId][_holderAddress] * 1e18) / 100) * 1000000) / _propertyBalanceLedger);\r\n\r\n            uint256 _propertyValue \r\n            = ((propertyvalue_[_ownerAddress][_propertyUniqueId] * 1e18) / 100) * 1000000;\r\n\r\n            uint256 _pCalculate \r\n            = _propertyValue / _divideby;\r\n\r\n            propertyBalanceLedger_[_propertyUniqueId][_holderAddress] \r\n            = _pCalculate;\r\n            \r\n            tokenBalanceLedger_[_holderAddress] \r\n            = (tokenBalanceLedger_[_holderAddress] + _pCalculate) - _propertyBalanceLedger;\r\n\r\n            propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId] \r\n            = propertyPriceUpdateCountAsset_[_propertyUniqueId];\r\n            \r\n            propertyLastKnownValue_[_propertyUniqueId][_holderAddress] \r\n            = propertyvalue_[_ownerAddress][_propertyUniqueId];\r\n            \r\n        } else {\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    //manual function to update a property balance ledger for a specific wallet in order to see new balance \r\n    //before calling other functions that auto update property balance ledgers after ceva value adjustments\r\n    \r\n    function memberUpdateRollingPropertyValue(address _holderAddress, bytes32 _propertyUniqueId)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        returns(uint8)\r\n\r\n    {\r\n\r\n        address _ownerAddress \r\n        = propertyOwner_[_propertyUniqueId];\r\n\r\n        if(propertyPriceUpdateCountAsset_[_propertyUniqueId] != propertyPriceUpdateCountMember_[_holderAddress][_propertyUniqueId]\r\n\r\n        && propertyBalanceLedger_[_propertyUniqueId][_holderAddress] > 0){\r\n\r\n            require(propertywhitelist_[_ownerAddress][_propertyUniqueId] = true);\r\n\r\n            assert(propertyvalue_[_ownerAddress][_propertyUniqueId] > 0);\r\n\r\n            updateRollingPropertyValueMember(_holderAddress,_propertyUniqueId);\r\n\r\n            return 1;\r\n\r\n        } else {\r\n\r\n            return 2;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /*----------  FOUNDER DEVELOPER ONLY FUNCTIONS  ----------*/\r\n\r\n    // Mint an amount of tokens to an address\r\n\r\n    // using the minting request unique ID, and property unique ID set by the founder developer\r\n\r\n    function founderDeveloperMintAVEC(uint256 _founderDeveloperFee, address _toAddress, address _holdOne, address _holdTwo, address _holdThree,\r\n\r\n        uint256 _propertyValue, address _commissionFounderDeveloper)\r\n\r\n        public\r\n\r\n        onlyFounderDevelopers(msg.sender)\r\n\r\n    {\r\n        bytes32 _propertyUniqueID = workingPropertyid_[msg.sender];\r\n        \r\n        bytes32 _mintingRequestUniqueid = workingMintRequestid_[msg.sender];\r\n        \r\n        uint256 _amountOfTokens \r\n        = (_propertyValue * 1e18) / 100;\r\n\r\n        if(_propertyValue == propertyvalue_[propertyOwner_[_propertyUniqueID]][_propertyUniqueID]){\r\n\r\n        // data setup\r\n            \r\n            require(members_[_toAddress] == true \r\n            \r\n            && _founderDeveloperFee >= 20001 \r\n            \r\n            && _founderDeveloperFee <= 100000 \r\n            \r\n            && msg.sender != _toAddress \r\n            \r\n            && _propertyUniqueID == workingPropertyid_[msg.sender]\r\n\r\n            && _mintingRequestUniqueid == workingMintRequestid_[msg.sender]);\r\n\r\n            // add tokens to the pool\r\n\r\n            updateHoldsandSupply(_amountOfTokens);\r\n\r\n            // add to burner stockpile\r\n\r\n            tokenBalanceLedger_[whoaaddress_] \r\n            = tokenBalanceLedger_[whoaaddress_] + (_amountOfTokens / 50);\r\n\r\n            // credit founder developer fee\r\n\r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][_commissionFounderDeveloper] += (_amountOfTokens * 1000) / _founderDeveloperFee;\r\n\r\n            tokenBalanceLedger_[_commissionFounderDeveloper] \r\n            = tokenBalanceLedger_[_commissionFounderDeveloper] + (_amountOfTokens * 1000) / _founderDeveloperFee;\r\n\r\n            //credit Envelope Fee Shareholds\r\n\r\n            creditFeeSharehold(_amountOfTokens, _toAddress, _holdOne, _holdTwo, _holdThree);\r\n\r\n            // credit tech feeSharehold_    ;\r\n\r\n            uint256 _techFee \r\n            = (_amountOfTokens * 100) / 25000;\r\n\r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][techaddress_] \r\n            += _techFee;\r\n\r\n            propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n            += (_amountOfTokens * 100000000000) / 1111234581620;\r\n\r\n            tokenBalanceLedger_[techaddress_] \r\n            = tokenBalanceLedger_[techaddress_] + _techFee;\r\n\r\n            uint256 _whoaFees \r\n            = (_amountOfTokens * 100000000000000) / 2500000000000625;\r\n\r\n            uint256 _fee \r\n            = (_amountOfTokens * (1000 * 100000)) / (_founderDeveloperFee * 100000);\r\n\r\n            // add tokens to the _toAddress\r\n\r\n            propertyBalanceLedger_[_propertyUniqueID][_toAddress] \r\n            = propertyBalanceLedger_[_propertyUniqueID][_toAddress] + ((_amountOfTokens - _whoaFees)- _fee);\r\n\r\n            tokenBalanceLedger_[_toAddress] \r\n            = tokenBalanceLedger_[_toAddress] + ((_amountOfTokens - _whoaFees)- _fee);\r\n\r\n            mintingDepositsOf_[_toAddress] \r\n            += ((_amountOfTokens - _whoaFees)- _fee);\r\n\r\n            propertyGlobalBalance_[_propertyUniqueID] \r\n            += _whoaFees + _fee;\r\n\r\n            // whoa fee\r\n\r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] \r\n            += _whoaFees - _techFee;\r\n\r\n            // fire event\r\n\r\n            emit Transfer(msg.sender, _toAddress, _amountOfTokens);\r\n\r\n        } else {\r\n\r\n            // fire event\r\n\r\n            _amountOfTokens \r\n            = 0;\r\n\r\n            emit Transfer(msg.sender, _toAddress, _amountOfTokens);\r\n\r\n        }\r\n\r\n    }\r\n    \r\n    function globalReplace()\r\n        \r\n        public\r\n        \r\n    {\r\n        if(ceva_[msg.sender] == true && propertywhitelist_[propertyOwner_[workingPropertyid_[msg.sender]]][workingPropertyid_[msg.sender]]){\r\n\r\n            uint256 _amountOfTokens = (propertyvalue_[propertyOwner_[workingPropertyid_[msg.sender]]][workingPropertyid_[msg.sender]] * 1e18) / 100;\r\n            \r\n            propertyBalanceLedger_[0x676c6f62616c0000000000000000000000000000000000000000000000000000][whoaaddress_] \r\n            += _amountOfTokens;\r\n            \r\n            propertyGlobalBalance_[workingPropertyid_[msg.sender]] += _amountOfTokens;\r\n\r\n            propertyvalue_[whoaaddressValue_][0x676c6f62616c0000000000000000000000000000000000000000000000000000] \r\n            += _amountOfTokens;\r\n\r\n            tokenBalanceLedger_[whoaaddress_] \r\n            += _amountOfTokens;\r\n\r\n            // fire event\r\n\r\n            emit Transfer(msg.sender, whoaaddress_, _amountOfTokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n\r\n     * choose the property id that you will be working on ceva/Founder Developer\r\n\r\n     */\r\n\r\n    function propertyId(address _ownerAddress, bytes32 _propertyUniqueId)\r\n\r\n        public\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(members_[_ownerAddress] == true){\r\n\r\n            workingPropertyid_[msg.sender] \r\n            = _propertyUniqueId;\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Select a specific property unique id to swap its AVEC when calling the transfer function.\r\n\r\n     */\r\n\r\n    function swapAVEC(bytes32 _propertyUniqueID)\r\n\r\n        public\r\n\r\n        onlyMembers(msg.sender)\r\n\r\n        returns(bytes32, uint8)\r\n\r\n    {\r\n\r\n        if(transferingFromWallet_[msg.sender] == 0){\r\n            \r\n            updateRollingPropertyValueMember(msg.sender, _propertyUniqueID);\r\n            \r\n            transferingPropertyid_[msg.sender] \r\n            = _propertyUniqueID;\r\n            \r\n            transferType_[msg.sender]\r\n            = 1;\r\n\r\n            return (transferingPropertyid_[msg.sender], 1);\r\n        } else {\r\n            return (transferingPropertyid_[msg.sender], 2);\r\n        }\r\n\r\n\r\n\r\n    }\r\n    \r\n    /**\r\n\r\n     * Select ONUS as the asset to be moved when calling the transfer function.\r\n\r\n     */\r\n\r\n    function swapONUS()\r\n\r\n        public\r\n\r\n        returns(bytes32, uint8)\r\n\r\n    {\r\n\r\n        if(transferingFromWallet_[msg.sender] == 0){\r\n            \r\n            transferingPropertyid_[msg.sender] \r\n            = onusCode_;\r\n            updateRollingPropertyValueMember(msg.sender, onusCode_);\r\n            transferType_[msg.sender]\r\n            = 2;\r\n\r\n            return (transferingPropertyid_[msg.sender], 1);\r\n        } else {\r\n            return (transferingPropertyid_[msg.sender], 2);\r\n        }\r\n\r\n\r\n\r\n    }\r\n    \r\n    /**\r\n\r\n     * Select OMNI as the asset to be moved when calling the transfer function.\r\n\r\n     */\r\n\r\n    function swapOMNI()\r\n\r\n        public\r\n\r\n        returns(bytes32, uint8)\r\n\r\n    {\r\n\r\n        if(transferingFromWallet_[msg.sender] == 0){\r\n            \r\n            transferingPropertyid_[msg.sender] \r\n            = omniCode_;\r\n            updateRollingPropertyValueMember(msg.sender, omniCode_);\r\n            transferType_[msg.sender]\r\n            = 3;\r\n\r\n            return (transferingPropertyid_[msg.sender], 1);\r\n        } else {\r\n            return (transferingPropertyid_[msg.sender], 2);\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * choose the whitelisted minting request you want to work workingMintRequestid_\r\n     * \r\n     * founder developer only\r\n\r\n     */\r\n\r\n    function founderDeveloperMintingRequest(address _ownerAddress, bytes32 _mintingRequestUniqueid)\r\n\r\n        public\r\n\r\n        onlyFounderDevelopers(msg.sender)\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        require(mintrequestwhitelist_[_ownerAddress][_mintingRequestUniqueid] = true);\r\n\r\n            if(members_[_ownerAddress] == true){\r\n\r\n                workingMintRequestid_[msg.sender] \r\n                = _mintingRequestUniqueid;\r\n\r\n                return true;\r\n\r\n            } else {\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * select the burn request id you would like to use for the clear title function\r\n     * \r\n     * ceva only\r\n\r\n     */\r\n\r\n    function cevaBurnRequestId(address _ownerAddress, bytes32 _propertyUniqueID, uint256 _propertyValue)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n        returns(bytes32)\r\n\r\n    {\r\n\r\n        require(burnrequestwhitelist_[_ownerAddress][_propertyUniqueID] = true);\r\n\r\n            if(members_[_ownerAddress] == true){\r\n\r\n                workingPropertyid_[msg.sender] = _propertyUniqueID;\r\n\r\n                numberofburnrequestswhitelisted_[msg.sender] \r\n                += 1;\r\n\r\n                emit PropertyValuation(msg.sender, _propertyUniqueID, _propertyValue);\r\n\r\n                return _propertyUniqueID;\r\n\r\n            } else {\r\n\r\n                numberofmintingrequestswhitelisted_[msg.sender] \r\n                -= 1;\r\n\r\n                _propertyValue = 0;\r\n\r\n                return _propertyUniqueID;\r\n\r\n            }\r\n\r\n    }\r\n\r\n    //Function to Convert Bytes32 codes into a string.\r\n    \r\n    function bytes32ToString(bytes32 _bytes32)\r\n\r\n    public\r\n\r\n    view\r\n\r\n    onlyMembers(msg.sender)\r\n\r\n    returns (string memory) {\r\n\r\n        uint8 i = 0;\r\n\r\n        while(i < 32 && _bytes32[i] != 0) {\r\n\r\n            i++;\r\n\r\n        }\r\n\r\n        bytes memory bytesArray = new bytes(i);\r\n\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n\r\n            bytesArray[i] = _bytes32[i];\r\n\r\n        }\r\n\r\n        return string(bytesArray);\r\n\r\n    }\r\n\r\n    //function to convert strings into bytes32 code\r\n    \r\n    function stringToBytes32(string memory source)\r\n\r\n    public\r\n\r\n    view\r\n\r\n    onlyMembers(msg.sender)\r\n\r\n    returns (bytes32 result) {\r\n\r\n    bytes memory tempEmptyStringTest = bytes(source);\r\n\r\n    if (tempEmptyStringTest.length == 0) {\r\n\r\n        return 0x0;\r\n\r\n    }\r\n\r\n\r\n\r\n    assembly {\r\n\r\n        result := mload(add(source, 32))\r\n\r\n    }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * Whitelist a Founder Developer ceva only\r\n\r\n     */\r\n\r\n    function cevaWhitelistFounderDeveloper(address _identifier, bool _status)\r\n\r\n        public\r\n\r\n        onlyCEVA(msg.sender)\r\n\r\n    {\r\n\r\n            founderdevelopers_[_identifier] = _status;\r\n\r\n            numberofburnrequestswhitelisted_[_identifier] = 0;\r\n\r\n            numberofpropertieswhitelisted_[_identifier] = 0;\r\n\r\n            numberofmintingrequestswhitelisted_[_identifier] = 0;\r\n\r\n            emit FounderDeveloperWhitelisted(msg.sender, _identifier, _status);\r\n\r\n    }\r\n\r\n    //check the property id of an address used on ceva/founder developer\r\n    \r\n    function checkPropertyIDOf(address _user)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bytes32)\r\n\r\n    {\r\n\r\n        return workingPropertyid_[_user];\r\n\r\n    }\r\n    \r\n    //check the available avec you can acquire on a specific property using onus\r\n    \r\n    function checkAvailableAVEC(bytes32 _propertyUniqueID)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        uint256 _availableAVEC = propertyGlobalBalance_[_propertyUniqueID];\r\n        \r\n        return _availableAVEC;\r\n\r\n    }\r\n    \r\n    //check ceva addresses current burn request id\r\n    \r\n    function checkBurnRequestIDOf(address _user)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bytes32)\r\n\r\n    {\r\n\r\n        return workingBurnRequestid_[_user];\r\n\r\n    }\r\n    \r\n    //check the mint id of a founder developer\r\n\r\n    function checkMintIDOf(address _user)\r\n\r\n        public\r\n\r\n        view\r\n\r\n        returns(bytes32)\r\n\r\n    {\r\n\r\n        return workingMintRequestid_[_user];\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * whitelist a member founder developer only\r\n\r\n     */\r\n\r\n    function founderDeveloperWhitelistMember(address _identifier, bool _status)\r\n\r\n        public\r\n\r\n        onlyFounderDevelopers(msg.sender)\r\n\r\n    {\r\n\r\n        require(msg.sender != _identifier);\r\n\r\n            members_[_identifier] = _status;\r\n\r\n            emit MemberWhitelisted(msg.sender, _identifier, _status);\r\n\r\n    }\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n\r\n    /**\r\n\r\n     * Retrieve the tokens owned by the caller without 18 zeros of decimal.\r\n\r\n     */\r\n\r\n    function tokensNoDecimals()\r\n\r\n        view\r\n\r\n        public\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        address _customerAddress = msg.sender;\r\n\r\n        uint256 _tokens =  (balanceOf(_customerAddress) / 1e18);\r\n\r\n        if(_tokens >= 1){\r\n\r\n            return _tokens;\r\n\r\n        } else {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n    }\r\n    \r\n    //retrieve the balance of a specific address this balance is the total\r\n    //combined value of all property balance ledgers onus tokens and omni tokens\r\n\r\n    function balanceOf(address _owner)\r\n\r\n        view\r\n\r\n        public\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        return tokenBalanceLedger_[_owner];\r\n\r\n    }\r\n\r\n    //check the property balance of a specific wallet and property pair using wallet address and property unique id\r\n    \r\n    function checkPropertyBalanceOf(address _wallet, bytes32 _propertyUniqueID)\r\n\r\n        view\r\n\r\n        public\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        return propertyBalanceLedger_[_propertyUniqueID][_wallet];\r\n\r\n    }\r\n    \r\n    //check the dividends still not withdrawn by a specific wallet using the \r\n    //wallet address and evelope number of the envelope you are currently auditing\r\n\r\n    function checkDividendsOf(address _customerAddress, uint8 _envelopeNumber)\r\n\r\n        view\r\n\r\n        public\r\n\r\n        returns(uint256)\r\n\r\n    {\r\n\r\n        if(_envelopeNumber == 1){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / taxesfeeTotalHolds_;\r\n\r\n            uint256 _taxesSharehold \r\n            = taxesFeeSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = ((_dividendPershare * _taxesSharehold) -\r\n\r\n            (taxesFeeTotalWithdrawn_[_customerAddress] + taxesPreviousWithdrawn_[_customerAddress])) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 2){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / insurancefeeTotalHolds_;\r\n\r\n            uint256 _insuranceSharehold \r\n            = insuranceFeeSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_insuranceSharehold + 0)) -\r\n\r\n            ((insuranceFeeTotalWithdrawn_[_customerAddress] + 0) + (insurancePreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 3){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / maintencancefeeTotalHolds_;\r\n\r\n            uint256 _maintenanceSharehold \r\n            = maintenanceFeeSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_maintenanceSharehold + 0)) -\r\n\r\n            ((maintenanceFeeTotalWithdrawn_[_customerAddress] + 0) + (maintenancePreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 4){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / waECOfeeTotalHolds_;\r\n\r\n            uint256 _waECOSharehold \r\n            = waECOFeeSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_waECOSharehold + 0)) -\r\n\r\n            ((waECOFeeTotalWithdrawn_[_customerAddress] + 0) + (waECOPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 5){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / holdonefeeTotalHolds_;\r\n\r\n            uint256 _holdOneSharehold \r\n            = holdoneSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare) * (_holdOneSharehold)) -\r\n\r\n            ((holdoneTotalWithdrawn_[_customerAddress]) + (holdonePreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 6){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / holdtwofeeTotalHolds_;\r\n\r\n            uint256 _holdtwoSharehold \r\n            = holdtwoSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_holdtwoSharehold + 0)) -\r\n\r\n            ((holdtwoTotalWithdrawn_[_customerAddress] + 0) + (holdtwoPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 7){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / holdthreefeeTotalHolds_;\r\n\r\n            uint256 _holdthreeSharehold \r\n            = holdthreeSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_holdthreeSharehold + 0)) -\r\n\r\n            ((holdthreeTotalWithdrawn_[_customerAddress] + 0) + (holdthreePreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 8){\r\n\r\n            uint256 _dividendPershare = ((globalFeeLedger_ / 2) / 8) / rewardsfeeTotalHolds_;\r\n\r\n            uint256 _rewardsSharehold = rewardsSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate =  (((_dividendPershare + 0) * (_rewardsSharehold + 0)) -\r\n\r\n            ((rewardsTotalWithdrawn_[_customerAddress] + 0) + (rewardsPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 9){\r\n\r\n            uint256 _dividendPershare \r\n            = (((globalFeeLedger_ / 2) / 5) * 2) / techfeeTotalHolds_;\r\n\r\n            uint256 _techSharehold \r\n            = techSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_techSharehold + 0)) -\r\n\r\n            ((techTotalWithdrawn_[_customerAddress] + 0) + (techPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 10){\r\n\r\n            uint256 _dividendPershare = (((globalFeeLedger_ / 2) / 5) + (globalFeeLedger_ / 40)) / existholdingsfeeTotalHolds_;\r\n\r\n            uint256 _existholdingsSharehold = existholdingsSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate =  (((_dividendPershare + 0) * (_existholdingsSharehold + 0)) -\r\n\r\n            ((existholdingsTotalWithdrawn_[_customerAddress] + 0) + (existholdingsPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 11){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / existcryptofeeTotalHolds_;\r\n\r\n            uint256 _existcryptoSharehold \r\n            = existcryptoSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_existcryptoSharehold + 0)) -\r\n\r\n            ((existcryptoTotalWithdrawn_[_customerAddress] + 0) + (existcryptoPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 12){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / whoafeeTotalHolds_;\r\n\r\n            uint256 _whoaSharehold \r\n            = whoaSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_whoaSharehold + 0)) -\r\n\r\n            ((whoaTotalWithdrawn_[_customerAddress] + 0) + (whoaPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else if(_envelopeNumber == 13){\r\n\r\n            uint256 _dividendPershare \r\n            = ((globalFeeLedger_ / 2) / 8) / credibleyoufeeTotalHolds_;\r\n\r\n            uint256 _credibleyouSharehold \r\n            = credibleyouSharehold_[_customerAddress];\r\n\r\n            uint256 _pCalculate \r\n            = (((_dividendPershare + 0) * (_credibleyouSharehold + 0)) -\r\n\r\n            ((credibleyouTotalWithdrawn_[_customerAddress] + 0) + (credibleyouPreviousWithdrawn_[_customerAddress] + 0))) /\r\n\r\n            ((mintingDepositsOf_[_customerAddress] + 1) / (amountCirculated_[_customerAddress] + 1));\r\n\r\n            return _pCalculate;\r\n\r\n        } else {\r\n\r\n            return 0;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n\r\n     * check the sharehold an address has of a specific hold envelope\r\n\r\n     */\r\n\r\n    function checkShareHoldOf(address _customerAddress, uint8 _envelopeNumber)\r\n\r\n        view\r\n\r\n        public\r\n\r\n        returns(uint256, uint8)\r\n\r\n    {\r\n\r\n\r\n\r\n        if(_envelopeNumber == 1){\r\n\r\n            return (taxesFeeSharehold_[_customerAddress], 1);\r\n\r\n        } else if(_envelopeNumber == 2){\r\n\r\n            return (insuranceFeeSharehold_[_customerAddress], 2);\r\n\r\n        } else if(_envelopeNumber == 3){\r\n\r\n            return (maintenanceFeeSharehold_[_customerAddress], 3);\r\n\r\n        } else if(_envelopeNumber == 4){\r\n\r\n            return (waECOFeeSharehold_[_customerAddress], 4);\r\n\r\n        } else if(_envelopeNumber == 5){\r\n\r\n            return (holdoneSharehold_[_customerAddress], 5);\r\n\r\n        } else if(_envelopeNumber == 6){\r\n\r\n            return (holdtwoSharehold_[_customerAddress], 6);\r\n\r\n        } else if(_envelopeNumber == 7){\r\n\r\n            return (holdthreeSharehold_[_customerAddress], 7);\r\n\r\n        } else if(_envelopeNumber == 8){\r\n\r\n            return (rewardsSharehold_[_customerAddress], 8);\r\n\r\n        } else if(_envelopeNumber == 9){\r\n\r\n            return (techSharehold_[_customerAddress], 9);\r\n\r\n        } else if(_envelopeNumber == 10){\r\n\r\n            return (existholdingsSharehold_[_customerAddress], 10);\r\n\r\n        } else if(_envelopeNumber == 11){\r\n\r\n            return (existcryptoSharehold_[_customerAddress], 11);\r\n\r\n        } else if(_envelopeNumber == 12){\r\n\r\n            return (whoaSharehold_[_customerAddress], 12);\r\n\r\n        } else if(_envelopeNumber == 13){\r\n\r\n            return (credibleyouSharehold_[_customerAddress], 13);\r\n\r\n        } else {\r\n\r\n            return (0, 0);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /*==========================================\r\n\r\n    =            INTERNAL FUNCTIONS            =\r\n\r\n    ==========================================*/\r\n\r\n    /**\r\n\r\n     * Update totals holds of all envelopes and total supply of all enevelopes.\r\n\r\n     */\r\n\r\n    function updateHoldsandSupply(uint256 _amountOfTokens)\r\n\r\n        internal\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        totalSupply \r\n        = totalSupply + _amountOfTokens;\r\n\r\n        taxesfeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + taxesfeeTotalHolds_;\r\n\r\n        insurancefeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + insurancefeeTotalHolds_;\r\n\r\n        maintencancefeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + maintencancefeeTotalHolds_;\r\n\r\n        waECOfeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + waECOfeeTotalHolds_;\r\n\r\n        holdonefeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + holdonefeeTotalHolds_;\r\n\r\n        holdtwofeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + holdtwofeeTotalHolds_;\r\n\r\n        holdthreefeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + holdthreefeeTotalHolds_;\r\n\r\n        rewardsfeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + rewardsfeeTotalHolds_;\r\n\r\n        techfeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + techfeeTotalHolds_;\r\n\r\n        existholdingsfeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + existholdingsfeeTotalHolds_;\r\n\r\n        existcryptofeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + existcryptofeeTotalHolds_;\r\n\r\n        whoafeeTotalHolds_ \r\n        = (_amountOfTokens / 1e18) + whoafeeTotalHolds_;\r\n\r\n        credibleyoufeeTotalHolds_\r\n        = (_amountOfTokens / 1e18) + credibleyoufeeTotalHolds_;\r\n\r\n        feeTotalHolds_ \r\n        = ((_amountOfTokens / 1e18)* 13) + feeTotalHolds_;\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    //adds tokens to the global fee ledger for distribution betweens envelope hold shareholders\r\n    \r\n    function updateEquityRents(uint256 _amountOfTokens)\r\n\r\n        internal\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        if(_amountOfTokens > 0){\r\n\r\n            globalFeeLedger_ \r\n            = globalFeeLedger_ + (_amountOfTokens / 50);\r\n\r\n            return true;\r\n\r\n        } else {\r\n\r\n            _amountOfTokens = 0;\r\n\r\n            return false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //credits envelope hold shareholds to respective envelope chosen during minting process\r\n    \r\n    function creditFeeSharehold(uint256 _amountOfTokens, address _owner, address _toAddress, address _toAddresstwo, address _toAddressthree)\r\n\r\n        internal\r\n\r\n        returns(bool)\r\n\r\n    {\r\n\r\n        taxesFeeSharehold_[_owner] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        insuranceFeeSharehold_[_owner] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        maintenanceFeeSharehold_[whoamaintenanceaddress_] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        waECOFeeSharehold_[_owner] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        holdoneSharehold_[_toAddress] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        holdtwoSharehold_[_toAddresstwo] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        holdthreeSharehold_[_toAddressthree] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        rewardsSharehold_[whoarewardsaddress_] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        techSharehold_[techaddress_] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        existholdingsSharehold_[existholdingsaddress_] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        existcryptoSharehold_[existcryptoaddress_] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        whoaSharehold_[whoaaddress_]\r\n        += _amountOfTokens / 1e18;\r\n\r\n        credibleyouSharehold_[credibleyouaddress_] \r\n        += _amountOfTokens / 1e18;\r\n\r\n        return true;\r\n\r\n    }\r\n}"
    }
  }
}