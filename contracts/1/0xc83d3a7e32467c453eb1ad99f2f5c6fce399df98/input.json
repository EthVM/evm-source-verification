{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/PickleJar.sol": {
      "content": "\n// File: contracts/interfaces/IUniswapV2ERC20.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface IUniswapV2ERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// File: contracts/interfaces/IUniswapV2Pair.sol\n\npragma solidity ^0.6.12;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n}\n\n// File: contracts/interfaces/IUniswapV2Router2.sol\n\npragma solidity ^0.6.12;\n\ninterface IUniswapV2Router2 {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function WETH() external pure returns (address);\n}\n\n// File: contracts/PickleJar.sol\n\npragma solidity ^0.6.12;\n\n\n\n\n// PickleJAR contract helps you swap your UNIV2 LP tokens around,\n// using uniswap's permit functionality, so only 1 tx is needed\n// e.g. from ETH/USDC LP tokens to ETH/USDT LP tokens\ncontract PickleJar {\n    IUniswapV2Router2 router = IUniswapV2Router2(\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    );\n\n    function convertWETHPair(\n        address fromLP,\n        address toLP,\n        uint256 value\n    ) public {\n        IUniswapV2Pair fromPair = IUniswapV2Pair(fromLP);\n        IUniswapV2Pair toPair = IUniswapV2Pair(toLP);\n\n        address weth = router.WETH();\n\n        // Only for WETH/<TOKEN> pairs\n        if (!(fromPair.token0() == weth || fromPair.token1() == weth)) {\n            revert(\"!eth-from\");\n        }\n        if (!(toPair.token0() == weth || toPair.token1() == weth)) {\n            revert(\"!eth-to\");\n        }\n\n        // Get non-eth token from pairs\n        address _from = fromPair.token0() != weth\n            ? fromPair.token0()\n            : fromPair.token1();\n\n        address _to = toPair.token0() != weth\n            ? toPair.token0()\n            : toPair.token1();\n\n        // Transfer\n        IUniswapV2ERC20(fromLP).transferFrom(msg.sender, address(this), value);\n\n        // Remove liquidity\n        IUniswapV2ERC20(fromLP).approve(address(router), value);\n        router.removeLiquidity(\n            fromPair.token0(),\n            fromPair.token1(),\n            value,\n            0,\n            0,\n            address(this),\n            now + 60\n        );\n\n        // Convert to target token\n        address[] memory path = new address[](3);\n        path[0] = _from;\n        path[1] = weth;\n        path[2] = _to;\n        IUniswapV2ERC20(_from).approve(address(router), uint256(-1));\n        router.swapExactTokensForTokens(\n            IUniswapV2ERC20(_from).balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            now + 60\n        );\n\n        // Supply liquidity\n        IUniswapV2ERC20(weth).approve(address(router), uint256(-1));\n        IUniswapV2ERC20(_to).approve(address(router), uint256(-1));\n        router.addLiquidity(\n            weth,\n            _to,\n            IUniswapV2ERC20(weth).balanceOf(address(this)),\n            IUniswapV2ERC20(_to).balanceOf(address(this)),\n            0,\n            0,\n            msg.sender,\n            now + 60\n        );\n\n        // Refund sender any remaining tokens\n        IUniswapV2ERC20(weth).transfer(\n            msg.sender,\n            IUniswapV2ERC20(weth).balanceOf(address(this))\n        );\n        IUniswapV2ERC20(_to).transfer(\n            msg.sender,\n            IUniswapV2ERC20(_to).balanceOf(address(this))\n        );\n    }\n\n    function convertWETHPairWithPermit(\n        address fromLP,\n        address toLP,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        // Permit\n        IUniswapV2ERC20(fromLP).permit(\n            msg.sender,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        convertWETHPair(fromLP, toLP, value);\n    }\n}\n"
    }
  }
}