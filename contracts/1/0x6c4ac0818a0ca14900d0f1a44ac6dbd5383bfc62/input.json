{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DutchSwapAuction.sol": {
      "content": "pragma solidity ^0.6.9;\r\n\r\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n//::::::::::: @#::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\r\n//::::::::::: ##::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\r\n//::::::::::: ##::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\r\n//::::: ########: ##:: ##:: DUTCh>: ihD%y: #@Whdqy:::::::::::::::::::::\r\n//::: ###... ###: ##:: ##:: @B... @@7...t: N@N.. R@K:::::::::::::::::::\r\n//::: ##::::: ##: ##:: ##:: @Q::: @Q.::::: N@j:: z@Q:::::::::::::::::::\r\n//:::: ##DuTCH##: .@QQ@@#:: hQQQh <R@QN@Q: N@j:: z@Q:::::::::::::::::::\r\n//::::::.......: =Q@y....:::....:::......::...:::...:::::::::::::::::::\r\n//:::::::::::::: h@W? sWAP@! 'DW;:::::: KK. ydSWAP@t: NNKNQBdt:::::::::\r\n//:::::::::::::: 'zqRqj*. L@R h@w: QQ: L@5 Q@... d@@: @@U... @Q::::::::\r\n//:::::::::::::::::...... Q@^ ^@@N@wt@BQ@ <@Q^::: @@: @@}::: @@:::::::: \r\n//:::::::::::::::::: U@@QKt... D@@L.. B@Q.. KDUTCH@Q: @@QQ#QQq:::::::::\r\n//:::::::::::::::::::.....::::::...:::...::::.......: @@!.....:::::::::\r\n//::::::::::::::::::::::::::::::::::::::::::::::::::: @@!::::::::::::::\r\n//::::::::::::::::::::::::::::::::::::::::::::::::::: @@!::::::::::::::\r\n//::::::::::::::01101100:01101111:01101111:01101011::::::::::::::::::::\r\n//:::::01100100:01100101:01100101:01110000:01111001:01110010:::::::::::\r\n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\r\n//\r\n// DutchSwap Auction V1.3.1\r\n//   Copyright (c) 2020 DutchSwap.com\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  \r\n// If not, see <https://github.com/deepyr/DutchSwap/>.\r\n//\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n//\r\n// Authors:\r\n// * Adrian Guerrera / Deepyr Pty Ltd\r\n//\r\n// ---------------------------------------------------------------------\r\n// SPDX-License-Identifier: GPL-3.0-or-later                        \r\n// ---------------------------------------------------------------------\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * See: https://github.com/OpenZeppelin/openzeppelin-contracts\r\n */\r\nlibrary SafeMathPlus {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a <= b ? a : b;\r\n    }\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n\r\ncontract DutchSwapAuction  {\r\n\r\n    using SafeMathPlus for uint256;\r\n    /// @dev The placeholder ETH address.\r\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    uint256 public startDate;\r\n    uint256 public endDate;\r\n    uint256 public startPrice;\r\n    uint256 public minimumPrice;\r\n    uint256 public totalTokens;  // Amount to be sold\r\n    uint256 public priceDrop; // Price reduction from startPrice at endDate\r\n    uint256 public commitmentsTotal;\r\n    uint256 public tokenWithdrawn;  // the amount of auction tokens already withdrawn\r\n    bool private initialised;    \r\n    bool public finalised;\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    address public auctionToken;\r\n    address public paymentCurrency;\r\n    address payable public wallet;  // Where the auction funds will get paid\r\n    mapping(address => uint256) public commitments;\r\n    mapping(address => uint256) public claimed;\r\n\r\n    event AddedCommitment(address addr, uint256 commitment, uint256 price);\r\n\r\n\r\n    /// @dev Prevents a contract from calling itself, directly or indirectly.\r\n    /// @dev https://eips.ethereum.org/EIPS/eip-2200)\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED);          // ReentrancyGuard: reentrant call\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /// @dev Init function\r\n    function initDutchAuction(\r\n        address _funder,\r\n        address _token,\r\n        uint256 _totalTokens,\r\n        uint256 _startDate,\r\n        uint256 _endDate,\r\n        address _paymentCurrency,\r\n        uint256 _startPrice,\r\n        uint256 _minimumPrice,\r\n        address payable _wallet\r\n    )\r\n        external\r\n    {\r\n        require(!initialised);                // Already Initialised\r\n        require(_endDate > _startDate);       // End date earlier than start date\r\n        require(_minimumPrice > 0);           // Minimum price must be greater than 0\r\n        \r\n        auctionToken = _token;\r\n        paymentCurrency = _paymentCurrency;\r\n\r\n        totalTokens = _totalTokens;\r\n        startDate = _startDate;\r\n        endDate = _endDate;\r\n        startPrice = _startPrice;\r\n        minimumPrice = _minimumPrice;\r\n        wallet = _wallet;\r\n        _status = _NOT_ENTERED;\r\n\r\n        uint256 numerator = startPrice.sub(minimumPrice);\r\n        uint256 denominator = endDate.sub(startDate);\r\n        priceDrop = numerator.div(denominator);\r\n\r\n        // There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\r\n        _safeTransferFrom(auctionToken, _funder, _totalTokens);\r\n        initialised = true;\r\n\r\n    }\r\n\r\n    // Dutch Auction Price Function\r\n    // ============================\r\n    //\r\n    // Start Price -----\r\n    //                   \\\r\n    //                    \\\r\n    //                     \\\r\n    //                      \\ ------------ Clearing Price\r\n    //                     / \\            = AmountRaised/TokenSupply\r\n    //      Token Price  --   \\\r\n    //                  /      \\\r\n    //                --        ----------- Minimum Price\r\n    // Amount raised /          End Time\r\n    //\r\n\r\n\r\n\r\n    /// @notice The average price of each token from all commitments. \r\n    function tokenPrice() public view returns (uint256) {\r\n        return commitmentsTotal.mul(1e18).div(totalTokens);\r\n    }\r\n\r\n      /// @notice Returns price during the auction \r\n    function priceFunction() public view returns (uint256) {\r\n        /// @dev Return Auction Price\r\n        if (block.timestamp <= startDate) {\r\n            return startPrice;\r\n        }\r\n        if (block.timestamp >= endDate) {\r\n            return minimumPrice;\r\n        }\r\n         return _currentPrice();\r\n    }\r\n\r\n    /// @notice The current clearing price of the Dutch auction\r\n    function clearingPrice() public view returns (uint256) {\r\n        /// @dev If auction successful, return tokenPrice\r\n        if (tokenPrice() > priceFunction()) {\r\n            return tokenPrice();\r\n        }\r\n        return priceFunction();\r\n    }\r\n\r\n    /// @notice How many tokens the user is able to claim\r\n    function tokensClaimable(address _user) public view returns (uint256) {\r\n        uint256 tokensAvailable = commitments[_user].mul(1e18).div(clearingPrice());\r\n        return tokensAvailable.sub(claimed[msg.sender]);\r\n    }\r\n\r\n    /// @notice Total amount of tokens committed at current auction priceâ€“\r\n    function totalTokensCommitted() public view returns(uint256) {\r\n        return commitmentsTotal.mul(1e18).div(clearingPrice());\r\n    }\r\n\r\n    /// @notice Total amount of tokens remaining \r\n    function tokensRemaining() public view returns (uint256) {\r\n        uint256 totalCommitted = totalTokensCommitted();\r\n        if (totalCommitted >= totalTokens ) {\r\n            return 0;\r\n        } else {\r\n            return totalTokens.sub(totalCommitted);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns price during the auction\r\n    function _currentPrice() private view returns (uint256) {\r\n        uint256 elapsed = block.timestamp.sub(startDate);\r\n        uint256 priceDiff = elapsed.mul(priceDrop);\r\n        return startPrice.sub(priceDiff);\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // Commit to buying tokens! \r\n    //--------------------------------------------------------\r\n\r\n    /// @notice Buy Tokens by committing ETH to this contract address \r\n    /// @dev Needs extra gas limit for additional state changes\r\n    receive () external payable {\r\n        commitEthFrom(msg.sender);\r\n    }\r\n\r\n    /// @dev Needs extra gas limit for additional state changes\r\n    function commitEth() public payable {\r\n        commitEthFrom(msg.sender);\r\n    }\r\n\r\n    /// @notice Commit ETH to buy tokens for any address \r\n    function commitEthFrom (address payable _from) public payable {\r\n        require(!finalised);                                  // Auction was cancelled\r\n        require(address(paymentCurrency) == ETH_ADDRESS);       // Payment currency is not ETH\r\n        // Get ETH able to be committed\r\n        uint256 ethToTransfer = calculateCommitment( msg.value);\r\n\r\n        // Accept ETH Payments\r\n        uint256 ethToRefund = msg.value.sub(ethToTransfer);\r\n        if (ethToTransfer > 0) {\r\n            _addCommitment(_from, ethToTransfer);\r\n        }\r\n        // Return any ETH to be refunded\r\n        if (ethToRefund > 0) {\r\n            _from.transfer(ethToRefund);\r\n        }\r\n    }\r\n\r\n    /// @notice Commit approved ERC20 tokens to buy tokens on sale\r\n    function commitTokens(uint256 _amount) public {\r\n        commitTokensFrom(msg.sender, _amount);\r\n    }\r\n\r\n    /// @dev Users must approve contract prior to committing tokens to auction\r\n    function commitTokensFrom(address _from, uint256 _amount) public nonReentrant {\r\n        require(!finalised);                                  // Auction was cancelled\r\n        require(address(paymentCurrency) != ETH_ADDRESS);          // Only token transfers\r\n        uint256 tokensToTransfer = calculateCommitment( _amount);\r\n        if (tokensToTransfer > 0) {\r\n            _safeTransferFrom(paymentCurrency, _from, tokensToTransfer);\r\n            _addCommitment(_from, tokensToTransfer);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the amout able to be committed during an auction\r\n    function calculateCommitment( uint256 _commitment) \r\n        public view returns (uint256 committed) \r\n    {\r\n        uint256 maxCommitment = totalTokens.mul(clearingPrice()).div(1e18);\r\n        if (commitmentsTotal.add(_commitment) > maxCommitment) {\r\n            return maxCommitment.sub(commitmentsTotal);\r\n        }\r\n        return _commitment;\r\n    }\r\n\r\n    /// @notice Commits to an amount during an auction\r\n    function _addCommitment(address _addr,  uint256 _commitment) internal {\r\n        require(block.timestamp >= startDate && block.timestamp <= endDate);  // Outside auction hours\r\n        commitments[_addr] = commitments[_addr].add(_commitment);\r\n        commitmentsTotal = commitmentsTotal.add(_commitment);\r\n        emit AddedCommitment(_addr, _commitment, _currentPrice());\r\n\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // Finalise Auction\r\n    //--------------------------------------------------------\r\n\r\n    /// @notice Successful if tokens sold equals totalTokens\r\n    function auctionSuccessful() public view returns (bool){\r\n        return tokenPrice() >= clearingPrice();\r\n    }\r\n\r\n    /// @notice Returns bool if successful or time has ended\r\n    /// @dev able to claim early if auction is successful\r\n    function auctionEnded() public view returns (bool){\r\n        return auctionSuccessful() || block.timestamp > endDate;\r\n    }\r\n\r\n    /// @notice Auction finishes successfully above the reserve\r\n    /// @dev Transfer contract funds to initialised wallet. \r\n    function finaliseAuction () public nonReentrant {\r\n        require(!finalised);                                  // Auction already finalised\r\n        if( auctionSuccessful() ) \r\n        {\r\n            /// @dev Successful auction\r\n            /// @dev Transfer contributed tokens to wallet.\r\n            _tokenPayment(paymentCurrency, wallet, commitmentsTotal);\r\n        }\r\n        else if ( commitmentsTotal == 0 && block.timestamp < startDate )\r\n        {\r\n            /// @dev Cancelled Auction\r\n            /// @dev You can cancel the auction before it starts\r\n            _tokenPayment(auctionToken, wallet, totalTokens);\r\n        }\r\n        else\r\n        {\r\n            /// @dev Failed auction\r\n            /// @dev Return auction tokens back to wallet.\r\n            require(block.timestamp > endDate, \"Auction not finished yet\" );    \r\n            _tokenPayment(auctionToken, wallet, totalTokens);\r\n        }\r\n        finalised = true;\r\n    }\r\n\r\n    /// @notice Withdraw your tokens once the Auction has ended.\r\n    function withdrawTokens() public nonReentrant {\r\n        if( auctionSuccessful() ) \r\n        {\r\n            /// @dev Successful auction! Transfer claimed tokens.\r\n            uint256 tokensToClaim = tokensClaimable(msg.sender);\r\n            require(tokensToClaim > 0, \"No tokens to claim\");      \r\n            claimed[ msg.sender] = claimed[ msg.sender].add(tokensToClaim);\r\n            tokenWithdrawn = tokenWithdrawn.add(tokensToClaim);\r\n            _tokenPayment(auctionToken, msg.sender, tokensToClaim);\r\n        }\r\n        else \r\n        {\r\n            /// @dev Auction did not meet reserve price.\r\n            /// @dev Return committed funds back to user.\r\n            require(block.timestamp > endDate);               // Auction not yet finished\r\n            uint256 fundsCommitted = commitments[ msg.sender];\r\n            require(fundsCommitted > 0);                      // No funds committed\r\n\r\n            commitments[msg.sender] = 0;     // Stop multiple withdrawals and free some gas\r\n            _tokenPayment(paymentCurrency, msg.sender, fundsCommitted);       \r\n        }\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // Helper Functions\r\n    //--------------------------------------------------------\r\n\r\n    // There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\r\n    // I'm trying to make it a habit to put external calls last (reentrancy)\r\n    // You can put this in an internal function if you like.\r\n    function _safeTransfer(address token, address to, uint256 amount) internal {\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success, bytes memory data) = token.call(\r\n            // 0xa9059cbb = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\r\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\r\n        );\r\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed \r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, uint256 amount) internal {\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        (bool success, bytes memory data) = token.call(\r\n            // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\r\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\r\n        );\r\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed \r\n    }\r\n\r\n    /// @dev Helper function to handle both ETH and ERC20 payments\r\n    function _tokenPayment(address _token, address payable _to, uint256 _amount) internal {\r\n        if (address(_token) == ETH_ADDRESS) {\r\n            uint256 ethBal = address(this).balance;\r\n            if (_amount > ethBal) {\r\n                _to.transfer(ethBal);\r\n            } else {\r\n                _to.transfer(_amount);\r\n            }\r\n        } else {\r\n            uint256 tokenBal = IERC20(_token).balanceOf(address(this));\r\n            if (_amount > tokenBal) {\r\n                _safeTransfer(_token, _to, tokenBal);\r\n            } else {\r\n                _safeTransfer(_token, _to, _amount);\r\n            }\r\n        }\r\n    }\r\n}"
    }
  }
}