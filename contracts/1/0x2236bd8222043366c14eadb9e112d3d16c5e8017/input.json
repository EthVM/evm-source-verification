{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PreSale.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n//openzeppelin-contracts/contracts/access/roles\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    \r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\n// File: contracts\\open-zeppelin-contracts\\math\\SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n\r\n    constructor () internal { }\r\n   \r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title WhitelistedRole\r\n * @dev Whitelisted accounts have been approved by a onlyOwner to perform certain actions (e.g. participate in a\r\n * crowdsale). This role is special in that the only accounts that can add it are onlyOwner (who can also remove\r\n * it).\r\n */\r\ncontract WhitelistedRole is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistedAdded(address indexed account);\r\n    event WhitelistedRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelisteds;\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isWhitelisted(address account) public view returns (bool) {\r\n        return _whitelisteds.has(account);\r\n    }\r\n\r\n    function addWhitelisted(address account) public onlyOwner {\r\n        _addWhitelisted(account);\r\n    }\r\n\r\n    function removeWhitelisted(address account) public onlyOwner {\r\n        _removeWhitelisted(account);\r\n    }\r\n\r\n    function _addWhitelisted(address account) internal {\r\n        _whitelisteds.add(account);\r\n        emit WhitelistedAdded(account);\r\n    }\r\n\r\n    function _removeWhitelisted(address account) internal {\r\n        _whitelisteds.remove(account);\r\n        emit WhitelistedRemoved(account);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title PreSale\r\n * @dev Presale contract accept ether from whitelsted address. there are certain condition must be required to fulfill.\r\n * Private Sale target set 30 ETH \r\n */\r\ncontract PreSale is WhitelistedRole {\r\n\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) public investors;\r\n    address payable investorWallet;\r\n    uint256 public collectedEther;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _investorWallet address able to withdraw investment\r\n     */\r\n    constructor(address payable _investorWallet) public payable {\r\n        investorWallet = _investorWallet;\r\n        \r\n        // <!-- Whitelisted wallet -->\r\n        _addWhitelisted(0xD8b3b1b185c9A278BD20265c846a5F4c1010CD0f);\r\n        _addWhitelisted(0x2d55748cE1b792d1Ba65f42AFcF189fdc386BBcF);\r\n        _addWhitelisted(0xEF9EFf0479d57032cda12e0d6bBEDb55B9b8c9E7);\r\n        _addWhitelisted(0xdF55AcD44102FA7dd9C1b7f95ADC2eDB1129B8d8);\r\n        _addWhitelisted(0xBfe663805129915942980bC86BD832aB031Bb2f9);\r\n        _addWhitelisted(0x5fd8Eb9B9958E88698fa64F0e4a418f6C9C563e2);\r\n        _addWhitelisted(0xcC174625b93437098591C6B1d3b526F730cb6346);\r\n        _addWhitelisted(0xc221f41c08656E9Fd49141306a9365FF8702b8A5);\r\n        _addWhitelisted(0x1C5f7635a4A302d72E652486907051f84cd55005);\r\n        _addWhitelisted(0x0E49d6eC5E22daA59bC845B3353D81E59A45eE0d);\r\n        _addWhitelisted(0xEf92D1638b63dd82BD744fFfb96f9d46B0eEc50E);\r\n        _addWhitelisted(0xA50341f5e72eD061cD0adbD338cbF070DC45784C);\r\n        _addWhitelisted(0x29Bf6652e795C360f7605be0FcD8b8e4F29a52d4);\r\n        _addWhitelisted(0xdb820EdEe02c9ee0D9a95910AF34031f17989660);\r\n        _addWhitelisted(0xE12D52275eB64FF18680aA2b081Fef8b736CD66d);\r\n        _addWhitelisted(0xAE5d528177A6273dC022ecA11496B89298e4654F);\r\n        _addWhitelisted(0xA59c52b97c2cDcbBe9D5fCB3240233e3868314C1);\r\n        _addWhitelisted(0x7C0Bf6BB2356aAaa60C04072C73a5DBe67dAc25e);\r\n        _addWhitelisted(0x6F1E02F7853a7614F11C1909ED00310713d2E5cf);\r\n        _addWhitelisted(0x1F4a6756Da7592fc0f9a031D127d016ACc0BfcB2);\r\n        _addWhitelisted(0xD8c91ec53E8d236F9a15D6B42e878393bF413515);\r\n        _addWhitelisted(0xfD026dFFfDf66BBecfC9F8bc26caf2A425ea0467);\r\n\r\n    }\r\n\r\n    // It is important to also provide the\r\n    // `payable` keyword here, otherwise the function will\r\n    // automatically reject all Ether sent to it.\r\n    function () payable external onlyWhitelisted {\r\n        require(2 ether <= msg.value &&  msg.value <= 5 ether, \"Ether investment range must be required between 2 to 5 ether.\");\r\n        require(collectedEther <= 30 ether, \"Pre Sale target fulfilled, Unable to accept more funds.\");\r\n        \r\n        investors[_msgSender()] = investors[_msgSender()].add(msg.value);\r\n\r\n        collectedEther = collectedEther.add(msg.value);\r\n    }\r\n    \r\n    // WithDraw ether \r\n    function withDraw() public onlyOwner returns (bool) {\r\n        investorWallet.transfer(collectedEther);\r\n        collectedEther = 0;\r\n        return true;\r\n    }\r\n\r\n}"
    }
  }
}