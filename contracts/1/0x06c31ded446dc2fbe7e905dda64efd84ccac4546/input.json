{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SantaSwapExchange.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.4;\r\n\r\n/// ============ Libraries ============\r\n\r\n/// @notice OpenZeppelin: MerkleProof\r\n/// @dev The hashing algorithm should be keccak256 and pair sorting should be enabled.\r\nlibrary MerkleProof {\r\n  /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree defined by `root`.\r\n  function verify(\r\n    bytes32[] memory proof,\r\n    bytes32 root,\r\n    bytes32 leaf\r\n  ) internal pure returns (bool) {\r\n    return processProof(proof, leaf) == root;\r\n  }\r\n\r\n  /// @dev Returns the rebuilt hash obtained by traversing a Merklee tree up from `leaf` using `proof`.\r\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n    bytes32 computedHash = leaf;\r\n    for (uint256 i = 0; i < proof.length; i++) {\r\n      bytes32 proofElement = proof[i];\r\n      if (computedHash <= proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n    }\r\n    return computedHash;\r\n  }\r\n}\r\n\r\n/// ============ Interfaces ============\r\n\r\ninterface IERC721 {\r\n  /// @notice ERC721 transfer from (from) to (to)\r\n  function transferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\ncontract SantaSwapExchange {\r\n\r\n  /// ============ Structs ============\r\n\r\n  /// @notice Individual ERC721 NFT details\r\n  struct SantaNFT {\r\n    /// @notice NFT contract\r\n    address nftContract;\r\n    /// @notice NFT tokenId\r\n    uint256 tokenId;\r\n  }\r\n\r\n  /// ============ Immutable storage ============\r\n\r\n  /// @notice Timestamp when reclaim is enabled\r\n  uint256 immutable public RECLAIM_OPEN;\r\n\r\n  /// ============ Mutable storage ============\r\n\r\n  /// @notice Contract owner\r\n  address public owner;\r\n  /// @notice Merkle root of santa => giftee\r\n  /// @dev keccak256(giftee, santa, santaNFTIndex)\r\n  bytes32 public merkle;\r\n  /// @notice Helper to iterate nfts for front-en\r\n  /// @dev Keeps santaNFTIndex count\r\n  mapping(address => uint256) public nftCount;\r\n  /// @notice Address to deposited NFTs\r\n  mapping(address => SantaNFT[]) public nfts;\r\n\r\n  // ============ Errors ============\r\n\r\n  /// @notice Thrown if caller is not owner\r\n  error NotOwner();\r\n  /// @notice Thrown if cannot claim NFT\r\n  error NotClaimable();\r\n\r\n  /// ============ Constructor ============\r\n\r\n  constructor() {\r\n    // Update contract owner\r\n    owner = msg.sender;\r\n    // Allow reclaiming 7 days after depositing\r\n    RECLAIM_OPEN = block.timestamp + 604_800;\r\n  }\r\n\r\n  /// @notice Computes leaf of merkle tree by hashing params\r\n  /// @param giftee address receiving NFT gift\r\n  /// @param santa address giving NFT gift\r\n  /// @param santaIndex index of gift (for multiple tickets)\r\n  /// @return hash of leaf\r\n  function _leaf(\r\n    address giftee, \r\n    address santa, \r\n    uint256 santaIndex\r\n  ) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(giftee, santa, santaIndex));\r\n  }\r\n\r\n  /// @notice Verifies that leaf matches provided proof\r\n  /// @param leaf (computed in contract)\r\n  /// @param proof (provided externally)\r\n  /// @return whether santa => giftee matches up\r\n  function _verify(\r\n    bytes32 leaf,\r\n    bytes32[] calldata proof\r\n  ) internal view returns (bool) {\r\n    return MerkleProof.verify(proof, merkle, leaf);\r\n  }\r\n\r\n  /// @notice Allows santas to deposit NFTs to contract\r\n  /// @param nftContract of NFT being deposited\r\n  /// @param tokenId being deposited\r\n  function santaDepositNFT(address nftContract, uint256 tokenId) external {\r\n    // Transfer NFT to contract\r\n    IERC721(nftContract).transferFrom(msg.sender, address(this), tokenId);\r\n    // Mark as deposited by santa\r\n    nftCount[msg.sender]++;\r\n    nfts[msg.sender].push(SantaNFT(nftContract, tokenId));\r\n  }\r\n\r\n  /// @notice Allows giftees to claim NFTs\r\n  /// @param santa who is gifting them\r\n  /// @param santaIndex index of gift in santa's array\r\n  /// @param proof merkle proof of claim\r\n  function gifteeClaimNFT(\r\n    address santa,\r\n    uint256 santaIndex,\r\n    bytes32[] calldata proof\r\n  ) external {\r\n    // Require merkle to be set\r\n    if (merkle == 0) revert NotClaimable();\r\n    // Require giftee to be claiming correct santa NFT\r\n    if (!_verify(_leaf(msg.sender, santa, santaIndex), proof)) revert NotClaimable();\r\n\r\n    // Collect NFT\r\n    SantaNFT memory nft = nfts[santa][santaIndex];\r\n    // Transfer NFT\r\n    IERC721(nft.nftContract).transferFrom(address(this), msg.sender, nft.tokenId);\r\n  }\r\n\r\n  /// @notice ALlows santas to reclaim their NFTs given reclaim period is active\r\n  /// @param index of gift in santa's array (fka: santaIndex)\r\n  function santaReclaimNFT(uint256 index) external {\r\n    // Require reclaim period to be active\r\n    if (block.timestamp < RECLAIM_OPEN) revert NotClaimable();\r\n    // Require provided index to be in range of owned NFTs\r\n    if (index + 1 > nfts[msg.sender].length) revert NotClaimable();\r\n\r\n    // Collect NFT\r\n    SantaNFT memory nft = nfts[msg.sender][index];\r\n    // Transfer unclaimed NFT\r\n    IERC721(nft.nftContract).transferFrom(address(this), msg.sender, nft.tokenId);\r\n  }\r\n\r\n  /// @notice Allows contract owner to withdraw any single NFT\r\n  /// @notice nftContract of NFT to withdraw\r\n  /// @notice tokenId to withdraw\r\n  /// @notice recipient of withdrawn NFT\r\n  function adminWithdrawNFT(\r\n    address nftContract,\r\n    uint256 tokenId,\r\n    address recipient\r\n  ) external {\r\n    // Require caller to be owner\r\n    if (msg.sender != owner) revert NotOwner();\r\n\r\n    IERC721(nftContract).transferFrom(\r\n      // From this contract\r\n      address(this),\r\n      // To provided recipient\r\n      recipient,\r\n      // Transfer specified NFT tokenId\r\n      tokenId\r\n    );\r\n  }\r\n\r\n  /// @notice Allows contract owner to withdraw bulk NFTs\r\n  /// @notice contracts of NFTs to withdraw\r\n  /// @notice tokenIds to withdraw\r\n  /// @notice recipients of withdrawn NFT\r\n  /// @dev Does not check for array length equality\r\n  function adminWithdrawNFTBulk(\r\n    address[] calldata contracts,\r\n    uint256[] calldata tokenIds,\r\n    address[] calldata recipients\r\n  ) external {\r\n    // Require caller to be owner\r\n    if (msg.sender != owner) revert NotOwner();\r\n\r\n    // For each provided contract\r\n    for (uint256 i = 0; i < contracts.length; i++) {\r\n      IERC721(contracts[i]).transferFrom(\r\n        // From contract\r\n        address(this),\r\n        // To provided recipient\r\n        recipients[i],\r\n        // Transfer specified NFT tokenId\r\n        tokenIds[i]\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @notice Allows owner to update merkle\r\n  /// @param merkleRoot to update\r\n  function adminUpdateMerkle(bytes32 merkleRoot) external {\r\n    // Require caller to be owner\r\n    if (msg.sender != owner) revert NotOwner();\r\n    // Update merkle root\r\n    merkle = merkleRoot;\r\n  }\r\n\r\n  /// @notice Allows owner to update new owner\r\n  /// @param newOwner to update\r\n  function adminUpdateOwner(address newOwner) external {\r\n    // Require caller to be owner\r\n    if (msg.sender != owner) revert NotOwner();\r\n    // Update to new owner\r\n    owner = newOwner;\r\n  }\r\n}"}}}