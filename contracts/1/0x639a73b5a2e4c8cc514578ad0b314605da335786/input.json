{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Grail.sol": {
      "content": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/Grail.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface InterfaceRainbows {\r\n    function burn(address user, uint256 amount) external;\r\n}\r\n\r\ncontract Grail is Ownable {\r\n\r\n    struct RaffleEntry {\r\n        address user;\r\n        uint32 count;\r\n    }\r\n\r\n    // Interfaces to interact with the other contracts\r\n    InterfaceRainbows public Rainbows;\r\n\r\n    // address[] public entryList;\r\n    address[] public winnerList;\r\n\r\n    uint256 public raffleEntryCost = 20 ether;\r\n\r\n    // Entry time.\r\n    uint256 public raffleStartTime = 0;\r\n    uint256 public raffleEndTime = 0;\r\n\r\n    RaffleEntry[] public raffleEntries;\r\n    uint256 public totalRaffleEntries;\r\n\r\n    uint256 public uniqueEntryAddresses;\r\n    mapping(address => uint256) public userEntries;\r\n    mapping(address => bool) public winners;\r\n\r\n    event RaffleWinner(address indexed _winner);\r\n\r\n    // Extended access\r\n    mapping(address => bool) public extendedAccess;\r\n\r\n    modifier raffleEnabled() {\r\n        require(raffleStartTime > 0 && block.timestamp > raffleStartTime, \"Raffle not started.\");\r\n        require(raffleEndTime > 0 && block.timestamp <= raffleEndTime, \"Raffle has ended.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromRestricted() {\r\n        require(extendedAccess[msg.sender], \"Your address does not have permission to use.\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        extendedAccess[msg.sender] = true;\r\n    }\r\n\r\n    // Set the address for the contract.\r\n    function setAddressAccess(address _noundles, bool _value) public onlyOwner {\r\n        extendedAccess[_noundles] = _value;\r\n    }\r\n\r\n    // Get the access status for a address.\r\n    function getAddressAccess(address user) external view returns(bool) {\r\n        return extendedAccess[user];\r\n    }\r\n\r\n    // Reset the raffle.\r\n    function resetRaffle() public onlyFromRestricted {\r\n        totalRaffleEntries = 0;\r\n        uniqueEntryAddresses = 0;\r\n        for(uint i; i < raffleEntries.length; i++) {\r\n            address user = raffleEntries[i].user;\r\n            userEntries[user] = 0;\r\n            winners[user] = false;\r\n        }\r\n        delete winnerList;\r\n        delete raffleEntries;\r\n    }\r\n\r\n    function resetWinners() internal {\r\n        for(uint i; i < raffleEntries.length; i++) {\r\n            address user = raffleEntries[i].user;\r\n            winners[user] = false;\r\n        }\r\n        delete winnerList;\r\n    }\r\n\r\n    // Set the time.\r\n    function setRaffleSettings(uint256 _raffleStartTime, uint256 _raffleEndTime, uint256 _raffleEntryCost) public onlyFromRestricted {\r\n        raffleStartTime = _raffleStartTime;\r\n        raffleEndTime   = _raffleEndTime;\r\n        raffleEntryCost = _raffleEntryCost;\r\n    }\r\n\r\n    // Set the address.\r\n    function setAddresses(address _rainbow) external onlyOwner {\r\n        Rainbows = InterfaceRainbows(_rainbow);\r\n    }\r\n\r\n    // Enter the raffle.\r\n    function enterRaffle(uint32 _entryCount) public raffleEnabled {\r\n        Rainbows.burn(msg.sender, raffleEntryCost * _entryCount);\r\n\r\n        raffleEntries.push(RaffleEntry(msg.sender, _entryCount));\r\n        totalRaffleEntries += _entryCount;\r\n\r\n        if(userEntries[msg.sender] == 0) {\r\n            uniqueEntryAddresses += 1;\r\n        }\r\n\r\n        userEntries[msg.sender] += _entryCount;\r\n    }\r\n\r\n    // Pick the winners.\r\n    function pickWinners(uint256 _winnerCount) public onlyFromRestricted {\r\n        require(_winnerCount <= uniqueEntryAddresses, \"Can't have more winners than entries\");\r\n\r\n        // Reset the winners.\r\n        resetWinners();\r\n\r\n        uint256 retryCounter = 0;\r\n\r\n        for(uint256 i = 1; i < (_winnerCount + 1); i += 1) {\r\n\r\n            uint256 pick = getRandomNumber(i + retryCounter) % totalRaffleEntries;\r\n            uint256 runningTotal = 0;\r\n\r\n            for(uint r; r < raffleEntries.length; r += 1) {\r\n\r\n                RaffleEntry storage entry = raffleEntries[r];\r\n\r\n                if(runningTotal <= pick && pick < (runningTotal + entry.count)) {\r\n\r\n                    // If it's already picked.\r\n                    if(winners[entry.user]) {\r\n                        i--;\r\n                        retryCounter += 1;\r\n                        break;\r\n                    }\r\n\r\n                    winners[entry.user] = true;\r\n                    emit RaffleWinner(entry.user);\r\n                    winnerList.push(entry.user);\r\n                    break;\r\n                }\r\n\r\n                // Add to our total.\r\n                runningTotal += entry.count;\r\n            }\r\n        }\r\n    }\r\n\r\n    function pickWinnersView(uint256 _winnerCount) public view returns (address [] memory){\r\n        require(_winnerCount <= uniqueEntryAddresses, \"Can't have more winners than entries\");\r\n\r\n        address[] memory localWinnerList = new address[](_winnerCount);\r\n\r\n        uint256 retryCounter = 0;\r\n\r\n        for(uint256 i = 1; i < (_winnerCount + 1); i += 1) {\r\n\r\n            uint256 pick = getRandomNumber(i + retryCounter) % totalRaffleEntries;\r\n            uint256 runningTotal = 0;\r\n\r\n            for(uint r; r < raffleEntries.length; r += 1) {\r\n                RaffleEntry storage entry = raffleEntries[r];\r\n\r\n                if(runningTotal <= pick && pick < (runningTotal + entry.count)) {\r\n                    localWinnerList[i -1] = entry.user;\r\n                    break;\r\n                }\r\n\r\n                // Add to our total.\r\n                runningTotal += entry.count;\r\n            }\r\n        }\r\n\r\n        return localWinnerList;\r\n    }\r\n\r\n    function getRandomNumber(uint256 _arg) public view returns (uint) {\r\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _arg)));\r\n    }\r\n\r\n    function getEntryCount(address _arg) public view returns (uint256) {\r\n        return userEntries[_arg];\r\n    }\r\n\r\n    function getWinners() public view returns (address[] memory) {\r\n        return winnerList;\r\n    }\r\n\r\n    function checkWinners(address _arg) public view returns (bool) {\r\n        return winners[_arg];\r\n    }\r\n}"
    }
  }
}