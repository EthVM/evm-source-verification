{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BankBTC.sol":{"content":"// SPDX-License-Identifier: Unlicensed\r\n\r\n/**\r\n *  \r\n *  $$$$$$$\\   $$$$$$\\  $$\\   $$\\ $$\\   $$\\       $$$$$$$\\ $$$$$$$$\\  $$$$$$\\  \r\n *  $$  __$$\\ $$  __$$\\ $$$\\  $$ |$$ | $$  |      $$  __$$\\\\__$$  __|$$  __$$\\ \r\n *  $$ |  $$ |$$ /  $$ |$$$$\\ $$ |$$ |$$  /       $$ |  $$ |  $$ |   $$ /  \\__|\r\n *  $$$$$$$\\ |$$$$$$$$ |$$ $$\\$$ |$$$$$  /        $$$$$$$\\ |  $$ |   $$ |      \r\n *  $$  __$$\\ $$  __$$ |$$ \\$$$$ |$$  $$<         $$  __$$\\   $$ |   $$ |      \r\n *  $$ |  $$ |$$ |  $$ |$$ |\\$$$ |$$ |\\$$\\        $$ |  $$ |  $$ |   $$ |  $$\\ \r\n *  $$$$$$$  |$$ |  $$ |$$ | \\$$ |$$ | \\$$\\       $$$$$$$  |  $$ |   \\$$$$$$  |\r\n *  \\_______/ \\__|  \\__|\\__|  \\__|\\__|  \\__|      \\_______/   \\__|    \\______/                                                                            \r\n *                                                                 \r\n *  Bank BTC is the easiest way to earn Bitcoin! Just buy & hold $BankBTC and you’ll get Bitcoin (WBTC) rewards 24×7.\r\n *  \r\n *  10% of every $BankBTC transaction is automatically deposited to the vault, which you can securely claim anytime.\r\n *  \r\n *  https://bankbtc.app\r\n *  https://t.me/BankBTCApp\r\n */\r\n \r\n\r\npragma solidity ^0.8.6;\r\n\r\n/**\r\n * Standard SafeMath, stripped down to just add/sub/mul/div\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract deployer\r\n     */\r\n    modifier onlyDeployer() {\r\n        require(isOwner(msg.sender), \"!D\"); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isAuthorized(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Authorize address. Owner only\r\n     */\r\n    function authorize(address adr) public onlyDeployer {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    /**\r\n     * Remove address' authorization. Deployer only\r\n     */\r\n    function unauthorize(address adr) public onlyDeployer {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be deployer. Leaves old deployer authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyDeployer {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IDividendDistributor {\r\n    function setShare(address shareholder, uint256 amount) external;\r\n    function deposit() external payable;\r\n    function claimDividend(address shareholder) external;\r\n    function setDividendToken(address dividendToken) external;\r\n}\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n\r\n    address _token;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    IBEP20 dividendToken;\r\n    IDEXRouter router;\r\n    \r\n    address WETH;\r\n\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) shareholderClaims;\r\n\r\n    mapping (address => Share) public shares;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n    \r\n    address owner;\r\n\r\n    uint256 currentIndex;\r\n\r\n    bool initialized;\r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner); _;\r\n    }\r\n    \r\n    event DividendTokenUpdate(address dividendToken);\r\n\r\n    constructor (address _router, address _dividendToken, address _owner) {\r\n        router = _router != address(0)\r\n            ? IDEXRouter(_router)\r\n            : IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _token = msg.sender;\r\n        dividendToken = IBEP20(_dividendToken);\r\n        WETH = router.WETH();\r\n        owner = _owner;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if(shares[shareholder].amount > 0){\r\n            distributeDividend(shareholder);\r\n        }\r\n\r\n        if(amount > 0 && shares[shareholder].amount == 0){\r\n            addShareholder(shareholder);\r\n        }else if(amount == 0 && shares[shareholder].amount > 0){\r\n            removeShareholder(shareholder);\r\n        }\r\n\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 balanceBefore = dividendToken.balanceOf(address(this));\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = address(dividendToken);\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amount = dividendToken.balanceOf(address(this)).sub(balanceBefore);\r\n\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function distributeDividend(address shareholder) internal {\r\n        if(shares[shareholder].amount == 0){ return; }\r\n\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount > 0){\r\n            totalDistributed = totalDistributed.add(amount);\r\n            dividendToken.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n        }\r\n    }\r\n    \r\n    function claimDividend(address shareholder) external override onlyToken {\r\n        distributeDividend(shareholder);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        if(shares[shareholder].amount == 0){ return 0; }\r\n\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\r\n\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n    \r\n    function setDividendToken(address _dividendToken) external override onlyToken {\r\n        dividendToken = IBEP20(_dividendToken);\r\n        emit DividendTokenUpdate(_dividendToken);\r\n    }\r\n    \r\n    function getDividendToken() external view returns (address) {\r\n        return address(dividendToken);\r\n    }\r\n    \r\n    function sendDividend(address holder, uint256 amount) external onlyOwner {\r\n        dividendToken.transfer(holder, amount);\r\n    }\r\n}\r\n\r\ncontract BankBTC is IBEP20, Auth {\r\n    using SafeMath for uint256;\r\n\r\n    address WETH;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    string constant _name = \"Bank BTC | https://bankbtc.app\";\r\n    string constant _symbol = \"BANKBTC\";\r\n    uint8 constant _decimals = 9;\r\n\r\n    uint256 _totalSupply = 1000000000000 * (10 ** _decimals);\r\n    uint256 public _maxTxAmountBuy = _totalSupply;\r\n    uint256 public _maxTxAmountSell = _totalSupply / 100;\r\n    \r\n    uint256 _maxWalletToken = 10 * 10**9 * (10**_decimals);\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n    mapping (address => bool) isFeeExempt;\r\n    mapping (address => bool) isTxLimitExempt;\r\n    mapping (address => bool) isDividendExempt;\r\n    mapping (address => bool) isBot;\r\n\r\n    uint256 initialBlockLimit = 15;\r\n    \r\n    uint256 reflectionFeeBuy = 10;\r\n    uint256 marketingFeeBuy = 2;\r\n    uint256 totalFeeBuy = 12;\r\n    uint256 feeDenominatorBuy = 100;\r\n    \r\n    uint256 reflectionFeeSell = 10;\r\n    uint256 marketingFeeSell = 5;\r\n    uint256 totalFeeSell = 15;\r\n    uint256 feeDenominatorSell = 100;\r\n\r\n    address marketingReceiver;\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    uint256 public launchedAt;\r\n\r\n    DividendDistributor distributor;\r\n\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply / 5000; // 200M\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor (\r\n        address _presaler,\r\n        address _router,\r\n        address _token\r\n    ) Auth(msg.sender) {\r\n        router = _router != address(0)\r\n            ? IDEXRouter(_router)\r\n            : IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n            \r\n        _presaler = _presaler != address(0)\r\n            ? _presaler\r\n            : msg.sender;\r\n            \r\n        WETH = router.WETH();\r\n        \r\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\r\n        \r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n        \r\n        _token = _token != address(0)\r\n            ? _token\r\n            : 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\r\n\r\n        distributor = new DividendDistributor(address(router), _token, _presaler);\r\n\r\n        isFeeExempt[_presaler] = true;\r\n        isTxLimitExempt[_presaler] = true;\r\n        isDividendExempt[pair] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[DEAD] = true;\r\n\r\n        marketingReceiver = msg.sender;\r\n\r\n        _balances[_presaler] = _totalSupply;\r\n    \r\n        emit Transfer(address(0), _presaler, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _tF(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _tF(sender, recipient, amount);\r\n    }\r\n\r\n    function _tF(address s, address r, uint256 amount) internal returns (bool) {\r\n        if(inSwap){ return _basicTransfer(s, r, amount); }\r\n        \r\n        checkTxLimit(s, r, amount);\r\n\r\n        if(shouldSwapBack()){ swapBack(); }\r\n\r\n        if(!launched() && r == pair){ require(_balances[s] > 0); launch(); }\r\n\r\n        _balances[s] = _balances[s].sub(amount, \"Insufficient Balance\");\r\n\r\n        uint256 amountReceived = shouldTakeFee(s) ? takeFee(s, r, amount) : amount;\r\n        \r\n        if(r != pair && !isTxLimitExempt[r]){\r\n            uint256 contractBalanceRecepient = balanceOf(r);\r\n            require(contractBalanceRecepient + amountReceived <= _maxWalletToken, \"Exceeds maximum wallet token amount\"); \r\n        }\r\n        \r\n        _balances[r] = _balances[r].add(amountReceived);\r\n\r\n        if(!isDividendExempt[s]){ try distributor.setShare(s, _balances[s]) {} catch {} }\r\n        if(!isDividendExempt[r]){ try distributor.setShare(r, _balances[r]) {} catch {} }\r\n\r\n        emit Transfer(s, r, amountReceived);\r\n        return true;\r\n    }\r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function checkTxLimit(address sender, address receiver, uint256 amount) internal view {\r\n        sender == pair\r\n            ? require(amount <= _maxTxAmountBuy || isTxLimitExempt[receiver], \"Buy TX Limit Exceeded\")\r\n            : require(amount <= _maxTxAmountSell || isTxLimitExempt[sender], \"Sell TX Limit Exceeded\");\r\n    }\r\n\r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        return !isFeeExempt[sender];\r\n    }\r\n\r\n    function getTotalFee(bool selling, bool bot) public view returns (uint256) {\r\n        // Anti-bot, fees as 99% for the first block\r\n        if(launchedAt + initialBlockLimit >= block.number || bot){ return selling ? feeDenominatorSell.sub(1) : feeDenominatorBuy.sub(1); }\r\n        // If selling and buyback has happened in past 30 mins, then get the multiplied fees or otherwise get the normal fees\r\n        return selling ? totalFeeSell : totalFeeBuy;\r\n    }\r\n\r\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\r\n        // Add all the fees to the contract. In case of Sell, it will be multiplied fees.\r\n        uint256 feeAmount = (receiver == pair) ? amount.mul(getTotalFee(true, isBot[sender])).div(feeDenominatorSell) : amount.mul(getTotalFee(false, isBot[receiver])).div(feeDenominatorBuy);\r\n\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 amountToSwap = swapThreshold;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WETH;\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\r\n        uint256 amountReflection = amountETH.mul(reflectionFeeSell).div(totalFeeSell);\r\n        uint256 amountMarketing = amountETH.sub(amountReflection);\r\n\r\n        try distributor.deposit{value: amountReflection}() {} catch {}\r\n        \r\n        (bool successMarketing, /* bytes memory data */) = payable(marketingReceiver).call{value: amountMarketing, gas: 30000}(\"\");\r\n        require(successMarketing, \"receiver rejected ETH transfer\");\r\n    }\r\n\r\n    function launched() internal view returns (bool) {\r\n        return launchedAt != 0;\r\n    }\r\n\r\n    function launch() internal {\r\n        //To know when it was launched\r\n        launchedAt = block.number;\r\n    }\r\n    \r\n    function setInitialBlockLimit(uint256 blocks) external onlyOwner {\r\n        require(blocks > 0, \"Blocks should be greater than 0\");\r\n        initialBlockLimit = blocks;\r\n    }\r\n\r\n    function setBuyTxLimit(uint256 amount) external onlyOwner {\r\n        _maxTxAmountBuy = amount;\r\n    }\r\n    \r\n    function setSellTxLimit(uint256 amount) external onlyOwner {\r\n        _maxTxAmountSell = amount;\r\n    }\r\n    \r\n    function setMaxWalletToken(uint256 amount) external onlyOwner {\r\n        _maxWalletToken = amount;\r\n    }\r\n    \r\n    function getMaxWalletToken() public view onlyOwner returns (uint256) {\r\n        return _maxWalletToken;\r\n    }\r\n    \r\n    function setBot(address _address, bool toggle) external onlyOwner {\r\n        isBot[_address] = toggle;\r\n        _setIsDividendExempt(_address, toggle);\r\n    }\r\n    \r\n    function isInBot(address _address) public view onlyOwner returns (bool) {\r\n        return isBot[_address];\r\n    }\r\n    \r\n    function _setIsDividendExempt(address holder, bool exempt) internal {\r\n        require(holder != address(this) && holder != pair);\r\n        isDividendExempt[holder] = exempt;\r\n        if(exempt){\r\n            distributor.setShare(holder, 0);\r\n        }else{\r\n            distributor.setShare(holder, _balances[holder]);\r\n        }\r\n    }\r\n\r\n    function setIsDividendExempt(address holder, bool exempt) public onlyOwner {\r\n        _setIsDividendExempt(holder, exempt);\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\r\n        isTxLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    function setSellFees( uint256 _reflectionFee, uint256 _marketingFee, uint256 _feeDenominator) external onlyOwner {\r\n        reflectionFeeSell = _reflectionFee;\r\n        marketingFeeSell = _marketingFee;\r\n        totalFeeSell = _reflectionFee.add(_marketingFee);\r\n        feeDenominatorSell = _feeDenominator;\r\n        //Total fees has be less than 25%\r\n        require(totalFeeSell < feeDenominatorSell/4);\r\n    }\r\n    \r\n    function setBuyFees(uint256 _reflectionFee, uint256 _marketingFee, uint256 _feeDenominator) external onlyOwner {\r\n        reflectionFeeBuy = _reflectionFee;\r\n        marketingFeeBuy = _marketingFee;\r\n        totalFeeBuy = _reflectionFee.add(_marketingFee);\r\n        feeDenominatorBuy = _feeDenominator;\r\n        //Total fees has be less than 25%\r\n        require(totalFeeBuy < feeDenominatorBuy/4);\r\n    }\r\n\r\n    function setFeeReceivers(address _marketingReceiver) external onlyOwner {\r\n        marketingReceiver = _marketingReceiver;\r\n    }\r\n    \r\n    function fixFeeIssue(uint256 amount) external onlyOwner {\r\n        //Use in case marketing fees or dividends are stuck.\r\n        uint256 contractETHBalance = address(this).balance;\r\n        payable(marketingReceiver).transfer(amount > 0 ? amount : contractETHBalance);\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external onlyOwner {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _amount;\r\n    }\r\n    \r\n    function claimDividend() external {\r\n        distributor.claimDividend(msg.sender);\r\n    }\r\n    \r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        return distributor.getUnpaidEarnings(shareholder);\r\n    }\r\n    \r\n    function banMultipleBots(address[] calldata accounts, bool excluded) external onlyOwner {\r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n            isBot[accounts[i]] = excluded;\r\n            isDividendExempt[accounts[i]] = excluded;\r\n            if(excluded){\r\n                distributor.setShare(accounts[i], 0);\r\n            }else{\r\n                distributor.setShare(accounts[i], _balances[accounts[i]]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function blockKnownBots() external onlyOwner {\r\n        isBot[address(0x7589319ED0fD750017159fb4E4d96C63966173C1)] = true;\r\n        isDividendExempt[address(0x7589319ED0fD750017159fb4E4d96C63966173C1)] = true;\r\n    \r\n        isBot[address(0x65A67DF75CCbF57828185c7C050e34De64d859d0)] = true;\r\n        isDividendExempt[address(0x65A67DF75CCbF57828185c7C050e34De64d859d0)] = true;\r\n    \r\n        isBot[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;\r\n        isDividendExempt[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;\r\n    \r\n        isBot[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;\r\n        isDividendExempt[address(0xE031b36b53E53a292a20c5F08fd1658CDdf74fce)] = true;\r\n    \r\n        isBot[address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345)] = true;\r\n        isDividendExempt[address(0xe516bDeE55b0b4e9bAcaF6285130De15589B1345)] = true;\r\n    \r\n        isBot[address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b)] = true;\r\n        isDividendExempt[address(0xa1ceC245c456dD1bd9F2815a6955fEf44Eb4191b)] = true;\r\n    \r\n        isBot[address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95)] = true;\r\n        isDividendExempt[address(0xd7d3EE77D35D0a56F91542D4905b1a2b1CD7cF95)] = true;\r\n    \r\n        isBot[address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964)] = true;\r\n        isDividendExempt[address(0xFe76f05dc59fEC04184fA0245AD0C3CF9a57b964)] = true;\r\n    \r\n        isBot[address(0xDC81a3450817A58D00f45C86d0368290088db848)] = true;\r\n        isDividendExempt[address(0xDC81a3450817A58D00f45C86d0368290088db848)] = true;\r\n    \r\n        isBot[address(0x45fD07C63e5c316540F14b2002B085aEE78E3881)] = true;\r\n        isDividendExempt[address(0x45fD07C63e5c316540F14b2002B085aEE78E3881)] = true;\r\n    \r\n        isBot[address(0x27F9Adb26D532a41D97e00206114e429ad58c679)] = true;\r\n        isDividendExempt[address(0x27F9Adb26D532a41D97e00206114e429ad58c679)] = true;\r\n    \r\n        isBot[address(0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7)] = true;\r\n        isDividendExempt[address(0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7)] = true;\r\n    \r\n        isBot[address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533)] = true;\r\n        isDividendExempt[address(0xfad95B6089c53A0D1d861eabFaadd8901b0F8533)] = true;\r\n    \r\n        isBot[address(0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d)] = true;\r\n        isDividendExempt[address(0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d)] = true;\r\n    \r\n        isBot[address(0x000000000000084e91743124a982076C59f10084)] = true;\r\n        isDividendExempt[address(0x000000000000084e91743124a982076C59f10084)] = true;\r\n    \r\n        isBot[address(0x6dA4bEa09C3aA0761b09b19837D9105a52254303)] = true;\r\n        isDividendExempt[address(0x6dA4bEa09C3aA0761b09b19837D9105a52254303)] = true;\r\n    \r\n        isBot[address(0x323b7F37d382A68B0195b873aF17CeA5B67cd595)] = true;\r\n        isDividendExempt[address(0x323b7F37d382A68B0195b873aF17CeA5B67cd595)] = true;\r\n    \r\n        isBot[address(0x000000005804B22091aa9830E50459A15E7C9241)] = true;\r\n        isDividendExempt[address(0x000000005804B22091aa9830E50459A15E7C9241)] = true;\r\n    \r\n        isBot[address(0xA3b0e79935815730d942A444A84d4Bd14A339553)] = true;\r\n        isDividendExempt[address(0xA3b0e79935815730d942A444A84d4Bd14A339553)] = true;\r\n    \r\n        isBot[address(0xf6da21E95D74767009acCB145b96897aC3630BaD)] = true;\r\n        isDividendExempt[address(0xf6da21E95D74767009acCB145b96897aC3630BaD)] = true;\r\n    \r\n        isBot[address(0x0000000000007673393729D5618DC555FD13f9aA)] = true;\r\n        isDividendExempt[address(0x0000000000007673393729D5618DC555FD13f9aA)] = true;\r\n    \r\n        isBot[address(0x00000000000003441d59DdE9A90BFfb1CD3fABf1)] = true;\r\n        isDividendExempt[address(0x00000000000003441d59DdE9A90BFfb1CD3fABf1)] = true;\r\n    \r\n        isBot[address(0x59903993Ae67Bf48F10832E9BE28935FEE04d6F6)] = true;\r\n        isDividendExempt[address(0x59903993Ae67Bf48F10832E9BE28935FEE04d6F6)] = true;\r\n    \r\n        isBot[address(0x000000917de6037d52b1F0a306eeCD208405f7cd)] = true;\r\n        isDividendExempt[address(0x000000917de6037d52b1F0a306eeCD208405f7cd)] = true;\r\n    \r\n        isBot[address(0x7100e690554B1c2FD01E8648db88bE235C1E6514)] = true;\r\n        isDividendExempt[address(0x7100e690554B1c2FD01E8648db88bE235C1E6514)] = true;\r\n    \r\n        isBot[address(0x72b30cDc1583224381132D379A052A6B10725415)] = true;\r\n        isDividendExempt[address(0x72b30cDc1583224381132D379A052A6B10725415)] = true;\r\n    \r\n        isBot[address(0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE)] = true;\r\n        isDividendExempt[address(0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE)] = true;\r\n    \r\n        isBot[address(0xfe9d99ef02E905127239E85A611c29ad32c31c2F)] = true;\r\n        isDividendExempt[address(0xfe9d99ef02E905127239E85A611c29ad32c31c2F)] = true;\r\n    \r\n        isBot[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;\r\n        isDividendExempt[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;\r\n    \r\n        isBot[address(0xc496D84215d5018f6F53E7F6f12E45c9b5e8e8A9)] = true;\r\n        isDividendExempt[address(0xc496D84215d5018f6F53E7F6f12E45c9b5e8e8A9)] = true;\r\n    \r\n        isBot[address(0x59341Bc6b4f3Ace878574b05914f43309dd678c7)] = true;\r\n        isDividendExempt[address(0x59341Bc6b4f3Ace878574b05914f43309dd678c7)] = true;\r\n    \r\n        isBot[address(0xe986d48EfeE9ec1B8F66CD0b0aE8e3D18F091bDF)] = true;\r\n        isDividendExempt[address(0xe986d48EfeE9ec1B8F66CD0b0aE8e3D18F091bDF)] = true;\r\n    \r\n        isBot[address(0x4aEB32e16DcaC00B092596ADc6CD4955EfdEE290)] = true;\r\n        isDividendExempt[address(0x4aEB32e16DcaC00B092596ADc6CD4955EfdEE290)] = true;\r\n    \r\n        isBot[address(0x136F4B5b6A306091b280E3F251fa0E21b1280Cd5)] = true;\r\n        isDividendExempt[address(0x136F4B5b6A306091b280E3F251fa0E21b1280Cd5)] = true;\r\n    \r\n        isBot[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;\r\n        isDividendExempt[address(0x39608b6f20704889C51C0Ae28b1FCA8F36A5239b)] = true;\r\n    \r\n        isBot[address(0x5B83A351500B631cc2a20a665ee17f0dC66e3dB7)] = true;\r\n        isDividendExempt[address(0x5B83A351500B631cc2a20a665ee17f0dC66e3dB7)] = true;\r\n    \r\n        isBot[address(0xbCb05a3F85d34f0194C70d5914d5C4E28f11Cc02)] = true;\r\n        isDividendExempt[address(0xbCb05a3F85d34f0194C70d5914d5C4E28f11Cc02)] = true;\r\n    \r\n        isBot[address(0x22246F9BCa9921Bfa9A3f8df5baBc5Bc8ee73850)] = true;\r\n        isDividendExempt[address(0x22246F9BCa9921Bfa9A3f8df5baBc5Bc8ee73850)] = true;\r\n    \r\n        isBot[address(0x42d4C197036BD9984cA652303e07dD29fA6bdB37)] = true;\r\n        isDividendExempt[address(0x42d4C197036BD9984cA652303e07dD29fA6bdB37)] = true;\r\n    \r\n        isBot[address(0x00000000003b3cc22aF3aE1EAc0440BcEe416B40)] = true;\r\n        isDividendExempt[address(0x00000000003b3cc22aF3aE1EAc0440BcEe416B40)] = true;\r\n    \r\n        isBot[address(0x231DC6af3C66741f6Cf618884B953DF0e83C1A2A)] = true;\r\n        isDividendExempt[address(0x231DC6af3C66741f6Cf618884B953DF0e83C1A2A)] = true;\r\n    \r\n        isBot[address(0xC6bF34596f74eb22e066a878848DfB9fC1CF4C65)] = true;\r\n        isDividendExempt[address(0xC6bF34596f74eb22e066a878848DfB9fC1CF4C65)] = true;\r\n    \r\n        isBot[address(0x20f6fCd6B8813c4f98c0fFbD88C87c0255040Aa3)] = true;\r\n        isDividendExempt[address(0x20f6fCd6B8813c4f98c0fFbD88C87c0255040Aa3)] = true;\r\n    \r\n        isBot[address(0xD334C5392eD4863C81576422B968C6FB90EE9f79)] = true;\r\n        isDividendExempt[address(0xD334C5392eD4863C81576422B968C6FB90EE9f79)] = true;\r\n    \r\n        isBot[address(0xFFFFF6E70842330948Ca47254F2bE673B1cb0dB7)] = true;\r\n        isDividendExempt[address(0xFFFFF6E70842330948Ca47254F2bE673B1cb0dB7)] = true;\r\n    \r\n        isBot[address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a)] = true;\r\n        isDividendExempt[address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a)] = true;\r\n    \r\n        isBot[address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a)] = true;\r\n        isDividendExempt[address(0xA39C50bf86e15391180240938F469a7bF4fDAe9a)] = true;\r\n    }\r\n}\r\n\r\n"}}}