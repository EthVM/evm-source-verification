{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"KyberReserve.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-08-15\r\n*/\r\n\r\n// File: contracts/sol4/ERC20Interface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/sol4/Utils.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/sol4/PermissionGroups.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/sol4/Withdrawable.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/sol4/ConversionRatesInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\ninterface ConversionRatesInterface {\r\n\r\n    function recordImbalance(\r\n        ERC20 token,\r\n        int buyAmount,\r\n        uint rateUpdateBlock,\r\n        uint currentBlock\r\n    )\r\n        public;\r\n\r\n    function getRate(ERC20 token, uint currentBlockNumber, bool buy, uint qty) public view returns(uint);\r\n}\r\n\r\n// File: contracts/sol4/SanityRatesInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\ninterface SanityRatesInterface {\r\n    function getSanityRate(ERC20 src, ERC20 dest) public view returns(uint);\r\n}\r\n\r\n// File: contracts/sol4/KyberReserveInterface.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n/// @title Kyber Reserve contract\r\ninterface KyberReserveInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\r\n}\r\n\r\n// File: contracts/sol4/reserves/KyberReserve.sol\r\n\r\npragma solidity 0.4.18;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Kyber Reserve contract\r\ncontract KyberReserve is KyberReserveInterface, Withdrawable, Utils {\r\n\r\n    address public kyberNetwork;\r\n    bool public tradeEnabled;\r\n    ConversionRatesInterface public conversionRatesContract;\r\n    SanityRatesInterface public sanityRatesContract;\r\n    mapping(bytes32=>bool) public approvedWithdrawAddresses; // sha3(token,address)=>bool\r\n    mapping(address=>address) public tokenWallet;\r\n\r\n    function KyberReserve(address _kyberNetwork, ConversionRatesInterface _ratesContract, address _admin) public {\r\n        require(_admin != address(0));\r\n        require(_ratesContract != address(0));\r\n        require(_kyberNetwork != address(0));\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _ratesContract;\r\n        admin = _admin;\r\n        tradeEnabled = true;\r\n    }\r\n\r\n    event DepositToken(ERC20 token, uint amount);\r\n\r\n    function() public payable {\r\n        DepositToken(ETH_TOKEN_ADDRESS, msg.value);\r\n    }\r\n\r\n    event TradeExecute(\r\n        address indexed origin,\r\n        address src,\r\n        uint srcAmount,\r\n        address destToken,\r\n        uint destAmount,\r\n        address destAddress\r\n    );\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        public\r\n        payable\r\n        returns(bool)\r\n    {\r\n        require(tradeEnabled);\r\n        require(msg.sender == kyberNetwork);\r\n\r\n        require(doTrade(srcToken, srcAmount, destToken, destAddress, conversionRate, validate));\r\n\r\n        return true;\r\n    }\r\n\r\n    event TradeEnabled(bool enable);\r\n\r\n    function enableTrade() public onlyAdmin returns(bool) {\r\n        tradeEnabled = true;\r\n        TradeEnabled(true);\r\n\r\n        return true;\r\n    }\r\n\r\n    function disableTrade() public onlyAlerter returns(bool) {\r\n        tradeEnabled = false;\r\n        TradeEnabled(false);\r\n\r\n        return true;\r\n    }\r\n\r\n    event WithdrawAddressApproved(ERC20 token, address addr, bool approve);\r\n\r\n    function approveWithdrawAddress(ERC20 token, address addr, bool approve) public onlyAdmin {\r\n        approvedWithdrawAddresses[keccak256(token, addr)] = approve;\r\n        WithdrawAddressApproved(token, addr, approve);\r\n\r\n        setDecimals(token);\r\n        if ((tokenWallet[token] == address(0x0)) && (token != ETH_TOKEN_ADDRESS)) {\r\n            tokenWallet[token] = this; // by default\r\n            require(token.approve(this, 2 ** 255));\r\n        }\r\n    }\r\n\r\n    event NewTokenWallet(ERC20 token, address wallet);\r\n\r\n    function setTokenWallet(ERC20 token, address wallet) public onlyAdmin {\r\n        require(wallet != address(0x0));\r\n        tokenWallet[token] = wallet;\r\n        NewTokenWallet(token, wallet);\r\n    }\r\n\r\n    event WithdrawFunds(ERC20 token, uint amount, address destination);\r\n\r\n    function withdraw(ERC20 token, uint amount, address destination) public onlyOperator returns(bool) {\r\n        require(approvedWithdrawAddresses[keccak256(token, destination)]);\r\n\r\n        if (token == ETH_TOKEN_ADDRESS) {\r\n            destination.transfer(amount);\r\n        } else {\r\n            require(token.transferFrom(tokenWallet[token], destination, amount));\r\n        }\r\n\r\n        WithdrawFunds(token, amount, destination);\r\n\r\n        return true;\r\n    }\r\n\r\n    event SetContractAddresses(address network, address rate, address sanity);\r\n\r\n    function setContracts(\r\n        address _kyberNetwork,\r\n        ConversionRatesInterface _conversionRates,\r\n        SanityRatesInterface _sanityRates\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_kyberNetwork != address(0));\r\n        require(_conversionRates != address(0));\r\n\r\n        kyberNetwork = _kyberNetwork;\r\n        conversionRatesContract = _conversionRates;\r\n        sanityRatesContract = _sanityRates;\r\n\r\n        SetContractAddresses(kyberNetwork, conversionRatesContract, sanityRatesContract);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    /// status functions ///////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////\r\n    function getBalance(ERC20 token) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return this.balance;\r\n        else {\r\n            address wallet = tokenWallet[token];\r\n            uint balanceOfWallet = token.balanceOf(wallet);\r\n            uint allowanceOfWallet = token.allowance(wallet, this);\r\n\r\n            return (balanceOfWallet < allowanceOfWallet) ? balanceOfWallet : allowanceOfWallet;\r\n        }\r\n    }\r\n\r\n    function getDestQty(ERC20 src, ERC20 dest, uint srcQty, uint rate) public view returns(uint) {\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcDstQty(srcQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getSrcQty(ERC20 src, ERC20 dest, uint dstQty, uint rate) public view returns(uint) {\r\n        uint dstDecimals = getDecimals(dest);\r\n        uint srcDecimals = getDecimals(src);\r\n\r\n        return calcSrcQty(dstQty, srcDecimals, dstDecimals, rate);\r\n    }\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint) {\r\n        ERC20 token;\r\n        bool  isBuy;\r\n\r\n        if (!tradeEnabled) return 0;\r\n\r\n        if (ETH_TOKEN_ADDRESS == src) {\r\n            isBuy = true;\r\n            token = dest;\r\n        } else if (ETH_TOKEN_ADDRESS == dest) {\r\n            isBuy = false;\r\n            token = src;\r\n        } else {\r\n            return 0; // pair is not listed\r\n        }\r\n\r\n        uint rate = conversionRatesContract.getRate(token, blockNumber, isBuy, srcQty);\r\n        uint destQty = getDestQty(src, dest, srcQty, rate);\r\n\r\n        if (getBalance(dest) < destQty) return 0;\r\n\r\n        if (sanityRatesContract != address(0)) {\r\n            uint sanityRate = sanityRatesContract.getSanityRate(src, dest);\r\n            if (rate > sanityRate) return 0;\r\n        }\r\n\r\n        return rate;\r\n    }\r\n\r\n    /// @dev do a trade\r\n    /// @param srcToken Src token\r\n    /// @param srcAmount Amount of src token\r\n    /// @param destToken Destination token\r\n    /// @param destAddress Destination address to send tokens to\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true iff trade is successful\r\n    function doTrade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        // can skip validation if done at kyber network level\r\n        if (validate) {\r\n            require(conversionRate > 0);\r\n            if (srcToken == ETH_TOKEN_ADDRESS)\r\n                require(msg.value == srcAmount);\r\n            else\r\n                require(msg.value == 0);\r\n        }\r\n\r\n        uint destAmount = getDestQty(srcToken, destToken, srcAmount, conversionRate);\r\n        // sanity check\r\n        require(destAmount > 0);\r\n\r\n        // add to imbalance\r\n        ERC20 token;\r\n        int tradeAmount;\r\n        if (srcToken == ETH_TOKEN_ADDRESS) {\r\n            tradeAmount = int(destAmount);\r\n            token = destToken;\r\n        } else {\r\n            tradeAmount = -1 * int(srcAmount);\r\n            token = srcToken;\r\n        }\r\n\r\n        conversionRatesContract.recordImbalance(\r\n            token,\r\n            tradeAmount,\r\n            0,\r\n            block.number\r\n        );\r\n\r\n        // collect src tokens\r\n        if (srcToken != ETH_TOKEN_ADDRESS) {\r\n            require(srcToken.transferFrom(msg.sender, tokenWallet[srcToken], srcAmount));\r\n        }\r\n\r\n        // send dest tokens\r\n        if (destToken == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(destAmount);\r\n        } else {\r\n            require(destToken.transferFrom(tokenWallet[destToken], destAddress, destAmount));\r\n        }\r\n\r\n        TradeExecute(msg.sender, srcToken, srcAmount, destToken, destAmount, destAddress);\r\n\r\n        return true;\r\n    }\r\n}"}}}