{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "YopCollection.sol": {
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n\ncontract PauserRole is Context {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () internal {\n        _addPauser(_msgSender());\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(_msgSender()), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function renouncePauser() public {\n        _removePauser(_msgSender());\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context, PauserRole {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\ninterface IERC1155 {\n\tevent TransferSingle(\n\t\taddress indexed _operator,\n\t\taddress indexed _from,\n\t\taddress indexed _to,\n\t\tuint256 _id,\n\t\tuint256 _amount\n\t);\n\n\tevent TransferBatch(\n\t\taddress indexed _operator,\n\t\taddress indexed _from,\n\t\taddress indexed _to,\n\t\tuint256[] _ids,\n\t\tuint256[] _amounts\n\t);\n\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\tevent URI(string _amount, uint256 indexed _id);\n\n\tfunction mint(\n\t\taddress _to,\n\t\tuint256 _id,\n\t\tuint256 _quantity,\n\t\tbytes calldata _data\n\t) external;\n\n\tfunction create(\n\t\tuint256 _maxSupply,\n\t\tuint256 _initialSupply,\n\t\tstring calldata _uri,\n\t\tbytes calldata _data\n\t) external returns (uint256 tokenId);\n\n\tfunction safeTransferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _id,\n\t\tuint256 _amount,\n\t\tbytes calldata _data\n\t) external;\n\n\tfunction safeBatchTransferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256[] calldata _ids,\n\t\tuint256[] calldata _amounts,\n\t\tbytes calldata _data\n\t) external;\n\n\tfunction balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n\tfunction balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory);\n\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract PoolTokenWrapper {\n\tusing SafeMath for uint256;\n\tIERC20 public token;\n\n\tconstructor(IERC20 _erc20Address) public {\n\t\ttoken = IERC20(_erc20Address);\n\t}\n\n\tuint256 private _totalSupply;\n\t// Objects balances [id][address] => balance\n\tmapping(uint256 => mapping(address => uint256)) internal _balances;\n\tmapping(uint256 => uint256) private _poolBalances;\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\tfunction balanceOfPool(uint256 id) public view returns (uint256) {\n\t\treturn _poolBalances[id];\n\t}\n\n\tfunction balanceOf(address account, uint256 id) public view returns (uint256) {\n\t\treturn _balances[id][account];\n\t}\n\n\tfunction stake(uint256 id, uint256 amount) public {\n\t\t_totalSupply = _totalSupply.add(amount);\n\t\t_poolBalances[id] = _poolBalances[id].add(amount);\n\t\t_balances[id][msg.sender] = _balances[id][msg.sender].add(amount);\n\t\ttoken.transferFrom(msg.sender, address(this), amount);\n\t}\n\n\tfunction withdraw(uint256 id, uint256 amount) public {\n\t\t_totalSupply = _totalSupply.sub(amount);\n\t\t_poolBalances[id] = _poolBalances[id].sub(amount);\n\t\t_balances[id][msg.sender] = _balances[id][msg.sender].sub(amount);\n\t\ttoken.transfer(msg.sender, amount);\n\t}\n\n\tfunction transfer(\n\t\tuint256 fromId,\n\t\tuint256 toId,\n\t\tuint256 amount\n\t) public {\n\t\t_poolBalances[fromId] = _poolBalances[fromId].sub(amount);\n\t\t_balances[fromId][msg.sender] = _balances[fromId][msg.sender].sub(amount);\n\n\t\t_poolBalances[toId] = _poolBalances[toId].add(amount);\n\t\t_balances[toId][msg.sender] = _balances[toId][msg.sender].add(amount);\n\t}\n\n\tfunction _rescuePineapples(address account, uint256 id) internal {\n\t\tuint256 amount = _balances[id][account];\n\n\t\t_totalSupply = _totalSupply.sub(amount);\n\t\t_poolBalances[id] = _poolBalances[id].sub(amount);\n\t\t_balances[id][account] = _balances[id][account].sub(amount);\n\t\ttoken.transfer(account, amount);\n\t}\n}\n\ncontract YopCollection is PoolTokenWrapper, Ownable, Pausable {\n\tusing SafeMath for uint256;\n\tIERC1155 public memeLtd;\n\n\tstruct Card {\n\t\tuint256 points;\n\t\tuint256 releaseTime;\n\t\tuint256 mintFee;\n\t}\n\n\tstruct Pool {\n\t\tuint256 periodStart;\n\t\tuint256 maxStake;\n\t\tuint256 rewardRate;\n\t\tuint256 feesCollected;\n\t\tuint256 spentPineapples;\n\t\tuint256 controllerShare;\n\t\taddress artist;\n\t\tuint256 boostCardId;\n\t\tuint256 boostAmount;\n\t\tmapping(address => uint256) lastUpdateTime;\n\t\tmapping(address => uint256) points;\n\t\tmapping(uint256 => Card) cards;\n\t}\n\n\taddress public controller;\n\taddress public rescuer;\n\tmapping(address => uint256) public pendingWithdrawals;\n\tmapping(uint256 => Pool) public pools;\n\n\tevent UpdatedArtist(uint256 poolId, address artist);\n\tevent PoolAdded(uint256 poolId, address artist, uint256 periodStart, uint256 rewardRate, uint256 maxStake);\n\tevent CardAdded(uint256 poolId, uint256 cardId, uint256 points, uint256 mintFee, uint256 releaseTime);\n\tevent Staked(address indexed user, uint256 poolId, uint256 amount);\n\tevent Withdrawn(address indexed user, uint256 poolId, uint256 amount);\n\tevent Transferred(address indexed user, uint256 fromPoolId, uint256 toPoolId, uint256 amount);\n\tevent Redeemed(address indexed user, uint256 poolId, uint256 amount);\n\n\tmodifier updateReward(address account, uint256 id) {\n\t\tif (account != address(0)) {\n\t\t\tpools[id].points[account] = earned(account, id);\n\t\t\tpools[id].lastUpdateTime[account] = block.timestamp;\n\t\t}\n\t\t_;\n\t}\n\n\tmodifier poolExists(uint256 id) {\n\t\trequire(pools[id].rewardRate > 0, \"pool does not exists\");\n\t\t_;\n\t}\n\n\tmodifier cardExists(uint256 pool, uint256 card) {\n\t\trequire(pools[pool].cards[card].points > 0, \"card does not exists\");\n\t\t_;\n\t}\n\n\tconstructor(\n\t\taddress _controller,\n\t\tIERC1155 _memeLtdAddress,\n\t\tIERC20 _tokenAddress\n\t) public PoolTokenWrapper(_tokenAddress) {\n\t\tcontroller = _controller;\n\t\tmemeLtd = _memeLtdAddress;\n\t}\n\n\tfunction cardMintFee(uint256 pool, uint256 card) public view returns (uint256) {\n\t\treturn pools[pool].cards[card].mintFee;\n\t}\n\n\tfunction cardReleaseTime(uint256 pool, uint256 card) public view returns (uint256) {\n\t\treturn pools[pool].cards[card].releaseTime;\n\t}\n\n\tfunction cardPoints(uint256 pool, uint256 card) public view returns (uint256) {\n\t\treturn pools[pool].cards[card].points;\n\t}\n\n\tfunction boost(address account, uint256 pool) public view returns (uint256) {\n\t\tPool storage p = pools[pool];\n\t\tif (p.boostCardId > 0 && memeLtd.balanceOf(account, p.boostCardId) >= 1) {\n\t\t\treturn p.boostAmount;\n\t\t}\n\t\treturn 100;\n\t}\n\n\tfunction earned(address account, uint256 pool) public view returns (uint256) {\n\t\tPool storage p = pools[pool];\n\t\tuint256 blockTime = block.timestamp;\n\t\tuint256 rewardRate = p.rewardRate.mul(boost(account, pool)).div(100);\n\n\t\treturn\n\t\t\tbalanceOf(account, pool).mul(blockTime.sub(p.lastUpdateTime[account]).mul(rewardRate)).div(1e8).add(\n\t\t\t\tp.points[account]\n\t\t\t);\n\t}\n\n\t// override PoolTokenWrapper's stake() function\n\tfunction stake(uint256 pool, uint256 amount)\n\t\tpublic\n\t\tpoolExists(pool)\n\t\tupdateReward(msg.sender, pool)\n\t\twhenNotPaused()\n\t{\n\t\tPool memory p = pools[pool];\n\n\t\trequire(block.timestamp >= p.periodStart, \"pool not open\");\n\t\trequire(amount.add(balanceOf(msg.sender, pool)) <= p.maxStake, \"stake exceeds max\");\n\n\t\tsuper.stake(pool, amount);\n\t\temit Staked(msg.sender, pool, amount);\n\t}\n\n\t// override PoolTokenWrapper's withdraw() function\n\tfunction withdraw(uint256 pool, uint256 amount) public poolExists(pool) updateReward(msg.sender, pool) {\n\t\trequire(amount > 0, \"cannot withdraw 0\");\n\n\t\tsuper.withdraw(pool, amount);\n\t\temit Withdrawn(msg.sender, pool, amount);\n\t}\n\n\t// override PoolTokenWrapper's transfer() function\n\tfunction transfer(\n\t\tuint256 fromPool,\n\t\tuint256 toPool,\n\t\tuint256 amount\n\t)\n\t\tpublic\n\t\tpoolExists(fromPool)\n\t\tpoolExists(toPool)\n\t\tupdateReward(msg.sender, fromPool)\n\t\tupdateReward(msg.sender, toPool)\n\t\twhenNotPaused()\n\t{\n\t\tPool memory toP = pools[toPool];\n\n\t\trequire(block.timestamp >= toP.periodStart, \"pool not open\");\n\t\trequire(amount.add(balanceOf(msg.sender, toPool)) <= toP.maxStake, \"stake exceeds max\");\n\n\t\tsuper.transfer(fromPool, toPool, amount);\n\t\temit Transferred(msg.sender, fromPool, toPool, amount);\n\t}\n\n\tfunction transferAll(uint256 fromPool, uint256 toPool) external {\n\t\ttransfer(fromPool, toPool, balanceOf(msg.sender, fromPool));\n\t}\n\n\tfunction exit(uint256 pool) external {\n\t\twithdraw(pool, balanceOf(msg.sender, pool));\n\t}\n\n\tfunction redeem(uint256 pool, uint256 card)\n\t\tpublic\n\t\tpayable\n\t\tpoolExists(pool)\n\t\tcardExists(pool, card)\n\t\tupdateReward(msg.sender, pool)\n\t{\n\t\tPool storage p = pools[pool];\n\t\tCard memory c = p.cards[card];\n\t\trequire(block.timestamp >= c.releaseTime, \"card not released\");\n\t\trequire(p.points[msg.sender] >= c.points, \"not enough pineapples\");\n\t\trequire(msg.value == c.mintFee, \"support our artists, send eth\");\n\n\t\tif (c.mintFee > 0) {\n\t\t\tuint256 _controllerShare = msg.value.mul(p.controllerShare).div(1000);\n\t\t\tuint256 _artistRoyalty = msg.value.sub(_controllerShare);\n\t\t\trequire(_artistRoyalty.add(_controllerShare) == msg.value, \"problem with fee\");\n\n\t\t\tp.feesCollected = p.feesCollected.add(c.mintFee);\n\t\t\tpendingWithdrawals[controller] = pendingWithdrawals[controller].add(_controllerShare);\n\t\t\tpendingWithdrawals[p.artist] = pendingWithdrawals[p.artist].add(_artistRoyalty);\n\t\t}\n\n\t\tp.points[msg.sender] = p.points[msg.sender].sub(c.points);\n\t\tp.spentPineapples = p.spentPineapples.add(c.points);\n\t\tmemeLtd.mint(msg.sender, card, 1, \"\");\n\t\temit Redeemed(msg.sender, pool, c.points);\n\t}\n\n\tfunction rescuePineapples(address account, uint256 pool)\n\t\tpublic\n\t\tpoolExists(pool)\n\t\tupdateReward(account, pool)\n\t\treturns (uint256)\n\t{\n\t\trequire(msg.sender == rescuer, \"!rescuer\");\n\t\tPool storage p = pools[pool];\n\n\t\tuint256 earnedPoints = p.points[account];\n\t\tp.spentPineapples = p.spentPineapples.add(earnedPoints);\n\t\tp.points[account] = 0;\n\n\t\t// transfer remaining MEME to the account\n\t\tif (balanceOf(account, pool) > 0) {\n\t\t\t_rescuePineapples(account, pool);\n\t\t}\n\n\t\temit Redeemed(account, pool, earnedPoints);\n\t\treturn earnedPoints;\n\t}\n\n\tfunction setArtist(uint256 pool, address artist) public onlyOwner {\n\t\tuint256 amount = pendingWithdrawals[artist];\n\t\tpendingWithdrawals[artist] = 0;\n\t\tpendingWithdrawals[artist] = pendingWithdrawals[artist].add(amount);\n\t\tpools[pool].artist = artist;\n\n\t\temit UpdatedArtist(pool, artist);\n\t}\n\n\tfunction setController(address _controller) public onlyOwner {\n\t\tuint256 amount = pendingWithdrawals[controller];\n\t\tpendingWithdrawals[controller] = 0;\n\t\tpendingWithdrawals[_controller] = pendingWithdrawals[_controller].add(amount);\n\t\tcontroller = _controller;\n\t}\n\n\tfunction setRescuer(address _rescuer) public onlyOwner {\n\t\trescuer = _rescuer;\n\t}\n\n\tfunction setControllerShare(uint256 pool, uint256 _controllerShare) public onlyOwner poolExists(pool) {\n\t\tpools[pool].controllerShare = _controllerShare;\n\t}\n\n\tfunction addCard(\n\t\tuint256 pool,\n\t\tuint256 id,\n\t\tuint256 points,\n\t\tuint256 mintFee,\n\t\tuint256 releaseTime\n\t) public onlyOwner poolExists(pool) {\n\t\tCard storage c = pools[pool].cards[id];\n\t\tc.points = points;\n\t\tc.releaseTime = releaseTime;\n\t\tc.mintFee = mintFee;\n\t\temit CardAdded(pool, id, points, mintFee, releaseTime);\n\t}\n\n\tfunction createCard(\n\t\tuint256 pool,\n\t\tuint256 supply,\n\t\tuint256 points,\n\t\tuint256 mintFee,\n\t\tuint256 releaseTime\n\t) public onlyOwner poolExists(pool) returns (uint256) {\n\t\tuint256 tokenId = memeLtd.create(supply, 0, \"\", \"\");\n\t\trequire(tokenId > 0, \"ERC1155 create did not succeed\");\n\n\t\tCard storage c = pools[pool].cards[tokenId];\n\t\tc.points = points;\n\t\tc.releaseTime = releaseTime;\n\t\tc.mintFee = mintFee;\n\t\temit CardAdded(pool, tokenId, points, mintFee, releaseTime);\n\t\treturn tokenId;\n\t}\n\n\tfunction createPool(\n\t\tuint256 id,\n\t\tuint256 periodStart,\n\t\tuint256 maxStake,\n\t\tuint256 rewardRate,\n\t\tuint256 controllerShare,\n\t\taddress artist,\n\t\tuint256 boostCardId,\n\t\tuint256 boostAmount\n\t) public onlyOwner returns (uint256) {\n\t\trequire(pools[id].rewardRate == 0, \"pool exists\");\n\n\t\tPool storage p = pools[id];\n\n\t\tp.periodStart = periodStart;\n\t\tp.maxStake = maxStake;\n\t\tp.rewardRate = rewardRate;\n\t\tp.controllerShare = controllerShare;\n\t\tp.artist = artist;\n\t\tp.boostCardId = boostCardId;\n\t\tp.boostAmount = boostAmount;\n\n\t\temit PoolAdded(id, artist, periodStart, rewardRate, maxStake);\n\t}\n\n\tfunction withdrawFee() public {\n\t\tuint256 amount = pendingWithdrawals[msg.sender];\n\t\trequire(amount > 0, \"nothing to withdraw\");\n\t\tpendingWithdrawals[msg.sender] = 0;\n\t\tmsg.sender.transfer(amount);\n\t}\n}"
    }
  }
}