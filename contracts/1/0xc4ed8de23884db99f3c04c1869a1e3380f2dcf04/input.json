{"language":"Solidity","settings":{"libraries":{"Strings.sol":{"Strings":"0xdbedc4ee481be454dc3ecd2f9b00e9315467a483"},"Introspection.sol":{"Introspection":"0x3cce081280060811889b63b98bf3d607029cc802"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Allowlist.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\nimport \"./Strings.sol\";\nimport \"./Introspection.sol\";\n\n/*******************************************************\n *                      Interfaces\n *******************************************************/\ninterface IAllowlistFactory {\n  function protocolOwnerAddressByOriginName(string memory originName)\n    external\n    view\n    returns (address ownerAddress);\n}\n\n/*******************************************************\n *                      Core Logic\n *******************************************************/\ncontract Allowlist {\n  /**\n   * methodName: Name of the method to validate (ie. \"approve\")\n   * paramTypes: Param types of the method to validate (ie. [\"address\", \"uint256\"])\n   * requirements: Array of requirements, where a requirement is as follows:\n   *    Element 0: Requirement type (ie. \"target\" or \"param\")\n   *    Element 1: Method name of validation method (ie. \"isVaultToken\")\n   *    Element 2: Index of param to test as a string. Only applicable where requirement type is \"param\" (ie. \"0\")\n   */\n  struct Condition {\n    string methodName;\n    string[] paramTypes;\n    string[][] requirements;\n    address implementationAddress;\n  }\n\n  Condition[] public conditions; // Array of conditions per protocol (managed by protocol owner)\n  string public protocolOriginName; // Domain name of protocol (ie. \"yearn.finance\")\n  address public rootAllowlistAddress; // Address of root allowlist (parent/factory)\n\n  /**\n   * Initialize the contract (this will only be called by proxy)\n   */\n  function initialize(string memory _protocolOriginName) public {\n    require(\n      rootAllowlistAddress == address(0),\n      \"Contract is already initialized\"\n    );\n    rootAllowlistAddress = msg.sender;\n    protocolOriginName = _protocolOriginName;\n  }\n\n  /*******************************************************\n   *                     Owner logic\n   *******************************************************/\n  modifier onlyOwner() {\n    require(\n      msg.sender == ownerAddress() || msg.sender == address(0),\n      \"Caller is not the protocol owner\"\n    );\n    _;\n  }\n\n  function ownerAddress() public view returns (address protcolOwnerAddress) {\n    protcolOwnerAddress = IAllowlistFactory(rootAllowlistAddress)\n      .protocolOwnerAddressByOriginName(protocolOriginName);\n  }\n\n  /*******************************************************\n   *                   Condition CRUD Logic\n   *******************************************************/\n  function addCondition(Condition memory condition) public onlyOwner {\n    validateCondition(condition);\n    conditions.push(condition);\n  }\n\n  function addConditions(Condition[] memory _conditions) public onlyOwner {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < _conditions.length;\n      conditionIdx++\n    ) {\n      Condition memory condition = _conditions[conditionIdx];\n      addCondition(condition);\n    }\n  }\n\n  function addConditionWithoutValidation(Condition memory condition)\n    public\n    onlyOwner\n  {\n    conditions.push(condition);\n  }\n\n  function addConditionsWithoutValidation(Condition[] memory _conditions)\n    public\n    onlyOwner\n  {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < _conditions.length;\n      conditionIdx++\n    ) {\n      Condition memory condition = _conditions[conditionIdx];\n      addCondition(condition);\n    }\n  }\n\n  function deleteCondition(uint256 conditionIdx) public onlyOwner {\n    Condition memory lastCondition = conditions[conditions.length - 1];\n    conditions[conditionIdx] = lastCondition;\n    conditions.pop();\n  }\n\n  function deleteAllConditions() public onlyOwner {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < conditions.length;\n      conditionIdx++\n    ) {\n      conditions.pop();\n    }\n  }\n\n  function updateCondition(uint256 conditionIdx, Condition memory condition)\n    public\n    onlyOwner\n  {\n    deleteCondition(conditionIdx);\n    addCondition(condition);\n  }\n\n  function conditionsList() public view returns (Condition[] memory test) {\n    Condition[] memory _conditions = new Condition[](conditions.length);\n    for (\n      uint256 conditionIdx;\n      conditionIdx < conditions.length;\n      conditionIdx++\n    ) {\n      _conditions[conditionIdx] = conditions[conditionIdx];\n    }\n    return _conditions;\n  }\n\n  function conditionsLength() public view returns (uint256) {\n    return conditions.length;\n  }\n\n  /*******************************************************\n   *                Condition Validation Logic\n   *******************************************************/\n  function validateCondition(Condition memory condition) public view {\n    string[][] memory requirements = condition.requirements;\n\n    for (\n      uint256 requirementIdx;\n      requirementIdx < requirements.length;\n      requirementIdx++\n    ) {\n      string[] memory requirement = requirements[requirementIdx];\n      string memory requirementType = requirement[0];\n      string memory requirementValidationMethod = requirement[1];\n      string memory methodSignature;\n      string memory paramType;\n      bool requirementTypeIsTarget = Strings.stringsEqual(\n        requirementType,\n        \"target\"\n      );\n      bool requirementTypeIsParam = Strings.stringsEqual(\n        requirementType,\n        \"param\"\n      );\n      if (requirementTypeIsTarget) {\n        require(\n          requirement.length == 2,\n          \"Requirement length must be equal to 2\"\n        );\n        methodSignature = string(\n          abi.encodePacked(requirementValidationMethod, \"(address)\")\n        );\n      } else if (requirementTypeIsParam) {\n        require(\n          requirement.length == 3,\n          \"Requirement length must be equal to 3\"\n        );\n        uint256 paramIdx = Strings.atoi(requirement[2], 10);\n        require(\n          paramIdx <= condition.paramTypes.length - 1,\n          \"Requirement parameter index is out of range\"\n        );\n        paramType = condition.paramTypes[paramIdx];\n        methodSignature = string(\n          abi.encodePacked(requirementValidationMethod, \"(\", paramType, \")\")\n        );\n      } else {\n        revert(\"Unsupported requirement type\");\n      }\n\n      address implementationAddress = condition.implementationAddress;\n      require(\n        implementationAddress != address(0),\n        \"Implementation address is not set\"\n      );\n\n      bool implementsInterface = Introspection.implementsMethodSignature(\n        implementationAddress,\n        methodSignature\n      );\n      require(\n        implementsInterface == true,\n        \"Implementation does not implement method selector\"\n      );\n    }\n  }\n\n  function validateConditions() public view {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < conditions.length;\n      conditionIdx++\n    ) {\n      Condition memory condition = conditions[conditionIdx];\n      validateCondition(condition);\n    }\n  }\n\n  function implementationValid() public view returns (bool) {\n    (bool success, ) = address(this).staticcall(\n      abi.encodeWithSignature(\"validateConditions()\")\n    );\n    return success;\n  }\n}\n"},"Introspection.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary Introspection {\n  // function implementsMethodNameAndParamTypes(string memory methodName, string[])\n  function implementsMethodSignature(address _address, string memory _signature)\n    public\n    view\n    returns (bool)\n  {\n    bytes4 _selector = bytes4(keccak256(bytes(_signature)));\n    uint256 contractSize;\n    assembly {\n      contractSize := extcodesize(_address)\n    }\n    bytes memory code = new bytes(contractSize);\n    assembly {\n      extcodecopy(_address, add(code, 0x20), 0, contractSize)\n    }\n    uint256 ptr = 0;\n    while (ptr < contractSize) {\n      // PUSH4 0x000000 (selector)\n      if (code[ptr] == 0x63) {\n        bytes memory selectorBytes = new bytes(64);\n        selectorBytes[0] = code[ptr + 1];\n        selectorBytes[1] = code[ptr + 2];\n        selectorBytes[2] = code[ptr + 3];\n        selectorBytes[3] = code[ptr + 4];\n        bytes4 selector = abi.decode(selectorBytes, (bytes4));\n        if (selector == _selector) {\n          return true;\n        }\n      }\n      ptr++;\n    }\n    return false;\n  }\n\n  function implementsInterface(address _address, string[] memory _interface)\n    public\n    view\n    returns (bool)\n  {\n    for (uint256 methodIdx = 0; methodIdx < _interface.length; methodIdx++) {\n      string memory method = _interface[methodIdx];\n      bool methodIsImplemented = implementsMethodSignature(_address, method);\n      if (!methodIsImplemented) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"},"Strings.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary Strings {\n  /**\n   * @notice Search for a needle in a haystack\n   * @param haystack The string to search\n   * @param needle The string to search for\n   */\n  function stringStartsWith(string memory haystack, string memory needle)\n    public\n    pure\n    returns (bool)\n  {\n    return indexOfStringInString(needle, haystack) == 0;\n  }\n\n  /**\n   * @notice Case insensitive string search\n   * @param needle The string to search for\n   * @param haystack The string to search\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\n   */\n  function indexOfStringInString(string memory needle, string memory haystack)\n    public\n    pure\n    returns (int256)\n  {\n    bytes memory _needle = bytes(needle);\n    bytes memory _haystack = bytes(haystack);\n    if (_haystack.length < _needle.length) {\n      return -1;\n    }\n    bool _match;\n    for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\n      for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\n        uint8 needleChar = uint8(_needle[needleIdx]);\n        if (haystackIdx + needleIdx >= _haystack.length) {\n          return -1;\n        }\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\n        if (needleChar == haystackChar) {\n          _match = true;\n          if (needleIdx == _needle.length - 1) {\n            return int256(haystackIdx);\n          }\n        } else {\n          _match = false;\n          break;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * @notice Check to see if two strings are exactly equal\n   */\n  function stringsEqual(string memory input1, string memory input2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 input1Length = bytes(input1).length;\n    uint256 input2Length = bytes(input2).length;\n    uint256 maxLength;\n    if (input1Length > input2Length) {\n      maxLength = input1Length;\n    } else {\n      maxLength = input2Length;\n    }\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\n    bytes32 input1Bytes32;\n    bytes32 input2Bytes32;\n    for (uint256 rowIdx; rowIdx < numberOfRowsToCompare; rowIdx++) {\n      uint256 offset = 0x20 * (rowIdx + 1);\n      assembly {\n        input1Bytes32 := mload(add(input1, offset))\n        input2Bytes32 := mload(add(input2, offset))\n      }\n      if (input1Bytes32 != input2Bytes32) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function atoi(string memory a, uint8 base) public pure returns (uint256 i) {\n    require(base == 2 || base == 8 || base == 10 || base == 16);\n    bytes memory buf = bytes(a);\n    for (uint256 p = 0; p < buf.length; p++) {\n      uint8 digit = uint8(buf[p]) - 0x30;\n      if (digit > 10) {\n        digit -= 7;\n      }\n      require(digit < base);\n      i *= base;\n      i += digit;\n    }\n    return i;\n  }\n\n  function itoa(uint256 i, uint8 base) public pure returns (string memory a) {\n    require(base == 2 || base == 8 || base == 10 || base == 16);\n    if (i == 0) {\n      return \"0\";\n    }\n    bytes memory buf = new bytes(256);\n    uint256 p = 0;\n    while (i > 0) {\n      uint8 digit = uint8(i % base);\n      uint8 ascii = digit + 0x30;\n      if (digit > 9) {\n        ascii += 7;\n      }\n      buf[p++] = bytes1(ascii);\n      i /= base;\n    }\n    uint256 length = p;\n    for (p = 0; p < length / 2; p++) {\n      buf[p] ^= buf[length - 1 - p];\n      buf[length - 1 - p] ^= buf[p];\n      buf[p] ^= buf[length - 1 - p];\n    }\n    return string(buf);\n  }\n}\n"}}}