{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AirdropTestToken.sol": {
      "content": "/**\r\n * SPDX-License-Identifier: UNLICENSED;\r\n *\r\n *\r\n *    db    88 88\"\"Yb 8888b.  88\"\"Yb  dP\"Yb  88\"\"Yb     888888 888888 .dP\"Y8 888888 \r\n *   dPYb   88 88__dP  8I  Yb 88__dP dP   Yb 88__dP       88   88__   `Ybo.\"   88   \r\n *  dP__Yb  88 88\"Yb   8I  dY 88\"Yb  Yb   dP 88\"\"\"        88   88\"\"   o.`Y8b   88   \r\n * dP\"\"\"\"Yb 88 88  Yb 8888Y\"  88  Yb  YbodP  88           88   888888 8bodP'   88   \r\n * 888888  dP\"Yb  88  dP 888888 88b 88                                              \r\n *   88   dP   Yb 88odP  88__   88Yb88                                              \r\n *   88   Yb   dP 88\"Yb  88\"\"   88 Y88                                              \r\n *   88    YbodP  88  Yb 888888 88  Y8    \r\n *\r\n * This is a test token. Usage on own risk. This is not an investment, security or anything like that.\r\n * \r\n * Tutorial:\r\n * 1) Run requestAirdrop()\r\n * 2) Wait :)\r\n * PRO TIP: Donate 0.1 ETH for 1 or more entries!\r\n */\r\n\r\n\r\npragma solidity 0.8.0;\r\n\r\ncontract AirdropTestToken {\r\n    \r\n    /**\r\n     * @dev Always use this to ensure that the msg.sender is always payable.\r\n     */\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev A modifier to only allow function calls by the owner.\r\n     */\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender, \"AirdropTestToken: You're not the owner.\");\r\n        _;\r\n    }\r\n\r\n    mapping (address => uint256) private _balances;\r\n\tmapping (address => uint256) private _lockedBalances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 private _maxSupply;\r\n    \r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n\tuint UNIT;\r\n\tuint public reward;\r\n\tbool public airdropActive;\r\n\r\n\taddress public owner;\r\n\r\n\tuint nextReceiver;\r\n\tuint receiversCount;\r\n\tmapping(uint => address) receivers;\r\n\tmapping(address => uint) received;\r\n\tmapping(address => bool) isDonator;\r\n\tmapping(address => uint) lastClaimed;\r\n\r\n\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    /**\r\n     * @dev Emitted when an Airdrop is rewarded.\r\n     */\r\n    event Airdrop(address indexed receiver, uint amount);\r\n    \r\n    /**\r\n     * @dev Emitted when an tokens are burned.\r\n     */\r\n    event Burn(address indexed burner, uint amount);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n    /**\r\n     * Emitted when the owner sends a message.\r\n     */\r\n    event OwnerMessage(string message);\r\n\r\n    /**\r\n     * @dev Initialize the project and define the project name, symbol, decimals,\r\n     * totalSupply, owner and the price for the shovels.\r\n     * Note: There are no pre-mined tokens.\r\n     */\r\n    constructor () {\r\n        airdropActive = true;\r\n        _name = \"AirdropTestToken\";\r\n        _symbol = \"ATT\";\r\n        _decimals = 18;\r\n\t\tUNIT = 10 ** _decimals;\r\n\t\treward = 1000 * UNIT;\r\n\t\towner = msg.sender;\r\n\t\tnextReceiver = 1;\r\n\r\n\t\t// Set the total supply to 100.000\r\n        _totalSupply = 0;\r\n\t\t_maxSupply = 9600000 * UNIT;\r\n\r\n\t\t// Add this to owners balance\r\n\t\t_mint(msg.sender, 100000 * UNIT);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Basic ERC20 getters\r\n     *  Get the decimals, totalSupply, name and symbol of the token and\r\n     * get the balances and allowances of specific addresses.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n\t// @dev Return the _totalSupply\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n\t// @dev Return the token balance of account_\r\n    function balanceOf(address account_) public view returns (uint256) {\r\n        return _balances[account_];\r\n    }\r\n\r\n\t// @dev Returns the locked token balance of account_\r\n    function lockedBalanceOf(address account_) public view returns (uint256) {\r\n        return _lockedBalances[account_];\r\n    }\r\n    \r\n\t// @dev Return the allowance of spender_ of owner_\r\n    function allowance(address owner_, address spender_) public view virtual returns (uint256) {\r\n        return _allowances[owner_][spender_];\r\n    }\r\n    \r\n\t// @dev Return the token name\r\n    function name() public view returns (string memory name_) {\r\n        return _name;\r\n    }\r\n    \r\n\t// @dev Return the token symbol\r\n    function symbol() public view returns (string memory symbol_) {\r\n        return _symbol;\r\n    }\r\n\r\n\t// @dev Return who's next\r\n\tfunction getNextReceiver() public view returns (uint nextReceiver_) {\r\n        return nextReceiver;\r\n    }\r\n\r\n\t// @dev Return the address behind `receiverAddress[id_]`\r\n\tfunction getReceiver(uint id_) public view returns (address receiverAddress_) {\r\n        return receivers[id_];\r\n    }\r\n\r\n\t// @dev Return how much `address_` has been airdropped to\r\n\tfunction getTotalReceivers() public view returns (uint receiversCount_) {\r\n        return receiversCount;\r\n    }\r\n    \r\n    // @dev Return how much total airdrops are/will be\r\n\tfunction getReceived(address address_) public view returns (uint received_) {\r\n        return received[address_];\r\n    }\r\n\r\n\t// @dev Return how much `address_` has been airdropped to\r\n\tfunction checkIsDonator(address address_) public view returns (bool isDonator_) {\r\n        return isDonator[address_];\r\n    }\r\n\t\r\n\r\n\t// @dev Create a new Airdrop request\r\n    receive() payable external {\r\n        requestAirdrop();\r\n    }\r\n    \r\n    // @dev Revert when no function is called and no eth are sent.\r\n    fallback() external {\r\n        revert();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Transfer `amount_` tokens from _msgSender() (msg.sender) to `recipient_`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient_, uint256 amount_) public returns (bool) {\r\n        _transfer(_msgSender(), recipient_, amount_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow `spender_` to spend `amount_` of tokens of _msgSender() (msg.sender)\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender_, uint256 amount_) public returns (bool) {\r\n        _approve(_msgSender(), spender_, amount_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `amount_` tokens from `sender_` to `recipient_`\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender_` and `recipient_` cannot be the zero address.\r\n     * - `sender_` must have a balance of at least `amount_`.\r\n     * - the caller must have allowance for ``sender_``'s tokens of at least `amount_`.\r\n     */\r\n    function transferFrom(address sender_, address recipient_, uint256 amount_) public returns (bool) {\r\n        _transfer(sender_, recipient_, amount_);\r\n        _approve(sender_, _msgSender(), _allowances[sender_][_msgSender()] - amount_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender_` by the caller.\r\n     *\r\n     * This is an alternative to {approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender_` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender_, uint256 addedValue_) public returns (bool) {\r\n        _approve(_msgSender(), spender_, _allowances[_msgSender()][spender_] + addedValue_);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender_` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender_` cannot be the zero address.\r\n     * - `spender_` must have allowance for the caller of at least\r\n     * `subtractedValue_`.\r\n     */\r\n    function decreaseAllowance(address spender_, uint256 subtractedValue_) public returns (bool) {\r\n        _approve(_msgSender(), spender_, _allowances[_msgSender()][spender_] - subtractedValue_);\r\n        return true;\r\n    }\r\n\r\n\t/**\r\n\t * @dev Lock `_amount` tokens and burn them.\r\n\t * @notice Warning! Token locks have NO FUNCTIONALITY BESIDES UPGRADING! DO NOT LOCK IF NOT NEEDED!\r\n\t */\r\n\tfunction lockTokens(uint _amount) public returns(bool) {\r\n\t\t_lockedBalances[_msgSender()] += _amount;\r\n\t\t_burn(_msgSender(), _amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Request an AirDrop\r\n\t * If msg.sender sends eth, get more AirDrops per 0.1 ETH.\r\n\t * Require to only pay in 0.001 incrementals.\r\n\t * Note: The price is on purpose set to a high price - to prevent spamming and to only allow generous people to use this :)\r\n\t */\r\n\tfunction requestAirdrop() payable public returns(bool) {\r\n\t    // Check if airdrop is enabled\r\n\t    require(airdropActive, \"AirdropTestToken: Airdrop is over.\");\r\n\t    \r\n\t    // Airdrop to the next 3 addresses\r\n\t    for(uint i = 1; i <= 3; i++) {\r\n\t        if(receivers[nextReceiver] != address(0)) {\r\n\t            // Reward the Airdrop\r\n    \t\t\t_mint(receivers[nextReceiver], reward);\r\n    \t\t\t\r\n    \t\t\t// Give 10 tokens (1%) to the owner\r\n    \t\t\t_mint(owner, 10 * UNIT);\r\n    \t\t\treceived[receivers[nextReceiver]] += reward;\r\n    \t\t\tnextReceiver++;\r\n    \t\t\temit Airdrop(receivers[nextReceiver], reward);\r\n    \t\t}\r\n\t    }\r\n\t\t\r\n\t\t// Add multiple requests when donating\r\n\t\tuint requestMultiplier_ = 1;\r\n\t\tuint donationSteps_ = 100000000000000000; // 0.1 ETH\r\n\t\t\r\n\t\t// Check if user is donating\r\n\t\tif(msg.value >= 1) {\r\n\r\n\t\t\t// Only send in 0.1 steps (0.1, 0.2, 0.5, etc.)\r\n\t\t\tuint remain_ = msg.value % donationSteps_;\r\n\t\t\trequire(remain_ == 0, \"AirdropTestToken: Please send ETH only in 0.1 steps.\");\r\n\t\t\t\r\n\t\t\tisDonator[_msgSender()] = true;\r\n\r\n\t\t\t// Calculate how much additional entries msg.sender gets\r\n\t\t\trequestMultiplier_ = msg.value / donationSteps_;\r\n\t\t\trequestMultiplier_ = requestMultiplier_ * 2;\r\n\t\t\tfor(uint i = 1; i <= requestMultiplier_; i++) {\r\n\t\t\t\treceiversCount++;\r\n\t\t\t\treceivers[receiversCount] = _msgSender();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t    // Reserve 5% of the Airdrop capacity for donating users\r\n\t\t\trequire(_totalSupply <= _maxSupply - _totalSupply / 5, \"AirdropTestToken: Last 5% supply reserved for donating users.\");\r\n\t\t\t\r\n\t\t\t// Only allow one airdrop per hour and address\r\n\t\t\trequire(block.timestamp - lastClaimed[msg.sender] >= 3600, \"AirdropTestToken: You can only get an Airdrop once an hour. Donate to get more.\");\r\n\t\t}\r\n\t\treceiversCount++;\r\n\t\treceivers[receiversCount] = _msgSender();\r\n\t\tlastClaimed[msg.sender] = block.timestamp;\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n     * @dev Withdraws the current balance\r\n     */\r\n    function withdraw() payable public onlyOwner {\r\n        _msgSender().call{value: address(this).balance}(\"\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Disables the airdrop function.\r\n     */\r\n    function status() public onlyOwner {\r\n        if(airdropActive == true) {\r\n            airdropActive = false;\r\n        }\r\n        else {\r\n            airdropActive = true;\r\n        }\r\n    }\r\n\r\n\t/**\r\n     * @dev emits an {OwnerMessage} event with message `message_`\r\n     * This is used for communication only.\r\n     * No otherwise usage.\r\n\t * May use twitter 'n stuff instead lol.\r\n     */\r\n    function ownerMessage(string memory message_) public onlyOwner {\r\n        emit OwnerMessage(message_);\r\n    }\r\n    \r\n    /**\r\n     * @dev Send (accidentally) to the smart contract sent tokens to the owner.\r\n     * Note: The owner CAN NOT send AirdropTest tokens as long as the CONTRACT does not hold them.\r\n     */\r\n    function transferERC20(address token_) public {\r\n        uint amount_ = IERC20(token_).balanceOf(address(this));\r\n        IERC20(token_).transfer(owner, amount_);\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender_, address recipient_, uint256 amount_) internal {\r\n        require(sender_ != address(0), \"AirdropTestToken: transfer from the zero address\");\r\n        require(recipient_ != address(0), \"AirdropTestToken: transfer to the zero address\");\r\n\r\n        _balances[sender_] = _balances[sender_] - amount_;\r\n        _balances[recipient_] = _balances[recipient_] + amount_;\r\n        emit Transfer(sender_, recipient_, amount_);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account_, uint256 amount_) internal {\r\n        require(account_ != address(0), \"AirdropTestToken: mint to the zero address\");\r\n        require(_totalSupply + amount_ <= _maxSupply, \"AirdropTestToken: Amount to mint exceeds max supply.\");\r\n\r\n        _totalSupply = _totalSupply + amount_;\r\n        _balances[account_] = _balances[account_] + amount_;\r\n        emit Transfer(address(0), account_, amount_);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account_, uint256 amount_) internal {\r\n        require(account_ != address(0), \"AirdropTestToken: burn from the zero address\");\r\n        _balances[account_] = _balances[account_] - amount_;\r\n        _totalSupply = _totalSupply - amount_;\r\n        _maxSupply = _maxSupply - amount_;\r\n        emit Transfer(account_, address(0), amount_);\r\n        emit Burn(account_, amount_);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount_` as the allowance of `spender_` over the `owner_` s tokens.\r\n     *\r\n     * This internal function is equivalent to {approve}, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner_` cannot be the zero address.\r\n     * - `spender_` cannot be the zero address.\r\n     */\r\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\r\n        require(owner_ != address(0), \"AirdropTestTokenRC20: approve from the zero address\");\r\n        require(spender_ != address(0), \"AirdropTestToken: approve to the zero address\");\r\n\r\n        _allowances[owner_][spender_] = amount_;\r\n        emit Approval(owner_, spender_, amount_);\r\n    }\r\n    \r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient_, uint256 amount_) external returns(bool);\r\n    function balanceOf(address account_) external view returns (uint256);\r\n}"
    }
  }
}