{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "EU21_Marketing.sol": {
      "content": "pragma solidity >=0.7.0;\n\n// SPDX-License-Identifier: BSD-3-Clause\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner ;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor()  {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n}\n\n\ninterface Token {\n    function transferFrom(address, address, uint) external returns (bool);\n    function transfer(address, uint) external returns (bool);\n}\n\ncontract EU21_Marketing is Ownable {\n    using SafeMath for uint;\n    \n    // token contract address\n    address public constant tokenAddress = 0x87ea1F06d7293161B9ff080662c1b0DF775122D3;\n    \n    uint256 public tokens = 0;\n    uint256 public tokensToUnlock ;\n    \n    bool public firstWith =  false;\n    bool public secondWith = false;\n    bool public thirdWith =  false;\n    bool public fourthWith =  false;\n    bool public fiveWith =  false;\n    bool public sixWith =  false;\n    uint256 public relaseTime = 5 days;\n    uint256 public relaseTime2 = 10 days;\n    uint256 public relaseTime3 = 15 days;\n    uint256 public relaseTime4 = 20 days;\n    uint256 public relaseTime5 = 25 days;\n    uint256 public relaseTime6 = 30 days;\n    uint256 public timing ;\n    \n\n    function getTiming()  public view returns (uint256){\n        return block.timestamp.sub(timing);\n    }\n    \n    function deposit(uint amountToStake) public onlyOwner{\n        require( tokens == 0, \"Cannot deposit more Tokens\");\n        require( amountToStake > 0, \"Cannot deposit  Tokens\");\n        \n        require(Token(tokenAddress).transferFrom(msg.sender, address(this), amountToStake), \"Insufficient Token Allowance\");\n        tokens = amountToStake;\n        tokensToUnlock = amountToStake.div(6);\n        firstWith = true;\n        timing = block.timestamp;\n        \n        }\n    \n    function withdraw1() public onlyOwner{\n        require( firstWith, \"Deposit first\");\n        require(block.timestamp.sub(timing)>relaseTime, \"Not yet\");\n        \n        firstWith = false;\n        secondWith = true;\n        require(Token(tokenAddress).transfer(owner, tokensToUnlock), \"Could not transfer tokens.\");\n        tokens = tokens.sub(tokensToUnlock);\n        \n        }\n    \n    \n    function withdraw2() public onlyOwner{\n        require( secondWith, \"With1 first\");\n        require(block.timestamp.sub(timing)>relaseTime2, \"Not yet\");\n        \n        secondWith = false;\n        thirdWith = true;\n        require(Token(tokenAddress).transfer(owner, tokensToUnlock), \"Could not transfer tokens.\");\n        tokens = tokens.sub(tokensToUnlock);  \n        \n        }\n        \n    function withdraw3() public onlyOwner{\n        require( thirdWith, \"With2 first\");\n        require(block.timestamp.sub(timing)>relaseTime3, \"Not yet\");\n        \n        thirdWith = false;\n        fourthWith = true;\n        require(Token(tokenAddress).transfer(owner, tokensToUnlock), \"Could not transfer tokens.\");\n        tokens = tokens.sub(tokensToUnlock); \n        }\n        \n    function withdraw4() public onlyOwner{\n        require( fourthWith, \"With3 first\");\n        require(block.timestamp.sub(timing)>relaseTime4, \"Not yet\");\n        \n        fourthWith = false;\n        fiveWith = true;\n        require(Token(tokenAddress).transfer(owner, tokensToUnlock), \"Could not transfer tokens.\");\n        tokens = tokens.sub(tokensToUnlock); \n    }\n    \n    function withdraw5() public onlyOwner{\n        require( fiveWith, \"With4 first\");\n        require(block.timestamp.sub(timing)>relaseTime5, \"Not yet\");\n        \n        fiveWith = false;\n        sixWith = true;\n        require(Token(tokenAddress).transfer(owner, tokensToUnlock), \"Could not transfer tokens.\");\n        tokens = tokens.sub(tokensToUnlock);\n        }\n        \n    function withdraw6() public onlyOwner{\n        require( sixWith, \"With5 first\");\n        require(block.timestamp.sub(timing)>relaseTime6, \"Not yet\");\n        \n        sixWith = false;\n        require(Token(tokenAddress).transfer(owner, tokensToUnlock), \"Could not transfer tokens.\");\n        tokens = tokens.sub(tokensToUnlock);  \n        }\n    \n    \n    \n    \n    }"
    }
  }
}