{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "bsb2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.4;\n\n// Interfaces for contract interaction\ninterface INterfaces {\n    function balanceOf(address) external returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function allowance(address, address) external returns (uint256);\n\n    //usdc\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// USDT is not ERC-20 compliant, not returning true on transfers\ninterface IUsdt {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\n// BigShortBets.com presale contract - via StableCoins and ETH\n//\n// USE ONLY OWN WALLET (Metamask, Trezor, Ledger...)\n// DO NOT SEND FROM EXCHANGES OR ANY SERVICES\n//\n// Use ONLY ETH network, ERC20 tokens (Not Binance/Tron/whatever!)\n//\n// Set approval to contract address or use USDC authorization first\n//\n// DO NOT SEND STABLE TOKENS DIRECTLY - IT WILL NOT COUNT THAT!\n//\n// send ONLY round number of USD(c|t)/DAI!\n// ie 20, 500, 2000 NOT 20.1, 500.5, 2000.3\n// contract will ignore decimals\n//\n// Need 150k gas limit\n// use proper pay* function\ncontract BigShortBetsPresale2 {\n    // max USD per user\n    uint256 private immutable _maxUsd;\n    // soft limit USD total\n    uint256 private immutable _limitUsd;\n    // max ETH per user\n    uint256 private immutable _maxEth;\n    // soft limit ETH total\n    uint256 private immutable _limitEth;\n    // contract starts accepting transfers\n    uint256 private immutable _dateStart;\n    // hard time limit\n    uint256 private immutable _dateEnd;\n\n    // total collected USD\n    uint256 private _usdCollected;\n\n    uint256 private constant DECIMALS_DAI = 18;\n    uint256 private constant DECIMALS_USDC = 6;\n    uint256 private constant DECIMALS_USDT = 6;\n\n    // addresses of tokens\n    address private immutable usdt;\n    address private immutable usdc;\n    address private immutable dai;\n\n    address public owner;\n    address public newOwner;\n\n    bool private _presaleEnded;\n\n    // deposited per user\n    mapping(address => uint256) private _usdBalance;\n    mapping(address => uint256) private _ethBalance;\n\n    // deposited per tokens\n    mapping(address => uint256) private _deposited;\n\n    // will be set after presale\n    uint256 private _tokensPerEth;\n\n    string private constant ERROR_ANS = \"Approval not set!\";\n\n    event AcceptedUSD(address indexed user, uint256 amount);\n    event AcceptedETH(address indexed user, uint256 amount);\n\n    constructor(\n        address _owner,\n        uint256 maxUsd,\n        uint256 limitUsd,\n        uint256 maxEth,\n        uint256 limitEth,\n        uint256 startDate,\n        uint256 endDate,\n        address _usdt,\n        address _usdc,\n        address _dai\n    ) {\n        owner = _owner;\n        _maxUsd = maxUsd;\n        _limitUsd = limitUsd;\n        _maxEth = maxEth;\n        _limitEth = limitEth;\n        _dateStart = startDate;\n        _dateEnd = endDate;\n        usdt = _usdt;\n        usdc = _usdc;\n        dai = _dai;\n\n        /**\n        mainnet:\n        usdt=0xdAC17F958D2ee523a2206206994597C13D831ec7;\n        usdc=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n        dai=0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        */\n    }\n\n    //pay in using USDC\n    //need prepare and sign approval first\n    //not included in dapp\n    function payUsdcByAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(to == address(this), \"Wrong authorization address\");\n        // should throw on any error\n        INterfaces(usdc).transferWithAuthorization(\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n        // not msg.sender, approval can be sent by anyone\n        _pay(from, value, DECIMALS_USDC);\n        _deposited[usdc] += value;\n    }\n\n    //pay in using USDC\n    //use approve/transferFrom\n    function payUSDC(uint256 amount) external {\n        require(\n            INterfaces(usdc).allowance(msg.sender, address(this)) >= amount,\n            ERROR_ANS\n        );\n        require(\n            INterfaces(usdc).transferFrom(msg.sender, address(this), amount),\n            \"USDC transfer failed\"\n        );\n        _pay(msg.sender, amount, DECIMALS_USDC);\n        _deposited[usdc] += amount;\n    }\n\n    //pay in using USDT\n    //need set approval first\n    function payUSDT(uint256 amount) external {\n        require(\n            INterfaces(usdt).allowance(msg.sender, address(this)) >= amount,\n            ERROR_ANS\n        );\n        IUsdt(usdt).transferFrom(msg.sender, address(this), amount);\n        _pay(msg.sender, amount, DECIMALS_USDT);\n        _deposited[usdt] += amount;\n    }\n\n    //pay in using DAI\n    //need set approval first\n    function payDAI(uint256 amount) external {\n        require(\n            INterfaces(dai).allowance(msg.sender, address(this)) >= amount,\n            ERROR_ANS\n        );\n        require(\n            INterfaces(dai).transferFrom(msg.sender, address(this), amount),\n            \"DAI transfer failed\"\n        );\n        _pay(msg.sender, amount, DECIMALS_DAI);\n        _deposited[dai] += amount;\n    }\n\n    //direct ETH send will not back\n    //\n    //accept ETH\n\n    // takes about 50k gas\n    receive() external payable {\n        _payEth(msg.sender, msg.value);\n    }\n\n    // takes about 35k gas\n    function payETH() external payable {\n        _payEth(msg.sender, msg.value);\n    }\n\n    function _payEth(address user, uint256 amount) internal notEnded {\n        uint256 amt = _ethBalance[user] + amount;\n        require(amt <= _maxEth, \"ETH per user reached\");\n        _ethBalance[user] += amt;\n        emit AcceptedETH(user, amount);\n    }\n\n    function _pay(\n        address user,\n        uint256 amount,\n        uint256 decimals\n    ) internal notEnded {\n        uint256 usd = amount / (10**decimals);\n        _usdBalance[user] += usd;\n        require(_usdBalance[user] <= _maxUsd, \"USD amount too high\");\n        _usdCollected += usd;\n        emit AcceptedUSD(user, usd);\n    }\n\n    //\n    // external readers\n    //\n    function USDcollected() external view returns (uint256) {\n        return _usdCollected;\n    }\n\n    function ETHcollected() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function USDmax() external view returns (uint256) {\n        return _maxUsd;\n    }\n\n    function USDlimit() external view returns (uint256) {\n        return _limitUsd;\n    }\n\n    function ETHmax() external view returns (uint256) {\n        return _maxEth;\n    }\n\n    function ETHlimit() external view returns (uint256) {\n        return _limitEth;\n    }\n\n    function dateStart() external view returns (uint256) {\n        return _dateStart;\n    }\n\n    function dateEnd() external view returns (uint256) {\n        return _dateEnd;\n    }\n\n    function tokensBoughtOf(address user) external view returns (uint256 amt) {\n        require(_tokensPerEth > 0, \"Tokens/ETH ratio not set yet\");\n        amt = (_usdBalance[user] * 95) / 100;\n        amt += _ethBalance[user] * _tokensPerEth;\n        return amt;\n    }\n\n    function usdDepositOf(address user) external view returns (uint256) {\n        return _usdBalance[user];\n    }\n\n    function ethDepositOf(address user) external view returns (uint256) {\n        return _ethBalance[user];\n    }\n\n    modifier notEnded() {\n        require(!_presaleEnded, \"Presale ended\");\n        require(\n            block.timestamp > _dateStart && block.timestamp < _dateEnd,\n            \"Too soon or too late\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only for contract Owner\");\n        _;\n    }\n\n    modifier timeIsUp() {\n        require(block.timestamp > _dateEnd, \"SOON\");\n        _;\n    }\n\n    function endPresale() external onlyOwner {\n        require(\n            _usdCollected > _limitUsd || address(this).balance > _limitEth,\n            \"Limit not reached\"\n        );\n        _presaleEnded = true;\n    }\n\n    function setTokensPerEth(uint256 ratio) external onlyOwner {\n        require(_tokensPerEth == 0, \"Ratio already set\");\n        _tokensPerEth = ratio;\n    }\n\n    // take out all stables and ETH\n    function takeAll() external onlyOwner timeIsUp {\n        _presaleEnded = true; //just to save gas for ppl that want buy too late\n        uint256 amt = INterfaces(usdt).balanceOf(address(this));\n        if (amt > 0) {\n            IUsdt(usdt).transfer(owner, amt);\n        }\n        amt = INterfaces(usdc).balanceOf(address(this));\n        if (amt > 0) {\n            INterfaces(usdc).transfer(owner, amt);\n        }\n        amt = INterfaces(dai).balanceOf(address(this));\n        if (amt > 0) {\n            INterfaces(dai).transfer(owner, amt);\n        }\n        amt = address(this).balance;\n        if (amt > 0) {\n            payable(owner).transfer(amt);\n        }\n    }\n\n    // we can recover any ERC20 token send in wrong way... for price!\n    function recoverErc20(address token) external onlyOwner {\n        uint256 amt = INterfaces(token).balanceOf(address(this));\n        // do not take deposits\n        amt -= _deposited[token];\n        if (amt > 0) {\n            INterfaces(token).transfer(owner, amt);\n        }\n    }\n\n    // should not be needed, but...\n    function recoverEth() external onlyOwner timeIsUp {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(\n            msg.sender != address(0) && msg.sender == newOwner,\n            \"Only NewOwner\"\n        );\n        newOwner = address(0);\n        owner = msg.sender;\n    }\n}\n\n// rav3n_pl was here\n"
    }
  }
}