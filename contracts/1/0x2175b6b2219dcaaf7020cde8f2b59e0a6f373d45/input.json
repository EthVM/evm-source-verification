{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"OccultMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n// https://kanon.art - K21\r\n// https://daemonica.io\r\n//\r\n//\r\n//                                   $@@@@@@@@@@@$$$\r\n//                               $$@@@@@@$$$$$$$$$$$$$$##\r\n//                           $$$$$$$$$$$$$$$$$#########***\r\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\r\n//                     ##$$$$$$$$$$$$#######****!!!!=========\r\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\r\n//                 *#################*#***!*!!======;;;:::\r\n//                ################********!!!!====;;;:::~~~~~\r\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\r\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\r\n//            ******#**********!*!!!!=!===;;::~~~-,........\r\n//           ***************!*!!!!====;;:::~~-,,..........\r\n//         !************!!!!!!===;;::~~--,............\r\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\r\n//        =!!!!!!!!!=!==;;;::~~-,,...........\r\n//        =!!!!!!!!!====;;;;:::~~--,........\r\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\r\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\r\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\r\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\r\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\r\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\r\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\r\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\r\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\r\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\r\n//          ---~~~-----,,,,,........,---,.\r\n//           ,,--------,,,,,,.........\r\n//             .,,,,,,,,,,,,......\r\n//                ...............\r\n//                    .........\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/*\r\n * @title OccultMath library\r\n * @author @0xAnimist\r\n * @notice Unsafe Math\r\n */\r\nlibrary OccultMath {\r\n\r\n  string public constant defaultTic = \":\";\r\n  string public constant defaultNthPrimeOpen = \"(\";\r\n  string public constant defaultNthPrimeClose = \")\";\r\n  string public constant defaultDeplex = \"-P\";\r\n\r\n  struct Index {\r\n    uint8 i;\r\n    uint8 j;\r\n  }\r\n\r\n\r\n  /** @notice Slices an array\r\n    * @param _array The array\r\n    * @param _length The length of the resulting array\r\n    * @return An array with the first _length values of the input array, _array\r\n    */\r\n  function slice(uint256[] memory _array, uint256 _length) public pure returns (uint256[] memory){\r\n    uint256[] memory output = new uint256[](_length);\r\n\r\n    for (uint256 i = 0; i < _length; i++) {\r\n        output[i] = _array[i];\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n\r\n  /** @notice Square root of a number\r\n    * @param y The number\r\n    * @return z Square root of the number, y\r\n    */\r\n  function sqrt(uint256 y) public pure returns (uint256 z) {\r\n      if (y > 3) {\r\n          z = y;\r\n          uint256 x = y / 2 + 1;\r\n          while (x < z) {\r\n              z = x;\r\n              x = (y / x + x) / 2;\r\n          }\r\n      } else if (y != 0) {\r\n          z = 1;\r\n      }\r\n  }\r\n\r\n\r\n  /** @notice Returns the smallest factor of a number\r\n    * @param _number The number\r\n    * @return Smallest factor of the number, _number\r\n    */\r\n  function smallestFactor(uint _number) public pure returns (uint256){\r\n    require(_number >= 2, \"Number must be greater than or equal to 2\");\r\n\r\n    if((_number % 2) == 0){\r\n      return 2;\r\n    }\r\n\r\n    uint end = sqrt(_number);\r\n\r\n\t\tfor(uint i = 3; i <= end; i += 2) {\r\n\t\t\tif (_number % i == 0)\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\t\treturn _number;\r\n\t}\r\n\r\n\r\n  /** @notice Returns an array of the factors of a number\r\n    * @param _number The number\r\n    * @return Array of factors of the number, _number\r\n    */\r\n  function factorize(uint256 _number) public pure returns (uint256[] memory){\r\n    uint n = _number;\r\n    uint[] memory factors = new uint[](100);\r\n    uint len = 0;\r\n\r\n\t\twhile (n > 1) {\r\n\t\t\tuint smallest = smallestFactor(n);\r\n      require(len < 100, \"factor overflow\");\r\n      factors[len] = smallest;\r\n      len = len + 1;\r\n      n = n / smallest;\r\n\t\t}\r\n\r\n    uint[] memory output = slice(factors, len);\r\n\r\n\t\treturn output;\r\n  }\r\n\r\n\r\n  /** @notice Returns an array of the prime numbers between _first and _last\r\n    * @param _first The smallest number to consider\r\n    * @param _last The largest number to consider\r\n    * @return Array of prime numbers between _first and _last\r\n    */\r\n  function listPrimes(uint256 _first, uint256 _last) public pure returns (uint256[] memory){\r\n    // Validate input and initialize storage for primes\r\n    require(_first > 1, \"The starting number must be a positive integer greater than 1\");\r\n    require(_last > _first, \"The range of search values must be greater than 0\");\r\n\r\n    uint firstPrime = 2;\r\n\r\n    uint len = _last - firstPrime + 1;\r\n    uint256[] memory list = new uint256[](len);\r\n\r\n    // Generate list of all natural numbers in [_first, _first+_total]\r\n    for(uint i = 0; i < len; i++){\r\n      list[i] = i + firstPrime;\r\n    }\r\n\r\n    // Find primes and eliminate their multiples\r\n    uint256 limit = sqrt(len);\r\n    for(uint256 i = 0; i <= limit; i++) {\r\n      if(list[i] != 0) {\r\n        for(uint256 pos = i + list[i]; pos < len; pos += list[i]) {\r\n          list[pos] = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    uint256 primesTotal = 0;\r\n    uint256 primesIndex = 0;\r\n\r\n    for(uint256 i = 0; i < len; i++){\r\n      if(list[i] != 0){\r\n        primesTotal++;\r\n      }\r\n    }\r\n\r\n    uint256[] memory primesList = new uint256[](primesTotal);\r\n\r\n    // Populate primes[] with all prime numbers in order\r\n    for (uint256 i = 0; i < len; i++) {\r\n      if(list[i] != 0){\r\n        primesList[primesIndex++] = list[i];\r\n      }\r\n    }\r\n\r\n    // Trim primes from given start and return\r\n    if (_first != 2) {\r\n      uint returnTotal = 0;\r\n      for(uint i = 0; i < primesTotal; i++){\r\n        if(primesList[i] >= _first){\r\n          returnTotal = returnTotal + 1;\r\n        }\r\n      }\r\n\r\n      uint256[] memory sliced = new uint256[](returnTotal);\r\n      uint diff = primesTotal - returnTotal;\r\n\r\n      for (uint256 i = 0; i < returnTotal; i++) {\r\n        sliced[i] = primesList[i+diff];\r\n      }\r\n      return sliced;\r\n    }\r\n\r\n    return primesList;\r\n  }\r\n\r\n\r\n  /** @notice Returns the base-_base syzygetic pair of a given 8 x 8 matrix of uint8 values\r\n    * @param _entity The matrix of an entity\r\n    * @param _base The numerical base of the operation\r\n    * @return The base-_base syzygetic pair matrix\r\n    */\r\n  function syzygy888(uint8[8][8] memory _entity, uint8 _base) public pure returns (uint8[8][8] memory) {\r\n    uint8[8][8] memory pair;\r\n    for(uint8 i = 0; i < 8; i++){\r\n      for(uint8 j = 0; j < 8; j++){\r\n        require(_entity[i][j] < _base, \"entity value out of range\");\r\n        pair[i][j] = _base - 1 - _entity[i][j];\r\n      }\r\n    }\r\n    return pair;\r\n  }\r\n\r\n\r\n  /** @notice Returns the base-_base syzygetic pair of a given uint8 value\r\n    * @param _i The uint8 value\r\n    * @param _base The numerical base of the operation\r\n    * @return The base-_base syzygetic pair value\r\n    */\r\n  function getSyzygyPartner8(uint8 _i, uint8 _base) public pure returns (uint8) {\r\n    require(_i <= _base, \"pair out of range\");\r\n    return _base - 1 - _i;\r\n  }\r\n\r\n\r\n  /** @notice Returns the absolute value of the difference between uint8 values in\r\n    * corresponding cells in two 8 x 8 matrices\r\n    * @param _a The first matrix\r\n    * @param _b The second matrix\r\n    * @return The matrix of absolute value differences\r\n    */\r\n  function sub888(uint8[8][8] memory _a, uint8[8][8] memory _b) public pure returns (uint8[8][8] memory) {\r\n    uint8[8][8] memory diff;\r\n    for(uint8 i = 0; i < 8; i++){\r\n      for(uint8 j = 0; j < 8; j++){\r\n        if(_a[i][j] >= _b[i][j]){\r\n          diff[i][j] = _a[i][j] - _b[i][j];\r\n        }else{\r\n          diff[i][j] = _b[i][j] - _a[i][j];\r\n        }\r\n      }\r\n    }\r\n    return diff;\r\n\r\n  }\r\n\r\n\r\n\r\n  /** @notice Implements the canonical version of D.C. Barker's Tic Xenotation\r\n    * @param _number The number to encode\r\n    * @return The encoded string value\r\n    */\r\n  function encodeTX(uint256 _number) public view returns (string memory) {\r\n    return encodeTX(_number, defaultTic, defaultNthPrimeOpen, defaultNthPrimeClose, defaultDeplex);\r\n  }\r\n\r\n\r\n  /** @notice Implements a customizable version of D.C. Barker's Tic Xenotation\r\n    * @param _number The number to encode\r\n    * @param tic The tic string\r\n    * @param nthPrimeOpen Open parenthesis\r\n    * @param nthPrimeClose Close parenthesis\r\n    * @param deplexToken Deplex token\r\n    * @return The encoded string value\r\n    */\r\n  function encodeTX(\r\n    uint256 _number,\r\n    string memory tic,//canonically \":\"\r\n    string memory nthPrimeOpen,//canonically \"(\"\r\n    string memory nthPrimeClose,//canonically \")\"\r\n    string memory deplexToken//canonically \"-P\"\r\n  ) public view returns (string memory) {\r\n    //zero\r\n    if(_number == 0){\r\n      return string(abi.encodePacked(nthPrimeOpen, nthPrimeOpen, deplexToken, nthPrimeClose, nthPrimeClose, tic));\r\n    }\r\n\r\n    //one\r\n    if(_number == 1){\r\n      return string(abi.encodePacked(nthPrimeOpen, deplexToken, nthPrimeClose, tic));\r\n    }\r\n\r\n    //1st prime\r\n    if(_number == 2){\r\n      return tic;\r\n    }\r\n\r\n    //2nd prime\r\n    if(_number == 3){\r\n      return string(abi.encodePacked(nthPrimeOpen, tic, nthPrimeClose));\r\n    }\r\n\r\n    //initialize primes\r\n    uint256[] memory primes = listPrimes(2, _number);\r\n\r\n    //initialize hyprimes\r\n    uint256[] memory hyprimes = new uint256[](primes[primes.length-1]+1);\r\n    for(uint256 i = 0; i < primes.length; i++){\r\n      hyprimes[primes[i]] = i+1; //+1 because primes is 0-based array and hyprimes is 1-based\r\n    }\r\n\r\n    if(primes[primes.length-1] == _number){//ie. if _number is prime it would be the last in the primes array\r\n      //nth prime\r\n      uint256 ordinate = hyprimes[_number];\r\n\r\n      string memory output;\r\n\r\n      if(hyprimes[ordinate] != 0){//ie. if ordinate is prime\r\n        //_number is hyprime\r\n        output = string(\r\n          abi.encodePacked(\r\n            encodeTX(\r\n              ordinate,\r\n              tic,\r\n              nthPrimeOpen,\r\n              nthPrimeClose,\r\n              deplexToken\r\n            )));\r\n      }else{\r\n        //_number is !hyprime\r\n        uint[] memory ordinateFactors = factorize(ordinate);\r\n\r\n        for(uint i = 0; i < ordinateFactors.length; i++){\r\n          output = string(\r\n            abi.encodePacked(\r\n              encodeTX(\r\n                ordinateFactors[i],\r\n                tic,\r\n                nthPrimeOpen,\r\n                nthPrimeClose,\r\n                deplexToken\r\n              ), output));\r\n        }\r\n      }\r\n      return string(abi.encodePacked(nthPrimeOpen, output, nthPrimeClose));\r\n    }else{\r\n      uint[] memory factors = factorize(_number);\r\n      string memory output = encodeTX(\r\n        factors[0],\r\n        tic,\r\n        nthPrimeOpen,\r\n        nthPrimeClose,\r\n        deplexToken\r\n      );\r\n\r\n      for(uint i = 1; i < factors.length; i++){\r\n        //encode left to right from the largest factor to the smallest\r\n        output = string(\r\n          abi.encodePacked(\r\n            encodeTX(\r\n              factors[i],\r\n              tic,\r\n              nthPrimeOpen,\r\n              nthPrimeClose,\r\n              deplexToken\r\n            ), output));\r\n      }\r\n\r\n      return output;\r\n    }\r\n  }\r\n\r\n\r\n  /** @notice Returns the 2d base64 8 x 8 alphanumeric gematria matrix\r\n    * @return The Gematrix\r\n    */\r\n  function getGEMATRIX() public pure returns (uint8[8][8] memory){\r\n\r\n    uint8[8][8] memory GEMATRIX = [\r\n      [ 65,  66,  67,  68,  69,  70,  71,  72], // A B C D E F G H\r\n      [ 73,  74,  75,  76,  77,  78,  79,  80], // I J K L M N O P\r\n      [ 81,  82,  83,  84,  85,  86,  87,  88], // Q R S T U V W X\r\n      [ 89,  90,  97,  98,  99, 100, 101, 102], // Y Z a b c d e f\r\n      [103, 104, 105, 106, 107, 108, 109, 110], // g h i j k l m n\r\n      [111, 112, 113, 114, 115, 116, 117, 118], // o p q r s t u v\r\n      [119, 120, 121, 122,  48,  49,  50,  51], // w x y z 0 1 2 3\r\n      [ 52,  53,  54,  55,  56,  57,  43,  47]  // 4 5 6 7 8 9 + /\r\n    ];\r\n\r\n    return GEMATRIX;\r\n  }\r\n\r\n\r\n  /** @notice An occult Fourier transform that onverts base64 tokenURI values of\r\n    * an array of onchain NFTs into base-_modulo frequency values conformal mapped\r\n    * (surjective) to the Gematrix\r\n    * @dev For doing onchain art exegesis\r\n    * @return The resulting 8 x 8 uint8 matrix of frequency values\r\n    */\r\n  function sixtyFourier(bytes[] memory _tokenURIs, uint8 _modulo) public pure returns (uint8[8][8] memory) {\r\n    require(_modulo <= 256, \"Mod > 2^8\");//modulo cannot exceed max value of uint8\r\n    uint8[8][8] memory GEMATRIX = getGEMATRIX();\r\n\r\n    //build a linear index of the GEMATRIX\r\n    Index[] memory index = new Index[](123);//122 is the highest value in the GEMATRIX\r\n\r\n    //fill in the index values that point on map\r\n    for(uint8 i = 0; i < 8; i++){\r\n      for(uint8 j = 0; j < 8; j++){\r\n        index[GEMATRIX[i][j]] = Index(i,j);\r\n      }\r\n    }\r\n\r\n    //construct the frequency cipher\r\n    uint8[8][8] memory frequencies;\r\n    uint8 zero = 0;\r\n\r\n    for(uint8 t = 0; t < _tokenURIs.length; t++){\r\n\r\n      for(uint256 b = 0; b < _tokenURIs[t].length; b++){\r\n        uint8 char = uint8(bytes1(_tokenURIs[t][b]));\r\n        if(char != 61){//skip \"=\"\r\n          uint8 i = index[char].i;//TODO plex variable down uint8 i = index[uint8(_tokenURIs[t][d])].i\r\n          uint8 j = index[char].j;//TODO plex variable down uint8 j = index[uint8(_tokenURIs[t][d])].j;\r\n\r\n          //map frequency onto a _modulo-degree circle\r\n          //since we are counting one-by-one, this is equivalent to % _modulo\r\n          if(frequencies[i][j] == (_modulo - 1)){\r\n            frequencies[i][j] = zero;\r\n          }else{\r\n            frequencies[i][j]++;\r\n          }\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return frequencies;\r\n  }\r\n\r\n\r\n  function isBase64Character(bytes1 _c) public pure returns (bool) {\r\n    uint8 _cint = uint8(_c);\r\n    //+\r\n    if(_cint == 43 || _cint == 47){//+/\r\n      return true;\r\n    }else if(_cint >= 48 && _cint <= 57){//0-9\r\n      return true;\r\n    }else if(_cint >= 65 && _cint <= 90){//A-Z\r\n      return true;\r\n    }else if(_cint >= 97 && _cint <= 122) {//a-z\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  function isValidBase64String(string memory _string) public pure returns (bool) {\r\n    bytes memory data = bytes(_string);\r\n    require( (data.length % 4) == 0, \"!= %4\");\r\n\r\n    for (uint i = 0; i < data.length; i++) {\r\n      bytes1 c = data[i];\r\n      if(!isBase64Character(c)){\r\n        if(i >= (data.length - 3)){//last two bytes may be = for padding\r\n          if(uint8(c) != 61){//=\r\n            return false;\r\n          }\r\n        }else{\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}"}}}