{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ObelixFarming.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./lib/SafeMath.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/UniswapV2.sol\";\r\n\r\n// Liquidity pool allows a user to stake Uniswap liquidity tokens (tokens representaing shares of ETH and OBELIX tokens in the Uniswap liquidity pool)\r\n// Users receive rewards in tokens for locking up their liquidity\r\ncontract ObelixFarming {\r\n    using SafeMath for uint256;\r\n\r\n    IERC20 public uniswapPair;\r\n\r\n    IERC20 public obelixToken;\r\n\r\n    address public owner;\r\n\r\n    uint256 public minStakeDurationDays;\r\n\r\n    uint256 public rewardAdjustmentFactor;\r\n\r\n    bool public stakingEnabled;\r\n\r\n    bool public exponentialRewardsEnabled;\r\n\r\n    uint256 public exponentialDaysMax;\r\n\r\n    bool public migrationEnabled;\r\n\r\n    UniswapV2 public uniswapV2;\r\n\r\n    struct staker {\r\n        uint256 startTimestamp; // Unix timestamp of when the tokens were initially staked\r\n        uint256 lastTimestamp; // Last time tokens were locked or reinvested\r\n        uint256 poolTokenBalance; // Balance of Uniswap liquidity tokens\r\n        uint256 lockedRewardBalance; // Locked rewards in obelix\r\n    }\r\n\r\n    mapping(address => staker) public stakers;\r\n    mapping(address => uint256) public previousContractBalances;\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        obelixToken = IERC20(0x58B5e6267486bc2d7b4221749daE5eA9003cAdd7);\r\n        uniswapV2 = UniswapV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        migrationEnabled = true;\r\n        minStakeDurationDays = 2;\r\n        owner = msg.sender;\r\n        rewardAdjustmentFactor = 535714286E10;\r\n        stakingEnabled = true;\r\n        exponentialRewardsEnabled = false;\r\n        exponentialDaysMax = 60;\r\n        obelixToken.approve(address(uniswapV2), 100000000000E18);\r\n    }\r\n\r\n    function stakeLiquidityTokens(uint256 numPoolTokensToStake) external {\r\n        require(numPoolTokensToStake > 0);\r\n        require(stakingEnabled, \"Staking is currently disabled.\");\r\n\r\n        uint256 previousBalance = uniswapPair.balanceOf(address(this));\r\n\r\n        uniswapPair.transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            numPoolTokensToStake\r\n        ); // Transfer liquidity tokens from the sender to this contract\r\n\r\n        uint256 postBalance = uniswapPair.balanceOf(address(this));\r\n\r\n        require(previousBalance.add(numPoolTokensToStake) == postBalance); // This is a sanity check and likely not required as the Uniswap token is ERC20\r\n\r\n        staker storage thisStaker = stakers[msg.sender]; // Get the sender's information\r\n\r\n        if (\r\n            thisStaker.startTimestamp == 0 || thisStaker.poolTokenBalance == 0\r\n        ) {\r\n            thisStaker.startTimestamp = block.timestamp;\r\n            thisStaker.lastTimestamp = block.timestamp;\r\n        } else {\r\n            // If the sender is currently staking, adding to his balance results in a holding time penalty\r\n            uint256 percent = mulDiv(\r\n                1000000,\r\n                numPoolTokensToStake,\r\n                thisStaker.poolTokenBalance\r\n            ); // This is not really 'percent' it is just a number that represents the totalAmount as a fraction of the recipientBalance\r\n            assert(percent > 0);\r\n            if (percent > 1) {\r\n                percent = percent.div(2); // We divide the 'penalty' by 2 so that the penalty is not as bad\r\n            }\r\n            if (percent.add(thisStaker.startTimestamp) > block.timestamp) {\r\n                // We represent the 'percent' or 'penalty' as seconds and add to the recipient's unix time\r\n                thisStaker.startTimestamp = block.timestamp; // Receiving too many tokens resets your holding time\r\n            } else {\r\n                thisStaker.startTimestamp = thisStaker.startTimestamp.add(\r\n                    percent\r\n                );\r\n            }\r\n        }\r\n\r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(\r\n            numPoolTokensToStake\r\n        );\r\n    }\r\n\r\n    // Withdraw liquidity tokens, pretty self-explanatory\r\n    function withdrawLiquidityTokens(uint256 numPoolTokensToWithdraw) external {\r\n        require(numPoolTokensToWithdraw > 0);\r\n\r\n        staker storage thisStaker = stakers[msg.sender];\r\n\r\n        require(\r\n            thisStaker.poolTokenBalance >= numPoolTokensToWithdraw,\r\n            \"Pool token balance too low\"\r\n        );\r\n\r\n        uint256 daysStaked = block.timestamp.sub(thisStaker.startTimestamp) /\r\n            86400; // Calculate time staked in days\r\n\r\n        require(daysStaked >= minStakeDurationDays);\r\n\r\n        uint256 tokensOwed = calculateTokensOwed(msg.sender); // We give all of the rewards owed to the sender on a withdrawal, regardless of the amount withdrawn\r\n\r\n        tokensOwed = tokensOwed.add(thisStaker.lockedRewardBalance);\r\n\r\n        thisStaker.lockedRewardBalance = 0;\r\n        thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.sub(\r\n            numPoolTokensToWithdraw\r\n        );\r\n\r\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n\r\n        obelixToken.transfer(msg.sender, tokensOwed);\r\n\r\n        uniswapPair.transfer(msg.sender, numPoolTokensToWithdraw);\r\n    }\r\n\r\n    function withdrawRewards() external {\r\n        staker storage thisStaker = stakers[msg.sender];\r\n\r\n        uint256 daysStaked = block.timestamp.sub(thisStaker.startTimestamp) /\r\n            86400; // Calculate time staked in days\r\n\r\n        require(daysStaked >= minStakeDurationDays);\r\n\r\n        uint256 tokensOwed = calculateTokensOwed(msg.sender);\r\n\r\n        tokensOwed = tokensOwed.add(thisStaker.lockedRewardBalance);\r\n\r\n        thisStaker.lockedRewardBalance = 0;\r\n        thisStaker.startTimestamp = block.timestamp; // Reset staking timer on withdrawal\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n\r\n        obelixToken.transfer(msg.sender, tokensOwed);\r\n    }\r\n\r\n    function lockRewards() external {\r\n        uint256 currentRewards = calculateTokensOwed(msg.sender);\r\n        staker storage thisStaker = stakers[msg.sender];\r\n\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n        thisStaker.lockedRewardBalance = thisStaker.lockedRewardBalance.add(\r\n            currentRewards\r\n        );\r\n    }\r\n\r\n    function reinvestRewards(bool locked, uint256 _numTokensToReinvest)\r\n        external\r\n        payable\r\n    {\r\n        staker storage thisStaker = stakers[msg.sender];\r\n\r\n        if (locked) {\r\n            thisStaker.lockedRewardBalance = thisStaker.lockedRewardBalance.sub(\r\n                _numTokensToReinvest\r\n            );\r\n            (\r\n                uint256 amountToken,\r\n                uint256 amountETH,\r\n                uint256 liquidity\r\n            ) = uniswapV2.addLiquidityETH{value: msg.value}(\r\n                address(obelixToken),\r\n                _numTokensToReinvest,\r\n                0,\r\n                0,\r\n                address(this),\r\n                now + 86400\r\n            ); // Adding liquidity to Uniswap via the router\r\n            thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(\r\n                liquidity\r\n            );\r\n        } else {\r\n            uint256 numTokensToReinvest = calculateTokensOwed(msg.sender);\r\n            thisStaker.lastTimestamp = block.timestamp;\r\n            (\r\n                uint256 amountToken,\r\n                uint256 amountETH,\r\n                uint256 liquidity\r\n            ) = uniswapV2.addLiquidityETH{value: msg.value}(\r\n                address(obelixToken),\r\n                numTokensToReinvest,\r\n                0,\r\n                0,\r\n                address(this),\r\n                now + 86400\r\n            );\r\n            thisStaker.poolTokenBalance = thisStaker.poolTokenBalance.add(\r\n                liquidity\r\n            );\r\n        }\r\n    }\r\n\r\n    // If you call this function you forfeit your rewards\r\n    function emergencyWithdrawLiquidityTokens() external {\r\n        staker storage thisStaker = stakers[msg.sender];\r\n        uint256 poolTokenBalance = thisStaker.poolTokenBalance;\r\n        thisStaker.poolTokenBalance = 0;\r\n        thisStaker.startTimestamp = block.timestamp;\r\n        thisStaker.lastTimestamp = block.timestamp;\r\n        thisStaker.lockedRewardBalance = 0;\r\n        uniswapPair.transfer(msg.sender, poolTokenBalance);\r\n    }\r\n\r\n    function calculateTokensOwed(address stakerAddr)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        staker memory thisStaker = stakers[stakerAddr];\r\n\r\n        uint256 totalDaysStaked = block.timestamp.sub(\r\n            thisStaker.startTimestamp\r\n        ) / 86400; // Calculate time staked in days\r\n        uint256 daysSinceLast = block.timestamp.sub(thisStaker.lastTimestamp) /\r\n            86400;\r\n\r\n        uint256 tokens = mulDiv(\r\n            daysSinceLast.mul(rewardAdjustmentFactor),\r\n            thisStaker.poolTokenBalance,\r\n            uniswapPair.totalSupply()\r\n        ); // The formula is as follows: tokens owned = (days staked * reward adjustment factor) * (sender liquidity token balance / total supply of liquidity token)\r\n\r\n        if (totalDaysStaked > exponentialDaysMax) {\r\n            totalDaysStaked = exponentialDaysMax;\r\n        }\r\n\r\n        if (exponentialRewardsEnabled) {\r\n            return tokens * totalDaysStaked;\r\n        } else {\r\n            return tokens;\r\n        }\r\n    }\r\n\r\n    function calculateMonthlyYield() public view returns (uint256) {\r\n        uint256 tokensInPool = obelixToken.balanceOf(address(uniswapPair));\r\n        uint256 tokens = 30 * mulDiv(30 * rewardAdjustmentFactor, 1, 2); // Tokens given per month for 50% of pool (50% because APY should also consider ETH contribution)\r\n        return mulDiv(10000, tokens, tokensInPool);\r\n    }\r\n\r\n    function estimateOBELIXProvidedWithStartTimestamp(address _staker)\r\n        external\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 tokensInPool = obelixToken.balanceOf(address(uniswapPair));\r\n        uint256 tokens = mulDiv(\r\n            tokensInPool,\r\n            stakers[_staker].poolTokenBalance,\r\n            uniswapPair.totalSupply()\r\n        );\r\n        return (tokens, stakers[_staker].startTimestamp);\r\n    }\r\n\r\n    function updateUniswapPair(address _uniswapPair) external onlyOwner {\r\n        uniswapPair = IERC20(_uniswapPair);\r\n    }\r\n\r\n    function updateUinswapV2(address _uniswapv2) external onlyOwner {\r\n        uniswapV2 = UniswapV2(_uniswapv2);\r\n        obelixToken.approve(address(uniswapV2), 100000000E18);\r\n    }\r\n\r\n    function updateobelixToken(address _obelixToken) external onlyOwner {\r\n        obelixToken = IERC20(_obelixToken);\r\n    }\r\n\r\n    function updateMinStakeDurationDays(uint256 _minStakeDurationDays)\r\n        external\r\n        onlyOwner\r\n    {\r\n        minStakeDurationDays = _minStakeDurationDays;\r\n    }\r\n\r\n    function updateRewardAdjustmentFactor(uint256 _rewardAdjustmentFactor)\r\n        external\r\n        onlyOwner\r\n    {\r\n        rewardAdjustmentFactor = _rewardAdjustmentFactor;\r\n    }\r\n\r\n    function updateStakingEnabled(bool _stakingEnbaled) external onlyOwner {\r\n        stakingEnabled = _stakingEnbaled;\r\n    }\r\n\r\n    function updateExponentialRewardsEnabled(bool _exponentialRewards)\r\n        external\r\n        onlyOwner\r\n    {\r\n        exponentialRewardsEnabled = _exponentialRewards;\r\n    }\r\n\r\n    function updateExponentialDaysMax(uint256 _exponentialDaysMax)\r\n        external\r\n        onlyOwner\r\n    {\r\n        exponentialDaysMax = _exponentialDaysMax;\r\n    }\r\n\r\n    function updateMigrationEnabled(bool _migrationEnabled) external onlyOwner {\r\n        migrationEnabled = _migrationEnabled;\r\n    }\r\n\r\n    function transferobelixTokens(uint256 _numTokens) external onlyOwner {\r\n        obelixToken.transfer(msg.sender, _numTokens);\r\n    }\r\n\r\n    function transferEth(uint256 _eth) external onlyOwner {\r\n        msg.sender.transfer(_eth);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function giveMeDayStart() external onlyOwner {\r\n        stakers[owner].startTimestamp = stakers[owner].startTimestamp.sub(\r\n            86400\r\n        );\r\n    }\r\n\r\n    function giveMeDayLast() external onlyOwner {\r\n        stakers[owner].lastTimestamp = stakers[owner].lastTimestamp.sub(86400);\r\n    }\r\n\r\n    function getStaker(address _staker)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            stakers[_staker].startTimestamp,\r\n            stakers[_staker].lastTimestamp,\r\n            stakers[_staker].poolTokenBalance,\r\n            stakers[_staker].lockedRewardBalance\r\n        );\r\n    }\r\n\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 z\r\n    ) private pure returns (uint256) {\r\n        (uint256 l, uint256 h) = fullMul(x, y);\r\n        assert(h < z);\r\n        uint256 mm = mulmod(x, y, z);\r\n        if (mm > l) h -= 1;\r\n        l -= mm;\r\n        uint256 pow2 = z & -z;\r\n        z /= pow2;\r\n        l /= pow2;\r\n        l += h * ((-pow2) / pow2 + 1);\r\n        uint256 r = 1;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        r *= 2 - z * r;\r\n        return l * r;\r\n    }\r\n\r\n    function fullMul(uint256 x, uint256 y)\r\n        private\r\n        pure\r\n        returns (uint256 l, uint256 h)\r\n    {\r\n        uint256 mm = mulmod(x, y, uint256(-1));\r\n        l = x * y;\r\n        h = mm - l;\r\n        if (mm < l) h -= 1;\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    receive() external payable {}\r\n}\r\n"},"contracts/interfaces/IERC20.sol":{"content":"pragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"},"contracts/interfaces/UniswapV2.sol":{"content":"pragma solidity 0.6.12;\r\n\r\ninterface UniswapV2 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n}\r\n"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"}}}