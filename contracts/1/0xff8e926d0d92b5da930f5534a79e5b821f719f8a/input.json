{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/3_Ballot.sol":{"content":"pragma solidity 0.5.16; /*\r\n\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n\r\n ██████╗ ██╗██╗     ██╗     ██╗ ██████╗ ███╗   ██╗    ███╗   ███╗ ██████╗ ███╗   ██╗███████╗██╗   ██╗\r\n ██╔══██╗██║██║     ██║     ██║██╔═══██╗████╗  ██║    ████╗ ████║██╔═══██╗████╗  ██║██╔════╝╚██╗ ██╔╝\r\n ██████╔╝██║██║     ██║     ██║██║   ██║██╔██╗ ██║    ██╔████╔██║██║   ██║██╔██╗ ██║█████╗   ╚████╔╝ \r\n ██╔══██╗██║██║     ██║     ██║██║   ██║██║╚██╗██║    ██║╚██╔╝██║██║   ██║██║╚██╗██║██╔══╝    ╚██╔╝  \r\n ██████╔╝██║███████╗███████╗██║╚██████╔╝██║ ╚████║    ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║███████╗   ██║   \r\n ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   \r\n                                                                                            \r\n\r\n\r\n-------------------------------------------------------------------\r\n Copyright (c) 2020 onwards Billion Money Inc. ( https://billionmoney.live )\r\n-------------------------------------------------------------------\r\n */\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address payable public owner;\r\n    address payable internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         PAX interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface paxInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n }\r\n\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n\r\ncontract billionMoney is owned {\r\n\r\n    // Replace below address with main PAX token\r\n    address public paxTokenAddress;\r\n    uint public maxDownLimit = 2;\r\n    uint public levelLifeTime = 15552000;  // =180 days;\r\n    uint public lastIDCount = 0;\r\n    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\r\n    \r\n    address public specialAddress1;\r\n    address public specialAddress2;\r\n\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint referrerID;\r\n        address[] referral;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n\r\n    mapping(uint => uint) public priceOfLevel;\r\n    mapping(uint => uint) public distForLevel;\r\n    mapping(uint => uint) public autoPoolDist;\r\n    mapping(uint => uint) public uniLevelDistPart;\r\n    uint256 public totalDivCollection;\r\n    uint public globalDivDistPart = 0.6 ether;\r\n    uint public systemDistPart = 1 ether;\r\n    \r\n    uint public oneMonthDuration = 2592000; // = 30 days\r\n    uint public thisMonthEnd;\r\n    struct divPoolRecord\r\n    {\r\n        uint totalDividendCollection;\r\n        uint totalEligibleCount;\r\n    }\r\n    divPoolRecord[] public divPoolRecords;\r\n    mapping ( address => uint) public eligibleUser; // if val > 0 then user is eligible from this divPoolRecords;\r\n    mapping(uint => mapping ( address => bool)) public dividendReceived; // dividend index => user => true/false\r\n\r\n    struct autoPool\r\n    {\r\n        uint userID;\r\n        uint autoPoolParent;\r\n    }\r\n    mapping(uint => autoPool[]) public autoPoolLevel;  // users lavel records under auto pool scheme\r\n    mapping(address => mapping(uint => uint)) public autoPoolIndex; //to find index of user inside auto pool\r\n    uint[10] public nextMemberFillIndex;  // which auto pool index is in top of queue to fill in \r\n    uint[10] public nextMemberFillBox;   // 3 downline to each, so which downline need to fill in\r\n\r\n    uint[10][10] public autoPoolSubDist;\r\n\r\n    \r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address payable) public userAddressByID;\r\n\r\n    mapping(address => uint256) public totalGainInMainNetwork; //Main lavel income system income will go here with owner mapping\r\n    mapping(address => uint256) public totalGainInUniLevel; \r\n    mapping(address => uint256) public totalGainInAutoPool;\r\n    mapping(address => uint256) public netTotalUserWithdrawable;  //Dividend is not included in it\r\n\r\n\r\n    event regLevelEv(address indexed _userWallet, uint indexed _userID, uint indexed _referrerID, uint _time, address _refererWallet, uint _originalReferrer);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event lostForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n    event payDividendEv(uint timeNow,uint payAmount,address paitTo);\r\n    event updateAutoPoolEv(uint timeNow,uint autoPoolLevelIndex,uint userIndexInAutoPool, address user);\r\n    event autoPoolPayEv(uint timeNow,address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst);\r\n    event paidForUniLevelEv(uint timeNow,address PaitTo,uint Amount);\r\n    \r\n    constructor(address payable ownerAddress, address payable ID1address, address _specialAddress1, address _specialAddress2) public {\r\n        owner = ownerAddress;\r\n        specialAddress1 = _specialAddress1;\r\n        specialAddress2 = _specialAddress2;\r\n        emit OwnershipTransferred(address(0), owner);\r\n        address payable ownerWallet = ID1address;\r\n        priceOfLevel[1] = 20 ether;\r\n        priceOfLevel[2] = 20 ether;\r\n        priceOfLevel[3] = 40 ether;\r\n        priceOfLevel[4] = 140 ether;\r\n        priceOfLevel[5] = 600 ether;\r\n        priceOfLevel[6] = 5000 ether;\r\n        priceOfLevel[7] = 5500 ether;\r\n        priceOfLevel[8] = 10000 ether;\r\n        priceOfLevel[9] = 20000 ether;\r\n        priceOfLevel[10] = 40000 ether;\r\n\r\n        distForLevel[1] = 10 ether;\r\n        distForLevel[2] = 15 ether;\r\n        distForLevel[3] = 30 ether;\r\n        distForLevel[4] = 120 ether;\r\n        distForLevel[5] = 500 ether;\r\n        distForLevel[6] = 4700 ether;\r\n        distForLevel[7] = 5000 ether;\r\n        distForLevel[8] = 9000 ether;\r\n        distForLevel[9] = 18000 ether;\r\n        distForLevel[10] = 35000 ether;\r\n\r\n        autoPoolDist[1] = 4 ether;\r\n        autoPoolDist[2] = 5 ether;\r\n        autoPoolDist[3] = 10 ether;\r\n        autoPoolDist[4] = 20 ether;\r\n        autoPoolDist[5] = 100 ether;\r\n        autoPoolDist[6] = 300 ether;\r\n        autoPoolDist[7] = 500 ether;\r\n        autoPoolDist[8] = 1000 ether;\r\n        autoPoolDist[9] = 2000 ether;\r\n        autoPoolDist[10] = 5000 ether;        \r\n\r\n        uniLevelDistPart[1] = 1 ether;\r\n        uniLevelDistPart[2] = 0.6 ether;\r\n        uniLevelDistPart[3] = 0.4 ether;\r\n\r\n        for (uint i = 4 ; i < 11; i++)\r\n        {\r\n           uniLevelDistPart[i] =  0.2 ether;\r\n        } \r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: 0,\r\n            referral: new address[](0)\r\n        });\r\n        userInfos[ownerWallet] = UserInfo;\r\n        userAddressByID[lastIDCount] = ownerWallet;\r\n\r\n        for(uint i = 1; i <= 10; i++) {\r\n            userInfos[ownerWallet].levelExpired[i] = 99999999999;\r\n            emit paidForLevelEv(address(0), ownerWallet, i, distForLevel[i], now);\r\n        }\r\n\r\n        autoPool memory temp;\r\n        for (uint i = 11 ; i < 21; i++)\r\n        {\r\n           uniLevelDistPart[i] =  0.1 ether;\r\n           uint a = i-11;\r\n           temp.userID = lastIDCount;  \r\n           autoPoolLevel[a].push(temp);\r\n         \r\n           autoPoolIndex[ownerWallet][a] = 0;\r\n           uint distPart = autoPoolDist[a+1];\r\n           autoPoolSubDist[a][0] = distPart * 1250 / 10000;\r\n           autoPoolSubDist[a][1] = distPart * 1250 / 10000;\r\n           autoPoolSubDist[a][2] = distPart * 1000 / 10000;\r\n           autoPoolSubDist[a][3] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][4] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][5] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][6] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][7] = distPart * 1000 / 10000;\r\n           autoPoolSubDist[a][8] = distPart * 1250 / 10000;                                                                             \r\n           autoPoolSubDist[a][9] = distPart * 1250 / 10000;\r\n        } \r\n\r\n        startNextMonth();\r\n        eligibleUser[ownerWallet] = 1;\r\n        emit regLevelEv(ownerWallet, 1, 0, now, address(this), 0);\r\n\r\n    }\r\n\r\n    function () payable external {\r\n        regUser(defaultRefID);\r\n    }\r\n\r\n    function regUser(uint _referrerID) public returns(bool) \r\n    {\r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender; \r\n        uint originalReferrer = _referrerID;\r\n\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\r\n        uint fct = 1;\r\n        if(userInfos[userAddressByID[_referrerID]].referral.length >= maxDownLimit) _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\r\n\r\n\r\n        //transferring PAX tokens from smart user to smart contract for level 1\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[1]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            referral: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[lastIDCount] = msg.sender;\r\n\r\n        userInfos[msgSender].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].referral.push(msgSender);\r\n\r\n        totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n        netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n\r\n        if(thisMonthEnd < now) startNextMonth();\r\n\r\n        uint lastDivPoolIndex = divPoolRecords.length -1;\r\n        divPoolRecords[lastDivPoolIndex].totalDividendCollection += globalDivDistPart * fct;\r\n        totalDivCollection += globalDivDistPart * fct;\r\n\r\n        address usr = userAddressByID[_referrerID];\r\n        if(eligibleUser[usr] == 0)\r\n        {\r\n            if(userInfos[usr].referral.length > 9)\r\n            {\r\n                eligibleUser[usr] = lastDivPoolIndex;\r\n                divPoolRecords[lastDivPoolIndex + 1].totalEligibleCount++;\r\n            }\r\n        }\r\n\r\n        require(payForLevel(1, msgSender,fct),\"pay for level fail\");\r\n        emit regLevelEv(msgSender, lastIDCount, _referrerID, now,userAddressByID[_referrerID], originalReferrer );\r\n        emit levelBuyEv(msgSender, 1, priceOfLevel[1] * fct, now);\r\n        require(updateNPayAutoPool(1,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n\r\n    function viewCurrentMonthDividend() public view returns(uint256 amount, uint256 indexCount)\r\n    {\r\n        uint256 length = divPoolRecords.length;\r\n        return (divPoolRecords[length-1].totalDividendCollection,length);\r\n    }\r\n\r\n    function buyLevel(uint _level) public returns(bool){\r\n        \r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender;   \r\n        \r\n        \r\n        //checking conditions\r\n        require(userInfos[msgSender].joined, 'User not exist'); \r\n        uint fct=1;\r\n        require(_level >= 1 && _level <= 10, 'Incorrect level');\r\n        \r\n        //transfer tokens\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[_level]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        \r\n        //updating variables\r\n        if(_level == 1) {\r\n            userInfos[msgSender].levelExpired[1] += levelLifeTime;\r\n        }\r\n        else {\r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[msgSender].levelExpired[l] >= now, 'Buy the previous level');\r\n\r\n            if(userInfos[msgSender].levelExpired[_level] == 0) userInfos[msgSender].levelExpired[_level] = now + levelLifeTime;\r\n            else userInfos[msgSender].levelExpired[_level] += levelLifeTime;\r\n        }\r\n\r\n        require(payForLevel(_level, msgSender,fct),\"pay for level fail\");\r\n        emit levelBuyEv(msgSender, _level, priceOfLevel[_level] * fct, now);\r\n        require(updateNPayAutoPool(_level,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n    \r\n\r\n    function payForLevel(uint _level, address _user,uint fct) internal returns (bool){\r\n        address referer;\r\n        address referer1;\r\n        address referer2;\r\n        address referer3;\r\n        address referer4;\r\n\r\n        if(_level == 1 || _level == 6) {\r\n            referer = userAddressByID[userInfos[_user].referrerID];\r\n            payForUniLevel(userInfos[_user].referrerID,fct);\r\n            totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n            netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n        }\r\n        else if(_level == 2 || _level == 7) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer = userAddressByID[userInfos[referer1].referrerID];\r\n        }\r\n        else if(_level == 3 || _level == 8) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer = userAddressByID[userInfos[referer2].referrerID];\r\n        }\r\n        else if(_level == 4 || _level == 9) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer = userAddressByID[userInfos[referer3].referrerID];\r\n        }\r\n        else if(_level == 5 || _level == 10) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer4 = userAddressByID[userInfos[referer3].referrerID];\r\n            referer = userAddressByID[userInfos[referer4].referrerID];\r\n        }\r\n\r\n\r\n        if(!userInfos[referer].joined) referer = userAddressByID[defaultRefID];\r\n\r\n       \r\n        if(userInfos[referer].levelExpired[_level] >= now) {\r\n            totalGainInMainNetwork[referer] += distForLevel[_level] * fct;\r\n            netTotalUserWithdrawable[referer] += distForLevel[_level] * fct;\r\n            emit paidForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\r\n\r\n        }\r\n        else{\r\n\r\n            emit lostForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\r\n            payForLevel(_level, referer,fct);\r\n\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n        referrals[0] = userInfos[_user].referral[0];\r\n        referrals[1] = userInfos[_user].referral[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\r\n                if(i < 62) {\r\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\r\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n    function payForUniLevel(uint _referrerID, uint fct) internal returns(bool)\r\n    {\r\n        uint256 endID = 21;\r\n        for (uint i = 0 ; i < endID; i++)\r\n        {\r\n            address usr = userAddressByID[_referrerID];\r\n            _referrerID = userInfos[usr].referrerID;\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n            uint Amount = uniLevelDistPart[i + 1 ]  * fct;\r\n            totalGainInUniLevel[usr] += Amount;\r\n            netTotalUserWithdrawable[usr] += Amount;\r\n            emit paidForUniLevelEv(now,usr, Amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    event withdrawMyGainEv(uint timeNow,address caller,uint totalAmount);\r\n    function withdrawMyDividendNAll() public returns(uint)\r\n    {\r\n        address payable caller = msg.sender;\r\n        require(userInfos[caller].joined, 'User not exist');\r\n        uint from = eligibleUser[caller];\r\n        uint totalAmount;\r\n        if(from > 0)\r\n        {\r\n            from --;\r\n            uint lastDivPoolIndex = divPoolRecords.length;\r\n            if( lastDivPoolIndex > 1 )\r\n            {\r\n                lastDivPoolIndex = lastDivPoolIndex -2;\r\n\r\n                for(uint i=0;i<150;i++)\r\n                {\r\n                    if(lastDivPoolIndex < i) break;\r\n                    uint curIndex = lastDivPoolIndex - i;\r\n                    if( curIndex >= from && !dividendReceived[curIndex][caller] )\r\n                    {\r\n                        totalAmount +=  ( divPoolRecords[curIndex].totalDividendCollection * 10000000000 /  divPoolRecords[curIndex].totalEligibleCount ) / 10000000000;\r\n                        dividendReceived[curIndex][caller] = true;\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        if(totalAmount > 0)\r\n        {\r\n            totalDivCollection -= totalAmount;\r\n            emit payDividendEv(now, totalAmount, caller);\r\n        }\r\n        totalAmount = totalAmount + netTotalUserWithdrawable[caller];\r\n        netTotalUserWithdrawable[caller] = 0;\r\n        totalGainInAutoPool[caller] = 0;\r\n        totalGainInMainNetwork[caller] = 0;\r\n        totalGainInUniLevel[caller] = 0;\r\n        require(paxInterface(paxTokenAddress).transfer(msg.sender, totalAmount),\"token transfer failed\");\r\n        emit withdrawMyGainEv(now, caller, totalAmount);\r\n        \r\n    }\r\n\r\n    function viewMyDividendPotential(address user) public view returns(uint256 totalDivPotential, uint256 lastUnPaidIndex)\r\n    {\r\n        if (eligibleUser[user] > 0 )\r\n        {\r\n            uint256 i;\r\n            uint256 lastIndex = divPoolRecords.length -1;\r\n            for(i=1;i<50;i++)\r\n            {\r\n                lastUnPaidIndex = lastIndex - i;\r\n                if(dividendReceived[lastUnPaidIndex][user] == true) break;\r\n                totalDivPotential = totalDivPotential + ( divPoolRecords[lastUnPaidIndex].totalDividendCollection * 10000000000 /  divPoolRecords[lastUnPaidIndex].totalEligibleCount);               \r\n            }\r\n            return (totalDivPotential, lastUnPaidIndex + 1);\r\n        }\r\n        return (0,0);\r\n    }\r\n\r\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[10] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<10;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n\r\n    \r\n    \r\n    function divPoolAllLevel() public view returns (uint256[10] memory divPoolArray)\r\n    {\r\n        for(uint256 i=0;i<10;i++)\r\n        {\r\n            divPoolArray[i] = divPoolRecords[i].totalDividendCollection;\r\n        }\r\n        return divPoolArray;\r\n    }\r\n    \r\n\r\n    function startNextMonth() public returns(bool)\r\n    {\r\n        require(thisMonthEnd < now,\"month end not reached\");\r\n        thisMonthEnd = now + oneMonthDuration;\r\n        divPoolRecord memory temp;\r\n        temp.totalEligibleCount = 1;\r\n        divPoolRecords.push(temp);\r\n        uint lastDivPoolIndex = divPoolRecords.length -1;\r\n        if (lastDivPoolIndex > 0)\r\n        {\r\n            divPoolRecords[lastDivPoolIndex].totalEligibleCount = divPoolRecords[lastDivPoolIndex -1].totalEligibleCount;\r\n        }\r\n        return (true);\r\n    }\r\n\r\n    function updateNPayAutoPool(uint _level,address _user, uint fct) internal returns (bool)\r\n    {\r\n        uint a = _level -1;\r\n        uint len = autoPoolLevel[a].length;\r\n        autoPool memory temp;\r\n        temp.userID = userInfos[_user].id;\r\n        temp.autoPoolParent = nextMemberFillIndex[a];       \r\n        autoPoolLevel[a].push(temp);        \r\n        uint idx = nextMemberFillIndex[a];\r\n\r\n        address payable usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n        if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        for(uint i=0;i<10;i++)\r\n        {\r\n            uint amount = autoPoolSubDist[a][i]  * fct;\r\n            totalGainInAutoPool[usr] += amount;\r\n            netTotalUserWithdrawable[usr] += amount;\r\n            emit autoPoolPayEv(now, usr,a+1, amount, _user);\r\n            idx = autoPoolLevel[a][idx].autoPoolParent; \r\n            usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        }\r\n\r\n        if(nextMemberFillBox[a] == 0)\r\n        {\r\n            nextMemberFillBox[a] = 1;\r\n        }   \r\n        else if (nextMemberFillBox[a] == 1)\r\n        {\r\n            nextMemberFillBox[a] = 2;\r\n        }\r\n        else\r\n        {\r\n            nextMemberFillIndex[a]++;\r\n            nextMemberFillBox[a] = 0;\r\n        }\r\n        autoPoolIndex[_user][_level - 1] = len;\r\n        emit updateAutoPoolEv(now, _level, len, _user);\r\n        return true;\r\n    }\r\n\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    \r\n    /*======================================\r\n    =            ADMIN FUNCTIONS           =\r\n    ======================================*/\r\n    \r\n    function changePAXaddress(address newPAXaddress) onlyOwner public returns(string memory){\r\n        //if owner makes this 0x0 address, then it will halt all the operation of the contract. This also serves as security feature.\r\n        //so owner can halt it in any problematic situation. Owner can then input correct address to make it all come back to normal.\r\n        paxTokenAddress = newPAXaddress;\r\n        return(\"PAX address updated successfully\");\r\n    }\r\n    \r\n    function changeDefaultRefID(uint newDefaultRefID) onlyOwner public returns(string memory){\r\n        //this ref ID will be assigned to user who joins without any referral ID.\r\n        defaultRefID = newDefaultRefID;\r\n        return(\"Default Ref ID updated successfully\");\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n}\r\n"}}}