{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FeeHolderProxyOwner.sol":{"content":"// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        require(token.transfer(to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        require(token.transferFrom(from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0));\r\n        require(token.approve(spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        require(token.approve(spender, newAllowance));\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/iface/IFeeHolder.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @author Kongliang Zhong - <kongliang@loopring.org>\r\n/// @title IFeeHolder - A contract holding fees.\r\ncontract IFeeHolder {\r\n\r\n    event TokenWithdrawn(\r\n        address owner,\r\n        address token,\r\n        uint value\r\n    );\r\n\r\n    // A map of all fee balances; token --> owner --> balance\r\n    mapping(address => mapping(address => uint)) public feeBalances;\r\n\r\n    // A map of all the nonces for a withdrawTokenFor request\r\n    mapping(address => uint) public nonces;\r\n\r\n    /// @dev   Allows withdrawing the tokens to be burned by\r\n    ///        authorized contracts.\r\n    /// @param token The token to be used to burn buy and burn LRC\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawBurned(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds\r\n    ///        msg.sender is the recipient of the fee and the address\r\n    ///        to which the tokens will be sent.\r\n    /// @param token The token to withdraw\r\n    /// @param value The amount of tokens to withdraw\r\n    function withdrawToken(\r\n        address token,\r\n        uint value\r\n        )\r\n        external\r\n        returns (bool success);\r\n\r\n    /// @dev   Allows withdrawing the fee payments funds by providing a\r\n    ///        a signature\r\n    function withdrawTokenFor(\r\n      address owner,\r\n      address token,\r\n      uint value,\r\n      address recipient,\r\n      uint feeValue,\r\n      address feeRecipient,\r\n      uint nonce,\r\n      bytes calldata signature\r\n      )\r\n      external\r\n      returns (bool success);\r\n\r\n    function batchAddFeeBalances(\r\n        bytes32[] calldata batch\r\n        )\r\n        external;\r\n}\r\n\r\n// File: contracts/loopring/lib/Ownable.sol\r\n\r\n/*\r\n\r\n  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\npragma solidity ^0.5.7;\r\n\r\n\r\n/// @title Ownable\r\n/// @dev The Ownable contract has an owner address, and provides basic\r\n///      authorization control functions, this simplifies the implementation of\r\n///      \"user permissions\".\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /// @dev The Ownable constructor sets the original `owner` of the contract\r\n    ///      to the sender.\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the owner.\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current owner to transfer control of the contract to a\r\n    ///      newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(\r\n        address newOwner\r\n        )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0x0), \"ZERO_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/loopring/impl/FeeHolderProxyOwner.sol\r\n\r\n/*\r\n * Copyright 2019 Dolomite\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npragma solidity ^0.5.13;\r\n\r\n\r\n\r\n\r\ncontract FeeHolderProxyOwner is Ownable {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    event FeeHolderSet(address indexed newFeeHolder, address indexed oldFeeHolder);\r\n    event TokenWithdrawn(address indexed token, address receiver, uint amount);\r\n\r\n    IFeeHolder public feeHolder;\r\n\r\n    constructor(\r\n        address _feeHolder\r\n    ) public {\r\n        feeHolder = IFeeHolder(_feeHolder);\r\n    }\r\n\r\n    // ******************************\r\n    // ***** Getters\r\n    // ******************************\r\n\r\n    function getBalancesByToken(\r\n        address token\r\n    ) public view returns (uint burnBalance, uint feeBalance) {\r\n        burnBalance = feeHolder.feeBalances(token, address(feeHolder));\r\n        feeBalance = feeHolder.feeBalances(token, address(this));\r\n    }\r\n\r\n    // ******************************\r\n    // ***** Setters and Writers\r\n    // ******************************\r\n\r\n    function executeCode(\r\n        string calldata signature,\r\n        bytes calldata data\r\n    )\r\n    external\r\n    payable\r\n    onlyOwner\r\n    returns (bytes memory) {\r\n        bytes memory callData;\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        (bool success, bytes memory returnData) = (address(feeHolder)).call.value(msg.value)(callData);\r\n        require(success, \"EXECUTION_REVERTED\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function setFeeHolder(\r\n        address _feeHolder\r\n    )\r\n    external\r\n    onlyOwner {\r\n        address oldFeeHolder = address(feeHolder);\r\n        feeHolder = IFeeHolder(_feeHolder);\r\n        emit FeeHolderSet(_feeHolder, oldFeeHolder);\r\n    }\r\n\r\n    function withdrawAllFeesByTokens(\r\n        address[] calldata tokens,\r\n        address receiver\r\n    )\r\n    external\r\n    onlyOwner {\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            _withdrawAllFeesByToken(tokens[i], receiver);\r\n        }\r\n    }\r\n\r\n    function withdrawAllFeesByToken(\r\n        address token,\r\n        address receiver\r\n    )\r\n    external\r\n    onlyOwner {\r\n        _withdrawAllFeesByToken(token, receiver);\r\n    }\r\n\r\n    function _withdrawAllFeesByToken(\r\n        address token,\r\n        address receiver\r\n    ) internal {\r\n        (uint burnBalance, uint feeBalance) = getBalancesByToken(token);\r\n        if (burnBalance > 0) {\r\n            feeHolder.withdrawBurned(token, burnBalance);\r\n        }\r\n        if (feeBalance > 0) {\r\n            feeHolder.withdrawToken(token, feeBalance);\r\n        }\r\n\r\n        uint balance = IERC20(token).balanceOf(address(this));\r\n        if (balance > 0) {\r\n            IERC20(token).safeTransfer(receiver, balance);\r\n        }\r\n\r\n        emit TokenWithdrawn(token, receiver, balance);\r\n    }\r\n\r\n}"}}}