{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"campaign.sol":{"content":"/**\r\n SPDX-License-Identifier: MIT\r\n*/\r\n\r\npragma solidity ^0.8;\r\n\r\n\r\nabstract contract owned {\r\n    address payable public owner;\r\n\r\n    constructor ()  {\r\n        owner =  payable(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"only owner method\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n   function transfer(address _to, uint256 _value) external;\r\n   function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n   \r\n}\r\n\r\nabstract contract ERC20Holder is owned {\r\n    mapping (address => bool) acceptedTokens;\r\n    function modToken(address token,bool accepted) public onlyOwner {\r\n        acceptedTokens[token] = accepted;\r\n    }\r\n    \r\n    function tokenFallback(address _from, uint _value, bytes memory _data) pure public returns (bytes32 hash) {\r\n        bytes32 tokenHash = keccak256(abi.encodePacked(_from,_value,_data));\r\n        return tokenHash;\r\n    }\r\n    \r\n    fallback() external  payable {}\r\n    \r\n    function withdraw() onlyOwner public {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    function transferToken (address token,address to,uint256 val) public onlyOwner {\r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.transfer(to,val);\r\n    }\r\n    \r\n}\r\n\r\ncontract oracleClient is ERC20Holder {\r\n    \r\n    address oracle;\r\n    \r\n    function setOracle(address a) public  onlyOwner {\r\n        \r\n        oracle = a;\r\n    }\r\n}\r\n\r\ninterface IOracle {\r\n    function  ask (uint8 typeSN, string calldata idPost,string calldata idUser, bytes32 idRequest) external;\r\n    function  askBounty (uint8 typeSN, string calldata idPost,string calldata idUser, bytes32 idProm) external;\r\n    function oracleFee(address who)  external returns (uint256 fee);\r\n}\r\n\r\n\r\ncontract campaign is oracleClient {\r\n    \r\n    struct cpRatio {\r\n        uint256 likeRatio;\r\n        uint256 shareRatio;\r\n        uint256 viewRatio;\r\n        uint256 reachLimit;\r\n    }\r\n    \r\n    struct bountyUnit {\r\n        uint256 minRange;\r\n        uint256 maxRange;\r\n        uint256 typeSN;\r\n        uint256 amount;\r\n    }\r\n    \r\n    struct Campaign {\r\n\t\taddress advertiser;\r\n\t\tstring dataUrl; \r\n\t\tuint64 startDate;\r\n\t\tuint64 endDate;\r\n\t\tuint64 nbProms;\r\n\t\tuint64 nbValidProms;\r\n\t\tmapping (uint64 => bytes32)  proms;\r\n\t\tFund funds;\r\n\t\tmapping(uint8 => cpRatio)  ratios;\r\n\t\tbountyUnit[] bounties;\r\n\t}\r\n\t\r\n\t struct OracleUnit {\r\n\t\taddress advertiser;\r\n\t\tFund funds;\r\n\t}\r\n\t\r\n\tstruct Fund {\r\n\t    address token;\r\n\t    uint256 amount;\r\n\t}\r\n\t\r\n\tstruct Result  {\r\n\t    bytes32 idProm;\r\n\t    uint64 likes;\r\n\t    uint64 shares;\r\n\t    uint64 views;\r\n\t}\r\n\t\r\n\tstruct promElement {\r\n\t    address influencer;\r\n\t    bytes32 idCampaign;\r\n\t    bool isAccepted;\r\n\t    bool isPayed;\r\n\t    Fund funds;\r\n\t    uint8 typeSN;\r\n\t    string idPost;\r\n\t    string idUser;\r\n\t    uint64 nbResults;\r\n\t    mapping (uint64 => bytes32) results;\r\n\t    bytes32 prevResult;\r\n\t}\r\n\r\n\t\r\n\tmapping (bytes32  => Campaign) public campaigns;\r\n\tmapping (bytes32  => promElement) public proms;\r\n\tmapping (bytes32  => Result) public results;\r\n\tmapping (address  => OracleUnit) public oraclelist;\r\n\tmapping (bytes32 => bool) public isAlreadyUsed;\r\n\t\r\n\t\r\n\tevent CampaignCreated(bytes32 indexed id,uint64 startDate,uint64 endDate,string dataUrl);\r\n\tevent CampaignFundsSpent(bytes32 indexed id );\r\n\tevent CampaignApplied(bytes32 indexed id ,bytes32 indexed prom );\r\n    event PromAccepted(bytes32 indexed id );\r\n    event PromPayed(bytes32 indexed id ,uint256 amount);\r\n    event CampaignFunded(bytes32 indexed id,uint256 amount);\r\n\t\r\n    \r\n    function createCampaign(string memory dataUrl,\tuint64 startDate,uint64 endDate) public returns (bytes32 idCampaign) {\r\n        require(startDate > block.timestamp,\"start date too early\");\r\n        require(endDate > block.timestamp,\"end date too early\");\r\n        require(endDate > startDate,\"end date early than start\");\r\n       \r\n        bytes32 campaignId = keccak256(abi.encodePacked(msg.sender,dataUrl,startDate,endDate,block.timestamp));\r\n         // Campaign(msg.sender,dataUrl,startDate,endDate,0,0,0,Fund(address(0),0),0);\r\n        Campaign storage c = campaigns[campaignId];\r\n        c.advertiser = msg.sender;\r\n        c.dataUrl = dataUrl;\r\n        c.startDate = startDate;\r\n        c.endDate = endDate;\r\n        c.nbProms = 0;\r\n        c.nbValidProms = 0;\r\n        c.funds = Fund(address(0),0);\r\n        emit CampaignCreated(campaignId,startDate,endDate,dataUrl);\r\n        return campaignId;\r\n    }\r\n    \r\n    \r\n    \r\n    function modCampaign(bytes32 idCampaign,string memory dataUrl,\tuint64 startDate,uint64 endDate) public {\r\n        require(campaigns[idCampaign].advertiser == msg.sender,\"campaign owner mismatch\");\r\n        require(campaigns[idCampaign].startDate > block.timestamp,\"campaign already started\");\r\n        require(startDate > block.timestamp,\"start date too early\");\r\n        require(endDate > block.timestamp,\"end date too early\");\r\n        require(endDate > startDate,\"end date early than start\");\r\n       \r\n        campaigns[idCampaign].dataUrl = dataUrl;\r\n        campaigns[idCampaign].startDate = startDate;\r\n        campaigns[idCampaign].endDate = endDate;\r\n        emit CampaignCreated(idCampaign,startDate,endDate,dataUrl);\r\n    }\r\n    \r\n     function priceRatioCampaign(bytes32 idCampaign,uint8 typeSN,uint256 likeRatio,uint256 shareRatio,uint256 viewRatio,uint256 limit) public {\r\n        require(campaigns[idCampaign].advertiser == msg.sender,\"campaign owner mismatch\");\r\n        require(campaigns[idCampaign].startDate > block.timestamp,\"campaign already started\");\r\n        campaigns[idCampaign].ratios[typeSN] = cpRatio(likeRatio,shareRatio,viewRatio,limit);\r\n    }\r\n    \r\n  \r\n    \r\n    function fundCampaign (bytes32 idCampaign,address token,uint256 amount) public {\r\n        require(campaigns[idCampaign].endDate > block.timestamp,\"campaign ended\");\r\n        require(campaigns[idCampaign].funds.token == address(0) || campaigns[idCampaign].funds.token == token,\"token mismatch\");\r\n       \r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.transferFrom(msg.sender,address(this),amount);\r\n        uint256 prev_amount = campaigns[idCampaign].funds.amount;\r\n        \r\n        if(token == 0xDf49C9f599A0A9049D97CFF34D0C30E468987389 || token == 0x448BEE2d93Be708b54eE6353A7CC35C4933F1156) {\r\n            campaigns[idCampaign].funds = Fund(token,amount+prev_amount);\r\n            emit CampaignFunded(idCampaign,amount);\r\n        }\r\n        else {\r\n            campaigns[idCampaign].funds = Fund(token,(amount*85/100)+prev_amount);\r\n            emit CampaignFunded(idCampaign,(amount*85/100));\r\n        }\r\n      \r\n    }\r\n    \r\n    function createPriceFundYt(string memory dataUrl,uint64 startDate,uint64 endDate,uint256 likeRatio,uint256 viewRatio,address token,uint256 amount,uint256 limit) public returns (bytes32 idCampaign) {\r\n        bytes32 campaignId = createCampaign(dataUrl,startDate,endDate);\r\n        priceRatioCampaign(campaignId,2,likeRatio,0,viewRatio,limit);\r\n        fundCampaign(campaignId,token,amount);\r\n        return campaignId;\r\n    }\r\n    \r\n    function createPriceFundAll(\r\n            string memory dataUrl,\r\n            uint64  startDate,\r\n            uint64 endDate,\r\n            \r\n             uint256[] memory ratios,\r\n            address token,\r\n            uint256 amount) public returns (bytes32 idCampaign) {\r\n        \r\n        \r\n         require(startDate > block.timestamp,\"start date too early\");\r\n        require(endDate > block.timestamp,\"end date too early\");\r\n        require(endDate > startDate,\"end date early than start\");\r\n       \r\n        bytes32 campaignId = keccak256(abi.encodePacked(msg.sender,dataUrl,startDate,endDate,block.timestamp));\r\n        Campaign storage c = campaigns[campaignId];\r\n        c.advertiser = msg.sender;\r\n        c.dataUrl = dataUrl;\r\n        c.startDate = startDate;\r\n        c.endDate = endDate;\r\n        c.nbProms = 0;\r\n        c.nbValidProms = 0;\r\n        c.funds = Fund(address(0),0);\r\n        //campaigns[campaignId] = Campaign(msg.sender,dataUrl,startDate,endDate,0,0,Fund(address(0),0));\r\n        emit CampaignCreated(campaignId,startDate,endDate,dataUrl);\r\n        \r\n     \r\n\r\n            for (uint8 i=0;i<ratios.length;i=i+4) {\r\n              priceRatioCampaign(campaignId,(i/4)+1,ratios[i],ratios[i+1],ratios[i+2],ratios[i+3]);\r\n            }\r\n            \r\n            \r\n       \r\n        fundCampaign(campaignId,token,amount);\r\n        return campaignId;\r\n    }\r\n    \r\n    function createPriceFundBounty(\r\n            string memory dataUrl,\r\n            uint64  startDate,\r\n            uint64 endDate,\r\n            \r\n             uint256[] memory bounties,\r\n            address token,\r\n            uint256 amount) public returns (bytes32 idCampaign) {\r\n        \r\n        require(startDate > block.timestamp,\"start date too early\");\r\n        require(endDate > block.timestamp,\"end date too early\");\r\n        require(endDate > startDate,\"end date early than start\");\r\n       \r\n        bytes32 campaignId = keccak256(abi.encodePacked(msg.sender,dataUrl,startDate,endDate,block.timestamp));\r\n        Campaign storage c = campaigns[campaignId];\r\n        c.advertiser = msg.sender;\r\n        c.dataUrl = dataUrl;\r\n        c.startDate = startDate;\r\n        c.endDate = endDate;\r\n        c.nbProms = 0;\r\n        c.nbValidProms = 0;\r\n        c.funds = Fund(address(0),0);\r\n        for (uint i=0;i<bounties.length;i=i+4) {\r\n            c.bounties.push(bountyUnit(bounties[i],bounties[i+1],bounties[i+2],bounties[i+3]));\r\n        }\r\n        \r\n        emit CampaignCreated(campaignId,startDate,endDate,dataUrl);\r\n        \r\n        \r\n        fundCampaign(campaignId,token,amount);\r\n        return campaignId;\r\n    }\r\n    \r\n    function applyCampaign(bytes32 idCampaign,uint8 typeSN, string memory idPost, string memory idUser) public returns (bytes32 idProm) {\r\n        bytes32 prom = keccak256(abi.encodePacked(idCampaign,typeSN,idPost,idUser));\r\n        require(campaigns[idCampaign].endDate > block.timestamp,\"campaign ended\");\r\n        require(!isAlreadyUsed[prom],\"link already sent\");\r\n        bytes32 newIdProm = keccak256(abi.encodePacked( msg.sender,typeSN,idPost,idUser,block.timestamp));\r\n        promElement storage p = proms[newIdProm];\r\n        p.influencer = msg.sender;\r\n        p.idCampaign = idCampaign;\r\n        p.isAccepted = false;\r\n        p.funds = Fund(address(0),0);\r\n        p.typeSN = typeSN;\r\n        p.idPost = idPost;\r\n        p.idUser = idUser;\r\n        p.nbResults = 0;\r\n        p.prevResult = 0;\r\n        //proms[idProm] = promElement(msg.sender,idCampaign,false,Fund(address(0),0),typeSN,idPost,idUser,0,0);\r\n        campaigns[idCampaign].proms[campaigns[idCampaign].nbProms++] = newIdProm;\r\n        \r\n        bytes32 idRequest = keccak256(abi.encodePacked(typeSN,idPost,idUser,block.timestamp));\r\n        results[idRequest] = Result(newIdProm,0,0,0);\r\n        proms[newIdProm].results[0] = proms[newIdProm].prevResult = idRequest;\r\n        proms[newIdProm].nbResults = 1;\r\n        \r\n        //ask(typeSN,idPost,idUser,idRequest);\r\n        \r\n        isAlreadyUsed[prom] = true;\r\n        \r\n        emit CampaignApplied(idCampaign,newIdProm);\r\n        return newIdProm;\r\n    }\r\n    \r\n    function validateProm(bytes32 idProm) public {\r\n        Campaign storage cmp = campaigns[proms[idProm].idCampaign];\r\n        require(cmp.endDate > block.timestamp,\"campaign ended\");\r\n        require(cmp.advertiser == msg.sender,\"campaign owner mismatch\");\r\n        \r\n        proms[idProm].isAccepted = true;\r\n        cmp.nbValidProms++;\r\n\r\n        emit PromAccepted(idProm);\r\n    }\r\n\r\n    function validateProms(bytes32[] memory idProms) public {\r\n        for(uint64 i = 0;i < idProms.length ;i++) {\r\n            validateProm(idProms[i]);\r\n        }\r\n    }\r\n    \r\n    \r\n    function startCampaign(bytes32 idCampaign) public  {\r\n         require(campaigns[idCampaign].advertiser == msg.sender || msg.sender == owner,\"campaign owner mismatch\" );\r\n         require(campaigns[idCampaign].startDate > block.timestamp,\"campaign already started\");\r\n         campaigns[idCampaign].startDate = uint64(block.timestamp);\r\n    }\r\n    \r\n    function updateCampaignStats(bytes32 idCampaign) public  {\r\n        for(uint64 i = 0;i < campaigns[idCampaign].nbProms ;i++)\r\n        {\r\n            bytes32 idProm = campaigns[idCampaign].proms[i];\r\n            if(proms[idProm].isAccepted) {\r\n                bytes32 idRequest = keccak256(abi.encodePacked(proms[idProm].typeSN,proms[idProm].idPost,proms[idProm].idUser,block.timestamp));\r\n                results[idRequest] = Result(idProm,0,0,0);\r\n                proms[idProm].results[proms[idProm].nbResults++] = idRequest;\r\n                ask(proms[idProm].typeSN,proms[idProm].idPost,proms[idProm].idUser,idRequest);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function updatePromStats(bytes32 idProm) public returns (bytes32 requestId) {\r\n        require(proms[idProm].isAccepted,\"link not validated\"); \r\n        bytes32 idRequest = keccak256(abi.encodePacked(proms[idProm].typeSN,proms[idProm].idPost,proms[idProm].idUser,block.timestamp));\r\n        results[idRequest] = Result(idProm,0,0,0);\r\n        proms[idProm].results[proms[idProm].nbResults++] = idRequest;\r\n        ask(proms[idProm].typeSN,proms[idProm].idPost,proms[idProm].idUser,idRequest);\r\n        return idRequest;\r\n    }\r\n    \r\n    function updateBounty(bytes32 idProm) public  {\r\n        require(proms[idProm].isAccepted,\"link not validated\");\r\n        askBounty(proms[idProm].typeSN,proms[idProm].idPost,proms[idProm].idUser,idProm);\r\n    }\r\n    \r\n    function endCampaign(bytes32 idCampaign) public  {\r\n        require(campaigns[idCampaign].endDate > block.timestamp,\"campaign already ended\");\r\n        require(campaigns[idCampaign].advertiser == msg.sender || msg.sender == owner,\"campaign owner mismatch\" );\r\n        campaigns[idCampaign].endDate = uint64(block.timestamp);\r\n    }\r\n    \r\n    \r\n    function ask(uint8 typeSN, string memory idPost,string memory idUser,bytes32 idRequest) public {\r\n        IOracle o = IOracle(oracle);\r\n        o.ask(typeSN,idPost,idUser,idRequest);\r\n    }\r\n    \r\n    function askBounty(uint8 typeSN, string memory idPost,string memory idUser,bytes32 idProm) public {\r\n        IOracle o = IOracle(oracle);\r\n        o.askBounty(typeSN,idPost,idUser,idProm);\r\n    }\r\n    \r\n    function updateBounty(bytes32 idProm,uint256 nbAbos) external  returns (bool ok) {\r\n        require(msg.sender == oracle,\"oracle mismatch\");\r\n        \r\n        promElement storage prom = proms[idProm];\r\n        require(!prom.isPayed,\"link already paid\");\r\n        prom.isPayed= true;\r\n        prom.funds.token = campaigns[prom.idCampaign].funds.token;\r\n        \r\n        uint256 gain = 0;\r\n        for(uint256 i = 0;i<campaigns[prom.idCampaign].bounties.length;i++){\r\n            if(nbAbos >= campaigns[prom.idCampaign].bounties[i].minRange &&  nbAbos < campaigns[prom.idCampaign].bounties[i].maxRange && prom.typeSN == campaigns[prom.idCampaign].bounties[i].typeSN)\r\n            {\r\n                gain = campaigns[prom.idCampaign].bounties[i].amount;\r\n            }\r\n        }\r\n        \r\n        if(campaigns[prom.idCampaign].funds.amount <= gain )\r\n        {\r\n            campaigns[prom.idCampaign].endDate = uint64(block.timestamp);\r\n            prom.funds.amount += campaigns[prom.idCampaign].funds.amount;\r\n            campaigns[prom.idCampaign].funds.amount = 0;\r\n            emit CampaignFundsSpent(prom.idCampaign);\r\n            return true;\r\n        }\r\n        campaigns[prom.idCampaign].funds.amount -= gain;\r\n        prom.funds.amount += gain;\r\n        return true;\r\n        \r\n    }\r\n    \r\n    function update(bytes32 idRequest,uint64 likes,uint64 shares,uint64 views) external  returns (bool ok) {\r\n        require(msg.sender == oracle,\"oracle mismatch\");\r\n        \r\n        IOracle o = IOracle(oracle);\r\n        uint256 f = o.oracleFee(tx.origin);\r\n        promElement storage prom = proms[results[idRequest].idProm];\r\n        \r\n        if(f<0)\r\n        {\r\n           \r\n            if(oraclelist[address(msg.sender)].funds.token == address(0))\r\n            {\r\n                oraclelist[msg.sender].funds.token = campaigns[prom.idCampaign].funds.token;\r\n            }\r\n            require(oraclelist[address(msg.sender)].funds.token == campaigns[prom.idCampaign].funds.token,\"oracle funds mismatch\");\r\n            oraclelist[msg.sender].funds.amount += f;\r\n            campaigns[prom.idCampaign].funds.amount -= f;\r\n        }\r\n       \r\n        results[idRequest].likes = likes;\r\n        results[idRequest].shares = shares;\r\n        results[idRequest].views = views;\r\n       \r\n        uint256 gain = 0;\r\n        \r\n        if(likes > results[prom.prevResult].likes)\r\n            gain += (likes - results[prom.prevResult].likes)* campaigns[prom.idCampaign].ratios[prom.typeSN].likeRatio;\r\n        if(shares > results[prom.prevResult].shares)\r\n            gain += (shares - results[prom.prevResult].shares)* campaigns[prom.idCampaign].ratios[prom.typeSN].shareRatio;\r\n         if(views > results[prom.prevResult].views)\r\n        gain += (views - results[prom.prevResult].views)* campaigns[prom.idCampaign].ratios[prom.typeSN].viewRatio;\r\n        prom.prevResult = idRequest;\r\n        \r\n        //\r\n        // warn campaign low credits\r\n        //\r\n       \r\n       \r\n        if(prom.funds.token == address(0))\r\n        {\r\n            prom.funds.token = campaigns[prom.idCampaign].funds.token;\r\n        }\r\n        if(campaigns[prom.idCampaign].funds.amount <= gain )\r\n        {\r\n            campaigns[prom.idCampaign].endDate = uint64(block.timestamp);\r\n            prom.funds.amount += campaigns[prom.idCampaign].funds.amount;\r\n            campaigns[prom.idCampaign].funds.amount = 0;\r\n            emit CampaignFundsSpent(prom.idCampaign);\r\n            return true;\r\n        }\r\n        campaigns[prom.idCampaign].funds.amount -= gain;\r\n        prom.funds.amount += gain;\r\n        return true;\r\n    }\r\n    \r\n    function getGains(bytes32 idProm) public {\r\n        require(proms[idProm].influencer == msg.sender,\"link owner mismatch\");\r\n        IERC20 erc20 = IERC20(proms[idProm].funds.token);\r\n        uint256 amount = proms[idProm].funds.amount;\r\n        proms[idProm].funds.amount = 0;\r\n        erc20.transfer(proms[idProm].influencer,amount);\r\n\r\n        emit PromPayed(idProm,amount);\r\n        \r\n    }\r\n    \r\n    function getOracleFee() public {\r\n        \r\n        IERC20 erc20 = IERC20(oraclelist[msg.sender].funds.token);\r\n        uint256 amount = oraclelist[msg.sender].funds.amount;\r\n        oraclelist[msg.sender].funds.amount = 0;\r\n        erc20.transfer(msg.sender,amount);\r\n    }\r\n    \r\n    function getRemainingFunds(bytes32 idCampaign) public {\r\n        require(campaigns[idCampaign].advertiser == msg.sender,\"campaign owner mismatch\");\r\n        require(campaigns[idCampaign].endDate < block.timestamp,\"campaign not ended\");\r\n        IERC20 erc20 = IERC20(campaigns[idCampaign].funds.token);\r\n        uint256 amount = campaigns[idCampaign].funds.amount;\r\n        campaigns[idCampaign].funds.amount = 0;\r\n        erc20.transfer(campaigns[idCampaign].advertiser,amount);\r\n    }\r\n    \r\n    function getProms (bytes32 idCampaign) public view returns (bytes32[] memory cproms)\r\n    {\r\n        uint nbProms = campaigns[idCampaign].nbProms;\r\n        cproms = new bytes32[](nbProms);\r\n        \r\n        for (uint64 i = 0;i<nbProms;i++)\r\n        {\r\n            cproms[i] = campaigns[idCampaign].proms[i];\r\n        }\r\n        return cproms;\r\n    }\r\n    \r\n    function getRatios (bytes32 idCampaign) public view returns (uint8[] memory types,uint256[] memory likeRatios,uint256[] memory shareRatios,uint256[] memory viewRatios,uint256[] memory limits )\r\n    {   \r\n        uint8 l = 10;\r\n        types = new uint8[](l);\r\n        likeRatios = new uint256[](l);\r\n        shareRatios = new uint256[](l);\r\n        viewRatios = new uint256[](l);\r\n         limits = new uint256[](l);\r\n        for (uint8 i = 0;i<l;i++)\r\n        {\r\n            types[i] = i+1;\r\n            likeRatios[i] = campaigns[idCampaign].ratios[i+1].likeRatio;\r\n            shareRatios[i] = campaigns[idCampaign].ratios[i+1].shareRatio;\r\n            viewRatios[i] = campaigns[idCampaign].ratios[i+1].viewRatio;\r\n            limits[i] = campaigns[idCampaign].ratios[i+1].reachLimit;\r\n        }\r\n        return (types,likeRatios,shareRatios,viewRatios,limits);\r\n    }\r\n    \r\n    function getBounties (bytes32 idCampaign) public view returns (uint256[] memory bounty )\r\n    { \r\n        bounty = new uint256[](campaigns[idCampaign].bounties.length*4);\r\n        for (uint8 i = 0; i<campaigns[idCampaign].bounties.length; i++)\r\n        {\r\n         bounty[i*4] = campaigns[idCampaign].bounties[i].minRange;\r\n         bounty[i*4+1] = campaigns[idCampaign].bounties[i].maxRange;\r\n         bounty[i*4+2] = campaigns[idCampaign].bounties[i].typeSN;\r\n         bounty[i*4+3] = campaigns[idCampaign].bounties[i].amount;\r\n        }\r\n        return bounty;\r\n    }\r\n    \r\n    \r\n    function getResults (bytes32 idProm) public view returns (bytes32[] memory creq)\r\n    {\r\n        uint nbResults = proms[idProm].nbResults;\r\n        creq = new bytes32[](nbResults);\r\n        for (uint64 i = 0;i<nbResults;i++)\r\n        {\r\n            creq[i] = proms[idProm].results[i];\r\n        }\r\n        return creq;\r\n    }\r\n    \r\n    function getIsUsed(bytes32 idCampaign,uint8 typeSN, string memory idPost, string memory idUser) public view returns (bool) {\r\n        bytes32 prom = keccak256(abi.encodePacked(idCampaign,typeSN,idPost,idUser));\r\n        return isAlreadyUsed[prom];\r\n    }\r\n    \r\n    \r\n}"}}}