{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        \n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n            \n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n            \n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            \n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n            \n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               dataPtr := add(dataPtr, 3)\n               \n               // read 3 bytes\n               let input := mload(dataPtr)\n               \n               // write 4 characters\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n               resultPtr := add(resultPtr, 1)\n            }\n            \n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        \n        return result;\n    }\n}\n"
    },
    "contracts/IPublicSharedMetadata.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.6;\n\n/// Shared public library for on-chain NFT functions\ninterface IPublicSharedMetadata {\n    /// @param unencoded bytes to base64-encode\n    function base64Encode(bytes memory unencoded)\n        external\n        pure\n        returns (string memory);\n\n    /// Encodes the argument json bytes into base64-data uri format\n    /// @param json Raw json to base64 and turn into a data-uri\n    function encodeMetadataJSON(bytes memory json)\n        external\n        pure\n        returns (string memory);\n\n    /// Proxy to openzeppelin's toString function\n    /// @param value number to return as a string\n    function numberToString(uint256 value)\n        external\n        pure\n        returns (string memory);\n}\n"
    },
    "contracts/SharedNFTLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport {StringsUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport {Base64} from \"base64-sol/base64.sol\";\nimport {IPublicSharedMetadata} from \"./IPublicSharedMetadata.sol\";\n\n/// Shared NFT logic for rendering metadata associated with editions\n/// @dev Can safely be used for generic base64Encode and numberToString functions\ncontract SharedNFTLogic is IPublicSharedMetadata {\n    /// @param unencoded bytes to base64-encode\n    function base64Encode(bytes memory unencoded)\n        public\n        pure\n        override\n        returns (string memory)\n    {\n        return Base64.encode(unencoded);\n    }\n\n    /// Proxy to openzeppelin's toString function\n    /// @param value number to return as a string\n    function numberToString(uint256 value)\n        public\n        pure\n        override\n        returns (string memory)\n    {\n        return StringsUpgradeable.toString(value);\n    }\n\n    /// Generate edition metadata from storage information as base64-json blob\n    /// Combines the media data and metadata\n    /// @param name Name of NFT in metadata\n    /// @param description Description of NFT in metadata\n    /// @param imageUrl URL of image to render for edition\n    /// @param animationUrl URL of animation to render for edition\n    /// @param tokenOfEdition Token ID for specific token\n    /// @param editionSize Size of entire edition to show\n    function createMetadataEdition(\n        string memory name,\n        string memory description,\n        string memory imageUrl,\n        string memory animationUrl,\n        uint256 tokenOfEdition,\n        uint256 editionSize\n    ) external pure returns (string memory) {\n        string memory _tokenMediaData = tokenMediaData(\n            imageUrl,\n            animationUrl,\n            tokenOfEdition\n        );\n        bytes memory json = createMetadataJSON(\n            name,\n            description,\n            _tokenMediaData,\n            tokenOfEdition,\n            editionSize\n        );\n        return encodeMetadataJSON(json);\n    }\n\n    /// Function to create the metadata json string for the nft edition\n    /// @param name Name of NFT in metadata\n    /// @param description Description of NFT in metadata\n    /// @param mediaData Data for media to include in json object\n    /// @param tokenOfEdition Token ID for specific token\n    /// @param editionSize Size of entire edition to show\n    function createMetadataJSON(\n        string memory name,\n        string memory description,\n        string memory mediaData,\n        uint256 tokenOfEdition,\n        uint256 editionSize\n    ) public pure returns (bytes memory) {\n        bytes memory editionSizeText;\n        if (editionSize > 0) {\n            editionSizeText = abi.encodePacked(\n                \"/\",\n                numberToString(editionSize)\n            );\n        }\n        return\n            abi.encodePacked(\n                '{\"name\": \"',\n                name,\n                \" \",\n                numberToString(tokenOfEdition),\n                editionSizeText,\n                '\", \"',\n                'description\": \"',\n                description,\n                '\", \"',\n                mediaData,\n                'properties\": {\"number\": ',\n                numberToString(tokenOfEdition),\n                ', \"name\": \"',\n                name,\n                '\"}}'\n            );\n    }\n\n    /// Encodes the argument json bytes into base64-data uri format\n    /// @param json Raw json to base64 and turn into a data-uri\n    function encodeMetadataJSON(bytes memory json)\n        public\n        pure\n        override\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    base64Encode(json)\n                )\n            );\n    }\n\n    /// Generates edition metadata from storage information as base64-json blob\n    /// Combines the media data and metadata\n    /// @param imageUrl URL of image to render for edition\n    /// @param animationUrl URL of animation to render for edition\n    function tokenMediaData(\n        string memory imageUrl,\n        string memory animationUrl,\n        uint256 tokenOfEdition\n    ) public pure returns (string memory) {\n        bool hasImage = bytes(imageUrl).length > 0;\n        bool hasAnimation = bytes(animationUrl).length > 0;\n        if (hasImage && hasAnimation) {\n            return\n                string(\n                    abi.encodePacked(\n                        'image\": \"',\n                        imageUrl,\n                        \"?id=\",\n                        numberToString(tokenOfEdition),\n                        '\", \"animation_url\": \"',\n                        animationUrl,\n                        \"?id=\",\n                        numberToString(tokenOfEdition),\n                        '\", \"'\n                    )\n                );\n        }\n        if (hasImage) {\n            return\n                string(\n                    abi.encodePacked(\n                        'image\": \"',\n                        imageUrl,\n                        \"?id=\",\n                        numberToString(tokenOfEdition),\n                        '\", \"'\n                    )\n                );\n        }\n        if (hasAnimation) {\n            return\n                string(\n                    abi.encodePacked(\n                        'animation_url\": \"',\n                        animationUrl,\n                        \"?id=\",\n                        numberToString(tokenOfEdition),\n                        '\", \"'\n                    )\n                );\n        }\n\n        return \"\";\n    }\n}\n"
    }
  }
}