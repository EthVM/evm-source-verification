{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":0},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MarbleNFTCandidate.sol":{"content":"// File: @0xcert/ethereum-utils/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based\r\n * on the source code at https://goo.gl/iyQsmU.\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   * @param _a Factor number.\r\n   * @param _b Factor number.\r\n   */\r\n  function mul(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   * @param _a Dividend number.\r\n   * @param _b Divisor number.\r\n   */\r\n  function div(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a / _b;\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _a Minuend number.\r\n   * @param _b Subtrahend number.\r\n   */\r\n  function sub(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   * @param _a Number.\r\n   * @param _b Number.\r\n   */\r\n  function add(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/ERC165.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces. See https://goo.gl/cxQCse.\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * @notice This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/SupportsInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces.\r\n   * @notice You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/AddressUtils.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 size;\r\n\r\n    /**\r\n     * XXX Currently there is no better way to check if there is a contract in an address than to\r\n     * check the size of the code at that address.\r\n     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n     * TODO: Check this again before the Serenity release, because all addresses will be\r\n     * contracts then.\r\n     */\r\n    assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code\r\n * at https://goo.gl/n2ZGVt.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    onlyOwner\r\n    public\r\n  {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/ownership/Claimable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code\r\n * at goo.gl/CfEAkv and upgrades Ownable contracts with additional claim step which makes ownership\r\n * transfers less prone to errors.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Allows the current owner to give new owner ability to claim the ownership of the contract.\r\n   * This differs from the Owner's function in that it allows setting pedingOwner address to 0x0,\r\n   * which effectively cancels an active claim.\r\n   * @param _newOwner The address which can claim ownership of the contract.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    onlyOwner\r\n    public\r\n  {\r\n    pendingOwner = _newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current pending owner to claim the ownership of the contract. It emits\r\n   * OwnershipTransferred event and resets pending owner to 0.\r\n   */\r\n  function claimOwnership()\r\n    public\r\n  {\r\n    require(msg.sender == pendingOwner);\r\n    address previousOwner = owner;\r\n    owner = pendingOwner;\r\n    pendingOwner = 0;\r\n    emit OwnershipTransferred(previousOwner, owner);\r\n  }\r\n}\r\n\r\n// File: contracts/Adminable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Adminable\r\n * @dev Allows to manage privilages to special contract functionality.\r\n */\r\ncontract Adminable is Claimable {\r\n  mapping(address => uint) public adminsMap;\r\n  address[] public adminList;\r\n\r\n  /**\r\n   * @dev Returns true, if provided address has special privilages, otherwise false\r\n   * @param adminAddress - address to check\r\n   */\r\n  function isAdmin(address adminAddress)\r\n    public\r\n    view\r\n    returns(bool isIndeed)\r\n  {\r\n    if (adminAddress == owner) return true;\r\n\r\n    if (adminList.length == 0) return false;\r\n    return (adminList[adminsMap[adminAddress]] == adminAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants special rights for address holder\r\n   * @param adminAddress - address of future admin\r\n   */\r\n  function addAdmin(address adminAddress)\r\n    public\r\n    onlyOwner\r\n    returns(uint index)\r\n  {\r\n    require(!isAdmin(adminAddress), \"Address already has admin rights!\");\r\n\r\n    adminsMap[adminAddress] = adminList.push(adminAddress)-1;\r\n\r\n    return adminList.length-1;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes special rights for provided address\r\n   * @param adminAddress - address of current admin\r\n   */\r\n  function removeAdmin(address adminAddress)\r\n    public\r\n    onlyOwner\r\n    returns(uint index)\r\n  {\r\n    // we can not remove owner from admin role\r\n    require(owner != adminAddress, \"Owner can not be removed from admin role!\");\r\n    require(isAdmin(adminAddress), \"Provided address is not admin.\");\r\n\r\n    uint rowToDelete = adminsMap[adminAddress];\r\n    address keyToMove = adminList[adminList.length-1];\r\n    adminList[rowToDelete] = keyToMove;\r\n    adminsMap[keyToMove] = rowToDelete;\r\n    adminList.length--;\r\n\r\n    return rowToDelete;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(isAdmin(msg.sender), \"Can be executed only by admin accounts!\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts/Priceable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Priceable\r\n * @dev Contracts allows to handle ETH resources of the contract.\r\n */\r\ncontract Priceable is Claimable {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * @dev Emits when owner take ETH out of contract\r\n   * @param balance - amount of ETh sent out from contract\r\n   */\r\n  event Withdraw(uint256 balance);\r\n\r\n  /**\r\n   * @dev modifier Checks minimal amount, what was sent to function call.\r\n   * @param _minimalAmount - minimal amount neccessary to  continue function call\r\n   */\r\n  modifier minimalPrice(uint256 _minimalAmount) {\r\n    require(msg.value >= _minimalAmount, \"Not enough Ether provided.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier Associete fee with a function call. If the caller sent too much, then is refunded, but only after the function body.\r\n   * This was dangerous before Solidity version 0.4.0, where it was possible to skip the part after `_;`.\r\n   * @param _amount - ether needed to call the function\r\n   */\r\n  modifier price(uint256 _amount) {\r\n    require(msg.value >= _amount, \"Not enough Ether provided.\");\r\n    _;\r\n    if (msg.value > _amount) {\r\n      msg.sender.transfer(msg.value.sub(_amount));\r\n    }\r\n  }\r\n\r\n  /*\r\n   * @dev Remove all Ether from the contract, and transfer it to account of owner\r\n   */\r\n  function withdrawBalance()\r\n    external\r\n    onlyOwner\r\n  {\r\n    uint256 balance = address(this).balance;\r\n    msg.sender.transfer(balance);\r\n\r\n    // Tell everyone !!!!!!!!!!!!!!!!!!!!!!\r\n    emit Withdraw(balance);\r\n  }\r\n\r\n  // fallback function that allows contract to accept ETH\r\n  function () public payable {}\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism for mainenance purposes\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   */\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause()\r\n    external\r\n    onlyOwner\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    paused = true;\r\n    emit Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause()\r\n    external\r\n    onlyOwner\r\n    whenPaused\r\n    returns (bool)\r\n  {\r\n    paused = false;\r\n    emit Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/MarbleNFTCandidateInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Marble NFT Candidate Contract\r\n * @dev Contracts allows public audiance to create Marble NFT candidates. All our candidates for NFT goes through our services to figure out if they are suitable for Marble NFT.\r\n * once their are picked our other contract will create NFT with same owner as candite and plcae it to minting auction. In minitng auction everyone can buy created NFT until duration period.\r\n * If duration is over, and noone has bought NFT, then creator of candidate can take Marble NFT from minting auction to his collection.\r\n */\r\ninterface MarbleNFTCandidateInterface {\r\n\r\n  /**\r\n   * @dev Sets minimal price for creating Marble NFT Candidate\r\n   * @param _minimalMintingPrice Minimal price asked from creator of Marble NFT candidate (weis)\r\n   */\r\n  function setMinimalPrice(uint256 _minimalMintingPrice)\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns true if URI is already a candidate. Otherwise false.\r\n   * @param _uri URI to check\r\n   */\r\n  function isCandidate(string _uri)\r\n    external\r\n    view\r\n    returns(bool isIndeed);\r\n\r\n\r\n  /**\r\n   * @dev Creates Marble NFT Candidate. This candidate will go through our processing. If it's suitable, then Marble NFT is created.\r\n   * @param _uri URI of resource you want to transform to Marble NFT\r\n   */\r\n  function createCandidate(string _uri)\r\n    external\r\n    payable\r\n    returns(uint index);\r\n\r\n  /**\r\n   * @dev Removes URI from candidate list.\r\n   * @param _uri URI to be removed from candidate list.\r\n   */\r\n  function removeCandidate(string _uri)\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns total count of candidates.\r\n   */\r\n  function getCandidatesCount()\r\n    external\r\n    view\r\n    returns(uint256 count);\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function getUriHash(string _uri)\r\n    external\r\n    view\r\n    returns(uint256 hash);\r\n\r\n  /**\r\n   * @dev Returns Candidate model by URI\r\n   * @param _uri URI representing candidate\r\n   */\r\n  function getCandidate(string _uri)\r\n    external\r\n    view\r\n    returns(\r\n    uint256 index,\r\n    address owner,\r\n    uint256 mintingPrice,\r\n    string url,\r\n    uint256 created);\r\n}\r\n\r\n// File: contracts/MarbleNFTCandidate.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Marble NFT Candidate Contract\r\n * @dev Contracts allows public audiance to create Marble NFT candidates. All our candidates for NFT goes through our services to figure out if they are suitable for Marble NFT.\r\n * once their are picked our other contract will create NFT with same owner as candite and plcae it to minting auction. In minitng auction everyone can buy created NFT until duration ends.\r\n * If duration is over, and noone has bought NFT, then creator of candidate can take Marble NFT from minting auction to his collection.\r\n */\r\ncontract MarbleNFTCandidate is\r\n  SupportsInterface,\r\n  Adminable,\r\n  Pausable,\r\n  Priceable,\r\n  MarbleNFTCandidateInterface\r\n{\r\n\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  struct Candidate {\r\n    uint256 index;\r\n\r\n    // possible NFT creator\r\n    address owner;\r\n\r\n    // price paid for minting and placiing NFT to initial auction\r\n    uint256 mintingPrice;\r\n\r\n    // CANDIDATES DNA\r\n    string uri;\r\n\r\n    // date of creation\r\n    uint256 created;\r\n  }\r\n\r\n  // minimal price for creating candidate\r\n  uint256 public minimalMintingPrice;\r\n\r\n  // index of candidate in candidates is unique candidate id\r\n  mapping(uint256 => Candidate) public uriHashToCandidates;\r\n  uint256[] public uriHashIndex;\r\n\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function _getUriHash(string _uri)\r\n    internal\r\n    pure\r\n    returns(uint256 hash_) // `hash` changed to `hash_` - according to review\r\n  {\r\n    return uint256(keccak256(abi.encodePacked(_uri)));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if URI is already a candidate. Otherwise false.\r\n   * @param _uri URI to check\r\n   */\r\n  function _isCandidate(string _uri)\r\n    internal\r\n    view\r\n    returns(bool isIndeed)\r\n  {\r\n    if(uriHashIndex.length == 0) return false;\r\n\r\n    uint256 uriHash = _getUriHash(_uri);\r\n    return (uriHashIndex[uriHashToCandidates[uriHash].index] == uriHash);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets minimal price for creating Marble NFT Candidate\r\n   * @param _minimalMintingPrice Minimal price asked from creator of Marble NFT candidate\r\n   */\r\n  function setMinimalPrice(uint256 _minimalMintingPrice)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    minimalMintingPrice = _minimalMintingPrice;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if URI is already a candidate. Otherwise false.\r\n   * @param _uri URI to check\r\n   */\r\n  function isCandidate(string _uri)\r\n    external\r\n    view\r\n    returns(bool isIndeed)\r\n  {\r\n    return _isCandidate(_uri);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates Marble NFT Candidate. This candidate will go through our processing. If it's suitable, then Marble NFT is created.\r\n   * @param _uri URI of resource you want to transform to Marble NFT\r\n   */\r\n  function createCandidate(string _uri)\r\n    external\r\n    whenNotPaused\r\n    payable\r\n    minimalPrice(minimalMintingPrice)\r\n    returns(uint256 index)\r\n  {\r\n    uint256 uriHash = _getUriHash(_uri);\r\n\r\n    require(uriHash != _getUriHash(\"\"), \"Candidate URI can not be empty!\");\r\n    require(!_isCandidate(_uri), \"Candidate is already created!\");\r\n\r\n    uriHashToCandidates[uriHash] = Candidate(uriHashIndex.push(uriHash)-1, msg.sender, msg.value, _uri, now);\r\n    return uriHashIndex.length -1;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Removes URI from candidate list.\r\n   * @param _uri URI to be removed from candidate list.\r\n   */\r\n  function removeCandidate(string _uri)\r\n    external\r\n    onlyAdmin\r\n  {\r\n    require(_isCandidate(_uri), \"Candidate is not present!\");\r\n\r\n    uint256 uriHash = _getUriHash(_uri);\r\n\r\n    uint256 rowToDelete = uriHashToCandidates[uriHash].index;\r\n    uint256 keyToMove = uriHashIndex[uriHashIndex.length-1];\r\n    uriHashIndex[rowToDelete] = keyToMove;\r\n    uriHashToCandidates[keyToMove].index = rowToDelete;\r\n\r\n    delete uriHashToCandidates[uriHash];\r\n    uriHashIndex.length--;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns total count of candidates.\r\n   */\r\n  function getCandidatesCount()\r\n    external\r\n    view\r\n    returns(uint256 count)\r\n  {\r\n    return uriHashIndex.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function getUriHash(string _uri)\r\n    external\r\n    view\r\n    returns(uint256 hash)\r\n  {\r\n    return _getUriHash(_uri);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Returns Candidate model by URI\r\n   * @param _uri URI representing candidate\r\n   */\r\n  function getCandidate(string _uri)\r\n    external\r\n    view\r\n    returns(\r\n    uint256 index,\r\n    address owner,\r\n    uint256 mintingPrice,\r\n    string uri,\r\n    uint256 created)\r\n  {\r\n    Candidate memory candidate = uriHashToCandidates[_getUriHash(_uri)];\r\n\r\n    return (\r\n      candidate.index,\r\n      candidate.owner,\r\n      candidate.mintingPrice,\r\n      candidate.uri,\r\n      candidate.created);\r\n  }\r\n\r\n}"}}}