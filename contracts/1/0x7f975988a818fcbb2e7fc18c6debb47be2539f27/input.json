{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ITPLeader.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.4;\r\n \r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n \r\n   /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */ \r\n   modifier onlyOwner(){\r\n        require(msg.sender == owner, 'Operation is for owner only');\r\n        _;\r\n    }\r\n \r\n   /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */ \r\n   function transferOwnership(address newOwner) onlyOwner public{\r\n        require(newOwner != address(0), 'Wrong new owner address');\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ITPLeader\r\n * @dev ITP entrance contract.\r\n */\r\ncontract ITPLeader is Ownable{\r\n\r\n    struct User{\r\n        uint32 id;\r\n        uint32 level;\r\n        address referrer;\r\n    }\r\n\r\n    struct Tree{\r\n        uint64 parent;       // Id of parent tree node.\r\n        uint64[] childs;     // Tree child node ids.\r\n        address userAddress; // Node owner address.\r\n    }\r\n\r\n    struct Slot{\r\n        bool isActive;       // Is slot activated (fully upgraded).\r\n        uint toUpgrade;      // Amount of ether reserved to upgrade from first slot\r\n        uint64[] treeIds;    // Ids of tree nodes in ascending order. Length - 1 is reinvest count.\r\n    }\r\n    \r\n    // Prvious and current rate in cents.\r\n    uint private previousRate;\r\n    uint public currentRate;\r\n\r\n    // Base users structure\r\n    mapping(address => User) public users;\r\n    // Getting address for internal user id\r\n    mapping(uint32 => address) public addressById;\r\n    uint32 private lastUserId;\r\n    \r\n    // Tree map is matrix => (level => (id => TreeNode))\r\n    mapping(uint32 => mapping(uint32 => mapping(uint64 => Tree))) private tree;\r\n    // Slot map is matrix => (level => (address => TreeNode))\r\n    mapping(uint32 => mapping(uint32 => mapping(address => Slot))) private slots;\r\n    uint64 public currentNode;\r\n\r\n    // Maximum number of level\r\n    uint32 public maxLevel;\r\n    mapping(uint32 => uint32) public levelPriceUSDCent;\r\n\r\n    address private rateAddress;\r\n    address private topAddress;\r\n    bytes32 private signPhrase;\r\n    \r\n    event NewRate(uint value, uint timestamp);\r\n    event Register(address indexed userAddress, address indexed referrerAddress, uint32 userId);\r\n    event Reinvest(address indexed userAddress, address indexed referrerAddress, uint32 matrix, uint32 level);\r\n    event UnderUpgrade(address indexed userAddress, uint32 matrix, uint32 level);\r\n    event Upgrade(address indexed userAddress, address indexed referrerAddress, uint32 matrix, uint32 level);\r\n    event Transfer(address indexed from, address indexed to, uint amount, uint32 matrix, uint32 level);\r\n\r\n    constructor(){\r\n        owner = msg.sender;\r\n\r\n        // Set constant level costs\r\n        maxLevel = 14;\r\n        uint32 price = 1250;\r\n        for(uint32 i = 1; i <= maxLevel; i++){\r\n            levelPriceUSDCent[i] = price;\r\n            price = price * 2;\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Convert cent price to wei by the given rate.\r\n     * @param cents Price in USD cents.\r\n     * @param rate rate used to convert.\r\n     * @return An uint representing wei amount for supplied cent price.\r\n     */\r\n    function _toWeiPrice(uint cents, uint rate) private pure returns (uint){\r\n        if(cents == 0 || rate == 0){\r\n            return 0;\r\n        }\r\n        \r\n        uint centswei = cents * 1 ether;\r\n        require(cents == centswei / 1 ether);\r\n\r\n        return centswei / rate;\r\n    }\r\n\r\n    /** \r\n     * @dev Convert cent price to wei using current rate.\r\n     * @param priceCent Price in USD cents.\r\n     * @return An uint representing wei amount for supplied cent price.\r\n     */\r\n    function toWeiPrice(uint priceCent) public view returns (uint){\r\n        return _toWeiPrice(priceCent, currentRate);\r\n    }\r\n\r\n    /** \r\n     * @dev Check correspondence USD cent to wei price historically up to two rates ago.\r\n     * @param priceCent Price in USD cents.\r\n     * @param priceWei Price in Wei.\r\n     * @return True if price corresponds to current or previouse wei cost.\r\n     */\r\n    function checkPrice(uint priceCent, uint priceWei) private view returns (bool){\r\n        if(_toWeiPrice(priceCent, currentRate) == priceWei || _toWeiPrice(priceCent, previousRate) == priceWei){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n  \r\n    /** \r\n     * @dev Set new ETH to USD rate.\r\n     * @param rate New rate value (1 ETH cost in cents).\r\n     */\r\n    function setRate(uint rate) public{\r\n        require(msg.sender == rateAddress, 'Operation is not permitted');\r\n        previousRate = currentRate;\r\n        currentRate = rate;\r\n        NewRate(rate, block.timestamp);\r\n    }\r\n\r\n    /** \r\n     * @dev Set the phrase required for the sign.\r\n     * @param phrase The phrase itself.\r\n     */\r\n    function setSignPhrase(bytes32 phrase) onlyOwner public{\r\n        signPhrase = phrase;\r\n    }\r\n\r\n    /** \r\n     * @dev Get user upline.\r\n     * @param userAddress User address.\r\n     * @return Array of upline addresses starting from referrer.\r\n     */\r\n    function getUpline(address userAddress) public view returns (address[]  memory){\r\n        address[] memory upline = new address[](users[userAddress].level);\r\n        \r\n        uint32 i = 0;\r\n        while(users[userAddress].id > 0){\r\n            upline[i++] = users[userAddress].referrer;\r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n\r\n        return upline;\r\n    }\r\n\r\n    /** \r\n     * @dev Get user code to register in other blockchains.\r\n     * @param userAddress User address.\r\n     * @param signature Signed message by the user (ask to ITP how to obtain this message).\r\n     * @return Hash that could be provided to other contracts.\r\n     */\r\n    function getCode(address userAddress, bytes memory signature) public view returns (bytes32){\r\n        require(users[userAddress].id > 0, \"User is not registered yet\");\r\n        \r\n        bytes32 message = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(userAddress, users[userAddress].id, signPhrase))));\r\n        require(recoverSigner(message, signature) == userAddress, \"Wrong signature\");\r\n\r\n        return keccak256(abi.encodePacked(userAddress, users[userAddress].id, signPhrase));\r\n    }\r\n\r\n    /** \r\n     * @dev Get the message signer.\r\n     * @param message Signed message.\r\n     * @param signature Signature provided by the signer.\r\n     * @return Signer address.\r\n     */\r\n    function recoverSigner(bytes32 message, bytes memory signature) private pure returns (address){\r\n        require(signature.length == 65);\r\n        \r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        assembly{\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    /** \r\n     * @dev Init first node for each matrix and set to owner unlimited abilities. Could be called once. Owner can change parameters separately thereafter.\r\n     * @param ownerAddress Address of person who is top referrer.\r\n     */\r\n    function init(address ownerAddress) onlyOwner public{\r\n        require(lastUserId == 0, \"Contract has already been initialized\");\r\n        \r\n        topAddress = ownerAddress;\r\n\r\n        uint32 _lastUserId = lastUserId + 1;\r\n        users[ownerAddress].id = _lastUserId;\r\n        users[ownerAddress].level = 1;\r\n        addressById[_lastUserId] = ownerAddress;\r\n        lastUserId = _lastUserId;\r\n\r\n        // Init all matrix levels / top nodes with top address\r\n        uint64 _currentNode = currentNode;\r\n        for(uint32 i = 1; i <= maxLevel; i++){\r\n            _currentNode ++;\r\n            tree[3][i][_currentNode].userAddress = ownerAddress;\r\n            slots[3][i][ownerAddress].isActive = true;\r\n            slots[3][i][ownerAddress].treeIds.push(_currentNode);\r\n\r\n            _currentNode ++;\r\n            tree[6][i][_currentNode].userAddress = ownerAddress;\r\n            slots[6][i][ownerAddress].isActive = true;\r\n            slots[6][i][ownerAddress].treeIds.push(_currentNode);\r\n        }\r\n        currentNode = _currentNode;\r\n    }\r\n\r\n    /** \r\n     * @dev Change the address that receives fund from top account.\r\n     * @param addr Top address that receives funds.\r\n     */\r\n    function setTopAddress(address addr) onlyOwner public{\r\n        require(addr != address(0), \"Top address cannot be null\");\r\n        topAddress = addr;\r\n    }\r\n\r\n    /** \r\n     * @dev Change the address that provide ETH to USD rates.\r\n     * @param addr Allowed address.\r\n     */\r\n    function setRateAddress(address addr) onlyOwner public{\r\n        require(addr != address(0), \"Rate address cannot be null\");\r\n        rateAddress = addr;\r\n    }\r\n\r\n    /** \r\n     * @dev Default etrance method. Most registrations start here.\r\n     */\r\n    receive() external payable{\r\n        if(msg.data.length == 0) {\r\n            register(msg.sender, tree[3][1][1].userAddress);\r\n        }else{\r\n            register(msg.sender, bytesToAddress(msg.data));\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Alternative user registration with certain referrer.\r\n     * @param referrerAddress Address of user referrer.\r\n     */\r\n    function start(address referrerAddress) external payable{\r\n        register(msg.sender, referrerAddress);\r\n    }\r\n\r\n    /** \r\n     * @dev Register user in both matrixes and referral contract as well.\r\n     * @param userAddress Address of the user.\r\n     * @param referrerAddress Address of user referrer.\r\n     */\r\n    function register(address userAddress, address referrerAddress) private{\r\n        // Check user and partner and register them if required\r\n        require(tx.origin == msg.sender, \"Address cannot be a contract\");\r\n        require(users[userAddress].id == 0, \"User has already activated\");\r\n        require(users[referrerAddress].id > 0, \"Referrer partner has not activated yet\");\r\n\r\n        // Check provided cost for two matrixes for first level\r\n        uint requiredCost = levelPriceUSDCent[1] * 2;\r\n        bool isCostValid = checkPrice(requiredCost, msg.value);\r\n        require(isCostValid && msg.value > 0, \"Invalid or out to date level cost\");\r\n\r\n        // Store user to referral tree\r\n        uint32 userId = lastUserId + 1;\r\n        users[userAddress].id = userId;\r\n        users[userAddress].level = users[referrerAddress].level + 1;\r\n        users[userAddress].referrer = referrerAddress;\r\n        addressById[userId] = userAddress;\r\n        lastUserId = userId;\r\n        \r\n        // Divide wei between 3 and 6 matrixes\r\n        uint cost3 = msg.value / 2;\r\n        uint cost6 = msg.value - cost3;\r\n\r\n        // Set the user to both matrixes\r\n        Register(userAddress, referrerAddress, userId);\r\n        setTo3Matrix(userAddress, referrerAddress, 1, cost3);\r\n        setTo6Matrix(userAddress, referrerAddress, 1, cost6);\r\n    }\r\n\r\n    /** \r\n     * @dev Buy new level for selected matrix.\r\n     * @param matrix Matrix number \"3\" or \"6\".\r\n     * @param level New level. Previous level should be activated!\r\n     */\r\n    function buyLevel(uint32 matrix, uint32 level) external payable{\r\n        require(matrix == 3 || matrix == 6, \"Have no such matrix\");\r\n        require(level >= 2 && level <= maxLevel, \"Matrix has no requested level\");\r\n        require(!slots[matrix][level][msg.sender].isActive, \"This level has already been activated\");\r\n        require(slots[matrix][level-1][msg.sender].isActive, \"You should activate previous level first\");\r\n\r\n        // Check provided cost for required level\r\n        uint requiredCost = levelPriceUSDCent[level];\r\n        bool isCostValid = checkPrice(requiredCost, msg.value);\r\n\r\n        // Check if change required\r\n        uint cost = msg.value;\r\n        if(slots[matrix][level][msg.sender].toUpgrade > 0){\r\n            if(!isCostValid){\r\n                requiredCost = requiredCost / 2;\r\n                isCostValid = checkPrice(requiredCost, msg.value);\r\n            }else{\r\n                // Send the change back to user\r\n                uint change = msg.value / 2;\r\n                cost = msg.value - change;\r\n                slots[matrix][level][msg.sender].toUpgrade = 0;\r\n                msg.sender.transfer(cost);\r\n            }\r\n        }\r\n        require(isCostValid && cost > 0, \"Invalid or out to date level cost\");\r\n\r\n        address nearestReferrer = findReferrer(matrix, level, msg.sender);\r\n        if(matrix == 3){\r\n            setTo3Matrix(msg.sender, nearestReferrer, level, cost);\r\n        }else if(matrix == 6){\r\n            setTo6Matrix(msg.sender, nearestReferrer, level, cost);\r\n        }\r\n        Upgrade(msg.sender, nearestReferrer, matrix, level);\r\n    }\r\n\r\n    /**\r\n     * @dev Recursive method that puts the user to M3 and performs according actions.\r\n     * @param userAddress Address of the user.\r\n     * @param referrerAddress Address of user referrer.\r\n     * @param level Matrix level.\r\n     * @param cost Amount of ether to be transfered to upline.\r\n     */\r\n    function setTo3Matrix(address userAddress, address referrerAddress, uint32 level, uint cost) private{\r\n        // Get referrer actual node\r\n        uint64 referrerNode = 0;\r\n        if(referrerAddress != address(0)){\r\n            referrerNode = slots[3][level][referrerAddress].treeIds[ slots[3][level][referrerAddress].treeIds.length - 1 ];\r\n        }\r\n        \r\n        // Add user tree node and slot\r\n        uint64 _currentNode = currentNode + 1;\r\n        tree[3][level][_currentNode].parent = referrerNode;\r\n        tree[3][level][_currentNode].userAddress = userAddress;\r\n        slots[3][level][userAddress].isActive = true;\r\n        slots[3][level][userAddress].treeIds.push(_currentNode);\r\n        currentNode = _currentNode;\r\n\r\n        // Stop if referrer node is 0 (it is possible for owner only) and send the ether to owner\r\n        if(referrerNode == 0){\r\n            transferEth(userAddress, cost);\r\n            Transfer(userAddress, address(0), cost, 3, level);\r\n            return;\r\n        }\r\n\r\n        // Modify partner's node\r\n        tree[3][level][referrerNode].childs.push(_currentNode);\r\n\r\n        // Check if the ether should be transfered and the process stopped\r\n        if(tree[3][level][referrerNode].childs.length < 3){\r\n            // First, check if it's an upgrade\r\n            if(level < maxLevel && slots[3][level][referrerAddress].treeIds.length == 2 && !slots[3][level + 1][referrerAddress].isActive){\r\n                // Do the half work before upgrade and wait next partner, accumulate ether for further transfer\r\n                if(slots[3][level + 1][referrerAddress].toUpgrade == 0){\r\n                    slots[3][level + 1][referrerAddress].toUpgrade = cost;\r\n                    UnderUpgrade(referrerAddress, 3, level + 1);\r\n                // Do the upgrade\r\n                }else{\r\n                    address nearestReferrer = findReferrer(3, level + 1, referrerAddress);\r\n                    setTo3Matrix(referrerAddress, nearestReferrer, level + 1, slots[3][level + 1][referrerAddress].toUpgrade + cost);\r\n                    slots[3][level + 1][referrerAddress].toUpgrade = 0;\r\n                    Upgrade(referrerAddress, nearestReferrer, 3, level + 1);\r\n                }\r\n                return;\r\n            }\r\n            \r\n            // In case of ordinary placement\r\n            transferEth(referrerAddress, cost);\r\n            Transfer(userAddress, referrerAddress, cost, 3, level);\r\n            return;\r\n        }\r\n\r\n        // Otherwise, create reinvested tree node (find referrer and create new node, transfer applies to a new referrer), recursively\r\n        address refReferrerAddress = findReferrer(3, level, referrerAddress);\r\n        setTo3Matrix(referrerAddress, refReferrerAddress, level, cost);\r\n        Reinvest(referrerAddress, refReferrerAddress, 3, level);\r\n    }\r\n\r\n    /**\r\n     * @dev Recursive method that puts the user to M6 and performs according actions.\r\n     * @param userAddress Address of the user.\r\n     * @param referrerAddress Address of user referrer.\r\n     * @param level Matrix level.\r\n     * @param cost Amount of ether to be transfered to upline.\r\n     */\r\n    function setTo6Matrix(address userAddress, address referrerAddress, uint32 level, uint cost) private{\r\n        // Get referrer actual node\r\n        uint64 referrerNode = 0;\r\n        if(referrerAddress != address(0)){\r\n            referrerNode = slots[6][level][referrerAddress].treeIds[ slots[6][level][referrerAddress].treeIds.length - 1 ];\r\n        }\r\n\r\n        // Get 2nd referrer node of actual referrer node\r\n        uint64 refReferrerNode = 0;\r\n        address refReferrerAddress = address(0);\r\n        if(referrerNode > 0){\r\n            refReferrerNode = tree[6][level][referrerNode].parent;\r\n            refReferrerAddress = tree[6][level][refReferrerNode].userAddress;\r\n        }\r\n\r\n        // Register to node and stop if referrer node is 0 (it is possible for owner only) and send the ether to owner\r\n        if(referrerNode == 0){\r\n            // Add user tree node and slot\r\n            uint64 _currentNode = currentNode + 1;\r\n            tree[6][level][_currentNode].parent = referrerNode;\r\n            tree[6][level][_currentNode].userAddress = userAddress;\r\n            slots[6][level][userAddress].isActive = true;\r\n            slots[6][level][userAddress].treeIds.push(_currentNode);\r\n            currentNode = _currentNode;\r\n\r\n            transferEth(userAddress, cost);\r\n            Transfer(userAddress, address(0), cost, 6, level);\r\n            return;\r\n        }\r\n\r\n        // Check if referrer has ability to register in first line\r\n        if(tree[6][level][referrerNode].childs.length < 2){\r\n            setTo6MatrixItem(userAddress, referrerNode, refReferrerNode, refReferrerAddress, level, cost);\r\n            return;\r\n        }\r\n\r\n        uint64[] storage refChilds = tree[6][level][referrerNode].childs;\r\n\r\n        // Try to register to the left second line otherwise\r\n        if(tree[6][level][refChilds[0]].childs.length < 2){\r\n            setTo6MatrixItem(userAddress, refChilds[0], referrerNode, referrerAddress, level, cost);\r\n            return;\r\n        }\r\n\r\n        // Register to the right second line finally\r\n        setTo6MatrixItem(userAddress, refChilds[1], referrerNode, referrerAddress, level, cost);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper to previous method since this should be called more than once.\r\n     * @param userAddress Address of the user.\r\n     * @param referrerNode Tree node under which user should be placed.\r\n     * @param refReferrerNode Tree node upon referrerNode.\r\n     * @param refReferrerAddress Address of that node.\r\n     * @param level Matrix level.\r\n     * @param cost Amount of ether to be transfered to upline.\r\n     */\r\n    function setTo6MatrixItem(address userAddress, uint64 referrerNode, uint64 refReferrerNode, address refReferrerAddress, uint32 level, uint cost) private{\r\n        // Add user tree node and slot\r\n        uint64 _currentNode = currentNode + 1;\r\n        tree[6][level][_currentNode].parent = referrerNode;\r\n        tree[6][level][_currentNode].userAddress = userAddress;\r\n        slots[6][level][userAddress].isActive = true;\r\n        slots[6][level][userAddress].treeIds.push(_currentNode);\r\n        currentNode = _currentNode;\r\n\r\n        // Modify partner's node\r\n        tree[6][level][referrerNode].childs.push(_currentNode);\r\n\r\n        // Check if it's an upgrade of ref referrer (if user have no active next level he doesn't have more than 2 partners on second line with the current)\r\n        if(level < maxLevel && refReferrerNode > 0 && slots[6][level][refReferrerAddress].treeIds.length == 2 && !slots[6][level + 1][refReferrerAddress].isActive){\r\n            // Do the half work before upgrade and wait next partner, accumulate ether for further transfer\r\n            if(slots[6][level + 1][refReferrerAddress].toUpgrade == 0){\r\n                slots[6][level + 1][refReferrerAddress].toUpgrade = cost;\r\n                UnderUpgrade(refReferrerAddress, 6, level + 1);\r\n            // Do the upgrade\r\n            }else{\r\n                address nearestReferrer = findReferrer(6, level + 1, refReferrerAddress);\r\n                setTo6Matrix(refReferrerAddress, nearestReferrer, level + 1, slots[6][level + 1][refReferrerAddress].toUpgrade + cost);\r\n                slots[6][level + 1][refReferrerAddress].toUpgrade = 0;\r\n                Upgrade(refReferrerAddress, nearestReferrer, 6, level + 1);\r\n            }\r\n            return;\r\n        }\r\n            \r\n        // Check if this is ordinary placement without reinvest\r\n        bool isFinal = refReferrerNode == 0 || tree[6][level][referrerNode].childs.length == 1;\r\n        if(!isFinal){\r\n            uint64[] storage refRefChilds = tree[6][level][refReferrerNode].childs;\r\n            // If ref refrral has one child only or the same has one of his child\r\n            if(refRefChilds.length < 2 || tree[6][level][ refRefChilds[0] ].childs.length < 2 || tree[6][level][ refRefChilds[1] ].childs.length < 2){\r\n                isFinal = true;\r\n            }\r\n        }\r\n        \r\n        // If it is ordinary placement\r\n        if(isFinal){\r\n            transferEth(refReferrerAddress, cost);\r\n            Transfer(userAddress, refReferrerAddress, cost, 6, level);\r\n            return;\r\n        }\r\n\r\n        // Otherwise, create reinvested tree node (find referrer and create new node, transfer applies to a new referrer), recursively\r\n        address refRefReferrerAddress = findReferrer(6, level, refReferrerAddress);\r\n        setTo6Matrix(refReferrerAddress, refRefReferrerAddress, level, cost);\r\n        Reinvest(refReferrerAddress, refRefReferrerAddress, 6, level);\r\n    }\r\n\r\n    /** \r\n     * @dev Return nearest address of referrers upline who is active in the same level of given matrix.\r\n     * @param matrix Matrix \"3\" or \"6\".\r\n     * @param level Matrix level.\r\n     * @param userAddress User address as a child.\r\n     * @return Address of the referrer. This could be 0.\r\n     */\r\n    function findReferrer(uint32 matrix, uint32 level, address userAddress) private view returns (address){\r\n        while(users[userAddress].id > 0){\r\n            if(slots[matrix][level][ users[userAddress].referrer ].isActive){\r\n                return users[userAddress].referrer;\r\n            }\r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n        return address(0);\r\n    }\r\n\r\n    /** \r\n     * @dev Transfer \"cost\" ether to \"to\" address.\r\n     * @param to Recepient of ether.\r\n     * @param cost Amount of ether to transfer.\r\n     */\r\n    function transferEth(address to, uint cost) private{\r\n        if(to == address(0) || to == tree[3][1][1].userAddress){\r\n            to = topAddress;\r\n\r\n            // Grant to ETHUSDRates contract owner\r\n            address payable ratesOwner = payable(owner);\r\n            if(ratesOwner.balance < 0.1 ether){\r\n                uint shortage = 0.2 ether - ratesOwner.balance;\r\n                if(shortage >= cost){\r\n                    ratesOwner.transfer(cost);\r\n                    return;\r\n                }else{\r\n                    cost = cost - shortage;\r\n                    ratesOwner.transfer(shortage);\r\n                }\r\n\r\n            }\r\n        }\r\n        \r\n        payable(to).transfer(cost);\r\n    }\r\n\r\n    /** \r\n     * @dev Get X node of required Matrix.\r\n     * @param matrix Matrix \"3\" or \"6\".\r\n     * @param level Matrix level.\r\n     * @param id Tree node id.\r\n     * @return Parameters of Tree structure: user address, parent node, parent address, child nodes, child addresses.\r\n     */\r\n    function getTreeNode(uint32 matrix, uint32 level, uint64 id) public view returns (address, uint64, address, uint64[] memory, address[] memory){\r\n        address[] memory childAddresses = new address[](tree[matrix][level][id].childs.length);\r\n        for(uint64 i = 0; i < tree[matrix][level][id].childs.length; i++){\r\n            childAddresses[i] = tree[matrix][level][ tree[matrix][level][id].childs[i] ].userAddress;\r\n        }\r\n        return (\r\n            tree[matrix][level][id].userAddress,\r\n            tree[matrix][level][id].parent,\r\n            tree[matrix][level][ tree[matrix][level][id].parent ].userAddress,\r\n            tree[matrix][level][id].childs,\r\n            childAddresses\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Get user slots info.\r\n     * @param matrix Matrix \"3\" or \"6\".\r\n     * @param level Matrix level.\r\n     * @param addr User address.\r\n     * @return Parameters of Slot structure: is slot level active, amount of wei as a first part of upgrade, tree ids from all (re)investments where last is a current.\r\n     */\r\n    function getSlot(uint32 matrix, uint32 level, address addr) public view returns (bool, uint, uint64[] memory){\r\n        return (slots[matrix][level][addr].isActive, slots[matrix][level][addr].toUpgrade, slots[matrix][level][addr].treeIds);\r\n    }\r\n\r\n    function bytesToAddress(bytes memory data) private pure returns (address addr){\r\n        assembly{\r\n            addr := mload(add(data, 20))\r\n        }\r\n    }\r\n}"}}}