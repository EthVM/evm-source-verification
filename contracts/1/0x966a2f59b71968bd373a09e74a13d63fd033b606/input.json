{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ConnectRefinance.sol":{"content":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface TokenInterface {\r\n    function approve(address, uint256) external;\r\n    function transfer(address, uint) external;\r\n    function transferFrom(address, address, uint) external;\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n    function balanceOf(address) external view returns (uint);\r\n    function decimals() external view returns (uint);\r\n}\r\n\r\n// Compound Helpers\r\ninterface CTokenInterface {\r\n    function mint(uint mintAmount) external returns (uint);\r\n    function borrow(uint borrowAmount) external returns (uint);\r\n    function repayBorrow(uint repayAmount) external returns (uint);\r\n\r\n    function borrowBalanceCurrent(address account) external returns (uint);\r\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ninterface CETHInterface {\r\n    function mint() external payable;\r\n    function repayBorrow() external payable;\r\n    // function repayBorrowBehalf(address borrower) external payable;\r\n    // function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\r\n}\r\n\r\ninterface InstaMapping {\r\n    function cTokenMapping(address) external view returns (address);\r\n    function gemJoinMapping(bytes32) external view returns (address);\r\n}\r\n\r\ninterface ComptrollerInterface {\r\n    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\r\n    // function exitMarket(address cTokenAddress) external returns (uint);\r\n    // function getAssetsIn(address account) external view returns (address[] memory);\r\n    // function getAccountLiquidity(address account) external view returns (uint, uint, uint);\r\n}\r\n// End Compound Helpers\r\n\r\n// Aave v1 Helpers\r\ninterface AaveV1Interface {\r\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external payable;\r\n    function redeemUnderlying(\r\n        address _reserve,\r\n        address payable _user,\r\n        uint256 _amount,\r\n        uint256 _aTokenBalanceAfterRedeem\r\n    ) external;\r\n    \r\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\r\n    function getUserReserveData(address _reserve, address _user) external view returns (\r\n        uint256 currentATokenBalance,\r\n        uint256 currentBorrowBalance,\r\n        uint256 principalBorrowBalance,\r\n        uint256 borrowRateMode,\r\n        uint256 borrowRate,\r\n        uint256 liquidityRate,\r\n        uint256 originationFee,\r\n        uint256 variableBorrowIndex,\r\n        uint256 lastUpdateTimestamp,\r\n        bool usageAsCollateralEnabled\r\n    );\r\n    function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external;\r\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf) external payable;\r\n}\r\n\r\ninterface AaveV1ProviderInterface {\r\n    function getLendingPool() external view returns (address);\r\n    function getLendingPoolCore() external view returns (address);\r\n}\r\n\r\ninterface AaveV1CoreInterface {\r\n    function getReserveATokenAddress(address _reserve) external view returns (address);\r\n}\r\n\r\ninterface ATokenV1Interface {\r\n    function redeem(uint256 _amount) external;\r\n    function balanceOf(address _user) external view returns(uint256);\r\n    function principalBalanceOf(address _user) external view returns(uint256);\r\n\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external;\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n}\r\n// End Aave v1 Helpers\r\n\r\n// Aave v2 Helpers\r\ninterface AaveV2Interface {\r\n    function deposit(address _asset, uint256 _amount, address _onBehalfOf, uint16 _referralCode) external;\r\n    function withdraw(address _asset, uint256 _amount, address _to) external;\r\n    function borrow(\r\n        address _asset,\r\n        uint256 _amount,\r\n        uint256 _interestRateMode,\r\n        uint16 _referralCode,\r\n        address _onBehalfOf\r\n    ) external;\r\n    function repay(address _asset, uint256 _amount, uint256 _rateMode, address _onBehalfOf) external;\r\n    function setUserUseReserveAsCollateral(address _asset, bool _useAsCollateral) external;\r\n    function getUserAccountData(address user) external view returns (\r\n        uint256 totalCollateralETH,\r\n        uint256 totalDebtETH,\r\n        uint256 availableBorrowsETH,\r\n        uint256 currentLiquidationThreshold,\r\n        uint256 ltv,\r\n        uint256 healthFactor\r\n    );\r\n}\r\n\r\ninterface AaveV2LendingPoolProviderInterface {\r\n    function getLendingPool() external view returns (address);\r\n}\r\n\r\n// Aave Protocol Data Provider\r\ninterface AaveV2DataProviderInterface {\r\n    function getUserReserveData(address _asset, address _user) external view returns (\r\n        uint256 currentATokenBalance,\r\n        uint256 currentStableDebt,\r\n        uint256 currentVariableDebt,\r\n        uint256 principalStableDebt,\r\n        uint256 scaledVariableDebt,\r\n        uint256 stableBorrowRate,\r\n        uint256 liquidityRate,\r\n        uint40 stableRateLastUpdated,\r\n        bool usageAsCollateralEnabled\r\n    );\r\n}\r\n// End Aave v2 Helpers\r\n\r\n// MakerDAO Helpers\r\ninterface ManagerLike {\r\n    function cdpCan(address, uint, address) external view returns (uint);\r\n    function ilks(uint) external view returns (bytes32);\r\n    function last(address) external view returns (uint);\r\n    function count(address) external view returns (uint);\r\n    function owns(uint) external view returns (address);\r\n    function urns(uint) external view returns (address);\r\n    function vat() external view returns (address);\r\n    function open(bytes32, address) external returns (uint);\r\n    function give(uint, address) external;\r\n    function frob(uint, int, int) external;\r\n    function flux(uint, address, uint) external;\r\n    function move(uint, address, uint) external;\r\n}\r\n\r\ninterface VatLike {\r\n    function can(address, address) external view returns (uint);\r\n    function ilks(bytes32) external view returns (uint, uint, uint, uint, uint);\r\n    function dai(address) external view returns (uint);\r\n    function urns(bytes32, address) external view returns (uint, uint);\r\n    function frob(\r\n        bytes32,\r\n        address,\r\n        address,\r\n        address,\r\n        int,\r\n        int\r\n    ) external;\r\n    function hope(address) external;\r\n    function move(address, address, uint) external;\r\n    function gem(bytes32, address) external view returns (uint);\r\n}\r\n\r\ninterface TokenJoinInterface {\r\n    function dec() external returns (uint);\r\n    function gem() external returns (TokenInterface);\r\n    function join(address, uint) external payable;\r\n    function exit(address, uint) external;\r\n}\r\n\r\ninterface DaiJoinInterface {\r\n    function vat() external returns (VatLike);\r\n    function dai() external returns (TokenInterface);\r\n    function join(address, uint) external payable;\r\n    function exit(address, uint) external;\r\n}\r\n\r\ninterface JugLike {\r\n    function drip(bytes32) external returns (uint);\r\n}\r\n// End MakerDAO Helpers\r\n\r\ncontract DSMath {\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"math-not-safe\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"sub-overflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\r\n    }\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function toRad(uint wad) internal pure returns (uint rad) {\r\n        rad = mul(wad, 10 ** 27);\r\n    }\r\n\r\n    function toInt(uint x) internal pure returns (int y) {\r\n        y = int(x);\r\n        require(y >= 0, \"int-overflow\");\r\n    }\r\n\r\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\r\n        amt = mul(_amt, 10 ** (18 - _dec));\r\n    }\r\n\r\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\r\n        amt = (_amt / 10 ** (18 - _dec));\r\n    }\r\n\r\n}\r\n\r\ncontract Helpers is DSMath {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    enum Protocol {\r\n        Aave,\r\n        AaveV2,\r\n        Compound\r\n    }\r\n\r\n    address payable constant feeCollector = 0xb1DC62EC38E6E3857a887210C38418E4A17Da5B2;\r\n\r\n    /**\r\n     * @dev Return ethereum address\r\n     */\r\n    function getEthAddr() internal pure returns (address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Weth address\r\n    */\r\n    function getWethAddr() internal pure returns (address) {\r\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // Mainnet WETH Address\r\n        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // Kovan WETH Address\r\n    }\r\n\r\n    /**\r\n     * @dev Connector Details.\r\n    */\r\n    function connectorID() public pure returns(uint _type, uint _id) {\r\n        (_type, _id) = (1, 72);\r\n    }\r\n\r\n    /**\r\n     * @dev Return InstaDApp Mapping Address\r\n     */\r\n    function getMappingAddr() internal pure returns (address) {\r\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\r\n    }\r\n\r\n    /**\r\n     * @dev Return Compound Comptroller Address\r\n     */\r\n    function getComptrollerAddress() internal pure returns (address) {\r\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Maker MCD DAI_Join Address.\r\n    */\r\n    function getMcdDaiJoin() internal pure returns (address) {\r\n        return 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Maker MCD Manager Address.\r\n    */\r\n    function getMcdManager() internal pure returns (address) {\r\n        return 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Maker MCD DAI Address.\r\n    */\r\n    function getMcdDai() internal pure returns (address) {\r\n        return 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    }\r\n\r\n    /**\r\n     * @dev Return Maker MCD Jug Address.\r\n    */\r\n    function getMcdJug() internal pure returns (address) {\r\n        return 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\r\n    }\r\n\r\n    /**\r\n     * @dev get Aave Provider\r\n    */\r\n    function getAaveProvider() internal pure returns (AaveV1ProviderInterface) {\r\n        return AaveV1ProviderInterface(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8); //mainnet\r\n        // return AaveV1ProviderInterface(0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5); //kovan\r\n    }\r\n\r\n    /**\r\n     * @dev get Aave Lending Pool Provider\r\n    */\r\n    function getAaveV2Provider() internal pure returns (AaveV2LendingPoolProviderInterface) {\r\n        return AaveV2LendingPoolProviderInterface(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); //mainnet\r\n        // return AaveV2LendingPoolProviderInterface(0x652B2937Efd0B5beA1c8d54293FC1289672AFC6b); //kovan\r\n    }\r\n\r\n    /**\r\n     * @dev get Aave Protocol Data Provider\r\n    */\r\n    function getAaveV2DataProvider() internal pure returns (AaveV2DataProviderInterface) {\r\n        return AaveV2DataProviderInterface(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d); //mainnet\r\n        // return AaveV2DataProviderInterface(0x744C1aaA95232EeF8A9994C4E0b3a89659D9AB79); //kovan\r\n    }\r\n\r\n    /**\r\n     * @dev get Referral Code\r\n    */\r\n    function getReferralCode() internal pure returns (uint16) {\r\n        return 3228;\r\n    }\r\n\r\n    function getWithdrawBalance(AaveV1Interface aave, address token) internal view returns (uint bal) {\r\n        (bal, , , , , , , , , ) = aave.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getPaybackBalance(AaveV1Interface aave, address token) internal view returns (uint bal, uint fee) {\r\n        (, bal, , , , , fee, , , ) = aave.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getTotalBorrowBalance(AaveV1Interface aave, address token) internal view returns (uint amt) {\r\n        (, uint bal, , , , , uint fee, , , ) = aave.getUserReserveData(token, address(this));\r\n        amt = add(bal, fee);\r\n    }\r\n\r\n    function getWithdrawBalanceV2(AaveV2DataProviderInterface aaveData, address token) internal view returns (uint bal) {\r\n        (bal, , , , , , , , ) = aaveData.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getPaybackBalanceV2(AaveV2DataProviderInterface aaveData, address token, uint rateMode) internal view returns (uint bal) {\r\n        if (rateMode == 1) {\r\n            (, bal, , , , , , , ) = aaveData.getUserReserveData(token, address(this));\r\n        } else {\r\n            (, , bal, , , , , , ) = aaveData.getUserReserveData(token, address(this));\r\n        }\r\n    }\r\n\r\n    function getIsColl(AaveV1Interface aave, address token) internal view returns (bool isCol) {\r\n        (, , , , , , , , , isCol) = aave.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    function getIsCollV2(AaveV2DataProviderInterface aaveData, address token) internal view returns (bool isCol) {\r\n        (, , , , , , , , isCol) = aaveData.getUserReserveData(token, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Get Vault's ilk.\r\n    */\r\n    function getVaultData(ManagerLike managerContract, uint vault) internal view returns (bytes32 ilk, address urn) {\r\n        ilk = managerContract.ilks(vault);\r\n        urn = managerContract.urns(vault);\r\n    }\r\n\r\n    /**\r\n     * @dev Get Vault Debt Amount.\r\n    */\r\n    function _getVaultDebt(\r\n        address vat,\r\n        bytes32 ilk,\r\n        address urn\r\n    ) internal view returns (uint wad) {\r\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\r\n        (, uint art) = VatLike(vat).urns(ilk, urn);\r\n        uint dai = VatLike(vat).dai(urn);\r\n\r\n        uint rad = sub(mul(art, rate), dai);\r\n        wad = rad / RAY;\r\n\r\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\r\n    }\r\n\r\n    /**\r\n     * @dev Get Payback Amount.\r\n    */\r\n    function _getWipeAmt(\r\n        address vat,\r\n        uint amt,\r\n        address urn,\r\n        bytes32 ilk\r\n    ) internal view returns (int dart)\r\n    {\r\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\r\n        (, uint art) = VatLike(vat).urns(ilk, urn);\r\n        dart = toInt(amt / rate);\r\n        dart = uint(dart) <= art ? - dart : - toInt(art);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert String to bytes32.\r\n    */\r\n    function stringToBytes32(string memory str) internal pure returns (bytes32 result) {\r\n        require(bytes(str).length != 0, \"string-empty\");\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            result := mload(add(str, 32))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get vault ID. If `vault` is 0, get last opened vault.\r\n    */\r\n    function getVault(ManagerLike managerContract, uint vault) internal view returns (uint _vault) {\r\n        if (vault == 0) {\r\n            require(managerContract.count(address(this)) > 0, \"no-vault-opened\");\r\n            _vault = managerContract.last(address(this));\r\n        } else {\r\n            _vault = vault;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get Borrow Amount [MakerDAO]\r\n    */\r\n    function _getBorrowAmt(\r\n        address vat,\r\n        address urn,\r\n        bytes32 ilk,\r\n        uint amt\r\n    ) internal returns (int dart)\r\n    {\r\n        address jug = getMcdJug();\r\n        uint rate = JugLike(jug).drip(ilk);\r\n        uint dai = VatLike(vat).dai(urn);\r\n        if (dai < mul(amt, RAY)) {\r\n            dart = toInt(sub(mul(amt, RAY), dai) / rate);\r\n            dart = mul(uint(dart), rate) < mul(amt, RAY) ? dart + 1 : dart;\r\n        }\r\n    }\r\n\r\n    function convertEthToWeth(bool isEth, TokenInterface token, uint amount) internal {\r\n        if(isEth) token.deposit.value(amount)();\r\n    }\r\n\r\n    function convertWethToEth(bool isEth, TokenInterface token, uint amount) internal {\r\n       if(isEth) {\r\n            token.approve(address(token), amount);\r\n            token.withdraw(amount);\r\n        }\r\n    }\r\n\r\n    function getMaxBorrow(Protocol target, address token, uint rateMode) internal returns (uint amt) {\r\n        AaveV1Interface aaveV1 = AaveV1Interface(getAaveProvider().getLendingPool());\r\n        AaveV2DataProviderInterface aaveData = getAaveV2DataProvider();\r\n\r\n        if (target == Protocol.Aave) {\r\n            (uint _amt, uint _fee) = getPaybackBalance(aaveV1, token);\r\n            amt = _amt + _fee;\r\n        } else if (target == Protocol.AaveV2) {\r\n            address _token = token == getEthAddr() ? getWethAddr() : token;\r\n            amt = getPaybackBalanceV2(aaveData, _token, rateMode);\r\n        } else if (target == Protocol.Compound) {\r\n            address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\r\n            amt = CTokenInterface(cToken).borrowBalanceCurrent(address(this));\r\n        }\r\n    }\r\n\r\n    function transferFees(address token, uint feeAmt) internal {\r\n        if (feeAmt > 0) {\r\n            if (token == getEthAddr()) {\r\n                feeCollector.transfer(feeAmt);\r\n            } else {\r\n                IERC20(token).safeTransfer(feeCollector, feeAmt);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTokenInterfaces(uint length, address[] memory tokens) internal pure returns (TokenInterface[] memory) {\r\n        TokenInterface[] memory _tokens = new TokenInterface[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            if (tokens[i] ==  getEthAddr()) {\r\n                _tokens[i] = TokenInterface(getWethAddr());\r\n            } else {\r\n                _tokens[i] = TokenInterface(tokens[i]);\r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    function getCtokenInterfaces(uint length, address[] memory tokens) internal view returns (CTokenInterface[] memory) {\r\n        CTokenInterface[] memory _ctokens = new CTokenInterface[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            address _cToken = InstaMapping(getMappingAddr()).cTokenMapping(tokens[i]);\r\n            _ctokens[i] = CTokenInterface(_cToken);\r\n        }\r\n        return _ctokens;\r\n    }\r\n}\r\n\r\ncontract CompoundHelpers is Helpers {\r\n\r\n    struct CompoundBorrowData {\r\n        uint length;\r\n        uint fee;\r\n        Protocol target;\r\n        CTokenInterface[] ctokens;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n        uint[] rateModes;\r\n    }\r\n\r\n    function _compEnterMarkets(uint length, CTokenInterface[] memory ctokens) internal {\r\n        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\r\n        address[] memory _cTokens = new address[](length);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            _cTokens[i] = address(ctokens[i]);\r\n        }\r\n        troller.enterMarkets(_cTokens);\r\n    }\r\n\r\n    function _compBorrowOne(\r\n        uint fee,\r\n        CTokenInterface ctoken,\r\n        TokenInterface token,\r\n        uint amt,\r\n        Protocol target,\r\n        uint rateMode\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                amt = getMaxBorrow(target, _token, rateMode);\r\n            }\r\n\r\n            uint feeAmt = wmul(amt, fee);\r\n            uint _amt = add(amt, feeAmt);\r\n\r\n            require(ctoken.borrow(_amt) == 0, \"borrow-failed-collateral?\");\r\n            transferFees(_token, feeAmt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _compBorrow(\r\n        CompoundBorrowData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _compBorrowOne(\r\n                data.fee, \r\n                data.ctokens[i], \r\n                data.tokens[i], \r\n                data.amts[i], \r\n                data.target, \r\n                data.rateModes[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _compDepositOne(uint fee, CTokenInterface ctoken, TokenInterface token, uint amt) internal {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            uint feeAmt = wmul(amt, fee);\r\n            uint _amt = sub(amt, feeAmt);\r\n\r\n            if (_token != getEthAddr()) {\r\n                token.approve(address(ctoken), _amt);\r\n                require(ctoken.mint(_amt) == 0, \"deposit-failed\");\r\n            } else {\r\n                CETHInterface(address(ctoken)).mint.value(_amt)();\r\n            }\r\n            transferFees(_token, feeAmt);\r\n        }\r\n    }\r\n\r\n    function _compDeposit(\r\n        uint length,\r\n        uint fee,\r\n        CTokenInterface[] memory ctokens,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _compDepositOne(fee, ctokens[i], tokens[i], amts[i]);\r\n        }\r\n    }\r\n\r\n    function _compWithdrawOne(CTokenInterface ctoken, uint amt) internal returns (uint) {\r\n        if (amt > 0) {\r\n            if (amt == uint(-1)) {\r\n                amt = ctoken.balanceOf(address(this));\r\n            }\r\n            require(ctoken.redeemUnderlying(amt) == 0, \"withdraw-failed\");\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _compWithdraw(\r\n        uint length,\r\n        CTokenInterface[] memory ctokens,\r\n        uint[] memory amts\r\n    ) internal returns(uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            finalAmts[i] = _compWithdrawOne(ctokens[i], amts[i]);\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _compPaybackOne(CTokenInterface ctoken, TokenInterface token, uint amt) internal returns (uint) {\r\n        if (amt > 0) {\r\n            if (amt == uint(-1)) {\r\n                amt = ctoken.borrowBalanceCurrent(address(this));\r\n            }\r\n            if (address(token) != getWethAddr()) {\r\n                token.approve(address(ctoken), amt);\r\n                require(ctoken.repayBorrow(amt) == 0, \"repay-failed.\");\r\n            } else {\r\n                CETHInterface(address(ctoken)).repayBorrow.value(amt)();\r\n            }\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _compPayback(\r\n        uint length,\r\n        CTokenInterface[] memory ctokens,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _compPaybackOne(ctokens[i], tokens[i], amts[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AaveV1Helpers is CompoundHelpers {\r\n\r\n    struct AaveV1BorrowData {\r\n        AaveV1Interface aave;\r\n        uint length;\r\n        uint fee;\r\n        Protocol target;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n        uint[] borrowRateModes;\r\n        uint[] paybackRateModes;\r\n    }\r\n\r\n    function _aaveV1BorrowOne(\r\n        AaveV1Interface aave,\r\n        uint fee,\r\n        Protocol target,\r\n        TokenInterface token,\r\n        uint amt,\r\n        uint borrowRateMode,\r\n        uint paybackRateMode\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                amt = getMaxBorrow(target, _token, paybackRateMode);\r\n            }\r\n\r\n            uint feeAmt = wmul(amt, fee);\r\n            uint _amt = add(amt, feeAmt);\r\n\r\n            aave.borrow(_token, _amt, borrowRateMode, getReferralCode());\r\n            transferFees(_token, feeAmt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV1Borrow(\r\n        AaveV1BorrowData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _aaveV1BorrowOne(\r\n                data.aave,\r\n                data.fee,\r\n                data.target,\r\n                data.tokens[i],\r\n                data.amts[i],\r\n                data.borrowRateModes[i],\r\n                data.paybackRateModes[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV1DepositOne(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint fee,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal {\r\n        if (amt > 0) {\r\n            uint ethAmt;\r\n            uint feeAmt = wmul(amt, fee);\r\n            uint _amt = sub(amt, feeAmt);\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            if (isEth) {\r\n                ethAmt = _amt;\r\n            } else {\r\n                token.approve(address(aaveCore), _amt);\r\n            }\r\n\r\n            transferFees(_token, feeAmt);\r\n\r\n            aave.deposit.value(ethAmt)(_token, _amt, getReferralCode());\r\n\r\n            if (!getIsColl(aave, _token))\r\n                aave.setUserUseReserveAsCollateral(_token, true);\r\n        }\r\n    }\r\n\r\n    function _aaveV1Deposit(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint length,\r\n        uint fee,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _aaveV1DepositOne(aave, aaveCore, fee, tokens[i], amts[i]);\r\n        }\r\n    }\r\n\r\n    function _aaveV1WithdrawOne(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n            ATokenV1Interface atoken = ATokenV1Interface(aaveCore.getReserveATokenAddress(_token));\r\n            atoken.redeem(amt);\r\n            if (amt == uint(-1)) {\r\n                amt = getWithdrawBalance(aave, _token);\r\n            }\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV1Withdraw(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint length,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            finalAmts[i] = _aaveV1WithdrawOne(aave, aaveCore, tokens[i], amts[i]);\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV1PaybackOne(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            uint ethAmt;\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                (uint _amt, uint _fee) = getPaybackBalance(aave, _token);\r\n                amt = _amt + _fee;\r\n            }\r\n\r\n            if (isEth) {\r\n                ethAmt = amt;\r\n            } else {\r\n                token.approve(address(aaveCore), amt);\r\n            }\r\n\r\n            aave.repay.value(ethAmt)(_token, amt, payable(address(this)));\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV1Payback(\r\n        AaveV1Interface aave,\r\n        AaveV1CoreInterface aaveCore,\r\n        uint length,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _aaveV1PaybackOne(aave, aaveCore, tokens[i], amts[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AaveV2Helpers is AaveV1Helpers {\r\n\r\n    struct AaveV2BorrowData {\r\n        AaveV2Interface aave;\r\n        uint length;\r\n        uint fee;\r\n        Protocol target;\r\n        TokenInterface[] tokens;\r\n        uint[] amts;\r\n        uint[] rateModes;\r\n    }\r\n\r\n    function _aaveV2BorrowOne(\r\n        AaveV2Interface aave,\r\n        uint fee,\r\n        Protocol target,\r\n        TokenInterface token,\r\n        uint amt,\r\n        uint rateMode\r\n    ) internal returns (uint) {\r\n        if (amt > 0) {\r\n            address _token = address(token) == getWethAddr() ? getEthAddr() : address(token);\r\n\r\n            if (amt == uint(-1)) {\r\n                amt = getMaxBorrow(target, _token, rateMode);\r\n            }\r\n\r\n            uint feeAmt = wmul(amt, fee);\r\n            uint _amt = add(amt, feeAmt);\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            aave.borrow(address(token), _amt, rateMode, getReferralCode(), address(this));\r\n            convertWethToEth(isEth, token, amt);\r\n\r\n            transferFees(_token, feeAmt);\r\n        }\r\n        return amt;\r\n    }\r\n\r\n    function _aaveV2Borrow(\r\n        AaveV2BorrowData memory data\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            finalAmts[i] = _aaveV2BorrowOne(\r\n                data.aave,\r\n                data.fee,\r\n                data.target,\r\n                data.tokens[i],\r\n                data.amts[i],\r\n                data.rateModes[i]\r\n            );\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV2DepositOne(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        uint fee,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal {\r\n        if (amt > 0) {\r\n            uint feeAmt = wmul(amt, fee);\r\n            uint _amt = sub(amt, feeAmt);\r\n\r\n            bool isEth = address(token) == getWethAddr();\r\n            address _token = isEth ? getEthAddr() : address(token);\r\n\r\n            transferFees(_token, feeAmt);\r\n\r\n            convertEthToWeth(isEth, token, _amt);\r\n\r\n            token.approve(address(aave), _amt);\r\n\r\n            aave.deposit(address(token), _amt, address(this), getReferralCode());\r\n\r\n            if (!getIsCollV2(aaveData, address(token))) {\r\n                aave.setUserUseReserveAsCollateral(address(token), true);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _aaveV2Deposit(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        uint length,\r\n        uint fee,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _aaveV2DepositOne(aave, aaveData, fee, tokens[i], amts[i]);\r\n        }\r\n    }\r\n\r\n    function _aaveV2WithdrawOne(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        TokenInterface token,\r\n        uint amt\r\n    ) internal returns (uint _amt) {\r\n        if (amt > 0) {\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            aave.withdraw(address(token), amt, address(this));\r\n\r\n            _amt = amt == uint(-1) ? getWithdrawBalanceV2(aaveData, address(token)) : amt;\r\n\r\n            convertWethToEth(isEth, token, _amt);\r\n        }\r\n    }\r\n\r\n    function _aaveV2Withdraw(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        uint length,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts\r\n    ) internal returns (uint[] memory) {\r\n        uint[] memory finalAmts = new uint[](length);\r\n        for (uint i = 0; i < length; i++) {\r\n            finalAmts[i] = _aaveV2WithdrawOne(aave, aaveData, tokens[i], amts[i]);\r\n        }\r\n        return finalAmts;\r\n    }\r\n\r\n    function _aaveV2PaybackOne(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        TokenInterface token,\r\n        uint amt,\r\n        uint rateMode\r\n    ) internal returns (uint _amt) {\r\n        if (amt > 0) {\r\n            bool isEth = address(token) == getWethAddr();\r\n\r\n            _amt = amt == uint(-1) ? getPaybackBalanceV2(aaveData, address(token), rateMode) : amt;\r\n\r\n            convertEthToWeth(isEth, token, _amt);\r\n\r\n            token.approve(address(aave), _amt);\r\n\r\n            aave.repay(address(token), _amt, rateMode, address(this));\r\n        }\r\n    }\r\n\r\n    function _aaveV2Payback(\r\n        AaveV2Interface aave,\r\n        AaveV2DataProviderInterface aaveData,\r\n        uint length,\r\n        TokenInterface[] memory tokens,\r\n        uint[] memory amts,\r\n        uint[] memory rateModes\r\n    ) internal {\r\n        for (uint i = 0; i < length; i++) {\r\n            _aaveV2PaybackOne(aave, aaveData, tokens[i], amts[i], rateModes[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract MakerHelpers is AaveV2Helpers {\r\n\r\n    struct MakerData {\r\n        uint _vault;\r\n        address colAddr;\r\n        address daiJoin;\r\n        TokenJoinInterface tokenJoinContract;\r\n        VatLike vatContract;\r\n        TokenInterface tokenContract;\r\n        DaiJoinInterface daiJoinContract;\r\n    }\r\n\r\n    function _makerOpen(string memory colType) internal {\r\n        bytes32 ilk = stringToBytes32(colType);\r\n        require(InstaMapping(getMappingAddr()).gemJoinMapping(ilk) != address(0), \"wrong-col-type\");\r\n        ManagerLike(getMcdManager()).open(ilk, address(this));\r\n    }\r\n\r\n    function _makerDepositAndBorrow(\r\n        uint vault,\r\n        uint collateralAmt,\r\n        uint debtAmt,\r\n        uint collateralFee,\r\n        uint debtFee\r\n    ) internal {\r\n        uint collateralFeeAmt = wmul(collateralAmt, collateralFee);\r\n        uint _collateralAmt = sub(collateralAmt, collateralFeeAmt);\r\n\r\n        uint debtFeeAmt = wmul(debtAmt, debtFee);\r\n        uint _debtAmt = add(debtAmt, debtFeeAmt);\r\n\r\n        MakerData memory makerData;\r\n\r\n        ManagerLike managerContract = ManagerLike(getMcdManager());\r\n\r\n        makerData._vault = getVault(managerContract, vault);\r\n        (bytes32 ilk, address urn) = getVaultData(managerContract, makerData._vault);\r\n\r\n        makerData.colAddr = InstaMapping(getMappingAddr()).gemJoinMapping(ilk);\r\n        makerData.tokenJoinContract = TokenJoinInterface(makerData.colAddr);\r\n        makerData.tokenContract = makerData.tokenJoinContract.gem();\r\n        makerData.daiJoin = getMcdDaiJoin();\r\n        makerData.vatContract = VatLike(managerContract.vat());\r\n\r\n        if (address(makerData.tokenContract) == getWethAddr()) {\r\n            makerData.tokenContract.deposit.value(collateralAmt)();\r\n        }\r\n\r\n        transferFees(address(makerData.tokenContract), collateralFeeAmt);\r\n\r\n        makerData.tokenContract.approve(address(makerData.colAddr), _collateralAmt);\r\n        makerData.tokenJoinContract.join(urn, _collateralAmt);\r\n\r\n        int intAmt = toInt(convertTo18(makerData.tokenJoinContract.dec(), _collateralAmt));\r\n\r\n        int dart = _getBorrowAmt(address(makerData.vatContract), urn, ilk, _debtAmt);\r\n\r\n        managerContract.frob(\r\n            makerData._vault,\r\n            intAmt,\r\n            dart\r\n        );\r\n\r\n        managerContract.move(\r\n            makerData._vault,\r\n            address(this),\r\n            toRad(_debtAmt)\r\n        );\r\n\r\n        if (makerData.vatContract.can(address(this), address(makerData.daiJoin)) == 0) {\r\n            makerData.vatContract.hope(makerData.daiJoin);\r\n        }\r\n\r\n        DaiJoinInterface(makerData.daiJoin).exit(address(this), _debtAmt);\r\n\r\n        transferFees(getMcdDai(), debtFeeAmt);\r\n    }\r\n\r\n    function _makerPaybackAndWithdraw(\r\n        uint vault,\r\n        uint withdrawAmt,\r\n        uint paybackAmt\r\n    ) internal returns (uint, uint) {\r\n        ManagerLike managerContract = ManagerLike(getMcdManager());\r\n        MakerData memory makerData;\r\n\r\n        makerData._vault = getVault(managerContract, vault);\r\n        (bytes32 ilk, address urn) = getVaultData(managerContract, makerData._vault);\r\n\r\n        makerData.colAddr = InstaMapping(getMappingAddr()).gemJoinMapping(ilk);\r\n        makerData.tokenJoinContract = TokenJoinInterface(makerData.colAddr);\r\n        makerData.tokenContract = makerData.tokenJoinContract.gem();\r\n        makerData.daiJoin = getMcdDaiJoin();\r\n        makerData.vatContract = VatLike(managerContract.vat());\r\n\r\n        uint _withdrawAmt18;\r\n        if (withdrawAmt == uint(-1)) {\r\n            (_withdrawAmt18,) = makerData.vatContract.urns(ilk, urn);\r\n            withdrawAmt = convert18ToDec(makerData.tokenJoinContract.dec(), _withdrawAmt18);\r\n        } else {\r\n            _withdrawAmt18 = convertTo18(makerData.tokenJoinContract.dec(), withdrawAmt);\r\n        }\r\n\r\n        int _paybackDart;\r\n        {\r\n            (, uint art) = makerData.vatContract.urns(ilk, urn);\r\n            uint _maxDebt = _getVaultDebt(address(makerData.vatContract), ilk, urn);\r\n            _paybackDart = paybackAmt == uint(-1) ?\r\n                -int(art) :\r\n                _getWipeAmt(\r\n                address(makerData.vatContract),\r\n                makerData.vatContract.dai(urn),\r\n                urn,\r\n                ilk\r\n            );\r\n\r\n            paybackAmt = paybackAmt == uint(-1) ? _maxDebt : paybackAmt;\r\n\r\n            require(_maxDebt >= paybackAmt, \"paying-excess-debt\");\r\n        }\r\n\r\n        makerData.daiJoinContract = DaiJoinInterface(makerData.daiJoin);\r\n        makerData.daiJoinContract.dai().approve(makerData.daiJoin, paybackAmt);\r\n        makerData.daiJoinContract.join(urn, paybackAmt);\r\n\r\n        managerContract.frob(\r\n            makerData._vault,\r\n            -toInt(_withdrawAmt18),\r\n            _paybackDart\r\n        );\r\n\r\n        managerContract.flux(\r\n            makerData._vault,\r\n            address(this),\r\n            _withdrawAmt18\r\n        );\r\n\r\n        if (address(makerData.tokenContract) == getWethAddr()) {\r\n            makerData.tokenJoinContract.exit(address(this), _withdrawAmt18);\r\n            makerData.tokenContract.withdraw(_withdrawAmt18);\r\n        } else {\r\n            makerData.tokenJoinContract.exit(address(this), _withdrawAmt18);\r\n        }\r\n\r\n        return (withdrawAmt, paybackAmt);\r\n    }\r\n}\r\n\r\ncontract RefinanceResolver is MakerHelpers {\r\n\r\n    struct RefinanceData {\r\n        Protocol source;\r\n        Protocol target;\r\n        uint collateralFee;\r\n        uint debtFee;\r\n        address[] tokens;\r\n        uint[] borrowAmts;\r\n        uint[] withdrawAmts;\r\n        uint[] borrowRateModes;\r\n        uint[] paybackRateModes;\r\n    }\r\n\r\n    struct RefinanceMakerData {\r\n        uint fromVaultId;\r\n        uint toVaultId;\r\n        Protocol source;\r\n        Protocol target;\r\n        uint collateralFee;\r\n        uint debtFee;\r\n        bool isFrom;\r\n        string colType;\r\n        address token;\r\n        uint debt;\r\n        uint collateral;\r\n        uint borrowRateMode;\r\n        uint paybackRateMode;\r\n    }\r\n\r\n    function refinance(RefinanceData calldata data) external payable {\r\n\r\n        require(data.source != data.target, \"source-and-target-unequal\");\r\n\r\n        uint length = data.tokens.length;\r\n\r\n        require(data.borrowAmts.length == length, \"length-mismatch\");\r\n        require(data.withdrawAmts.length == length, \"length-mismatch\");\r\n        require(data.borrowRateModes.length == length, \"length-mismatch\");\r\n        require(data.paybackRateModes.length == length, \"length-mismatch\");\r\n\r\n        AaveV2Interface aaveV2 = AaveV2Interface(getAaveV2Provider().getLendingPool());\r\n        AaveV1Interface aaveV1 = AaveV1Interface(getAaveProvider().getLendingPool());\r\n        AaveV1CoreInterface aaveCore = AaveV1CoreInterface(getAaveProvider().getLendingPoolCore());\r\n        AaveV2DataProviderInterface aaveData = getAaveV2DataProvider();\r\n\r\n        uint[] memory depositAmts;\r\n        uint[] memory paybackAmts;\r\n\r\n        TokenInterface[] memory tokens = getTokenInterfaces(length, data.tokens);\r\n\r\n        if (data.source == Protocol.Aave && data.target == Protocol.AaveV2) {\r\n            AaveV2BorrowData memory _aaveV2BorrowData;\r\n\r\n            _aaveV2BorrowData.aave = aaveV2;\r\n            _aaveV2BorrowData.length = length;\r\n            _aaveV2BorrowData.fee = data.debtFee;\r\n            _aaveV2BorrowData.target = data.target;\r\n            _aaveV2BorrowData.tokens = tokens;\r\n            _aaveV2BorrowData.amts = data.borrowAmts;\r\n            _aaveV2BorrowData.rateModes = data.borrowRateModes;\r\n\r\n            paybackAmts = _aaveV2Borrow(_aaveV2BorrowData);\r\n            _aaveV1Payback(aaveV1, aaveCore, length, tokens, paybackAmts);\r\n            depositAmts = _aaveV1Withdraw(aaveV1, aaveCore, length, tokens, data.withdrawAmts);\r\n            _aaveV2Deposit(aaveV2, aaveData, length, data.collateralFee, tokens, depositAmts);\r\n        } else if (data.source == Protocol.Aave && data.target == Protocol.Compound) {\r\n            CTokenInterface[] memory _ctokens = getCtokenInterfaces(length, data.tokens);\r\n            _compEnterMarkets(length, _ctokens);\r\n\r\n            CompoundBorrowData memory _compoundBorrowData;\r\n\r\n            _compoundBorrowData.length = length;\r\n            _compoundBorrowData.fee = data.debtFee;\r\n            _compoundBorrowData.target = data.target;\r\n            _compoundBorrowData.ctokens = _ctokens;\r\n            _compoundBorrowData.tokens = tokens;\r\n            _compoundBorrowData.amts = data.borrowAmts;\r\n            _compoundBorrowData.rateModes = data.borrowRateModes;\r\n\r\n            paybackAmts = _compBorrow(_compoundBorrowData);\r\n            \r\n            _aaveV1Payback(aaveV1, aaveCore, length, tokens, paybackAmts);\r\n            depositAmts = _aaveV1Withdraw(aaveV1, aaveCore, length, tokens, data.withdrawAmts);\r\n            _compDeposit(length, data.collateralFee, _ctokens, tokens, depositAmts);\r\n        } else if (data.source == Protocol.AaveV2 && data.target == Protocol.Aave) {\r\n\r\n            AaveV1BorrowData memory _aaveV1BorrowData;\r\n\r\n            _aaveV1BorrowData.aave = aaveV1;\r\n            _aaveV1BorrowData.length = length;\r\n            _aaveV1BorrowData.fee = data.debtFee;\r\n            _aaveV1BorrowData.target = data.target;\r\n            _aaveV1BorrowData.tokens = tokens;\r\n            _aaveV1BorrowData.amts = data.borrowAmts;\r\n            _aaveV1BorrowData.borrowRateModes = data.borrowRateModes;\r\n            _aaveV1BorrowData.paybackRateModes = data.paybackRateModes;\r\n\r\n            paybackAmts = _aaveV1Borrow(_aaveV1BorrowData);\r\n            _aaveV2Payback(aaveV2, aaveData, length, tokens, paybackAmts, data.paybackRateModes);\r\n            depositAmts = _aaveV2Withdraw(aaveV2, aaveData, length, tokens, data.withdrawAmts);\r\n            _aaveV1Deposit(aaveV1, aaveCore, length, data.collateralFee, tokens, depositAmts);\r\n        } else if (data.source == Protocol.AaveV2 && data.target == Protocol.Compound) {\r\n            CTokenInterface[] memory _ctokens = getCtokenInterfaces(length, data.tokens);\r\n            _compEnterMarkets(length, _ctokens);\r\n\r\n            {\r\n                CompoundBorrowData memory _compoundBorrowData;\r\n\r\n                _compoundBorrowData.length = length;\r\n                _compoundBorrowData.fee = data.debtFee;\r\n                _compoundBorrowData.target = data.target;\r\n                _compoundBorrowData.ctokens = _ctokens;\r\n                _compoundBorrowData.tokens = tokens;\r\n                _compoundBorrowData.amts = data.borrowAmts;\r\n                _compoundBorrowData.rateModes = data.borrowRateModes;\r\n\r\n                paybackAmts = _compBorrow(_compoundBorrowData);\r\n            }\r\n            \r\n            _aaveV2Payback(aaveV2, aaveData, length, tokens, paybackAmts, data.paybackRateModes);\r\n            depositAmts = _aaveV2Withdraw(aaveV2, aaveData, length, tokens, data.withdrawAmts);\r\n            _compDeposit(length, data.collateralFee, _ctokens, tokens, depositAmts);\r\n        } else if (data.source == Protocol.Compound && data.target == Protocol.Aave) {\r\n\r\n            AaveV1BorrowData memory _aaveV1BorrowData;\r\n\r\n            _aaveV1BorrowData.aave = aaveV1;\r\n            _aaveV1BorrowData.length = length;\r\n            _aaveV1BorrowData.fee = data.debtFee;\r\n            _aaveV1BorrowData.target = data.target;\r\n            _aaveV1BorrowData.tokens = tokens;\r\n            _aaveV1BorrowData.amts = data.borrowAmts;\r\n            _aaveV1BorrowData.borrowRateModes = data.borrowRateModes;\r\n            _aaveV1BorrowData.paybackRateModes = data.paybackRateModes;\r\n            \r\n            paybackAmts = _aaveV1Borrow(_aaveV1BorrowData);\r\n            {\r\n            CTokenInterface[] memory _ctokens = getCtokenInterfaces(length, data.tokens);\r\n            _compPayback(length, _ctokens, tokens, paybackAmts);\r\n            depositAmts = _compWithdraw(length, _ctokens, data.withdrawAmts);\r\n            }\r\n            _aaveV1Deposit(aaveV1, aaveCore, length, data.collateralFee, tokens, depositAmts);\r\n        } else if (data.source == Protocol.Compound && data.target == Protocol.AaveV2) {\r\n            CTokenInterface[] memory _ctokens = getCtokenInterfaces(length, data.tokens);\r\n\r\n            AaveV2BorrowData memory _aaveV2BorrowData;\r\n\r\n            _aaveV2BorrowData.aave = aaveV2;\r\n            _aaveV2BorrowData.length = length;\r\n            _aaveV2BorrowData.fee = data.debtFee;\r\n            _aaveV2BorrowData.target = data.target;\r\n            _aaveV2BorrowData.tokens = tokens;\r\n            _aaveV2BorrowData.amts = data.borrowAmts;\r\n            _aaveV2BorrowData.rateModes = data.borrowRateModes;\r\n            \r\n            paybackAmts = _aaveV2Borrow(_aaveV2BorrowData);\r\n            _compPayback(length, _ctokens, tokens, paybackAmts);\r\n            depositAmts = _compWithdraw(length, _ctokens, data.withdrawAmts);\r\n            _aaveV2Deposit(aaveV2, aaveData, length, data.collateralFee, tokens, depositAmts);\r\n        } else {\r\n            revert(\"invalid-options\");\r\n        }\r\n    }\r\n\r\n    function refinanceMaker(RefinanceMakerData calldata data) external payable {\r\n\r\n        AaveV2Interface aaveV2 = AaveV2Interface(getAaveV2Provider().getLendingPool());\r\n        AaveV1Interface aaveV1 = AaveV1Interface(getAaveProvider().getLendingPool());\r\n        AaveV1CoreInterface aaveCore = AaveV1CoreInterface(getAaveProvider().getLendingPoolCore());\r\n        AaveV2DataProviderInterface aaveData = getAaveV2DataProvider();\r\n\r\n        TokenInterface dai = TokenInterface(getMcdDai());\r\n        TokenInterface token = TokenInterface(data.token == getEthAddr() ? getWethAddr() : data.token);\r\n\r\n        uint depositAmt;\r\n        uint borrowAmt;\r\n\r\n        if (data.isFrom) {\r\n            (depositAmt, borrowAmt) = _makerPaybackAndWithdraw(\r\n                data.fromVaultId,\r\n                data.collateral,\r\n                data.debt\r\n            );\r\n\r\n            if (data.target == Protocol.Aave) {\r\n                _aaveV1DepositOne(aaveV1, aaveCore, data.collateralFee, token, depositAmt);\r\n                _aaveV1BorrowOne(aaveV1, data.debtFee, Protocol.AaveV2, dai, borrowAmt, data.borrowRateMode, 2);\r\n            } else if (data.target == Protocol.AaveV2) {\r\n                _aaveV2DepositOne(aaveV2, aaveData, data.collateralFee, token, depositAmt);\r\n                _aaveV2BorrowOne(aaveV2, data.debtFee, Protocol.AaveV2, dai, borrowAmt, data.borrowRateMode);\r\n            } else if (data.target == Protocol.Compound) {\r\n                address[] memory tokens = new address[](2);\r\n                tokens[0] = address(dai);\r\n                tokens[1] = data.token;\r\n\r\n                CTokenInterface[] memory _ctokens = getCtokenInterfaces(2, tokens);\r\n\r\n                _compEnterMarkets(2, _ctokens);\r\n\r\n                _compDepositOne(data.collateralFee, _ctokens[1], token, depositAmt);\r\n                _compBorrowOne(data.debtFee, _ctokens[0], dai, borrowAmt, Protocol.Aave, 2);\r\n            } else {\r\n                revert(\"invalid-option\");\r\n            }\r\n        } else {\r\n            if (data.toVaultId == 0) {\r\n                _makerOpen(data.colType);\r\n            }\r\n\r\n            if (data.source == Protocol.Aave) {\r\n                borrowAmt = _aaveV1PaybackOne(aaveV1, aaveCore, dai, data.debt);\r\n                depositAmt = _aaveV1WithdrawOne(aaveV1, aaveCore, token, data.collateral);\r\n            } else if (data.source == Protocol.AaveV2) {\r\n                borrowAmt = _aaveV2PaybackOne(aaveV2, aaveData, dai, data.debt, data.paybackRateMode);\r\n                depositAmt = _aaveV2WithdrawOne(aaveV2, aaveData, token, data.collateral);\r\n            } else if (data.source == Protocol.Compound) {\r\n                address _cDai = InstaMapping(getMappingAddr()).cTokenMapping(address(dai));\r\n                address _cToken = InstaMapping(getMappingAddr()).cTokenMapping(data.token);\r\n\r\n                CTokenInterface cDai = CTokenInterface(_cDai);\r\n                CTokenInterface cToken = CTokenInterface(_cToken);\r\n\r\n                borrowAmt = _compPaybackOne(cDai, dai, data.debt);\r\n                depositAmt = _compWithdrawOne(cToken, data.collateral);\r\n            } else {\r\n                revert(\"invalid-option\");\r\n            }\r\n\r\n            _makerDepositAndBorrow(data.toVaultId, depositAmt, borrowAmt, data.collateralFee, data.debtFee);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ConnectRefinance is RefinanceResolver {\r\n    string public name = \"Refinance-v1\";\r\n}"}}}