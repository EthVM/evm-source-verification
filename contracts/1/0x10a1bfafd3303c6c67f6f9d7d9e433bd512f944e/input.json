{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/new_fdo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) { return 0; }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Owner {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, 'Caller must be the owner!');\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), 'New owner is the zero address.');\n        newOwner = _newOwner;\n    }\n\n    function transferOwnershipAccept() public {\n        require(msg.sender == newOwner, 'Caller must be the owner!');\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\ncontract Campaigns is Owner {\n    \n    using SafeMath for uint256;\n\n    enum ProjectType {ETH, USDT}\n\n    Project[] private projects;\n    ProjectUSDT[] private projects_usdt;\n\n    event ProjectStarted(address contractAddress, address projectStarter, string projectTitle, string projectDesc, uint256 deadline,\n    uint256 goalAmount, ProjectType projectType);\n\n    function startProject(string calldata title, string calldata description, uint deadline, uint amountToRaise, uint hold, ProjectType projectType) external onlyOwner {\n        \n        if(projectType == ProjectType.ETH) {\n            Project newProject = new Project(msg.sender, title, description, deadline, amountToRaise, hold);\n            projects.push(newProject);\n            emit ProjectStarted(address(newProject), msg.sender, title, description, deadline, amountToRaise, ProjectType.ETH);\n        }\n        else if (projectType == ProjectType.USDT) {\n            ProjectUSDT newProject = new ProjectUSDT(msg.sender, title, description, deadline, amountToRaise, hold);\n            projects_usdt.push(newProject);\n            emit ProjectStarted(address(newProject), msg.sender, title, description, deadline, amountToRaise, ProjectType.USDT);            \n        }\n        \n    }                                                                                                                                   \n\n    function returnAllProjects() external view returns(Project[] memory) {\n        return projects;\n    }\n    function returnAllProjectsUSDT() external view returns(ProjectUSDT[] memory) {\n        return projects_usdt;\n    }\n}\n\ncontract Project {\n    using SafeMath for uint256;\n    \n    enum State {INITIATED, SUCCESSFUL, SENDED, CANCELED}\n\n    address payable public creator;\n    \n    uint public assetAmount;\n    uint public completeAt;\n    uint public deadline;\n    uint public refundFEE = 0;\n    uint public currentBalance;\n    uint public earnings = 0;\n    uint public fHold;\n    uint constant CAP = 1000000000000000000; //smallest currency unit\n\n    string public title;\n    string public description;\n    \n    State public state = State.INITIATED; \n    \n    struct Investment {\n        uint fund;\n        uint rate;\n        uint earningTotal;\n    }\n\n    mapping (address => Investment) public investor;\n\n    event FundingReceived(address investor, uint amount, uint currentTotal);\n    event RefundSent(address investor, uint amount, uint currentTotal);\n    event Cancel(address creator, string title, uint assetAmount, uint currentTotal);\n    event CreatorReceives(address recipient, uint amount);\n    event DepositedEarnings(uint deposit);\n    event InvestorReceived(uint amount);\n\n    IERC20 FDO = IERC20(0x361887C1D1B73557018c47c8001711168128cf69);\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only for the creator.');\n        _;\n    }\n\n    constructor (address payable projectStarter, string memory projectTitle, string memory projectDesc, uint fundRaisingDeadline, uint goalAmount, uint hold) {\n        creator = projectStarter;\n        title = projectTitle;\n        description = projectDesc;\n        assetAmount = goalAmount;\n        deadline = fundRaisingDeadline;\n        currentBalance = 0;\n        fHold = hold;\n    }\n    \n    function setAssetAmount(uint newAssetAmount) internal {\n        require(newAssetAmount > 0, 'New asset amount value must be greater than 0.');\n        require(newAssetAmount >= assetAmount, 'New asset amount value must be greater than the old value.');\n        assetAmount = newAssetAmount;\n    }\n    \n    function setNewDeadline(uint newDeadline) internal {\n        require(newDeadline > 0, 'New deadline value must be greater than 0.');\n        require(newDeadline >= deadline, 'New deadline value must be greater than the old value.');\n        deadline = newDeadline;\n    }\n    \n    function setNewRefundFEE(uint _FEE) internal {\n        require(_FEE >= 0 && _FEE <= 100, 'New fee must be between 0 and 100');\n        refundFEE = _FEE;\n    }\n    \n    function setNewFHold(uint newF) internal {\n        require(newF >= 0, 'New Fhold total value must be greater than or equal to 0.');\n        fHold = newF;\n    }\n    \n    function setNewValues(uint newAssetAmount, uint newDeadline, uint _FEE, uint newF) external onlyCreator {\n        require(state == State.INITIATED, 'Invalid state');\n        setAssetAmount(newAssetAmount);\n        setNewDeadline(newDeadline);\n        setNewRefundFEE(_FEE);\n        setNewFHold(newF);\n    }\n\n    function buy() external payable {\n        uint dif = assetAmount.sub(currentBalance);\n        \n        require(fHold <= FDO.balanceOf(msg.sender), 'You must have Firdaos tokens in your portfolio to be able to invest.');\n        require(msg.value <= dif, 'Higher than allowed value');\n        require(msg.value > 0, 'Invest a value greater than 0.');\n        require(block.timestamp < deadline, 'Campaign timed out.');\n        require(state == State.INITIATED, 'Invalid state');\n        require(msg.sender != creator, 'Creator cannot invest in the project.');\n        \n        Investment memory investment = investor[msg.sender];\n        \n        investment.fund = investment.fund + msg.value;\n        investment.rate = investment.fund.mul(CAP).div(assetAmount);\n        currentBalance = currentBalance.add(msg.value);\n\n        investor[msg.sender] = Investment(investment.fund, investment.rate, 0);\n        \n        emit FundingReceived(msg.sender, msg.value, currentBalance);\n        \n        if(currentBalance >= assetAmount) {\n            state = State.SUCCESSFUL;  \n            completeAt = block.timestamp;\n        }\n    }\n    \n    function refund() external {\n        require(state == State.INITIATED || state == State.CANCELED, 'Invalid state');\n        \n        Investment memory investment = investor[msg.sender];\n        uint temp = investment.fund;\n        \n        require(temp > 0, 'Your invested amount is 0');\n        temp = temp.mul(100-refundFEE).div(100);\n        msg.sender.transfer(temp);\n        currentBalance = currentBalance.sub(temp);\n        \n        investor[msg.sender] = Investment(0, 0, 0);\n        \n        emit RefundSent(msg.sender, temp, currentBalance);\n    }\n    \n    function payout() external onlyCreator {\n        require(state == State.SUCCESSFUL, 'Invalid state');\n        uint temp = currentBalance;\n        \n        creator.transfer(temp);\n        \n        emit CreatorReceives(creator, temp);\n\n        currentBalance = 0;\n        state = State.SENDED;  \n    }\n    \n    function cancel() external onlyCreator {\n        require(state == State.INITIATED || state == State.SUCCESSFUL, 'Invalid state');\n      \n        emit Cancel(creator, title, assetAmount, currentBalance);\n        state = State.CANCELED; \n    }\n    \n    function depositEarnings() external payable onlyCreator {\n        require(state == State.SENDED, 'Invalid state');\n        earnings = earnings + msg.value;\n        emit DepositedEarnings(msg.value);   \n    }\n    \n    function withdrawEarnings() external {\n        require(state == State.SENDED, 'Invalid state');\n        Investment memory investment = investor[msg.sender];\n        uint temp = investment.fund;\n        require(temp > 0, 'Your invested amount is 0');\n        uint earning_temp = earnings.mul(investment.rate).div(CAP).sub(investment.earningTotal);\n        if(earning_temp > 0) { \n            msg.sender.transfer(earning_temp); \n            investor[msg.sender] = Investment(temp, investment.rate, earning_temp + investment.earningTotal);\n            emit InvestorReceived(earning_temp);\n        }\n    }\n    \n    function getInvestor(address inv) public view returns\n    (\n        uint256 fund,\n        uint256 rate,\n        uint256 earningTotal\n    ) {\n        Investment memory investment = investor[inv];\n        fund = investment.fund;\n        rate = investment.rate;\n        earningTotal = investment.earningTotal;\n    }\n\n    function getDetails() public view returns \n    (\n        address payable projectStarter,\n        string memory projectTitle,\n        string memory projectDesc,\n        uint256 deadLine,\n        State currentState,\n        uint256 currentAmount,\n        uint256 goalAmount,\n        uint256 valueToComplete,\n        uint256 fpay\n    ) {\n        projectStarter = creator;\n        projectTitle = title;\n        projectDesc = description;\n        deadLine = deadline;\n        currentState = state;\n        currentAmount = currentBalance;\n        goalAmount = assetAmount;\n        valueToComplete = assetAmount.sub(currentBalance);\n        fpay = fHold;\n    }\n    \n    receive() external payable { \n\n    }\n}\n\ncontract ProjectUSDT {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n    enum State {INITIATED, SUCCESSFUL, SENDED, CANCELED}\n\n    address payable public creator;\n    \n    uint public assetAmount;\n    uint public completeAt;\n    uint public deadline;\n    uint public refundFEE = 0;\n    uint public currentBalance;\n    uint public earnings = 0;\n    uint public fHold;\n    uint constant CAP = 1000000; //smallest currency unit\n\n    string public title;\n    string public description;\n    \n    State public state = State.INITIATED; \n    \n    struct Investment {\n        uint fund;\n        uint rate;\n        uint earningTotal;\n    }\n\n    mapping (address => Investment) public investor;\n\n    event FundingReceived(address investor, uint amount, uint currentTotal);\n    event RefundSent(address investor, uint amount, uint currentTotal);\n    event Cancel(address creator, string title, uint assetAmount, uint currentTotal);\n    event CreatorReceives(address recipient, uint amount);\n    event DepositedEarnings(uint deposit);\n    event InvestorReceived(uint amount);\n    \n    IERC20 FDO = IERC20(0x361887C1D1B73557018c47c8001711168128cf69);\n    IERC20 USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only for the creator.');\n        _;\n    }\n\n    constructor (address payable projectStarter, string memory projectTitle, string memory projectDesc, uint fundRaisingDeadline, uint goalAmount, uint hold) {\n        creator = projectStarter;\n        title = projectTitle;\n        description = projectDesc;\n        assetAmount = goalAmount;\n        deadline = fundRaisingDeadline;\n        currentBalance = 0;\n        fHold = hold;\n    }\n    \n    function setAssetAmount(uint newAssetAmount) internal {\n        require(newAssetAmount > 0, 'New asset amount value must be greater than 0.');\n        require(newAssetAmount >= assetAmount, 'New asset amount value must be greater than the old value.');\n        assetAmount = newAssetAmount;\n    }\n    \n    function setNewDeadline(uint newDeadline) internal {\n        require(newDeadline > 0, 'New deadline value must be greater than 0.');\n        require(newDeadline >= deadline, 'New deadline value must be greater than the old value.');\n        deadline = newDeadline;\n    }\n    \n    function setNewRefundFEE(uint _FEE) internal {\n        require(_FEE >= 0 && _FEE <= 100, 'New fee must be between 0 and 100');\n        refundFEE = _FEE;\n    }\n    \n    function setNewFHold(uint newF) internal {\n        require(newF >= 0, 'New Fhold total value must be greater than or equal to 0.');\n        fHold = newF;\n    }\n    \n    function setNewValues(uint newAssetAmount, uint newDeadline, uint _FEE, uint newF) external onlyCreator {\n        require(state == State.INITIATED, 'Invalid state');\n        setAssetAmount(newAssetAmount);\n        setNewDeadline(newDeadline);\n        setNewRefundFEE(_FEE);\n        setNewFHold(newF);\n    }\n\n    function buy(uint payment) external {\n        uint dif = assetAmount.sub(currentBalance);\n        \n        require(fHold <= FDO.balanceOf(msg.sender), 'You must have Firdaos tokens in your portfolio to be able to invest.');\n        \n        require(USDT.balanceOf(msg.sender) >= payment, 'You dont have enough tokens.');\n        USDT.safeTransferFrom(msg.sender, address(this), payment);\n        \n        require(payment <= dif, 'Higher than allowed value');\n        require(payment > 0, 'Invest a value greater than 0.');\n        require(block.timestamp < deadline, 'Campaign timed out.');\n        require(state == State.INITIATED, 'Invalid state');\n        require(msg.sender != creator, 'Creator cannot invest in the project.');\n        \n        Investment memory investment = investor[msg.sender];\n        \n        investment.fund = investment.fund + payment;\n        investment.rate = investment.fund.mul(CAP).div(assetAmount);\n        currentBalance = currentBalance.add(payment);\n\n        investor[msg.sender] = Investment(investment.fund, investment.rate, 0);\n        \n        emit FundingReceived(msg.sender, payment, currentBalance);\n        \n        if(currentBalance >= assetAmount) {\n            state = State.SUCCESSFUL;  \n            completeAt = block.timestamp;\n        }\n    }\n    \n    function refund() external {\n        require(state == State.INITIATED || state == State.CANCELED, 'Invalid state');\n        \n        Investment memory investment = investor[msg.sender];\n        uint temp = investment.fund;\n        \n        require(temp > 0, 'Your invested amount is 0');\n        temp = temp.mul(100-refundFEE).div(100);\n        \n        USDT.safeTransfer(msg.sender, temp);\n        \n        currentBalance = currentBalance.sub(temp);\n        \n        investor[msg.sender] = Investment(0, 0, 0);\n        \n        emit RefundSent(msg.sender, temp, currentBalance);\n    }\n    \n    function payout() external onlyCreator {\n        require(state == State.SUCCESSFUL, 'Invalid state');\n        uint temp = currentBalance;\n        \n        USDT.safeTransfer(creator, temp);\n        \n        emit CreatorReceives(creator, temp);\n\n        currentBalance = 0;\n        state = State.SENDED;  \n    }\n    \n    function cancel() external onlyCreator {\n        require(state == State.INITIATED || state == State.SUCCESSFUL, 'Invalid state');\n      \n        emit Cancel(creator, title, assetAmount, currentBalance);\n        state = State.CANCELED; \n    }\n    \n    function depositEarnings(uint payment) external onlyCreator {\n        require(USDT.balanceOf(msg.sender) >= payment, 'You dont have enough tokens.');\n        USDT.safeTransferFrom(msg.sender, address(this), payment);\n        \n        require(state == State.SENDED, 'Invalid state');\n        earnings = earnings + payment;\n        emit DepositedEarnings(payment);   \n    }\n    \n    function withdrawEarnings() external {\n        require(state == State.SENDED, 'Invalid state');\n        Investment memory investment = investor[msg.sender];\n        uint temp = investment.fund;\n        require(temp > 0, 'Your invested amount is 0');\n        uint earning_temp = earnings.mul(investment.rate).div(CAP).sub(investment.earningTotal);\n        if(earning_temp > 0) { \n            USDT.safeTransfer(msg.sender, earning_temp); \n            investor[msg.sender] = Investment(temp, investment.rate, earning_temp + investment.earningTotal);\n            emit InvestorReceived(earning_temp);\n        }\n    }\n    \n    function getInvestor(address inv) public view returns\n    (\n        uint256 fund,\n        uint256 rate,\n        uint256 earningTotal\n    ) {\n        Investment memory investment = investor[inv];\n        fund = investment.fund;\n        rate = investment.rate;\n        earningTotal = investment.earningTotal;\n    }\n\n    function getDetails() public view returns \n    (\n        address payable projectStarter,\n        string memory projectTitle,\n        string memory projectDesc,\n        uint256 deadLine,\n        State currentState,\n        uint256 currentAmount,\n        uint256 goalAmount,\n        uint256 valueToComplete,\n        uint256 fpay\n    ) {\n        projectStarter = creator;\n        projectTitle = title;\n        projectDesc = description;\n        deadLine = deadline;\n        currentState = state;\n        currentAmount = currentBalance;\n        goalAmount = assetAmount;\n        valueToComplete = assetAmount.sub(currentBalance);\n        fpay = fHold;\n    }\n    \n    receive() external payable { \n\n    }\n}"
    }
  }
}