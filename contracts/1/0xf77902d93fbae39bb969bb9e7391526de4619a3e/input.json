{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"VouchMarket.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8;\r\n\r\n/**\r\n * @title ProofOfHumanity Interface\r\n * @dev See https://github.com/Proof-Of-Humanity/Proof-Of-Humanity.\r\n */\r\ninterface IProofOfHumanity {\r\n    function isRegistered(address _submissionID)\r\n        external\r\n        view\r\n        returns (bool registered);\r\n\r\n    function getSubmissionInfo(address _submissionID)\r\n        external\r\n        view\r\n        returns (\r\n            uint8 status,\r\n            uint64 submissionTime,\r\n            uint64 index,\r\n            bool registered,\r\n            bool hasVouched,\r\n            uint256 numberOfRequests\r\n        );\r\n}\r\n\r\ncontract VouchMarket {\r\n    /** @dev To be emitted when a proposal is submitted.\r\n     *  @param idProposal Unique identifier of the proposal.\r\n     *  @param user The user that receives the vouch.\r\n     *  @param amount The ETH sent by the user.\r\n     *  @param timeLimit Time limit until the user can claim his own funds.\r\n     *  @param voucher The person who vouch.\r\n     */\r\n    event LogProposal(\r\n        uint64 indexed idProposal,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint64 timeLimit,\r\n        address voucher\r\n    );\r\n    /**\r\n     *  @dev Emitted when a voucher locks a proposal.\r\n     *  @param idProposal Unique identifier of the proposal.\r\n     *  @param voucher The person who locks and vouch the proposal.\r\n     */\r\n    event LogProposalLocked(uint64 indexed idProposal, address indexed voucher);\r\n    /**\r\n     *  @dev Emitted when a proposal reward is claimed.\r\n     *  @param idProposal Unique identifier of the proposal.\r\n     *  @param voucher The person who vouch.\r\n     */\r\n    event LogRewardForVouchingClaimed(\r\n        uint64 indexed idProposal,\r\n        address indexed voucher\r\n    );\r\n    /**\r\n     *  @dev Emitted when a vouch is not performed for this proposal.\r\n     *  @param idProposal Unique identifier of the proposal.\r\n     */\r\n    event LogClaimVouchNotPerformed(uint64 indexed idProposal);\r\n    /**\r\n     *  @dev To be emitted when a withdrawal occurs.\r\n     *  @param idProposal Unique identifier of the proposal.\r\n     *  @param withdrawer The person who withdraws.\r\n     *  @param fund The ETH sent to the person who withdraws.\r\n     *  @param fee The contract fee.\r\n     */\r\n    event LogWithdrawn(\r\n        uint64 indexed idProposal,\r\n        address indexed withdrawer,\r\n        uint256 fund,\r\n        uint256 fee\r\n    );\r\n\r\n    // Proof of Humanity contract.\r\n    IProofOfHumanity private PoH =\r\n        IProofOfHumanity(0xC5E9dDebb09Cd64DfaCab4011A0D5cEDaf7c9BDb);\r\n    /// @dev Divisor to calculate the fee, higher the value, higher the voucher reward\r\n    uint256 public feeDivisor;\r\n    /// @dev Counter of submitted proposals\r\n    uint64 public proposalCounter;\r\n    /// @dev Minimum waiting time to lock another proposal\r\n    uint64 public cooldownTime;\r\n    // Contract maintainer\r\n    address private maintainer;\r\n    // UBIburner contract\r\n    address private UBIburner;\r\n\r\n    struct Proposal {\r\n        address user; //Person who need the vouch\r\n        uint64 timeLimit; //If someone locks it and does not claim it, time limit to wait and withdraw your funds\r\n        uint256 amount; //Transactions cost + incentive + fee to burn UBI\r\n        address voucher; //Person selected to vouch or person who lock the proposal\r\n    }\r\n\r\n    /// @dev Map all the proposals by their IDs. idProposal -> Proposal\r\n    mapping(uint64 => Proposal) public proposalMap;\r\n\r\n    /// @dev Map the last time a user locks a proposal. voucher -> time\r\n    mapping(address => uint64) public timeLastLockMap;\r\n\r\n    constructor(\r\n        uint256 _feeDivisor,\r\n        uint64 _cooldownTime,\r\n        address _UBIburner\r\n    ) {\r\n        maintainer = msg.sender;\r\n        feeDivisor = _feeDivisor;\r\n        cooldownTime = _cooldownTime;\r\n        UBIburner = _UBIburner;\r\n    }\r\n\r\n    modifier onlyMaintainer() {\r\n        require(msg.sender == maintainer, \"Not maintainer\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  @dev Submit proposal.\r\n     *  @param addedTime Time limit until the user can claim his own funds.\r\n     *  @param voucher (Optional) The person who give the vouch. Address 0 to denote that anyone can vouch.\r\n     */\r\n    function submitProposal(uint64 addedTime, address voucher)\r\n        external\r\n        payable\r\n    {\r\n        uint64 idProposal = proposalCounter;\r\n        Proposal storage thisProposal = proposalMap[idProposal];\r\n        uint256 amount = msg.value;\r\n        require(amount > 0, \"money?\");\r\n        uint64 timeLimit = uint64(block.timestamp) + addedTime;\r\n        thisProposal.user = msg.sender;\r\n        thisProposal.amount = amount;\r\n        thisProposal.timeLimit = timeLimit;\r\n        if (voucher != address(0)) {\r\n            thisProposal.voucher = voucher;\r\n            emit LogProposalLocked(idProposal, voucher);\r\n        }\r\n        proposalCounter++;\r\n        emit LogProposal(idProposal, msg.sender, amount, timeLimit, voucher);\r\n    }\r\n\r\n    /**\r\n     *  @dev Lock the proposal before the vouch happens and only the locker will be able to claim it. Reducing the voucher race.\r\n     *  @param idProposal The ID of the proposal.\r\n     */\r\n    function lockProposal(uint64 idProposal) external {\r\n        (, , , , bool hasVouched, ) = PoH.getSubmissionInfo(msg.sender);\r\n        Proposal storage thisProposal = proposalMap[idProposal];\r\n        require(thisProposal.amount > 0, \"Wrong time or done\");\r\n        require(thisProposal.voucher == address(0), \"Locked or assigned\");\r\n        require(PoH.isRegistered(msg.sender), \"Not registered\"); //Avoid invalid vouch\r\n        require(\r\n            block.timestamp > timeLastLockMap[msg.sender] + cooldownTime &&\r\n                !hasVouched,\r\n            \"Can't vouch yet\"\r\n        ); //Avoid multiple locks at the same time and vouchers w/o available vouch\r\n        timeLastLockMap[msg.sender] = uint64(block.timestamp);\r\n        thisProposal.voucher = msg.sender;\r\n        emit LogProposalLocked(idProposal, msg.sender);\r\n    }\r\n\r\n    /**\r\n     *  @dev Update the proposal to increase the reward and set a new time limit.\r\n     *  @param idProposal The ID of the proposal.\r\n     *  @param addedTime Time limit until the user can claim his own funds.\r\n     *  @param voucher (Optional) The person who vouch. Address 0 to denote that anyone can vouch.\r\n     */\r\n    function updateProposal(\r\n        uint64 idProposal,\r\n        uint64 addedTime,\r\n        address voucher\r\n    ) external payable {\r\n        Proposal storage thisProposal = proposalMap[idProposal];\r\n        require(thisProposal.user == msg.sender, \"Nice try\");\r\n        require(thisProposal.amount > 0, \"Wrong time or done\");\r\n        address designedVoucher = thisProposal.voucher;\r\n        uint64 moment = uint64(block.timestamp);\r\n        if (thisProposal.timeLimit < moment)\r\n            require(designedVoucher == address(0), \"Wait time limit expires\");\r\n        uint64 timeLimit = moment + addedTime;\r\n        uint256 amount = thisProposal.amount;\r\n        if (msg.value > 0) {\r\n            amount += msg.value;\r\n            thisProposal.amount = amount;\r\n        }\r\n        thisProposal.timeLimit = timeLimit;\r\n        if (voucher != designedVoucher) thisProposal.voucher = voucher;\r\n        emit LogProposal(idProposal, msg.sender, amount, timeLimit, voucher);\r\n    }\r\n\r\n    /**\r\n     *  @dev After vouch for a proposal, claim the proposal reward.\r\n     *  @param idProposal The ID of the proposal.\r\n     */\r\n    function claimRewardForVouching(uint64 idProposal) external {\r\n        Proposal storage thisProposal = proposalMap[idProposal];\r\n        address user = thisProposal.user;\r\n        (uint8 status, , , , , ) = PoH.getSubmissionInfo(user);\r\n        require(thisProposal.amount > 0, \"Wrong time or done\");\r\n        require(thisProposal.voucher == msg.sender, \"You are not the voucher\");\r\n        require(\r\n            status == uint8(2) || PoH.isRegistered(user), //status == 2 is pending registration\r\n            \"Can't claim yet\"\r\n        );\r\n        emit LogRewardForVouchingClaimed(idProposal, msg.sender);\r\n        pay(idProposal);\r\n    }\r\n\r\n    /**\r\n     *  @dev If the user is not vouched in time limit, user can claim his own funds.\r\n     *  @param idProposal The ID of the proposal.\r\n     */\r\n    function claimVouchNotPerformed(uint64 idProposal) external {\r\n        Proposal storage thisProposal = proposalMap[idProposal];\r\n        require(thisProposal.user == msg.sender, \"Nice try\");\r\n        require(\r\n            ((block.timestamp > thisProposal.timeLimit &&\r\n                thisProposal.amount > 0) ||\r\n                (thisProposal.voucher == address(0))),\r\n            \"Done or has a voucher and the time limit is not over yet\"\r\n        );\r\n        emit LogClaimVouchNotPerformed(idProposal);\r\n        pay(idProposal);\r\n    }\r\n\r\n    /**\r\n     *  @dev Calculate and withdraw the funds of the proposal.\r\n     *  @param idProposal The ID of the proposal.\r\n     */\r\n    function pay(uint64 idProposal) private {\r\n        Proposal storage thisProposal = proposalMap[idProposal];\r\n        uint256 fee = thisProposal.amount / feeDivisor;\r\n        uint256 feeToMaintainer = fee / 5; //20% of the fee for the maintainer. That is a maximum of 5% of the deposit.\r\n        uint256 feeToBurnUBI = fee - feeToMaintainer; //80% of the fee to burn UBIs. That is a maximum of 20% of the deposit.\r\n        uint256 fund = thisProposal.amount - fee;\r\n        thisProposal.amount = 0;\r\n        emit LogWithdrawn(idProposal, msg.sender, fund, fee);\r\n        (bool successTx1, ) = maintainer.call{value: feeToMaintainer}(\"\");\r\n        require(successTx1, \"Tx1 fail\");\r\n        (bool successTx2, ) = UBIburner.call{value: feeToBurnUBI}(\"\");\r\n        require(successTx2, \"Tx2 fail\");\r\n        (bool successTx3, ) = msg.sender.call{value: fund}(\"\");\r\n        require(successTx3, \"Tx3 fail\");\r\n    }\r\n\r\n    /**\r\n     *  @dev Change Fee Divisor Commission Calculator and the cooldown time to wait after a proposal lock.\r\n     *  @param _feeDivisor The divisor to calculate the fee, the higher this value is, the lower the fee and the higher the reward for the voucher.\r\n     *  @param _cooldownTime Minimum waiting time to lock another proposal.\r\n     */\r\n    function changeParameters(\r\n        uint256 _feeDivisor,\r\n        uint64 _cooldownTime,\r\n        address _UBIburner\r\n    ) external onlyMaintainer {\r\n        require(_feeDivisor >= 4);\r\n        feeDivisor = _feeDivisor;\r\n        cooldownTime = _cooldownTime;\r\n        UBIburner = _UBIburner;\r\n    }\r\n\r\n    /**\r\n     *  @dev Change maintainer.\r\n     *  @param _maintainer The address of the new maintainer\r\n     */\r\n    function changeMaintainer(address _maintainer) external onlyMaintainer {\r\n        require(_maintainer != address(0));\r\n        maintainer = _maintainer;\r\n    }\r\n}\r\n"}}}