{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/MerkleTwoDrop.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ncontract MerkleTwoDrop {\n\n    struct Airdrop {\n      bytes32 root;\n      mapping(address => bool) awarded;\n    }\n\n    /// Events\n    event Start(uint id);\n    event Award(uint id, address recipient, uint amount0, uint amount1);\n\n    /// State\n    mapping(uint => Airdrop) public airdrops;\n    ITokenManager public tokenManager0;\n    ITokenManager public tokenManager1;\n    uint public airdropsCount;\n    address public startAuth;\n\n    bool private initialized;\n\n    function initialize(address _tokenManager0, address _tokenManager1, address _startAuth) public {\n        require(!initialized, \"Already initialized\");\n        initialized = true;\n\n        require(_tokenManager0 != address(0), \"Needs token0 manager\");\n        require(_tokenManager1 != address(0), \"Needs token1 manager\");\n        require(_startAuth != address(0), \"Needs startAuth\");\n\n        tokenManager0 = ITokenManager(_tokenManager0);\n        tokenManager1 = ITokenManager(_tokenManager1);\n        startAuth = _startAuth;\n    }\n\n    /**\n     * @notice Start a new airdrop `_root`\n     * @param _root New airdrop merkle root\n     */\n    function start(bytes32 _root) public {\n        require(msg.sender == startAuth, \"Not authorized\");\n        _start(_root);\n    }\n\n    function _start(bytes32 _root) internal returns(uint id){\n        id = ++airdropsCount;    // start at 1\n        Airdrop storage newAirdrop = airdrops[id];\n        newAirdrop.root = _root;\n        emit Start(id);\n    }\n\n    /**\n     * @notice Award from airdrop\n     * @param _id Airdrop id\n     * @param _recipient Recepient of award\n     * @param _amount0 The token0 amount\n     * @param _amount1 The token1 amount\n     * @param _proof Merkle proof to correspond to data supplied\n     */\n    function award(uint _id, address _recipient, uint256 _amount0, uint256 _amount1, bytes32[] calldata _proof) public {\n        Airdrop storage airdrop = airdrops[_id];\n\n        bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount0, _amount1));\n        require( validate(airdrop.root, _proof, hash), \"Invalid proof\" );\n\n        require( !airdrops[_id].awarded[_recipient], \"Already awarded\" );\n\n        airdrops[_id].awarded[_recipient] = true;\n\n        tokenManager0.mint(_recipient, _amount0);\n        tokenManager1.mint(_recipient, _amount1);\n\n        emit Award(_id, _recipient, _amount0, _amount1);\n    }\n\n    /**\n     * @notice Award from multiple airdrops to single recipient\n     * @param _ids Airdrop ids\n     * @param _recipient Recepient of award\n     * @param _amount0s The token0 amounts\n     * @param _amount1s The token1 amounts\n     * @param _proofs Merkle proofs\n     */\n    function awardFromMany(uint[] calldata _ids, address _recipient, uint[] calldata _amount0s, uint[] calldata _amount1s, bytes32[][] calldata _proofs) public {\n\n        uint totalAmount0;\n        uint totalAmount1;\n\n        for (uint i = 0; i < _ids.length; i++) {\n            uint id = _ids[i];\n\n            bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount0s[i], _amount1s[i]));\n            require( validate(airdrops[id].root, _proofs[i], hash), \"Invalid proof\" );\n\n            require( !airdrops[id].awarded[_recipient], \"Already awarded\" );\n\n            airdrops[id].awarded[_recipient] = true;\n\n            totalAmount0 += _amount0s[i];\n            totalAmount1 += _amount1s[i];\n\n            emit Award(id, _recipient, _amount0s[i], _amount1s[i]);\n        }\n\n        tokenManager0.mint(_recipient, totalAmount0);\n        tokenManager1.mint(_recipient, totalAmount1);\n\n    }\n\n    /**\n     * @notice Award from airdrop to multiple recipients\n     * @param _id Airdrop ids\n     * @param _recipients Recepients of award\n     * @param _amount0s The karma amount\n     * @param _amount1s The currency amount\n     * @param _proofs Merkle proofs\n     */\n    function awardToMany(uint _id, address[] calldata _recipients, uint[] calldata _amount0s, uint[] calldata _amount1s, bytes32[][] calldata _proofs) public {\n\n        for (uint i = 0; i < _recipients.length; i++) {\n            address recipient = _recipients[i];\n\n            if( airdrops[_id].awarded[recipient] )\n                continue;\n\n            bytes32 hash = keccak256(abi.encodePacked(recipient, _amount0s[i], _amount1s[i]));\n            if( !validate(airdrops[_id].root, _proofs[i], hash) )\n                continue;\n\n            airdrops[_id].awarded[recipient] = true;\n\n            tokenManager0.mint(recipient, _amount0s[i]);\n            tokenManager1.mint(recipient, _amount1s[i]);\n\n            emit Award(_id, recipient, _amount0s[i], _amount1s[i]);\n        }\n\n    }\n\n    function validate(bytes32 root, bytes32[] memory proof, bytes32 hash) public pure returns (bool) {\n\n        for (uint i = 0; i < proof.length; i++) {\n            if (hash < proof[i]) {\n                hash = keccak256(abi.encodePacked(hash, proof[i]));\n            } else {\n                hash = keccak256(abi.encodePacked(proof[i], hash));\n            }\n        }\n\n        return hash == root;\n    }\n\n    /**\n     * @notice Check if address:`_recipient` awarded in airdrop:`_id`\n     * @param _id Airdrop id\n     * @param _recipient Recipient to check\n     */\n    function awarded(uint _id, address _recipient) public view returns(bool) {\n        return airdrops[_id].awarded[_recipient];\n    }\n}\n\nabstract contract ITokenManager {\n    function mint(address _receiver, uint256 _amount) virtual external;\n}\n"
    }
  }
}