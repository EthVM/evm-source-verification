{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "WrapAndUnWrap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.7.4;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface WrappedETH {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n\r\n}\r\n\r\ninterface UniswapFactory{\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n\r\n\r\ninterface UniswapV2{\r\n\r\n\r\n   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\r\n   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\r\n   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\r\n   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\r\n\r\n   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n\r\n\r\n  function sub(uint256 a, uint256 b) internal view returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal view returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract WrapAndUnWrap{\r\n\r\n  using SafeMath\r\n    for uint256;\r\n\r\n  address payable public owner;\r\n  //placehodler token address for specifying eth tokens\r\n  address public ETH_TOKEN_ADDRESS  = address(0x0);\r\n  address public WETH_TOKEN_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  WrappedETH wethToken = WrappedETH(WETH_TOKEN_ADDRESS);\r\n  uint256 approvalAmount = 1000000000000000000000000000000;\r\n  uint256 longTimeFromNow = 1000000000000000000000000000;\r\n  address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n  address uniFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n  UniswapV2 uniswapExchange = UniswapV2(uniAddress);\r\n  UniswapFactory factory = UniswapFactory(uniFactoryAddress);\r\n  mapping (address => address[]) public lpTokenAddressToPairs;\r\n\r\n\r\n\r\n  modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only owner can call this function.\"\r\n        );\r\n        _;\r\n}\r\n\r\n\r\n  constructor() public payable {\r\n\r\n        owner= msg.sender;\r\n\r\n  }\r\n\r\n\r\n  function wrap(address sourceToken, address[] memory destinationTokens, uint256 amount) public payable returns(address, uint256){\r\n\r\n\r\n    ERC20 sToken = ERC20(sourceToken);\r\n    ERC20 dToken = ERC20(destinationTokens[0]);\r\n\r\n\r\n/*\r\n    if(sourceToken == ETH_TOKEN_ADDRESS){\r\n      WrappedETH sToken1 = WrappedETH(WETH_TOKEN_ADDRESS);\r\n      sToken1.deposit{value:msg.value}();\r\n      sToken = ERC20(WETH_TOKEN_ADDRESS);\r\n      amount = msg.value;\r\n      sourceToken = WETH_TOKEN_ADDRESS;\r\n    }\r\n\r\n\r\n*/\r\n      if(destinationTokens.length==1){\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer 1\");\r\n          sToken.approve(uniAddress, approvalAmount);\r\n        }\r\n\r\n        conductUniswap(sourceToken, destinationTokens[0], amount);\r\n        uint256 thisBalance = dToken.balanceOf(address(this));\r\n        dToken.transfer(msg.sender, thisBalance);\r\n        return (destinationTokens[0], thisBalance);\r\n\r\n      }\r\n\r\n      else{\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  2\");\r\n        }\r\n\r\n        sToken.approve(uniAddress, approvalAmount);\r\n\r\n        conductUniswap(sourceToken, destinationTokens[0], amount.div(2));\r\n        conductUniswap(sourceToken, destinationTokens[1], amount.div(2));\r\n\r\n\r\n        ERC20 dToken2 = ERC20(destinationTokens[1]);\r\n        uint256 dTokenBalance = dToken.balanceOf(address(this));\r\n        uint256 dTokenBalance2 = dToken2.balanceOf(address(this));\r\n\r\n        dToken.approve(uniAddress, approvalAmount);\r\n        dToken2.approve(uniAddress, approvalAmount);\r\n\r\n        (,,uint liquidityCoins)  = uniswapExchange.addLiquidity(destinationTokens[0],destinationTokens[1], dTokenBalance, dTokenBalance2, 1,1, msg.sender, longTimeFromNow);\r\n        address thisPairAddress = factory.getPair(destinationTokens[0],destinationTokens[1]);\r\n        ERC20 lpToken = ERC20(thisPairAddress);\r\n        lpTokenAddressToPairs[thisPairAddress] =[destinationTokens[0], destinationTokens[1]];\r\n        uint256 thisBalance =lpToken.balanceOf(address(this));\r\n        lpToken.transfer(msg.sender, thisBalance);\r\n        return (thisPairAddress,thisBalance) ;\r\n      }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n      function unwrap(address sourceToken, address destinationToken, uint256 amount) public payable returns( uint256){\r\n\r\n        ERC20 sToken = ERC20(sourceToken);\r\n        ERC20 dToken = ERC20(destinationToken);\r\n\r\n\r\n\r\n\r\n        if(sourceToken != ETH_TOKEN_ADDRESS){\r\n          require(sToken.transferFrom(msg.sender, address(this), amount), \"You have not approved this contract or do not have enough token for this transfer  3 unwrapping\");\r\n        }\r\n\r\n\r\n        if(lpTokenAddressToPairs[sourceToken].length !=0){\r\n          uniswapExchange.removeLiquidity(lpTokenAddressToPairs[sourceToken][0], lpTokenAddressToPairs[sourceToken][1], amount, 1,1, msg.sender, longTimeFromNow);\r\n\r\n          ERC20 pToken1 = ERC20(lpTokenAddressToPairs[sourceToken][0]);\r\n          ERC20 pToken2 = ERC20(lpTokenAddressToPairs[sourceToken][1]);\r\n\r\n          uint256 pTokenBalance = pToken1.balanceOf(address(this));\r\n          uint256 pTokenBalance2 = pToken2.balanceOf(address(this));\r\n          pToken1.approve(uniAddress, approvalAmount);\r\n          pToken2.approve(uniAddress, approvalAmount);\r\n\r\n          conductUniswap(lpTokenAddressToPairs[sourceToken][0], destinationToken, pTokenBalance);\r\n          conductUniswap(lpTokenAddressToPairs[sourceToken][1], destinationToken, pTokenBalance2);\r\n\r\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\r\n          dToken.transfer(msg.sender, destinationTokenBalance);\r\n          return destinationTokenBalance;\r\n\r\n        }\r\n        else{\r\n\r\n            sToken.approve(uniAddress, approvalAmount);\r\n          conductUniswap(sourceToken, destinationToken, amount);\r\n          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\r\n          dToken.transfer(msg.sender, destinationTokenBalance);\r\n          return destinationTokenBalance;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n      }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  function updateOwnerAddress(address payable newOwner) onlyOwner public returns (bool){\r\n     owner = newOwner;\r\n     return true;\r\n   }\r\n\r\n   function updateUniswapExchange(address newAddress ) public onlyOwner returns (bool){\r\n\r\n    uniswapExchange = UniswapV2( newAddress);\r\n    uniAddress = newAddress;\r\n    return true;\r\n\r\n  }\r\n\r\n  function updateUniswapFactory(address newAddress ) public onlyOwner returns (bool){\r\n\r\n   factory = UniswapFactory( newAddress);\r\n   uniFactoryAddress = newAddress;\r\n   return true;\r\n\r\n }\r\n\r\n\r\n\r\n  function conductUniswap(address sellToken, address buyToken, uint amount) internal returns (uint256 amounts1){\r\n\r\n            if(sellToken == address(0x0)){\r\n                address [] memory addresses = new address[](2);\r\n                addresses[0] = WETH_TOKEN_ADDRESS;\r\n                addresses[1] = buyToken;\r\n                uniswapExchange.swapExactETHForTokens{value:msg.value}(0, addresses, address(this), 1000000000000000 );\r\n\r\n            }\r\n\r\n            else if(sellToken == WETH_TOKEN_ADDRESS){\r\n                wethToken.withdraw(amount);\r\n\r\n                address [] memory addresses = new address[](2);\r\n                addresses[0] = WETH_TOKEN_ADDRESS;\r\n                addresses[1] = buyToken;\r\n                uniswapExchange.swapExactETHForTokens{value:amount}(0, addresses, address(this), 1000000000000000 );\r\n\r\n            }\r\n\r\n\r\n\r\n            else{\r\n          address [] memory addresses = new address[](2);\r\n          addresses[0] = sellToken;\r\n          addresses[1] = buyToken;\r\n           uint256 [] memory amounts = conductUniswapT4T(addresses, amount );\r\n           uint256 resultingTokens = amounts[1];\r\n           return resultingTokens;\r\n            }\r\n    }\r\n\r\n    function conductUniswapT4T(address  [] memory theAddresses, uint amount) internal returns (uint256[] memory amounts1){\r\n\r\n           uint256 deadline = 1000000000000000;\r\n           uint256 [] memory amounts =  uniswapExchange.swapExactTokensForTokens(amount, 0, theAddresses, address(this),deadline );\r\n           return amounts;\r\n\r\n    }\r\n\r\n    function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\r\n\r\n      if (address(token) == ETH_TOKEN_ADDRESS) {\r\n          destination.transfer(amount);\r\n      }\r\n      else {\r\n          ERC20 tokenToken = ERC20(token);\r\n          require(tokenToken.transfer(destination, amount));\r\n      }\r\n      return true;\r\n  }\r\n\r\n\r\n  //this function is here for easy testing in production on a sandbox\r\n   function getUserTokenBalance(address userAddress, address tokenAddress) public view returns (uint256){\r\n    ERC20 token = ERC20(tokenAddress);\r\n    return token.balanceOf(userAddress);\r\n\r\n  }\r\n\r\n\r\n\r\n\r\n  function kill() virtual public onlyOwner {\r\n         selfdestruct(owner);\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n}"
    }
  }
}