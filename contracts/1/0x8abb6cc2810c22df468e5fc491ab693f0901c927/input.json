{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PriceOracle.sol": {
      "content": "pragma solidity 0.5.15;\r\n\r\ncontract ErrorReporter {\r\n    /**\r\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n     */\r\n    event Failure(uint256 error, uint256 info, uint256 detail);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\r\n        UNAUTHORIZED,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW,\r\n        DIVISION_BY_ZERO,\r\n        BAD_INPUT,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_TRANSFER_FAILED,\r\n        MARKET_NOT_SUPPORTED,\r\n        SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_RATE_CALCULATION_FAILED,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INSUFFICIENT_BALANCE,\r\n        INVALID_COLLATERAL_RATIO,\r\n        MISSING_ASSET_PRICE,\r\n        EQUITY_INSUFFICIENT_BALANCE,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        ASSET_NOT_PRICED,\r\n        INVALID_LIQUIDATION_DISCOUNT,\r\n        INVALID_COMBINED_RISK_PARAMETERS\r\n    }\r\n\r\n    /**\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        BORROW_MARKET_NOT_SUPPORTED,\r\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\r\n        BORROW_TRANSFER_OUT_FAILED,\r\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\r\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\r\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\r\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\r\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\r\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\r\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_TRANSFER_IN_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_ADMIN_OWNER_CHECK,\r\n        SET_ASSET_PRICE_CHECK_ORACLE,\r\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_ORACLE_OWNER_CHECK,\r\n        SET_ORIGINATION_FEE_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_VALIDATION,\r\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_MARKET_NOT_SUPPORTED,\r\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        SUPPLY_TRANSFER_IN_FAILED,\r\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SUPPORT_MARKET_PRICE_CHECK,\r\n        SUSPEND_MARKET_OWNER_CHECK,\r\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\r\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\r\n     */\r\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\r\n        emit Failure(uint256(err), uint256(info), 0);\r\n\r\n        return uint256(err);\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n     */\r\n    function failOpaque(FailureInfo info, uint256 opaqueError)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        emit Failure(uint256(Error.OPAQUE_ERROR), uint256(info), opaqueError);\r\n\r\n        return uint256(Error.OPAQUE_ERROR);\r\n    }\r\n}\r\n\r\ncontract CarefulMath is ErrorReporter {\r\n    /**\r\n     * @dev Multiplies two numbers, returns an error on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (a == 0) {\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n\r\n        uint256 c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (b == 0) {\r\n            return (Error.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (b <= a) {\r\n            return (Error.NO_ERROR, a - b);\r\n        } else {\r\n            return (Error.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, returns an error on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        uint256 c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (Error.NO_ERROR, c);\r\n        } else {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev add a and b and then subtract c\r\n     */\r\n    function addThenSub(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c\r\n    ) internal pure returns (Error, uint256) {\r\n        (Error err0, uint256 sum) = add(a, b);\r\n\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return sub(sum, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, overflow will lead to revert.\r\n     */\r\n    function srcMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function srcDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y > 0, \"ds-math-div-overflow\");\r\n        z = x / y;\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y power(base, exponent)\r\n     */\r\n    function pow(uint256 base, uint256 exponent) public pure returns (uint256) {\r\n        if (exponent == 0) {\r\n            return 1;\r\n        } else if (exponent == 1) {\r\n            return base;\r\n        } else if (base == 0 && exponent != 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 z = base;\r\n            for (uint256 i = 1; i < exponent; i++) z = srcMul(z, base);\r\n            return z;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Exponential is CarefulMath {\r\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\r\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\r\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\r\n    uint256 constant expScale = 10**18;\r\n\r\n    // See TODO on expScale\r\n    uint256 constant halfExpScale = expScale / 2;\r\n\r\n    struct Exp {\r\n        uint256 mantissa;\r\n    }\r\n\r\n    uint256 constant mantissaOne = 10**18;\r\n    uint256 constant mantissaOneTenth = 10**17;\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint256 num, uint256 denom)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 scaledNumerator) = mul(num, expScale);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err1, uint256 rational) = div(scaledNumerator, denom);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error error, uint256 result) = add(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error error, uint256 result) = sub(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint256 scalar)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 scaledMantissa) = mul(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint256 scalar)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 descaledMantissa) = div(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        /*\r\n            We are doing this as:\r\n            getExp(mul(expScale, scalar), divisor.mantissa)\r\n\r\n            How it works:\r\n            Exp = a / b;\r\n            Scalar = s;\r\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (Error err0, uint256 numerator) = mul(expScale, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 doubleScaledProduct) = mul(a.mantissa, b.mantissa);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (Error err1, uint256 doubleScaledProductWithHalfScale) = add(\r\n            halfExpScale,\r\n            doubleScaledProduct\r\n        );\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err2, uint256 product) = div(\r\n            doubleScaledProductWithHalfScale,\r\n            expScale\r\n        );\r\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == Error.NO_ERROR);\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\r\n     */\r\n    function truncate(Exp memory exp) internal pure returns (uint256) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / 10**18;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is greater than second Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n\r\ncontract ExchangeRateModel {\r\n    function scale() external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function getExchangeRate() external view returns (uint256);\r\n\r\n    function getMaxSwingRate(uint256 interval) external view returns (uint256);\r\n\r\n    function getFixedInterestRate(uint256 interval)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getFixedExchangeRate(uint256 interval)\r\n        public\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint256);\r\n}\r\n\r\ncontract PriceOracle is Exponential {\r\n    // Flag for whether or not contract is paused.\r\n    bool public paused;\r\n\r\n    // Approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds.\r\n    uint256 public constant numBlocksPerPeriod = 240;\r\n\r\n    uint256 public constant maxSwingMantissa = (5 * 10**15); // 0.005\r\n\r\n    /**\r\n     * @dev An administrator who can set the pending anchor value for assets.\r\n     *      Set in the constructor.\r\n     */\r\n    address public anchorAdmin;\r\n\r\n    /**\r\n     * @dev Pending anchor administrator for this contract.\r\n     */\r\n    address public pendingAnchorAdmin;\r\n\r\n    /**\r\n     * @dev Address of the price poster.\r\n     *      Set in the constructor.\r\n     */\r\n    address public poster;\r\n\r\n    /**\r\n     * @dev The maximum allowed percentage difference between a new price and the anchor's price\r\n     *      Set only in the constructor\r\n     */\r\n    Exp public maxSwing;\r\n\r\n    /**\r\n     * @dev The maximum allowed percentage difference for all assets between a new price and the anchor's price\r\n     */\r\n    mapping(address => Exp) public maxSwings;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses to exchange rate information.\r\n     *      Dynamic changes in asset prices based on exchange rates.\r\n     * map: assetAddress -> ExchangeRateInfo\r\n     */\r\n    struct ExchangeRateInfo {\r\n        address exchangeRateModel; // Address of exchange rate model contract\r\n        uint256 exchangeRate; // Exchange rate between token and wrapped token\r\n        uint256 maxSwingRate; // Maximum changing ratio of the exchange rate\r\n        uint256 maxSwingDuration; // Duration of maximum changing ratio of the exchange rate\r\n    }\r\n    mapping(address => ExchangeRateInfo) public exchangeRates;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses to asset addresses. Stable coin can share a price.\r\n     *\r\n     * map: assetAddress -> Reader\r\n     */\r\n    struct Reader {\r\n        address asset; // Asset to read price\r\n        int256 decimalsDifference; // Standard decimal is 18, so this is equal to the decimal of `asset` - 18.\r\n    }\r\n    mapping(address => Reader) public readers;\r\n\r\n    /**\r\n     * @dev Mapping of asset addresses and their corresponding price in terms of Eth-Wei\r\n     *      which is simply equal to AssetWeiPrice * 10e18. For instance, if OMG token was\r\n     *      worth 5x Eth then the price for OMG would be 5*10e18 or Exp({mantissa: 5000000000000000000}).\r\n     * map: assetAddress -> Exp\r\n     */\r\n    mapping(address => Exp) public _assetPrices;\r\n\r\n    /**\r\n     * @dev Mapping of asset address and timestamp, in order to ensure the recording is valid.\r\n     *\r\n     * map: assetAddress -> uint256\r\n     */\r\n    mapping(address => uint256) public lastSetPriceTimestamp;\r\n\r\n    constructor(address _poster, uint256 _maxSwing) public {\r\n        anchorAdmin = msg.sender;\r\n        poster = _poster;\r\n        _setMaxSwing(_maxSwing);\r\n    }\r\n\r\n    /**\r\n     * @notice Do not pay into PriceOracle.\r\n     */\r\n    function() external payable {\r\n        revert();\r\n    }\r\n\r\n    enum OracleError {NO_ERROR, UNAUTHORIZED, FAILED_TO_SET_PRICE}\r\n\r\n    enum OracleFailureInfo {\r\n        ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK,\r\n        SET_PAUSED_OWNER_CHECK,\r\n        SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK,\r\n        SET_PENDING_ANCHOR_PERMISSION_CHECK,\r\n        SET_PRICE_CALCULATE_SWING,\r\n        SET_PRICE_CAP_TO_MAX,\r\n        SET_PRICE_MAX_SWING_CHECK,\r\n        SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO,\r\n        SET_PRICE_PERMISSION_CHECK,\r\n        SET_PRICE_ZERO_PRICE,\r\n        SET_PRICES_PARAM_VALIDATION,\r\n        SET_PRICE_IS_READER_ASSET\r\n    }\r\n\r\n    /**\r\n     * @dev `msgSender` is msg.sender; `error` corresponds to enum OracleError;\r\n     *      `info` corresponds to enum OracleFailureInfo, and `detail` is an arbitrary\r\n     *      contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n     */\r\n    event OracleFailure(\r\n        address msgSender,\r\n        address asset,\r\n        uint256 error,\r\n        uint256 info,\r\n        uint256 detail\r\n    );\r\n\r\n    /**\r\n     * @dev Use this when reporting a known error from the price oracle or a non-upgradeable collaborator\r\n     *      Using Oracle in name because we already inherit a `fail` function from ErrorReporter.sol\r\n     *      via Exponential.sol\r\n     */\r\n    function failOracle(\r\n        address asset,\r\n        OracleError err,\r\n        OracleFailureInfo info\r\n    ) internal returns (uint256) {\r\n        emit OracleFailure(msg.sender, asset, uint256(err), uint256(info), 0);\r\n\r\n        return uint256(err);\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to report an error when set asset price.\r\n     *      Give the `error` corresponds to enum Error as `details`.\r\n     */\r\n    function failOracleWithDetails(\r\n        address asset,\r\n        OracleError err,\r\n        OracleFailureInfo info,\r\n        uint256 details\r\n    ) internal returns (uint256) {\r\n        emit OracleFailure(\r\n            msg.sender,\r\n            asset,\r\n            uint256(err),\r\n            uint256(info),\r\n            details\r\n        );\r\n\r\n        return uint256(err);\r\n    }\r\n\r\n    struct Anchor {\r\n        // Floor(block.number / numBlocksPerPeriod) + 1\r\n        uint256 period;\r\n        // Price in ETH, scaled by 10**18\r\n        uint256 priceMantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Anchors by asset.\r\n     */\r\n    mapping(address => Anchor) public anchors;\r\n\r\n    /**\r\n     * @dev Pending anchor prices by asset.\r\n     */\r\n    mapping(address => uint256) public pendingAnchors;\r\n\r\n    /**\r\n     * @dev Emitted when a pending anchor is set.\r\n     * @param asset Asset for which to set a pending anchor.\r\n     * @param oldScaledPrice If an unused pending anchor was present, its value; otherwise 0.\r\n     * @param newScaledPrice The new scaled pending anchor price.\r\n     */\r\n    event NewPendingAnchor(\r\n        address anchorAdmin,\r\n        address asset,\r\n        uint256 oldScaledPrice,\r\n        uint256 newScaledPrice\r\n    );\r\n\r\n    /**\r\n     * @notice Provides ability to override the anchor price for an asset.\r\n     * @dev Admin function to set the anchor price for an asset.\r\n     * @param asset Asset for which to override the anchor price.\r\n     * @param newScaledPrice New anchor price.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function _setPendingAnchor(address asset, uint256 newScaledPrice)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin.\r\n        // Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        uint256 oldScaledPrice = pendingAnchors[asset];\r\n        pendingAnchors[asset] = newScaledPrice;\r\n\r\n        emit NewPendingAnchor(\r\n            msg.sender,\r\n            asset,\r\n            oldScaledPrice,\r\n            newScaledPrice\r\n        );\r\n\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted for all exchangeRates changes.\r\n     */\r\n    event SetExchangeRate(\r\n        address asset,\r\n        address exchangeRateModel,\r\n        uint256 exchangeRate,\r\n        uint256 maxSwingRate,\r\n        uint256 maxSwingDuration\r\n    );\r\n    event SetMaxSwingRate(\r\n        address asset,\r\n        uint256 oldMaxSwingRate,\r\n        uint256 newMaxSwingRate,\r\n        uint256 maxSwingDuration\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted for all readers changes.\r\n     */\r\n    event ReaderPosted(\r\n        address asset,\r\n        address oldReader,\r\n        address newReader,\r\n        int256 decimalsDifference\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted for max swing changes.\r\n     */\r\n    event SetMaxSwing(uint256 maxSwing);\r\n\r\n    /**\r\n     * @dev Emitted for max swing changes.\r\n     */\r\n    event SetMaxSwingForAsset(address asset, uint256 maxSwing);\r\n\r\n    /**\r\n     * @dev Emitted for all price changes.\r\n     */\r\n    event PricePosted(\r\n        address asset,\r\n        uint256 previousPriceMantissa,\r\n        uint256 requestedPriceMantissa,\r\n        uint256 newPriceMantissa\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted if this contract successfully posts a capped-to-max price.\r\n     */\r\n    event CappedPricePosted(\r\n        address asset,\r\n        uint256 requestedPriceMantissa,\r\n        uint256 anchorPriceMantissa,\r\n        uint256 cappedPriceMantissa\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when admin either pauses or resumes the contract; `newState` is the resulting state.\r\n     */\r\n    event SetPaused(bool newState);\r\n\r\n    /**\r\n     * @dev Emitted when `pendingAnchorAdmin` is changed.\r\n     */\r\n    event NewPendingAnchorAdmin(\r\n        address oldPendingAnchorAdmin,\r\n        address newPendingAnchorAdmin\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `pendingAnchorAdmin` is accepted, which means anchor admin is updated.\r\n     */\r\n    event NewAnchorAdmin(address oldAnchorAdmin, address newAnchorAdmin);\r\n\r\n    /**\r\n     * @dev Emitted when `poster` is changed.\r\n     */\r\n    event NewPoster(address oldPoster, address newPoster);\r\n\r\n    /**\r\n     * @notice Set `paused` to the specified state.\r\n     * @dev Admin function to pause or resume the contract.\r\n     * @param requestedState Value to assign to `paused`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setPaused(bool requestedState) public returns (uint256) {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PAUSED_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        paused = requestedState;\r\n        emit SetPaused(requestedState);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Begins to transfer the right of anchor admin.\r\n     *         The `newPendingAnchorAdmin` must call `_acceptAnchorAdmin` to finalize the transfer.\r\n     * @dev Admin function to change the anchor admin.\r\n     *      The `newPendingAnchorAdmin` must call `_acceptAnchorAdmin` to finalize the transfer.\r\n     * @param newPendingAnchorAdmin New pending anchor admin.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setPendingAnchorAdmin(address newPendingAnchorAdmin)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log.\r\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\r\n        // Store pendingAdmin = newPendingAdmin.\r\n        pendingAnchorAdmin = newPendingAnchorAdmin;\r\n\r\n        emit NewPendingAnchorAdmin(\r\n            oldPendingAnchorAdmin,\r\n            newPendingAnchorAdmin\r\n        );\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Accepts transfer of anchor admin rights. `msg.sender` must be `pendingAnchorAdmin`.\r\n     * @dev Admin function for pending anchor admin to accept role and update anchor admin`\r\n     * @return uint 0=success, otherwise a failure`\r\n     */\r\n    function _acceptAnchorAdmin() public returns (uint256) {\r\n        // Check caller = pendingAnchorAdmin.\r\n        // `msg.sender` can't be zero.\r\n        if (msg.sender != pendingAnchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo\r\n                        .ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK\r\n                );\r\n        }\r\n\r\n        // Save current value for inclusion in log.\r\n        address oldAnchorAdmin = anchorAdmin;\r\n        // Store admin = pendingAnchorAdmin.\r\n        anchorAdmin = pendingAnchorAdmin;\r\n        // Clear the pending value.\r\n        pendingAnchorAdmin = address(0);\r\n\r\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set new poster.\r\n     * @dev Admin function to change of poster.\r\n     * @param newPoster New poster.\r\n     * @return uint 0=success, otherwise a failure.\r\n     *\r\n     * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\r\n     */\r\n    function _setPoster(address newPoster) public returns (uint256) {\r\n        assert(poster != newPoster);\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        // Save current value, if any, for inclusion in log.\r\n        address oldPoster = poster;\r\n        // Store poster = newPoster.\r\n        poster = newPoster;\r\n\r\n        emit NewPoster(oldPoster, newPoster);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set new exchange rate model.\r\n     * @dev Function to set exchangeRateModel for an asset.\r\n     * @param asset Asset to set the new `exchangeRateModel`.\r\n     * @param exchangeRateModel New `exchangeRateModel` cnotract address,\r\n     *                          if the `exchangeRateModel` is address(0), revert to cancle.\r\n     * @param maxSwingDuration A value greater than zero and less than the seconds of a week.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function setExchangeRate(\r\n        address asset,\r\n        address exchangeRateModel,\r\n        uint256 maxSwingDuration\r\n    ) public returns (uint256) {\r\n        // Check caller = anchorAdmin.\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        require(\r\n            exchangeRateModel != address(0),\r\n            \"setExchangeRate: exchangeRateModel cannot be a zero address.\"\r\n        );\r\n        require(\r\n            maxSwingDuration > 0 && maxSwingDuration <= 604800,\r\n            \"setExchangeRate: maxSwingDuration cannot be zero, less than 604800 (seconds per week).\"\r\n        );\r\n\r\n        uint256 currentExchangeRate = ExchangeRateModel(exchangeRateModel)\r\n            .getExchangeRate();\r\n        require(\r\n            currentExchangeRate > 0,\r\n            \"setExchangeRate: currentExchangeRate not zero.\"\r\n        );\r\n\r\n        uint256 maxSwingRate = ExchangeRateModel(exchangeRateModel)\r\n            .getMaxSwingRate(maxSwingDuration);\r\n        require(\r\n            maxSwingRate > 0 &&\r\n                maxSwingRate <=\r\n                ExchangeRateModel(exchangeRateModel).getMaxSwingRate(604800),\r\n            \"setExchangeRate: maxSwingRate cannot be zero, less than 604800 (seconds per week).\"\r\n        );\r\n\r\n        exchangeRates[asset].exchangeRateModel = exchangeRateModel;\r\n        exchangeRates[asset].exchangeRate = currentExchangeRate;\r\n        exchangeRates[asset].maxSwingRate = maxSwingRate;\r\n        exchangeRates[asset].maxSwingDuration = maxSwingDuration;\r\n\r\n        emit SetExchangeRate(\r\n            asset,\r\n            exchangeRateModel,\r\n            currentExchangeRate,\r\n            maxSwingRate,\r\n            maxSwingDuration\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set a new `maxSwingRate`.\r\n     * @dev Function to set exchange rate `maxSwingRate` for an asset.\r\n     * @param asset Asset for which to set the exchange rate `maxSwingRate`.\r\n     * @param maxSwingDuration Interval time.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details)\r\n     */\r\n    function setMaxSwingRate(address asset, uint256 maxSwingDuration)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        require(\r\n            maxSwingDuration > 0 && maxSwingDuration <= 604800,\r\n            \"setMaxSwingRate: maxSwingDuration cannot be zero, less than 604800 (seconds per week).\"\r\n        );\r\n\r\n        ExchangeRateModel exchangeRateModel = ExchangeRateModel(\r\n            exchangeRates[asset].exchangeRateModel\r\n        );\r\n        uint256 newMaxSwingRate = exchangeRateModel.getMaxSwingRate(\r\n            maxSwingDuration\r\n        );\r\n        uint256 oldMaxSwingRate = exchangeRates[asset].maxSwingRate;\r\n        require(\r\n            oldMaxSwingRate != newMaxSwingRate,\r\n            \"setMaxSwingRate: the same max swing rate.\"\r\n        );\r\n        require(\r\n            newMaxSwingRate > 0 &&\r\n                newMaxSwingRate <= exchangeRateModel.getMaxSwingRate(604800),\r\n            \"setMaxSwingRate: maxSwingRate cannot be zero, less than 31536000 (seconds per week).\"\r\n        );\r\n\r\n        exchangeRates[asset].maxSwingRate = newMaxSwingRate;\r\n        exchangeRates[asset].maxSwingDuration = maxSwingDuration;\r\n\r\n        emit SetMaxSwingRate(\r\n            asset,\r\n            oldMaxSwingRate,\r\n            newMaxSwingRate,\r\n            maxSwingDuration\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Entry point for updating prices.\r\n     * @dev Set reader for an asset.\r\n     * @param asset Asset for which to set the reader.\r\n     * @param readAsset Reader address, if the reader is address(0), cancel the reader.\r\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function setReaders(address asset, address readAsset)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        address oldReadAsset = readers[asset].asset;\r\n        // require(readAsset != oldReadAsset, \"setReaders: Old and new values cannot be the same.\");\r\n        require(\r\n            readAsset != asset,\r\n            \"setReaders: asset and readAsset cannot be the same.\"\r\n        );\r\n\r\n        readers[asset].asset = readAsset;\r\n        if (readAsset == address(0)) readers[asset].decimalsDifference = 0;\r\n        else\r\n            readers[asset].decimalsDifference = int256(\r\n                IERC20(asset).decimals() - IERC20(readAsset).decimals()\r\n            );\r\n\r\n        emit ReaderPosted(\r\n            asset,\r\n            oldReadAsset,\r\n            readAsset,\r\n            readers[asset].decimalsDifference\r\n        );\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `maxSwing` to the specified value.\r\n     * @dev Admin function to change of max swing.\r\n     * @param _maxSwing Value to assign to `maxSwing`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setMaxSwing(uint256 _maxSwing) public returns (uint256) {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PAUSED_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        uint256 oldMaxSwing = maxSwing.mantissa;\r\n        require(\r\n            _maxSwing != oldMaxSwing,\r\n            \"_setMaxSwing: Old and new values cannot be the same.\"\r\n        );\r\n        require(\r\n            _maxSwing >= 10**15 && _maxSwing <= 5 * 10**16,\r\n            \"_setMaxSwing: 0.1% <= _maxSwing <= 5%.\"\r\n        );\r\n        maxSwing = Exp({mantissa: _maxSwing});\r\n        emit SetMaxSwing(_maxSwing);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    /**\r\n     * @notice Set `maxSwing` for asset to the specified value.\r\n     * @dev Admin function to change of max swing.\r\n     * @param _asset Asset for which to set the `maxSwing`.\r\n     * @param _maxSwing Value to assign to `maxSwing`.\r\n     * @return uint 0=success, otherwise a failure.\r\n     */\r\n    function _setMaxSwingForAsset(address _asset, uint256 _maxSwing)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Check caller = anchorAdmin\r\n        if (msg.sender != anchorAdmin) {\r\n            return\r\n                failOracle(\r\n                    address(0),\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PAUSED_OWNER_CHECK\r\n                );\r\n        }\r\n\r\n        uint256 oldMaxSwing = maxSwings[_asset].mantissa;\r\n        require(\r\n            _maxSwing != oldMaxSwing,\r\n            \"_setMaxSwingForAsset: Old and new values cannot be the same.\"\r\n        );\r\n        require(\r\n            _maxSwing >= 10**15 && _maxSwing <= 10**17,\r\n            \"_setMaxSwingForAsset: 0.1% <= _maxSwing <= 10%.\"\r\n        );\r\n        maxSwings[_asset] = Exp({mantissa: _maxSwing});\r\n        emit SetMaxSwingForAsset(_asset, _maxSwing);\r\n\r\n        return uint256(Error.NO_ERROR);\r\n    }\r\n\r\n    function _setMaxSwingForAssetBatch(\r\n        address[] calldata _assets,\r\n        uint256[] calldata _maxSwings\r\n    ) external {\r\n        require(\r\n            _assets.length == _maxSwings.length,\r\n            \"_setMaxSwingForAssetBatch: assets & maxSwings must match the current length.\"\r\n        );\r\n        for (uint256 i = 0; i < _assets.length; i++)\r\n            _setMaxSwingForAsset(_assets[i], _maxSwings[i]);\r\n    }\r\n\r\n    /**\r\n     * @notice This is a basic function to read price, although this is a public function,\r\n     *         It is not recommended, the recommended function is `assetPrices(asset)`.\r\n     *         If `asset` does not has a reader to reader price, then read price from original\r\n     *         structure `_assetPrices`;\r\n     *         If `asset` has a reader to read price, first gets the price of reader, then\r\n     *         `readerPrice * 10 ** |(18-assetDecimals)|`\r\n     * @dev Get price of `asset`.\r\n     * @param asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset.\r\n     */\r\n    function getReaderPrice(address asset) public view returns (uint256) {\r\n        Reader memory reader = readers[asset];\r\n        if (reader.asset == address(0)) return _assetPrices[asset].mantissa;\r\n\r\n        uint256 readerPrice = _assetPrices[reader.asset].mantissa;\r\n\r\n        if (reader.decimalsDifference < 0)\r\n            return\r\n                srcMul(\r\n                    readerPrice,\r\n                    pow(10, uint256(0 - reader.decimalsDifference))\r\n                );\r\n\r\n        return srcDiv(readerPrice, pow(10, uint256(reader.decimalsDifference)));\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves price of an asset.\r\n     * @dev Get price for an asset.\r\n     * @param asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused.\r\n     */\r\n    function assetPrices(address asset) public view returns (uint256) {\r\n        // Note: zero is treated by the xSwap as an invalid\r\n        //       price and will cease operations with that asset\r\n        //       when zero.\r\n        //\r\n        // We get the price as:\r\n        //\r\n        //  1. If the contract is paused, return 0.\r\n        //  2. If the asset has an exchange rate model, the asset price is calculated based on the exchange rate.\r\n        //  3. Return price in `_assetPrices`, which may be zero.\r\n\r\n        if (paused) {\r\n            return 0;\r\n        } else {\r\n            uint256 readerPrice = getReaderPrice(asset);\r\n            ExchangeRateInfo memory exchangeRateInfo = exchangeRates[asset];\r\n            if (exchangeRateInfo.exchangeRateModel != address(0)) {\r\n                uint256 scale = ExchangeRateModel(\r\n                    exchangeRateInfo\r\n                        .exchangeRateModel\r\n                )\r\n                    .scale();\r\n                uint256 currentExchangeRate = ExchangeRateModel(\r\n                    exchangeRateInfo\r\n                        .exchangeRateModel\r\n                )\r\n                    .getExchangeRate();\r\n                uint256 currentChangeRate;\r\n                Error err;\r\n                (err, currentChangeRate) = mul(currentExchangeRate, scale);\r\n                if (err != Error.NO_ERROR) return 0;\r\n\r\n                currentChangeRate =\r\n                    currentChangeRate /\r\n                    exchangeRateInfo.exchangeRate;\r\n                // require(currentExchangeRate >= exchangeRateInfo.exchangeRate && currentChangeRate <= exchangeRateInfo.maxSwingRate, \"assetPrices: Abnormal exchange rate.\");\r\n                if (\r\n                    currentExchangeRate < exchangeRateInfo.exchangeRate ||\r\n                    currentChangeRate > exchangeRateInfo.maxSwingRate\r\n                ) return 0;\r\n\r\n                uint256 price;\r\n                (err, price) = mul(readerPrice, currentExchangeRate);\r\n                if (err != Error.NO_ERROR) return 0;\r\n\r\n                return price / scale;\r\n            } else {\r\n                return readerPrice;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves price of an asset.\r\n     * @dev Get price for an asset.\r\n     * @param asset Asset for which to get the price.\r\n     * @return Uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused.\r\n     */\r\n    function getPrice(address asset) public view returns (uint256) {\r\n        return assetPrices(asset);\r\n    }\r\n\r\n    /**\r\n     * @dev Get last setting price timestamp for an asset.\r\n     * @param asset Asset for which to get the timestamp.\r\n     * @return Uint of timestamp or zero if unset.\r\n     */\r\n    function getLastSetPriceTime(address asset)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return lastSetPriceTimestamp[asset];\r\n    }\r\n\r\n    /**\r\n     * @dev Get exchange rate info of an asset in the time of `interval`.\r\n     * @param asset Asset for which to get the exchange rate info.\r\n     * @param interval Time to get accmulator interest rate.\r\n     * @return Asset price, exchange rate model address, the token that is using this exchange rate model,\r\n     *         exchange rate model contract address,\r\n     *         the token that is using this exchange rate model,\r\n     *         exchange rate between token and wrapped token,\r\n     *         After the time of `interval`, get the accmulator interest rate.\r\n     */\r\n    function getExchangeRateInfo(address asset, uint256 interval)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        if (exchangeRates[asset].exchangeRateModel == address(0))\r\n            return (getReaderPrice(asset), address(0), address(0), 0, 0, 0);\r\n\r\n        return (\r\n            getReaderPrice(asset),\r\n            exchangeRates[asset].exchangeRateModel,\r\n            ExchangeRateModel(exchangeRates[asset].exchangeRateModel).token(),\r\n            ExchangeRateModel(exchangeRates[asset].exchangeRateModel).scale(),\r\n            ExchangeRateModel(exchangeRates[asset].exchangeRateModel)\r\n                .getExchangeRate(),\r\n            ExchangeRateModel(exchangeRates[asset].exchangeRateModel)\r\n                .getFixedInterestRate(interval)\r\n        );\r\n    }\r\n\r\n    struct SetPriceLocalVars {\r\n        Exp price;\r\n        Exp swing;\r\n        Exp maxSwing;\r\n        Exp anchorPrice;\r\n        uint256 anchorPeriod;\r\n        uint256 currentPeriod;\r\n        bool priceCapped;\r\n        uint256 cappingAnchorPriceMantissa;\r\n        uint256 pendingAnchorMantissa;\r\n    }\r\n\r\n    /**\r\n     * @notice Entry point for updating prices.\r\n     *         1) If admin has set a `readerPrice` for this asset, then poster can not use this function.\r\n     *         2) Standard stablecoin has 18 deicmals, and its price should be 1e18,\r\n     *            so when the poster set a new price for a token,\r\n     *            `requestedPriceMantissa` = actualPrice * 10 ** (18-tokenDecimals),\r\n     *            actualPrice is scaled by 10**18.\r\n     * @dev Set price for an asset.\r\n     * @param asset Asset for which to set the price.\r\n     * @param requestedPriceMantissa Requested new price, scaled by 10**18.\r\n     * @return Uint 0=success, otherwise a failure (see enum OracleError for details).\r\n     */\r\n    function setPrice(address asset, uint256 requestedPriceMantissa)\r\n        public\r\n        returns (uint256)\r\n    {\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        return setPriceInternal(asset, requestedPriceMantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Similar to `setPrice(address, uint)`, but for this function, it will record timestamp\r\n     *      when set new price.\r\n     */\r\n    function setPriceWithTime(address asset, uint256 requestedPriceMantissa)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.UNAUTHORIZED,\r\n                    OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n                );\r\n        }\r\n\r\n        uint256 setPriceResult = setPriceInternal(\r\n            asset,\r\n            requestedPriceMantissa\r\n        );\r\n        if (setPriceResult == 0) {\r\n            lastSetPriceTimestamp[asset] = block.timestamp;\r\n        }\r\n\r\n        return setPriceResult;\r\n    }\r\n\r\n    function setPriceInternal(address asset, uint256 requestedPriceMantissa)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // re-used for intermediate errors\r\n        Error err;\r\n        SetPriceLocalVars memory localVars;\r\n        // We add 1 for currentPeriod so that it can never be zero and there's no ambiguity about an unset value.\r\n        // (It can be a problem in tests with low block numbers.)\r\n        localVars.currentPeriod = (block.number / numBlocksPerPeriod) + 1;\r\n        localVars.pendingAnchorMantissa = pendingAnchors[asset];\r\n        localVars.price = Exp({mantissa: requestedPriceMantissa});\r\n\r\n        if (exchangeRates[asset].exchangeRateModel != address(0)) {\r\n            uint256 currentExchangeRate = ExchangeRateModel(\r\n                exchangeRates[asset]\r\n                    .exchangeRateModel\r\n            )\r\n                .getExchangeRate();\r\n            uint256 scale = ExchangeRateModel(\r\n                exchangeRates[asset]\r\n                    .exchangeRateModel\r\n            )\r\n                .scale();\r\n            uint256 currentChangeRate;\r\n            (err, currentChangeRate) = mul(currentExchangeRate, scale);\r\n            assert(err == Error.NO_ERROR);\r\n\r\n            currentChangeRate =\r\n                currentChangeRate /\r\n                exchangeRates[asset].exchangeRate;\r\n            require(\r\n                currentExchangeRate >= exchangeRates[asset].exchangeRate &&\r\n                    currentChangeRate <= exchangeRates[asset].maxSwingRate,\r\n                \"setPriceInternal: Abnormal exchange rate.\"\r\n            );\r\n            exchangeRates[asset].exchangeRate = currentExchangeRate;\r\n        }\r\n\r\n        if (readers[asset].asset != address(0)) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.NO_ERROR,\r\n                    OracleFailureInfo.SET_PRICE_IS_READER_ASSET\r\n                );\r\n        }\r\n\r\n        localVars.maxSwing = maxSwings[asset].mantissa == 0\r\n            ? maxSwing\r\n            : maxSwings[asset];\r\n        if (localVars.pendingAnchorMantissa != 0) {\r\n            // let's explicitly set to 0 rather than relying on default of declaration\r\n            localVars.anchorPeriod = 0;\r\n            localVars.anchorPrice = Exp({\r\n                mantissa: localVars.pendingAnchorMantissa\r\n            });\r\n\r\n            // Verify movement is within max swing of pending anchor (currently: 10%)\r\n            (err, localVars.swing) = calculateSwing(\r\n                localVars.anchorPrice,\r\n                localVars.price\r\n            );\r\n            if (err != Error.NO_ERROR) {\r\n                return\r\n                    failOracleWithDetails(\r\n                        asset,\r\n                        OracleError.FAILED_TO_SET_PRICE,\r\n                        OracleFailureInfo.SET_PRICE_CALCULATE_SWING,\r\n                        uint256(err)\r\n                    );\r\n            }\r\n\r\n            // Fail when swing > maxSwing\r\n            // if (greaterThanExp(localVars.swing, maxSwing)) {\r\n            if (greaterThanExp(localVars.swing, localVars.maxSwing)) {\r\n                return\r\n                    failOracleWithDetails(\r\n                        asset,\r\n                        OracleError.FAILED_TO_SET_PRICE,\r\n                        OracleFailureInfo.SET_PRICE_MAX_SWING_CHECK,\r\n                        localVars.swing.mantissa\r\n                    );\r\n            }\r\n        } else {\r\n            localVars.anchorPeriod = anchors[asset].period;\r\n            localVars.anchorPrice = Exp({\r\n                mantissa: anchors[asset].priceMantissa\r\n            });\r\n\r\n            if (localVars.anchorPeriod != 0) {\r\n                // (err, localVars.priceCapped, localVars.price) = capToMax(localVars.anchorPrice, localVars.price);\r\n                (err, localVars.priceCapped, localVars.price) = capToMax(\r\n                    localVars.anchorPrice,\r\n                    localVars.price,\r\n                    localVars.maxSwing\r\n                );\r\n                if (err != Error.NO_ERROR) {\r\n                    return\r\n                        failOracleWithDetails(\r\n                            asset,\r\n                            OracleError.FAILED_TO_SET_PRICE,\r\n                            OracleFailureInfo.SET_PRICE_CAP_TO_MAX,\r\n                            uint256(err)\r\n                        );\r\n                }\r\n                if (localVars.priceCapped) {\r\n                    // save for use in log\r\n                    localVars.cappingAnchorPriceMantissa = localVars\r\n                        .anchorPrice\r\n                        .mantissa;\r\n                }\r\n            } else {\r\n                // Setting first price. Accept as is (already assigned above from requestedPriceMantissa) and use as anchor\r\n                localVars.anchorPrice = Exp({mantissa: requestedPriceMantissa});\r\n            }\r\n        }\r\n\r\n        // Fail if anchorPrice or price is zero.\r\n        // zero anchor represents an unexpected situation likely due to a problem in this contract\r\n        // zero price is more likely as the result of bad input from the caller of this function\r\n        if (isZeroExp(localVars.anchorPrice)) {\r\n            // If we get here price could also be zero, but it does not seem worthwhile to distinguish the 3rd case\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.FAILED_TO_SET_PRICE,\r\n                    OracleFailureInfo\r\n                        .SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO\r\n                );\r\n        }\r\n\r\n        if (isZeroExp(localVars.price)) {\r\n            return\r\n                failOracle(\r\n                    asset,\r\n                    OracleError.FAILED_TO_SET_PRICE,\r\n                    OracleFailureInfo.SET_PRICE_ZERO_PRICE\r\n                );\r\n        }\r\n\r\n        // BEGIN SIDE EFFECTS\r\n\r\n        // Set pendingAnchor = Nothing\r\n        // Pending anchor is only used once.\r\n        if (pendingAnchors[asset] != 0) {\r\n            pendingAnchors[asset] = 0;\r\n        }\r\n\r\n        // If currentPeriod > anchorPeriod:\r\n        //  Set anchors[asset] = (currentPeriod, price)\r\n        //  The new anchor is if we're in a new period or we had a pending anchor, then we become the new anchor\r\n        if (localVars.currentPeriod > localVars.anchorPeriod) {\r\n            anchors[asset] = Anchor({\r\n                period: localVars.currentPeriod,\r\n                priceMantissa: localVars.price.mantissa\r\n            });\r\n        }\r\n\r\n        uint256 previousPrice = _assetPrices[asset].mantissa;\r\n\r\n        setPriceStorageInternal(asset, localVars.price.mantissa);\r\n\r\n        emit PricePosted(\r\n            asset,\r\n            previousPrice,\r\n            requestedPriceMantissa,\r\n            localVars.price.mantissa\r\n        );\r\n\r\n        if (localVars.priceCapped) {\r\n            // We have set a capped price. Log it so we can detect the situation and investigate.\r\n            emit CappedPricePosted(\r\n                asset,\r\n                requestedPriceMantissa,\r\n                localVars.cappingAnchorPriceMantissa,\r\n                localVars.price.mantissa\r\n            );\r\n        }\r\n\r\n        return uint256(OracleError.NO_ERROR);\r\n    }\r\n\r\n    // As a function to allow harness overrides\r\n    function setPriceStorageInternal(address asset, uint256 priceMantissa)\r\n        internal\r\n    {\r\n        _assetPrices[asset] = Exp({mantissa: priceMantissa});\r\n    }\r\n\r\n    // abs(price - anchorPrice) / anchorPrice\r\n    function calculateSwing(Exp memory anchorPrice, Exp memory price)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        Exp memory numerator;\r\n        Error err;\r\n\r\n        if (greaterThanExp(anchorPrice, price)) {\r\n            (err, numerator) = subExp(anchorPrice, price);\r\n            // can't underflow\r\n            assert(err == Error.NO_ERROR);\r\n        } else {\r\n            (err, numerator) = subExp(price, anchorPrice);\r\n            // Given greaterThan check above, price >= anchorPrice so can't underflow.\r\n            assert(err == Error.NO_ERROR);\r\n        }\r\n\r\n        return divExp(numerator, anchorPrice);\r\n    }\r\n\r\n    // Base on the current anchor price, get the final valid price.\r\n    function capToMax(\r\n        Exp memory anchorPrice,\r\n        Exp memory price,\r\n        Exp memory _maxSwing\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            Error,\r\n            bool,\r\n            Exp memory\r\n        )\r\n    {\r\n        Exp memory one = Exp({mantissa: mantissaOne});\r\n        Exp memory onePlusMaxSwing;\r\n        Exp memory oneMinusMaxSwing;\r\n        Exp memory max;\r\n        Exp memory min;\r\n        // re-used for intermediate errors\r\n        Error err;\r\n\r\n        (err, onePlusMaxSwing) = addExp(one, _maxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // max = anchorPrice * (1 + _maxSwing)\r\n        (err, max) = mulExp(anchorPrice, onePlusMaxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // If price > anchorPrice * (1 + _maxSwing)\r\n        // Set price = anchorPrice * (1 + _maxSwing)\r\n        if (greaterThanExp(price, max)) {\r\n            return (Error.NO_ERROR, true, max);\r\n        }\r\n\r\n        (err, oneMinusMaxSwing) = subExp(one, _maxSwing);\r\n        if (err != Error.NO_ERROR) {\r\n            return (err, false, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // min = anchorPrice * (1 - _maxSwing)\r\n        (err, min) = mulExp(anchorPrice, oneMinusMaxSwing);\r\n        // We can't overflow here or we would have already overflowed above when calculating `max`\r\n        assert(err == Error.NO_ERROR);\r\n\r\n        // If  price < anchorPrice * (1 - _maxSwing)\r\n        // Set price = anchorPrice * (1 - _maxSwing)\r\n        if (lessThanExp(price, min)) {\r\n            return (Error.NO_ERROR, true, min);\r\n        }\r\n\r\n        return (Error.NO_ERROR, false, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Entry point for updating multiple prices.\r\n     * @dev Set prices for a variable number of assets.\r\n     * @param assets A list of up to assets for which to set a price.\r\n     *        Notice: 0 < assets.length == requestedPriceMantissas.length\r\n     * @param requestedPriceMantissas Requested new prices for the assets, scaled by 10**18.\r\n     *        Notice: 0 < assets.length == requestedPriceMantissas.length\r\n     * @return Uint values in same order as inputs.\r\n     *         For each: 0=success, otherwise a failure (see enum OracleError for details)\r\n     */\r\n    function setPrices(\r\n        address[] memory assets,\r\n        uint256[] memory requestedPriceMantissas\r\n    ) public returns (uint256[] memory) {\r\n        uint256 numAssets = assets.length;\r\n        uint256 numPrices = requestedPriceMantissas.length;\r\n        uint256[] memory result;\r\n\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            result = new uint256[](1);\r\n            result[0] = failOracle(\r\n                address(0),\r\n                OracleError.UNAUTHORIZED,\r\n                OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n            );\r\n            return result;\r\n        }\r\n\r\n        if ((numAssets == 0) || (numPrices != numAssets)) {\r\n            result = new uint256[](1);\r\n            result[0] = failOracle(\r\n                address(0),\r\n                OracleError.FAILED_TO_SET_PRICE,\r\n                OracleFailureInfo.SET_PRICES_PARAM_VALIDATION\r\n            );\r\n            return result;\r\n        }\r\n\r\n        result = new uint256[](numAssets);\r\n\r\n        for (uint256 i = 0; i < numAssets; i++) {\r\n            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function setPricesWithTimes(\r\n        address[] memory assets,\r\n        uint256[] memory requestedPriceMantissas\r\n    ) public returns (uint256[] memory) {\r\n        uint256 numAssets = assets.length;\r\n        uint256 numPrices = requestedPriceMantissas.length;\r\n        uint256[] memory result;\r\n\r\n        // Fail when msg.sender is not poster\r\n        if (msg.sender != poster) {\r\n            result = new uint256[](1);\r\n            result[0] = failOracle(\r\n                address(0),\r\n                OracleError.UNAUTHORIZED,\r\n                OracleFailureInfo.SET_PRICE_PERMISSION_CHECK\r\n            );\r\n            return result;\r\n        }\r\n\r\n        if ((numAssets == 0) || (numPrices != numAssets)) {\r\n            result = new uint256[](1);\r\n            result[0] = failOracle(\r\n                address(0),\r\n                OracleError.FAILED_TO_SET_PRICE,\r\n                OracleFailureInfo.SET_PRICES_PARAM_VALIDATION\r\n            );\r\n            return result;\r\n        }\r\n\r\n        result = new uint256[](numAssets);\r\n\r\n        for (uint256 i = 0; i < numAssets; i++) {\r\n            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\r\n            if (result[i] == 0) {\r\n                lastSetPriceTimestamp[assets[i]] = block.timestamp;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"
    }
  }
}