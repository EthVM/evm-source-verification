{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "BulkMinter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED AND MIT\r\n\r\n// File: contracts/IArtBlocksMinter.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface IArtBlocksMinter {\r\n    function artblocksContract() external view returns (address);\r\n\r\n    function artistSetBonusContractAddress(\r\n        uint256 _projectId,\r\n        address _bonusContractAddress\r\n    ) external;\r\n\r\n    function artistToggleBonus(uint256 _projectId) external;\r\n\r\n    function checkYourAllowanceOfProjectERC20(uint256 _projectId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getYourBalanceOfProjectERC20(uint256 _projectId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function projectIdToBonus(uint256) external view returns (bool);\r\n\r\n    function projectIdToBonusContractAddress(uint256)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function purchase(uint256 _projectId)\r\n        external\r\n        payable\r\n        returns (uint256 _tokenId);\r\n\r\n    function purchaseTo(address _to, uint256 _projectId)\r\n        external\r\n        payable\r\n        returns (uint256 _tokenId);\r\n}\r\n\r\n// File: contracts/IArtBlocksMain.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface IArtBlocksMain {\r\n    function projectIdToCurrencyAddress(uint256)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function projectIdToCurrencySymbol(uint256)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    function projectIdToPricePerTokenInWei(uint256)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BulkMinter.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\ncontract BulkMinter {\r\n    IArtBlocksMinter _artBlocksMinter;\r\n    IArtBlocksMain _artBlocksMain;\r\n\r\n    constructor() public {\r\n        _artBlocksMinter = IArtBlocksMinter(\r\n            address(0x091dcd914fCEB1d47423e532955d1E62d1b2dAEf)\r\n        );\r\n        _artBlocksMain = IArtBlocksMain(\r\n            address(0xa7d8d9ef8D8Ce8992Df33D8b8CF4Aebabd5bD270)\r\n        );\r\n    }\r\n\r\n    function getPrice(uint256 projectId, uint256 numItems)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            _artBlocksMain.projectIdToCurrencyAddress(projectId) ==\r\n                address(0x0000000000000000000000000000000000000000),\r\n            \"project not in ETH\"\r\n        );\r\n        return\r\n            _artBlocksMain.projectIdToPricePerTokenInWei(projectId) * numItems;\r\n    }\r\n\r\n    function bulkMint(\r\n        uint256 projectId,\r\n        uint256 numItems,\r\n        uint256 tipAmount\r\n    ) public payable {\r\n        uint256 expectedAmount = getPrice(projectId, numItems) + tipAmount;\r\n        require(msg.value == expectedAmount, \"incorrect amount\");\r\n        uint256 pricePerMint =\r\n            _artBlocksMain.projectIdToPricePerTokenInWei(projectId);\r\n        for (uint256 x = 0; x < numItems; x++) {\r\n            _artBlocksMinter.purchaseTo{value: pricePerMint}(\r\n                msg.sender,\r\n                projectId\r\n            );\r\n        }\r\n    }\r\n\r\n    function moveDonations() public {\r\n        Address.sendValue(\r\n            payable(address(0x8a333a18B924554D6e83EF9E9944DE6260f61D3B)),\r\n            address(this).balance\r\n        );\r\n    }\r\n}"
    }
  }
}