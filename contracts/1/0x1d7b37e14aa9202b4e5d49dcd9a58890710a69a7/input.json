{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "HexlantTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface HexlantToken {\r\n  function initialize(\r\n    address _owner,\r\n    string memory _name,\r\n    string memory _symbol,\r\n    uint8 _decimals,\r\n    uint256 _supply\r\n  ) external;\r\n}\r\n\r\nabstract contract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor() {\r\n    address msgSender = msg.sender;\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\nabstract contract CloneFactory {\r\n  function clone(address implementation, bytes32 salt) internal returns (address instance) {\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n      instance := create2(0, ptr, 0x37, salt)\r\n    }\r\n    require(instance != address(0), \"ERC1167: create2 failed\");\r\n  }\r\n\r\n  function computeClone(\r\n    address implementation,\r\n    bytes32 salt,\r\n    address deployer\r\n  ) internal pure returns (address computed) {\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n      mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n      mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n      mstore(add(ptr, 0x4c), salt)\r\n      mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n      computed := keccak256(add(ptr, 0x37), 0x55)\r\n    }\r\n  }\r\n}\r\n\r\nabstract contract TokenSpecStorage is Ownable {\r\n  string private _DEFAULT = \"DEFAULT\";\r\n  string private _LOCK = \"LOCK\";\r\n  string private _PAUSE = \"PAUSE\";\r\n  string private _FREEZE = \"FREEZE\";\r\n  string private _UPGRADE = \"UPGRADE\";\r\n  string private _MINT = \"MINT\";\r\n  string private _BURN = \"BURN\";\r\n\r\n  mapping(string => address) internal _implementationBySpecKey;\r\n\r\n  function isLockable(bool _lock) internal view returns (string memory) {\r\n    return _lock ? _LOCK : \"\";\r\n  }\r\n\r\n  function isPausable(bool _pause) internal view returns (string memory) {\r\n    return _pause ? _PAUSE : \"\";\r\n  }\r\n\r\n  function isFreezable(bool _freeze) internal view returns (string memory) {\r\n    return _freeze ? _FREEZE : \"\";\r\n  }\r\n\r\n  function isUpgradable(bool _upgrade) internal view returns (string memory) {\r\n    return _upgrade ? _UPGRADE : \"\";\r\n  }\r\n\r\n  function isMintable(bool _mint) internal view returns (string memory) {\r\n    return _mint ? _MINT : \"\";\r\n  }\r\n\r\n  function isBurnable(bool _burn) internal view returns (string memory) {\r\n    return _burn ? _BURN : \"\";\r\n  }\r\n\r\n  function getTokenSpecKey(\r\n    bool _lock,\r\n    bool _pause,\r\n    bool _freeze,\r\n    bool _upgrade,\r\n    bool _mint,\r\n    bool _burn\r\n  ) internal view returns (string memory) {\r\n    string[7] memory specs;\r\n\r\n    specs[0] = _DEFAULT;\r\n    specs[1] = isLockable(_lock);\r\n    specs[2] = isPausable(_pause);\r\n    specs[3] = isFreezable(_freeze);\r\n    specs[4] = isUpgradable(_upgrade);\r\n    specs[5] = isMintable(_mint);\r\n    specs[6] = isBurnable(_burn);\r\n\r\n    return string(abi.encodePacked(specs[0], specs[1], specs[2], specs[3], specs[4], specs[5], specs[6]));\r\n  }\r\n\r\n  function setTokenSpecImplementation(\r\n    address _implementation,\r\n    bool _lock,\r\n    bool _pause,\r\n    bool _freeze,\r\n    bool _upgrade,\r\n    bool _mint,\r\n    bool _burn\r\n  ) external onlyOwner {\r\n    string memory specKey = getTokenSpecKey(_lock, _pause, _freeze, _upgrade, _mint, _burn);\r\n\r\n    _implementationBySpecKey[specKey] = _implementation;\r\n  }\r\n\r\n  function getTokenSpecImplementation(\r\n    bool _lock,\r\n    bool _pause,\r\n    bool _freeze,\r\n    bool _upgrade,\r\n    bool _mint,\r\n    bool _burn\r\n  ) public view returns (address) {\r\n    string memory specKey = getTokenSpecKey(_lock, _pause, _freeze, _upgrade, _mint, _burn);\r\n\r\n    return _implementationBySpecKey[specKey];\r\n  }\r\n}\r\n\r\ncontract HexlantTokenFactory is CloneFactory, TokenSpecStorage {\r\n  struct TokenParams {\r\n    address owner;\r\n    string name;\r\n    string symbol;\r\n    uint8 decimals;\r\n    uint256 supply;\r\n  }\r\n\r\n  function createToken(\r\n    TokenParams memory _tokenParams,\r\n    bool _lock,\r\n    bool _pause,\r\n    bool _freeze,\r\n    bool _upgrade,\r\n    bool _mint,\r\n    bool _burn\r\n  ) external onlyOwner returns (address token) {\r\n    address implementation = getTokenSpecImplementation(_lock, _pause, _freeze, _upgrade, _mint, _burn);\r\n\r\n    require(implementation != address(0), \"not found spec implementation\");\r\n\r\n    bytes32 finalSalt = keccak256(\r\n      abi.encodePacked(\r\n        _tokenParams.owner,\r\n        _tokenParams.name,\r\n        _tokenParams.symbol,\r\n        _tokenParams.decimals,\r\n        _tokenParams.supply,\r\n        _lock,\r\n        _pause,\r\n        _freeze,\r\n        _upgrade,\r\n        _mint,\r\n        _burn\r\n      )\r\n    );\r\n\r\n    token = clone(implementation, finalSalt);\r\n\r\n    HexlantToken(token).initialize(\r\n      _tokenParams.owner,\r\n      _tokenParams.name,\r\n      _tokenParams.symbol,\r\n      _tokenParams.decimals,\r\n      _tokenParams.supply\r\n    );\r\n  }\r\n\r\n  function getTokenAddress(\r\n    TokenParams memory _tokenParams,\r\n    bool _lock,\r\n    bool _pause,\r\n    bool _freeze,\r\n    bool _upgrade,\r\n    bool _mint,\r\n    bool _burn\r\n  ) external view returns (address wallet) {\r\n    address implementation = getTokenSpecImplementation(_lock, _pause, _freeze, _upgrade, _mint, _burn);\r\n\r\n    bytes32 finalSalt = keccak256(\r\n      abi.encodePacked(\r\n        _tokenParams.owner,\r\n        _tokenParams.name,\r\n        _tokenParams.symbol,\r\n        _tokenParams.decimals,\r\n        _tokenParams.supply,\r\n        _lock,\r\n        _pause,\r\n        _freeze,\r\n        _upgrade,\r\n        _mint,\r\n        _burn\r\n      )\r\n    );\r\n\r\n    return computeClone(implementation, finalSalt, address(this));\r\n  }\r\n}"
    }
  }
}