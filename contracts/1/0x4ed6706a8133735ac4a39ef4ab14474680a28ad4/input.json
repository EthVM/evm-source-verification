{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ForeignFeeManagerAMBNativeToErc20.sol": {
      "content": "// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/BaseMediatorFeeManager.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n/**\r\n* @title BaseMediatorFeeManager\r\n* @dev Base fee manager to handle fees for AMB mediators.\r\n*/\r\ncontract BaseMediatorFeeManager is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event FeeUpdated(uint256 fee);\r\n\r\n    // This is not a real fee value but a relative value used to calculate the fee percentage.\r\n    // 1 ether = 100% of the value.\r\n    uint256 internal constant MAX_FEE = 1 ether;\r\n    uint256 internal constant MAX_REWARD_ACCOUNTS = 50;\r\n\r\n    uint256 public fee;\r\n    address[] internal rewardAccounts;\r\n    address internal mediatorContract;\r\n\r\n    modifier validFee(uint256 _fee) {\r\n        require(_fee < MAX_FEE);\r\n        /* solcov ignore next */\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the initial parameters of the fee manager.\r\n    * @param _owner address of the owner of the fee manager contract.\r\n    * @param _fee the fee percentage amount.\r\n    * @param _rewardAccountList list of addresses that will receive the fee rewards.\r\n    */\r\n    constructor(address _owner, uint256 _fee, address[] _rewardAccountList, address _mediatorContract) public {\r\n        require(_rewardAccountList.length > 0 && _rewardAccountList.length <= MAX_REWARD_ACCOUNTS);\r\n        _transferOwnership(_owner);\r\n        _setFee(_fee);\r\n        mediatorContract = _mediatorContract;\r\n\r\n        for (uint256 i = 0; i < _rewardAccountList.length; i++) {\r\n            require(isValidAccount(_rewardAccountList[i]));\r\n        }\r\n        rewardAccounts = _rewardAccountList;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the fee amount to be subtracted from the value.\r\n    * @param _value the base value from which fees are calculated\r\n    */\r\n    function calculateFee(uint256 _value) external view returns (uint256) {\r\n        return _value.mul(fee).div(MAX_FEE);\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the fee percentage amount for the mediator operations.\r\n    * @param _fee the fee percentage\r\n    */\r\n    function _setFee(uint256 _fee) internal validFee(_fee) {\r\n        fee = _fee;\r\n        emit FeeUpdated(_fee);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the fee percentage amount for the mediator operations. Only the owner can call this method.\r\n    * @param _fee the fee percentage\r\n    */\r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        _setFee(_fee);\r\n    }\r\n\r\n    function isValidAccount(address _account) internal returns (bool) {\r\n        return _account != address(0) && _account != mediatorContract;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds a new account to the list of accounts to receive rewards for the operations.\r\n    * Only the owner can call this method.\r\n    * @param _account new reward account\r\n    */\r\n    function addRewardAccount(address _account) external onlyOwner {\r\n        require(isValidAccount(_account));\r\n        require(!isRewardAccount(_account));\r\n        require(rewardAccounts.length.add(1) < MAX_REWARD_ACCOUNTS);\r\n        rewardAccounts.push(_account);\r\n    }\r\n\r\n    /**\r\n    * @dev Removes an account from the list of accounts to receive rewards for the operations.\r\n    * Only the owner can call this method.\r\n    * finds the element, swaps it with the last element, and then deletes it;\r\n    * @param _account to be removed\r\n    * return boolean whether the element was found and deleted\r\n    */\r\n    function removeRewardAccount(address _account) external onlyOwner returns (bool) {\r\n        uint256 numOfAccounts = rewardAccountsCount();\r\n        for (uint256 i = 0; i < numOfAccounts; i++) {\r\n            if (rewardAccounts[i] == _account) {\r\n                rewardAccounts[i] = rewardAccounts[numOfAccounts - 1];\r\n                delete rewardAccounts[numOfAccounts - 1];\r\n                rewardAccounts.length--;\r\n                return true;\r\n            }\r\n        }\r\n        // If account is not found and removed, the transactions is reverted\r\n        revert();\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the amount of accounts in the list of reward accounts.\r\n    * @return amount of accounts.\r\n    */\r\n    function rewardAccountsCount() public view returns (uint256) {\r\n        return rewardAccounts.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells if the account is part of the list of reward accounts.\r\n    * @param _account to check if is part of the list.\r\n    * @return true if the account is in the list\r\n    */\r\n    function isRewardAccount(address _account) internal view returns (bool) {\r\n        for (uint256 i = 0; i < rewardAccountsCount(); i++) {\r\n            if (rewardAccounts[i] == _account) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the list of accounts that receives rewards for the operations.\r\n    * @return the list of reward accounts\r\n    */\r\n    function rewardAccountsList() public view returns (address[]) {\r\n        return rewardAccounts;\r\n    }\r\n\r\n    /**\r\n    * @dev ERC677 transfer callback function, received fee is distributed.\r\n    * @param _value amount of transferred tokens\r\n    */\r\n    function onTokenTransfer(address, uint256 _value, bytes) external returns (bool) {\r\n        distributeFee(_value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Distributes the provided amount of fees proportionally to the list of reward accounts.\r\n    * In case the fees cannot be equally distributed, the remaining difference will be distributed to an account\r\n    * in a semi-random way.\r\n    * @param _fee total amount to be distributed to the list of reward accounts.\r\n    */\r\n    function distributeFee(uint256 _fee) internal {\r\n        uint256 numOfAccounts = rewardAccountsCount();\r\n        uint256 feePerAccount = _fee.div(numOfAccounts);\r\n        uint256 randomAccountIndex;\r\n        uint256 diff = _fee.sub(feePerAccount.mul(numOfAccounts));\r\n        if (diff > 0) {\r\n            randomAccountIndex = random(numOfAccounts);\r\n        }\r\n\r\n        for (uint256 i = 0; i < numOfAccounts; i++) {\r\n            uint256 feeToDistribute = feePerAccount;\r\n            if (diff > 0 && randomAccountIndex == i) {\r\n                feeToDistribute = feeToDistribute.add(diff);\r\n            }\r\n            onFeeDistribution(rewardAccounts[i], feeToDistribute);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates a random number based on the block number.\r\n    * @param _count the max value for the random number.\r\n    * @return a number between 0 and _count.\r\n    */\r\n    function random(uint256 _count) internal view returns (uint256) {\r\n        return uint256(blockhash(block.number.sub(1))) % _count;\r\n    }\r\n\r\n    /* solcov ignore next */\r\n    function onFeeDistribution(address _rewardAddress, uint256 _fee) internal;\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/amb_native_to_erc20/ForeignFeeManagerAMBNativeToErc20.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n/**\r\n* @title ForeignFeeManagerAMBNativeToErc20\r\n* @dev Implements the logic to distribute fees from the native to erc20 mediator contract operations.\r\n* The fees are distributed in the form of tokens to the list of reward accounts.\r\n*/\r\ncontract ForeignFeeManagerAMBNativeToErc20 is BaseMediatorFeeManager {\r\n    address public token;\r\n\r\n    /**\r\n    * @dev Stores the initial parameters of the fee manager.\r\n    * @param _owner address of the owner of the fee manager contract.\r\n    * @param _fee the fee percentage amount.\r\n    * @param _rewardAccountList list of addresses that will receive the fee rewards.\r\n    * @param _token address of the token in which the fees will be received.\r\n    */\r\n    constructor(address _owner, uint256 _fee, address[] _rewardAccountList, address _mediatorContract, address _token)\r\n        public\r\n        BaseMediatorFeeManager(_owner, _fee, _rewardAccountList, _mediatorContract)\r\n    {\r\n        _setToken(_token);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the token address.\r\n    * Only the owner can call this method.\r\n    * @param _newToken address of the token in which the fees will be received.\r\n    */\r\n    function setToken(address _newToken) external onlyOwner {\r\n        _setToken(_newToken);\r\n    }\r\n\r\n    /**\r\n    * @dev Stores the token address.\r\n    * @param _newToken address of the token in which the fees will be received.\r\n    */\r\n    function _setToken(address _newToken) internal {\r\n        require(AddressUtils.isContract(_newToken));\r\n        token = _newToken;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer the fee amount of tokens to the reward account.\r\n    * @param _rewardAddress address that will receive the tokens.\r\n    * @param _fee amount of tokens to be transferred.\r\n    */\r\n    function onFeeDistribution(address _rewardAddress, uint256 _fee) internal {\r\n        ERC20Basic(token).transfer(_rewardAddress, _fee);\r\n    }\r\n}"
    }
  }
}