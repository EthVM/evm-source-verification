{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ZuniBadge.sol": {
      "content": "// File: @openzeppelin/contracts/math/SafeMath.sol\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// Needed to handle structures externally\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        require(\r\n            set._values.length > index,\r\n            \"EnumerableSet: index out of bounds\"\r\n        );\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal virtual view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal virtual view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IBPool {\r\n    function rebind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) external;\r\n\r\n    function setSwapFee(uint256 swapFee) external;\r\n\r\n    function setPublicSwap(bool publicSwap) external;\r\n\r\n    function bind(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denorm\r\n    ) external;\r\n\r\n    function unbind(address token) external;\r\n\r\n    function gulp(address token) external;\r\n\r\n    function isBound(address token) external view returns (bool);\r\n\r\n    function getBalance(address token) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function getSwapFee() external view returns (uint256);\r\n\r\n    function isPublicSwap() external view returns (bool);\r\n\r\n    function getDenormalizedWeight(address token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getTotalDenormalizedWeight() external view returns (uint256);\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function EXIT_FEE() external view returns (uint256);\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 poolAmountOut);\r\n\r\n    function calcSingleInGivenPoolOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountOut,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 tokenAmountIn);\r\n\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 tokenAmountOut);\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    ) external pure returns (uint256 poolAmountIn);\r\n\r\n    function getCurrentTokens() external view returns (address[] memory tokens);\r\n}\r\n\r\ninterface IBFactory {\r\n    function newBPool() external returns (IBPool);\r\n\r\n    function setBLabs(address b) external;\r\n\r\n    function collect(IBPool pool) external;\r\n\r\n    function isBPool(address b) external view returns (bool);\r\n\r\n    function getBLabs() external view returns (address);\r\n}\r\n\r\nlibrary BalancerConstants {\r\n    // State variables (must be constant in a library)\r\n\r\n    // B \"ONE\" - all math is in the \"realm\" of 10 ** 18;\r\n    // where numeric 1 = 10 ** 18\r\n    uint256 public constant BONE = 10**18;\r\n    uint256 public constant MIN_WEIGHT = BONE;\r\n    uint256 public constant MAX_WEIGHT = BONE * 50;\r\n    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\r\n    uint256 public constant MIN_BALANCE = BONE / 10**6;\r\n    uint256 public constant MAX_BALANCE = BONE * 10**12;\r\n    uint256 public constant MIN_POOL_SUPPLY = BONE * 100;\r\n    uint256 public constant MAX_POOL_SUPPLY = BONE * 10**9;\r\n    uint256 public constant MIN_FEE = BONE / 10**6;\r\n    uint256 public constant MAX_FEE = BONE / 10;\r\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\r\n    uint256 public constant EXIT_FEE = 0;\r\n    uint256 public constant MAX_IN_RATIO = BONE / 2;\r\n    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\r\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\r\n    uint256 public constant MIN_ASSET_LIMIT = 2;\r\n    uint256 public constant MAX_ASSET_LIMIT = 8;\r\n    uint256 public constant MAX_UINT = uint256(-1);\r\n}\r\n\r\n// File: contracts/balancer/libraries/BalancerSafeMath.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Imports\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\r\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\r\n */\r\nlibrary BalancerSafeMath {\r\n    /**\r\n     * @notice Safe addition\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev if we are adding b to a, the resulting sum must be greater than a\r\n     * @return - sum of operands; throws if overflow\r\n     */\r\n    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned subtraction\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Do a signed subtraction, and check that it produces a positive value\r\n     *      (i.e., a - b is valid if b <= a)\r\n     * @return - a - b; throws if underflow\r\n     */\r\n    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        (uint256 c, bool negativeResult) = bsubSign(a, b);\r\n        require(!negativeResult, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe signed subtraction\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Do a signed subtraction\r\n     * @return - difference between a and b, and a flag indicating a negative result\r\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\r\n     */\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (b <= a) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Safe multiplication\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @dev Multiply safely (and efficiently), rounding down\r\n     * @return - product of operands; throws if overflow or rounding error\r\n     */\r\n    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Standard overflow check: a/a*b=b\r\n        uint256 c0 = a * b;\r\n        require(c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n\r\n        // Round to 0 if x*y < BONE/2?\r\n        uint256 c1 = c0 + (BalancerConstants.BONE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / BalancerConstants.BONE;\r\n        return c2;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe division\r\n     * @param dividend - first operand\r\n     * @param divisor - second operand\r\n     * @dev Divide safely (and efficiently), rounding down\r\n     * @return - quotient; throws if overflow or rounding error\r\n     */\r\n    function bdiv(uint256 dividend, uint256 divisor)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(divisor != 0, \"ERR_DIV_ZERO\");\r\n\r\n        // Gas optimization\r\n        if (dividend == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c0 = dividend * BalancerConstants.BONE;\r\n        require(c0 / dividend == BalancerConstants.BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n\r\n        uint256 c1 = c0 + (divisor / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n\r\n        uint256 c2 = c1 / divisor;\r\n        return c2;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer modulo\r\n     * @dev Returns the remainder of dividing two unsigned integers.\r\n     *      Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * @param dividend - first operand\r\n     * @param divisor - second operand -- cannot be zero\r\n     * @return - quotient; throws if overflow or rounding error\r\n     */\r\n    function bmod(uint256 dividend, uint256 divisor)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(divisor != 0, \"ERR_MODULO_BY_ZERO\");\r\n\r\n        return dividend % divisor;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer max\r\n     * @dev Returns the greater of the two input values\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the maximum of a and b\r\n     */\r\n    function bmax(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer min\r\n     * @dev returns b, if b < a; otherwise returns a\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the lesser of the two input values\r\n     */\r\n    function bmin(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Safe unsigned integer average\r\n     * @dev Guard against (a+b) overflow by dividing each operand separately\r\n     *\r\n     * @param a - first operand\r\n     * @param b - second operand\r\n     * @return - the average of the two values\r\n     */\r\n    function baverage(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n\r\n    /**\r\n     * @notice Babylonian square root implementation\r\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n     * @param y - operand\r\n     * @return z - the square root result\r\n     */\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    // Emitted when the allowance of a spender for an owner is set by a call to approve.\r\n    // Value is the new allowance\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // Emitted when value tokens are moved from one account (from) to another (to).\r\n    // Note that value may be zero\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // Returns the amount of tokens in existence\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // Returns the amount of tokens owned by account\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\r\n    // through transferFrom. This is zero by default\r\n    // This value changes when approve or transferFrom are called\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    // Sets amount as the allowance of spender over the caller’s tokens\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits an Approval event.\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    // Moves amount tokens from the caller’s account to recipient\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits a Transfer event.\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    // Moves amount tokens from sender to recipient using the allowance mechanism\r\n    // Amount is then deducted from the caller’s allowance\r\n    // Returns a boolean value indicating whether the operation succeeded\r\n    // Emits a Transfer event\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// Contracts\r\n\r\n/* solhint-disable func-order */\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Highly opinionated token implementation\r\n */\r\ncontract PCToken is IERC20 {\r\n    using BalancerSafeMath for uint256;\r\n\r\n    // State variables\r\n    string public constant NAME = \"Balancer Smart Pool\";\r\n    uint8 public constant DECIMALS = 18;\r\n\r\n    // No leading underscore per naming convention (non-private)\r\n    // Cannot call totalSupply (name conflict)\r\n    // solhint-disable-next-line private-vars-leading-underscore\r\n    uint256 internal varTotalSupply;\r\n\r\n    mapping(address => uint256) private _balance;\r\n    mapping(address => mapping(address => uint256)) private _allowance;\r\n\r\n    string private _symbol;\r\n    string private _name;\r\n\r\n    // Event declarations\r\n\r\n    // See definitions above; must be redeclared to be emitted from this contract\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Base token constructor\r\n     * @param tokenSymbol - the token symbol\r\n     */\r\n    constructor(string memory tokenSymbol, string memory tokenName) public {\r\n        _symbol = tokenSymbol;\r\n        _name = tokenName;\r\n    }\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice Getter for allowance: amount spender will be allowed to spend on behalf of owner\r\n     * @param owner - owner of the tokens\r\n     * @param spender - entity allowed to spend the tokens\r\n     * @return uint - remaining amount spender is allowed to transfer\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowance[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for current account balance\r\n     * @param account - address we're checking the balance of\r\n     * @return uint - token balance in the account\r\n     */\r\n    function balanceOf(address account)\r\n        external\r\n        override\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _balance[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve owner (sender) to spend a certain amount\r\n     * @dev emits an Approval event\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        /* In addition to the increase/decreaseApproval functions, could\r\n           avoid the \"approval race condition\" by only allowing calls to approve\r\n           when the current approval amount is 0\r\n        \r\n           require(_allowance[msg.sender][spender] == 0, \"ERR_RACE_CONDITION\");\r\n           Some token contracts (e.g., KNC), already revert if you call approve \r\n           on a non-zero allocation. To deal with these, we use the SafeApprove library\r\n           and safeApprove function when adding tokens to the pool.\r\n        */\r\n\r\n        _allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Increase the amount the spender is allowed to spend on behalf of the owner (sender)\r\n     * @dev emits an Approval event\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function increaseApproval(address spender, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _allowance[msg.sender][spender] = BalancerSafeMath.badd(\r\n            _allowance[msg.sender][spender],\r\n            amount\r\n        );\r\n\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease the amount the spender is allowed to spend on behalf of the owner (sender)\r\n     * @dev emits an Approval event\r\n     * @dev If you try to decrease it below the current limit, it's just set to zero (not an error)\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     * @return bool - result of the approval (will always be true if it doesn't revert)\r\n     */\r\n    function decreaseApproval(address spender, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = _allowance[msg.sender][spender];\r\n        // Gas optimization - if amount == oldValue (or is larger), set to zero immediately\r\n        if (amount >= oldValue) {\r\n            _allowance[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowance[msg.sender][spender] = BalancerSafeMath.bsub(\r\n                oldValue,\r\n                amount\r\n            );\r\n        }\r\n\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the given amount from sender (caller) to recipient\r\n     * @dev _move emits a Transfer event if successful\r\n     * @param recipient - entity receiving the tokens\r\n     * @param amount - number of tokens being transferred\r\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\r\n\r\n        _move(msg.sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the given amount from sender to recipient\r\n     * @dev _move emits a Transfer event if successful; may also emit an Approval event\r\n     * @param sender - entity sending the tokens (must be caller or allowed to spend on behalf of caller)\r\n     * @param recipient - recipient of the tokens\r\n     * @param amount - number of tokens being transferred\r\n     * @return bool - result of the transfer (will always be true if it doesn't revert)\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        require(recipient != address(0), \"ERR_ZERO_ADDRESS\");\r\n        require(\r\n            msg.sender == sender || amount <= _allowance[sender][msg.sender],\r\n            \"ERR_PCTOKEN_BAD_CALLER\"\r\n        );\r\n\r\n        _move(sender, recipient, amount);\r\n\r\n        // memoize for gas optimization\r\n        uint256 oldAllowance = _allowance[sender][msg.sender];\r\n\r\n        // If the sender is not the caller, adjust the allowance by the amount transferred\r\n        if (msg.sender != sender && oldAllowance != uint256(-1)) {\r\n            _allowance[sender][msg.sender] = BalancerSafeMath.bsub(\r\n                oldAllowance,\r\n                amount\r\n            );\r\n\r\n            emit Approval(\r\n                msg.sender,\r\n                recipient,\r\n                _allowance[sender][msg.sender]\r\n            );\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // public functions\r\n\r\n    /**\r\n     * @notice Getter for the total supply\r\n     * @dev declared external for gas optimization\r\n     * @return uint - total number of tokens in existence\r\n     */\r\n    function totalSupply() external override view returns (uint256) {\r\n        return varTotalSupply;\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     *      We allow the user to set this name (as well as the symbol).\r\n     *      Alternatives are 1) A fixed string (original design)\r\n     *                       2) A fixed string plus the user-defined symbol\r\n     *                          return string(abi.encodePacked(NAME, \"-\", _symbol));\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external pure returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n\r\n    // internal functions\r\n\r\n    // Mint an amount of new tokens, and add them to the balance (and total supply)\r\n    // Emit a transfer amount from the null address to this contract\r\n    function _mint(uint256 amount) internal virtual {\r\n        _balance[address(this)] = BalancerSafeMath.badd(\r\n            _balance[address(this)],\r\n            amount\r\n        );\r\n        varTotalSupply = BalancerSafeMath.badd(varTotalSupply, amount);\r\n\r\n        emit Transfer(address(0), address(this), amount);\r\n    }\r\n\r\n    // Burn an amount of new tokens, and subtract them from the balance (and total supply)\r\n    // Emit a transfer amount from this contract to the null address\r\n    function _burn(uint256 amount) internal virtual {\r\n        // Can't burn more than we have\r\n        // Remove require for gas optimization - bsub will revert on underflow\r\n        // require(_balance[address(this)] >= amount, \"ERR_INSUFFICIENT_BAL\");\r\n\r\n        _balance[address(this)] = BalancerSafeMath.bsub(\r\n            _balance[address(this)],\r\n            amount\r\n        );\r\n        varTotalSupply = BalancerSafeMath.bsub(varTotalSupply, amount);\r\n\r\n        emit Transfer(address(this), address(0), amount);\r\n    }\r\n\r\n    // Transfer tokens from sender to recipient\r\n    // Adjust balances, and emit a Transfer event\r\n    function _move(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        // Can't send more than sender has\r\n        // Remove require for gas optimization - bsub will revert on underflow\r\n        // require(_balance[sender] >= amount, \"ERR_INSUFFICIENT_BAL\");\r\n\r\n        _balance[sender] = BalancerSafeMath.bsub(_balance[sender], amount);\r\n        _balance[recipient] = BalancerSafeMath.badd(\r\n            _balance[recipient],\r\n            amount\r\n        );\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    // Transfer from this contract to recipient\r\n    // Emits a transfer event if successful\r\n    function _push(address recipient, uint256 amount) internal {\r\n        _move(address(this), recipient, amount);\r\n    }\r\n\r\n    // Transfer from recipient to this contract\r\n    // Emits a transfer event if successful\r\n    function _pull(address sender, uint256 amount) internal {\r\n        _move(sender, address(this), amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @author Balancer Labs (and OpenZeppelin)\r\n * @title Protect against reentrant calls (and also selectively protect view functions)\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {_lock_} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `_lock_` guard, functions marked as\r\n * `_lock_` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `_lock_` entry\r\n * points to them.\r\n *\r\n * Also adds a _lockview_ modifier, which doesn't create a lock, but fails\r\n *   if another _lock_ call is in progress\r\n */\r\ncontract BalancerReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `_lock_` function from another `_lock_`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `_lock_` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier lock() {\r\n        // On the first call to _lock_, _notEntered will be true\r\n        require(_status != _ENTERED, \"ERR_REENTRY\");\r\n\r\n        // Any calls to _lock_ after this point will fail\r\n        _status = _ENTERED;\r\n        _;\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Also add a modifier that doesn't create a lock, but protects functions that\r\n     *      should not be called while a _lock_ function is running\r\n     */\r\n    modifier viewlock() {\r\n        require(_status != _ENTERED, \"ERR_REENTRY_VIEW\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract BalancerOwnable {\r\n    // State variables\r\n\r\n    address private _owner;\r\n\r\n    // Event declarations\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    // Modifiers\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"ERR_NOT_CONTROLLER\");\r\n        _;\r\n    }\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account (`newOwner`).\r\n     *         Can only be called by the current owner\r\n     * @dev external for gas optimization\r\n     * @param newOwner - address of new owner\r\n     */\r\n    function setController(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"ERR_ZERO_ADDRESS\");\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the current owner\r\n     * @dev external for gas optimization\r\n     * @return address - of the owner (AKA controller)\r\n     */\r\n    function getController() external view returns (address) {\r\n        return _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Manage Configurable Rights for the smart pool\r\n *      canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                         by default, it is off on initialization and can only be turned on\r\n *      canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      canWhitelistLPs - can limit liquidity providers to a given set of addresses\r\n *      canChangeCap - can change the BSP cap (max # of pool tokens)\r\n */\r\nlibrary RightsManager {\r\n    // Type declarations\r\n\r\n    enum Permissions {\r\n        PAUSE_SWAPPING,\r\n        CHANGE_SWAP_FEE,\r\n        CHANGE_WEIGHTS,\r\n        ADD_REMOVE_TOKENS,\r\n        WHITELIST_LPS,\r\n        CHANGE_CAP\r\n    }\r\n\r\n    struct Rights {\r\n        bool canPauseSwapping;\r\n        bool canChangeSwapFee;\r\n        bool canChangeWeights;\r\n        bool canAddRemoveTokens;\r\n        bool canWhitelistLPs;\r\n        bool canChangeCap;\r\n    }\r\n\r\n    // State variables (can only be constants in a library)\r\n    bool public constant DEFAULT_CAN_PAUSE_SWAPPING = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_SWAP_FEE = true;\r\n    bool public constant DEFAULT_CAN_CHANGE_WEIGHTS = true;\r\n    bool public constant DEFAULT_CAN_ADD_REMOVE_TOKENS = false;\r\n    bool public constant DEFAULT_CAN_WHITELIST_LPS = false;\r\n    bool public constant DEFAULT_CAN_CHANGE_CAP = false;\r\n\r\n    // Functions\r\n\r\n    /**\r\n     * @notice create a struct from an array (or return defaults)\r\n     * @dev If you pass an empty array, it will construct it using the defaults\r\n     * @param a - array input\r\n     * @return Rights struct\r\n     */\r\n\r\n    function constructRights(bool[] calldata a)\r\n        external\r\n        pure\r\n        returns (Rights memory)\r\n    {\r\n        if (a.length == 0) {\r\n            return\r\n                Rights(\r\n                    DEFAULT_CAN_PAUSE_SWAPPING,\r\n                    DEFAULT_CAN_CHANGE_SWAP_FEE,\r\n                    DEFAULT_CAN_CHANGE_WEIGHTS,\r\n                    DEFAULT_CAN_ADD_REMOVE_TOKENS,\r\n                    DEFAULT_CAN_WHITELIST_LPS,\r\n                    DEFAULT_CAN_CHANGE_CAP\r\n                );\r\n        } else {\r\n            return Rights(a[0], a[1], a[2], a[3], a[4], a[5]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Convert rights struct to an array (e.g., for events, GUI)\r\n     * @dev avoids multiple calls to hasPermission\r\n     * @param rights - the rights struct to convert\r\n     * @return boolean array containing the rights settings\r\n     */\r\n    function convertRights(Rights calldata rights)\r\n        external\r\n        pure\r\n        returns (bool[] memory)\r\n    {\r\n        bool[] memory result = new bool[](6);\r\n\r\n        result[0] = rights.canPauseSwapping;\r\n        result[1] = rights.canChangeSwapFee;\r\n        result[2] = rights.canChangeWeights;\r\n        result[3] = rights.canAddRemoveTokens;\r\n        result[4] = rights.canWhitelistLPs;\r\n        result[5] = rights.canChangeCap;\r\n\r\n        return result;\r\n    }\r\n\r\n    // Though it is actually simple, the number of branches triggers code-complexity\r\n    /* solhint-disable code-complexity */\r\n\r\n    /**\r\n     * @notice Externally check permissions using the Enum\r\n     * @param self - Rights struct containing the permissions\r\n     * @param permission - The permission to check\r\n     * @return Boolean true if it has the permission\r\n     */\r\n    function hasPermission(Rights calldata self, Permissions permission)\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (Permissions.PAUSE_SWAPPING == permission) {\r\n            return self.canPauseSwapping;\r\n        } else if (Permissions.CHANGE_SWAP_FEE == permission) {\r\n            return self.canChangeSwapFee;\r\n        } else if (Permissions.CHANGE_WEIGHTS == permission) {\r\n            return self.canChangeWeights;\r\n        } else if (Permissions.ADD_REMOVE_TOKENS == permission) {\r\n            return self.canAddRemoveTokens;\r\n        } else if (Permissions.WHITELIST_LPS == permission) {\r\n            return self.canWhitelistLPs;\r\n        } else if (Permissions.CHANGE_CAP == permission) {\r\n            return self.canChangeCap;\r\n        }\r\n    }\r\n\r\n    /* solhint-enable code-complexity */\r\n}\r\n\r\n// File: contracts/balancer/interfaces/IConfigurableRightsPool.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n// Interface declarations\r\n\r\n// Introduce to avoid circularity (otherwise, the CRP and SmartPoolManager include each other)\r\n// Removing circularity allows flattener tools to work, which enables Etherscan verification\r\ninterface IConfigurableRightsPool {\r\n    function mintPoolShareFromLib(uint256 amount) external;\r\n\r\n    function pushPoolShareFromLib(address to, uint256 amount) external;\r\n\r\n    function pullPoolShareFromLib(address from, uint256 amount) external;\r\n\r\n    function burnPoolShareFromLib(uint256 amount) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function getController() external view returns (address);\r\n}\r\n\r\n/**\r\n * @author PieDAO (ported to Balancer Labs)\r\n * @title SafeApprove - set approval for tokens that require 0 prior approval\r\n * @dev Perhaps to address the known ERC20 race condition issue\r\n *      See https://github.com/crytic/not-so-smart-contracts/tree/master/race_condition\r\n *      Some tokens - notably KNC - only allow approvals to be increased from 0\r\n */\r\nlibrary SafeApprove {\r\n    /**\r\n     * @notice handle approvals of tokens that require approving from a base of 0\r\n     * @param token - the token we're approving\r\n     * @param spender - entity the owner (sender) is approving to spend his tokens\r\n     * @param amount - number of tokens being approved\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 currentAllowance = token.allowance(address(this), spender);\r\n\r\n        // Do nothing if allowance is already set to this value\r\n        if (currentAllowance == amount) {\r\n            return true;\r\n        }\r\n\r\n        // If approval is not zero reset it to zero first\r\n        if (currentAllowance != 0) {\r\n            return token.approve(spender, 0);\r\n        }\r\n\r\n        // do the actual approval\r\n        return token.approve(spender, amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Factor out the weight updates\r\n */\r\nlibrary SmartPoolManager {\r\n    // Type declarations\r\n\r\n    struct NewTokenParams {\r\n        address addr;\r\n        bool isCommitted;\r\n        uint256 commitBlock;\r\n        uint256 denorm;\r\n        uint256 balance;\r\n    }\r\n\r\n    // For blockwise, automated weight updates\r\n    // Move weights linearly from startWeights to endWeights,\r\n    // between startBlock and endBlock\r\n    struct GradualUpdateParams {\r\n        uint256 startBlock;\r\n        uint256 endBlock;\r\n        uint256[] startWeights;\r\n        uint256[] endWeights;\r\n    }\r\n\r\n    // updateWeight and pokeWeights are unavoidably long\r\n    /* solhint-disable function-max-lines */\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token\r\n     * @dev Refactored to library to make CRPFactory deployable\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - token to be reweighted\r\n     * @param newWeight - new weight of the token\r\n     */\r\n    function updateWeight(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address token,\r\n        uint256 newWeight\r\n    ) external {\r\n        require(newWeight >= BalancerConstants.MIN_WEIGHT, \"ERR_MIN_WEIGHT\");\r\n        require(newWeight <= BalancerConstants.MAX_WEIGHT, \"ERR_MAX_WEIGHT\");\r\n\r\n        uint256 currentWeight = bPool.getDenormalizedWeight(token);\r\n        // Save gas; return immediately on NOOP\r\n        if (currentWeight == newWeight) {\r\n            return;\r\n        }\r\n\r\n        uint256 currentBalance = bPool.getBalance(token);\r\n        uint256 totalSupply = self.totalSupply();\r\n        uint256 totalWeight = bPool.getTotalDenormalizedWeight();\r\n        uint256 poolShares;\r\n        uint256 deltaBalance;\r\n        uint256 deltaWeight;\r\n        uint256 newBalance;\r\n\r\n        if (newWeight < currentWeight) {\r\n            // This means the controller will withdraw tokens to keep price\r\n            // So they need to redeem PCTokens\r\n            deltaWeight = BalancerSafeMath.bsub(currentWeight, newWeight);\r\n\r\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\r\n            poolShares = BalancerSafeMath.bmul(\r\n                totalSupply,\r\n                BalancerSafeMath.bdiv(deltaWeight, totalWeight)\r\n            );\r\n\r\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\r\n            deltaBalance = BalancerSafeMath.bmul(\r\n                currentBalance,\r\n                BalancerSafeMath.bdiv(deltaWeight, currentWeight)\r\n            );\r\n\r\n            // New balance cannot be lower than MIN_BALANCE\r\n            newBalance = BalancerSafeMath.bsub(currentBalance, deltaBalance);\r\n\r\n            require(\r\n                newBalance >= BalancerConstants.MIN_BALANCE,\r\n                \"ERR_MIN_BALANCE\"\r\n            );\r\n\r\n            // First get the tokens from this contract (Pool Controller) to msg.sender\r\n            bPool.rebind(token, newBalance, newWeight);\r\n\r\n            // Now with the tokens this contract can send them to msg.sender\r\n            bool xfer = IERC20(token).transfer(msg.sender, deltaBalance);\r\n            require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n            self.pullPoolShareFromLib(msg.sender, poolShares);\r\n            self.burnPoolShareFromLib(poolShares);\r\n        } else {\r\n            // This means the controller will deposit tokens to keep the price.\r\n            // They will be minted and given PCTokens\r\n            deltaWeight = BalancerSafeMath.bsub(newWeight, currentWeight);\r\n\r\n            require(\r\n                BalancerSafeMath.badd(totalWeight, deltaWeight) <=\r\n                    BalancerConstants.MAX_TOTAL_WEIGHT,\r\n                \"ERR_MAX_TOTAL_WEIGHT\"\r\n            );\r\n\r\n            // poolShares = totalSupply * (deltaWeight / totalWeight)\r\n            poolShares = BalancerSafeMath.bmul(\r\n                totalSupply,\r\n                BalancerSafeMath.bdiv(deltaWeight, totalWeight)\r\n            );\r\n            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\r\n            deltaBalance = BalancerSafeMath.bmul(\r\n                currentBalance,\r\n                BalancerSafeMath.bdiv(deltaWeight, currentWeight)\r\n            );\r\n\r\n            // First gets the tokens from msg.sender to this contract (Pool Controller)\r\n            bool xfer = IERC20(token).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                deltaBalance\r\n            );\r\n            require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n            // Now with the tokens this contract can bind them to the pool it controls\r\n            bPool.rebind(\r\n                token,\r\n                BalancerSafeMath.badd(currentBalance, deltaBalance),\r\n                newWeight\r\n            );\r\n\r\n            self.mintPoolShareFromLib(poolShares);\r\n            self.pushPoolShareFromLib(msg.sender, poolShares);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param gradualUpdate - gradual update parameters from the CRP\r\n     */\r\n    function pokeWeights(\r\n        IBPool bPool,\r\n        GradualUpdateParams storage gradualUpdate\r\n    ) external {\r\n        // Do nothing if we call this when there is no update plan\r\n        if (gradualUpdate.startBlock == 0) {\r\n            return;\r\n        }\r\n\r\n        // Error to call it before the start of the plan\r\n        require(block.number >= gradualUpdate.startBlock, \"ERR_CANT_POKE_YET\");\r\n        // Proposed error message improvement\r\n        // require(block.number >= startBlock, \"ERR_NO_HOKEY_POKEY\");\r\n\r\n        // This allows for pokes after endBlock that get weights to endWeights\r\n        // Get the current block (or the endBlock, if we're already past the end)\r\n        uint256 currentBlock;\r\n        if (block.number > gradualUpdate.endBlock) {\r\n            currentBlock = gradualUpdate.endBlock;\r\n        } else {\r\n            currentBlock = block.number;\r\n        }\r\n\r\n        uint256 blockPeriod = BalancerSafeMath.bsub(\r\n            gradualUpdate.endBlock,\r\n            gradualUpdate.startBlock\r\n        );\r\n        uint256 blocksElapsed = BalancerSafeMath.bsub(\r\n            currentBlock,\r\n            gradualUpdate.startBlock\r\n        );\r\n        uint256 weightDelta;\r\n        uint256 deltaPerBlock;\r\n        uint256 newWeight;\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            // Make sure it does nothing if the new and old weights are the same (saves gas)\r\n            // It's a degenerate case if they're *all* the same, but you certainly could have\r\n            // a plan where you only change some of the weights in the set\r\n            if (gradualUpdate.startWeights[i] != gradualUpdate.endWeights[i]) {\r\n                if (\r\n                    gradualUpdate.endWeights[i] < gradualUpdate.startWeights[i]\r\n                ) {\r\n                    // We are decreasing the weight\r\n\r\n                    // First get the total weight delta\r\n                    weightDelta = BalancerSafeMath.bsub(\r\n                        gradualUpdate.startWeights[i],\r\n                        gradualUpdate.endWeights[i]\r\n                    );\r\n                    // And the amount it should change per block = total change/number of blocks in the period\r\n                    deltaPerBlock = BalancerSafeMath.bdiv(\r\n                        weightDelta,\r\n                        blockPeriod\r\n                    );\r\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\r\n\r\n                    // newWeight = startWeight - (blocksElapsed * deltaPerBlock)\r\n                    newWeight = BalancerSafeMath.bsub(\r\n                        gradualUpdate.startWeights[i],\r\n                        BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock)\r\n                    );\r\n                } else {\r\n                    // We are increasing the weight\r\n\r\n                    // First get the total weight delta\r\n                    weightDelta = BalancerSafeMath.bsub(\r\n                        gradualUpdate.endWeights[i],\r\n                        gradualUpdate.startWeights[i]\r\n                    );\r\n                    // And the amount it should change per block = total change/number of blocks in the period\r\n                    deltaPerBlock = BalancerSafeMath.bdiv(\r\n                        weightDelta,\r\n                        blockPeriod\r\n                    );\r\n                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\r\n\r\n                    // newWeight = startWeight + (blocksElapsed * deltaPerBlock)\r\n                    newWeight = BalancerSafeMath.badd(\r\n                        gradualUpdate.startWeights[i],\r\n                        BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock)\r\n                    );\r\n                }\r\n\r\n                uint256 bal = bPool.getBalance(tokens[i]);\r\n\r\n                bPool.rebind(tokens[i], bal, newWeight);\r\n            }\r\n        }\r\n\r\n        // Reset to allow add/remove tokens, or manual weight updates\r\n        if (block.number >= gradualUpdate.endBlock) {\r\n            gradualUpdate.startBlock = 0;\r\n        }\r\n    }\r\n\r\n    /* solhint-enable function-max-lines */\r\n\r\n    /**\r\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\r\n     *         number of blocks to actually add the token\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - the token to be added\r\n     * @param balance - how much to be added\r\n     * @param denormalizedWeight - the desired token weight\r\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\r\n     */\r\n    function commitAddToken(\r\n        IBPool bPool,\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denormalizedWeight,\r\n        NewTokenParams storage newToken\r\n    ) external {\r\n        require(!bPool.isBound(token), \"ERR_IS_BOUND\");\r\n\r\n        require(\r\n            denormalizedWeight <= BalancerConstants.MAX_WEIGHT,\r\n            \"ERR_WEIGHT_ABOVE_MAX\"\r\n        );\r\n        require(\r\n            denormalizedWeight >= BalancerConstants.MIN_WEIGHT,\r\n            \"ERR_WEIGHT_BELOW_MIN\"\r\n        );\r\n        require(\r\n            BalancerSafeMath.badd(\r\n                bPool.getTotalDenormalizedWeight(),\r\n                denormalizedWeight\r\n            ) <= BalancerConstants.MAX_TOTAL_WEIGHT,\r\n            \"ERR_MAX_TOTAL_WEIGHT\"\r\n        );\r\n        require(\r\n            balance >= BalancerConstants.MIN_BALANCE,\r\n            \"ERR_BALANCE_BELOW_MIN\"\r\n        );\r\n\r\n        newToken.addr = token;\r\n        newToken.balance = balance;\r\n        newToken.denorm = denormalizedWeight;\r\n        newToken.commitBlock = block.number;\r\n        newToken.isCommitted = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token previously committed (in commitAddToken) to the pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param addTokenTimeLockInBlocks -  Wait time between committing and applying a new token\r\n     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\r\n     */\r\n    function applyAddToken(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint256 addTokenTimeLockInBlocks,\r\n        NewTokenParams storage newToken\r\n    ) external {\r\n        require(newToken.isCommitted, \"ERR_NO_TOKEN_COMMIT\");\r\n        require(\r\n            BalancerSafeMath.bsub(block.number, newToken.commitBlock) >=\r\n                addTokenTimeLockInBlocks,\r\n            \"ERR_TIMELOCK_STILL_COUNTING\"\r\n        );\r\n\r\n        uint256 totalSupply = self.totalSupply();\r\n\r\n        // poolShares = totalSupply * newTokenWeight / totalWeight\r\n        uint256 poolShares = BalancerSafeMath.bdiv(\r\n            BalancerSafeMath.bmul(totalSupply, newToken.denorm),\r\n            bPool.getTotalDenormalizedWeight()\r\n        );\r\n\r\n        // Clear this to allow adding more tokens\r\n        newToken.isCommitted = false;\r\n\r\n        // First gets the tokens from msg.sender to this contract (Pool Controller)\r\n        bool returnValue = IERC20(newToken.addr).transferFrom(\r\n            self.getController(),\r\n            address(self),\r\n            newToken.balance\r\n        );\r\n        require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n        // Now with the tokens this contract can bind them to the pool it controls\r\n        // Approves bPool to pull from this controller\r\n        // Approve unlimited, same as when creating the pool, so they can join pools later\r\n        returnValue = SafeApprove.safeApprove(\r\n            IERC20(newToken.addr),\r\n            address(bPool),\r\n            BalancerConstants.MAX_UINT\r\n        );\r\n        require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n        bPool.bind(newToken.addr, newToken.balance, newToken.denorm);\r\n\r\n        self.mintPoolShareFromLib(poolShares);\r\n        self.pushPoolShareFromLib(msg.sender, poolShares);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a token from the pool\r\n     * @dev Logic in the CRP controls when ths can be called. There are two related permissions:\r\n     *      AddRemoveTokens - which allows removing down to the underlying BPool limit of two\r\n     *      RemoveAllTokens - which allows completely draining the pool by removing all tokens\r\n     *                        This can result in a non-viable pool with 0 or 1 tokens (by design),\r\n     *                        meaning all swapping or binding operations would fail in this state\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param token - token to remove\r\n     */\r\n    function removeToken(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address token\r\n    ) external {\r\n        uint256 totalSupply = self.totalSupply();\r\n\r\n        // poolShares = totalSupply * tokenWeight / totalWeight\r\n        uint256 poolShares = BalancerSafeMath.bdiv(\r\n            BalancerSafeMath.bmul(\r\n                totalSupply,\r\n                bPool.getDenormalizedWeight(token)\r\n            ),\r\n            bPool.getTotalDenormalizedWeight()\r\n        );\r\n\r\n        // this is what will be unbound from the pool\r\n        // Have to get it before unbinding\r\n        uint256 balance = bPool.getBalance(token);\r\n\r\n        // Unbind and get the tokens out of balancer pool\r\n        bPool.unbind(token);\r\n\r\n        // Now with the tokens this contract can send them to msg.sender\r\n        bool xfer = IERC20(token).transfer(self.getController(), balance);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n\r\n        self.pullPoolShareFromLib(self.getController(), poolShares);\r\n        self.burnPoolShareFromLib(poolShares);\r\n    }\r\n\r\n    /**\r\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\r\n     * @dev Will revert if invalid\r\n     * @param token - The prospective token to verify\r\n     */\r\n    function verifyTokenCompliance(address token) external {\r\n        verifyTokenComplianceInternal(token);\r\n    }\r\n\r\n    /**\r\n     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\r\n     * @dev Will revert if invalid - overloaded to save space in the main contract\r\n     * @param tokens - The prospective tokens to verify\r\n     */\r\n    function verifyTokenCompliance(address[] calldata tokens) external {\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            verifyTokenComplianceInternal(tokens[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external cals to pokeWeights\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param newWeights - final weights we want to get to\r\n     * @param startBlock - when weights should start to change\r\n     * @param endBlock - when weights will be at their final values\r\n     * @param minimumWeightChangeBlockPeriod - needed to validate the block period\r\n     */\r\n    function updateWeightsGradually(\r\n        IBPool bPool,\r\n        GradualUpdateParams storage gradualUpdate,\r\n        uint256[] calldata newWeights,\r\n        uint256 startBlock,\r\n        uint256 endBlock,\r\n        uint256 minimumWeightChangeBlockPeriod\r\n    ) external {\r\n        require(block.number < endBlock, \"ERR_GRADUAL_UPDATE_TIME_TRAVEL\");\r\n\r\n        if (block.number > startBlock) {\r\n            // This means the weight update should start ASAP\r\n            // Moving the start block up prevents a big jump/discontinuity in the weights\r\n            gradualUpdate.startBlock = block.number;\r\n        } else {\r\n            gradualUpdate.startBlock = startBlock;\r\n        }\r\n\r\n        // Enforce a minimum time over which to make the changes\r\n        // The also prevents endBlock <= startBlock\r\n        require(\r\n            BalancerSafeMath.bsub(endBlock, gradualUpdate.startBlock) >=\r\n                minimumWeightChangeBlockPeriod,\r\n            \"ERR_WEIGHT_CHANGE_TIME_BELOW_MIN\"\r\n        );\r\n\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        // Must specify weights for all tokens\r\n        require(\r\n            newWeights.length == tokens.length,\r\n            \"ERR_START_WEIGHTS_MISMATCH\"\r\n        );\r\n\r\n        uint256 weightsSum = 0;\r\n        gradualUpdate.startWeights = new uint256[](tokens.length);\r\n\r\n        // Check that endWeights are valid now to avoid reverting in a future pokeWeights call\r\n        //\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            require(\r\n                newWeights[i] <= BalancerConstants.MAX_WEIGHT,\r\n                \"ERR_WEIGHT_ABOVE_MAX\"\r\n            );\r\n            require(\r\n                newWeights[i] >= BalancerConstants.MIN_WEIGHT,\r\n                \"ERR_WEIGHT_BELOW_MIN\"\r\n            );\r\n\r\n            weightsSum = BalancerSafeMath.badd(weightsSum, newWeights[i]);\r\n            gradualUpdate.startWeights[i] = bPool.getDenormalizedWeight(\r\n                tokens[i]\r\n            );\r\n        }\r\n        require(\r\n            weightsSum <= BalancerConstants.MAX_TOTAL_WEIGHT,\r\n            \"ERR_MAX_TOTAL_WEIGHT\"\r\n        );\r\n\r\n        gradualUpdate.endBlock = endBlock;\r\n        gradualUpdate.endWeights = newWeights;\r\n    }\r\n\r\n    /**\r\n     * @notice Join a pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param poolAmountOut - number of pool tokens to receive\r\n     * @param maxAmountsIn - Max amount of asset tokens to spend\r\n     * @return actualAmountsIn - calculated values of the tokens to pull in\r\n     */\r\n    function joinPool(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint256 poolAmountOut,\r\n        uint256[] calldata maxAmountsIn\r\n    ) external view returns (uint256[] memory actualAmountsIn) {\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        require(maxAmountsIn.length == tokens.length, \"ERR_AMOUNTS_MISMATCH\");\r\n\r\n        uint256 poolTotal = self.totalSupply();\r\n        // Subtract  1 to ensure any rounding errors favor the pool\r\n        uint256 ratio = BalancerSafeMath.bdiv(\r\n            poolAmountOut,\r\n            BalancerSafeMath.bsub(poolTotal, 1)\r\n        );\r\n\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        // We know the length of the array; initialize it, and fill it below\r\n        // Cannot do \"push\" in memory\r\n        actualAmountsIn = new uint256[](tokens.length);\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint256 bal = bPool.getBalance(t);\r\n            // Add 1 to ensure any rounding errors favor the pool\r\n            uint256 tokenAmountIn = BalancerSafeMath.bmul(\r\n                ratio,\r\n                BalancerSafeMath.badd(bal, 1)\r\n            );\r\n\r\n            require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountIn <= maxAmountsIn[i], \"ERR_LIMIT_IN\");\r\n\r\n            actualAmountsIn[i] = tokenAmountIn;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for underlying assets\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountsOut - minimum amount of asset tokens to receive\r\n     * @return exitFee - calculated exit fee\r\n     * @return pAiAfterExitFee - final amount in (after accounting for exit fee)\r\n     * @return actualAmountsOut - calculated amounts of each token to pull\r\n     */\r\n    function exitPool(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        uint256 poolAmountIn,\r\n        uint256[] calldata minAmountsOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 exitFee,\r\n            uint256 pAiAfterExitFee,\r\n            uint256[] memory actualAmountsOut\r\n        )\r\n    {\r\n        address[] memory tokens = bPool.getCurrentTokens();\r\n\r\n        require(minAmountsOut.length == tokens.length, \"ERR_AMOUNTS_MISMATCH\");\r\n\r\n        uint256 poolTotal = self.totalSupply();\r\n\r\n        // Calculate exit fee and the final amount in\r\n        exitFee = BalancerSafeMath.bmul(\r\n            poolAmountIn,\r\n            BalancerConstants.EXIT_FEE\r\n        );\r\n        pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        uint256 ratio = BalancerSafeMath.bdiv(\r\n            pAiAfterExitFee,\r\n            BalancerSafeMath.badd(poolTotal, 1)\r\n        );\r\n\r\n        require(ratio != 0, \"ERR_MATH_APPROX\");\r\n\r\n        actualAmountsOut = new uint256[](tokens.length);\r\n\r\n        // This loop contains external calls\r\n        // External calls are to math libraries or the underlying pool, so low risk\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            address t = tokens[i];\r\n            uint256 bal = bPool.getBalance(t);\r\n            // Subtract 1 to ensure any rounding errors favor the pool\r\n            uint256 tokenAmountOut = BalancerSafeMath.bmul(\r\n                ratio,\r\n                BalancerSafeMath.bsub(bal, 1)\r\n            );\r\n\r\n            require(tokenAmountOut != 0, \"ERR_MATH_APPROX\");\r\n            require(tokenAmountOut >= minAmountsOut[i], \"ERR_LIMIT_OUT\");\r\n\r\n            actualAmountsOut[i] = tokenAmountOut;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\r\n     *         System calculates the pool token amount\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenIn - which token we're transferring in\r\n     * @param tokenAmountIn - amount of deposit\r\n     * @param minPoolAmountOut - minimum of pool tokens to receive\r\n     * @return poolAmountOut - amount of pool tokens minted and transferred\r\n     */\r\n    function joinswapExternAmountIn(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external view returns (uint256 poolAmountOut) {\r\n        require(bPool.isBound(tokenIn), \"ERR_NOT_BOUND\");\r\n        require(\r\n            tokenAmountIn <=\r\n                BalancerSafeMath.bmul(\r\n                    bPool.getBalance(tokenIn),\r\n                    BalancerConstants.MAX_IN_RATIO\r\n                ),\r\n            \"ERR_MAX_IN_RATIO\"\r\n        );\r\n\r\n        poolAmountOut = bPool.calcPoolOutGivenSingleIn(\r\n            bPool.getBalance(tokenIn),\r\n            bPool.getDenormalizedWeight(tokenIn),\r\n            self.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            tokenAmountIn,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        require(poolAmountOut >= minPoolAmountOut, \"ERR_LIMIT_OUT\");\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping an external token in (must be present in the pool)\r\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\r\n     * @param poolAmountOut - amount of pool tokens to be received\r\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\r\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\r\n     */\r\n    function joinswapPoolAmountOut(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenIn,\r\n        uint256 poolAmountOut,\r\n        uint256 maxAmountIn\r\n    ) external view returns (uint256 tokenAmountIn) {\r\n        require(bPool.isBound(tokenIn), \"ERR_NOT_BOUND\");\r\n\r\n        tokenAmountIn = bPool.calcSingleInGivenPoolOut(\r\n            bPool.getBalance(tokenIn),\r\n            bPool.getDenormalizedWeight(tokenIn),\r\n            self.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            poolAmountOut,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        require(tokenAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(tokenAmountIn <= maxAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        require(\r\n            tokenAmountIn <=\r\n                BalancerSafeMath.bmul(\r\n                    bPool.getBalance(tokenIn),\r\n                    BalancerConstants.MAX_IN_RATIO\r\n                ),\r\n            \"ERR_MAX_IN_RATIO\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\r\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountOut - minimum asset tokens to receive\r\n     * @return exitFee - calculated exit fee\r\n     * @return tokenAmountOut - amount of asset tokens returned\r\n     */\r\n    function exitswapPoolAmountIn(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external view returns (uint256 exitFee, uint256 tokenAmountOut) {\r\n        require(bPool.isBound(tokenOut), \"ERR_NOT_BOUND\");\r\n\r\n        tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\r\n            bPool.getBalance(tokenOut),\r\n            bPool.getDenormalizedWeight(tokenOut),\r\n            self.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            poolAmountIn,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        require(tokenAmountOut >= minAmountOut, \"ERR_LIMIT_OUT\");\r\n        require(\r\n            tokenAmountOut <=\r\n                BalancerSafeMath.bmul(\r\n                    bPool.getBalance(tokenOut),\r\n                    BalancerConstants.MAX_OUT_RATIO\r\n                ),\r\n            \"ERR_MAX_OUT_RATIO\"\r\n        );\r\n\r\n        exitFee = BalancerSafeMath.bmul(\r\n            poolAmountIn,\r\n            BalancerConstants.EXIT_FEE\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\r\n     *         Asset must be present in the pool\r\n     * @param self - ConfigurableRightsPool instance calling the library\r\n     * @param bPool - Core BPool the CRP is wrapping\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\r\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\r\n     * @return exitFee - calculated exit fee\r\n     * @return poolAmountIn - amount of pool tokens redeemed\r\n     */\r\n    function exitswapExternAmountOut(\r\n        IConfigurableRightsPool self,\r\n        IBPool bPool,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external view returns (uint256 exitFee, uint256 poolAmountIn) {\r\n        require(bPool.isBound(tokenOut), \"ERR_NOT_BOUND\");\r\n        require(\r\n            tokenAmountOut <=\r\n                BalancerSafeMath.bmul(\r\n                    bPool.getBalance(tokenOut),\r\n                    BalancerConstants.MAX_OUT_RATIO\r\n                ),\r\n            \"ERR_MAX_OUT_RATIO\"\r\n        );\r\n        poolAmountIn = bPool.calcPoolInGivenSingleOut(\r\n            bPool.getBalance(tokenOut),\r\n            bPool.getDenormalizedWeight(tokenOut),\r\n            self.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            tokenAmountOut,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        require(poolAmountIn != 0, \"ERR_MATH_APPROX\");\r\n        require(poolAmountIn <= maxPoolAmountIn, \"ERR_LIMIT_IN\");\r\n\r\n        exitFee = BalancerSafeMath.bmul(\r\n            poolAmountIn,\r\n            BalancerConstants.EXIT_FEE\r\n        );\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    // Check for zero transfer, and make sure it returns true to returnValue\r\n    function verifyTokenComplianceInternal(address token) internal {\r\n        bool returnValue = IERC20(token).transfer(msg.sender, 0);\r\n        require(returnValue, \"ERR_NONCONFORMING_TOKEN\");\r\n    }\r\n}\r\n\r\n// Interfaces\r\n\r\n// Libraries\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Smart Pool with customizable features\r\n * @notice PCToken is the \"Balancer Smart Pool\" token (transferred upon finalization)\r\n * @dev Rights are defined as follows (index values into the array)\r\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                            by default, it is off on initialization and can only be turned on\r\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      4: canWhitelistLPs - can restrict LPs to a whitelist\r\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\r\n *\r\n * Note that functions called on bPool and bFactory may look like internal calls,\r\n *   but since they are contracts accessed through an interface, they are really external.\r\n * To make this explicit, we could write \"IBPool(address(bPool)).function()\" everywhere,\r\n *   instead of \"bPool.function()\".\r\n */\r\ncontract ConfigurableRightsPool is\r\n    PCToken,\r\n    BalancerOwnable,\r\n    BalancerReentrancyGuard\r\n{\r\n    using BalancerSafeMath for uint256;\r\n    using SafeApprove for IERC20;\r\n\r\n    // Type declarations\r\n\r\n    struct PoolParams {\r\n        // Balancer Pool Token (representing shares of the pool)\r\n        string poolTokenSymbol;\r\n        string poolTokenName;\r\n        // Tokens inside the Pool\r\n        address[] constituentTokens;\r\n        uint256[] tokenBalances;\r\n        uint256[] tokenWeights;\r\n        uint256 swapFee;\r\n    }\r\n\r\n    // State variables\r\n\r\n    IBFactory public bFactory;\r\n    IBPool public bPool;\r\n\r\n    // Struct holding the rights configuration\r\n    RightsManager.Rights public rights;\r\n\r\n    // Hold the parameters used in updateWeightsGradually\r\n    SmartPoolManager.GradualUpdateParams public gradualUpdate;\r\n\r\n    // This is for adding a new (currently unbound) token to the pool\r\n    // It's a two-step process: commitAddToken(), then applyAddToken()\r\n    SmartPoolManager.NewTokenParams public newToken;\r\n\r\n    // Fee is initialized on creation, and can be changed if permission is set\r\n    // Only needed for temporary storage between construction and createPool\r\n    // Thereafter, the swap fee should always be read from the underlying pool\r\n    uint256 private _initialSwapFee;\r\n\r\n    // Store the list of tokens in the pool, and balances\r\n    // NOTE that the token list is *only* used to store the pool tokens between\r\n    //   construction and createPool - thereafter, use the underlying BPool's list\r\n    //   (avoids synchronization issues)\r\n    address[] private _initialTokens;\r\n    uint256[] private _initialBalances;\r\n\r\n    // Enforce a minimum time between the start and end blocks\r\n    uint256 public minimumWeightChangeBlockPeriod;\r\n    // Enforce a mandatory wait time between updates\r\n    // This is also the wait time between committing and applying a new token\r\n    uint256 public addTokenTimeLockInBlocks;\r\n\r\n    // Whitelist of LPs (if configured)\r\n    mapping(address => bool) private _liquidityProviderWhitelist;\r\n\r\n    // Cap on the pool size (i.e., # of tokens minted when joining)\r\n    // Limits the risk of experimental pools; failsafe/backup for fixed-size pools\r\n    uint256 public bspCap;\r\n\r\n    // Event declarations\r\n\r\n    // Anonymous logger event - can only be filtered by contract address\r\n\r\n    event LogCall(bytes4 indexed sig, address indexed caller, bytes data);\r\n\r\n    event LogJoin(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256 tokenAmountIn\r\n    );\r\n\r\n    event LogExit(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256 tokenAmountOut\r\n    );\r\n\r\n    event CapChanged(address indexed caller, uint256 oldCap, uint256 newCap);\r\n\r\n    event NewTokenCommitted(\r\n        address indexed token,\r\n        address indexed pool,\r\n        address indexed caller\r\n    );\r\n\r\n    // Modifiers\r\n\r\n    modifier logs() {\r\n        emit LogCall(msg.sig, msg.sender, msg.data);\r\n        _;\r\n    }\r\n\r\n    // Mark functions that require delegation to the underlying Pool\r\n    modifier needsBPool() {\r\n        require(address(bPool) != address(0), \"ERR_NOT_CREATED\");\r\n        _;\r\n    }\r\n\r\n    modifier lockUnderlyingPool() {\r\n        // Turn off swapping on the underlying pool during joins\r\n        // Otherwise tokens with callbacks would enable attacks involving simultaneous swaps and joins\r\n        bool origSwapState = bPool.isPublicSwap();\r\n        bPool.setPublicSwap(false);\r\n        _;\r\n        bPool.setPublicSwap(origSwapState);\r\n    }\r\n\r\n    // Default values for these variables (used only in updateWeightsGradually), set in the constructor\r\n    // Pools without permission to update weights cannot use them anyway, and should call\r\n    //   the default createPool() function.\r\n    // To override these defaults, pass them into the overloaded createPool()\r\n    // Period is in blocks; 500 blocks ~ 2 hours; 90,000 blocks ~ 2 weeks\r\n    uint256 public constant DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD = 90000;\r\n    uint256 public constant DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS = 500;\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Construct a new Configurable Rights Pool (wrapper around BPool)\r\n     * @dev _initialTokens and _swapFee are only used for temporary storage between construction\r\n     *      and create pool, and should not be used thereafter! _initialTokens is destroyed in\r\n     *      createPool to prevent this, and _swapFee is kept in sync (defensively), but\r\n     *      should never be used except in this constructor and createPool()\r\n     * @param factoryAddress - the BPoolFactory used to create the underlying pool\r\n     * @param poolParams - struct containing pool parameters\r\n     * @param rightsStruct - Set of permissions we are assigning to this smart pool\r\n     */\r\n    constructor(\r\n        address factoryAddress,\r\n        PoolParams memory poolParams,\r\n        RightsManager.Rights memory rightsStruct\r\n    ) public PCToken(poolParams.poolTokenSymbol, poolParams.poolTokenName) {\r\n        // We don't have a pool yet; check now or it will fail later (in order of likelihood to fail)\r\n        // (and be unrecoverable if they don't have permission set to change it)\r\n        // Most likely to fail, so check first\r\n        require(\r\n            poolParams.swapFee >= BalancerConstants.MIN_FEE,\r\n            \"ERR_INVALID_SWAP_FEE\"\r\n        );\r\n        require(\r\n            poolParams.swapFee <= BalancerConstants.MAX_FEE,\r\n            \"ERR_INVALID_SWAP_FEE\"\r\n        );\r\n\r\n        // Arrays must be parallel\r\n        require(\r\n            poolParams.tokenBalances.length ==\r\n                poolParams.constituentTokens.length,\r\n            \"ERR_START_BALANCES_MISMATCH\"\r\n        );\r\n        require(\r\n            poolParams.tokenWeights.length ==\r\n                poolParams.constituentTokens.length,\r\n            \"ERR_START_WEIGHTS_MISMATCH\"\r\n        );\r\n        // Cannot have too many or too few - technically redundant, since BPool.bind() would fail later\r\n        // But if we don't check now, we could have a useless contract with no way to create a pool\r\n\r\n        require(\r\n            poolParams.constituentTokens.length >=\r\n                BalancerConstants.MIN_ASSET_LIMIT,\r\n            \"ERR_TOO_FEW_TOKENS\"\r\n        );\r\n        require(\r\n            poolParams.constituentTokens.length <=\r\n                BalancerConstants.MAX_ASSET_LIMIT,\r\n            \"ERR_TOO_MANY_TOKENS\"\r\n        );\r\n        // There are further possible checks (e.g., if they use the same token twice), but\r\n        // we can let bind() catch things like that (i.e., not things that might reasonably work)\r\n\r\n        SmartPoolManager.verifyTokenCompliance(poolParams.constituentTokens);\r\n\r\n        bFactory = IBFactory(factoryAddress);\r\n        rights = rightsStruct;\r\n        _initialTokens = poolParams.constituentTokens;\r\n        _initialBalances = poolParams.tokenBalances;\r\n        _initialSwapFee = poolParams.swapFee;\r\n\r\n        // These default block time parameters can be overridden in createPool\r\n        minimumWeightChangeBlockPeriod = DEFAULT_MIN_WEIGHT_CHANGE_BLOCK_PERIOD;\r\n        addTokenTimeLockInBlocks = DEFAULT_ADD_TOKEN_TIME_LOCK_IN_BLOCKS;\r\n\r\n        gradualUpdate.startWeights = poolParams.tokenWeights;\r\n        // Initializing (unnecessarily) for documentation - 0 means no gradual weight change has been initiated\r\n        gradualUpdate.startBlock = 0;\r\n        // By default, there is no cap (unlimited pool token minting)\r\n        bspCap = BalancerConstants.MAX_UINT;\r\n    }\r\n\r\n    // External functions\r\n\r\n    /**\r\n     * @notice Set the swap fee on the underlying pool\r\n     * @dev Keep the local version and core in sync (see below)\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param swapFee in Wei\r\n     */\r\n    function setSwapFee(uint256 swapFee)\r\n        external\r\n        virtual\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n    {\r\n        require(rights.canChangeSwapFee, \"ERR_NOT_CONFIGURABLE_SWAP_FEE\");\r\n\r\n        // Underlying pool will check against min/max fee\r\n        bPool.setSwapFee(swapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the publicSwap field on the underlying pool\r\n     * @dev viewLock, because setPublicSwap is lock\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @return Current value of isPublicSwap\r\n     */\r\n    function isPublicSwap()\r\n        external\r\n        virtual\r\n        view\r\n        viewlock\r\n        needsBPool\r\n        returns (bool)\r\n    {\r\n        return bPool.isPublicSwap();\r\n    }\r\n\r\n    /**\r\n     * @notice Set the cap (max # of pool tokens)\r\n     * @dev _bspCap defaults in the constructor to unlimited\r\n     *      Can set to 0 (or anywhere below the current supply), to halt new investment\r\n     *      Prevent setting it before creating a pool, since createPool sets to intialSupply\r\n     *      (it does this to avoid an unlimited cap window between construction and createPool)\r\n     *      Therefore setting it before then has no effect, so should not be allowed\r\n     * @param newCap - new value of the cap\r\n     */\r\n    function setCap(uint256 newCap) external logs lock needsBPool onlyOwner {\r\n        require(rights.canChangeCap, \"ERR_CANNOT_CHANGE_CAP\");\r\n\r\n        emit CapChanged(msg.sender, bspCap, newCap);\r\n\r\n        bspCap = newCap;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the public swap flag on the underlying pool\r\n     * @dev If this smart pool has canPauseSwapping enabled, we can turn publicSwap off if it's already on\r\n     *      Note that if they turn swapping off - but then finalize the pool - finalizing will turn the\r\n     *      swapping back on. They're not supposed to finalize the underlying pool... would defeat the\r\n     *      smart pool functions. (Only the owner can finalize the pool - which is this contract -\r\n     *      so there is no risk from outside.)\r\n     *\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param publicSwap new value of the swap\r\n     */\r\n    function setPublicSwap(bool publicSwap)\r\n        external\r\n        virtual\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n    {\r\n        require(rights.canPauseSwapping, \"ERR_NOT_PAUSABLE_SWAP\");\r\n\r\n        bPool.setPublicSwap(publicSwap);\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool - and set the block period time parameters\r\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\r\n     *      Can be changed if the canChangeSwapFee permission is enabled\r\n     *      Time parameters will be fixed at these values\r\n     *\r\n     *      If this contract doesn't have canChangeWeights permission - or you want to use the default\r\n     *      values, the block time arguments are not needed, and you can just call the single-argument\r\n     *      createPool()\r\n     * @param initialSupply - Starting token balance\r\n     * @param minimumWeightChangeBlockPeriodParam - Enforce a minimum time between the start and end blocks\r\n     * @param addTokenTimeLockInBlocksParam - Enforce a mandatory wait time between updates\r\n     *                                   This is also the wait time between committing and applying a new token\r\n     */\r\n    function createPool(\r\n        uint256 initialSupply,\r\n        uint256 minimumWeightChangeBlockPeriodParam,\r\n        uint256 addTokenTimeLockInBlocksParam\r\n    ) external virtual onlyOwner logs lock {\r\n        require(\r\n            minimumWeightChangeBlockPeriodParam >=\r\n                addTokenTimeLockInBlocksParam,\r\n            \"ERR_INCONSISTENT_TOKEN_TIME_LOCK\"\r\n        );\r\n\r\n        minimumWeightChangeBlockPeriod = minimumWeightChangeBlockPeriodParam;\r\n        addTokenTimeLockInBlocks = addTokenTimeLockInBlocksParam;\r\n\r\n        createPoolInternal(initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool\r\n     * @dev Delegates to internal function\r\n     * @param initialSupply starting token balance\r\n     */\r\n    function createPool(uint256 initialSupply)\r\n        external\r\n        virtual\r\n        onlyOwner\r\n        logs\r\n        lock\r\n    {\r\n        createPoolInternal(initialSupply);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the weight of an existing token\r\n     * @dev Notice Balance is not an input (like with rebind on BPool) since we will require prices not to change\r\n     *      This is achieved by forcing balances to change proportionally to weights, so that prices don't change\r\n     *      If prices could be changed, this would allow the controller to drain the pool by arbing price changes\r\n     * @param token - token to be reweighted\r\n     * @param newWeight - new weight of the token\r\n     */\r\n    function updateWeight(address token, uint256 newWeight)\r\n        external\r\n        virtual\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n    {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n        // We don't want people to set weights manually if there's a block-based update in progress\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.updateWeight(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            token,\r\n            newWeight\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Update weights in a predetermined way, between startBlock and endBlock,\r\n     *         through external calls to pokeWeights\r\n     * @dev Must call pokeWeights at least once past the end for it to do the final update\r\n     *      and enable calling this again.\r\n     *      It is possible to call updateWeightsGradually during an update in some use cases\r\n     *      For instance, setting newWeights to currentWeights to stop the update where it is\r\n     * @param newWeights - final weights we want to get to. Note that the ORDER (and number) of\r\n     *                     tokens can change if you have added or removed tokens from the pool\r\n     *                     It ensures the counts are correct, but can't help you with the order!\r\n     *                     You can get the underlying BPool (it's public), and call\r\n     *                     getCurrentTokens() to see the current ordering, if you're not sure\r\n     * @param startBlock - when weights should start to change\r\n     * @param endBlock - when weights will be at their final values\r\n     */\r\n    function updateWeightsGradually(\r\n        uint256[] calldata newWeights,\r\n        uint256 startBlock,\r\n        uint256 endBlock\r\n    ) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n        // Don't start this when we're in the middle of adding a new token\r\n        require(!newToken.isCommitted, \"ERR_PENDING_TOKEN_ADD\");\r\n\r\n        // Library computes the startBlock, computes startWeights as the current\r\n        // denormalized weights of the core pool tokens.\r\n        SmartPoolManager.updateWeightsGradually(\r\n            bPool,\r\n            gradualUpdate,\r\n            newWeights,\r\n            startBlock,\r\n            endBlock,\r\n            minimumWeightChangeBlockPeriod\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice External function called to make the contract update weights according to plan\r\n     * @dev Still works if we poke after the end of the period; also works if the weights don't change\r\n     *      Resets if we are poking beyond the end, so that we can do it again\r\n     */\r\n    function pokeWeights() external virtual logs lock needsBPool {\r\n        require(rights.canChangeWeights, \"ERR_NOT_CONFIGURABLE_WEIGHTS\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.pokeWeights(bPool, gradualUpdate);\r\n    }\r\n\r\n    /**\r\n     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\r\n     *         number of blocks to actually add the token\r\n     *\r\n     * @dev The purpose of this two-stage commit is to give warning of a potentially dangerous\r\n     *      operation. A malicious pool operator could add a large amount of a low-value token,\r\n     *      then drain the pool through price manipulation. Of course, there are many\r\n     *      legitimate purposes, such as adding additional collateral tokens.\r\n     *\r\n     * @param token - the token to be added\r\n     * @param balance - how much to be added\r\n     * @param denormalizedWeight - the desired token weight\r\n     */\r\n    function commitAddToken(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denormalizedWeight\r\n    ) external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n\r\n        // Can't do this while a progressive update is happening\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        SmartPoolManager.verifyTokenCompliance(token);\r\n\r\n        emit NewTokenCommitted(token, address(this), msg.sender);\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.commitAddToken(\r\n            bPool,\r\n            token,\r\n            balance,\r\n            denormalizedWeight,\r\n            newToken\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Add the token previously committed (in commitAddToken) to the pool\r\n     */\r\n    function applyAddToken() external virtual logs lock onlyOwner needsBPool {\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.applyAddToken(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            addTokenTimeLockInBlocks,\r\n            newToken\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove a token from the pool\r\n     * @dev bPool is a contract interface; function calls on it are external\r\n     * @param token - token to remove\r\n     */\r\n    function removeToken(address token)\r\n        external\r\n        logs\r\n        lock\r\n        onlyOwner\r\n        needsBPool\r\n    {\r\n        // It's possible to have remove rights without having add rights\r\n        require(rights.canAddRemoveTokens, \"ERR_CANNOT_ADD_REMOVE_TOKENS\");\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        require(!newToken.isCommitted, \"ERR_REMOVE_WITH_ADD_PENDING\");\r\n        // Prevent removing during an update (or token lists can get out of sync)\r\n        require(gradualUpdate.startBlock == 0, \"ERR_NO_UPDATE_DURING_GRADUAL\");\r\n\r\n        // Delegate to library to save space\r\n        SmartPoolManager.removeToken(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            token\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Join a pool\r\n     * @dev Emits a LogJoin event (for each token)\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param poolAmountOut - number of pool tokens to receive\r\n     * @param maxAmountsIn - Max amount of asset tokens to spend\r\n     */\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        lockUnderlyingPool\r\n    {\r\n        require(\r\n            !rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender],\r\n            \"ERR_NOT_ON_WHITELIST\"\r\n        );\r\n\r\n        // Delegate to library to save space\r\n\r\n        // Library computes actualAmountsIn, and does many validations\r\n        // Cannot call the push/pull/min from an external library for\r\n        // any of these pool functions. Since msg.sender can be anybody,\r\n        // they must be internal\r\n        uint256[] memory actualAmountsIn = SmartPoolManager.joinPool(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            poolAmountOut,\r\n            maxAmountsIn\r\n        );\r\n\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        address[] memory poolTokens = bPool.getCurrentTokens();\r\n\r\n        for (uint256 i = 0; i < poolTokens.length; i++) {\r\n            address t = poolTokens[i];\r\n            uint256 tokenAmountIn = actualAmountsIn[i];\r\n\r\n            emit LogJoin(msg.sender, t, tokenAmountIn);\r\n\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n        }\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for underlying assets\r\n     * @dev Emits a LogExit event for each token\r\n     *      bPool is a contract interface; function calls on it are external\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountsOut - minimum amount of asset tokens to receive\r\n     */\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n        external\r\n        logs\r\n        lock\r\n        needsBPool\r\n        lockUnderlyingPool\r\n    {\r\n        // Delegate to library to save space\r\n\r\n        // Library computes actualAmountsOut, and does many validations\r\n        // Also computes the exitFee and pAiAfterExitFee\r\n        (\r\n            uint256 exitFee,\r\n            uint256 pAiAfterExitFee,\r\n            uint256[] memory actualAmountsOut\r\n        ) = SmartPoolManager.exitPool(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            poolAmountIn,\r\n            minAmountsOut\r\n        );\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        // After createPool, token list is maintained in the underlying BPool\r\n        address[] memory poolTokens = bPool.getCurrentTokens();\r\n\r\n        for (uint256 i = 0; i < poolTokens.length; i++) {\r\n            address t = poolTokens[i];\r\n            uint256 tokenAmountOut = actualAmountsOut[i];\r\n\r\n            emit LogExit(msg.sender, t, tokenAmountOut);\r\n\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\r\n     *         System calculates the pool token amount\r\n     * @dev emits a LogJoin event\r\n     * @param tokenIn - which token we're transferring in\r\n     * @param tokenAmountIn - amount of deposit\r\n     * @param minPoolAmountOut - minimum of pool tokens to receive\r\n     * @return poolAmountOut - amount of pool tokens minted and transferred\r\n     */\r\n    function joinswapExternAmountIn(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 minPoolAmountOut\r\n    ) external logs lock needsBPool returns (uint256 poolAmountOut) {\r\n        require(\r\n            !rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender],\r\n            \"ERR_NOT_ON_WHITELIST\"\r\n        );\r\n\r\n        // Delegate to library to save space\r\n        poolAmountOut = SmartPoolManager.joinswapExternAmountIn(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenIn,\r\n            tokenAmountIn,\r\n            minPoolAmountOut\r\n        );\r\n\r\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Join by swapping an external token in (must be present in the pool)\r\n     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\r\n     * @dev emits a LogJoin event\r\n     * @param tokenIn - which token we're transferring in (system calculates amount required)\r\n     * @param poolAmountOut - amount of pool tokens to be received\r\n     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\r\n     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\r\n     */\r\n    function joinswapPoolAmountOut(\r\n        address tokenIn,\r\n        uint256 poolAmountOut,\r\n        uint256 maxAmountIn\r\n    ) external logs lock needsBPool returns (uint256 tokenAmountIn) {\r\n        require(\r\n            !rights.canWhitelistLPs || _liquidityProviderWhitelist[msg.sender],\r\n            \"ERR_NOT_ON_WHITELIST\"\r\n        );\r\n\r\n        // Delegate to library to save space\r\n        tokenAmountIn = SmartPoolManager.joinswapPoolAmountOut(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenIn,\r\n            poolAmountOut,\r\n            maxAmountIn\r\n        );\r\n\r\n        emit LogJoin(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\r\n     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\r\n     * @dev Emits a LogExit event for the token\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param poolAmountIn - amount of pool tokens to redeem\r\n     * @param minAmountOut - minimum asset tokens to receive\r\n     * @return tokenAmountOut - amount of asset tokens returned\r\n     */\r\n    function exitswapPoolAmountIn(\r\n        address tokenOut,\r\n        uint256 poolAmountIn,\r\n        uint256 minAmountOut\r\n    ) external logs lock needsBPool returns (uint256 tokenAmountOut) {\r\n        // Delegate to library to save space\r\n\r\n        // Calculates final amountOut, and the fee and final amount in\r\n        (uint256 exitFee, uint256 amountOut) = SmartPoolManager\r\n            .exitswapPoolAmountIn(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenOut,\r\n            poolAmountIn,\r\n            minAmountOut\r\n        );\r\n\r\n        tokenAmountOut = amountOut;\r\n        uint256 pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\r\n     *         Asset must be present in the pool\r\n     * @dev Emits a LogExit event for the token\r\n     * @param tokenOut - which token the caller wants to receive\r\n     * @param tokenAmountOut - amount of underlying asset tokens to receive\r\n     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\r\n     * @return poolAmountIn - amount of pool tokens redeemed\r\n     */\r\n    function exitswapExternAmountOut(\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPoolAmountIn\r\n    ) external logs lock needsBPool returns (uint256 poolAmountIn) {\r\n        // Delegate to library to save space\r\n\r\n        // Calculates final amounts in, accounting for the exit fee\r\n        (uint256 exitFee, uint256 amountIn) = SmartPoolManager\r\n            .exitswapExternAmountOut(\r\n            IConfigurableRightsPool(address(this)),\r\n            bPool,\r\n            tokenOut,\r\n            tokenAmountOut,\r\n            maxPoolAmountIn\r\n        );\r\n\r\n        poolAmountIn = amountIn;\r\n        uint256 pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\r\n\r\n        emit LogExit(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n        _pushPoolShare(address(bFactory), exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return poolAmountIn;\r\n    }\r\n\r\n    /**\r\n     * @notice Add to the whitelist of liquidity providers (if enabled)\r\n     * @param provider - address of the liquidity provider\r\n     */\r\n    function whitelistLiquidityProvider(address provider)\r\n        external\r\n        onlyOwner\r\n        lock\r\n        logs\r\n    {\r\n        require(rights.canWhitelistLPs, \"ERR_CANNOT_WHITELIST_LPS\");\r\n        require(provider != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n        _liquidityProviderWhitelist[provider] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove from the whitelist of liquidity providers (if enabled)\r\n     * @param provider - address of the liquidity provider\r\n     */\r\n    function removeWhitelistedLiquidityProvider(address provider)\r\n        external\r\n        onlyOwner\r\n        lock\r\n        logs\r\n    {\r\n        require(rights.canWhitelistLPs, \"ERR_CANNOT_WHITELIST_LPS\");\r\n        require(\r\n            _liquidityProviderWhitelist[provider],\r\n            \"ERR_LP_NOT_WHITELISTED\"\r\n        );\r\n        require(provider != address(0), \"ERR_INVALID_ADDRESS\");\r\n\r\n        _liquidityProviderWhitelist[provider] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a liquidity provider\r\n     * @dev If the whitelist feature is not enabled, anyone can provide liquidity (assuming finalized)\r\n     * @return boolean value indicating whether the address can join a pool\r\n     */\r\n    function canProvideLiquidity(address provider)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (rights.canWhitelistLPs) {\r\n            return _liquidityProviderWhitelist[provider];\r\n        } else {\r\n            // Probably don't strictly need this (could just return true)\r\n            // But the null address can't provide funds\r\n            return provider != address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for specific permissions\r\n     * @dev value of the enum is just the 0-based index in the enumeration\r\n     *      For instance canPauseSwapping is 0; canChangeWeights is 2\r\n     * @return token boolean true if we have the given permission\r\n     */\r\n    function hasPermission(RightsManager.Permissions permission)\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool)\r\n    {\r\n        return RightsManager.hasPermission(rights, permission);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the denormalized weight of a token\r\n     * @dev viewlock to prevent calling if it's being updated\r\n     * @return token weight\r\n     */\r\n    function getDenormalizedWeight(address token)\r\n        external\r\n        view\r\n        viewlock\r\n        needsBPool\r\n        returns (uint256)\r\n    {\r\n        return bPool.getDenormalizedWeight(token);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the RightsManager contract\r\n     * @dev Convenience function to get the address of the RightsManager library (so clients can check version)\r\n     * @return address of the RightsManager library\r\n     */\r\n    function getRightsManagerVersion() external pure returns (address) {\r\n        return address(RightsManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the BalancerSafeMath contract\r\n     * @dev Convenience function to get the address of the BalancerSafeMath library (so clients can check version)\r\n     * @return address of the BalancerSafeMath library\r\n     */\r\n    function getBalancerSafeMathVersion() external pure returns (address) {\r\n        return address(BalancerSafeMath);\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the SmartPoolManager contract\r\n     * @dev Convenience function to get the address of the SmartPoolManager library (so clients can check version)\r\n     * @return address of the SmartPoolManager library\r\n     */\r\n    function getSmartPoolManagerVersion() external pure returns (address) {\r\n        return address(SmartPoolManager);\r\n    }\r\n\r\n    // Public functions\r\n\r\n    // \"Public\" versions that can safely be called from SmartPoolManager\r\n    // Allows only the contract itself to call them (not the controller or any external account)\r\n\r\n    function mintPoolShareFromLib(uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _mint(amount);\r\n    }\r\n\r\n    function pushPoolShareFromLib(address to, uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _push(to, amount);\r\n    }\r\n\r\n    function pullPoolShareFromLib(address from, uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function burnPoolShareFromLib(uint256 amount) public {\r\n        require(msg.sender == address(this), \"ERR_NOT_CONTROLLER\");\r\n\r\n        _burn(amount);\r\n    }\r\n\r\n    // Internal functions\r\n\r\n    // Lint wants the function to have a leading underscore too\r\n    /* solhint-disable private-vars-leading-underscore */\r\n\r\n    /**\r\n     * @notice Create a new Smart Pool\r\n     * @dev Initialize the swap fee to the value provided in the CRP constructor\r\n     *      Can be changed if the canChangeSwapFee permission is enabled\r\n     * @param initialSupply starting token balance\r\n     */\r\n    function createPoolInternal(uint256 initialSupply) internal {\r\n        require(address(bPool) == address(0), \"ERR_IS_CREATED\");\r\n        require(\r\n            initialSupply >= BalancerConstants.MIN_POOL_SUPPLY,\r\n            \"ERR_INIT_SUPPLY_MIN\"\r\n        );\r\n        require(\r\n            initialSupply <= BalancerConstants.MAX_POOL_SUPPLY,\r\n            \"ERR_INIT_SUPPLY_MAX\"\r\n        );\r\n\r\n        // If the controller can change the cap, initialize it to the initial supply\r\n        // Defensive programming, so that there is no gap between creating the pool\r\n        // (initialized to unlimited in the constructor), and setting the cap,\r\n        // which they will presumably do if they have this right.\r\n        if (rights.canChangeCap) {\r\n            bspCap = initialSupply;\r\n        }\r\n\r\n        // There is technically reentrancy here, since we're making external calls and\r\n        // then transferring tokens. However, the external calls are all to the underlying BPool\r\n\r\n        // To the extent possible, modify state variables before calling functions\r\n        _mintPoolShare(initialSupply);\r\n        _pushPoolShare(msg.sender, initialSupply);\r\n\r\n        // Deploy new BPool (bFactory and bPool are interfaces; all calls are external)\r\n        bPool = bFactory.newBPool();\r\n\r\n        // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\r\n        require(bPool.EXIT_FEE() == 0, \"ERR_NONZERO_EXIT_FEE\");\r\n        require(BalancerConstants.EXIT_FEE == 0, \"ERR_NONZERO_EXIT_FEE\");\r\n\r\n        for (uint256 i = 0; i < _initialTokens.length; i++) {\r\n            address t = _initialTokens[i];\r\n            uint256 bal = _initialBalances[i];\r\n            uint256 denorm = gradualUpdate.startWeights[i];\r\n\r\n            bool returnValue = IERC20(t).transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                bal\r\n            );\r\n            require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n            returnValue = IERC20(t).safeApprove(\r\n                address(bPool),\r\n                BalancerConstants.MAX_UINT\r\n            );\r\n            require(returnValue, \"ERR_ERC20_FALSE\");\r\n\r\n            bPool.bind(t, bal, denorm);\r\n        }\r\n\r\n        while (_initialTokens.length > 0) {\r\n            // Modifying state variable after external calls here,\r\n            // but not essential, so not dangerous\r\n            _initialTokens.pop();\r\n        }\r\n\r\n        // Set fee to the initial value set in the constructor\r\n        // Hereafter, read the swapFee from the underlying pool, not the local state variable\r\n        bPool.setSwapFee(_initialSwapFee);\r\n        bPool.setPublicSwap(true);\r\n\r\n        // \"destroy\" the temporary swap fee (like _initialTokens above) in case a subclass tries to use it\r\n        _initialSwapFee = 0;\r\n    }\r\n\r\n    /* solhint-enable private-vars-leading-underscore */\r\n\r\n    // Rebind BPool and pull tokens from address\r\n    // bPool is a contract interface; function calls on it are external\r\n    function _pullUnderlying(\r\n        address erc20,\r\n        address from,\r\n        uint256 amount\r\n    ) internal needsBPool {\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint256 tokenBalance = bPool.getBalance(erc20);\r\n        uint256 tokenWeight = bPool.getDenormalizedWeight(erc20);\r\n\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n        bPool.rebind(\r\n            erc20,\r\n            BalancerSafeMath.badd(tokenBalance, amount),\r\n            tokenWeight\r\n        );\r\n    }\r\n\r\n    // Rebind BPool and push tokens to address\r\n    // bPool is a contract interface; function calls on it are external\r\n    function _pushUnderlying(\r\n        address erc20,\r\n        address to,\r\n        uint256 amount\r\n    ) internal needsBPool {\r\n        // Gets current Balance of token i, Bi, and weight of token i, Wi, from BPool.\r\n        uint256 tokenBalance = bPool.getBalance(erc20);\r\n        uint256 tokenWeight = bPool.getDenormalizedWeight(erc20);\r\n        bPool.rebind(\r\n            erc20,\r\n            BalancerSafeMath.bsub(tokenBalance, amount),\r\n            tokenWeight\r\n        );\r\n\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }\r\n\r\n    // Wrappers around corresponding core functions\r\n\r\n    //\r\n    function _mint(uint256 amount) internal override {\r\n        super._mint(amount);\r\n        require(varTotalSupply <= bspCap, \"ERR_CAP_LIMIT_REACHED\");\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount) internal {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint256 amount) internal {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint256 amount) internal {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint256 amount) internal {\r\n        _burn(amount);\r\n    }\r\n}\r\n\r\n// Imports\r\n\r\n// Contracts\r\n\r\n/**\r\n * @author Balancer Labs\r\n * @title Configurable Rights Pool Factory - create parameterized smart pools\r\n * @dev Rights are held in a corresponding struct in ConfigurableRightsPool\r\n *      Index values are as follows:\r\n *      0: canPauseSwapping - can setPublicSwap back to false after turning it on\r\n *                            by default, it is off on initialization and can only be turned on\r\n *      1: canChangeSwapFee - can setSwapFee after initialization (by default, it is fixed at create time)\r\n *      2: canChangeWeights - can bind new token weights (allowed by default in base pool)\r\n *      3: canAddRemoveTokens - can bind/unbind tokens (allowed by default in base pool)\r\n *      4: canWhitelistLPs - if set, only whitelisted addresses can join pools\r\n *                           (enables private pools with more than one LP)\r\n *      5: canChangeCap - can change the BSP cap (max # of pool tokens)\r\n */\r\ncontract CRPFactory {\r\n    // State variables\r\n\r\n    // Keep a list of all Configurable Rights Pools\r\n    mapping(address => bool) private _isCrp;\r\n\r\n    // Event declarations\r\n\r\n    // Log the address of each new smart pool, and its creator\r\n    event LogNewCrp(address indexed caller, address indexed pool);\r\n\r\n    // Function declarations\r\n\r\n    /**\r\n     * @notice Create a new CRP\r\n     * @dev emits a LogNewCRP event\r\n     * @param factoryAddress - the BFactory instance used to create the underlying pool\r\n     * @param poolParams - struct containing the names, tokens, weights, balances, and swap fee\r\n     * @param rights - struct of permissions, configuring this CRP instance (see above for definitions)\r\n     */\r\n    function newCrp(\r\n        address factoryAddress,\r\n        ConfigurableRightsPool.PoolParams calldata poolParams,\r\n        RightsManager.Rights calldata rights\r\n    ) external returns (ConfigurableRightsPool) {\r\n        require(\r\n            poolParams.constituentTokens.length >=\r\n                BalancerConstants.MIN_ASSET_LIMIT,\r\n            \"ERR_TOO_FEW_TOKENS\"\r\n        );\r\n\r\n        // Arrays must be parallel\r\n        require(\r\n            poolParams.tokenBalances.length ==\r\n                poolParams.constituentTokens.length,\r\n            \"ERR_START_BALANCES_MISMATCH\"\r\n        );\r\n        require(\r\n            poolParams.tokenWeights.length ==\r\n                poolParams.constituentTokens.length,\r\n            \"ERR_START_WEIGHTS_MISMATCH\"\r\n        );\r\n\r\n        ConfigurableRightsPool crp = new ConfigurableRightsPool(\r\n            factoryAddress,\r\n            poolParams,\r\n            rights\r\n        );\r\n\r\n        emit LogNewCrp(msg.sender, address(crp));\r\n\r\n        _isCrp[address(crp)] = true;\r\n        // The caller is the controller of the CRP\r\n        // The CRP will be the controller of the underlying Core BPool\r\n        crp.setController(msg.sender);\r\n\r\n        return crp;\r\n    }\r\n\r\n    /**\r\n     * @notice Check to see if a given address is a CRP\r\n     * @param addr - address to check\r\n     * @return boolean indicating whether it is a CRP\r\n     */\r\n    function isCrp(address addr) external view returns (bool) {\r\n        return _isCrp[addr];\r\n    }\r\n}\r\n\r\ncontract ZuniTreasury is Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    ConfigurableRightsPool public crp;\r\n\r\n    IERC20 public zuni;\r\n    IBPool public bPool;\r\n\r\n    address public zuniBadge;\r\n\r\n    uint256 public constant MAX_VAL = 2**256 - 1;\r\n    uint256 public constant WEI_POINT = 10**18;\r\n    uint256 public constant DEFAULT_ISSURANCE_AMOUNT = WEI_POINT * 100;\r\n\r\n    constructor(IERC20 _zuni) public {\r\n        zuni = _zuni;\r\n    }\r\n\r\n    modifier onlyZuniBadge() {\r\n        require(msg.sender == zuniBadge, \"ZuinTreasury: should be badge sc\");\r\n        _;\r\n    }\r\n\r\n    function smartPoolAddress() external view returns (address) {\r\n        return address(crp);\r\n    }\r\n\r\n    function setZuniBadge(address _zuniBadge) external onlyOwner {\r\n        zuniBadge = _zuniBadge;\r\n    }\r\n\r\n    function setCRP(address _crpAddress) external onlyOwner {\r\n        // require(address(crp) == address(0x0));\r\n\r\n        crp = ConfigurableRightsPool(_crpAddress);\r\n        bPool = IBPool(crp.bPool());\r\n    }\r\n\r\n    function setZuniToken(IERC20 _zuni) external onlyOwner {\r\n        zuni = _zuni;\r\n    }\r\n\r\n    function _issue(uint256 tokenAmountOut) internal {\r\n        uint256 maxPoolAmountIn = bPool.calcPoolInGivenSingleOut(\r\n            bPool.getBalance(address(zuni)),\r\n            bPool.getDenormalizedWeight(address(zuni)),\r\n            crp.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            tokenAmountOut,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        maxPoolAmountIn = maxPoolAmountIn.mul(101).div(100);\r\n\r\n        crp.exitswapExternAmountOut(\r\n            address(zuni),\r\n            tokenAmountOut,\r\n            maxPoolAmountIn\r\n        );\r\n    }\r\n\r\n    function giveZuniReward(address to, uint256 amount) external onlyZuniBadge {\r\n        if (IERC20(address(zuni)).balanceOf(address(this)) < amount) {\r\n            _issue(amount.add(DEFAULT_ISSURANCE_AMOUNT));\r\n        }\r\n\r\n        require(IERC20(address(zuni)).transfer(to, amount));\r\n    }\r\n\r\n    function issue(uint256 tokenAmountOut) external onlyOwner {\r\n        _issue(tokenAmountOut);\r\n    }\r\n\r\n    function buyback(uint256 tokenAmountIn) external onlyOwner {\r\n        require(\r\n            IERC20(address(zuni)).balanceOf(address(this)) >= tokenAmountIn,\r\n            \"ZuniTreasury: zuni balance is not enough\"\r\n        );\r\n\r\n        uint256 minPoolAmountOut = bPool.calcPoolOutGivenSingleIn(\r\n            bPool.getBalance(address(zuni)),\r\n            bPool.getDenormalizedWeight(address(zuni)),\r\n            crp.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            tokenAmountIn,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        minPoolAmountOut = minPoolAmountOut.mul(99).div(100);\r\n\r\n        require(IERC20(address(zuni)).approve(address(crp), tokenAmountIn));\r\n\r\n        crp.joinswapExternAmountIn(\r\n            address(zuni),\r\n            tokenAmountIn,\r\n            minPoolAmountOut\r\n        );\r\n    }\r\n\r\n    function capitalization(address token, uint256 tokenAmountOut)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            token != address(zuni),\r\n            \"ZuniTreasury: token address is incorrect\"\r\n        );\r\n\r\n        uint256 maxPoolAmountIn = bPool.calcPoolInGivenSingleOut(\r\n            bPool.getBalance(address(token)),\r\n            bPool.getDenormalizedWeight(address(token)),\r\n            crp.totalSupply(),\r\n            bPool.getTotalDenormalizedWeight(),\r\n            tokenAmountOut,\r\n            bPool.getSwapFee()\r\n        );\r\n\r\n        maxPoolAmountIn = maxPoolAmountIn.mul(101).div(100);\r\n\r\n        crp.exitswapExternAmountOut(\r\n            address(token),\r\n            tokenAmountOut,\r\n            maxPoolAmountIn\r\n        );\r\n    }\r\n\r\n    function withdrawToken(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        require(\r\n            IERC20(address(token)).balanceOf(address(this)) >= amount,\r\n            \"ZuniTreasury: token balance is not enough\"\r\n        );\r\n\r\n        require(IERC20(address(token)).transfer(to, amount));\r\n    }\r\n\r\n    // external functions only can be called by owner to config CRP\r\n\r\n    function setSwapFee(uint256 swapFee) external onlyOwner {\r\n        crp.setSwapFee(swapFee);\r\n    }\r\n\r\n    function setCap(uint256 newCap) external onlyOwner {\r\n        crp.setCap(newCap);\r\n    }\r\n\r\n    function setPublicSwap(bool publicSwap) external onlyOwner {\r\n        crp.setPublicSwap(publicSwap);\r\n    }\r\n\r\n    function updateWeight(address token, uint256 newWeight) external onlyOwner {\r\n        crp.updateWeight(token, newWeight);\r\n    }\r\n\r\n    function updateWeightsGradually(\r\n        uint256[] calldata newWeights,\r\n        uint256 startBlock,\r\n        uint256 endBlock\r\n    ) external onlyOwner {\r\n        crp.updateWeightsGradually(newWeights, startBlock, endBlock);\r\n    }\r\n\r\n    function pokeWeights() external onlyOwner {\r\n        crp.pokeWeights();\r\n    }\r\n\r\n    function commitAddToken(\r\n        address token,\r\n        uint256 balance,\r\n        uint256 denormalizedWeight\r\n    ) external onlyOwner {\r\n        crp.commitAddToken(token, balance, denormalizedWeight);\r\n    }\r\n\r\n    function applyAddToken() external onlyOwner {\r\n        crp.applyAddToken();\r\n    }\r\n\r\n    function removeToken(address token) external onlyOwner {\r\n        crp.removeToken(token);\r\n    }\r\n\r\n    function whitelistLiquidityProvider(address provider) external onlyOwner {\r\n        crp.whitelistLiquidityProvider(provider);\r\n    }\r\n\r\n    function removeWhitelistedLiquidityProvider(address provider)\r\n        external\r\n        onlyOwner\r\n    {\r\n        crp.removeWhitelistedLiquidityProvider(provider);\r\n    }\r\n}\r\n\r\ncontract ZuniBadge is Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    struct Unit {\r\n        uint256 interest;\r\n        address leader;\r\n        address creator;\r\n        EnumerableSet.UintSet childUnitIds; // childUnitId or AccountId\r\n    }\r\n\r\n    struct UnitsByLevel {\r\n        uint256 length;\r\n        mapping(uint256 => Unit) levelUnits; // unit id start from 1\r\n    }\r\n\r\n    struct WarrantBadge {\r\n        uint256 id;\r\n        uint256 pendingReward;\r\n        uint256 collectedAmount;\r\n        uint256 claimedAmount;\r\n    }\r\n\r\n    struct Account {\r\n        uint256 accountId; // unique id of account, start from 1\r\n        uint256 level; // level start from 0\r\n        bool claimedLevel;\r\n        uint256 interest;\r\n        uint256 childUnitId;\r\n        uint256 parentUnitId;\r\n        uint256 bannedTimes;\r\n        uint256 pendingWarrantReward;\r\n        uint256 claimedRankReward;\r\n        uint256 cliamedWarrantReward;\r\n        uint256[] promoteTimes;\r\n        WarrantBadge[] warrantBadges;\r\n    }\r\n\r\n    uint256 constant REWARD_MUL_DECIMAL = 100000;\r\n    uint256 public constant WEI_POINT = 10**18;\r\n\r\n    ZuniTreasury private zuniTreasury;\r\n\r\n    uint256 private interestLength;\r\n    uint256 private totalUsers;\r\n    uint256 private unitSize;\r\n    uint256 private maxLevel;\r\n    uint256[] private levelWeight;\r\n\r\n    address private rankAdmin;\r\n    uint256 private topLevel;\r\n    uint256[] private distributeTimes;\r\n\r\n    mapping(uint256 => UnitsByLevel) private units; // level => UnitsByLevel\r\n    mapping(address => Account) private accounts; // addresss => Account\r\n    mapping(uint256 => address) private accountsById; // accountId => Account\r\n\r\n    address private warrantAdmin;\r\n\r\n    modifier onlyRankAdmin() {\r\n        require(msg.sender == rankAdmin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWarrantAdmin() {\r\n        require(msg.sender == warrantAdmin);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _interestLength,\r\n        uint256 _unitSize,\r\n        uint256 _maxLevel,\r\n        address _rankAdmin,\r\n        address _warrantAdmin\r\n    ) public {\r\n        require(_interestLength > 0 && _interestLength <= 8);\r\n\r\n        interestLength = _interestLength;\r\n        unitSize = _unitSize;\r\n        maxLevel = _maxLevel;\r\n        rankAdmin = _rankAdmin;\r\n        warrantAdmin = _warrantAdmin;\r\n    }\r\n\r\n    function setTreasury(ZuniTreasury _zuniTreasury) external onlyOwner {\r\n        zuniTreasury = _zuniTreasury;\r\n    }\r\n\r\n    function updateRankAdmin(address _rankAdmin) external onlyOwner {\r\n        rankAdmin = _rankAdmin;\r\n    }\r\n\r\n    function updateWarrantAdmin(address _warrantAdmin) external onlyOwner {\r\n        warrantAdmin = _warrantAdmin;\r\n    }\r\n\r\n    function giveWarrantBadge(\r\n        address _user,\r\n        uint256 _warrantId,\r\n        uint256 _reward\r\n    ) external onlyWarrantAdmin {\r\n        Account storage account = accounts[_user];\r\n\r\n        for (uint256 i = 0; i < account.warrantBadges.length; i++) {\r\n            if (account.warrantBadges[i].id == _warrantId) {\r\n                account.warrantBadges[i].pendingReward = account\r\n                    .warrantBadges[i]\r\n                    .pendingReward\r\n                    .add(_reward);\r\n                account.warrantBadges[i].collectedAmount = account\r\n                    .warrantBadges[i]\r\n                    .collectedAmount\r\n                    .add(1);\r\n                return;\r\n            }\r\n        }\r\n\r\n        account.warrantBadges.push(\r\n            WarrantBadge({\r\n                id: _warrantId,\r\n                pendingReward: _reward,\r\n                collectedAmount: 1,\r\n                claimedAmount: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    function setLevelWeight(uint256[] calldata _levelWeight)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _levelWeight.length == maxLevel,\r\n            \"ZuniBadge: must have exactly one weight point for each level\"\r\n        );\r\n\r\n        delete levelWeight;\r\n\r\n        for (uint256 i = 0; i < maxLevel; i++) {\r\n            levelWeight.push(_levelWeight[i]);\r\n        }\r\n    }\r\n\r\n    function isMatchingInterest(uint256 baseInterest, uint256 compareInterest)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < interestLength; i++) {\r\n            if (\r\n                baseInterest.mod(2) == 1 &&\r\n                baseInterest.mod(2) == compareInterest.mod(2)\r\n            ) {\r\n                return true;\r\n            }\r\n            baseInterest = baseInterest >> 1;\r\n            compareInterest = compareInterest >> 1;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function mergeInterest(uint256 baseInterest, uint256 compareInterest)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 mergedInterest = 0;\r\n        uint256 baseMul = 1;\r\n\r\n        for (uint256 i = 0; i < interestLength; i++) {\r\n            mergedInterest = mergedInterest.add(\r\n                (baseInterest.mod(2) | compareInterest.mod(2)).mul(baseMul)\r\n            );\r\n            baseMul = baseMul << 1;\r\n            baseInterest = baseInterest >> 1;\r\n            compareInterest = compareInterest >> 1;\r\n        }\r\n        return mergedInterest;\r\n    }\r\n\r\n    function maxUnitLengthByLevel(uint256 _level)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (maxLevel.sub(_level))**unitSize;\r\n    }\r\n\r\n    function updateAccounting(address _user, uint256 _interest)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        Account storage account = accounts[_user];\r\n        if (account.bannedTimes >= 5 || account.accountId > 0) {\r\n            return false;\r\n        }\r\n        if (account.accountId == 0) {\r\n            totalUsers = totalUsers.add(1);\r\n            account.accountId = totalUsers;\r\n            account.interest = _interest;\r\n            accountsById[totalUsers] = _user;\r\n            account.childUnitId = account.accountId;\r\n            account.parentUnitId = 0;\r\n            account.claimedLevel = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function findMatchingUnit(uint256 _level, uint256 _interest)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        UnitsByLevel storage unitsByLevel = units[_level];\r\n        for (uint256 i = 1; i <= unitsByLevel.length; i++) {\r\n            if (\r\n                unitsByLevel.levelUnits[i].childUnitIds.length() < unitSize &&\r\n                isMatchingInterest(\r\n                    unitsByLevel.levelUnits[i].interest,\r\n                    _interest\r\n                )\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function findSpareUnit(uint256 _level) internal view returns (uint256) {\r\n        UnitsByLevel storage unitsByLevel = units[_level];\r\n        for (uint256 i = 1; i <= unitsByLevel.length; i++) {\r\n            if (unitsByLevel.levelUnits[i].childUnitIds.length() < unitSize) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function createOrJoinUnit(address _user) internal returns (bool) {\r\n        Account storage account = accounts[_user];\r\n        UnitsByLevel storage unitsByLevel = units[account.level];\r\n        uint256 maxUnitLength = maxUnitLengthByLevel(account.level);\r\n        uint256 matchingUnitId = findMatchingUnit(\r\n            account.level,\r\n            account.interest\r\n        );\r\n\r\n        // join\r\n        if (matchingUnitId > 0) {\r\n            require(\r\n                unitsByLevel.levelUnits[matchingUnitId].childUnitIds.add(\r\n                    account.childUnitId\r\n                )\r\n            );\r\n            account.parentUnitId = matchingUnitId;\r\n            return true;\r\n        }\r\n\r\n        // create\r\n        if (unitsByLevel.length < maxUnitLength) {\r\n            EnumerableSet.UintSet memory _childUnitIds;\r\n            uint256 newUnitId = unitsByLevel.length.add(1);\r\n            unitsByLevel.length = newUnitId;\r\n\r\n            unitsByLevel.levelUnits[newUnitId] = Unit({\r\n                interest: account.interest,\r\n                leader: address(0x0),\r\n                creator: msg.sender,\r\n                childUnitIds: _childUnitIds\r\n            });\r\n\r\n            require(\r\n                unitsByLevel.levelUnits[newUnitId].childUnitIds.add(\r\n                    account.childUnitId\r\n                )\r\n            );\r\n\r\n            account.parentUnitId = newUnitId;\r\n            return true;\r\n        }\r\n\r\n        // update unit interest\r\n        uint256 spareUnitId = findSpareUnit(account.level);\r\n        if (spareUnitId > 0) {\r\n            unitsByLevel.levelUnits[spareUnitId].childUnitIds.add(\r\n                account.childUnitId\r\n            );\r\n            unitsByLevel.levelUnits[spareUnitId].interest = mergeInterest(\r\n                unitsByLevel.levelUnits[spareUnitId].interest,\r\n                account.interest\r\n            );\r\n            account.parentUnitId = spareUnitId;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function joinCrew(uint256 _interest) external returns (bool) {\r\n        require(\r\n            updateAccounting(msg.sender, _interest),\r\n            \"ZuniBadge: banned user or already joined community\"\r\n        ); // update accounting\r\n\r\n        return createOrJoinUnit(msg.sender);\r\n    }\r\n\r\n    function addToUnit(address _user) external {\r\n        Account memory account = accounts[msg.sender];\r\n        require(account.childUnitId > 0, \"ZuniBadge: should have child unit\");\r\n\r\n        Unit storage unit = units[account.level.sub(1)].levelUnits[account\r\n            .childUnitId];\r\n\r\n        require(\r\n            unit.leader == msg.sender,\r\n            \"ZuniBadge: should be leader of the unit\"\r\n        );\r\n\r\n        require(\r\n            unit.childUnitIds.length() < unitSize,\r\n            \"ZuniBadge: unit is full\"\r\n        );\r\n\r\n        Account storage user = accounts[_user];\r\n\r\n        require(\r\n            account.level == user.level.add(1),\r\n            \"ZuniBadge: user level is incorrect\"\r\n        );\r\n        require(user.parentUnitId == 0, \"ZuniBadge: user already has a parent\");\r\n\r\n        if (user.accountId == 0) {\r\n            require(\r\n                updateAccounting(_user, account.interest),\r\n                \"ZuniBadge: banned user or already joined community\"\r\n            );\r\n        }\r\n\r\n        require(unit.childUnitIds.add(user.childUnitId));\r\n        user.parentUnitId = account.childUnitId;\r\n    }\r\n\r\n    function removeFromUnit(address _user) external {\r\n        Account storage account = accounts[msg.sender];\r\n        require(account.childUnitId > 0, \"ZuniBadge: should have child unit\");\r\n\r\n        Unit storage unit = units[account.level.sub(1)].levelUnits[account\r\n            .childUnitId];\r\n\r\n        require(\r\n            unit.leader == msg.sender,\r\n            \"ZuniBadge: should be leader of the unit\"\r\n        );\r\n\r\n        Account storage user = accounts[_user];\r\n\r\n        require(\r\n            account.level == user.level.add(1),\r\n            \"ZuniBadge: user level is incorrect\"\r\n        );\r\n\r\n        require(\r\n            unit.childUnitIds.contains(user.childUnitId),\r\n            \"ZuniBadge: unitId should be exits\"\r\n        );\r\n\r\n        require(unit.childUnitIds.remove(user.childUnitId));\r\n\r\n        user.parentUnitId = 0;\r\n        user.bannedTimes = user.bannedTimes.add(1);\r\n        if (user.bannedTimes >= 5) {\r\n            if (user.level > 0) {\r\n                Unit memory childUnit = units[user.level.sub(1)].levelUnits[user\r\n                    .childUnitId];\r\n                childUnit.leader = address(0x0);\r\n            }\r\n\r\n            user.childUnitId = 0;\r\n            user.accountId = 0;\r\n            user.level = 0;\r\n            delete user.promoteTimes;\r\n        }\r\n    }\r\n\r\n    function isEligibleForPromote(address _user) public view returns (bool) {\r\n        Account memory account = accounts[_user];\r\n        if (account.parentUnitId == 0 || account.claimedLevel == false) {\r\n            return false;\r\n        }\r\n\r\n        Unit storage unit = units[account.level].levelUnits[account\r\n            .parentUnitId];\r\n\r\n        if (\r\n            unit.leader != address(0x0) ||\r\n            unit.childUnitIds.length() != unitSize\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (account.level > 0) {\r\n            for (uint256 i = 0; i < unitSize; i++) {\r\n                if (\r\n                    units[account.level.sub(1)].levelUnits[unit.childUnitIds.at(\r\n                        i\r\n                    )]\r\n                        .leader == address(0x0)\r\n                ) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function checkTree(address _manager, address _user)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        Account memory manager = accounts[_manager];\r\n        Account memory user = accounts[_user];\r\n        Unit storage unit = units[manager.level.sub(1)].levelUnits[manager\r\n            .childUnitId];\r\n\r\n        return unit.childUnitIds.contains(user.parentUnitId);\r\n    }\r\n\r\n    function promote(address _user) external {\r\n        Account memory manager = accounts[msg.sender];\r\n        Account storage user = accounts[_user];\r\n\r\n        require(\r\n            user.level.add(2) == manager.level,\r\n            \"ZuniBadge: manager level is incorrect\"\r\n        );\r\n        require(\r\n            checkTree(msg.sender, _user),\r\n            \"ZuniBadge: should be in the same tree\"\r\n        );\r\n        require(isEligibleForPromote(_user), \"ZuniBadge: user is not eligible\");\r\n\r\n        // update child unit\r\n        Unit storage parentUnit = units[user.level].levelUnits[user\r\n            .parentUnitId];\r\n        parentUnit.leader = _user;\r\n        if (user.level == 0) {\r\n            parentUnit.childUnitIds.remove(user.accountId);\r\n        } else {\r\n            units[user.level - 1].levelUnits[user.childUnitId].leader = address(\r\n                0x0\r\n            );\r\n        }\r\n\r\n        // update account\r\n        user.level = user.level.add(1);\r\n        user.claimedLevel = false;\r\n        user.childUnitId = user.parentUnitId;\r\n        user.parentUnitId = manager.childUnitId;\r\n        user.promoteTimes.push(now);\r\n    }\r\n\r\n    function promoteByAdmin(address _user) external onlyRankAdmin {\r\n        Account storage user = accounts[_user];\r\n\r\n        require(isEligibleForPromote(_user), \"ZuniBadge: user is not eligible\");\r\n\r\n        // update child unit\r\n        Unit storage parentUnit = units[user.level].levelUnits[user\r\n            .parentUnitId];\r\n        parentUnit.leader = _user;\r\n        if (user.level == 0) {\r\n            parentUnit.childUnitIds.remove(user.accountId);\r\n        } else {\r\n            units[user.level - 1].levelUnits[user.childUnitId].leader = address(\r\n                0x0\r\n            );\r\n        }\r\n\r\n        // update account\r\n        user.level = user.level.add(1);\r\n        user.claimedLevel = false;\r\n        user.childUnitId = user.parentUnitId;\r\n        user.parentUnitId = 0;\r\n        uint256 promoteTime = now;\r\n        user.promoteTimes.push(promoteTime);\r\n\r\n        require(createOrJoinUnit(_user));\r\n\r\n        if (topLevel < user.level && user.level >= 2) {\r\n            topLevel = user.level;\r\n            distributeTimes.push(promoteTime);\r\n        }\r\n    }\r\n\r\n    function claimLevel() external {\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        require(account.level > 0 && account.claimedLevel == false);\r\n\r\n        account.claimedLevel = true;\r\n    }\r\n\r\n    function claimWarrantBadge(uint256 _warrantId) external {\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        for (uint256 i = 0; i < account.warrantBadges.length; i++) {\r\n            if (account.warrantBadges[i].id == _warrantId) {\r\n                require(\r\n                    account.warrantBadges[i].collectedAmount >\r\n                        account.warrantBadges[i].claimedAmount,\r\n                    \"ZuniBadge: warrant badge is claimed already\"\r\n                );\r\n\r\n                account.warrantBadges[i].claimedAmount = account\r\n                    .warrantBadges[i]\r\n                    .collectedAmount;\r\n                account.pendingWarrantReward = account.pendingWarrantReward.add(\r\n                    account.warrantBadges[i].pendingReward\r\n                );\r\n                account.warrantBadges[i].pendingReward = 0;\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        revert(\"ZuniBadge: warrant badge does not exit\");\r\n    }\r\n\r\n    function rewardMultiplier(uint256 distIndex, uint256 levelIndex)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 maxDistEvents = maxLevel.sub(2);\r\n\r\n        if (levelIndex > distIndex) {\r\n            return 0;\r\n        }\r\n\r\n        if (maxDistEvents.sub(levelIndex) == 0) {\r\n            return REWARD_MUL_DECIMAL;\r\n        }\r\n\r\n        return REWARD_MUL_DECIMAL >> (distIndex.sub(levelIndex).add(1));\r\n    }\r\n\r\n    function _availableRankReward(address _user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Account memory user = accounts[_user];\r\n        uint256 totalReward = 0;\r\n        uint256 maxDistEvents = maxLevel.sub(2);\r\n\r\n        for (uint256 i = 0; i < distributeTimes.length; i++) {\r\n            for (uint256 j = 0; j < user.promoteTimes.length; j++) {\r\n                if (user.promoteTimes[j] <= distributeTimes[i]) {\r\n                    totalReward = totalReward.add(\r\n                        levelWeight[j]\r\n                            .mul(\r\n                            rewardMultiplier(\r\n                                maxDistEvents == i.add(1)\r\n                                    ? maxDistEvents.sub(1)\r\n                                    : i.add(1),\r\n                                j.add(1)\r\n                            )\r\n                        )\r\n                            .div(REWARD_MUL_DECIMAL)\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        return totalReward.sub(user.claimedRankReward);\r\n    }\r\n\r\n    function availableReward(address _user) public view returns (uint256) {\r\n        Account memory user = accounts[_user];\r\n        uint256 availableRankReward = _availableRankReward(_user);\r\n\r\n        return availableRankReward.add(user.pendingWarrantReward);\r\n    }\r\n\r\n    function claimReward() external {\r\n        require(\r\n            address(zuniTreasury) != address(0x0),\r\n            \"ZuniBadge: zuniTreasury didn't set yet\"\r\n        );\r\n\r\n        Account storage user = accounts[msg.sender];\r\n        uint256 availableRankReward = _availableRankReward(msg.sender);\r\n        uint256 available = availableRankReward.add(user.pendingWarrantReward);\r\n\r\n        if (available > 0) {\r\n            user.claimedRankReward = user.claimedRankReward.add(\r\n                availableRankReward\r\n            );\r\n            user.cliamedWarrantReward = user.cliamedWarrantReward.add(\r\n                user.pendingWarrantReward\r\n            );\r\n            user.pendingWarrantReward = 0;\r\n            zuniTreasury.giveZuniReward(msg.sender, available);\r\n        }\r\n    }\r\n\r\n    function accountInfo(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            bool,\r\n            uint256\r\n        )\r\n    {\r\n        Account memory account = accounts[_user];\r\n        return (\r\n            account.accountId,\r\n            account.level,\r\n            account.interest,\r\n            account.childUnitId,\r\n            account.parentUnitId,\r\n            account.claimedLevel,\r\n            account.claimedRankReward.add(account.cliamedWarrantReward)\r\n        );\r\n    }\r\n\r\n    function accountWarrants(address _user)\r\n        public\r\n        view\r\n        returns (WarrantBadge[] memory)\r\n    {\r\n        return accounts[_user].warrantBadges;\r\n    }\r\n\r\n    function unitInfo(uint256 _level, uint256 _unitId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            uint256\r\n        )\r\n    {\r\n        Unit storage unit = units[_level].levelUnits[_unitId];\r\n        return (unit.interest, unit.leader, unit.childUnitIds.length());\r\n    }\r\n\r\n    function unitMembers(uint256 _level, uint256 _unitId)\r\n        public\r\n        view\r\n        returns (\r\n            address leader,\r\n            uint256 length,\r\n            address[4] memory members // assume unitSize <= 4\r\n        )\r\n    {\r\n        Unit storage unit = units[_level].levelUnits[_unitId];\r\n        leader = unit.leader;\r\n        length = unit.childUnitIds.length();\r\n        if (_level == 0) {\r\n            for (uint256 i = 0; i < length; i++) {\r\n                members[i] = accountsById[unit.childUnitIds.at(i)];\r\n            }\r\n        } else {\r\n            uint256 subLevel = _level.sub(1);\r\n            for (uint256 i = 0; i < length; i++) {\r\n                Unit memory subUnit = units[subLevel].levelUnits[unit\r\n                    .childUnitIds\r\n                    .at(i)];\r\n                members[i] = subUnit.leader;\r\n            }\r\n        }\r\n    }\r\n\r\n    function promotableSubUnits(uint256 _level, uint256 _uintId)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 length,\r\n            uint256[4] memory subUnitIds // assume unitSize <= 4\r\n        )\r\n    {\r\n        if (_level > 0) {\r\n            Unit storage unit = units[_level].levelUnits[_uintId];\r\n            uint256 subLevel = _level.sub(1);\r\n            for (uint256 i = 0; i < unit.childUnitIds.length(); i++) {\r\n                uint256 subUnitId = unit.childUnitIds.at(i);\r\n                Unit storage subUnit = units[subLevel].levelUnits[subUnitId];\r\n                if (\r\n                    subUnit.leader == address(0x0) &&\r\n                    subUnit.childUnitIds.length() == unitSize\r\n                ) {\r\n                    subUnitIds[length] = subUnitId;\r\n                    length = length.add(1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
    }
  }
}