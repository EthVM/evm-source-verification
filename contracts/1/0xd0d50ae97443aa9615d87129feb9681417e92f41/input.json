{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MultiWallet.sol":{"content":"pragma solidity ^0.6.3;\r\n\r\n/**\r\n * @title Helps contracts guard agains reentrancy attacks.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @notice If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\ncontract MultiWallet is ReentrancyGuard {\r\n    address payable wallet1_10 = 0x5410c9762d3C5E12299e0d1175471d1D8c8b2C05;\r\n    address payable wallet2_10 = 0x36d9399A33C4851526D541E0e4B577E5dAdc6be0;\r\n    address payable wallet3_10 = 0x1D351463823C0726E8334469f09E47Ac01ddE16C;\r\n    address payable wallet4_10 = 0x3DCB1c27b0c9251bA4877ec4DC83baE9C65d1310;\r\n    address payable wallet5_60 = 0xb2406fe92dA73f6ed175862007b5cb7d781d881D;\r\n\r\n  receive() external payable { }\r\n  \r\n  function divide() external nonReentrant {\r\n        uint256 totalBalance = address(this).balance;\r\n        uint256 w10 = totalBalance * 1 / 10;\r\n        \r\n        wallet1_10.transfer(w10);\r\n        wallet2_10.transfer(w10);\r\n        wallet3_10.transfer(w10);\r\n        wallet4_10.transfer(w10);\r\n        wallet5_60.transfer(totalBalance - 4 * w10);\r\n   }\r\n   function changeWallet1(address payable _newWallet) external {\r\n       require(msg.sender == wallet1_10);\r\n       wallet1_10 = _newWallet;\r\n   }\r\n   function changeWallet2(address payable _newWallet) external {\r\n       require(msg.sender == wallet2_10);\r\n       wallet2_10 = _newWallet;\r\n   }\r\n   function changeWallet3(address payable _newWallet) external {\r\n       require(msg.sender == wallet3_10);\r\n       wallet3_10 = _newWallet;\r\n   }\r\n   function changeWallet4(address payable _newWallet) external {\r\n       require(msg.sender == wallet4_10);\r\n       wallet4_10 = _newWallet;\r\n   }\r\n   function changeWallet5(address payable _newWallet) external {\r\n       require(msg.sender == wallet5_60);\r\n       wallet5_60 = _newWallet;\r\n   }\r\n \r\n}"}}}