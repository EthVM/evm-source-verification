{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Holdefi_mainnet/HoldefiOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n/// @title HoldefiOwnable\n/// @author Holdefi Team\n/// @notice Taking ideas from Open Zeppelin's Ownable contract\n/// @dev Contract module which provides a basic access control mechanism, where\n/// there is an account (an owner) that can be granted exclusive access to\n/// specific functions.\n///\n/// By default, the owner account will be the one that deploys the contract. This\n/// can later be changed with {transferOwnership}.\n///\n/// This module is used through inheritance. It will make available the modifier\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\n/// the owner.\ncontract HoldefiOwnable {\n    address public owner;\n    address public pendingOwner;\n\n    /// @notice Event emitted when an ownership transfer request is recieved\n    event OwnershipTransferRequested(address newPendingOwner);\n\n    /// @notice Event emitted when an ownership transfer request is accepted by the pending owner\n    event OwnershipTransferred(address newOwner, address oldOwner);\n\n    /// @notice Initializes the contract owner\n    constructor () public {\n        owner = msg.sender;\n        emit OwnershipTransferred(owner, address(0));\n    }\n\n    /// @notice Throws if called by any account other than the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender should be owner\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new owner\n    /// @dev Can only be called by the current owner\n    /// @param newOwner Address of new owner\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"New owner can not be zero address\");\n        pendingOwner = newOwner;\n\n        emit OwnershipTransferRequested(newOwner);\n    }\n\n    /// @notice Pending owner accepts ownership of the contract\n    /// @dev Only Pending owner can call this function\n    function acceptTransferOwnership () external {\n        require (pendingOwner != address(0), \"Pending owner is empty\");\n        require (pendingOwner == msg.sender, \"Pending owner is not same as sender\");\n        \n        emit OwnershipTransferred(pendingOwner, owner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}"
    },
    "Holdefi_mainnet/HoldefiSettings.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./HoldefiOwnable.sol\";\r\n\r\n/// @notice File: contracts/Holdefi.sol\r\ninterface HoldefiInterface {\r\n\tstruct Market {\r\n\t\tuint256 totalSupply;\r\n\t\tuint256 supplyIndex;\r\n\t\tuint256 supplyIndexUpdateTime;\r\n\r\n\t\tuint256 totalBorrow;\r\n\t\tuint256 borrowIndex;\r\n\t\tuint256 borrowIndexUpdateTime;\r\n\r\n\t\tuint256 promotionReserveScaled;\r\n\t\tuint256 promotionReserveLastUpdateTime;\r\n\t\tuint256 promotionDebtScaled;\r\n\t\tuint256 promotionDebtLastUpdateTime;\r\n\t}\r\n\r\n\tfunction marketAssets(address market) external view returns (Market memory);\r\n\tfunction holdefiSettings() external view returns (address contractAddress);\r\n\tfunction beforeChangeSupplyRate (address market) external;\r\n\tfunction beforeChangeBorrowRate (address market) external;\r\n\tfunction reserveSettlement (address market) external;\r\n}\r\n\r\n/// @title HoldefiSettings contract\r\n/// @author Holdefi Team\r\n/// @notice This contract is for Holdefi settings implementation\r\ncontract HoldefiSettings is HoldefiOwnable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t/// @notice Markets Features\r\n\tstruct MarketSettings {\r\n\t\tbool isExist;\t\t// Market is exist or not\r\n\t\tbool isActive;\t\t// Market is open for deposit or not\r\n\r\n\t\tuint256 borrowRate;\r\n\t\tuint256 borrowRateUpdateTime;\r\n\r\n\t\tuint256 suppliersShareRate;\r\n\t\tuint256 suppliersShareRateUpdateTime;\r\n\r\n\t\tuint256 promotionRate;\r\n\t}\r\n\r\n\t/// @notice Collateral Features\r\n\tstruct CollateralSettings {\r\n\t\tbool isExist;\t\t// Collateral is exist or not\r\n\t\tbool isActive;\t\t// Collateral is open for deposit or not\r\n\r\n\t\tuint256 valueToLoanRate;\r\n\t\tuint256 VTLUpdateTime;\r\n\r\n\t\tuint256 penaltyRate;\r\n\t\tuint256 penaltyUpdateTime;\r\n\r\n\t\tuint256 bonusRate;\r\n\t}\r\n\r\n\tuint256 constant public rateDecimals = 10 ** 4;\r\n\r\n\taddress constant public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n\tuint256 constant public periodBetweenUpdates = 864000;      \t// seconds per ten days\r\n\r\n\tuint256 constant public maxBorrowRate = 4000;      \t\t\t\t// 40%\r\n\r\n\tuint256 constant public borrowRateMaxIncrease = 500;      \t\t// 5%\r\n\r\n\tuint256 constant public minSuppliersShareRate = 5000;      \t\t// 50%\r\n\r\n\tuint256 constant public suppliersShareRateMaxDecrease = 500;\t// 5%\r\n\r\n\tuint256 constant public maxValueToLoanRate = 20000;      \t\t// 200%\r\n\r\n\tuint256 constant public valueToLoanRateMaxIncrease = 500;      \t// 5%\r\n\r\n\tuint256 constant public maxPenaltyRate = 13000;      \t\t\t// 130%\r\n\r\n\tuint256 constant public penaltyRateMaxIncrease = 500;      \t\t// 5%\r\n\r\n\tuint256 constant public maxPromotionRate = 3000;\t\t\t\t// 30%\r\n\r\n\tuint256 constant public maxListsLength = 25;\r\n\r\n\t/// @dev Used for calculating liquidation threshold \r\n\t/// There is 5% gap between value to loan rate and liquidation rate\r\n\tuint256 constant private fivePercentLiquidationGap = 500;\r\n\r\n\tmapping (address => MarketSettings) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\tmapping (address => CollateralSettings) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\t/// @notice Event emitted when market activation status is changed\r\n\tevent MarketActivationChanged(address indexed market, bool status);\r\n\r\n\t/// @notice Event emitted when collateral activation status is changed\r\n\tevent CollateralActivationChanged(address indexed collateral, bool status);\r\n\r\n\t/// @notice Event emitted when market existence status is changed\r\n\tevent MarketExistenceChanged(address indexed market, bool status);\r\n\r\n\t/// @notice Event emitted when collateral existence status is changed\r\n\tevent CollateralExistenceChanged(address indexed collateral, bool status);\r\n\r\n\t/// @notice Event emitted when market borrow rate is changed\r\n\tevent BorrowRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when market suppliers share rate is changed\r\n\tevent SuppliersShareRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when market promotion rate is changed\r\n\tevent PromotionRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when collateral value to loan rate is changed\r\n\tevent ValueToLoanRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when collateral penalty rate is changed\r\n\tevent PenaltyRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when collateral bonus rate is changed\r\n\tevent BonusRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\r\n\r\n\r\n\r\n\t/// @dev Modifier to make a function callable only when the market is exist\r\n\t/// @param market Address of the given market\r\n    modifier marketIsExist(address market) {\r\n        require (marketAssets[market].isExist, \"The market is not exist\");\r\n        _;\r\n    }\r\n\r\n\t/// @dev Modifier to make a function callable only when the collateral is exist\r\n\t/// @param collateral Address of the given collateral\r\n    modifier collateralIsExist(address collateral) {\r\n        require (collateralAssets[collateral].isExist, \"The collateral is not exist\");\r\n        _;\r\n    }\r\n\r\n\r\n\t/// @notice you cannot send ETH to this contract\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n \t/// @notice Activate a market asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\tfunction activateMarket (address market) public onlyOwner marketIsExist(market) {\r\n\t\tactivateMarketInternal(market);\r\n\t}\r\n\r\n\t/// @notice Deactivate a market asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\tfunction deactivateMarket (address market) public onlyOwner marketIsExist(market) {\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketActivationChanged(market, false);\r\n\t}\r\n\r\n\t/// @notice Activate a collateral asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address the given collateral\r\n\tfunction activateCollateral (address collateral) public onlyOwner collateralIsExist(collateral) {\r\n\t\tactivateCollateralInternal(collateral);\r\n\t}\r\n\r\n\t/// @notice Deactivate a collateral asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\tfunction deactivateCollateral (address collateral) public onlyOwner collateralIsExist(collateral) {\r\n\t\tcollateralAssets[collateral].isActive = false;\r\n\t\temit CollateralActivationChanged(collateral, false);\r\n\t}\r\n\r\n\t/// @notice Returns the list of markets\r\n\t/// @return res List of markets\r\n\tfunction getMarketsList() external view returns (address[] memory res){\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t/// @notice Disposable function to interact with Holdefi contract\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param holdefiContractAddress Address of the Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (holdefiContractAddress.holdefiSettings() == address(this),\r\n\t\t\t\"Conflict with Holdefi contract address\"\r\n\t\t);\r\n\t\trequire (address(holdefiContract) == address(0), \"Should be set once\");\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t/// @notice Returns supply, borrow and promotion rate of the given market\r\n\t/// @dev supplyRate = (totalBorrow * borrowRate) * suppliersShareRate / totalSupply\r\n\t/// @param market Address of the given market\r\n\t/// @return borrowRate Borrow rate of the given market\r\n\t/// @return supplyRateBase Supply rate base of the given market\r\n\t/// @return promotionRate Promotion rate of the given market\r\n\tfunction getInterests (address market)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256 borrowRate, uint256 supplyRateBase, uint256 promotionRate)\r\n\t{\r\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\r\n\t\tuint256 totalSupply = holdefiContract.marketAssets(market).totalSupply;\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\r\n\t\tif (totalSupply == 0) {\r\n\t\t\tsupplyRateBase = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint256 totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint256 suppliersShare = totalInterestFromBorrow.mul(marketAssets[market].suppliersShareRate);\r\n\t\t\tsuppliersShare = suppliersShare.div(rateDecimals);\r\n\t\t\tsupplyRateBase = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t\tpromotionRate = marketAssets[market].promotionRate;\r\n\t}\r\n\r\n\r\n\t/// @notice Set promotion rate for a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param newPromotionRate New promotion rate\r\n\tfunction setPromotionRate (address market, uint256 newPromotionRate) external onlyOwner {\r\n\t\trequire (newPromotionRate <= maxPromotionRate, \"Rate should be in allowed range\");\r\n\r\n\t\tholdefiContract.beforeChangeSupplyRate(market);\r\n\t\tholdefiContract.reserveSettlement(market);\r\n\r\n\t\temit PromotionRateChanged(market, newPromotionRate, marketAssets[market].promotionRate);\r\n\t\tmarketAssets[market].promotionRate = newPromotionRate;\r\n\t}\r\n\r\n\t/// @notice Reset promotion rate of the market to zero\r\n\t/// @dev Can only be called by holdefi contract\r\n\t/// @param market Address of the given market\r\n\tfunction resetPromotionRate (address market) external {\r\n\t\trequire (msg.sender == address(holdefiContract), \"Sender is not Holdefi contract\");\r\n\r\n\t\temit PromotionRateChanged(market, 0, marketAssets[market].promotionRate);\r\n\t\tmarketAssets[market].promotionRate = 0;\r\n\t}\r\n\r\n\t/// @notice Set borrow rate for a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param newBorrowRate New borrow rate\r\n\tfunction setBorrowRate (address market, uint256 newBorrowRate)\r\n\t\texternal \r\n\t\tonlyOwner\r\n\t\tmarketIsExist(market)\r\n\t{\r\n\t\tsetBorrowRateInternal(market, newBorrowRate);\r\n\t}\r\n\r\n\t/// @notice Set suppliers share rate for a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param newSuppliersShareRate New suppliers share rate\r\n\tfunction setSuppliersShareRate (address market, uint256 newSuppliersShareRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tmarketIsExist(market)\r\n\t{\r\n\t\tsetSuppliersShareRateInternal(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t/// @notice Set value to loan rate for a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param newValueToLoanRate New value to loan rate\r\n\tfunction setValueToLoanRate (address collateral, uint256 newValueToLoanRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tcollateralIsExist(collateral)\r\n\t{\r\n\t\tsetValueToLoanRateInternal(collateral, newValueToLoanRate);\r\n\t}\r\n\r\n\t/// @notice Set penalty rate for a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param newPenaltyRate New penalty rate\r\n\tfunction setPenaltyRate (address collateral, uint256 newPenaltyRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tcollateralIsExist(collateral)\r\n\t{\r\n\t\tsetPenaltyRateInternal(collateral, newPenaltyRate);\r\n\t}\r\n\r\n\t/// @notice Set bonus rate for a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param newBonusRate New bonus rate\r\n\tfunction setBonusRate (address collateral, uint256 newBonusRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tcollateralIsExist(collateral)\r\n\t{\r\n\t\tsetBonusRateInternal(collateral, newBonusRate); \r\n\t}\r\n\r\n\t/// @notice Add a new asset as a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the new market\r\n\t/// @param borrowRate BorrowRate of the new market\r\n\t/// @param suppliersShareRate SuppliersShareRate of the new market\r\n\tfunction addMarket (address market, uint256 borrowRate, uint256 suppliersShareRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\trequire (!marketAssets[market].isExist, \"The market is exist\");\r\n\t\trequire (marketsList.length < maxListsLength, \"Market list is full\");\r\n\r\n\t\tif (market != ethAddress) {\r\n\t\t\tIERC20(market);\r\n\t\t}\r\n\r\n\t\tmarketsList.push(market);\r\n\t\tmarketAssets[market].isExist = true;\r\n\t\temit MarketExistenceChanged(market, true);\r\n\r\n\t\tsetBorrowRateInternal(market, borrowRate);\r\n\t\tsetSuppliersShareRateInternal(market, suppliersShareRate);\r\n\t\t\r\n\t\tactivateMarketInternal(market);\t\t\r\n\t}\r\n\r\n\t/// @notice Remove a market asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\tfunction removeMarket (address market) external onlyOwner marketIsExist(market) {\r\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\r\n\t\trequire (totalBorrow == 0, \"Total borrow is not zero\");\r\n\t\t\r\n\t\tholdefiContract.beforeChangeBorrowRate(market);\r\n\r\n\t\tuint256 i;\r\n\t\tuint256 index;\r\n\t\tuint256 marketListLength = marketsList.length;\r\n\t\tfor (i = 0 ; i < marketListLength ; i++) {\r\n\t\t\tif (marketsList[i] == market) {\r\n\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (index != marketListLength-1) {\r\n\t\t\tfor (i = index ; i < marketListLength-1 ; i++) {\r\n\t\t\t\tmarketsList[i] = marketsList[i+1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmarketsList.pop();\r\n\t\tdelete marketAssets[market];\r\n\t\temit MarketExistenceChanged(market, false);\r\n\t}\r\n\r\n\t/// @notice Add a new asset as a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the new collateral\r\n\t/// @param valueToLoanRate ValueToLoanRate of the new collateral\r\n\t/// @param penaltyRate PenaltyRate of the new collateral\r\n\t/// @param bonusRate BonusRate of the new collateral\r\n\tfunction addCollateral (\r\n\t\taddress collateral,\r\n\t\tuint256 valueToLoanRate,\r\n\t\tuint256 penaltyRate,\r\n\t\tuint256 bonusRate\r\n\t)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\trequire (!collateralAssets[collateral].isExist, \"The collateral is exist\");\r\n\r\n\t\tif (collateral != ethAddress) {\r\n\t\t\tIERC20(collateral);\r\n\t\t}\r\n\r\n\t\tcollateralAssets[collateral].isExist = true;\r\n\t\temit CollateralExistenceChanged(collateral, true);\r\n\r\n\t\tsetValueToLoanRateInternal(collateral, valueToLoanRate);\r\n\t\tsetPenaltyRateInternal(collateral, penaltyRate);\r\n\t\tsetBonusRateInternal(collateral, bonusRate);\r\n\r\n\t\tactivateCollateralInternal(collateral);\r\n\t}\r\n\r\n\t/// @notice Activate the market\r\n\tfunction activateMarketInternal (address market) internal {\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\temit MarketActivationChanged(market, true);\r\n\t}\r\n\r\n\t/// @notice Activate the collateral\r\n\tfunction activateCollateralInternal (address collateral) internal {\r\n\t\tcollateralAssets[collateral].isActive = true;\r\n\t\temit CollateralActivationChanged(collateral, true);\r\n\t}\r\n\r\n\t/// @notice Set borrow rate operation\r\n\tfunction setBorrowRateInternal (address market, uint256 newBorrowRate) internal {\r\n\t\trequire (newBorrowRate <= maxBorrowRate, \"Rate should be less than max\");\r\n\t\tuint256 currentTime = block.timestamp;\r\n\r\n\t\tif (marketAssets[market].borrowRateUpdateTime != 0) {\r\n\t\t\tif (newBorrowRate > marketAssets[market].borrowRate) {\r\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Increasing rate is not allowed at this time\");\r\n\r\n\t\t\t\tuint256 maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\t\trequire (newBorrowRate <= maxIncrease, \"Rate should be increased less than max allowed\");\r\n\t\t\t}\r\n\r\n\t\t\tholdefiContract.beforeChangeBorrowRate(market);\r\n\t\t}\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate, marketAssets[market].borrowRate);\r\n\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set suppliers share rate operation\r\n\tfunction setSuppliersShareRateInternal (address market, uint256 newSuppliersShareRate) internal {\r\n\t\trequire (\r\n\t\t\tnewSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= rateDecimals,\r\n\t\t\t\"Rate should be in allowed range\"\r\n\t\t);\r\n\t\tuint256 currentTime = block.timestamp;\r\n\r\n\t\tif (marketAssets[market].suppliersShareRateUpdateTime != 0) {\r\n\t\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Decreasing rate is not allowed at this time\");\r\n\r\n\t\t\t\tuint256 decreasedAllowed = newSuppliersShareRate.add(suppliersShareRateMaxDecrease);\r\n\t\t\t\trequire (\r\n\t\t\t\t\tmarketAssets[market].suppliersShareRate <= decreasedAllowed,\r\n\t\t\t\t\t\"Rate should be decreased less than max allowed\"\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tholdefiContract.beforeChangeSupplyRate(market);\r\n\t\t}\r\n\r\n\t\temit SuppliersShareRateChanged(\r\n\t\t\tmarket,\r\n\t\t\tnewSuppliersShareRate,\r\n\t\t\tmarketAssets[market].suppliersShareRate\r\n\t\t);\r\n\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set value to loan rate operation\r\n\tfunction setValueToLoanRateInternal (address collateral, uint256 newValueToLoanRate) internal {\r\n\t\trequire (\r\n\t\t\tnewValueToLoanRate <= maxValueToLoanRate &&\r\n\t\t\tcollateralAssets[collateral].penaltyRate.add(fivePercentLiquidationGap) <= newValueToLoanRate,\r\n\t\t\t\"Rate should be in allowed range\"\r\n\t\t);\r\n\t\t\r\n\t\tuint256 currentTime = block.timestamp;\r\n\t\tif (\r\n\t\t\tcollateralAssets[collateral].VTLUpdateTime != 0 &&\r\n\t\t\tnewValueToLoanRate > collateralAssets[collateral].valueToLoanRate\r\n\t\t) {\r\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= periodBetweenUpdates,\"Increasing rate is not allowed at this time\");\r\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].valueToLoanRate.add(\r\n\t\t\t\tvalueToLoanRateMaxIncrease\r\n\t\t\t);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,\"Rate should be increased less than max allowed\");\r\n\t\t}\r\n\t\temit ValueToLoanRateChanged(\r\n\t\t\tcollateral,\r\n\t\t\tnewValueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate\r\n\t\t);\r\n\r\n\t    collateralAssets[collateral].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateral].VTLUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set penalty rate operation\r\n\tfunction setPenaltyRateInternal (address collateral, uint256 newPenaltyRate) internal {\r\n\t\trequire (\r\n\t\t\tnewPenaltyRate <= maxPenaltyRate &&\r\n\t\t\tnewPenaltyRate <= collateralAssets[collateral].valueToLoanRate.sub(fivePercentLiquidationGap) &&\r\n\t\t\tcollateralAssets[collateral].bonusRate <= newPenaltyRate,\r\n\t\t\t\"Rate should be in allowed range\"\r\n\t\t);\r\n\r\n\t\tuint256 currentTime = block.timestamp;\r\n\t\tif (\r\n\t\t\tcollateralAssets[collateral].penaltyUpdateTime != 0 &&\r\n\t\t\tnewPenaltyRate > collateralAssets[collateral].penaltyRate\r\n\t\t) {\r\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= periodBetweenUpdates, \"Increasing rate is not allowed at this time\");\r\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease, \"Rate should be increased less than max allowed\");\r\n\t\t}\r\n\r\n\t\temit PenaltyRateChanged(collateral, newPenaltyRate, collateralAssets[collateral].penaltyRate);\r\n\r\n\t    collateralAssets[collateral].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateral].penaltyUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set Bonus rate operation\r\n\tfunction setBonusRateInternal (address collateral, uint256 newBonusRate) internal {\r\n\t\trequire (\r\n\t\t\tnewBonusRate <= collateralAssets[collateral].penaltyRate && newBonusRate >= rateDecimals,\r\n\t\t\t\"Rate should be in allowed range\"\r\n\t\t);\r\n\t\t\r\n\t\temit BonusRateChanged(collateral, newBonusRate, collateralAssets[collateral].bonusRate);\r\n\t    collateralAssets[collateral].bonusRate = newBonusRate;    \r\n\t}\r\n}\r\n"
    },
    "Holdefi_mainnet/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "Holdefi_mainnet/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}