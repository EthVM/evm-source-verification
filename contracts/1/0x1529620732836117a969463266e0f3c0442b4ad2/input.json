{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Vault.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface ERC20Interface {\n    \n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract AxiaVault {\n    \n    address public AXIA;\n    address public SwapLiquidity;\n    address public OracleLiquidty;\n    address public DefiLiquidity;\n    \n    address owner = msg.sender;\n    uint256 public lastTradingFeeDistributionAxia;\n    uint256 public lastTradingFeeDistributionSwap;\n    uint256 public lastTradingFeeDistributionOracle;\n    uint256 public lastTradingFeeDistributionDefi;\n    \n    uint256 public migrationLock;\n    address public migrationRecipient;\n    \n    \n// Has a hardcap of 1% per trading fees distribution in one week.\n\n    function distributeAXIA(address recipient, uint256 amount) external {\n        uint256 TokenBalance = ERC20Interface(AXIA).balanceOf(address(this));\n        require(amount <= (TokenBalance / 100), \"Amount is higher than 1% of AXIA vault balance\"); // Max 1%\n        require(lastTradingFeeDistributionAxia + 168 hours < now, \"Time is less than assigned time for distribution of Axia\"); // Max once a week \n        require(msg.sender == owner, \"No Authorization\");\n               ERC20Interface(AXIA).transfer(recipient, amount);\n        lastTradingFeeDistributionAxia = now;\n    } \n    \n    function distributeSWAP(address recipient, uint256 amount) external {\n        uint256 TokenBalance = ERC20Interface(SwapLiquidity).balanceOf(address(this));\n        require(amount <= (TokenBalance / 100), \"Amount is higher than 1% of SwapLiquidity vault balance\"); // Max 1%\n        require(lastTradingFeeDistributionSwap + 168 hours < now, \"Time is less than assigned time for distribution of SwapLiquidity\"); // Max once a week \n        require(msg.sender == owner, \"No Authorization\");\n               ERC20Interface(SwapLiquidity).transfer(recipient, amount);\n        lastTradingFeeDistributionSwap = now;\n    } \n    \n    function distributeORACLE(address recipient, uint256 amount) external {\n        uint256 TokenBalance = ERC20Interface(OracleLiquidty).balanceOf(address(this));\n        require(amount <= (TokenBalance / 100), \"Amount is higher than 1% of OracleLiquidty vault balance\"); // Max 1%\n        require(lastTradingFeeDistributionOracle + 168 hours < now, \"Time is less than assigned time for distribution of OracleLiquidty\"); // Max once a week \n        require(msg.sender == owner, \"No Authorization\");\n               ERC20Interface(OracleLiquidty).transfer(recipient, amount);\n        lastTradingFeeDistributionOracle = now;\n    } \n    \n    function distributeDEFI(address recipient, uint256 amount) external {\n        uint256 TokenBalance = ERC20Interface(DefiLiquidity).balanceOf(address(this));\n        require(amount <= (TokenBalance / 100), \"Amount is higher than 1% of DefiLiquidity vault balance\"); // Max 1%\n        require(lastTradingFeeDistributionDefi + 168 hours < now, \"Time is less than assigned time for distribution of DefiLiquidity\"); // Max once a week \n        require(msg.sender == owner, \"No Authorization\");\n               ERC20Interface(DefiLiquidity).transfer(recipient, amount);\n        lastTradingFeeDistributionDefi = now;\n    } \n    \n\n// Function allows liquidity to be migrated, after 3 months lockup - preventing abuse.\n\n\n    function startLiquidityMigration(address recipient) external {\n        require(msg.sender == owner, \"No Authorization\");\n        migrationLock = now + 2160 hours;\n        migrationRecipient = recipient;\n    }\n    \n    \n// Migrates liquidity to new location, assuming the 3 months lockup has passed -preventing abuse.\n\n    function processMigration() external {\n        \n        require(msg.sender == owner, \"No Authorization\");\n        require(migrationRecipient != address(0));\n        require(now > migrationLock);\n        \n        uint256 TokenBalance = ERC20Interface(AXIA).balanceOf(address(this));\n        uint256 TokenBalanceSwap = ERC20Interface(SwapLiquidity).balanceOf(address(this));\n        uint256 TokenBalanceOracle = ERC20Interface(OracleLiquidty).balanceOf(address(this));\n        uint256 TokenBalanceDefi = ERC20Interface(DefiLiquidity).balanceOf(address(this));\n        \n        ERC20Interface(AXIA).transfer(migrationRecipient, TokenBalance);\n        ERC20Interface(SwapLiquidity).transfer(migrationRecipient, TokenBalanceSwap);\n        ERC20Interface(OracleLiquidty).transfer(migrationRecipient, TokenBalanceOracle);\n        ERC20Interface(DefiLiquidity).transfer(migrationRecipient, TokenBalanceDefi);\n        \n    }  \n    \n    \n    // Setting the interracting tokens\n    \n    function startToken(address _AXIAaddress, address _SwapLiquidity, address _OracleLiquidity, address _DefiLiquidity) external {\n        require(msg.sender == owner);\n        AXIA = _AXIAaddress;\n        SwapLiquidity = _SwapLiquidity;\n        OracleLiquidty = _OracleLiquidity;\n        DefiLiquidity = _DefiLiquidity;\n    }\n    \n    \n}\n\n\n    \n\n"
    }
  }
}