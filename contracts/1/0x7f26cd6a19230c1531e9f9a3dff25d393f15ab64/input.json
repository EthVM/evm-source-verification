{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"lender.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// Global Enums and Structs\n\n\n\nstruct StrategyParams {\n    uint256 performanceFee;\n    uint256 activation;\n    uint256 debtRatio;\n    uint256 minDebtPerHarvest;\n    uint256 maxDebtPerHarvest;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalGain;\n    uint256 totalLoss;\n}\n\n// Part: IBaseStrategy\n\ninterface IBaseStrategy {\n    function apiVersion() external pure returns (string memory);\n\n    function name() external pure returns (string memory);\n\n    function vault() external view returns (address);\n\n    function keeper() external view returns (address);\n\n    function tendTrigger(uint256 callCost) external view returns (bool);\n\n    function tend() external;\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    function management() external view returns (address);\n}\n\n// Part: IGenericLender\n\ninterface IGenericLender {\n    function lenderName() external view returns (string memory);\n\n    function nav() external view returns (uint256);\n\n    function strategy() external view returns (address);\n\n    function apr() external view returns (uint256);\n\n    function weightedApr() external view returns (uint256);\n\n    function withdraw(uint256 amount) external returns (uint256);\n\n    function emergencyWithdraw(uint256 amount) external;\n\n    function deposit() external;\n\n    function withdrawAll() external returns (bool);\n\n    function hasAssets() external view returns (bool);\n\n    function aprAfterDeposit(uint256 amount) external view returns (uint256);\n\n    function setDust(uint256 _dust) external;\n\n    function sweep(address _token) external;\n}\n\n// Part: InterestRateModel\n\ninterface InterestRateModel {\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256, uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/Address\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/IERC20\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeMath\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// Part: CTokenI\n\ninterface CTokenI {\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n\n    /**\n     * @notice Event emitted when tokens are minted\n     */\n    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint256 repayAmount, address cTokenCollateral, uint256 seizeTokens);\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @notice Event emitted when the reserve factor is changed\n     */\n    event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n    /**\n     * @notice EIP20 Transfer event\n     */\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @notice EIP20 Approval event\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Failure event\n     */\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function accrualBlockNumber() external view returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function interestRateModel() external view returns (InterestRateModel);\n\n    function totalReserves() external view returns (uint256);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@3.1.0/SafeERC20\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// Part: iearn-finance/yearn-vaults@0.4.3/VaultAPI\n\ninterface VaultAPI is IERC20 {\n    function name() external view returns (string calldata);\n\n    function symbol() external view returns (string calldata);\n\n    function decimals() external view returns (uint256);\n\n    function apiVersion() external pure returns (string memory);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 expiry,\n        bytes calldata signature\n    ) external returns (bool);\n\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\n    function deposit() external returns (uint256);\n\n    function deposit(uint256 amount) external returns (uint256);\n\n    function deposit(uint256 amount, address recipient) external returns (uint256);\n\n    // NOTE: Vyper produces multiple signatures for a given function with \"default\" args\n    function withdraw() external returns (uint256);\n\n    function withdraw(uint256 maxShares) external returns (uint256);\n\n    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\n\n    function token() external view returns (address);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n\n    function pricePerShare() external view returns (uint256);\n\n    function totalAssets() external view returns (uint256);\n\n    function depositLimit() external view returns (uint256);\n\n    function maxAvailableShares() external view returns (uint256);\n\n    /**\n     * View how much the Vault would increase this Strategy's borrow limit,\n     * based on its present performance (since its last report). Can be used to\n     * determine expectedReturn in your Strategy.\n     */\n    function creditAvailable() external view returns (uint256);\n\n    /**\n     * View how much the Vault would like to pull back from the Strategy,\n     * based on its present performance (since its last report). Can be used to\n     * determine expectedReturn in your Strategy.\n     */\n    function debtOutstanding() external view returns (uint256);\n\n    /**\n     * View how much the Vault expect this Strategy to return at the current\n     * block, based on its present performance (since its last report). Can be\n     * used to determine expectedReturn in your Strategy.\n     */\n    function expectedReturn() external view returns (uint256);\n\n    /**\n     * This is the main contact point where the Strategy interacts with the\n     * Vault. It is critical that this call is handled as intended by the\n     * Strategy. Therefore, this function will be called by BaseStrategy to\n     * make sure the integration is correct.\n     */\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtPayment\n    ) external returns (uint256);\n\n    /**\n     * This function should only be used in the scenario where the Strategy is\n     * being retired but no migration of the positions are possible, or in the\n     * extreme scenario that the Strategy needs to be put into \"Emergency Exit\"\n     * mode in order for it to exit as quickly as possible. The latter scenario\n     * could be for any reason that is considered \"critical\" that the Strategy\n     * exits its position as fast as possible, such as a sudden change in\n     * market conditions leading to losses, or an imminent failure in an\n     * external dependency.\n     */\n    function revokeStrategy() external;\n\n    /**\n     * View the governance address of the Vault to assert privileged functions\n     * can only be called by governance. The Strategy serves the Vault, so it\n     * is subject to governance defined by the Vault.\n     */\n    function governance() external view returns (address);\n\n    /**\n     * View the management address of the Vault to assert privileged functions\n     * can only be called by management. The Strategy serves the Vault, so it\n     * is subject to management defined by the Vault.\n     */\n    function management() external view returns (address);\n\n    /**\n     * View the guardian address of the Vault to assert privileged functions\n     * can only be called by guardian. The Strategy serves the Vault, so it\n     * is subject to guardian defined by the Vault.\n     */\n    function guardian() external view returns (address);\n}\n\n// Part: CErc20I\n\ninterface CErc20I is CTokenI {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        CTokenI cTokenCollateral\n    ) external returns (uint256);\n\n    function underlying() external view returns (address);\n}\n\n// Part: GenericLenderBase\n\nabstract contract GenericLenderBase is IGenericLender {\n    using SafeERC20 for IERC20;\n    VaultAPI public vault;\n    address public override strategy;\n    IERC20 public want;\n    string public override lenderName;\n    uint256 public dust;\n\n    event Cloned(address indexed clone);\n\n    constructor(address _strategy, string memory _name) public {\n        _initialize(_strategy, _name);\n    }\n\n    function _initialize(address _strategy, string memory _name) internal {\n        require(address(strategy) == address(0), \"Lender already initialized\");\n\n        strategy = _strategy;\n        vault = VaultAPI(IBaseStrategy(strategy).vault());\n        want = IERC20(vault.token());\n        lenderName = _name;\n        dust = 10000;\n\n        want.safeApprove(_strategy, uint256(-1));\n    }\n\n    function initialize(address _strategy, string memory _name) external virtual {\n        _initialize(_strategy, _name);\n    }\n\n    function _clone(address _strategy, string memory _name) internal returns (address newLender) {\n        // Copied from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n        bytes20 addressBytes = bytes20(address(this));\n\n        assembly {\n            // EIP-1167 bytecode\n            let clone_code := mload(0x40)\n            mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone_code, 0x14), addressBytes)\n            mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            newLender := create(0, clone_code, 0x37)\n        }\n\n        GenericLenderBase(newLender).initialize(_strategy, _name);\n        emit Cloned(newLender);\n    }\n\n    function setDust(uint256 _dust) external virtual override management {\n        dust = _dust;\n    }\n\n    function sweep(address _token) external virtual override management {\n        address[] memory _protectedTokens = protectedTokens();\n        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], \"!protected\");\n\n        IERC20(_token).safeTransfer(vault.governance(), IERC20(_token).balanceOf(address(this)));\n    }\n\n    function protectedTokens() internal view virtual returns (address[] memory);\n\n    modifier management() {\n        require(\n            msg.sender == address(strategy) || msg.sender == vault.governance() || msg.sender == IBaseStrategy(strategy).management(),\n            \"!management\"\n        );\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == vault.governance(), \"!gov\");\n        _;\n    }\n}\n\n// File: GenericCream.sol\n\n/********************\n *   A lender plugin for LenderYieldOptimiser for any erc20 asset on Cream (not eth)\n *   Made by SamPriestley.com\n *   https://github.com/Grandthrax/yearnv2/blob/master/contracts/GenericLender/GenericCream.sol\n *\n ********************* */\n\ncontract GenericCream is GenericLenderBase {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 private constant blocksPerYear = 2_300_000;\n    uint256 public dustThreshold;\n    CErc20I public cToken;\n\n    constructor(\n        address _strategy,\n        string memory name,\n        address _cToken\n    ) public GenericLenderBase(_strategy, name) {\n        _initialize(_cToken);\n    }\n\n    function initialize(address _cToken) external {\n        _initialize(_cToken);\n    }\n\n    function _initialize(address _cToken) internal {\n        require(address(cToken) == address(0), \"GenericCream already initialized\");\n        cToken = CErc20I(_cToken);\n        require(cToken.underlying() == address(want), \"WRONG CTOKEN\");\n        want.safeApprove(_cToken, uint256(-1));\n        dustThreshold = 10_000;\n    }\n\n    function cloneCreamLender(\n        address _strategy,\n        string memory _name,\n        address _cToken\n    ) external returns (address newLender) {\n        newLender = _clone(_strategy, _name);\n        GenericCream(newLender).initialize(_cToken);\n    }\n\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    function _nav() internal view returns (uint256) {\n        uint256 amount = want.balanceOf(address(this)).add(underlyingBalanceStored());\n        if(amount < dustThreshold){\n            return 0;\n        }else{\n            return amount;\n        }\n\n    }\n\n    function underlyingBalanceStored() public view returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr < dustThreshold) {\n            balance = 0;\n        } else {\n            //The current exchange rate as an unsigned integer, scaled by 1e18.\n            balance = currentCr.mul(cToken.exchangeRateStored()).div(1e18);\n        }\n    }\n\n    function convertFromUnderlying(uint256 amountOfUnderlying) public view returns (uint256 balance){\n        if (amountOfUnderlying == 0) {\n            balance = 0;\n        } else {\n            balance = amountOfUnderlying.mul(1e18).div(cToken.exchangeRateStored());\n        }\n    }\n\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    function _apr() internal view returns (uint256) {\n        return cToken.supplyRatePerBlock().mul(blocksPerYear);\n    }\n\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a.mul(_nav());\n    }\n\n    function withdraw(uint256 amount) external override management returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    //emergency withdraw. sends balance plus amount to governance\n    function emergencyWithdraw(uint256 amount) external override management {\n        //dont care about error here\n        cToken.redeem(amount);\n\n        want.safeTransfer(vault.governance(), want.balanceOf(address(this)));\n    }\n\n    //adjust dust threshol\n    function setDustThreshold(uint256 amount) external management {\n        dustThreshold = amount;\n    }\n\n    //withdraw an amount including any want balance\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying.add(looseBalance);\n\n        if (amount.add(dustThreshold) >= total) {\n            //cant withdraw more than we own. so withdraw all we can\n            if(balanceUnderlying > dustThreshold){\n                require(cToken.redeem(cToken.balanceOf(address(this))) == 0, \"ctoken: redeemAll fail\");\n            }\n            looseBalance = want.balanceOf(address(this));\n            want.safeTransfer(address(strategy), looseBalance);\n            return looseBalance;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        //not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount.sub(looseBalance);\n\n            //we can take all\n            if (toWithdraw > liquidity) {\n                toWithdraw = liquidity;\n            }\n            require(cToken.redeemUnderlying(toWithdraw) == 0, \"ctoken: redeemUnderlying fail\");\n\n        }\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    function deposit() external override management {\n        uint256 balance = want.balanceOf(address(this));\n        require(cToken.mint(balance) == 0, \"ctoken: mint fail\");\n    }\n\n    //we use different method to withdraw for safety\n    function withdrawAll() external override management returns (bool all) {\n        //redo or else price changes\n        cToken.mint(0);\n\n        uint256 liquidity = want.balanceOf(address(cToken));\n        uint256 liquidityInCTokens = convertFromUnderlying(liquidity);\n        uint256 amountInCtokens = cToken.balanceOf(address(this));\n\n        if (liquidityInCTokens > 2) {\n            liquidityInCTokens = liquidityInCTokens-1;\n\n            if (amountInCtokens <= liquidityInCTokens) {\n                //we can take all\n                all = true;\n                cToken.redeem(amountInCtokens);\n            } else {\n                liquidityInCTokens = convertFromUnderlying(want.balanceOf(address(cToken)));\n                //take all we can\n                all = false;\n                cToken.redeem(liquidityInCTokens);\n            }\n        }\n\n        want.safeTransfer(address(strategy), want.balanceOf(address(this)));\n        return all;\n    }\n\n    function hasAssets() external view override returns (bool) {\n        return cToken.balanceOf(address(this)) > dustThreshold;\n    }\n\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n        InterestRateModel model = cToken.interestRateModel();\n\n        //the supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior.add(amount), borrows, reserves, reserverFactor);\n\n        return supplyRate.mul(blocksPerYear);\n    }\n\n    function protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        return protected;\n    }\n}\n"}}}