{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"contracts/AtopiaApe.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/Base.sol\";\nimport \"./libs/BatchCounters.sol\";\nimport \"./interfaces/IDrawer.sol\";\n\ncontract AtopiaApe is AtopiaBase {\n\tbool public initialized;\n\tusing BatchCounters for BatchCounters.Counter;\n\tBatchCounters.Counter private _tokenIds;\n\n\tstruct Token {\n\t\taddress token;\n\t\tuint256 price;\n\t\tuint256 limit;\n\t}\n\n\tevent TraitUpdated(uint256 tokenId, uint256 tokenTrait);\n\n\tuint256 public constant saleFee = 0.06 ether;\n\tuint256 public constant BLOCK_COUNT = 1000;\n\n\tmapping(address => bool) public memberships;\n\tmapping(address => uint256) public whitelists;\n\tToken[] public tokens;\n\n\tmapping(uint256 => string) names;\n\n\tmapping(uint256 => uint256) public tokenTraits;\n\tmapping(uint256 => mapping(uint256 => uint256)) public traitStore;\n\tuint256[] blockHashes;\n\tuint256 seed;\n\n\tIDrawer public drawer;\n\n\tuint8 public state;\n\n\tfunction initialize(address bucks) public virtual override {\n\t\trequire(!initialized);\n\t\tinitialized = true;\n\t\tAtopiaBase.initialize(bucks);\n\t\tseed = uint256(keccak256(abi.encodePacked(block.difficulty, block.coinbase, block.timestamp)));\n\t}\n\n\tfunction migrateV2(uint256[] memory tokenIds) public onlyOwner {\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\tuint256 info = infos[tokenId];\n\t\t\tuint256 retired = retiredGrow[tokenId];\n\t\t\tif (retired > 0) infos[tokenId] = (((info >> 192) + retired) << 192) | uint192(info);\n\t\t}\n\t}\n\n\tfunction totalTokens() external view returns (uint256) {\n\t\treturn tokens.length;\n\t}\n\n\tfunction onlyState(uint8 _state) internal view {\n\t\trequire(state >= _state, \"Not Allowed\");\n\t}\n\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn _tokenIds.current();\n\t}\n\n\tfunction nextGenInfo(uint256 last) public pure returns (uint256, uint256) {\n\t\tif (last < 10_000) {\n\t\t\treturn (10_000_000_000, 5 * apeYear); // 10k ABUCKS\n\t\t} else if (last < 20_000) {\n\t\t\treturn (10_000_000_000, 3 * apeYear); // 10k ABUCKS\n\t\t} else if (last < 30_000) {\n\t\t\treturn (15_000_000_000, 2 * apeYear); // 15k ABUCKS\n\t\t} else if (last < 40_000) {\n\t\t\treturn (20_000_000_000, 1 * apeYear); // 20k ABUCKS\n\t\t} else {\n\t\t\treturn (25_000_000_000, 1 * apeYear); // 25k ABUCKS\n\t\t}\n\t}\n\n\tfunction blockToken(uint16 blockIndex) public view returns (uint256) {\n\t\tuint256 blockHash = blockHashes[blockIndex];\n\t\trequire(blockHash > 0);\n\t\treturn (blockHash % BLOCK_COUNT) + 1 + blockIndex * BLOCK_COUNT;\n\t}\n\n\tfunction enter(\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tuint256 _seed\n\t) internal {\n\t\tuint256 tokenTrait;\n\t\tuint256 drawerCounts = 0x00020009000a00040001000a000c000c000700070013;\n\t\tfor (uint16 i = 0; i < 11; i++) {\n\t\t\t// 12 traits\n\t\t\ttokenTrait = (tokenTrait << 16) | ((_seed & 0xFFFF) % (drawerCounts & 0xFFFF));\n\t\t\t_seed = _seed >> 16;\n\t\t\tdrawerCounts = drawerCounts >> 16;\n\t\t}\n\n\t\ttokenTraits[tokenId] = tokenTrait;\n\t\t_mint(to, tokenId);\n\t}\n\n\tfunction batch(\n\t\taddress to,\n\t\tuint256 amount,\n\t\tuint256 age\n\t) internal {\n\t\tuint256 newSeed = seed;\n\t\t(uint256 start, uint256 end) = _tokenIds.increment(amount);\n\t\tuint256 info = ((block.timestamp - age) << 64) | uint64(block.timestamp);\n\t\tfor (uint256 i = start; i <= end; i++) {\n\t\t\tinfos[i] = info;\n\n\t\t\tnewSeed = uint256(keccak256(abi.encodePacked(uint8(i), uint128(info), newSeed)));\n\t\t\tenter(to, i, newSeed);\n\n\t\t\tif (i % BLOCK_COUNT == 0) {\n\t\t\t\tblockHashes.push(newSeed);\n\t\t\t}\n\t\t}\n\t\tseed = newSeed;\n\t}\n\n\tfunction mint(uint256 amount) external payable {\n\t\tonlyState(2);\n\t\trequire(amount <= 7);\n\t\trequire(totalSupply() + amount <= 10_000);\n\t\trequire(msg.value >= saleFee * amount);\n\t\tbatch(msg.sender, amount, 5 * apeYear);\n\t}\n\n\tfunction mintPresale(uint256 amount) external payable {\n\t\tonlyState(1);\n\t\trequire(whitelists[msg.sender] >= amount);\n\t\twhitelists[msg.sender] -= amount;\n\t\trequire(totalSupply() + amount <= 10_000);\n\t\trequire(msg.value >= saleFee * amount);\n\t\tbatch(msg.sender, amount, 5 * apeYear);\n\t}\n\n\tfunction mintOG() external {\n\t\tonlyState(1);\n\t\trequire(memberships[msg.sender]);\n\t\tdelete memberships[msg.sender];\n\t\trequire(totalSupply() < 10_000);\n\t\tbatch(msg.sender, 1, 5 * apeYear);\n\t}\n\n\tfunction mintWithToken(uint256 index, uint256 amount) external {\n\t\tonlyState(1);\n\t\trequire(amount <= (state == 1 ? 3 : 7));\n\t\trequire(tokens[index].limit >= amount);\n\t\ttokens[index].limit -= amount;\n\t\trequire(totalSupply() + amount <= 10_000);\n\t\tIBucks(tokens[index].token).transferFrom(msg.sender, admin, tokens[index].price * amount);\n\t\tbatch(msg.sender, amount, 5 * apeYear);\n\t}\n\n\tfunction mintNextGen(uint256 amount) external {\n\t\tuint256 last = totalSupply();\n\t\tuint256 end = last + amount;\n\t\trequire(end <= 50_000);\n\t\trequire((last / 10_000) == (end / 10_000));\n\t\t(uint256 price, uint256 age) = nextGenInfo(end);\n\t\tbucks.burnFrom(msg.sender, price * amount);\n\t\tbatch(msg.sender, amount, age);\n\t}\n\n\tfunction setName(uint256 tokenId, string memory name) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tbucks.burnFrom(msg.sender, 10_000_000_000);\n\t\tnames[tokenId] = name;\n\t}\n\n\tfunction placeItem(\n\t\tuint256 tokenId,\n\t\tuint16 traitType,\n\t\tuint256 traitId,\n\t\tbool isStore\n\t) internal {\n\t\tuint16 traitPos = (10 - traitType) * 16;\n\t\tuint256 tokenTrait = tokenTraits[tokenId];\n\t\tuint256 exchangeId = (tokenTrait >> traitPos) & 0xFFFF;\n\n\t\tif (isStore) {\n\t\t\tuint256 store = traitStore[tokenId][traitType];\n\t\t\tuint256 count = store & 0xFFFF;\n\t\t\tstore = store >> 16;\n\t\t\tif (count == 0 && exchangeId > 0) {\n\t\t\t\tstore = exchangeId;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\ttraitStore[tokenId][traitType] = (store << 32) | (traitId << 16) | (count + 1);\n\t\t}\n\n\t\ttokenTrait = ((tokenTrait ^ (exchangeId << traitPos)) ^ 0) | (traitId << traitPos);\n\t\ttokenTraits[tokenId] = tokenTrait;\n\t\temit TraitUpdated(tokenId, tokenTrait);\n\t}\n\n\tfunction useItemFor(\n\t\tuint256 tokenId,\n\t\tuint256 itemInfo,\n\t\tuint256 amount\n\t) internal {\n\t\t// Min Age\n\t\trequire(getAge(tokenId) >= itemInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\t\titemInfo = itemInfo >> 128;\n\t\t// Bonus Trait\n\t\tif (itemInfo & 0xFFFFFFFF > 0) {\n\t\t\trequire(amount == 1);\n\t\t\tplaceItem(tokenId, uint16((itemInfo >> 16) & 0xFFFF), uint16(itemInfo & 0xFFFF), true);\n\t\t}\n\t\titemInfo = itemInfo >> 64;\n\t\t// Bonus Age\n\t\tuseItemInternal(tokenId, itemInfo * amount);\n\t}\n\n\tfunction useItem(\n\t\tuint256 tokenId,\n\t\tuint256 itemId,\n\t\tuint256 amount\n\t) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tIShop _shop = IShop(shop);\n\t\tuint256 itemInfo = _shop.itemInfo(itemId - 1);\n\t\t_shop.burn(msg.sender, itemId, amount);\n\t\tuseItemFor(tokenId, itemInfo, amount);\n\t}\n\n\tfunction buyAndUseItem(uint256 tokenId, uint256 itemInfo) external {\n\t\trequire(shop == msg.sender);\n\t\tuseItemFor(tokenId, itemInfo, 1);\n\t}\n\n\tfunction makeup(\n\t\tuint256 tokenId,\n\t\tuint16 traitType,\n\t\tuint256 storeIndex\n\t) external {\n\t\tonlyTokenOwner(tokenId);\n\t\tuint256 store = traitStore[tokenId][traitType];\n\t\tuint256 count = store & 0xFFFF;\n\t\trequire(storeIndex < count);\n\t\tplaceItem(tokenId, traitType, (store >> ((storeIndex + 1) * 16)) & 0xFFFF, false);\n\t}\n\n\tfunction claimTraits(uint16 blockIndex) external {\n\t\tuint256 tokenId = blockToken(blockIndex);\n\t\tblockHashes[blockIndex] = 0;\n\t\tuint16 traitIndex = 0x000a + blockIndex;\n\t\trequire(traitIndex < drawer.totalItems(5));\n\t\tplaceItem(tokenId, 5, traitIndex, true);\n\t\ttraitIndex = 0x0002 + blockIndex;\n\t\trequire(traitIndex < drawer.totalItems(10));\n\t\tplaceItem(tokenId, 10, traitIndex, false);\n\t}\n\n\tfunction setState(uint8 _state) external onlyOwner {\n\t\tstate = _state;\n\t}\n\n\tfunction setDrawer(address _drawer) external onlyOwner {\n\t\tdrawer = IDrawer(_drawer);\n\t\temit DrawerUpdated(_drawer);\n\t}\n\n\t// function addMembership(address[] calldata members) public onlyOwner {\n\t// \tfor (uint256 i = 0; i < members.length; i++) {\n\t// \t\tmemberships[members[i]] = true;\n\t// \t}\n\t// }\n\n\t// function addWhitelists(address[] calldata members) public onlyOwner {\n\t// \tfor (uint256 i = 0; i < members.length; i++) {\n\t// \t\twhitelists[members[i]] = 3;\n\t// \t}\n\t// }\n\n\t// function addToken(\n\t// \taddress token,\n\t// \tuint256 price,\n\t// \tuint256 limit\n\t// ) public onlyOwner {\n\t// \ttokens.push(Token(token, price, limit));\n\t// }\n\n\tfunction withdraw() external onlyOwner {\n\t\tpayable(admin).transfer(address(this).balance);\n\t}\n\n\tfunction tokenURI(uint256 tokenId) public view returns (string memory) {\n\t\trequire(ownerOf[tokenId] != address(0), \"Token Invalid\");\n\t\treturn drawer.tokenURI(tokenId, names[tokenId], tokenTraits[tokenId], uint16((getAge(tokenId) / apeYear)));\n\t}\n}\n"},"contracts/interfaces/IBucks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBucks {\n\tfunction mint(address account, uint256 amount) external;\n\n\tfunction burn(uint256 amount) external;\n\n\tfunction burnFrom(address account, uint256 amount) external;\n\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\tfunction balanceOf(address account) external view returns (uint256);\n}\n"},"contracts/interfaces/IDrawer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ITrait.sol\";\n\ninterface IDrawer {\n\tfunction totalItems(uint256 traitId) external view returns (uint256);\n\n\tfunction tokenURI(\n\t\tuint256 tokenId,\n\t\tstring memory name,\n\t\tuint256 tokenTrait,\n\t\tuint16 age\n\t) external view returns (string memory);\n}\n"},"contracts/interfaces/IShop.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IShop {\n\tfunction itemInfo(uint256 index) external view returns (uint256);\n\n\tfunction burn(\n\t\taddress account,\n\t\tuint256 id,\n\t\tuint256 value\n\t) external;\n}\n"},"contracts/interfaces/ITrait.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITrait {\n\tfunction name() external view returns (string memory);\n\n\tfunction itemCount() external view returns (uint256);\n\n\tfunction totalItems() external view returns (uint256);\n\n\tfunction getTraitName(uint16 traitId) external view returns (string memory);\n\n\tfunction getTraitContent(uint16 traitId) external view returns (string memory);\n\n\tfunction getTraitByAge(uint16 age) external view returns (uint16);\n\n\tfunction isOverEye(uint16 traitId) external view returns (bool);\n}\n"},"contracts/libs/BatchCounters.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary BatchCounters {\n\tstruct Counter {\n\t\tuint256 _value; // default: 0\n\t}\n\n\tfunction current(Counter storage counter) internal view returns (uint256) {\n\t\treturn counter._value;\n\t}\n\n\tfunction increment(Counter storage counter, uint256 amount) internal returns (uint256 start, uint256 end) {\n\t\tstart = counter._value + 1;\n\t\tcounter._value += amount;\n\t\tend = counter._value;\n\t}\n}\n"},"contracts/utils/Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"../interfaces/IBucks.sol\";\nimport \"../interfaces/IShop.sol\";\n\ninterface ISpace {\n\tfunction getLife(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 job,\n\t\t\tuint256 task,\n\t\t\tuint256 data\n\t\t);\n\n\tfunction totalCenters() external view returns (uint256);\n\n\tfunction addFeeAmount(uint256 centerId, uint256 amount) external;\n\n\tfunction grow(uint256 centerId, uint256 tokenId) external;\n\n\tfunction getGrowthAndFee(\n\t\tuint256 centerId,\n\t\tuint256 tokenId,\n\t\tuint256 growingReward\n\t) external view returns (uint256 grown, uint256 fee);\n}\n\nabstract contract AtopiaBase is ERC721 {\n\tuint256 constant apeYear = 365 days / 10;\n\n\tIBucks public bucks;\n\taddress public shop;\n\tISpace public space;\n\n\tmapping(uint256 => uint256) public infos;\n\tmapping(uint256 => uint256) public retiredGrow; // retire\n\n\tfunction initialize(address _bucks) public virtual {\n\t\tname = \"Atopia Apes\";\n\t\tsymbol = \"ATPAPE\";\n\t\tbucks = IBucks(_bucks);\n\t}\n\n\tfunction getRewardsInternal(uint256 info, uint256 timestamp) internal pure returns (uint256) {\n\t\tif (info == 0) return 0;\n\t\tuint64 claims = uint64(info);\n\t\tuint256 duration = timestamp - claims;\n\t\tuint256 averageSpeed = (timestamp + claims) / 2 + uint64(info >> 192) - (uint128(info) >> 64);\n\t\treturn (averageSpeed * duration * 20_000_000) / apeYear / 1 days;\n\t}\n\n\tfunction getAge(uint256 tokenId) public view returns (uint256) {\n\t\tuint256 info = infos[tokenId];\n\t\treturn (block.timestamp - (uint128(info) >> 64)) + (info >> 192);\n\t}\n\n\tfunction getReward(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256 reward,\n\t\t\tuint256 info,\n\t\t\tuint256 centerId,\n\t\t\tuint256 fee,\n\t\t\tuint256 grown\n\t\t)\n\t{\n\t\t(uint256 job, uint256 task, ) = space.getLife(tokenId);\n\t\tinfo = infos[tokenId];\n\t\treward = uint64(info >> 128);\n\t\tuint256 growingReward = getRewardsInternal(info, block.timestamp);\n\t\tif (job > 0 && task == 0) {\n\t\t\tcenterId = job;\n\t\t\t(grown, fee) = space.getGrowthAndFee(centerId, tokenId, growingReward);\n\t\t}\n\t\treward += growingReward;\n\t}\n\n\tfunction getRewards(uint256[] memory tokenIds) external view returns (uint256 rewards) {\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\t(uint256 reward, , , uint256 fee, ) = getReward(tokenId);\n\t\t\trewards += (reward - fee);\n\t\t}\n\t}\n\n\tfunction onlyTokenOwner(uint256 tokenId) public view {\n\t\trequire(ownerOf[tokenId] == msg.sender);\n\t}\n\n\tfunction claimRewards(uint256[] memory tokenIds) public {\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 rewards;\n\t\tuint256[] memory fees = new uint256[](space.totalCenters());\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tuint256 tokenId = tokenIds[i];\n\t\t\tonlyTokenOwner(tokenId);\n\t\t\t(uint256 reward, uint256 info, uint256 centerId, uint256 fee, uint256 grown) = getReward(tokenId);\n\t\t\tif (fee > 0) {\n\t\t\t\treward -= fee;\n\t\t\t\tfees[centerId - 1] += fee;\n\t\t\t\tspace.grow(centerId, tokenId);\n\t\t\t}\n\t\t\trewards += reward;\n\t\t\tinfos[tokenId] = (((info >> 192) + grown) << 192) | ((uint128(info) >> 64) << 64) | uint64(timestamp);\n\t\t}\n\t\tfor (uint256 i = 0; i < fees.length; i++) {\n\t\t\tuint256 fee = fees[i];\n\t\t\tif (fee > 0) {\n\t\t\t\tspace.addFeeAmount(i + 1, fee);\n\t\t\t}\n\t\t}\n\t\tbucks.mint(msg.sender, rewards);\n\t}\n\n\tfunction useItemInternal(uint256 tokenId, uint256 bonusAge) internal {\n\t\t(uint256 centerId, uint256 task, ) = space.getLife(tokenId);\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 info = infos[tokenId];\n\t\tuint256 growingReward = getRewardsInternal(info, timestamp);\n\t\tuint256 fee;\n\t\tuint256 grown;\n\t\tif (centerId > 0 && task == 0) {\n\t\t\t(grown, fee) = space.getGrowthAndFee(centerId, tokenId, growingReward);\n\t\t\tspace.grow(centerId, tokenId);\n\t\t\tspace.addFeeAmount(centerId, fee);\n\t\t}\n\t\tuint256 pending = growingReward + uint64(info >> 128) - fee;\n\t\tinfos[tokenId] =\n\t\t\t(((info >> 192) + grown + bonusAge) << 192) |\n\t\t\t(pending << 128) |\n\t\t\t((uint128(info) >> 64) << 64) |\n\t\t\tuint64(timestamp);\n\t}\n\n\tfunction onlySpace() internal view {\n\t\trequire(address(space) == msg.sender);\n\t}\n\n\tfunction claimGrowth(\n\t\tuint256 tokenId,\n\t\tuint256 grown,\n\t\tuint256 enjoyFee\n\t) external returns (uint256) {\n\t\tonlySpace();\n\t\tuint256 timestamp = block.timestamp;\n\t\tuint256 info = infos[tokenId];\n\t\tuint256 rewards = getRewardsInternal(info, timestamp);\n\t\tuint256 fee = (rewards * enjoyFee) / 10000;\n\t\tuint256 pending = rewards + uint64(info >> 128) - fee;\n\t\tinfos[tokenId] =\n\t\t\t(((info >> 192) + grown) << 192) |\n\t\t\t(pending << 128) |\n\t\t\t((uint128(info) >> 64) << 64) |\n\t\t\tuint64(timestamp);\n\t\treturn fee;\n\t}\n\n\tfunction addReward(uint256 tokenId, uint256 reward) external {\n\t\tonlySpace();\n\t\tuint256 info = infos[tokenId];\n\t\tuint256 pending = uint64(info >> 128) + reward;\n\t\tinfos[tokenId] = ((info >> 192) << 192) | (pending << 128) | ((uint128(info) >> 64) << 64) | uint64(info);\n\t}\n\n\tfunction claimBucks(address user, uint256 amount) external {\n\t\tonlySpace();\n\t\tbucks.mint(user, amount);\n\t}\n\n\tfunction setShop(address _shop) external onlyOwner {\n\t\tshop = _shop;\n\t\temit ShopUpdated(_shop);\n\t}\n\n\tfunction setSpace(address _space) external onlyOwner {\n\t\tspace = ISpace(_space);\n\t\temit SpaceUpdated(_space);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress,\n\t\taddress,\n\t\tuint256 tokenId\n\t) internal virtual override {\n\t\tuint256 timestamp = block.timestamp;\n\t\t(uint256 reward, uint256 info, uint256 centerId, uint256 fee, uint256 grown) = getReward(tokenId);\n\t\tif (fee > 0) {\n\t\t\treward -= fee;\n\t\t\tspace.addFeeAmount(centerId, fee);\n\t\t\tspace.grow(centerId, tokenId);\n\t\t}\n\t\tinfos[tokenId] = (((info >> 192) + grown) << 192) | ((uint128(info) >> 64) << 64) | uint64(timestamp);\n\t\tbucks.mint(ownerOf[tokenId], reward);\n\t}\n\n\tevent DrawerUpdated(address drawer);\n\tevent ShopUpdated(address shop);\n\tevent SpaceUpdated(address space);\n}\n"},"contracts/utils/ERC721.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\n/// including the MetaData, and partially, Enumerable extensions.\ncontract ERC721 {\n\t/*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n\tevent Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\n\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n\t/*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n\taddress implementation_;\n\taddress public admin;\n\n\tstring public name;\n\tstring public symbol;\n\n\t/*///////////////////////////////////////////////////////////////\n                             ERC-721 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n\tmapping(address => uint256) public balanceOf;\n\n\tmapping(uint256 => address) public ownerOf;\n\n\tmapping(uint256 => address) public getApproved;\n\n\tmapping(address => mapping(address => bool)) public isApprovedForAll;\n\n\t/*///////////////////////////////////////////////////////////////\n                             VIEW FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == admin);\n\t\t_;\n\t}\n\n\tfunction owner() external view returns (address) {\n\t\treturn admin;\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                              ERC-20-LIKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction transfer(address to, uint256 tokenId) external {\n\t\trequire(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\n\n\t\t_transfer(msg.sender, to, tokenId);\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                              ERC-721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\n\t\tsupported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\n\t}\n\n\tfunction approve(address spender, uint256 tokenId) external {\n\t\taddress owner_ = ownerOf[tokenId];\n\n\t\trequire(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \"NOT_APPROVED\");\n\n\t\tgetApproved[tokenId] = spender;\n\n\t\temit Approval(owner_, spender, tokenId);\n\t}\n\n\tfunction setApprovalForAll(address operator, bool approved) external {\n\t\tisApprovedForAll[msg.sender][operator] = approved;\n\n\t\temit ApprovalForAll(msg.sender, operator, approved);\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public {\n\t\trequire(\n\t\t\tmsg.sender == from || msg.sender == getApproved[tokenId] || isApprovedForAll[from][msg.sender],\n\t\t\t\"NOT_APPROVED\"\n\t\t);\n\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public {\n\t\ttransferFrom(from, to, tokenId);\n\n\t\tif (to.code.length != 0) {\n\t\t\t// selector = `onERC721Received(address,address,uint,bytes)`\n\t\t\t(, bytes memory returned) = to.staticcall(\n\t\t\t\tabi.encodeWithSelector(0x150b7a02, msg.sender, from, tokenId, data)\n\t\t\t);\n\n\t\t\tbytes4 selector = abi.decode(returned, (bytes4));\n\n\t\t\trequire(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\n\t\t}\n\t}\n\n\t/*///////////////////////////////////////////////////////////////\n                          INTERNAL UTILS\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal {\n\t\trequire(ownerOf[tokenId] == from);\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\tbalanceOf[from]--;\n\t\tbalanceOf[to]++;\n\n\t\tdelete getApproved[tokenId];\n\n\t\townerOf[tokenId] = to;\n\t\temit Transfer(msg.sender, to, tokenId);\n\t}\n\n\tfunction _mint(address to, uint256 tokenId) internal {\n\t\trequire(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\n\n\t\t// This is safe because the sum of all user\n\t\t// balances can't exceed type(uint256).max!\n\t\tunchecked {\n\t\t\tbalanceOf[to]++;\n\t\t}\n\n\t\townerOf[tokenId] = to;\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\tfunction _burn(uint256 tokenId) internal {\n\t\taddress owner_ = ownerOf[tokenId];\n\n\t\trequire(owner_ != address(0), \"NOT_MINTED\");\n\t\t_beforeTokenTransfer(owner_, address(0), tokenId);\n\n\t\tbalanceOf[owner_]--;\n\n\t\tdelete ownerOf[tokenId];\n\n\t\temit Transfer(owner_, address(0), tokenId);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal virtual {}\n}\n"}}}