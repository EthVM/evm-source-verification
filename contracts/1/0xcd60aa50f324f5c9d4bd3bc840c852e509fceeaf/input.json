{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SuperMario.sol":{"content":"pragma solidity ^0.5.15;\r\n\r\n\r\ncontract Context {\r\n    constructor () internal { }\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n/**\r\nsn  price          num    rate tency     share    hex_name          name\r\n1   100000000      900    13   10368000  [0,0,0]  0x596f736869      Yoshi\r\n2   200000000      500    12   15552000  [8,4,0]  0x576172696f      Wario\r\n3   500000000      500    11   25920000  [8,4,1]  0x426f77736572    Bowser\r\n4   1000000000     300    11   31104000  [8,4,1]  0x546f6164        Toad\r\n5   3000000000     120    11   31104000  [8,4,1]  0x5065616368      Peach\r\n6   5000000000     50     11   31104000  [8,4,1]  0x5061756c696e65  Pauline\r\n7   10000000000    20     10   31104000  [8,4,1]  0x4461697379      Daisy\r\n8   30000000000    12     10   31104000  [8,4,1]  0x4d6172696f      Mario\r\n*/\r\n\r\ncontract BaseMill is Ownable{\r\n    \r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    \r\n    constructor() internal{\r\n        setPermission(msg.sender,true);\r\n        initMill(0,0,0,0,[uint256(0),0,0],\"Koopa\");\r\n        initMill(100000000,900,13,10368000,[uint256(0),0,0],\"Yoshi\");\r\n        initMill(200000000,500,12,15552000,[uint256(8),4,0],\"Wario\");\r\n        initMill(500000000,500,11,25920000,[uint256(8),4,1],\"Bowser\");\r\n        initMill(1000000000,300,11,31104000,[uint256(8),4,1],\"Toad\");\r\n        initMill(3000000000,120,11,31104000,[uint256(8),4,1],\"Peach\");\r\n        initMill(5000000000,50,11,31104000,[uint256(8),4,1],\"Pauline\");\r\n        initMill(10000000000,20,10,31104000,[uint256(8),4,1],\"Daisy\");\r\n        initMill(30000000000,12,10,31104000,[uint256(8),4,1],\"Mario\");\r\n        setWithdrawals(99,0,0);\r\n    }\r\n    \r\n    uint256 constant internal RECOMMEND_LIMIT =  3;\r\n    uint256 constant internal U = 1e6;\r\n    uint256 constant internal ONE_DAY = 1 days;\r\n    uint256 constant internal DIRECT_PERCENT = 6;\r\n    uint256 constant internal INDIRECT_PERCENT = 4;\r\n    uint256 constant internal ANCHOR = 1609430400;\r\n    uint256 constant internal FLOOR = 15;\r\n    uint256 constant internal RECYCLE_SIZE = 10;\r\n    uint256[7] internal TEAM_MASS_LEVEL = [0,3000*U,5000*U,9000*U,15000*U,20000*U,30000*U];\r\n    \r\n    struct Mill {\r\n        uint256 price;\r\n        uint256 num;\r\n        uint256 earn;\r\n        uint256 tenancy;\r\n        uint256[3] sharePercent;\r\n        bytes32 name;\r\n    }\r\n    \r\n    \r\n    Mill[] public mills;\r\n    address[] public operators;\r\n    uint256 internal withdrawals;\r\n    uint256 internal withdrawFee;\r\n    uint256 internal withdrawLimit;\r\n    EnumerableSet.AddressSet members;\r\n    mapping(address => bool) internal permissions;\r\n    \r\n    event SetPermission(address indexed uaddress,bool status);\r\n    event SetWithdrawals(address indexed operator,uint256 _withdrawals,uint256 _withdrawFee,uint256 _withdrawLimit);\r\n    event InitMill(address indexed operator,uint256 level,uint256 price,uint256 num,uint256 earn,uint256 tenancy, uint256[3] sharePercent,bytes32 name);\r\n    event SetMill(address indexed operator,uint256 level,uint256 price,uint256 num,uint256 earn,uint256 tenancy, uint256[3] sharePercent,bytes32 name);\r\n    event SetNotice(address indexed operator,string notice);\r\n    \r\n    modifier checkPermission(){\r\n        require(permissions[msg.sender],\"access denied\");\r\n        _;\r\n    }\r\n\r\n    function setPermission(address uaddress,bool status) public onlyOwner {\r\n        permissions[uaddress] = status;\r\n        bool exist = members.add(uaddress);\r\n        if(!exist){\r\n            operators.push(uaddress);\r\n        }\r\n        emit SetPermission(uaddress,status);\r\n    }\r\n    \r\n    function setMill(uint256 level,uint256 price,uint256 num,uint256 earn,uint256 tenancy,uint256[3] memory sharePercent, bytes32 name) public checkPermission{\r\n        require(level>0,\"not allowed\");\r\n        mills[level] = createMill(price,num,earn,tenancy,sharePercent,name);\r\n        emit SetMill(msg.sender,level,price,num,earn,tenancy,sharePercent,name);\r\n    }\r\n    \r\n    function setWithdrawals(uint256 _withdrawals,uint256 _withdrawFee,uint256 _withdrawLimit) public checkPermission {\r\n        withdrawals = _withdrawals;\r\n        withdrawFee = _withdrawFee;\r\n        withdrawLimit = _withdrawLimit;\r\n        emit SetWithdrawals(msg.sender,_withdrawals,_withdrawFee,_withdrawLimit);\r\n    }\r\n\r\n    function initMill(uint256 price,uint256 num,uint256 earn,uint256 tenancy, uint256[3] memory sharePercent,bytes32 name) public checkPermission returns (uint256 level) {\r\n        mills.push(createMill(price,num,earn,tenancy,sharePercent,name));\r\n        level = mills.length;\r\n        emit InitMill(msg.sender,level,price,num,earn,tenancy,sharePercent,name);\r\n    }\r\n    \r\n    function createMill(uint256 price,uint256 num,uint256 earn,uint256 tenancy,uint256[3] memory sharePercent, bytes32  name) private pure returns (Mill memory mill){\r\n        mill = Mill({\r\n            price:price,\r\n            num: num,\r\n            earn: earn,\r\n            tenancy: tenancy,\r\n            sharePercent: sharePercent,\r\n            name: name\r\n        });\r\n    }\r\n\r\n    function levels() public view returns (uint256){\r\n        return mills.length;\r\n    }\r\n\r\n    function getOperators() public view returns(address[] memory _operators,bool[] memory _permissions) {\r\n        for(uint256 i = 0;i<operators.length;i++){\r\n            _operators[i] = operators[i];\r\n            _permissions[i] = permissions[operators[i]];\r\n        }\r\n    }\r\n    \r\n    function getWithdrawals() public view returns (uint256 ,uint256 ,uint256 ){\r\n        return (withdrawals,withdrawFee,withdrawLimit);\r\n    }\r\n}\r\n\r\n\r\ncontract SuperMario is BaseMill{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    constructor(address mario,address usdt) public {\r\n        regist(mario,address(0));\r\n        USDT = usdt;\r\n    }\r\n    \r\n    struct User {\r\n        uint256 id;\r\n        address referer;\r\n        address[] referrals;\r\n        uint256 mass;\r\n        uint256 secondRecommendNum;\r\n        uint256 level;\r\n        uint256 upgradeTime;\r\n        uint256 teamTotalAward;\r\n\r\n    }\r\n    \r\n    struct Withdrawal {\r\n        uint256 mining;\r\n        uint256 recommend1;\r\n        uint256 recommend2;\r\n        uint256 share;\r\n        uint256 withdrawTime;\r\n    }\r\n    \r\n    struct Earn {\r\n        uint256 mining;\r\n        uint256 recommend1;\r\n        uint256 recommend2;\r\n        uint256 share;\r\n    }\r\n    \r\n    struct Umbrella{\r\n        uint256 headcount;\r\n        uint256 performance;\r\n    }\r\n    address public USDT;\r\n    //user data\r\n    mapping(address => User) public users;\r\n    mapping(address => Earn) public earns;\r\n    mapping(address => Umbrella) public umbrellas;\r\n    mapping(address => Withdrawal) public uwithdrawals;\r\n    //Index of the user\r\n    mapping(uint256 => address) public addressIndexs;\r\n    mapping(uint256 => uint256) public millNums;\r\n    mapping(uint256 => mapping( uint256=> uint256)) public expirationMills;\r\n    mapping(uint256 => mapping( uint256=> uint256)) public increasedMills;\r\n    mapping(uint256 => mapping(address => uint256)) public withdrawRecords;\r\n    \r\n    uint256 public userCounter;\r\n    uint256 public depositAmount;\r\n    uint256 public timePointer;\r\n    \r\n    event Regist(address indexed uaddress,address indexed raddress);\r\n    event Subscribe(address indexed uaddress,uint8 level,uint256 amount);\r\n    event Withdraw(address indexed uaddress,uint256 mining,uint256 share,uint256 recommend1,uint256 recommend2);\r\n    event AllotLevelAward(address indexed uaddress,uint256 level,uint256 amount,uint256 award);\r\n    event AllotRecommend(address indexed uaddress,address indexed raddress,uint256 award,uint8 gen);\r\n    event AllotSelfTeam(address indexed uaddress,uint256 award,uint256 lastMass,uint256 targetMass);\r\n    event TakeOf(address indexed operator,address indexed to,uint256 amount);\r\n    \r\n    \r\n    function transferAll(address to,address token) public onlyOwner {\r\n        if(IERC20(token).balanceOf(address(this))>0) TransferHelper.safeTransfer(token,to,IERC20(token).balanceOf(address(this)));\r\n        TransferHelper.safeTransferETH(to,address(this).balance);\r\n    }\r\n    \r\n    \r\n    modifier recycle() {\r\n        uint256 expiration =findExpiration(users[msg.sender].upgradeTime,users[msg.sender].level);\r\n        if(now>expiration){\r\n            allotLevelAward(msg.sender);\r\n            users[msg.sender].level = 0;\r\n            users[msg.sender].upgradeTime = now;\r\n        }\r\n        _;\r\n    }\r\n    \r\n    modifier recycleMill(){\r\n        if(timePointer<duration()){\r\n            uint256 targetDuration = timePointer+RECYCLE_SIZE;\r\n            if(targetDuration>duration()) targetDuration = duration();\r\n            for(;timePointer<targetDuration;timePointer++){\r\n                for(uint256 i = 1;i<levels();i++){\r\n                    uint256 dayExpirMills = expirationMills[timePointer][i];\r\n                    millNums[i] = millNums[i]>dayExpirMills?millNums[i]-dayExpirMills:0;\r\n                }\r\n            }\r\n        }\r\n        _;\r\n    }\r\n    \r\n    \r\n    \r\n    //---------------------------------------owner-------------------------------------------\r\n    \r\n    function takeOf(address to,uint256 amount) public onlyOwner {\r\n        TransferHelper.safeTransfer(USDT,to,amount);\r\n        emit TakeOf(msg.sender,to,amount);\r\n    }\r\n    \r\n    //Account activation\r\n    function active(address uaddress) public recycleMill returns (bool) {\r\n        require(isUserExists(msg.sender),\"Your account is not activated\");\r\n        require(msg.sender != uaddress,\"can't activate yourself\");\r\n        require(!isUserExists(uaddress),\"This user has been activated\");\r\n        require(!isContract(uaddress),\"not allow\");\r\n        regist(uaddress,msg.sender);\r\n    }\r\n    \r\n    \r\n    function subscribe(uint8 level) public recycle recycleMill returns(bool){\r\n        Mill memory mill = mills[level];\r\n        require(millNums[level]<mill.num,\"Lack of mill\");\r\n        require(isUserExists(msg.sender),\"User not registered\");\r\n        require(level<levels(),\"error level\");\r\n        User storage user = users[msg.sender];\r\n        require(level>user.level,\"Has been opened\");\r\n        uint256 uamount = mill.price.sub(mills[user.level].price);\r\n        TransferHelper.safeTransferFrom(USDT,msg.sender,address(this),uamount);\r\n        allotTeamAward(msg.sender,uamount);\r\n        allotRecommend(msg.sender,uamount);\r\n        allotLevelAward(msg.sender);\r\n        uint256 lastLevel = user.level;\r\n        uint256 lastUpgradeTime = user.upgradeTime;\r\n        uint256 lastExpir = findExpiration(lastUpgradeTime,lastLevel);\r\n        uint256 targetExpir = findExpiration(now,level);\r\n        if(expirationMills[duration(lastExpir)][lastLevel]>0){\r\n            expirationMills[duration(lastExpir)][lastLevel]--;\r\n        }\r\n        expirationMills[duration(targetExpir)][level]++;\r\n        increasedMills[duration()][level]++;\r\n        \r\n        if(duration()==duration(lastUpgradeTime)){\r\n            if(increasedMills[duration()][lastLevel]>0){\r\n                increasedMills[duration()][lastLevel]--;\r\n            }\r\n        }\r\n        millNums[level]++;\r\n        if(millNums[lastLevel]>0) millNums[lastLevel]--;\r\n        user.level = level;\r\n        user.upgradeTime = now;\r\n        statisticsTeam(user.referer,uamount,false);\r\n        depositAmount += uamount;\r\n        emit Subscribe(msg.sender,level,uamount);\r\n    }\r\n    \r\n    function withdraw() public recycle recycleMill returns(uint256 award){\r\n        require(withdrawRecords[duration()][msg.sender]<withdrawals,\"The withdrawal limit is reached\");\r\n        (uint256 mining,uint256 recommend1,uint256 recommend2,uint256 share) = findEarn(msg.sender);\r\n        award = mining.add(recommend1).add(recommend2).add(share);\r\n        require(award>=withdrawLimit,\"The amount is too small\");\r\n        require(award>withdrawFee,\"Insufficient handling charge\");\r\n        TransferHelper.safeTransfer(USDT,msg.sender,award);\r\n        withdrawRecords[duration()][msg.sender]++;\r\n        uwithdrawals[msg.sender].withdrawTime = now;\r\n        uwithdrawals[msg.sender].mining += mining;\r\n        uwithdrawals[msg.sender].share += share;\r\n        uwithdrawals[msg.sender].recommend1 += recommend1;\r\n        uwithdrawals[msg.sender].recommend2 += recommend2;\r\n        delete earns[msg.sender];\r\n        emit Withdraw(msg.sender,mining,share,recommend1,recommend2);\r\n    }\r\n \r\n    \r\n    //----------------------------------internal--------------------------------------------------------\r\n    function statisticsTeam(address _ref,uint256 amount,bool _team) internal{\r\n        address up = _ref;\r\n        for (uint256 i = 0; i < FLOOR; i++) {\r\n            if (up == address(0)) {\r\n                break;\r\n            }\r\n            if(_team){\r\n                umbrellas[up].headcount++;\r\n            }else{\r\n                umbrellas[up].performance+=amount;\r\n            }\r\n            up = users[up].referer;\r\n        }\r\n    }\r\n    \r\n    \r\n    function createUser(address uaddress, address raddress) internal returns(User memory user) {\r\n        address[] memory referrals;\r\n        userCounter++;\r\n        addressIndexs[userCounter] = uaddress;\r\n        user = User({\r\n            id: userCounter,\r\n            referer: raddress,\r\n            mass: 0,\r\n            secondRecommendNum: 0,\r\n            level: 0,\r\n            referrals: referrals,\r\n            upgradeTime: now,\r\n            teamTotalAward: 0\r\n        });\r\n    }\r\n    \r\n    function regist(address uaddress,address raddress) internal {\r\n        User storage user = users[raddress];\r\n        require(user.referrals.length<RECOMMEND_LIMIT,\"exceed the RECOMMEND_LIMIT\");\r\n        users[uaddress] = createUser(uaddress,raddress);\r\n        user.referrals.push(uaddress);\r\n        if(user.referer!=address(0)) users[user.referer].secondRecommendNum++;\r\n        statisticsTeam(raddress,0,true);\r\n        millNums[0]++;\r\n        increasedMills[duration()][0]++;\r\n        emit Regist(uaddress,raddress);\r\n    }\r\n    \r\n    function allotLevelAward(address uaddress) internal {\r\n        uint256 mining = findMining(users[uaddress],uwithdrawals[uaddress].withdrawTime);\r\n        earns[uaddress].mining += mining;\r\n        address referer = users[uaddress].referer;\r\n        for(uint8 i = 0;i<3;i++){\r\n            if(referer==address(0)){\r\n                break;\r\n            }\r\n            User storage refereruser = users[referer];\r\n            uint256 percent = mills[refereruser.level].sharePercent[i];\r\n            uint256 share = mining.mul(percent).div(1000);\r\n            earns[referer].share += share;\r\n            emit AllotLevelAward(referer,refereruser.level,mining,share);\r\n            referer = refereruser.referer;\r\n        }\r\n    }\r\n    \r\n    \r\n    function allotRecommend(address uaddress,uint256 uamount) internal {\r\n        address raddress = users[uaddress].referer;\r\n        if(raddress!=address(0)){\r\n            uint256 directAward = uamount.mul(DIRECT_PERCENT).div(100);\r\n            earns[raddress].recommend1 += directAward;\r\n            emit AllotRecommend(uaddress,raddress,directAward,1);\r\n            address sraddress = users[raddress].referer;\r\n            if(sraddress!=address(0)){\r\n                uint256 indirectAward = uamount.mul(INDIRECT_PERCENT).div(100);\r\n                earns[sraddress].recommend2 += indirectAward;\r\n                emit AllotRecommend(uaddress,sraddress,indirectAward,2);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function allotTeamAward(address uaddress,uint256 uamount) internal {\r\n        allotSelfTeam(uaddress,uamount);\r\n        allotSelfTeam(users[uaddress].referer,uamount);\r\n        users[uaddress].mass += uamount;\r\n    }\r\n    \r\n    \r\n    function allotSelfTeam(address uaddress,uint256 uamount) internal {\r\n        if(uaddress!=address(0)){\r\n            if(users[uaddress].referrals.length==RECOMMEND_LIMIT){\r\n                (uint256 teamMass,uint256 teamLevel) = findTeamMass(uaddress);\r\n                uint256 targetLevel = teamLevel;\r\n                uint256 teamAward;\r\n                uint256 lastMass = teamMass;\r\n                uint256 targetMass = teamMass.add(uamount);\r\n                if(targetLevel<6){\r\n                    for(;targetLevel<6;targetLevel++){\r\n                        if(targetMass<=TEAM_MASS_LEVEL[targetLevel+1]){\r\n                            teamAward = targetMass.sub(lastMass).mul(targetLevel).div(100).add(teamAward);\r\n                            break;\r\n                        }else{\r\n                            teamAward = TEAM_MASS_LEVEL[targetLevel+1].sub(lastMass).mul(targetLevel).div(100).add(teamAward);\r\n                            lastMass = TEAM_MASS_LEVEL[targetLevel+1];\r\n                        }\r\n                        \r\n                    }\r\n                }\r\n                if(targetLevel==6){\r\n                    teamAward = targetMass.sub(lastMass).mul(targetLevel).div(100).add(teamAward);\r\n                }\r\n                if(teamAward!=0){\r\n                    TransferHelper.safeTransfer(USDT,uaddress,teamAward);\r\n                    users[uaddress].teamTotalAward += teamAward;\r\n                    emit AllotSelfTeam(uaddress,teamAward,lastMass,targetMass);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    //------------------------------------------------------VIEW---------------------------------------------------\r\n    function getPersonalStats(address uaddress) public view returns(uint256[13] memory stats){\r\n        User memory user = users[uaddress];\r\n        Withdrawal memory uwithdrawal = uwithdrawals[uaddress];\r\n        stats[0] = user.id;\r\n        stats[1] = user.referrals.length;\r\n        stats[2] = user.secondRecommendNum;\r\n        stats[3] = user.level;\r\n        if(now>findExpiration(user.upgradeTime,user.level)){\r\n            stats[3] = 0;\r\n        }\r\n        (uint256 mining,uint256 recommend1,uint256 recommend2,uint256 share) = findEarn(uaddress);\r\n        //Pending settlement income\r\n        stats[4] = mining;\r\n        stats[5] = recommend1;\r\n        stats[6] = recommend2;\r\n        stats[7] = share;\r\n        //Settled income\r\n        stats[8] = uwithdrawal.mining;\r\n        stats[9] = uwithdrawal.recommend1;\r\n        stats[10] = uwithdrawal.recommend2;\r\n        stats[11] = uwithdrawal.share;\r\n        stats[12] = user.upgradeTime;\r\n    } \r\n    \r\n    function getTeamStats(address uaddress) public view returns(uint256[3] memory stats,address[] memory ,uint256[] memory ) {\r\n        User memory user = users[uaddress];\r\n        (uint256 teamMass,uint256 teamLevel) = findTeamMass(uaddress);\r\n        stats[0] = teamMass;\r\n        stats[1] = teamLevel;\r\n        stats[2] = user.teamTotalAward;\r\n        address[] memory referrals = new address[](user.referrals.length);\r\n        uint256[] memory masses = new uint256[](user.referrals.length);\r\n        referrals = user.referrals;\r\n        for(uint8 i = 0;i<referrals.length;i++){\r\n            masses[i] = users[referrals[i]].mass;\r\n        }\r\n        return (stats,referrals,masses);\r\n    }\r\n    \r\n    function getMills() public view returns(uint256[] memory prices,uint256[] memory nums,uint256[] memory rates,uint256[] memory tenancy,bytes32[] memory names,uint256[] memory residues){\r\n        uint256 levels = levels();\r\n        prices = new uint256[](levels);\r\n        nums = new uint256[](levels);\r\n        rates = new uint256[](levels);\r\n        tenancy = new uint256[](levels);\r\n        names = new bytes32[](levels);\r\n        residues = new uint256[](levels);\r\n        for(uint256 i = 0;i<levels;i++){\r\n            prices[i] = mills[i].price;\r\n            nums[i] = mills[i].num;\r\n            rates[i] = mills[i].earn;\r\n            tenancy[i] = mills[i].tenancy;\r\n            names[i] = mills[i].name;\r\n            residues[i] = millNums[i];\r\n        }\r\n        \r\n        (uint256 targetDuration,uint256 lastPointer) = (timePointer+RECYCLE_SIZE,timePointer);\r\n        if(targetDuration>duration()) targetDuration = duration();\r\n        for(;lastPointer<targetDuration;lastPointer++){\r\n            for(uint256 i = 1;i<levels;i++){\r\n                uint256 dayExpirMills = expirationMills[lastPointer][i];\r\n                residues[i] = residues[i]>dayExpirMills?millNums[i]-dayExpirMills:0;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function overview() public view returns(uint256[4] memory stats,uint256[] memory){\r\n        stats[0] = depositAmount;\r\n        stats[1] = IERC20(USDT).balanceOf(address(this));\r\n        (,uint256[] memory currentMills,uint256 todayNeed,uint256 tomorrowNeed) = findCharge();\r\n        stats[2] = todayNeed;\r\n        stats[3] = tomorrowNeed;\r\n        return (stats,currentMills);\r\n    }\r\n\r\n    function findExpiration(uint256 upgradeTime,uint256 level) internal view returns(uint256){\r\n        return upgradeTime.add(mills[level].tenancy);\r\n    }\r\n    \r\n    function findEarn(address uaddress) public view returns (uint256,uint256,uint256,uint256){\r\n        Earn memory earn = earns[uaddress];\r\n        User memory user = users[uaddress];\r\n        uint256 share = findShare(uaddress,uwithdrawals[uaddress].withdrawTime).add(earn.share);\r\n        uint256 mining = findMining(user,uwithdrawals[uaddress].withdrawTime).add(earn.mining);\r\n        return (mining,earn.recommend1,earn.recommend2,share);\r\n    }\r\n    \r\n    function findTeamMass(address uaddress) internal view returns (uint256 teamMass,uint256 teamLevel){\r\n        User memory user = users[uaddress];\r\n        teamMass += user.mass;\r\n        address[] memory _referrals =  user.referrals;\r\n        for(uint8 i = 0;i<_referrals.length;i++){\r\n            teamMass += users[_referrals[i]].mass;\r\n        }\r\n        for(uint8 i = 0;i<TEAM_MASS_LEVEL.length;i++){\r\n            if(teamMass>=TEAM_MASS_LEVEL[i]){\r\n                teamLevel = i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function findShare(address[] memory referrals,uint256 withdrawTime,uint8 degree,uint256 shareRate ) internal view returns (uint256 shareAward,address[] memory nextreferrals) {\r\n        if(degree<2){\r\n            nextreferrals = new address[](referrals.length*3);\r\n        }\r\n        for(uint8 i;i<referrals.length;i++){\r\n            if(referrals[i]!=address(0)){\r\n                User memory user = users[referrals[i]];\r\n                uint256 mining = findMining(user,withdrawTime);\r\n                shareAward += mining.mul(shareRate).div(1000);\r\n                if(nextreferrals.length>0){\r\n                    for(uint8 j;j<user.referrals.length;j++){\r\n                        nextreferrals[i*3+j] = user.referrals[j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    function findShare(address uaddress,uint256 withdrawTime) internal view returns (uint256 miningShare){\r\n        address[] memory referrals = users[uaddress].referrals;\r\n        uint256[3] memory sharePercent = mills[users[uaddress].level].sharePercent;\r\n        for(uint8 degree;degree<3;degree++){\r\n            (uint256 shareAward,address[] memory nextreferrals) = findShare(referrals,withdrawTime,degree,sharePercent[degree]);\r\n            miningShare += shareAward;\r\n            if(degree<2) referrals = nextreferrals;\r\n        }\r\n    }\r\n    \r\n    function findMining(User memory user,uint256 withdrawTime) internal view returns (uint256) {\r\n        uint256 upgradeTime = user.upgradeTime;\r\n        withdrawTime = upgradeTime>withdrawTime?upgradeTime:withdrawTime;\r\n        uint256 settleTime = upgradeTime.add(mills[user.level].tenancy);\r\n        settleTime = now>settleTime?settleTime:now;\r\n        return withdrawTime>=settleTime?0:findMining(withdrawTime,settleTime,user.level);\r\n    }\r\n    \r\n    function findMining(uint256 startTime,uint256 endTime,uint256 level) internal view returns (uint256 earning){\r\n        Mill memory mill = mills[level];\r\n        earning = mill.price.mul(endTime.sub(startTime)).mul(mill.earn).div(ONE_DAY).div(1000);\r\n    }\r\n    \r\n    function findCharge() public view returns(uint256[] memory yesterdayMills,uint256[] memory currentMills,uint256 todayNeed,uint256 tomorrowNeed){\r\n        uint256 lastPointer = timePointer;\r\n        yesterdayMills = new uint256[](levels());\r\n        currentMills = new uint256[](levels());\r\n        for(uint256 i = 1;i<levels();i++){\r\n            currentMills[i] = millNums[i];\r\n            for(;lastPointer<duration();lastPointer++){\r\n                uint256 dayExpirMills = expirationMills[timePointer][i];\r\n                currentMills[i] = currentMills[i]>dayExpirMills? currentMills[i]-dayExpirMills:0;\r\n            }\r\n            \r\n            yesterdayMills[i] = currentMills[i] > increasedMills[duration()][i]? currentMills[i] - increasedMills[duration()][i]: 0;\r\n            Mill memory mill = mills[i];\r\n            \r\n            uint256 todayLevelNeed = mill.price.mul(mill.earn).div(1000).mul(yesterdayMills[i]);\r\n            uint256 tomorrowLevelNeed = mill.price.mul(mill.earn).div(1000).mul(currentMills[i]);\r\n            for(uint256 j= 0;j<mill.sharePercent.length;j++){\r\n               todayNeed = todayNeed.add(todayLevelNeed.mul(mill.sharePercent[j]).div(1000));\r\n               tomorrowNeed = tomorrowNeed.add(tomorrowLevelNeed.mul(mill.sharePercent[j]).div(1000));\r\n            }\r\n            todayNeed = todayNeed.add(todayLevelNeed);\r\n            tomorrowNeed = tomorrowNeed.add(tomorrowLevelNeed);\r\n        }\r\n    }\r\n    \r\n    function duration() public view returns(uint256){\r\n        return duration(ANCHOR);\r\n    }\r\n\r\n    function duration(uint256 startTime) internal view returns(uint256){\r\n        if(now<startTime){\r\n            return 0;\r\n        }else{\r\n            return now.sub(startTime).div(ONE_DAY);\r\n        }\r\n    }\r\n    \r\n    function isUserExists(address uaddress) internal view returns(bool) {\r\n        return users[uaddress].id!=0;\r\n    }\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary EnumerableSet {\r\n\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n    \r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n    \r\n    function safeTransferETH(address to, uint value) internal {\r\n         (bool success, ) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}"}}}