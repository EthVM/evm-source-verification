{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Holdefi_mainnet/AggregatorV3Interface.sol":{"content":"pragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"},"Holdefi_mainnet/HoldefiOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n/// @title HoldefiOwnable\n/// @author Holdefi Team\n/// @notice Taking ideas from Open Zeppelin's Ownable contract\n/// @dev Contract module which provides a basic access control mechanism, where\n/// there is an account (an owner) that can be granted exclusive access to\n/// specific functions.\n///\n/// By default, the owner account will be the one that deploys the contract. This\n/// can later be changed with {transferOwnership}.\n///\n/// This module is used through inheritance. It will make available the modifier\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\n/// the owner.\ncontract HoldefiOwnable {\n    address public owner;\n    address public pendingOwner;\n\n    /// @notice Event emitted when an ownership transfer request is recieved\n    event OwnershipTransferRequested(address newPendingOwner);\n\n    /// @notice Event emitted when an ownership transfer request is accepted by the pending owner\n    event OwnershipTransferred(address newOwner, address oldOwner);\n\n    /// @notice Initializes the contract owner\n    constructor () public {\n        owner = msg.sender;\n        emit OwnershipTransferred(owner, address(0));\n    }\n\n    /// @notice Throws if called by any account other than the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Sender should be owner\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new owner\n    /// @dev Can only be called by the current owner\n    /// @param newOwner Address of new owner\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"New owner can not be zero address\");\n        pendingOwner = newOwner;\n\n        emit OwnershipTransferRequested(newOwner);\n    }\n\n    /// @notice Pending owner accepts ownership of the contract\n    /// @dev Only Pending owner can call this function\n    function acceptTransferOwnership () external {\n        require (pendingOwner != address(0), \"Pending owner is empty\");\n        require (pendingOwner == msg.sender, \"Pending owner is not same as sender\");\n        \n        emit OwnershipTransferred(pendingOwner, owner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}"},"Holdefi_mainnet/HoldefiPrices.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\n\r\nimport \"./AggregatorV3Interface.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./HoldefiOwnable.sol\";\r\n\r\ninterface ERC20DecimalInterface {\r\n    function decimals () external view returns(uint256 res);\r\n}\r\n/// @title HoldefiPrices contract\r\n/// @author Holdefi Team\r\n/// @notice This contract is for getting tokens price\r\n/// @dev This contract uses Chainlink Oracle to get the tokens price\r\n/// @dev The address of ETH asset considered as 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\ncontract HoldefiPrices is HoldefiOwnable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address constant public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    uint256 constant public valueDecimals = 30;\r\n\r\n    struct Asset {\r\n        uint256 decimals;\r\n        AggregatorV3Interface priceContract;\r\n    }\r\n   \r\n    mapping(address => Asset) public assets;\r\n\r\n    /// @notice Event emitted when a new price aggregator is set for an asset\r\n    event NewPriceAggregator(address indexed asset, uint256 decimals, address priceAggregator);\r\n\r\n\t/// @notice Initializes ETH decimals\r\n    constructor() public {\r\n        assets[ethAddress].decimals = 18;\r\n    }\r\n\r\n    /// @notice You cannot send ETH to this contract\r\n    receive() payable external {\r\n        revert();\r\n    }\r\n\r\n    /// @notice Gets price of selected asset from Chainlink\r\n\t/// @dev The ETH price is assumed to be 1\r\n\t/// @param asset Address of the given asset\r\n    /// @return price Price of the given asset\r\n    /// @return priceDecimals Decimals of the given asset\r\n    function getPrice(address asset) public view returns (uint256 price, uint256 priceDecimals) {\r\n        if (asset == ethAddress){\r\n            price = 1;\r\n            priceDecimals = 0;\r\n        }\r\n        else {\r\n            (,int aggregatorPrice,,,) = assets[asset].priceContract.latestRoundData();\r\n            priceDecimals = assets[asset].priceContract.decimals();\r\n            if (aggregatorPrice > 0) {\r\n                price = uint(aggregatorPrice);\r\n            }\r\n            else {\r\n                revert();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Sets price aggregator for the given asset \r\n\t/// @param asset Address of the given asset\r\n    /// @param decimals Decimals of the given asset\r\n    /// @param priceContractAddress Address of asset's price aggregator\r\n    function setPriceAggregator(address asset, uint256 decimals, AggregatorV3Interface priceContractAddress)\r\n        external\r\n        onlyOwner\r\n    { \r\n        require (asset != ethAddress, \"Asset should not be ETH\");\r\n        assets[asset].priceContract = priceContractAddress;\r\n\r\n        try ERC20DecimalInterface(asset).decimals() returns (uint256 tokenDecimals) {\r\n            assets[asset].decimals = tokenDecimals;\r\n        }\r\n        catch {\r\n            assets[asset].decimals = decimals;\r\n        }\r\n        emit NewPriceAggregator(asset, decimals, address(priceContractAddress));\r\n    }\r\n\r\n    /// @notice Calculates the given asset value based on the given amount \r\n\t/// @param asset Address of the given asset\r\n    /// @param amount Amount of the given asset\r\n    /// @return res Value calculated for asset based on the price and given amount\r\n    function getAssetValueFromAmount(address asset, uint256 amount) external view returns (uint256 res) {\r\n        uint256 decimalsDiff;\r\n        uint256 decimalsScale;\r\n\r\n        (uint256 price, uint256 priceDecimals) = getPrice(asset);\r\n        uint256 calValueDecimals = priceDecimals.add(assets[asset].decimals);\r\n        if (valueDecimals > calValueDecimals){\r\n            decimalsDiff = valueDecimals.sub(calValueDecimals);\r\n            decimalsScale =  10 ** decimalsDiff;\r\n            res = amount.mul(price).mul(decimalsScale);\r\n        }\r\n        else {\r\n            decimalsDiff = calValueDecimals.sub(valueDecimals);\r\n            decimalsScale =  10 ** decimalsDiff;\r\n            res = amount.mul(price).div(decimalsScale);\r\n        }   \r\n    }\r\n\r\n    /// @notice Calculates the given amount based on the given asset value\r\n    /// @param asset Address of the given asset\r\n    /// @param value Value of the given asset\r\n    /// @return res Amount calculated for asset based on the price and given value\r\n    function getAssetAmountFromValue(address asset, uint256 value) external view returns (uint256 res) {\r\n        uint256 decimalsDiff;\r\n        uint256 decimalsScale;\r\n\r\n        (uint256 price, uint256 priceDecimals) = getPrice(asset);\r\n        uint256 calValueDecimals = priceDecimals.add(assets[asset].decimals);\r\n        if (valueDecimals > calValueDecimals){\r\n            decimalsDiff = valueDecimals.sub(calValueDecimals);\r\n            decimalsScale =  10 ** decimalsDiff;\r\n            res = value.div(decimalsScale).div(price);\r\n        }\r\n        else {\r\n            decimalsDiff = calValueDecimals.sub(valueDecimals);\r\n            decimalsScale =  10 ** decimalsDiff;\r\n            res = value.mul(decimalsScale).div(price);\r\n        }   \r\n    }\r\n}"},"Holdefi_mainnet/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"}}}