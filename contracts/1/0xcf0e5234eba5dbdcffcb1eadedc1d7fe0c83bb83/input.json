{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "GovernanceV2.sol": {
      "content": "// File: contracts/interfaces/IAllMarkets.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IAllMarkets {\r\n\r\n\tenum PredictionStatus {\r\n      Live,\r\n      InSettlement,\r\n      Cooling,\r\n      InDispute,\r\n      Settled\r\n    }\r\n\r\n    function marketStatus(uint256 _marketId) public view returns(PredictionStatus);\r\n\r\n    function burnDisputedProposalTokens(uint _proposaId) external;\r\n\r\n    function getTotalStakedValueInPLOT(uint256 _marketId) public view returns(uint256);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IMarketCreationRewards.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarketCreationRewards {\r\n\r\n    function calculateMarketCreationIncentive(address _createdBy, uint256 _gasCosumed, uint64 _marketId) external;    \r\n\r\n    function depositMarketRewardPoolShare(uint256 _marketId, uint256 _ethShare, uint256 _plotShare, uint64 _ethDeposit, uint64 _plotDeposit) external payable;\r\n\r\n    function returnMarketRewardPoolShare(uint256 _marketId) external;\r\n\r\n    function getMarketCreatorRPoolShareParams(uint256 _market, uint256 plotStaked, uint256 ethStaked) external view returns(uint16, bool);\r\n\r\n    function transferAssets(address _asset, address _to, uint _amount) external;\r\n\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IGovernance.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IGovernance { \r\n\r\n    event Proposal(\r\n        address indexed proposalOwner,\r\n        uint256 indexed proposalId,\r\n        uint256 dateAdd,\r\n        string proposalTitle,\r\n        string proposalSD,\r\n        string proposalDescHash\r\n    );\r\n\r\n    event Solution(\r\n        uint256 indexed proposalId,\r\n        address indexed solutionOwner,\r\n        uint256 indexed solutionId,\r\n        string solutionDescHash,\r\n        uint256 dateAdd\r\n    );\r\n\r\n    event Vote(\r\n        address indexed from,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed voteId,\r\n        uint256 dateAdd,\r\n        uint256 solutionChosen\r\n    );\r\n\r\n    event RewardClaimed(\r\n        address indexed member,\r\n        uint gbtReward\r\n    );\r\n\r\n    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \r\n    event VoteCast (uint256 proposalId);\r\n\r\n    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \r\n    ///      call any offchain actions\r\n    event ProposalAccepted (uint256 proposalId);\r\n\r\n    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\r\n    event CloseProposalOnTime (\r\n        uint256 indexed proposalId,\r\n        uint256 time\r\n    );\r\n\r\n    /// @dev ActionSuccess event is called whenever an onchain action is executed.\r\n    event ActionSuccess (\r\n        uint256 proposalId\r\n    );\r\n\r\n    /// @dev Creates a new proposal\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    function createProposal(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint _categoryId\r\n    ) \r\n        external;\r\n\r\n    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    function categorizeProposal(\r\n        uint _proposalId, \r\n        uint _categoryId,\r\n        uint _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev Submit proposal with solution\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Creates a new proposal with solution and votes for the solution\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Casts vote\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external;\r\n\r\n    function closeProposal(uint _proposalId) external;\r\n\r\n    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \r\n\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalReward\r\n        );\r\n\r\n    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\r\n\r\n    function allowedToCatgorize() public view returns(uint roleId);\r\n\r\n    /**\r\n     * @dev Gets length of propsal\r\n     * @return length of propsal\r\n     */\r\n    function getProposalLength() external view returns(uint);\r\n\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IProposalCategory.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IProposalCategory {\r\n\r\n    event Category(\r\n        uint indexed categoryId,\r\n        string categoryName,\r\n        string actionHash\r\n    );\r\n\r\n    mapping(uint256 => bytes) public categoryActionHashes;\r\n\r\n    /**\r\n    * @dev Adds new category\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    * @param _functionHash function signature to be executed\r\n    */\r\n    function newCategory(\r\n        string calldata _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives,\r\n        string calldata _functionHash\r\n    )\r\n        external;\r\n\r\n    /** @dev gets category details\r\n    */\r\n    function category(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            uint memberRoleToVote,\r\n            uint majorityVotePerc,\r\n            uint quorumPerc,\r\n            uint[] memory allowedToCreateProposal,\r\n            uint closingTime,\r\n            uint minStake\r\n        );\r\n    \r\n    /**@dev gets category action details\r\n    */\r\n    function categoryAction(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            address contractAddress,\r\n            bytes2 contractName,\r\n            uint defaultIncentive\r\n        );\r\n    \r\n    /** @dev Gets Total number of categories added till now\r\n    */\r\n    function totalCategories() external view returns(uint numberOfCategories);\r\n\r\n    /**\r\n     * @dev Gets the category acion details of a category id\r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     * @return action function hash\r\n     */\r\n    function categoryActionDetails(uint256 _categoryId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            address,\r\n            bytes2,\r\n            uint256,\r\n            bytes memory\r\n        );\r\n\r\n    /**\r\n    * @dev Updates category details\r\n    * @param _categoryId Category id that needs to be updated\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    * @param _functionHash function signature to be executed\r\n    */\r\n    function editCategory(\r\n        uint _categoryId, \r\n        string calldata _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives,\r\n        string calldata _functionHash\r\n    )\r\n        external;\r\n\r\n}\r\n\r\n// File: contracts/external/govblocks-protocol/interfaces/IMemberRoles.sol\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\ncontract IMemberRoles {\r\n\r\n    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n    \r\n    enum Role {UnAssigned, AdvisoryBoard, TokenHolder, DisputeResolution}\r\n\r\n    function setInititorAddress(address _initiator) external;\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _authorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _authorized) public;\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256);\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint);\r\n    \r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address);\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \r\n}\r\n\r\n// File: contracts/external/proxy/Proxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\n// File: contracts/external/proxy/UpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath128 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        uint128 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint128 a, uint128 b, string memory errorMessage) internal pure returns (uint128) {\r\n        require(b <= a, errorMessage);\r\n        uint128 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint128 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint128 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b <= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b <= a, errorMessage);\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint32 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/Iupgradable.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract Iupgradable {\r\n\r\n    /**\r\n     * @dev change master address\r\n     */\r\n    function setMasterAddress() public;\r\n}\r\n\r\n// File: contracts/interfaces/IMarketRegistry.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarketRegistry {\r\n\r\n    enum MarketType {\r\n      HourlyMarket,\r\n      DailyMarket,\r\n      WeeklyMarket\r\n    }\r\n    address public owner;\r\n    address public tokenController;\r\n    address public marketUtility;\r\n    bool public marketCreationPaused;\r\n\r\n    mapping(address => bool) public isMarket;\r\n    function() external payable{}\r\n\r\n    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\r\n\r\n    function burnDisputedProposalTokens(uint _proposaId) external;\r\n\r\n    function isWhitelistedSponsor(address _address) public view returns(bool);\r\n\r\n    function transferAssets(address _asset, address _to, uint _amount) external;\r\n\r\n    /**\r\n    * @dev Initialize the PlotX.\r\n    * @param _marketConfig The address of market config.\r\n    * @param _plotToken The address of PLOT token.\r\n    */\r\n    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\r\n\r\n    /**\r\n    * @dev Create proposal if user wants to raise the dispute.\r\n    * @param proposalTitle The title of proposal created by user.\r\n    * @param description The description of dispute.\r\n    * @param solutionHash The ipfs solution hash.\r\n    * @param actionHash The action hash for solution.\r\n    * @param stakeForDispute The token staked to raise the diospute.\r\n    * @param user The address who raises the dispute.\r\n    */\r\n    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the PlacePrediction event and sets user data.\r\n    * @param _user The address who placed prediction.\r\n    * @param _value The amount of ether user staked.\r\n    * @param _predictionPoints The positions user will get.\r\n    * @param _predictionAsset The prediction assets user will get.\r\n    * @param _prediction The option range on which user placed prediction.\r\n    * @param _leverage The leverage selected by user at the time of place prediction.\r\n    */\r\n    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\r\n    }\r\n\r\n    /**\r\n    * @dev Emits the claimed event.\r\n    * @param _user The address who claim their reward.\r\n    * @param _reward The reward which is claimed by user.\r\n    * @param incentives The incentives of user.\r\n    * @param incentiveToken The incentive tokens of user.\r\n    */\r\n    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\r\n    }\r\n\r\n        /**\r\n    * @dev Emits the MarketResult event.\r\n    * @param _totalReward The amount of reward to be distribute.\r\n    * @param _winningOption The winning option of the market.\r\n    * @param _closeValue The closing value of the market currency.\r\n    */\r\n    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ITokenController.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract ITokenController {\r\n\taddress public token;\r\n    address public bLOTToken;\r\n\r\n    /**\r\n    * @dev Swap BLOT token.\r\n    * account.\r\n    * @param amount The amount that will be swapped.\r\n    */\r\n    function swapBLOT(address _of, address _to, uint256 amount) public;\r\n\r\n    function totalBalanceOf(address _of)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\r\n\r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount);\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burnCommissionTokens(uint256 amount) external returns(bool);\r\n \r\n    function initiateVesting(address _vesting) external;\r\n\r\n    function lockForGovernanceVote(address _of, uint _days) public;\r\n\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function mint(address _member, uint _amount) public;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IToken.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IToken {\r\n\r\n    function decimals() external view returns(uint8);\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param recipient The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    \r\n     /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param sender address The address which you want to send tokens from\r\n    * @param recipient address The address which you want to transfer to\r\n    * @param amount uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IMaster.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMaster {\r\n    function dAppToken() public view returns(address);\r\n    function isInternal(address _address) public view returns(bool);\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\r\n}\r\n\r\n// File: contracts/interfaces/IMarket.sol\r\n\r\npragma solidity 0.5.7;\r\n\r\ncontract IMarket {\r\n\r\n    enum PredictionStatus {\r\n      Live,\r\n      InSettlement,\r\n      Cooling,\r\n      InDispute,\r\n      Settled\r\n    }\r\n\r\n    struct MarketData {\r\n      uint64 startTime;\r\n      uint64 predictionTime;\r\n      uint64 neutralMinValue;\r\n      uint64 neutralMaxValue;\r\n    }\r\n\r\n    struct MarketSettleData {\r\n      uint64 WinningOption;\r\n      uint64 settleTime;\r\n    }\r\n\r\n    MarketSettleData public marketSettleData;\r\n\r\n    MarketData public marketData;\r\n\r\n    function WinningOption() public view returns(uint256);\r\n\r\n    function marketCurrency() public view returns(bytes32);\r\n\r\n    function getMarketFeedData() public view returns(uint8, bytes32, address);\r\n\r\n    function settleMarket() external;\r\n    \r\n    function getTotalStakedValueInPLOT() external view returns(uint256);\r\n\r\n    /**\r\n    * @dev Initialize the market.\r\n    * @param _startTime The time at which market will create.\r\n    * @param _predictionTime The time duration of market.\r\n    * @param _minValue The minimum value of middle option range.\r\n    * @param _maxValue The maximum value of middle option range.\r\n    */\r\n    function initiate(uint64 _startTime, uint64 _predictionTime, uint64 _minValue, uint64 _maxValue) public payable;\r\n\r\n    /**\r\n    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\r\n    * @param accepted The flag defining that the dispute raised is accepted or not \r\n    * @param finalResult The final correct value of market currency.\r\n    */\r\n    function resolveDispute(bool accepted, uint256 finalResult) external payable;\r\n\r\n    /**\r\n    * @dev Gets the market data.\r\n    * @return _marketCurrency bytes32 representing the currency or stock name of the market.\r\n    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\r\n    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\r\n    * @return _optionPrice uint[] memory representing the option price of each option ranges of the market.\r\n    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\r\n    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\r\n    * @return _predictionType uint representing the type of market.\r\n    * @return _expireTime uint representing the expire time of the market.\r\n    * @return _predictionStatus uint representing the status of the market.\r\n    */\r\n    function getData() external view \r\n    \treturns (\r\n    \t\tbytes32 _marketCurrency,uint[] memory minvalue,uint[] memory maxvalue,\r\n        \tuint[] memory _optionPrice, uint[] memory _ethStaked, uint[] memory _plotStaked,uint _predictionType,\r\n        \tuint _expireTime, uint _predictionStatus\r\n        );\r\n\r\n    // /**\r\n    // * @dev Gets the pending return.\r\n    // * @param _user The address to specify the return of.\r\n    // * @return uint representing the pending return amount.\r\n    // */\r\n    // function getPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens);\r\n\r\n    /**\r\n    * @dev Claim the return amount of the specified address.\r\n    * @param _user The address to query the claim return amount of.\r\n    * @return Flag, if 0:cannot claim, 1: Already Claimed, 2: Claimed\r\n    */\r\n    function claimReturn(address payable _user) public returns(uint256);\r\n\r\n}\r\n\r\n// File: contracts/Governance.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Governance is IGovernance, Iupgradable {\r\n    using SafeMath for uint256;\r\n\r\n    enum ProposalStatus {\r\n        Draft,\r\n        AwaitingSolution,\r\n        VotingStarted,\r\n        Accepted,\r\n        Rejected,\r\n        Denied\r\n    }\r\n\r\n    struct ProposalData {\r\n        uint256 propStatus;\r\n        uint256 finalVerdict;\r\n        uint256 category;\r\n        uint256 commonIncentive;\r\n        uint256 dateUpd;\r\n        uint256 totalVoteValue;\r\n        address owner;\r\n    }\r\n\r\n    struct ProposalVote {\r\n        address voter;\r\n        uint256 proposalId;\r\n        uint256 solutionChosen;\r\n        uint256 voteValue;\r\n        uint256 dateAdd;\r\n    }\r\n    struct VoteTally {\r\n        mapping(uint256 => uint256) voteValue;\r\n        mapping(uint=>uint) abVoteValue;\r\n        uint256 voters;\r\n    }\r\n\r\n    ProposalVote[] internal allVotes;\r\n\r\n    mapping(uint256 => ProposalData) internal allProposalData;\r\n    mapping(uint256 => bytes[]) internal allProposalSolutions;\r\n    mapping(address => uint256[]) internal allVotesByMember;\r\n    mapping(uint256 => mapping(address => bool)) public rewardClaimed;\r\n    mapping(address => mapping(uint256 => uint256)) public memberProposalVote;\r\n    mapping(uint256 => VoteTally) public proposalVoteTally;\r\n    mapping(address => uint256) public lastRewardClaimed;\r\n\r\n    bytes32 constant swapABMemberHash = keccak256(abi.encodeWithSignature(\"swapABMember(address,address)\"));\r\n    bytes32 constant resolveDisputeHash = keccak256(abi.encodeWithSignature(\"resolveDispute(address,uint256)\"));\r\n    uint256 constant totalSupplyCapForDRQrm = 50;\r\n\r\n    bool internal constructorCheck;\r\n    uint256 public tokenHoldingTime;\r\n    uint256 internal roleIdAllowedToCatgorize;\r\n    uint256 internal maxVoteWeigthPer;\r\n    uint256 internal advisoryBoardMajority;\r\n    uint256 internal totalProposals;\r\n    uint256 internal maxDraftTime;\r\n    uint256 internal votePercRejectAction;\r\n    uint256 internal actionRejectAuthRole;\r\n    uint256 internal drQuorumMulitplier;\r\n\r\n    IMaster public ms;\r\n    IMemberRoles internal memberRole;\r\n    IMarketRegistry internal marketRegistry;\r\n    IProposalCategory internal proposalCategory;\r\n    //Plot Token Instance\r\n    IToken internal tokenInstance;\r\n    ITokenController internal tokenController;\r\n\r\n    mapping(uint256 => uint256) public proposalActionStatus;\r\n    mapping(uint256 => uint256) internal proposalExecutionTime;\r\n    mapping(uint256 => mapping(address => bool)) public isActionRejected;\r\n    mapping(uint256 => uint256) internal actionRejectedCount;\r\n\r\n    uint256 internal actionWaitingTime;\r\n\r\n    enum ActionStatus {Pending, Accepted, Rejected, Executed, NoAction}\r\n\r\n    /**\r\n     * @dev Called whenever an action execution is failed.\r\n     */\r\n    event ActionFailed(uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Called whenever an AB member rejects the action execution.\r\n     */\r\n    event ActionRejected(uint256 indexed proposalId, address rejectedBy);\r\n\r\n    /**\r\n     * @dev Checks if msg.sender is proposal owner\r\n     */\r\n    modifier onlyProposalOwner(uint256 _proposalId) {\r\n        require(\r\n            msg.sender == allProposalData[_proposalId].owner,\r\n            \"Not allowed\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if proposal is opened for voting\r\n     */\r\n    modifier voteNotStarted(uint256 _proposalId) {\r\n        require(\r\n            allProposalData[_proposalId].propStatus <\r\n                uint256(ProposalStatus.VotingStarted)\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if msg.sender is allowed to create proposal under given category\r\n     */\r\n    modifier isAllowed(uint256 _categoryId) {\r\n        require(allowedToCreateProposal(_categoryId), \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if msg.sender is allowed categorize proposal\r\n     */\r\n    modifier isAllowedToCategorize() {\r\n        require(allowedToCategorize());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Event emitted whenever a proposal is categorized\r\n     */\r\n    event ProposalCategorized(\r\n        uint256 indexed proposalId,\r\n        address indexed categorizedBy,\r\n        uint256 categoryId\r\n    );\r\n\r\n    /**\r\n     * @dev Creates a new proposal\r\n     * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n     * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n     */\r\n    function createProposal(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint256 _categoryId\r\n    ) external isAllowed(_categoryId) {\r\n        require(\r\n            memberRole.checkRole(\r\n                msg.sender,\r\n                uint256(IMemberRoles.Role.TokenHolder)\r\n            ),\r\n            \"Not Member\"\r\n        );\r\n\r\n        _createProposal(\r\n            _proposalTitle,\r\n            _proposalSD,\r\n            _proposalDescHash,\r\n            _categoryId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n     */\r\n    function categorizeProposal(\r\n        uint256 _proposalId,\r\n        uint256 _categoryId,\r\n        uint256 _incentive\r\n    ) external voteNotStarted(_proposalId) isAllowedToCategorize {\r\n        uint256 incentive = _incentive;\r\n        bytes memory _functionHash = proposalCategory\r\n            .categoryActionHashes(_categoryId);\r\n        if(keccak256(_functionHash) == swapABMemberHash) {\r\n            incentive = 0;\r\n        }\r\n        _categorizeProposal(_proposalId, _categoryId, incentive, _functionHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Submit proposal with solution\r\n     * @param _proposalId Proposal id\r\n     * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n     */\r\n    function submitProposalWithSolution(\r\n        uint256 _proposalId,\r\n        string calldata _solutionHash,\r\n        bytes calldata _action\r\n    ) external onlyProposalOwner(_proposalId) {\r\n        require(\r\n            allProposalData[_proposalId].propStatus ==\r\n                uint256(ProposalStatus.AwaitingSolution)\r\n        );\r\n\r\n        _proposalSubmission(_proposalId, _solutionHash, _action);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new proposal with solution\r\n     * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n     * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n     * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n     */\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint256 _categoryId,\r\n        string calldata _solutionHash,\r\n        bytes calldata _action\r\n    ) external isAllowed(_categoryId) {\r\n        uint256 proposalId = totalProposals;\r\n\r\n        _createProposal(\r\n            _proposalTitle,\r\n            _proposalSD,\r\n            _proposalDescHash,\r\n            _categoryId\r\n        );\r\n\r\n        require(_categoryId > 0);\r\n\r\n        _proposalSubmission(proposalId, _solutionHash, _action);\r\n    }\r\n\r\n    /**\r\n     * @dev Submit a vote on the proposal.\r\n     * @param _proposalId to vote upon.\r\n     * @param _solutionChosen is the chosen vote.\r\n     */\r\n    function submitVote(uint256 _proposalId, uint256 _solutionChosen) external {\r\n        require(\r\n            allProposalData[_proposalId].propStatus ==\r\n                uint256(Governance.ProposalStatus.VotingStarted),\r\n            \"Not allowed\"\r\n        );\r\n\r\n        require(_solutionChosen < allProposalSolutions[_proposalId].length);\r\n\r\n        _submitVote(_proposalId, _solutionChosen);\r\n    }\r\n\r\n    /**\r\n     * @dev Closes the proposal.\r\n     * @param _proposalId of proposal to be closed.\r\n     */\r\n    function closeProposal(uint256 _proposalId) external {\r\n        uint256 category = allProposalData[_proposalId].category;\r\n\r\n        if (\r\n            allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\r\n            allProposalData[_proposalId].propStatus <\r\n            uint256(ProposalStatus.VotingStarted)\r\n        ) {\r\n            _updateProposalStatus(_proposalId, uint256(ProposalStatus.Denied));\r\n            _transferPLOT(\r\n                address(marketRegistry),\r\n                allProposalData[_proposalId].commonIncentive\r\n            );\r\n        } else {\r\n            require(canCloseProposal(_proposalId) == 1);\r\n            _closeVote(_proposalId, category);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Claims reward for member.\r\n     * @param _memberAddress to claim reward of.\r\n     * @param _maxRecords maximum number of records to claim reward for.\r\n     _proposals list of proposals of which reward will be claimed.\r\n     * @return amount of pending reward.\r\n     */\r\n    function claimReward(address _memberAddress, uint256 _maxRecords)\r\n        external\r\n        returns (uint256 pendingDAppReward)\r\n    {\r\n        uint256 voteId;\r\n        uint256 proposalId;\r\n        uint256 totalVotes = allVotesByMember[_memberAddress].length;\r\n        uint256 lastClaimed = totalVotes;\r\n        uint256 j;\r\n        uint256 i;\r\n        for (\r\n            i = lastRewardClaimed[_memberAddress];\r\n            i < totalVotes && j < _maxRecords;\r\n            i++\r\n        ) {\r\n            voteId = allVotesByMember[_memberAddress][i];\r\n            proposalId = allVotes[voteId].proposalId;\r\n            if (\r\n                proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus >\r\n                    uint256(ProposalStatus.VotingStarted)\r\n            ) {                    \r\n                if (!rewardClaimed[voteId][_memberAddress]) {\r\n                    pendingDAppReward = pendingDAppReward.add(\r\n                        allProposalData[proposalId].commonIncentive.div(\r\n                            proposalVoteTally[proposalId].voters\r\n                        )\r\n                    );\r\n                    rewardClaimed[voteId][_memberAddress] = true;\r\n                    j++;\r\n                }\r\n            } else {\r\n                if (lastClaimed == totalVotes) {\r\n                    lastClaimed = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (lastClaimed == totalVotes) {\r\n            lastRewardClaimed[_memberAddress] = i;\r\n        } else {\r\n            lastRewardClaimed[_memberAddress] = lastClaimed;\r\n        }\r\n\r\n        if (j > 0) {\r\n            _transferPLOT(\r\n                _memberAddress,\r\n                pendingDAppReward\r\n            );\r\n            emit RewardClaimed(_memberAddress, pendingDAppReward);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers action of accepted proposal after waiting time is finished\r\n     */\r\n    function triggerAction(uint256 _proposalId) external {\r\n        require(\r\n            proposalActionStatus[_proposalId] ==\r\n                uint256(ActionStatus.Accepted) &&\r\n                proposalExecutionTime[_proposalId] <= now,\r\n            \"Cannot trigger\"\r\n        );\r\n        _triggerAction(_proposalId, allProposalData[_proposalId].category);\r\n    }\r\n\r\n    /**\r\n     * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\r\n     */\r\n    function rejectAction(uint256 _proposalId) external {\r\n        require(\r\n            memberRole.checkRole(msg.sender, actionRejectAuthRole) &&\r\n                proposalExecutionTime[_proposalId] > now\r\n        );\r\n\r\n        require(\r\n            proposalActionStatus[_proposalId] == uint256(ActionStatus.Accepted)\r\n        );\r\n\r\n        require(!isActionRejected[_proposalId][msg.sender]);\r\n\r\n        isActionRejected[_proposalId][msg.sender] = true;\r\n        actionRejectedCount[_proposalId]++;\r\n        emit ActionRejected(_proposalId, msg.sender);\r\n        if (\r\n            actionRejectedCount[_proposalId].mul(100).div(\r\n                memberRole.numberOfMembers(actionRejectAuthRole)\r\n            ) >= votePercRejectAction\r\n        ) {\r\n            proposalActionStatus[_proposalId] = uint256(ActionStatus.Rejected);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code)\r\n        external\r\n        view\r\n        returns (bytes8 codeVal, uint256 val)\r\n    {\r\n        codeVal = code;\r\n\r\n        if (code == \"GOVHOLD\") { // Governance token holding time\r\n            val = tokenHoldingTime / (1 days);\r\n        } else if (code == \"MAXDRFT\") { // Maximum draft time for proposals\r\n            val = maxDraftTime / (1 days);\r\n        } else if (code == \"ACWT\") { //Action wait time\r\n            val = actionWaitingTime / (1 hours);\r\n        } else if (code == \"REJAUTH\") { // Authorized role to stop executing actions\r\n            val = actionRejectAuthRole;\r\n        } else if (code == \"REJCOUNT\") { // Majorty percentage for action rejection\r\n            val = votePercRejectAction;\r\n        } else if (code == \"MAXVW\") { // Max vote weight percentage\r\n            val = maxVoteWeigthPer;\r\n        } else if (code == \"ABMAJ\") { // Advisory board majority percentage\r\n            val = advisoryBoardMajority;\r\n        } else if (code == \"DRQUMR\") { // Dispute Resolution Quorum multiplier\r\n            val = drQuorumMulitplier;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all details of a propsal\r\n     * @param _proposalId whose details we want\r\n     * @return proposalId\r\n     * @return category\r\n     * @return status\r\n     * @return finalVerdict\r\n     * @return totalReward\r\n     */\r\n    function proposal(uint256 _proposalId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 proposalId,\r\n            uint256 category,\r\n            uint256 status,\r\n            uint256 finalVerdict,\r\n            uint256 totalRewar\r\n        )\r\n    {\r\n        return (\r\n            _proposalId,\r\n            allProposalData[_proposalId].category,\r\n            allProposalData[_proposalId].propStatus,\r\n            allProposalData[_proposalId].finalVerdict,\r\n            allProposalData[_proposalId].commonIncentive\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets some details of a propsal\r\n     * @param _proposalId whose details we want\r\n     * @return proposalId\r\n     * @return number of all proposal solutions\r\n     * @return amount of votes\r\n     */\r\n    function proposalDetails(uint256 _proposalId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            _proposalId,\r\n            allProposalSolutions[_proposalId].length,\r\n            proposalVoteTally[_proposalId].voters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets solution action on a proposal\r\n     * @param _proposalId whose details we want\r\n     * @param _solution whose details we want\r\n     * @return action of a solution on a proposal\r\n     */\r\n    function getSolutionAction(uint256 _proposalId, uint256 _solution)\r\n        external\r\n        view\r\n        returns (uint256, bytes memory)\r\n    {\r\n        return (_solution, allProposalSolutions[_proposalId][_solution]);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets length of propsal\r\n     * @return length of propsal\r\n     */\r\n    function getProposalLength() external view returns (uint256) {\r\n        return totalProposals;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets pending rewards of a member\r\n     * @param _memberAddress in concern\r\n     * @return amount of pending reward\r\n     */\r\n    function getPendingReward(address _memberAddress)\r\n        public\r\n        view\r\n        returns (uint256 pendingDAppReward)\r\n    {\r\n        uint256 proposalId;\r\n        for (\r\n            uint256 i = lastRewardClaimed[_memberAddress];\r\n            i < allVotesByMember[_memberAddress].length;\r\n            i++\r\n        ) {\r\n            if (\r\n                !rewardClaimed[allVotesByMember[_memberAddress][i]][_memberAddress]\r\n            ) {\r\n                proposalId = allVotes[allVotesByMember[_memberAddress][i]]\r\n                    .proposalId;\r\n                if (\r\n                    proposalVoteTally[proposalId].voters > 0 &&\r\n                    allProposalData[proposalId].propStatus >\r\n                    uint256(ProposalStatus.VotingStarted)\r\n                ) {\r\n                    pendingDAppReward = pendingDAppReward.add(\r\n                        allProposalData[proposalId].commonIncentive.div(\r\n                            proposalVoteTally[proposalId].voters\r\n                        )\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint256 val) public {\r\n        require(ms.isAuthorizedToGovern(msg.sender));\r\n        if (code == \"GOVHOLD\") {\r\n            tokenHoldingTime = val * 1 days;\r\n        } else if (code == \"MAXDRFT\") {\r\n            maxDraftTime = val * 1 days;\r\n        } else if (code == \"ACWT\") {\r\n            actionWaitingTime = val * 1 hours;\r\n        } else if (code == \"REJAUTH\") {\r\n            actionRejectAuthRole = val;\r\n        } else if (code == \"REJCOUNT\") {\r\n            votePercRejectAction = val;\r\n        } else if (code == \"MAXVW\") {\r\n            maxVoteWeigthPer = val;\r\n        } else if (code == \"ABMAJ\") {\r\n            advisoryBoardMajority = val;\r\n        } else if (code == \"DRQUMR\") {\r\n            drQuorumMulitplier = val;\r\n        } else {\r\n            revert(\"Invalid code\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates all dependency addresses to latest ones from Master\r\n     */\r\n    function setMasterAddress() public {\r\n        OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\r\n        require(msg.sender == proxy.proxyOwner(),\"Sender is not proxy owner.\");\r\n\r\n        require(!constructorCheck);\r\n        _initiateGovernance();\r\n        ms = IMaster(msg.sender);\r\n        tokenInstance = IToken(ms.dAppToken());\r\n        memberRole = IMemberRoles(ms.getLatestAddress(\"MR\"));\r\n        proposalCategory = IProposalCategory(ms.getLatestAddress(\"PC\"));\r\n        tokenController = ITokenController(ms.getLatestAddress(\"TC\"));\r\n        marketRegistry = IMarketRegistry(address(uint160(ms.getLatestAddress(\"PL\"))));\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if msg.sender is allowed to create a proposal under given category\r\n     */\r\n    function allowedToCreateProposal(uint256 category)\r\n        public\r\n        view\r\n        returns (bool check)\r\n    {\r\n        if (category == 0) return true;\r\n        uint256[] memory mrAllowed;\r\n        (, , , , mrAllowed, , ) = proposalCategory.category(category);\r\n        for (uint256 i = 0; i < mrAllowed.length; i++) {\r\n            if (\r\n                mrAllowed[i] == 0 ||\r\n                memberRole.checkRole(msg.sender, mrAllowed[i])\r\n            ) return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if msg.sender is allowed to categorize proposals\r\n     */\r\n    function allowedToCategorize()\r\n        public\r\n        view\r\n        returns (bool check)\r\n    {\r\n        return memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks If the proposal voting time is up and it's ready to close\r\n     *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\r\n     * @param _proposalId Proposal id to which closing value is being checked\r\n     */\r\n    function canCloseProposal(uint256 _proposalId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 dateUpdate;\r\n        uint256 pStatus;\r\n        uint256 _closingTime;\r\n        uint256 _roleId;\r\n        uint256 majority;\r\n        pStatus = allProposalData[_proposalId].propStatus;\r\n        dateUpdate = allProposalData[_proposalId].dateUpd;\r\n        (, _roleId, majority, , , _closingTime, ) = proposalCategory.category(\r\n            allProposalData[_proposalId].category\r\n        );\r\n        if (pStatus == uint256(ProposalStatus.VotingStarted)) {\r\n            uint256 numberOfMembers = memberRole.numberOfMembers(_roleId);\r\n            if (\r\n                _roleId == uint256(IMemberRoles.Role.AdvisoryBoard)\r\n            ) {\r\n                if (\r\n                    proposalVoteTally[_proposalId].voteValue[1].mul(100).div(\r\n                        numberOfMembers\r\n                    ) >=\r\n                    majority ||\r\n                    proposalVoteTally[_proposalId].voteValue[1].add(\r\n                        proposalVoteTally[_proposalId].voteValue[0]\r\n                    ) ==\r\n                    numberOfMembers ||\r\n                    dateUpdate.add(_closingTime) <= now\r\n                ) {\r\n                    return 1;\r\n                }\r\n            } else {\r\n                if(_roleId == uint256(IMemberRoles.Role.TokenHolder) ||\r\n                _roleId == uint256(IMemberRoles.Role.DisputeResolution)) {\r\n                    if(dateUpdate.add(_closingTime) <= now)\r\n                        return 1;\r\n                } else if (\r\n                    numberOfMembers <= proposalVoteTally[_proposalId].voters ||\r\n                    dateUpdate.add(_closingTime) <= now\r\n                ) return 1;\r\n            }\r\n        } else if (pStatus > uint256(ProposalStatus.VotingStarted)) {\r\n            return 2;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Id of member role allowed to categorize the proposal\r\n     * @return roleId allowed to categorize the proposal\r\n     */\r\n    function allowedToCatgorize() public view returns (uint256 roleId) {\r\n        return roleIdAllowedToCatgorize;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets vote tally data\r\n     * @param _proposalId in concern\r\n     * @param _solution of a proposal id\r\n     * @return member vote value\r\n     * @return advisory board vote value\r\n     * @return amount of votes\r\n     */\r\n    function voteTallyData(uint256 _proposalId, uint256 _solution)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        return (\r\n            proposalVoteTally[_proposalId].voteValue[_solution],\r\n            proposalVoteTally[_proposalId].abVoteValue[_solution],\r\n            proposalVoteTally[_proposalId].voters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to create proposal\r\n     * @param _proposalTitle of proposal\r\n     * @param _proposalSD is short description of proposal\r\n     * @param _proposalDescHash IPFS hash value of propsal\r\n     * @param _categoryId of proposal\r\n     */\r\n    function _createProposal(\r\n        string memory _proposalTitle,\r\n        string memory _proposalSD,\r\n        string memory _proposalDescHash,\r\n        uint256 _categoryId\r\n    ) internal {\r\n        uint256 _proposalId = totalProposals;\r\n        allProposalData[_proposalId].owner = msg.sender;\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalSolutions[_proposalId].push(\"\");\r\n        totalProposals++;\r\n\r\n        emit Proposal(\r\n            msg.sender,\r\n            _proposalId,\r\n            now,\r\n            _proposalTitle,\r\n            _proposalSD,\r\n            _proposalDescHash\r\n        );\r\n\r\n        if (_categoryId > 0) {\r\n            (, , , uint defaultIncentive, bytes memory _functionHash) = proposalCategory\r\n            .categoryActionDetails(_categoryId);\r\n            require(allowedToCategorize() ||\r\n                keccak256(_functionHash) ==\r\n                 resolveDisputeHash ||\r\n                keccak256(_functionHash) == swapABMemberHash\r\n            );\r\n            if(keccak256(_functionHash) == swapABMemberHash) {\r\n                defaultIncentive = 0;\r\n            }\r\n            _categorizeProposal(_proposalId, _categoryId, defaultIncentive, _functionHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to categorize a proposal\r\n     * @param _proposalId of proposal\r\n     * @param _categoryId of proposal\r\n     * @param _incentive is commonIncentive\r\n     */\r\n    function _categorizeProposal(\r\n        uint256 _proposalId,\r\n        uint256 _categoryId,\r\n        uint256 _incentive,\r\n        bytes memory _functionHash\r\n    ) internal {\r\n        require(\r\n            _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\r\n            \"Invalid category\"\r\n        );\r\n        if(keccak256(_functionHash) == resolveDisputeHash) {\r\n            require(msg.sender == address(marketRegistry));\r\n        }\r\n        allProposalData[_proposalId].category = _categoryId;\r\n        allProposalData[_proposalId].commonIncentive = _incentive;\r\n        allProposalData[_proposalId].propStatus = uint256(\r\n            ProposalStatus.AwaitingSolution\r\n        );\r\n\r\n        if (_incentive > 0) {\r\n            marketRegistry.transferAssets(\r\n                address(tokenInstance),\r\n                address(this),\r\n                _incentive\r\n            );\r\n        }\r\n\r\n        emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to add solution to a proposal\r\n     * @param _proposalId in concern\r\n     * @param _action on that solution\r\n     * @param _solutionHash string value\r\n     */\r\n    function _addSolution(\r\n        uint256 _proposalId,\r\n        bytes memory _action,\r\n        string memory _solutionHash\r\n    ) internal {\r\n        allProposalSolutions[_proposalId].push(_action);\r\n        emit Solution(\r\n            _proposalId,\r\n            msg.sender,\r\n            allProposalSolutions[_proposalId].length.sub(1),\r\n            _solutionHash,\r\n            now\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to add solution and open proposal for voting\r\n     */\r\n    function _proposalSubmission(\r\n        uint256 _proposalId,\r\n        string memory _solutionHash,\r\n        bytes memory _action\r\n    ) internal {\r\n        uint256 _categoryId = allProposalData[_proposalId].category;\r\n        if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\r\n            require(keccak256(_action) == keccak256(\"\"));\r\n            proposalActionStatus[_proposalId] = uint256(ActionStatus.NoAction);\r\n        }\r\n\r\n        _addSolution(_proposalId, _action, _solutionHash);\r\n\r\n        _updateProposalStatus(\r\n            _proposalId,\r\n            uint256(ProposalStatus.VotingStarted)\r\n        );\r\n        (, , , , , uint256 closingTime, ) = proposalCategory.category(\r\n            _categoryId\r\n        );\r\n        emit CloseProposalOnTime(_proposalId, closingTime.add(now));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to submit vote\r\n     * @param _proposalId of proposal in concern\r\n     * @param _solution for that proposal\r\n     */\r\n    function _submitVote(uint256 _proposalId, uint256 _solution) internal {\r\n        uint256 mrSequence;\r\n        uint256 majority;\r\n        uint256 closingTime;\r\n        (, mrSequence, majority, , , closingTime, ) = proposalCategory.category(\r\n            allProposalData[_proposalId].category\r\n        );\r\n\r\n        require(\r\n            allProposalData[_proposalId].dateUpd.add(closingTime) > now,\r\n            \"Closed\"\r\n        );\r\n\r\n        require(\r\n            memberProposalVote[msg.sender][_proposalId] == 0,\r\n            \"Not allowed\"\r\n        );\r\n\r\n        require(memberRole.checkRole(msg.sender, mrSequence), \"Not Authorized\");\r\n        uint256 totalVotes = allVotes.length;\r\n\r\n        allVotesByMember[msg.sender].push(totalVotes);\r\n        memberProposalVote[msg.sender][_proposalId] = totalVotes;\r\n        tokenController.lockForGovernanceVote(msg.sender, tokenHoldingTime);\r\n\r\n        emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\r\n        uint256 numberOfMembers = memberRole.numberOfMembers(mrSequence);\r\n        _setVoteTally(_proposalId, _solution, mrSequence);\r\n\r\n        if (\r\n            numberOfMembers == proposalVoteTally[_proposalId].voters &&\r\n            mrSequence != uint256(IMemberRoles.Role.TokenHolder)\r\n        ) {\r\n            emit VoteCast(_proposalId);\r\n        }\r\n    }\r\n\r\n    function _setVoteTally(\r\n        uint256 _proposalId,\r\n        uint256 _solution,\r\n        uint256 mrSequence\r\n    ) internal {\r\n        uint256 voters = 1;\r\n        uint256 voteWeight;\r\n        uint256 tokenBalance = tokenController.totalBalanceOf(msg.sender);\r\n        uint totalSupply = tokenController.totalSupply();\r\n        if (mrSequence != uint(IMemberRoles.Role.AdvisoryBoard) &&\r\n        memberRole.checkRole(msg.sender, uint(IMemberRoles.Role.AdvisoryBoard))\r\n        )\r\n         {\r\n            proposalVoteTally[_proposalId].abVoteValue[_solution]++;\r\n        }\r\n        if (\r\n            mrSequence == uint256(IMemberRoles.Role.TokenHolder)\r\n        ) {\r\n            voteWeight = _minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100));\r\n        } else if (\r\n            mrSequence == uint256(IMemberRoles.Role.DisputeResolution)\r\n        ) {\r\n            voteWeight = tokenController.tokensLockedAtTime(msg.sender, \"DR\", now);\r\n        } else {\r\n            voteWeight = 1;\r\n        }\r\n        allVotes.push(\r\n            ProposalVote(msg.sender, _proposalId, _solution, tokenBalance, now)\r\n        );\r\n        allProposalData[_proposalId]\r\n            .totalVoteValue = allProposalData[_proposalId].totalVoteValue.add(\r\n            voteWeight\r\n        );\r\n        proposalVoteTally[_proposalId]\r\n            .voteValue[_solution] = proposalVoteTally[_proposalId]\r\n            .voteValue[_solution]\r\n            .add(voteWeight);\r\n        proposalVoteTally[_proposalId].voters =\r\n            proposalVoteTally[_proposalId].voters.add(voters);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets minimum of two numbers\r\n     * @param a one of the two numbers\r\n     * @param b one of the two numbers\r\n     * @return minimum number out of the two\r\n     */\r\n    function _minOf(uint a, uint b) internal pure returns(uint res) {\r\n        res = a;\r\n        if (res > b)\r\n            res = b;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the vote count against any solution passes the threshold value or not.\r\n     */\r\n    function _checkForThreshold(uint256 _proposalId, uint256 _category)\r\n        internal\r\n        view\r\n        returns (bool check)\r\n    {\r\n        uint256 categoryQuorumPerc;\r\n        uint256 roleAuthorized;\r\n        (, roleAuthorized, , categoryQuorumPerc, , , ) = proposalCategory\r\n            .category(_category);\r\n        if (roleAuthorized == uint256(IMemberRoles.Role.TokenHolder)) {\r\n            check =\r\n                (allProposalData[_proposalId].totalVoteValue).mul(100).div(\r\n                    tokenController.totalSupply()\r\n                ) >=\r\n                categoryQuorumPerc;\r\n        } else if (roleAuthorized == uint256(IMemberRoles.Role.DisputeResolution)) {\r\n            (address marketAddress, ) = abi.decode(allProposalSolutions[_proposalId][1], (address, uint256));\r\n            uint256 totalStakeValueInPlot = IMarket(marketAddress).getTotalStakedValueInPLOT();\r\n            if(allProposalData[_proposalId].totalVoteValue > 0) {\r\n                check =\r\n                    (allProposalData[_proposalId].totalVoteValue) >=\r\n                    (_minOf(totalStakeValueInPlot.mul(drQuorumMulitplier), (tokenController.totalSupply()).mul(100).div(totalSupplyCapForDRQrm)));\r\n            } else {\r\n                check = false;\r\n            }\r\n        } else {\r\n            check =\r\n                (proposalVoteTally[_proposalId].voters).mul(100).div(\r\n                    memberRole.numberOfMembers(roleAuthorized)\r\n                ) >=\r\n                categoryQuorumPerc;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Called when vote majority is reached\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal in concern\r\n     * @param category of proposal in concern\r\n     * @param max vote value of proposal in concern\r\n     */\r\n    function _callIfMajReached(\r\n        uint256 _proposalId,\r\n        uint256 _status,\r\n        uint256 category,\r\n        uint256 max,\r\n        uint256 role\r\n    ) internal {\r\n        allProposalData[_proposalId].finalVerdict = max;\r\n        _updateProposalStatus(_proposalId, _status);\r\n        emit ProposalAccepted(_proposalId);\r\n        if (\r\n            proposalActionStatus[_proposalId] != uint256(ActionStatus.NoAction)\r\n        ) {\r\n            if (role == actionRejectAuthRole) {\r\n                _triggerAction(_proposalId, category);\r\n            } else {\r\n                proposalActionStatus[_proposalId] = uint256(\r\n                    ActionStatus.Accepted\r\n                );\r\n                bytes memory functionHash = proposalCategory.categoryActionHashes(category);\r\n                if(keccak256(functionHash)\r\n                    == swapABMemberHash ||\r\n                    keccak256(functionHash)\r\n                    == resolveDisputeHash \r\n                ) {\r\n                    _triggerAction(_proposalId, category);\r\n                } else {\r\n                    proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to trigger action of accepted proposal\r\n     */\r\n    function _triggerAction(uint256 _proposalId, uint256 _categoryId) internal {\r\n        proposalActionStatus[_proposalId] = uint256(ActionStatus.Executed);\r\n        bytes2 contractName;\r\n        address actionAddress;\r\n        bytes memory _functionHash;\r\n        (, actionAddress, contractName, , _functionHash) = proposalCategory\r\n            .categoryActionDetails(_categoryId);\r\n        if (contractName == \"MS\") {\r\n            actionAddress = address(ms);\r\n        } else if (contractName != \"EX\") {\r\n            actionAddress = ms.getLatestAddress(contractName);\r\n        }\r\n        (bool actionStatus, ) = actionAddress.call(\r\n            abi.encodePacked(\r\n                _functionHash,\r\n                allProposalSolutions[_proposalId][1]\r\n            )\r\n        );\r\n        if (actionStatus) {\r\n            emit ActionSuccess(_proposalId);\r\n        } else {\r\n            proposalActionStatus[_proposalId] = uint256(ActionStatus.Accepted);\r\n            emit ActionFailed(_proposalId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to update proposal status\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal to set\r\n     */\r\n    function _updateProposalStatus(uint256 _proposalId, uint256 _status)\r\n        internal\r\n    {\r\n        if (\r\n            _status == uint256(ProposalStatus.Rejected) ||\r\n            _status == uint256(ProposalStatus.Denied)\r\n        ) {\r\n            proposalActionStatus[_proposalId] = uint256(ActionStatus.NoAction);\r\n        }\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalData[_proposalId].propStatus = _status;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to close member voting\r\n     * @param _proposalId of proposal in concern\r\n     * @param category of proposal in concern\r\n     */\r\n    function _closeVote(uint256 _proposalId, uint256 category) internal {\r\n        uint256 majorityVote;\r\n        uint256 mrSequence;\r\n        (, mrSequence, majorityVote, , , , ) = proposalCategory.category(\r\n            category\r\n        );\r\n        bytes memory _functionHash = proposalCategory.categoryActionHashes(category);\r\n        if (_checkForThreshold(_proposalId, category)) {\r\n            if (\r\n                (\r\n                    (\r\n                        proposalVoteTally[_proposalId].voteValue[1]\r\n                            .mul(100)\r\n                    )\r\n                        .div(allProposalData[_proposalId].totalVoteValue)\r\n                ) >= majorityVote\r\n            ) {\r\n                _callIfMajReached(\r\n                    _proposalId,\r\n                    uint256(ProposalStatus.Accepted),\r\n                    category,\r\n                    1,\r\n                    mrSequence\r\n                );\r\n            } else {\r\n                _updateProposalStatus(\r\n                    _proposalId,\r\n                    uint256(ProposalStatus.Rejected)\r\n                );\r\n            }\r\n        } else {\r\n            if ((keccak256(_functionHash) != resolveDisputeHash) &&\r\n             (mrSequence != uint(IMemberRoles.Role.AdvisoryBoard)) &&\r\n             proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n                .div(memberRole.numberOfMembers(uint(IMemberRoles.Role.AdvisoryBoard))) >= advisoryBoardMajority\r\n            ) {\r\n                _callIfMajReached(\r\n                    _proposalId,\r\n                    uint256(ProposalStatus.Accepted),\r\n                    category,\r\n                    1,\r\n                    mrSequence\r\n                );\r\n            } else {\r\n                _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n            }\r\n        }\r\n        if(allProposalData[_proposalId].propStatus > uint256(ProposalStatus.Accepted)) {\r\n            if(keccak256(_functionHash) == resolveDisputeHash) {\r\n                marketRegistry.burnDisputedProposalTokens(_proposalId);\r\n            }\r\n        }\r\n\r\n        if (proposalVoteTally[_proposalId].voters == 0 && allProposalData[_proposalId].commonIncentive > 0) {\r\n            _transferPLOT(\r\n                address(marketRegistry),\r\n                allProposalData[_proposalId].commonIncentive\r\n            );\r\n        }\r\n    }\r\n\r\n    function _transferPLOT(address _recipient, uint256 _amount) internal {\r\n        if(_amount > 0) {\r\n            tokenInstance.transfer(\r\n                _recipient,\r\n                _amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to initiate the governance process\r\n     */\r\n    function _initiateGovernance() internal {\r\n        allVotes.push(ProposalVote(address(0), 0, 0, 0, 0));\r\n        totalProposals = 1;\r\n        tokenHoldingTime = 1 * 3 days;\r\n        constructorCheck = true;\r\n        roleIdAllowedToCatgorize = uint256(IMemberRoles.Role.AdvisoryBoard);\r\n        actionWaitingTime = 1 days;\r\n        actionRejectAuthRole = uint256(IMemberRoles.Role.AdvisoryBoard);\r\n        votePercRejectAction = 60;\r\n        maxVoteWeigthPer = 5;\r\n        advisoryBoardMajority = 60;\r\n        drQuorumMulitplier = 5;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/GovernanceV2.sol\r\n\r\n/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\n\r\n\r\n\r\ncontract GovernanceV2 is Governance {\r\n\r\n    IAllMarkets internal allMarkets;\r\n    IMarketCreationRewards internal mcr;\r\n    bytes32 constant resolveDisputeHashV2 = keccak256(abi.encodeWithSignature(\"resolveDispute(uint256,uint256)\"));\r\n\r\n    /**\r\n     * @dev Updates all dependency addresses to latest ones from Master\r\n     */\r\n    function setAllMarketsAddress() public {\r\n        require(address(allMarkets) == address(0));\r\n        allMarkets = IAllMarkets(address(uint160(ms.getLatestAddress(\"AM\"))));\r\n        mcr = IMarketCreationRewards(address(uint160(ms.getLatestAddress(\"MC\"))));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to create proposal\r\n     * @param _proposalTitle of proposal\r\n     * @param _proposalSD is short description of proposal\r\n     * @param _proposalDescHash IPFS hash value of propsal\r\n     * @param _categoryId of proposal\r\n     */\r\n    function _createProposal(\r\n        string memory _proposalTitle,\r\n        string memory _proposalSD,\r\n        string memory _proposalDescHash,\r\n        uint256 _categoryId\r\n    ) internal {\r\n        uint256 _proposalId = totalProposals;\r\n        allProposalData[_proposalId].owner = msg.sender;\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalSolutions[_proposalId].push(\"\");\r\n        totalProposals++;\r\n\r\n        emit Proposal(\r\n            msg.sender,\r\n            _proposalId,\r\n            now,\r\n            _proposalTitle,\r\n            _proposalSD,\r\n            _proposalDescHash\r\n        );\r\n\r\n        if (_categoryId > 0) {\r\n            (, , , uint defaultIncentive, bytes memory _functionHash) = proposalCategory\r\n            .categoryActionDetails(_categoryId);\r\n            require(allowedToCategorize() ||\r\n                keccak256(_functionHash) ==\r\n                 resolveDisputeHashV2 ||\r\n                keccak256(_functionHash) == swapABMemberHash\r\n            );\r\n            if(keccak256(_functionHash) == swapABMemberHash) {\r\n                defaultIncentive = 0;\r\n            }\r\n            _categorizeProposal(_proposalId, _categoryId, defaultIncentive, _functionHash);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Internal call to categorize a proposal\r\n     * @param _proposalId of proposal\r\n     * @param _categoryId of proposal\r\n     * @param _incentive is commonIncentive\r\n     */\r\n    function _categorizeProposal(\r\n        uint256 _proposalId,\r\n        uint256 _categoryId,\r\n        uint256 _incentive,\r\n        bytes memory _functionHash\r\n    ) internal {\r\n        require(\r\n            _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\r\n            \"Invalid category\"\r\n        );\r\n        if(keccak256(_functionHash) == resolveDisputeHashV2) {\r\n            require(msg.sender == address(allMarkets));\r\n        }\r\n        allProposalData[_proposalId].category = _categoryId;\r\n        allProposalData[_proposalId].commonIncentive = _incentive;\r\n        allProposalData[_proposalId].propStatus = uint256(\r\n            ProposalStatus.AwaitingSolution\r\n        );\r\n\r\n        if (_incentive > 0) {\r\n            mcr.transferAssets(\r\n                address(tokenInstance),\r\n                address(this),\r\n                _incentive\r\n            );\r\n        }\r\n\r\n        emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n    }\r\n\r\n        /**\r\n     * @dev Called when vote majority is reached\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal in concern\r\n     * @param category of proposal in concern\r\n     * @param max vote value of proposal in concern\r\n     */\r\n    function _callIfMajReached(\r\n        uint256 _proposalId,\r\n        uint256 _status,\r\n        uint256 category,\r\n        uint256 max,\r\n        uint256 role\r\n    ) internal {\r\n        allProposalData[_proposalId].finalVerdict = max;\r\n        _updateProposalStatus(_proposalId, _status);\r\n        emit ProposalAccepted(_proposalId);\r\n        if (\r\n            proposalActionStatus[_proposalId] != uint256(ActionStatus.NoAction)\r\n        ) {\r\n            if (role == actionRejectAuthRole) {\r\n                _triggerAction(_proposalId, category);\r\n            } else {\r\n                proposalActionStatus[_proposalId] = uint256(\r\n                    ActionStatus.Accepted\r\n                );\r\n                bytes memory functionHash = proposalCategory.categoryActionHashes(category);\r\n                if(keccak256(functionHash)\r\n                    == swapABMemberHash ||\r\n                    keccak256(functionHash)\r\n                    == resolveDisputeHashV2 \r\n                ) {\r\n                    _triggerAction(_proposalId, category);\r\n                } else {\r\n                    proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Closes the proposal.\r\n     * @param _proposalId of proposal to be closed.\r\n     */\r\n    function closeProposal(uint256 _proposalId) external {\r\n        uint256 category = allProposalData[_proposalId].category;\r\n\r\n        if (\r\n            allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\r\n            allProposalData[_proposalId].propStatus <\r\n            uint256(ProposalStatus.VotingStarted)\r\n        ) {\r\n            _updateProposalStatus(_proposalId, uint256(ProposalStatus.Denied));\r\n            _transferPLOT(\r\n                address(mcr),\r\n                allProposalData[_proposalId].commonIncentive\r\n            );\r\n        } else {\r\n            require(canCloseProposal(_proposalId) == 1);\r\n            _closeVote(_proposalId, category);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to close member voting\r\n     * @param _proposalId of proposal in concern\r\n     * @param category of proposal in concern\r\n     */\r\n    function _closeVote(uint256 _proposalId, uint256 category) internal {\r\n        uint256 majorityVote;\r\n        uint256 mrSequence;\r\n        (, mrSequence, majorityVote, , , , ) = proposalCategory.category(\r\n            category\r\n        );\r\n        bytes memory _functionHash = proposalCategory.categoryActionHashes(category);\r\n        if (_checkForThreshold(_proposalId, category)) {\r\n            if (\r\n                (\r\n                    (\r\n                        proposalVoteTally[_proposalId].voteValue[1]\r\n                            .mul(100)\r\n                    )\r\n                        .div(allProposalData[_proposalId].totalVoteValue)\r\n                ) >= majorityVote\r\n            ) {\r\n                _callIfMajReached(\r\n                    _proposalId,\r\n                    uint256(ProposalStatus.Accepted),\r\n                    category,\r\n                    1,\r\n                    mrSequence\r\n                );\r\n            } else {\r\n                _updateProposalStatus(\r\n                    _proposalId,\r\n                    uint256(ProposalStatus.Rejected)\r\n                );\r\n            }\r\n        } else {\r\n            if ((keccak256(_functionHash) != resolveDisputeHashV2) &&\r\n             (mrSequence != uint(IMemberRoles.Role.AdvisoryBoard)) &&\r\n             proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n                .div(memberRole.numberOfMembers(uint(IMemberRoles.Role.AdvisoryBoard))) >= advisoryBoardMajority\r\n            ) {\r\n                _callIfMajReached(\r\n                    _proposalId,\r\n                    uint256(ProposalStatus.Accepted),\r\n                    category,\r\n                    1,\r\n                    mrSequence\r\n                );\r\n            } else {\r\n                _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n            }\r\n        }\r\n        if(allProposalData[_proposalId].propStatus > uint256(ProposalStatus.Accepted)) {\r\n            if(keccak256(_functionHash) == resolveDisputeHashV2) {\r\n                allMarkets.burnDisputedProposalTokens(_proposalId);\r\n            }\r\n        }\r\n\r\n        if (proposalVoteTally[_proposalId].voters == 0 && allProposalData[_proposalId].commonIncentive > 0) {\r\n            _transferPLOT(\r\n                address(mcr),\r\n                allProposalData[_proposalId].commonIncentive\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the vote count against any solution passes the threshold value or not.\r\n     */\r\n    function _checkForThreshold(uint256 _proposalId, uint256 _category)\r\n        internal\r\n        view\r\n        returns (bool check)\r\n    {\r\n        uint256 categoryQuorumPerc;\r\n        uint256 roleAuthorized;\r\n        (, roleAuthorized, , categoryQuorumPerc, , , ) = proposalCategory\r\n            .category(_category);\r\n        if (roleAuthorized == uint256(IMemberRoles.Role.TokenHolder)) {\r\n            check =\r\n                (allProposalData[_proposalId].totalVoteValue).mul(100).div(\r\n                    tokenController.totalSupply()\r\n                ) >=\r\n                categoryQuorumPerc;\r\n        } else if (roleAuthorized == uint256(IMemberRoles.Role.DisputeResolution)) {\r\n            (uint256 marketId, ) = abi.decode(allProposalSolutions[_proposalId][1], (uint256, uint256));\r\n            uint256 totalStakeValueInPlot = allMarkets.getTotalStakedValueInPLOT(marketId);\r\n            if(allProposalData[_proposalId].totalVoteValue > 0) {\r\n                check =\r\n                    (allProposalData[_proposalId].totalVoteValue) >=\r\n                    (_minOf(totalStakeValueInPlot.mul(drQuorumMulitplier), (tokenController.totalSupply()).mul(100).div(totalSupplyCapForDRQrm)));\r\n            } else {\r\n                check = false;\r\n            }\r\n        } else {\r\n            check =\r\n                (proposalVoteTally[_proposalId].voters).mul(100).div(\r\n                    memberRole.numberOfMembers(roleAuthorized)\r\n                ) >=\r\n                categoryQuorumPerc;\r\n        }\r\n    }\r\n\r\n}"
    }
  }
}