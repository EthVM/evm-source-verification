{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Raise.sol":{"content":"\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/role/interface/ITraderOperators.sol\n\n/**\n * @title ITraderOperators\n * @notice Interface for TraderOperators contract\n */\n\npragma solidity 0.5.12;\n\n\ncontract ITraderOperators {\n    function isTrader(address _account) external view returns (bool);\n    function addTrader(address _account) external;\n    function removeTrader(address _account) external;\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/role/interface/IBaseOperators.sol\n\n/**\n * @title IBaseOperators\n * @notice Interface for BaseOperators contract\n */\n\npragma solidity 0.5.12;\n\n\ninterface IBaseOperators {\n    function isOperator(address _account) external view returns (bool);\n    function isAdmin(address _account) external view returns (bool);\n    function isSystem(address _account) external view returns (bool);\n    function isRelay(address _account) external view returns (bool);\n    function isMultisig(address _contract) external view returns (bool);\n\n    function confirmFor(address _address) external;\n\n    function addOperator(address _account) external;\n    function removeOperator(address _account) external;\n    function addAdmin(address _account) external;\n    function removeAdmin(address _account) external;\n    function addSystem(address _account) external;\n    function removeSystem(address _account) external;\n    function addRelay(address _account) external;\n    function removeRelay(address _account) external;\n\n    function addOperatorAndAdmin(address _account) external;\n    function removeOperatorAndAdmin(address _account) external;\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/helpers/Initializable.sol\n\npragma solidity 0.5.12;\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Initializable: Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    uint256 cs;\n    assembly { cs := extcodesize(address) }\n    return cs == 0;\n  }\n\n  function isInitialized() public view returns (bool) {\n    return initialized;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/role/base/Operatorable.sol\n\n/**\n * @title Operatorable\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev Operatorable contract stores the BaseOperators contract address, and modifiers for\n *       contracts.\n */\n\npragma solidity 0.5.12;\n\n\n\ncontract Operatorable is Initializable {\n    IBaseOperators internal operatorsInst;\n    address private operatorsPending;\n\n    event OperatorsContractChanged(address indexed caller, address indexed operatorsAddress);\n    event OperatorsContractPending(address indexed caller, address indexed operatorsAddress);\n\n    /**\n     * @dev Reverts if sender does not have operator role associated.\n     */\n    modifier onlyOperator() {\n        require(isOperator(msg.sender), \"Operatorable: caller does not have the operator role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have admin role associated.\n     */\n    modifier onlyAdmin() {\n        require(isAdmin(msg.sender), \"Operatorable: caller does not have the admin role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have system role associated.\n     */\n    modifier onlySystem() {\n        require(isSystem(msg.sender), \"Operatorable: caller does not have the system role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have multisig privileges.\n     */\n    modifier onlyMultisig() {\n        require(isMultisig(msg.sender), \"Operatorable: caller does not have multisig role\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have admin or system role associated.\n     */\n    modifier onlyAdminOrSystem() {\n        require(isAdminOrSystem(msg.sender), \"Operatorable: caller does not have the admin role nor system\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have operator or system role associated.\n     */\n    modifier onlyOperatorOrSystem() {\n        require(isOperatorOrSystem(msg.sender), \"Operatorable: caller does not have the operator role nor system\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the relay role associated.\n     */\n\tmodifier onlyRelay() {\n        require(isRelay(msg.sender), \"Operatorable: caller does not have relay role associated\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have relay or operator role associated.\n     */\n\tmodifier onlyOperatorOrRelay() {\n        require(isOperator(msg.sender) || isRelay(msg.sender), \"Operatorable: caller does not have the operator role nor relay\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have relay or admin role associated.\n     */\n\tmodifier onlyAdminOrRelay() {\n        require(isAdmin(msg.sender) || isRelay(msg.sender), \"Operatorable: caller does not have the admin role nor relay\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the operator, or system, or relay role associated.\n     */\n\tmodifier onlyOperatorOrSystemOrRelay() {\n        require(isOperator(msg.sender) || isSystem(msg.sender) || isRelay(msg.sender), \"Operatorable: caller does not have the operator role nor system nor relay\");\n        _;\n    }\n\n    /**\n     * @dev Initialization instead of constructor, called once. The setOperatorsContract function can be called only by Admin role with\n     *       confirmation through the operators contract.\n     * @param _baseOperators BaseOperators contract address.\n     */\n    function initialize(address _baseOperators) public initializer {\n        _setOperatorsContract(_baseOperators);\n    }\n\n    /**\n     * @dev Set the new the address of Operators contract, should be confirmed from operators contract by calling confirmFor(addr)\n     *       where addr is the address of current contract instance. This is done to prevent the case when the new contract address is\n     *       broken and control of the contract can be lost in such case\n     * @param _baseOperators BaseOperators contract address.\n     */\n    function setOperatorsContract(address _baseOperators) public onlyAdmin {\n        require(_baseOperators != address(0), \"Operatorable: address of new operators contract can not be zero\");\n        operatorsPending = _baseOperators;\n        emit OperatorsContractPending(msg.sender, _baseOperators);\n    }\n\n    /**\n     * @dev The function should be called from new operators contract by admin to insure that operatorsPending address\n     *       is the real contract address.\n     */\n    function confirmOperatorsContract() public {\n        require(operatorsPending != address(0), \"Operatorable: address of new operators contract can not be zero\");\n        require(msg.sender == operatorsPending, \"Operatorable: should be called from new operators contract\");\n        _setOperatorsContract(operatorsPending);\n    }\n\n    /**\n     * @return The address of the BaseOperators contract.\n     */\n    function getOperatorsContract() public view returns(address) {\n        return address(operatorsInst);\n    }\n\n    /**\n     * @return The pending address of the BaseOperators contract.\n     */\n    function getOperatorsPending() public view returns(address) {\n        return operatorsPending;\n    }\n\n    /**\n     * @return If '_account' has operator privileges.\n     */\n    function isOperator(address _account) public view returns (bool) {\n        return operatorsInst.isOperator(_account);\n    }\n\n    /**\n     * @return If '_account' has admin privileges.\n     */\n    function isAdmin(address _account) public view returns (bool) {\n        return operatorsInst.isAdmin(_account);\n    }\n\n    /**\n     * @return If '_account' has system privileges.\n     */\n    function isSystem(address _account) public view returns (bool) {\n        return operatorsInst.isSystem(_account);\n    }\n\n    /**\n     * @return If '_account' has relay privileges.\n     */\n    function isRelay(address _account) public view returns (bool) {\n        return operatorsInst.isRelay(_account);\n    }\n\n    /**\n     * @return If '_contract' has multisig privileges.\n     */\n    function isMultisig(address _contract) public view returns (bool) {\n        return operatorsInst.isMultisig(_contract);\n    }\n\n    /**\n     * @return If '_account' has admin or system privileges.\n     */\n    function isAdminOrSystem(address _account) public view returns (bool) {\n        return (operatorsInst.isAdmin(_account) || operatorsInst.isSystem(_account));\n    }\n\n    /**\n     * @return If '_account' has operator or system privileges.\n     */\n    function isOperatorOrSystem(address _account) public view returns (bool) {\n        return (operatorsInst.isOperator(_account) || operatorsInst.isSystem(_account));\n    }\n\n    /** INTERNAL FUNCTIONS */\n    function _setOperatorsContract(address _baseOperators) internal {\n        require(_baseOperators != address(0), \"Operatorable: address of new operators contract cannot be zero\");\n        operatorsInst = IBaseOperators(_baseOperators);\n        emit OperatorsContractChanged(msg.sender, _baseOperators);\n    }\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/role/trader/TraderOperatorable.sol\n\n/**\n * @title TraderOperatorable\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev TraderOperatorable contract stores TraderOperators contract address, and modifiers for\n *      contracts.\n */\n\npragma solidity 0.5.12;\n\n\n\n\n\ncontract TraderOperatorable is Operatorable {\n    ITraderOperators internal traderOperatorsInst;\n    address private traderOperatorsPending;\n\n    event TraderOperatorsContractChanged(address indexed caller, address indexed traderOperatorsAddress);\n    event TraderOperatorsContractPending(address indexed caller, address indexed traderOperatorsAddress);\n\n    /**\n     * @dev Reverts if sender does not have the trader role associated.\n     */\n\tmodifier onlyTrader() {\n        require(isTrader(msg.sender), \"TraderOperatorable: caller is not trader\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the operator or trader role associated.\n     */\n    modifier onlyOperatorOrTraderOrSystem() {\n        require(isOperator(msg.sender) || isTrader(msg.sender) || isSystem(msg.sender), \"TraderOperatorable: caller is not trader or operator or system\");\n        _;\n    }\n\n    /**\n     * @dev Initialization instead of constructor, called once. The setTradersOperatorsContract function can be called only by Admin role with\n     * confirmation through the operators contract.\n     * @param _baseOperators BaseOperators contract address.\n     * @param _traderOperators TraderOperators contract address.\n     */\n    function initialize(address _baseOperators, address _traderOperators) public initializer {\n        super.initialize(_baseOperators);\n        _setTraderOperatorsContract(_traderOperators);\n    }\n\n    /**\n     * @dev Set the new the address of Operators contract, should be confirmed from operators contract by calling confirmFor(addr)\n     * where addr is the address of current contract instance. This is done to prevent the case when the new contract address is\n     * broken and control of the contract can be lost in such case\n     * @param _traderOperators TradeOperators contract address.\n     */\n    function setTraderOperatorsContract(address _traderOperators) public onlyAdmin {\n        require(_traderOperators != address(0), \"TraderOperatorable: address of new traderOperators contract can not be zero\");\n        traderOperatorsPending = _traderOperators;\n        emit TraderOperatorsContractPending(msg.sender, _traderOperators);\n    }\n\n    /**\n     * @dev The function should be called from new operators contract by admin to insure that traderOperatorsPending address\n     *       is the real contract address.\n     */\n    function confirmTraderOperatorsContract() public {\n        require(traderOperatorsPending != address(0), \"TraderOperatorable: address of pending traderOperators contract can not be zero\");\n        require(msg.sender == traderOperatorsPending, \"TraderOperatorable: should be called from new traderOperators contract\");\n        _setTraderOperatorsContract(traderOperatorsPending);\n    }\n\n    /**\n     * @return The address of the TraderOperators contract.\n     */\n    function getTraderOperatorsContract() public view returns(address) {\n        return address(traderOperatorsInst);\n    }\n\n    /**\n     * @return The pending TraderOperators contract address\n     */\n    function getTraderOperatorsPending() public view returns(address) {\n        return traderOperatorsPending;\n    }\n\n    /**\n     * @return If '_account' has trader privileges.\n     */\n    function isTrader(address _account) public view returns (bool) {\n        return traderOperatorsInst.isTrader(_account);\n    }\n\n    /** INTERNAL FUNCTIONS */\n    function _setTraderOperatorsContract(address _traderOperators) internal {\n        require(_traderOperators != address(0), \"TraderOperatorable: address of new traderOperators contract can not be zero\");\n        traderOperatorsInst = ITraderOperators(_traderOperators);\n        emit TraderOperatorsContractChanged(msg.sender, _traderOperators);\n    }\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/helpers/Pausable.sol\n\n/**\n * @title Pausable\n * @author Connor Howe <connor.howe@sygnum.com>\n * @dev Contract module which allows children to implement an emergency stop\n *      mechanism that can be triggered by an authorized account in the TraderOperatorable\n *      contract.\n */\npragma solidity 0.5.12;\n\n\ncontract Pausable is TraderOperatorable {\n    event Paused(address indexed account);\n    event Unpaused(address indexed account);\n\n    bool internal _paused;\n\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Reverts if contract is paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by operator to pause child contract. The contract\n     *      must not already be paused.\n     */\n    function pause() public onlyOperatorOrTraderOrSystem whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /** @dev Called by operator to pause child contract. The contract\n     *       must already be paused.\n     */\n    function unpause() public onlyOperatorOrTraderOrSystem whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @return If child contract is already paused or not.\n     */\n    function isPaused() public view returns(bool){\n        return _paused;\n    }\n\n    /**\n     * @return If child contract is not paused.\n     */\n    function isNotPaused() public view returns(bool){\n        return !_paused;\n    }\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/role/interface/IRaiseOperators.sol\n\n/**\n * @title IRaiseOperators\n * @notice Interface for RaiseOperators contract\n */\n\npragma solidity 0.5.12;\n\n\ncontract IRaiseOperators {\n    function isInvestor(address _account) external view returns (bool);\n    function isIssuer(address _account) external view returns (bool);\n    function addInvestor(address _account) external;\n    function removeInvestor(address _account) external;\n    function addIssuer(address _account) external;\n    function removeIssuer(address _account) external;\n}\n\n// File: @sygnum/solidity-base-contracts/contracts/role/raise/RaiseOperatorable.sol\n\n/**\n * @title RaiseOperatorable\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev RaiseOperatorable contract stores RaiseOperators contract address, and modifiers for \n *      contracts.\n */\n\npragma solidity 0.5.12;\n\n\n\n\n\ncontract RaiseOperatorable is Operatorable {\n    IRaiseOperators internal raiseOperatorsInst;\n    address private raiseOperatorsPending;\n\n    event RaiseOperatorsContractChanged(address indexed caller, address indexed raiseOperatorsAddress);\n    event RaiseOperatorsContractPending(address indexed caller, address indexed raiseOperatorsAddress);\n\n\n    /**\n     * @dev Reverts if sender does not have the investor role associated.\n     */\n\tmodifier onlyInvestor() {\n        require(isInvestor(msg.sender), \"RaiseOperatorable: caller is not investor\");\n        _;\n    }\n\n    /**\n     * @dev Reverts if sender does not have the issuer role associated.\n     */\n    modifier onlyIssuer() {\n        require(isIssuer(msg.sender), \"RaiseOperatorable: caller is not issuer\");\n        _;\n    }\n\n    /**\n     * @dev Initialization instead of constructor, called once. The setOperatorsContract function can be called only by Admin role with\n     * confirmation through the operators contract.\n     * @param _baseOperators BaseOperators contract address.\n     */\n    function initialize(address _baseOperators, address _raiseOperators) public initializer {\n        super.initialize(_baseOperators);\n        _setRaiseOperatorsContract(_raiseOperators);\n    }\n\n    /**\n     * @dev Set the new the address of Operators contract, should be confirmed from operators contract by calling confirmFor(addr)\n     * where addr is the address of current contract instance. This is done to prevent the case when the new contract address is\n     *broken and control of the contract can be lost in such case\n     * @param _raiseOperators RaiseOperators contract address.\n     */\n    function setRaiseOperatorsContract(address _raiseOperators) public onlyAdmin {\n        require(_raiseOperators != address(0), \"RaiseOperatorable: address of new raiseOperators contract can not be zero\");\n        raiseOperatorsPending = _raiseOperators;\n        emit RaiseOperatorsContractPending(msg.sender, _raiseOperators);\n    }\n\n    /**\n     * @dev The function should be called from new operators contract by admin to insure that operatorsPending address\n     *       is the real contract address.\n     */\n    function confirmRaiseOperatorsContract() public {\n        require(raiseOperatorsPending != address(0), \"RaiseOperatorable: address of pending raiseOperators contract can not be zero\");\n        require(msg.sender == raiseOperatorsPending, \"RaiseOperatorable: should be called from new raiseOperators contract\");\n        _setRaiseOperatorsContract(raiseOperatorsPending);\n    }\n\n    /**\n     * @return The address of the RaiseOperators contract.\n     */\n    function getRaiseOperatorsContract() public view returns(address) {\n        return address(raiseOperatorsInst);\n    }\n\n    /**\n     * @return The pending RaiseOperators contract address\n     */\n    function getRaiseOperatorsPending() public view returns(address) {\n        return raiseOperatorsPending;\n    }\n\n    /**\n     * @return If '_account' has investor privileges.\n     */\n    function isInvestor(address _account) public view returns (bool) {\n        return raiseOperatorsInst.isInvestor(_account);\n    }\n\n    /**\n     * @return If '_account' has issuer privileges.\n     */\n    function isIssuer(address _account) public view returns (bool) {\n        return raiseOperatorsInst.isIssuer(_account);\n    }\n\n    /** INTERNAL FUNCTIONS */\n    function _setRaiseOperatorsContract(address _raiseOperators) internal {\n        require(_raiseOperators != address(0), \"RaiseOperatorable: address of new raiseOperators contract can not be zero\");\n        raiseOperatorsInst = IRaiseOperators(_raiseOperators);\n        emit RaiseOperatorsContractChanged(msg.sender, _raiseOperators);\n    }\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/raise/CappedRaise.sol\n\n/**\n * @title CappedRaise\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev Stores, and modified amount of shares that have been sold.  This also implements total amount available to be sold limitations.\n */\n\npragma solidity 0.5.12;\n\n\ncontract CappedRaise {\n    using SafeMath for uint256;\n\n    uint256 private minCap;\n    uint256 private maxCap;\n    uint256 private sold;\n    address[] private receivers;\n\n    mapping (address => uint256) private shares;\n\n    /**\n    * @dev Sets the minimum and maximum cap for the capital raise.\n    * @param _minCap uint256 minimum cap.\n    * @param _maxCap uint256 maximum cap.\n    */\n    function _setCap(uint256 _minCap, uint256 _maxCap) internal {\n        require(_minCap > 0, \"CappedRaise: minimum cap must exceed zero\");\n        require(_maxCap > _minCap, \"CappedRaise: maximum cap must exceed minimum cap\");\n        minCap = _minCap;\n        maxCap = _maxCap;\n    }\n\n    /**\n    * @dev updates the total that the capital raise has sold, and updates the relevant user shares balance.\n    * @param _receiver address Receiving address.\n    * @param _shares uint256 Amount of shares.\n    */\n    function _updateSold(address _receiver, uint256 _shares) internal {\n        shares[_receiver] = shares[_receiver].add(_shares);\n        sold = sold.add(_shares);\n\n        receivers.push(_receiver);\n    }\n\n    /**\n    * @return the max cap of the raise.\n    */\n    function getMaxCap() public view returns (uint256) {\n        return maxCap;\n    }\n\n    /**\n    * @return the min cap of the raise.\n    */\n    function getMinCap() public view returns (uint256) {\n        return minCap;\n    }\n\n    /**\n    * @return the sold amount of the raise.\n    */\n    function getSold() public view returns (uint256) {\n        return sold;\n    }\n\n    /**\n    * @return the length of receivers.\n    */\n    function getReceiversLength() public view returns (uint256) {\n        return receivers.length;\n    }\n\n    /**\n    * @return receiver address at index.\n    */\n    function getReceiver(uint256 _index) public view returns (address) {\n        return receivers[_index];\n    }\n\n    /**\n    * @dev returns sub-array of receivers for a given range of indices\n    * @param _start uint256 start index\n    * @param _end uint256 end index\n    * @return address[] sub-array of receivers' addressess\n    */\n    function getReceiversBatch(uint256 _start, uint256 _end) public view returns (address[] memory) {\n        require(_start < _end, \"CappedRaise: Wrong receivers array indices\");\n        require(_end.sub(_start) <= 256, \"CappedRaise: Greater than block limit\");\n        address[] memory _receivers = new address[](_end.sub(_start));\n        for(uint256 _i = 0; _i < _end.sub(_start); _i++){\n            _receivers[_i] = _i.add(_start) < receivers.length ? receivers[_i.add(_start)] : address(0);\n        }\n        return _receivers;\n    }\n\n    /**\n    * @return the available shares of raise (shares that are not sold yet).\n    */\n    function getAvailableShares() public view returns (uint256) {\n        return maxCap.sub(sold);\n    }\n\n    /**\n    * @return the receiver's shares.\n    */\n    function getShares(address _receiever) public view returns (uint256) {\n        return shares[_receiever];\n    }\n\n    /**\n    * @dev Checks whether the max cap has been reached.\n    * @return Whether the max cap has been reached.\n    */\n    function maxCapReached() public view returns (bool) {\n        return sold >= maxCap;\n    }\n\n    /**\n    * @dev Checks whether the min cap has been reached.\n    * @return Whether the min cap has been reached.\n    */\n    function minCapReached() public view returns (bool) {\n        return sold >= minCap;\n    }\n}\n\n// File: contracts/raise/TimedRaise.sol\n\n/**\n * @title TimedRaise\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev This contract implements time limitations upon contributions.\n */\n\npragma solidity 0.5.12;\n\n\ncontract TimedRaise {\n    using SafeMath for uint256;\n\n    uint256 private openingTime;\n    uint256 private closingTime;\n\n    /**\n    * @dev Reverts if not in raise time range.\n    */\n    modifier onlyWhileOpen {\n        require(isOpen(), \"TimedRaise: not open\");\n        _;\n    }\n\n    /**\n    * @dev Reverts if not after raise time range.\n    */\n    modifier onlyWhenClosed {\n        require(hasClosed(), \"TimedRaise: not closed\");\n        _;\n    }\n\n    /**\n    * @dev sets raise opening and closing times.\n    * @param _openingTime uint256 Opening time for raise.\n    * @param _closingTime uint256 Closing time for raise.\n    */\n    function _setTime(uint256 _openingTime, uint256 _closingTime) internal {\n        require(_openingTime >= block.timestamp, \"TimedRaise: opening time is before current time\");\n        require(_closingTime > _openingTime, \"TimedRaise: opening time is not before closing time\");\n\n        openingTime = _openingTime;\n        closingTime = _closingTime;\n    }\n\n    /**\n    * @return the raise opening time.\n    */\n    function getOpening() public view returns (uint256) {\n        return openingTime;\n    }\n\n    /**\n    * @return the raise closing time.\n    */\n    function getClosing() public view returns (uint256) {\n        return closingTime;\n    }\n\n    /**\n    * @return true if the raise is open, false otherwise.\n    */\n    function isOpen() public view returns (bool) {\n        return now >= openingTime && now <= closingTime;\n    }\n\n    /**\n    * @dev Checks whether the period in which the raise is open has already elapsed.\n    * @return Whether raise period has elapsed\n    */\n    function hasClosed() public view returns (bool) {\n        return now > closingTime;\n    }\n}\n\n// File: contracts/libraries/Bytes32Set.sol\n\npragma solidity 0.5.12;\n\n// SPDX-License-Identifier: Unlicensed\n// https://github.com/rob-Hitchens/SetTypes/blob/master/contracts/Bytes32Set.sol\n\nlibrary Bytes32Set {\n    \n    struct Set {\n        mapping(bytes32 => uint) keyPointers;\n        bytes32[] keyList;\n    }\n    \n    /**\n     * @notice insert a key. \n     * @dev duplicate keys are not permitted.\n     * @param self storage pointer to a Set. \n     * @param key value to insert.\n     */\n    function insert(Set storage self, bytes32 key) internal {\n        require(!exists(self, key), \"Bytes32Set: key already exists in the set.\");\n        self.keyPointers[key] = self.keyList.length;\n        self.keyList.push(key);\n    }\n\n    /**\n     * @notice remove a key.\n     * @dev key to remove must exist. \n     * @param self storage pointer to a Set.\n     * @param key value to remove.\n     */\n    function remove(Set storage self, bytes32 key) internal {\n        require(exists(self, key), \"Bytes32Set: key does not exist in the set.\");\n        uint last = count(self) - 1;\n        uint rowToReplace = self.keyPointers[key];\n        if(rowToReplace != last) {\n            bytes32 keyToMove = self.keyList[last];\n            self.keyPointers[keyToMove] = rowToReplace;\n            self.keyList[rowToReplace] = keyToMove;\n        }\n        delete self.keyPointers[key];\n        self.keyList.pop();\n    }\n\n    /**\n     * @notice count the keys.\n     * @param self storage pointer to a Set. \n     */    \n    function count(Set storage self) internal view returns(uint) {\n        return(self.keyList.length);\n    }\n    \n    /**\n     * @notice check if a key is in the Set.\n     * @param self storage pointer to a Set.\n     * @param key value to check. \n     * @return bool true: Set member, false: not a Set member.\n     */\n    function exists(Set storage self, bytes32 key) internal view returns(bool) {\n        if(self.keyList.length == 0) return false;\n        return self.keyList[self.keyPointers[key]] == key;\n    }\n\n    /**\n     * @notice fetch a key by row (enumerate).\n     * @param self storage pointer to a Set.\n     * @param index row to enumerate. Must be < count() - 1.\n     */    \n    function keyAtIndex(Set storage self, uint index) internal view returns(bytes32) {\n        return self.keyList[index];\n    }\n}\n\n// File: contracts/raise/Raise.sol\n\n/**\n * @title Raise\n * @author Connor Howe <Connor.howe@sygnum.com>\n * @dev The Raise contract acts as an escrow for subscriptions, and issuer payments.\n *       This contract also has a cap upon how much can be purchased, and time boundaries implemented.\n *       Contract is spawned from RaiseFactory.\n */\n\npragma solidity 0.5.12;\n\n\n\n\n\n\n\ncontract Raise is RaiseOperatorable, CappedRaise, TimedRaise, Pausable {\n    using SafeMath for uint256;\n    using Bytes32Set for Bytes32Set.Set;\n\n    IERC20 public dchf;\n    address public issuer;\n    uint256 public price;\n    uint256 public minSubscription;\n    uint256 public totalPendingDeposits;\n    uint256 public totalDeclinedDeposits;\n    uint256 public totalAcceptedDeposits;\n    bool public issuerPaid;\n\n    mapping (bytes32 => Subscription) public subscription;\n    mapping (bool => Bytes32Set.Set) internal subscriptions;\n    mapping (address => mapping (bool => Bytes32Set.Set)) internal investor;\n\n    Stage public stage;\n    enum Stage { Created, RepayAll, IssuerAccepted, OperatorAccepted, Closed }\n\n    struct Subscription {\n        address investor;\n        uint256 shares;\n        uint256 cost;\n    }\n\n    uint16 constant BATCH_LIMIT = 256;\n\n    event SubscriptionProposal(address indexed issuer, address indexed investor, bytes32 subID);\n    event SubscriptionAccepted(address indexed payee, bytes32 subID, uint256 shares, uint256 cost);\n    event SubscriptionDeclined(address indexed payee, bytes32 subID, uint256 cost);\n    event RaiseClosed(address indexed issuer, bool accepted);\n    event OperatorRaiseFinalization(address indexed issuer, bool accepted);\n    event IssuerPaid(address indexed issuer, uint256 amount);\n    event OperatorClosed(address indexed operator);\n    event UnsuccessfulRaise(address indexed issuer);\n    event ReleasedPending(address indexed investor, uint256 amount);\n    event ReleasedEmergency(address indexed investor, uint256 amount);\n\n    /**\n    * @dev Reverts if caller is not the issuer.\n    */\n    modifier onlyIssuer() {\n      require(msg.sender == issuer, \"Raise: caller not issuer\");\n      _;\n    }\n\n    /**\n    * @dev Reverts the current stage is not the specified stage.\n    */\n    modifier onlyAtStage(Stage _stage) {\n      require(stage == _stage, \"Raise: not at correct stage\");\n      _;\n    }\n\n    /**\n    * @dev Initialization instead of constructor, called once to initialize all the necessary values.\n    * @param _dchf DCHF proxy contract address.\n    * @param _issuer Address of capital raise issuer.\n    * @param _min Minimum amount required in DCHF for the capital raise.\n    * @param _max Maximum amount required in DCHF for the capital raise.\n    * @param _price DCHF price per share.\n    * @param _minSubscription Minimum amount in DCHF that is required for a subscription.\n    * @param _open Opening time in unix epoch time.\n    * @param _close Closing time in unix epoch time.\n    * @param _baseOperators BaseOperators contract address.\n    * @param _raiseOperators RaiseOperators contract address.\n    */\n    function initialize(\n        IERC20 _dchf, address _issuer,\n        uint256 _min, uint256 _max,\n        uint256 _price, uint256 _minSubscription,\n        uint256 _open, uint256 _close,\n        address _baseOperators, address _raiseOperators\n    )\n        public\n        initializer\n    {\n        dchf = _dchf;\n        price = _price;\n        issuer = _issuer;\n        _setCap(_min, _max);\n        _setTime(_open, _close);\n        minSubscription = _minSubscription;\n        RaiseOperatorable.initialize(_baseOperators, _raiseOperators);\n    }\n\n    /**\n    * @dev Investor can subscribe to the capital raise with the unique subscription hash.\n    * @param _subID Subscription unique identifier\n    * @param _shares Amount of shares to purchase.\n    */\n    function subscribe(bytes32 _subID, uint256 _shares)\n        public\n        whenNotPaused\n        onlyInvestor\n        onlyAtStage(Stage.Created)\n        onlyWhileOpen\n    {\n        require(_shares <= getAvailableShares(), 'Raise: above available');\n\n        uint256 cost = _shares.mul(price);\n\n        require(cost >= minSubscription, 'Raise: below minimum subscription');\n        require(cost <= dchf.allowance(msg.sender, address(this)), 'Raise: below allowance');\n\n        dchf.transferFrom(msg.sender, address(this), cost);\n        totalPendingDeposits = totalPendingDeposits.add(cost);\n\n        investor[msg.sender][false].insert(_subID);\n        subscriptions[false].insert(_subID);\n        subscription[_subID] = Subscription({\n            investor: msg.sender,\n            shares: _shares,\n            cost: cost\n        });\n\n        emit SubscriptionProposal(issuer, msg.sender, _subID);\n    }\n\n    /**\n    * @dev Issuer accept or decline subscription.\n    * @param _subID Subscription unique identifier\n    * @param _accept Whether acceptance or not.\n    */\n    function issuerSubscription(bytes32 _subID, bool _accept)\n        public\n        whenNotPaused\n        onlyIssuer\n        onlyAtStage(Stage.Created)\n    {\n        require(subscriptions[false].exists(_subID), 'Raise: subscription does not exist');\n        require(!maxCapReached(), 'Raise: max sold already met');\n\n        Subscription memory sub = subscription[_subID];\n\n        totalPendingDeposits = totalPendingDeposits.sub(sub.cost);\n\n        if(!_accept || getAvailableShares() < sub.shares){\n          subscriptions[false].remove(_subID);\n          investor[sub.investor][false].remove(_subID);\n          totalDeclinedDeposits = totalDeclinedDeposits.add(sub.cost);\n          delete subscription[_subID];\n          dchf.transfer(sub.investor, sub.cost);\n          emit SubscriptionDeclined(sub.investor, _subID, sub.cost);\n          return;\n        }\n\n        subscriptions[false].remove(_subID);\n        subscriptions[true].insert(_subID);\n        investor[sub.investor][false].remove(_subID);\n        investor[sub.investor][true].insert(_subID);\n        _updateSold(sub.investor, sub.shares);\n        totalAcceptedDeposits = totalAcceptedDeposits.add(sub.cost);\n        emit SubscriptionAccepted(sub.investor, _subID, sub.shares, sub.cost);\n    }\n\n    /**\n    * @dev Issuer closes the capital raise.\n    * @param _accept Whether acceptance or not of the capital raise.\n    */\n    function issuerClose(bool _accept)\n        public\n        whenNotPaused\n        onlyIssuer\n        onlyAtStage(Stage.Created)\n    {\n        if(!minCapReached() && hasClosed()){\n            stage = Stage.RepayAll;\n            emit UnsuccessfulRaise(msg.sender);\n        } else if((minCapReached() && hasClosed()) || maxCapReached()){\n            stage = _accept ? Stage.IssuerAccepted : Stage.RepayAll;\n            emit RaiseClosed(msg.sender, _accept);\n        }\n    }\n\n    /**\n    * @dev Operator finalize capital raise after issuer has accepted.\n    * @param _accept Whether acceptance or not of the capital raise.\n    */\n    function operatorFinalize(bool _accept)\n        public\n        whenNotPaused\n        onlyOperator\n    {\n        if(_accept){\n            require(stage == Stage.IssuerAccepted, 'Raise: incorrect stage');\n            stage = Stage.OperatorAccepted;\n        } else {\n            require(stage != Stage.OperatorAccepted && stage != Stage.Closed, 'Raise: incorrect stage');\n            stage = Stage.RepayAll;\n        }\n        emit OperatorRaiseFinalization(msg.sender, _accept);\n    }\n\n    /**\n    * @dev Release DCHF obtained to issuer.\n    */\n    function releaseToIssuer()\n        public\n        whenNotPaused\n        onlyOperatorOrSystem\n        onlyAtStage(Stage.OperatorAccepted)\n    {\n        require(!issuerPaid, 'Raise: issuer already paid');\n        issuerPaid = true;\n\n        dchf.transfer(issuer, totalAcceptedDeposits);\n\n        emit IssuerPaid(issuer, totalAcceptedDeposits);\n    }\n\n    /**\n    * @dev Release pending DCHF subscriptions.\n    */\n    function batchReleasePending(address[] memory _investors)\n        public\n        whenNotPaused\n        onlyOperatorOrSystem\n    {\n        require(_investors.length <= BATCH_LIMIT, \"Raise: batch count is greater than BATCH_LIMIT\");\n        require(stage != Stage.Created, \"Raise: not at correct stage\");\n        for(uint i = 0; i < _investors.length; i++) {\n            address user = _investors[i];\n            uint256 amount = _clearInvestorFunds(user, false);\n            dchf.transfer(user, amount);\n            emit ReleasedPending(user, amount);\n        }\n    }\n\n    /**\n    * @dev Close the capital raise after either pending participants have been paid back, or all participants have been repaid.\n    */\n    function close()\n        public\n        whenNotPaused\n        onlyOperatorOrSystem\n        onlyWhenClosed\n    {\n        require(stage == Stage.OperatorAccepted || stage == Stage.RepayAll, \"Raise: not at correct stage\");\n        require(subscriptions[false].count() == 0, 'Raise: pending not emptied');\n\n        if (stage == Stage.OperatorAccepted)\n          require(issuerPaid, 'Raise: issuer not been paid');\n\n        if (stage == Stage.RepayAll)\n          require(subscriptions[true].count() == 0, 'Raise: not emptied');\n\n        stage = Stage.Closed;\n        emit OperatorClosed(msg.sender);\n    }\n\n    /**\n    * @dev Pay pending and accepted DCHF back to investors.\n    * @param _investors Array of investors to repay.\n    */\n    function releaseAllFunds(address[] memory _investors)\n        public\n        onlyOperatorOrSystem\n    {\n        require(Pausable.isPaused() || stage == Stage.RepayAll, 'Raise: not at correct stage\"');\n\n        for(uint i = 0; i < _investors.length; i++) {\n            address user = _investors[i];\n            uint256 amount = _clearInvestorFunds(user, false).add(_clearInvestorFunds(user, true));\n            if(amount > 0){\n                dchf.transfer(user, amount);\n                emit ReleasedEmergency(user, amount);\n            }\n        }\n    }\n\n    /**\n    * @param _accept Pending or accepted.\n    * @return Amount of pending/accepted subscriptions.\n    */\n    function getSubscriptionTypeLength(bool _accept)\n        public\n        view\n        returns(uint256)\n    {\n        return (subscriptions[_accept].count());\n    }\n\n    /**\n    * @param _investor address of investor.\n    * @param _accept pending or accepted.\n    * @return Subscription IDs per investor for pending or accepted subscriptions.\n    */\n    function getSubIDs(address _investor, bool _accept)\n        public\n        view\n        returns(bytes32[] memory)\n    {\n        bytes32[] memory subIDs = new bytes32[](investor[_investor][_accept].count());\n        for(uint256 i = 0; i < investor[_investor][_accept].count(); i++) {\n            subIDs[i] = investor[_investor][_accept].keyAtIndex(i);\n        }\n        return subIDs;\n    }\n\n    /**\n    * @param _investor address of investor.\n    * @param _accept pending or accepted.\n    * @return Subscription IDs per investor for pending or accepted subscriptions.\n    */\n    function getDeposits(address _investor, bool _accept)\n        public\n        view\n        returns(uint256 deposit)\n    {\n        bytes32[] memory subIDs = getSubIDs(_investor, _accept);\n\n        for(uint256 i = 0; i < subIDs.length; i++){\n            bytes32 subID = subIDs[i];\n\n            deposit = deposit.add(subscription[subID].cost);\n        }\n        return deposit;\n    }\n\n    function _clearInvestorFunds(address _user, bool _approved)\n      internal\n      returns (uint256)\n    {\n      uint256 amount;\n      while ( investor[_user][_approved].count() != 0) {\n          bytes32 subID = investor[_user][_approved].keyAtIndex(0);\n          Subscription memory sub = subscription[subID];\n          amount = amount.add(sub.cost);\n          subscriptions[_approved].remove(subID);\n          investor[_user][_approved].remove(subID);\n          delete subscription[subID];\n      }\n      return amount;\n    }\n}\n"}}}