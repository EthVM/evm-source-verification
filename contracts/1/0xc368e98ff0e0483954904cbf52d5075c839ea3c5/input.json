{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"singing.sol":{"content":"// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.8.4;\n\ncontract Singing {\n    mapping (address => uint256) internal _rOwned;\n    mapping (address => uint256) internal _tOwned;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping(address => bool) public isTaxedAsSender;\n\tmapping(address => bool) public isTaxedAsRecipient;\n    mapping (address => bool) public isExcluded;\n    address[] internal _excluded;\n\n    string public constant name = \"Singing\";\n    string public constant symbol = \"SING\";\n    uint8 public constant decimals = 18;\n\n    uint256 public constant totalSupply = 1_000_000_000 * (10 ** decimals);\n    uint256 internal _rTotal = (type(uint256).max - (type(uint256).max % totalSupply));\n    uint256 internal _tFeeTotal;\n    uint256 constant internal _reflectBasisPoints = 5000;  // 0.01% = 1 basis point, 4.00% = 400 basis points\n    uint256 internal reflectDisabledBlock;\n\n    address public owner;\n    address public pendingOwner;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed account, address indexed spender, uint256 value);\n    \n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    constructor () {\n        owner = msg.sender;\n        _rOwned[msg.sender] = _rTotal;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    modifier isOwner() {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return isExcluded[account] ? _tOwned[account] : tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function totalFees() external view returns (uint256) {\n        return _tFeeTotal;\n    }\n    \n    function reflect(uint256 tAmount) external {\n        require(!isExcluded[msg.sender], \"IS_EXCLUDED\");\n        \n        (uint256 rAmount,,,,) = _getValues(address(0), address(0), tAmount);\n        \n        _rOwned[msg.sender] -= rAmount;\n        _rTotal -= rAmount;\n        _tFeeTotal += tAmount;\n    }\n\n    function reflectionFromToken(address sender, address recipient, uint256 tAmount, bool deductTransferFee) external view returns (uint256) {\n        require(tAmount <= totalSupply, \"AMOUNT_>_SUPPLY\");\n        \n        (uint256 rAmount,uint256 rTransferAmount,,,) = _getValues(sender, recipient, tAmount);\n        \n        return deductTransferFee ? rTransferAmount : rAmount;\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n        require(rAmount <= _rTotal, \"AMOUNT_>_TOTAL_REFLECTIONS\");\n        return rAmount / _getRate();\n    }\n\n    function setSenderTaxed(address account, bool taxed) external isOwner {\n        // by default, all senders are not taxed\n        isTaxedAsSender[account] = taxed;\n\t}\n\t\n\tfunction setRecipientTaxed(address account, bool taxed) external isOwner {\n\t    // by default, all recipients are not taxed\n        isTaxedAsRecipient[account] = taxed;\n\t}\n\n    function excludeAccountFromRewards(address account) external isOwner {\n        require(!isExcluded[account], \"IS_EXCLUDED\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        \n        isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeAccountFromRewards(address account) external isOwner {\n        require(isExcluded[account], \"IS_INCLUDED\");\n        \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _approve(address account, address spender, uint256 amount) internal {\n        allowance[account][spender] = amount;\n        emit Approval(account, spender, amount);\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(sender, recipient, amount);\n        \n        _rOwned[sender] -= rAmount;\n        _rOwned[recipient] += rTransferAmount;\n        \n        if (isExcluded[sender] && !isExcluded[recipient]) {\n            _tOwned[sender] -= amount;\n        } else if (!isExcluded[sender] && isExcluded[recipient]) {\n            _tOwned[recipient] += tTransferAmount;\n        } else if (isExcluded[sender] && isExcluded[recipient]) {\n            _tOwned[sender] -= amount;\n            _tOwned[recipient] += tTransferAmount;\n        }\n        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) internal {\n        _rTotal -= rFee;\n        _tFeeTotal += tFee;\n    }\n\n    function _getValues(address sender, address recipient, uint256 tAmount) internal view returns (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) {\n        (tTransferAmount, tFee) = _getTValues(sender, recipient, tAmount);\n        (rAmount, rTransferAmount, rFee) = _getRValues(tAmount, tFee, _getRate());\n    }\n\n    function _getTValues(address sender, address recipient, uint256 tAmount) internal view returns (uint256 tTransferAmount, uint256 tFee) {\n        tFee = (block.number != reflectDisabledBlock) && (isTaxedAsSender[sender] || isTaxedAsRecipient[recipient])\n            ? (tAmount * _reflectBasisPoints) / 10_000\n            : 0;\n        \n        tTransferAmount = tAmount - tFee;\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) internal pure returns (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) {\n        rAmount = tAmount * currentRate;\n        rFee = tFee * currentRate;\n        rTransferAmount = rAmount - rFee;\n    }\n\n    function _getRate() internal view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    function _getCurrentSupply() internal view returns (uint256 rSupply, uint256 tSupply) {\n        rSupply = _rTotal;\n        tSupply = totalSupply; \n        \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, totalSupply);\n            \n            rSupply -= _rOwned[_excluded[i]];\n            tSupply -= _tOwned[_excluded[i]];\n        }\n        \n        if (rSupply < (_rTotal / totalSupply)) {\n            (rSupply, tSupply) = (_rTotal, totalSupply);\n        }\n    }\n    \n    function changeOwner(address newOwner) external isOwner {\n        pendingOwner = newOwner;\n\t}\n\t\n\tfunction acceptOwnership() external {\n        require(msg.sender == pendingOwner, \"NOT_PENDING_OWNER\");\n        \n        emit OwnershipTransferred(owner, msg.sender);\n        \n        owner = msg.sender;\n        pendingOwner = address(0);\n\t}\n\t\n\tfunction disableReflectionForCurrentBlock() external isOwner {\n\t    reflectDisabledBlock = block.number;\n\t}\n\t\n\tfunction resetReflectDisabledBlock() external isOwner {\n\t    reflectDisabledBlock = 0;\n\t}\n}\n\ninterface UniswapRouterV202 {\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    \n    function factory() external pure returns (address);\n}\n\ninterface UniswapPairV2 {\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n}\n\ncontract SingingOwner {\n    Singing immutable public token;\n    address public owner;\n    address public pendingOwner;\n    \n    UniswapRouterV202 public router;\n    UniswapPairV2 public pair;\n    \n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n    \n    constructor (address tokenAddress, address routerAddress, address pairAddress) {\n        owner = msg.sender;\n        token = Singing(tokenAddress);\n        router = UniswapRouterV202(routerAddress);\n        pair = UniswapPairV2(pairAddress);\n    }\n    \n    modifier isOwner() {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _;\n    }\n    \n    function changeOwner(address newOwner) external isOwner {\n        pendingOwner = newOwner;\n\t}\n\t\n\tfunction acceptOwner() external {\n        require(msg.sender == pendingOwner, \"NOT_PENDING_OWNER\");\n        \n        emit OwnershipTransferred(owner, msg.sender);\n        \n        owner = msg.sender;\n        pendingOwner = address(0);\n\t}\n\t\n\tfunction changeOwnerOfToken(address newOwner) external isOwner {\n        token.changeOwner(newOwner);\n\t}\n\t\n\tfunction acceptOwnershipOfToken() external isOwner {\n\t    token.acceptOwnership();\n\t}\n    \n    function setSenderTaxed(address account, bool taxed) external isOwner {\n        token.setSenderTaxed(account, taxed);\n\t}\n\t\n\tfunction setRecipientTaxed(address account, bool taxed) external isOwner {\n\t    token.setRecipientTaxed(account, taxed);\n\t}\n\n    function setAccountGetsRewards(address account, bool getsRewards) external isOwner {\n        getsRewards ? token.includeAccountFromRewards(account) : token.excludeAccountFromRewards(account);\n    }\n    \n    function addLiquidityETH(\n        address tokenAddress,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity) {\n        require(tokenAddress == address(token), \"NOT_TOKEN\");\n        \n        // Turn off tax for this block\n        token.disableReflectionForCurrentBlock();\n        \n        // Transfer token from caller to this\n        token.transferFrom(msg.sender, address(this), amountTokenDesired);\n        \n        // Approve Router on the amount of token\n        token.approve(address(router), amountTokenDesired);\n        \n        // Perform the liquidity add\n        (amountToken, amountETH, liquidity) = router.addLiquidityETH{value: msg.value}(tokenAddress, amountTokenDesired, amountTokenMin, amountETHMin, to, deadline);\n        \n        uint256 leftOver = token.balanceOf(address(this));\n\n        if (leftOver > 0) {\n            // Transfer leftover ETH or tokens to the caller\n            token.transfer(msg.sender, leftOver);\n        }\n\n        leftOver = address(this).balance;\n\n        if (leftOver > 0) {\n            payable(msg.sender).transfer(leftOver);\n        }\n        \n        // Turn on tax for this block\n        token.resetReflectDisabledBlock();\n    }\n    \n    function setRouterAndPair(address routerAddress, address pairAddress) external isOwner {\n        router = UniswapRouterV202(routerAddress);\n        pair = UniswapPairV2(pairAddress);\n    }\n    \n    receive() external payable {}\n}\n"}}}