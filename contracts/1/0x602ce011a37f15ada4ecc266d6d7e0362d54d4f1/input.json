{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AXC.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2019-09-04\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2019-08-20\n*/\n\npragma solidity ^0.5.17;\n\n// ----------------------------------------------------------------------------------------------\n// Acute Angle Coin by SCC Limited. \n// An ERC20 standard\n//\n// author:SCC Team\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint256 _totalSupply);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract SCC is ERC20Interface {\n    uint256 public constant decimals = 18;\n\n    string public constant symbol = \"SCC\";\n    string public constant name = \"Shared Charging Coin & Energy Token\";\n\n    uint256 public _totalSupply = 1000000000*(10 ** 18);\n\n    // Owner of this contract\n    address public owner;\n\n    // Balances SDAAC for each account\n    mapping(address => uint256) private balances;\n\n    // Owner of account approves the transfer of an amount to another account\n    mapping(address => mapping (address => uint256)) private allowed;\n\n    // List of approved investors\n    mapping(address => bool) private approvedInvestorList;\n\n    // deposit\n    // mapping(address => uint256) private deposit;\n\n    // totalTokenSold\n    // uint256 public totalTokenSold = 0;\n\n\n    /**\n     * @dev Fix for the ERC20 short address attack.\n     */\n    modifier onlyPayloadSize(uint size) {\n      if(msg.data.length < size + 4) {\n        revert();\n      }\n      _;\n    }\n\n\n\n    /// @dev Constructor\n    \n    constructor() public {\n        owner = msg.sender;\n        balances[owner] = _totalSupply;\n    }\n\n    /// @dev Gets totalSupply\n    /// @return Total supply\n    function totalSupply()\n        public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @dev Gets account's balance\n    /// @param _addr Address of the account\n    /// @return Account balance\n    function balanceOf(address _addr)\n        public view returns (uint256) {\n        return balances[_addr];\n    }\n\n    /// @dev check address is approved investor\n    /// @param _addr address\n    function isApprovedInvestor(address _addr)\n        public view returns (bool) {\n        return approvedInvestorList[_addr];\n    }\n\n    /// @dev get ETH deposit\n    /// @param _addr address get deposit\n    /// @return amount deposit of an buyer\n    // function getDeposit(address _addr)\n    //     public constant returns(uint256){\n    //         return deposit[_addr];\n    //     }\n\n\n    /// @dev Transfers the balance from msg.sender to an account\n    /// @param _to Recipient address\n    /// @param _amount Transfered amount in unit\n    /// @return Transfer status\n    function transfer(address _to, uint256 _amount)\n        public returns (bool success) {\n            \n        // if sender's balance has enough unit and amount >= 0,\n        //      and the sum is not overflow,\n        // then do transfer\n        require(_to != address(0));\n        require((balances[msg.sender] >= _amount) && (_amount >= 0) && (balances[_to] + _amount > balances[_to]));\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n        emit Transfer(msg.sender, _to, _amount);\n        success = true;\n    }\n\n    // Send _value amount of tokens from address _from to address _to\n    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n    // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n    // fees in sub-currencies; the command should fail unless the _from account has\n    // deliberately authorized the sender of the message via some mechanism; we propose\n    // these standardized APIs for approval:\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n    public returns (bool success) {\n        require(balances[_from] >= _amount && _amount > 0);\n        require(allowed[_from][msg.sender] >= _amount);\n        require(balances[_to] + _amount > balances[_to]);\n        balances[_from] -= _amount;\n        allowed[_from][msg.sender] -= _amount;\n        balances[_to] += _amount;\n        emit Transfer(_from, _to, _amount);\n        success =  true;\n    }\n\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    // If this function is called again it overwrites the current allowance with _value.\n    function approve(address _spender, uint256 _amount)\n        public\n\n        returns (bool success) {\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    // get allowance\n    function allowance(address _owner, address _spender)\n        public\n        view\n        returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function () external payable {\n        revert();\n    }\n}"
    }
  }
}