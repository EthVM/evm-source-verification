{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CairoBootloaderProgram.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ncontract CairoBootloaderProgramSize {\n    uint256 internal constant PROGRAM_SIZE = 216;\n}\n\ncontract CairoBootloaderProgram is CairoBootloaderProgramSize {\n    function getCompiledProgram()\n        external pure\n        returns (uint256[PROGRAM_SIZE] memory)\n    {\n        return [\n            290341444919459839,\n            5,\n            1226245742482522112,\n            167,\n            74168662805676031,\n            0,\n            146226256843603965,\n            4,\n            5191102238658887680,\n            2345108766317314046,\n            290341444919459839,\n            3,\n            4632937381316558848,\n            4612671182992932865,\n            4612671182992998402,\n            146226256843603968,\n            4,\n            74168662805676031,\n            4,\n            4612671182993063937,\n            4612671182993129474,\n            5198983563776196608,\n            1,\n            5198983563776262144,\n            1,\n            5200109459388203008,\n            5200109459388268544,\n            5198983563776458752,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020458,\n            2345108766317314046,\n            2345108766317314046,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            5198420613823102976,\n            3618502788666131213697322783095070105623107215331596699973092056135872020479,\n            2345108766317314046,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020475,\n            5191102234363920384,\n            5191102238658887680,\n            5191102242953854976,\n            5198420613822906368,\n            60,\n            5189976364521848832,\n            5,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020440,\n            4623648689905041407,\n            291467327646433279,\n            2345108766317314046,\n            5199827962936983548,\n            5208553695804948479,\n            4612389708016287743,\n            5198983563776262144,\n            1,\n            2345108766317314046,\n            146226256843603965,\n            4,\n            5191102230068953088,\n            2345108766317314046,\n            5191102230068953088,\n            5188850460319711232,\n            5188850460319776768,\n            5188850460319842304,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020467,\n            5198983563776262144,\n            1,\n            5198983563776327680,\n            1,\n            5198983563776393216,\n            1,\n            5198983563776458752,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020463,\n            2345108766317314046,\n            5188850460319907840,\n            5202361254907052032,\n            5191102242953854976,\n            5188287510366552064,\n            5188287506071519232,\n            5188287510366486527,\n            4611826762357964797,\n            5198420613822906368,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            5198420613822906368,\n            3,\n            5188287518956224512,\n            4623085744246521853,\n            145944781866893308,\n            3618502788666131213697322783095070105623107215331596699973092056135872020472,\n            2345108766317314046,\n            146226256843603965,\n            5,\n            5191102230068953088,\n            5191102242953854976,\n            2345108766317314046,\n            290341444919459839,\n            18,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020411,\n            4617174774030761984,\n            4612671182992932866,\n            5189976364521848832,\n            0,\n            4612389712311713791,\n            5188850464614612992,\n            5191102264428691456,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020449,\n            4612389712311779327,\n            4622804286450008067,\n            4,\n            4612671195878359044,\n            5200109476568596480,\n            5188850468910104576,\n            4625619027626983429,\n            4622804286450073606,\n            2,\n            4617174765440827399,\n            4612671191582867464,\n            4612671195877834761,\n            4612671200172802058,\n            5191102234363920384,\n            5198983563776655360,\n            6,\n            5191102273018626048,\n            5191102277313593344,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020388,\n            1191342862550269952,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020380,\n            4623648724265697279,\n            5191102234363920384,\n            5198983563776655360,\n            12,\n            5191102273018626048,\n            5191102307378364416,\n            5189976364521848832,\n            5,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020343,\n            4623648719970271231,\n            5191102242953854976,\n            5198983563776655360,\n            6,\n            5198983563776655360,\n            12,\n            5191102238658887680,\n            5189976364521848832,\n            5,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020384,\n            4623930190652866572,\n            4612671182993522705,\n            5198983563776655360,\n            12,\n            5191102234363920384,\n            5191102238658887680,\n            5193354042767540224,\n            5198983563776458752,\n            3618502788666131213697322783095070105623107215331596699973092056135872020480,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020410,\n            2345108766317314046,\n            290341444919459839,\n            16,\n            4622804286449483777,\n            1,\n            4614922957037207554,\n            4614922982807011331,\n            4614922965627142148,\n            4614922969922109445,\n            4613797087195136006,\n            122550255383924,\n            4613797087195136007,\n            8098989891770344814,\n            4613797087195136008,\n            138277649577220228665140075,\n            4613797087195136009,\n            435459224417,\n            4613797087195136010,\n            27700496658166629,\n            4613797087195136011,\n            1,\n            4613797087195136012,\n            3,\n            4613797087195136013,\n            1,\n            4613797087195136014,\n            2,\n            4613797087195136015,\n            5,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020316,\n            5198420613823102976,\n            1,\n            5198420613823037440,\n            6,\n            5198420613822971904,\n            11,\n            5191102238658887680,\n            5188850460319645696,\n            1226245742482522112,\n            3618502788666131213697322783095070105623107215331596699973092056135872020369,\n            4614641507830300671,\n            5188287510366552064,\n            5188287514661453824,\n            5188287518956355584,\n            5188287523251257344,\n            5188287527546159104,\n            2345108766317314046\n        ];\n    }\n}\n// ---------- End of auto-generated code. ----------\n"},"CairoVerifierContract.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nabstract contract CairoVerifierContract {\n    function verifyProofExternal(\n        uint256[] calldata proofParams,\n        uint256[] calldata proof,\n        uint256[] calldata publicInput\n    ) external virtual;\n\n    /*\n      Returns information that is related to the layout.\n\n      publicMemoryOffset is the offset of the public memory pages' information in the public input.\n      selectedBuiltins is a bit-map of builtins that are present in the layout.\n    */\n    function getLayoutInfo()\n        external\n        pure\n        virtual\n        returns (uint256 publicMemoryOffset, uint256 selectedBuiltins);\n\n    uint256 internal constant OUTPUT_BUILTIN_BIT = 0;\n    uint256 internal constant PEDERSEN_BUILTIN_BIT = 1;\n    uint256 internal constant RANGE_CHECK_BUILTIN_BIT = 2;\n    uint256 internal constant ECDSA_BUILTIN_BIT = 3;\n    uint256 internal constant BITWISE_BUILTIN_BIT = 4;\n}\n"},"CpuPublicInputOffsetsBase.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"PageInfo.sol\";\n\ncontract CpuPublicInputOffsetsBase is PageInfo {\n    // The following constants are offsets of data expected in the public input.\n    uint256 internal constant OFFSET_LOG_N_STEPS = 0;\n    uint256 internal constant OFFSET_RC_MIN = 1;\n    uint256 internal constant OFFSET_RC_MAX = 2;\n    uint256 internal constant OFFSET_LAYOUT_CODE = 3;\n    uint256 internal constant OFFSET_PROGRAM_BEGIN_ADDR = 4;\n    uint256 internal constant OFFSET_PROGRAM_STOP_PTR = 5;\n    uint256 internal constant OFFSET_EXECUTION_BEGIN_ADDR = 6;\n    uint256 internal constant OFFSET_EXECUTION_STOP_PTR = 7;\n    uint256 internal constant OFFSET_OUTPUT_BEGIN_ADDR = 8;\n    uint256 internal constant OFFSET_OUTPUT_STOP_PTR = 9;\n    uint256 internal constant OFFSET_PEDERSEN_BEGIN_ADDR = 10;\n    uint256 internal constant OFFSET_PEDERSEN_STOP_PTR = 11;\n    uint256 internal constant OFFSET_RANGE_CHECK_BEGIN_ADDR = 12;\n    uint256 internal constant OFFSET_RANGE_CHECK_STOP_PTR = 13;\n\n    uint256 internal constant N_WORDS_PER_PUBLIC_MEMORY_ENTRY = 2;\n    // The program segment starts from 1, so that memory address 0 is kept for the null pointer.\n    uint256 internal constant INITIAL_PC = 1;\n    // The first Cairo instructions are:\n    //   ap += n_args; call main; jmp rel 0.\n    // As the first two instructions occupy 2 cells each, the \"jmp rel 0\" instruction is at\n    // offset 4 relative to INITIAL_PC.\n    uint256 internal constant FINAL_PC = INITIAL_PC + 4;\n}\n"},"FactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"IQueryableFactRegistry.sol\";\n\ncontract FactRegistry is IQueryableFactRegistry {\n    // Mapping: fact hash -> true.\n    mapping(bytes32 => bool) private verifiedFact;\n\n    // Indicates whether the Fact Registry has at least one fact registered.\n    bool anyFactRegistered;\n\n    /*\n      Checks if a fact has been verified.\n    */\n    function isValid(bytes32 fact) external view override returns (bool) {\n        return _factCheck(fact);\n    }\n\n    /*\n      This is an internal method to check if the fact is already registered.\n      In current implementation of FactRegistry it's identical to isValid().\n      But the check is against the local fact registry,\n      So for a derived referral fact registry, it's not the same.\n    */\n    function _factCheck(bytes32 fact) internal view returns (bool) {\n        return verifiedFact[fact];\n    }\n\n    function registerFact(bytes32 factHash) internal {\n        // This function stores the fact hash in the mapping.\n        verifiedFact[factHash] = true;\n\n        // Mark first time off.\n        if (!anyFactRegistered) {\n            anyFactRegistered = true;\n        }\n    }\n\n    /*\n      Indicates whether at least one fact was registered.\n    */\n    function hasRegisteredFact() external view override returns (bool) {\n        return anyFactRegistered;\n    }\n}\n"},"GpsOutputParser.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"FactRegistry.sol\";\nimport \"CpuPublicInputOffsetsBase.sol\";\n\n/*\n  A utility contract to parse the GPS output.\n  See registerGpsFacts for more details.\n*/\ncontract GpsOutputParser is CpuPublicInputOffsetsBase, FactRegistry {\n    uint256 internal constant METADATA_TASKS_OFFSET = 1;\n    uint256 internal constant METADATA_OFFSET_TASK_OUTPUT_SIZE = 0;\n    uint256 internal constant METADATA_OFFSET_TASK_PROGRAM_HASH = 1;\n    uint256 internal constant METADATA_OFFSET_TASK_N_TREE_PAIRS = 2;\n    uint256 internal constant METADATA_TASK_HEADER_SIZE = 3;\n\n    uint256 internal constant METADATA_OFFSET_TREE_PAIR_N_PAGES = 0;\n    uint256 internal constant METADATA_OFFSET_TREE_PAIR_N_NODES = 1;\n\n    uint256 internal constant NODE_STACK_OFFSET_HASH = 0;\n    uint256 internal constant NODE_STACK_OFFSET_END = 1;\n    // The size of each node in the node stack.\n    uint256 internal constant NODE_STACK_ITEM_SIZE = 2;\n\n    uint256 internal constant FIRST_CONTINUOUS_PAGE_INDEX = 1;\n\n    /*\n      Logs the fact hash together with the relavent continuous memory pages' hashes.\n      Emitted for each registered fact.\n    */\n    event LogMemoryPagesHashes(bytes32 factHash, bytes32[] pagesHashes);\n\n    /*\n      Parses the GPS program output (using taskMetadata, which should be verified by the caller),\n      and registers the facts of the tasks which were executed.\n\n      The first entry in taskMetadata is the number of tasks.\n\n      For each task, the structure is as follows:\n        1. Size (including the size and hash fields).\n        2. Program hash.\n        3. The numebr of pairs in the Merkle tree structure (see below).\n        4. The Merkle tree structure (see below).\n\n      The fact of each task is stored as a (non-binary) Merkle tree.\n      Each non-leaf node is 1 + the hash of (node0, end0, node1, end1, ...)\n      where node* are its children and end* is the the total number of data words up to and\n      including that node and its children (including the previous sibling nodes).\n      We add 1 to the result of the hash to distinguish it from a leaf node.\n      Leaf nodes are the hash of their data.\n\n      The structure of the tree is passed as a list of pairs (n_pages, n_nodes), and the tree is\n      constructed using a stack of nodes (initialized to an empty stack) by repeating for each pair:\n      1. Add n_pages to the stack of nodes.\n      2. Pop the top n_nodes, construct a parent node for them, and push it back to the stack.\n      After applying the steps above, the stack much contain exactly one node, which will\n      constitute the root of the Merkle tree.\n      For example, [(2, 2)] will create a Merkle tree with a root and two direct children, while\n      [(3, 2), (0, 2)] will create a Merkle tree with a root whose left child is a leaf and\n      right child has two leaf children.\n\n      Assumptions: taskMetadata and cairoAuxInput are verified externally.\n    */\n    function registerGpsFacts(\n        uint256[] calldata taskMetadata,\n        uint256[] memory publicMemoryPages,\n        uint256 outputStartAddress\n    ) internal {\n        uint256 totalNumPages = publicMemoryPages[0];\n\n        // Allocate some of the loop variables here to avoid the stack-too-deep error.\n        uint256 task;\n        uint256 nTreePairs;\n        uint256 nTasks = taskMetadata[0];\n\n        // Contains fact hash with the relevant memory pages' hashes.\n        // Size is bounded from above with the total number of pages. Three extra places are\n        // dedicated for the fact hash and the array address and length.\n        uint256[] memory pageHashesLogData = new uint256[](totalNumPages + 3);\n        // Relative address to the beginning of the memory pages' hashes in the array.\n        pageHashesLogData[1] = 0x40;\n\n        uint256 taskMetadataOffset = METADATA_TASKS_OFFSET;\n\n        // Skip the 3 first output cells which contain the number of tasks and the size and\n        // program hash of the first task. curAddr points to the output of the first task.\n        uint256 curAddr = outputStartAddress + 3;\n\n        // Skip the main page.\n        uint256 curPage = FIRST_CONTINUOUS_PAGE_INDEX;\n\n        // Bound the size of the stack by the total number of pages.\n        // TODO(lior, 15/10/2021): Get a better bound on the size of the stack.\n        uint256[] memory nodeStack = new uint256[](NODE_STACK_ITEM_SIZE * totalNumPages);\n\n        // Copy to memory to workaround the \"stack too deep\" error.\n        uint256[] memory taskMetadataCopy = taskMetadata;\n\n        uint256[PAGE_INFO_SIZE] memory pageInfoPtr;\n        assembly {\n            // Skip the array length and the first page.\n            pageInfoPtr := add(add(publicMemoryPages, 0x20), PAGE_INFO_SIZE_IN_BYTES)\n        }\n\n        // Register the fact for each task.\n        for (task = 0; task < nTasks; task++) {\n            uint256 curOffset = 0;\n            uint256 firstPageOfTask = curPage;\n            nTreePairs = taskMetadataCopy[taskMetadataOffset + METADATA_OFFSET_TASK_N_TREE_PAIRS];\n\n            // Build the Merkle tree using a stack (see the function documentation) to compute\n            // the fact.\n            uint256 nodeStackLen = 0;\n            for (uint256 treePair = 0; treePair < nTreePairs; treePair++) {\n                // Add nPages to the stack of nodes.\n                uint256 nPages = taskMetadataCopy[\n                    taskMetadataOffset +\n                        METADATA_TASK_HEADER_SIZE +\n                        2 *\n                        treePair +\n                        METADATA_OFFSET_TREE_PAIR_N_PAGES\n                ];\n                require(nPages < 2**20, \"Invalid value of n_pages in tree structure.\");\n\n                for (uint256 i = 0; i < nPages; i++) {\n                    (uint256 pageSize, uint256 pageHash) = pushPageToStack(\n                        pageInfoPtr,\n                        curAddr,\n                        curOffset,\n                        nodeStack,\n                        nodeStackLen\n                    );\n                    pageHashesLogData[curPage - firstPageOfTask + 3] = pageHash;\n                    curPage += 1;\n                    nodeStackLen += 1;\n                    curAddr += pageSize;\n                    curOffset += pageSize;\n\n                    assembly {\n                        pageInfoPtr := add(pageInfoPtr, PAGE_INFO_SIZE_IN_BYTES)\n                    }\n                }\n\n                // Pop the top n_nodes, construct a parent node for them, and push it back to the\n                // stack.\n                uint256 nNodes = taskMetadataCopy[\n                    taskMetadataOffset +\n                        METADATA_TASK_HEADER_SIZE +\n                        2 *\n                        treePair +\n                        METADATA_OFFSET_TREE_PAIR_N_NODES\n                ];\n                if (nNodes != 0) {\n                    nodeStackLen = constructNode(nodeStack, nodeStackLen, nNodes);\n                }\n            }\n            require(nodeStackLen == 1, \"Node stack must contain exactly one item.\");\n\n            uint256 programHash = taskMetadataCopy[\n                taskMetadataOffset + METADATA_OFFSET_TASK_PROGRAM_HASH\n            ];\n\n            // Verify that the sizes of the pages correspond to the task output, to make\n            // sure that the computed hash is indeed the hash of the entire output of the task.\n            {\n                uint256 outputSize = taskMetadataCopy[\n                    taskMetadataOffset + METADATA_OFFSET_TASK_OUTPUT_SIZE\n                ];\n\n                require(\n                    nodeStack[NODE_STACK_OFFSET_END] + 2 == outputSize,\n                    \"The sum of the page sizes does not match output size.\"\n                );\n            }\n\n            uint256 factWithoutProgramHash = nodeStack[NODE_STACK_OFFSET_HASH];\n            bytes32 fact = keccak256(abi.encode(programHash, factWithoutProgramHash));\n\n            // Update taskMetadataOffset.\n            taskMetadataOffset += METADATA_TASK_HEADER_SIZE + 2 * nTreePairs;\n\n            {\n                // Documents each fact hash together with the hashes of the relavent memory pages.\n                // Instead of emit, we use log1 https://docs.soliditylang.org/en/v0.4.24/assembly.html,\n                // https://docs.soliditylang.org/en/v0.6.2/abi-spec.html#use-of-dynamic-types.\n\n                bytes32 logHash = keccak256(\"LogMemoryPagesHashes(bytes32,bytes32[])\");\n                assembly {\n                    let buf := add(pageHashesLogData, 0x20)\n                    // Number of memory pages that are relavent for this fact.\n                    let length := sub(curPage, firstPageOfTask)\n                    mstore(buf, factWithoutProgramHash)\n                    mstore(add(buf, 0x40), length)\n                    log1(buf, mul(add(length, 3), 0x20), logHash)\n                }\n            }\n            registerFact(fact);\n\n            // Move curAddr to the output of the next task (skipping the size and hash fields).\n            curAddr += 2;\n        }\n\n        require(totalNumPages == curPage, \"Not all memory pages were processed.\");\n    }\n\n    /*\n      Push one page (curPage) to the top of the node stack.\n      curAddr is the memory address, curOffset is the offset from the beginning of the task output.\n      Verifies that the page has the right start address and returns the page size and the page\n      hash.\n    */\n    function pushPageToStack(\n        uint256[PAGE_INFO_SIZE] memory pageInfoPtr,\n        uint256 curAddr,\n        uint256 curOffset,\n        uint256[] memory nodeStack,\n        uint256 nodeStackLen\n    ) internal pure returns (uint256 pageSize, uint256 pageHash) {\n        // Read the first address, page size and hash.\n        uint256 pageAddr = pageInfoPtr[PAGE_INFO_ADDRESS_OFFSET];\n        pageSize = pageInfoPtr[PAGE_INFO_SIZE_OFFSET];\n        pageHash = pageInfoPtr[PAGE_INFO_HASH_OFFSET];\n\n        require(pageSize < 2**30, \"Invalid page size.\");\n        require(pageAddr == curAddr, \"Invalid page address.\");\n\n        nodeStack[NODE_STACK_ITEM_SIZE * nodeStackLen + NODE_STACK_OFFSET_END] =\n            curOffset +\n            pageSize;\n        nodeStack[NODE_STACK_ITEM_SIZE * nodeStackLen + NODE_STACK_OFFSET_HASH] = pageHash;\n    }\n\n    /*\n      Pops the top nNodes nodes from the stack and pushes one parent node instead.\n      Returns the new value of nodeStackLen.\n    */\n    function constructNode(\n        uint256[] memory nodeStack,\n        uint256 nodeStackLen,\n        uint256 nNodes\n    ) internal pure returns (uint256) {\n        require(nNodes <= nodeStackLen, \"Invalid value of n_nodes in tree structure.\");\n        // The end of the node is the end of the last child.\n        uint256 newNodeEnd = nodeStack[\n            NODE_STACK_ITEM_SIZE * (nodeStackLen - 1) + NODE_STACK_OFFSET_END\n        ];\n        uint256 newStackLen = nodeStackLen - nNodes;\n        // Compute node hash.\n        uint256 nodeStart = 0x20 + newStackLen * NODE_STACK_ITEM_SIZE * 0x20;\n        uint256 newNodeHash;\n        assembly {\n            newNodeHash := keccak256(\n                add(nodeStack, nodeStart),\n                mul(\n                    nNodes,\n                    // NODE_STACK_ITEM_SIZE * 0x20 =\n                    0x40\n                )\n            )\n        }\n\n        nodeStack[NODE_STACK_ITEM_SIZE * newStackLen + NODE_STACK_OFFSET_END] = newNodeEnd;\n        // Add one to the new node hash to distinguish it from the hash of a leaf (a page).\n        nodeStack[NODE_STACK_ITEM_SIZE * newStackLen + NODE_STACK_OFFSET_HASH] = newNodeHash + 1;\n        return newStackLen + 1;\n    }\n}\n"},"GpsStatementVerifier.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"CairoBootloaderProgram.sol\";\nimport \"CairoVerifierContract.sol\";\nimport \"MemoryPageFactRegistry.sol\";\nimport \"Identity.sol\";\nimport \"PrimeFieldElement0.sol\";\nimport \"GpsOutputParser.sol\";\n\ncontract GpsStatementVerifier is\n    GpsOutputParser,\n    Identity,\n    CairoBootloaderProgramSize,\n    PrimeFieldElement0\n{\n    CairoBootloaderProgram bootloaderProgramContractAddress;\n    MemoryPageFactRegistry memoryPageFactRegistry;\n    CairoVerifierContract[] cairoVerifierContractAddresses;\n\n    uint256 internal constant N_BUILTINS = 5;\n    uint256 internal constant N_MAIN_ARGS = N_BUILTINS;\n    uint256 internal constant N_MAIN_RETURN_VALUES = N_BUILTINS;\n\n    /*\n      Constructs an instance of GpsStatementVerifier.\n      bootloaderProgramContract is the address of the bootloader program contract\n      and cairoVerifierContracts is a list of cairoVerifiers indexed by their id.\n    */\n    constructor(\n        address bootloaderProgramContract,\n        address memoryPageFactRegistry_,\n        address[] memory cairoVerifierContracts\n    ) public {\n        bootloaderProgramContractAddress = CairoBootloaderProgram(bootloaderProgramContract);\n        memoryPageFactRegistry = MemoryPageFactRegistry(memoryPageFactRegistry_);\n        cairoVerifierContractAddresses = new CairoVerifierContract[](cairoVerifierContracts.length);\n        for (uint256 i = 0; i < cairoVerifierContracts.length; ++i) {\n            cairoVerifierContractAddresses[i] = CairoVerifierContract(cairoVerifierContracts[i]);\n        }\n    }\n\n    function identify() external pure override returns (string memory) {\n        return \"StarkWare_GpsStatementVerifier_2021_4\";\n    }\n\n    /*\n      Verifies a proof and registers the corresponding facts.\n      For the structure of cairoAuxInput, see cpu/CpuPublicInputOffsets.sol.\n      taskMetadata is structured as follows:\n      1. Number of tasks.\n      2. For each task:\n         1. Task output size (including program hash and size).\n         2. Program hash.\n    */\n    function verifyProofAndRegister(\n        uint256[] calldata proofParams,\n        uint256[] calldata proof,\n        uint256[] calldata taskMetadata,\n        uint256[] calldata cairoAuxInput,\n        uint256 cairoVerifierId\n    ) external {\n        require(\n            cairoVerifierId < cairoVerifierContractAddresses.length,\n            \"cairoVerifierId is out of range.\"\n        );\n        CairoVerifierContract cairoVerifier = cairoVerifierContractAddresses[cairoVerifierId];\n\n        // The values z and alpha are used only for the fact registration of the main page.\n        // They are not part of the public input of CpuVerifier as they are computed there.\n        // Take the relevant slice from 'cairoAuxInput'.\n        uint256[] calldata cairoPublicInput = (\n            cairoAuxInput[:cairoAuxInput.length -\n                // z and alpha.\n                2]\n        );\n\n        uint256[] memory publicMemoryPages;\n        {\n            (uint256 publicMemoryOffset, uint256 selectedBuiltins) = cairoVerifier.getLayoutInfo();\n\n            require(cairoAuxInput.length > publicMemoryOffset, \"Invalid cairoAuxInput length.\");\n            publicMemoryPages = (uint256[])(cairoPublicInput[publicMemoryOffset:]);\n            uint256 nPages = publicMemoryPages[0];\n            require(nPages < 10000, \"Invalid nPages.\");\n\n            // Each page has a page info and a hash.\n            require(\n                publicMemoryPages.length == nPages * (PAGE_INFO_SIZE + 1),\n                \"Invalid publicMemoryPages length.\"\n            );\n\n            // Process public memory.\n            (\n                uint256 publicMemoryLength,\n                uint256 memoryHash,\n                uint256 prod\n            ) = registerPublicMemoryMainPage(taskMetadata, cairoAuxInput, selectedBuiltins);\n\n            // Make sure the first page is valid.\n            // If the size or the hash are invalid, it may indicate that there is a mismatch between the\n            // bootloader program contract and the program in the proof.\n            require(\n                publicMemoryPages[PAGE_INFO_SIZE_OFFSET] == publicMemoryLength,\n                \"Invalid size for memory page 0.\"\n            );\n            require(\n                publicMemoryPages[PAGE_INFO_HASH_OFFSET] == memoryHash,\n                \"Invalid hash for memory page 0.\"\n            );\n            require(\n                publicMemoryPages[nPages * PAGE_INFO_SIZE] == prod,\n                \"Invalid cumulative product for memory page 0.\"\n            );\n        }\n\n        // NOLINTNEXTLINE: reentrancy-benign.\n        cairoVerifier.verifyProofExternal(proofParams, proof, (uint256[])(cairoPublicInput));\n\n        registerGpsFacts(taskMetadata, publicMemoryPages, cairoAuxInput[OFFSET_OUTPUT_BEGIN_ADDR]);\n    }\n\n    /*\n      Registers the fact for memory page 0, which includes:\n      1. The bootloader program,\n      2. Arguments and return values of main()\n      3. Some of the data required for computing the task facts. which is represented in\n         taskMetadata.\n      Returns information on the registered fact.\n\n      Arguments:\n        selectedBuiltins: A bit-map of builtins that are present in the layout.\n            See CairoVerifierContract.sol for more information.\n        taskMetadata: Per task metadata.\n        cairoAuxInput: Auxiliary input for the cairo verifier.\n\n      Assumptions: cairoAuxInput is connected to the public input, which is verified by\n      cairoVerifierContractAddresses.\n      Guarantees: taskMetadata is consistent with the public memory, with some sanity checks.\n    */\n    function registerPublicMemoryMainPage(\n        uint256[] calldata taskMetadata,\n        uint256[] calldata cairoAuxInput,\n        uint256 selectedBuiltins\n    )\n        internal\n        returns (\n            uint256 publicMemoryLength,\n            uint256 memoryHash,\n            uint256 prod\n        )\n    {\n        uint256 nTasks = taskMetadata[0];\n        require(nTasks < 2**30, \"Invalid number of tasks.\");\n\n        // Public memory length.\n        publicMemoryLength = (PROGRAM_SIZE +\n            // return fp and pc =\n            2 +\n            N_MAIN_ARGS +\n            N_MAIN_RETURN_VALUES +\n            // Number of tasks cell =\n            1 +\n            2 *\n            nTasks);\n        uint256[] memory publicMemory = new uint256[](\n            N_WORDS_PER_PUBLIC_MEMORY_ENTRY * publicMemoryLength\n        );\n\n        uint256 offset = 0;\n\n        // Write public memory, which is a list of pairs (address, value).\n        {\n            // Program segment.\n            uint256[PROGRAM_SIZE] memory bootloaderProgram = bootloaderProgramContractAddress\n                .getCompiledProgram();\n            for (uint256 i = 0; i < bootloaderProgram.length; i++) {\n                // Force that memory[i + INITIAL_PC] = bootloaderProgram[i].\n                publicMemory[offset] = i + INITIAL_PC;\n                publicMemory[offset + 1] = bootloaderProgram[i];\n                offset += 2;\n            }\n        }\n\n        {\n            // Execution segment - Make sure [initial_fp - 2] = initial_fp and .\n            // This is required for the \"safe call\" feature (that is, all \"call\" instructions will\n            // return, even if the called function is malicious).\n            // It guarantees that it's not possible to create a cycle in the call stack.\n            uint256 initialFp = cairoAuxInput[OFFSET_EXECUTION_BEGIN_ADDR];\n            require(initialFp >= 2, \"Invalid execution begin address.\");\n            publicMemory[offset + 0] = initialFp - 2;\n            publicMemory[offset + 1] = initialFp;\n            // Make sure [initial_fp - 1] = 0.\n            publicMemory[offset + 2] = initialFp - 1;\n            publicMemory[offset + 3] = 0;\n            offset += 4;\n\n            // Execution segment: Enforce main's arguments and return values.\n            // Note that the page hash depends on the order of the (address, value) pair in the\n            // publicMemory and consequently the arguments must be written before the return values.\n            uint256 returnValuesAddress = cairoAuxInput[OFFSET_EXECUTION_STOP_PTR] - N_BUILTINS;\n            uint256 builtinSegmentInfoOffset = OFFSET_OUTPUT_BEGIN_ADDR;\n\n            for (uint256 i = 0; i < N_BUILTINS; i++) {\n                // Write argument address.\n                publicMemory[offset] = initialFp + i;\n                uint256 returnValueOffset = offset + 2 * N_BUILTINS;\n\n                // Write return value address.\n                publicMemory[returnValueOffset] = returnValuesAddress + i;\n\n                // Write values.\n                if ((selectedBuiltins & 1) != 0) {\n                    // Set the argument to the builtin start pointer.\n                    publicMemory[offset + 1] = cairoAuxInput[builtinSegmentInfoOffset];\n                    // Set the return value to the builtin stop pointer.\n                    publicMemory[returnValueOffset + 1] = cairoAuxInput[\n                        builtinSegmentInfoOffset + 1\n                    ];\n                    builtinSegmentInfoOffset += 2;\n                } else {\n                    // Builtin is not present in layout, set the argument value and return value to 0.\n                    publicMemory[offset + 1] = 0;\n                    publicMemory[returnValueOffset + 1] = 0;\n                }\n                offset += 2;\n                selectedBuiltins >>= 1;\n            }\n            require(selectedBuiltins == 0, \"SELECTED_BUILTINS_VECTOR_IS_TOO_LONG\");\n            // Skip the return values which were already written.\n            offset += 2 * N_BUILTINS;\n        }\n\n        // Program output.\n        {\n            // Check that there are enough range checks for the bootloader builtin validation.\n            // Each builtin is validated for each task and each validation uses one range check.\n            require(\n                cairoAuxInput[OFFSET_RANGE_CHECK_STOP_PTR] >=\n                    cairoAuxInput[OFFSET_RANGE_CHECK_BEGIN_ADDR] + N_BUILTINS * nTasks,\n                \"Range-check stop pointer should be after all range checks used for validations.\"\n            );\n\n            {\n                uint256 outputAddress = cairoAuxInput[OFFSET_OUTPUT_BEGIN_ADDR];\n                // Force that memory[outputAddress] = nTasks.\n                publicMemory[offset + 0] = outputAddress;\n                publicMemory[offset + 1] = nTasks;\n                offset += 2;\n                outputAddress += 1;\n\n                uint256[] calldata taskMetadataSlice = taskMetadata[METADATA_TASKS_OFFSET:];\n                for (uint256 task = 0; task < nTasks; task++) {\n                    uint256 outputSize = taskMetadataSlice[METADATA_OFFSET_TASK_OUTPUT_SIZE];\n                    require(2 <= outputSize && outputSize < 2**30, \"Invalid task output size.\");\n                    uint256 programHash = taskMetadataSlice[METADATA_OFFSET_TASK_PROGRAM_HASH];\n                    uint256 nTreePairs = taskMetadataSlice[METADATA_OFFSET_TASK_N_TREE_PAIRS];\n                    require(\n                        1 <= nTreePairs && nTreePairs < 2**20,\n                        \"Invalid number of pairs in the Merkle tree structure.\"\n                    );\n                    // Force that memory[outputAddress] = outputSize.\n                    publicMemory[offset + 0] = outputAddress;\n                    publicMemory[offset + 1] = outputSize;\n                    // Force that memory[outputAddress + 1] = programHash.\n                    publicMemory[offset + 2] = outputAddress + 1;\n                    publicMemory[offset + 3] = programHash;\n                    offset += 4;\n                    outputAddress += outputSize;\n                    taskMetadataSlice = taskMetadataSlice[METADATA_TASK_HEADER_SIZE +\n                        2 *\n                        nTreePairs:];\n                }\n                require(taskMetadataSlice.length == 0, \"Invalid length of taskMetadata.\");\n\n                require(\n                    cairoAuxInput[OFFSET_OUTPUT_STOP_PTR] == outputAddress,\n                    \"Inconsistent program output length.\"\n                );\n            }\n        }\n\n        require(publicMemory.length == offset, \"Not all Cairo public inputs were written.\");\n\n        uint256 z = cairoAuxInput[cairoAuxInput.length - 2];\n        uint256 alpha = cairoAuxInput[cairoAuxInput.length - 1];\n        bytes32 factHash;\n        (factHash, memoryHash, prod) = memoryPageFactRegistry.registerRegularMemoryPage(\n            publicMemory,\n            z,\n            alpha,\n            K_MODULUS\n        );\n    }\n}\n"},"Identity.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ninterface Identity {\n    /*\n      Allows a caller, typically another contract,\n      to ensure that the provided address is of the expected type and version.\n    */\n    function identify() external pure returns (string memory);\n}\n"},"IFactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post <https://medium.com/starkware/the-fact-registry-a64aafb598b6>`_.\n*/\ninterface IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact) external view returns (bool);\n}\n"},"IQueryableFactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"IFactRegistry.sol\";\n\n/*\n  Extends the IFactRegistry interface with a query method that indicates\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\n*/\ninterface IQueryableFactRegistry is IFactRegistry {\n    /*\n      Returns true if at least one fact has been registered.\n    */\n    function hasRegisteredFact() external view returns (bool);\n}\n"},"MemoryPageFactRegistry.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"FactRegistry.sol\";\n\ncontract MemoryPageFactRegistryConstants {\n    // A page based on a list of pairs (address, value).\n    // In this case, memoryHash = hash(address, value, address, value, address, value, ...).\n    uint256 internal constant REGULAR_PAGE = 0;\n    // A page based on adjacent memory cells, starting from a given address.\n    // In this case, memoryHash = hash(value, value, value, ...).\n    uint256 internal constant CONTINUOUS_PAGE = 1;\n}\n\n/*\n  A fact registry for the claim:\n    I know n pairs (addr, value) for which the hash of the pairs is memoryHash, and the cumulative\n    product: \\prod_i( z - (addr_i + alpha * value_i) ) is prod.\n  The exact format of the hash depends on the type of the page\n  (see MemoryPageFactRegistryConstants).\n  The fact consists of (pageType, prime, n, z, alpha, prod, memoryHash, address).\n  Note that address is only available for CONTINUOUS_PAGE, and otherwise it is 0.\n*/\ncontract MemoryPageFactRegistry is FactRegistry, MemoryPageFactRegistryConstants {\n    event LogMemoryPageFactRegular(bytes32 factHash, uint256 memoryHash, uint256 prod);\n    event LogMemoryPageFactContinuous(bytes32 factHash, uint256 memoryHash, uint256 prod);\n\n    /*\n      Registers a fact based of the given memory (address, value) pairs (REGULAR_PAGE).\n    */\n    function registerRegularMemoryPage(\n        uint256[] calldata memoryPairs,\n        uint256 z,\n        uint256 alpha,\n        uint256 prime\n    )\n        external\n        returns (\n            bytes32 factHash,\n            uint256 memoryHash,\n            uint256 prod\n        )\n    {\n        require(memoryPairs.length < 2**20, \"Too many memory values.\");\n        require(memoryPairs.length % 2 == 0, \"Size of memoryPairs must be even.\");\n        require(z < prime, \"Invalid value of z.\");\n        require(alpha < prime, \"Invalid value of alpha.\");\n        (factHash, memoryHash, prod) = computeFactHash(memoryPairs, z, alpha, prime);\n        emit LogMemoryPageFactRegular(factHash, memoryHash, prod);\n\n        registerFact(factHash);\n    }\n\n    function computeFactHash(\n        uint256[] memory memoryPairs,\n        uint256 z,\n        uint256 alpha,\n        uint256 prime\n    )\n        internal\n        pure\n        returns (\n            bytes32 factHash,\n            uint256 memoryHash,\n            uint256 prod\n        )\n    {\n        uint256 memorySize = memoryPairs.length / 2; // NOLINT: divide-before-multiply.\n\n        prod = 1;\n\n        assembly {\n            let memoryPtr := add(memoryPairs, 0x20)\n\n            // Each value of memoryPairs is a pair: (address, value).\n            let lastPtr := add(memoryPtr, mul(memorySize, 0x40))\n            for {\n                let ptr := memoryPtr\n            } lt(ptr, lastPtr) {\n                ptr := add(ptr, 0x40)\n            } {\n                // Compute address + alpha * value.\n                let address_value_lin_comb := addmod(\n                    // address=\n                    mload(ptr),\n                    mulmod(\n                        // value=\n                        mload(add(ptr, 0x20)),\n                        alpha,\n                        prime\n                    ),\n                    prime\n                )\n                prod := mulmod(prod, add(z, sub(prime, address_value_lin_comb)), prime)\n            }\n\n            memoryHash := keccak256(\n                memoryPtr,\n                mul(\n                    // 0x20 * 2.\n                    0x40,\n                    memorySize\n                )\n            )\n        }\n\n        factHash = keccak256(\n            abi.encodePacked(\n                REGULAR_PAGE,\n                prime,\n                memorySize,\n                z,\n                alpha,\n                prod,\n                memoryHash,\n                uint256(0)\n            )\n        );\n    }\n\n    /*\n      Registers a fact based on the given values, assuming continuous addresses.\n      values should be [value at startAddr, value at (startAddr + 1), ...].\n    */\n    function registerContinuousMemoryPage(\n        // NOLINT: external-function.\n        uint256 startAddr,\n        uint256[] memory values,\n        uint256 z,\n        uint256 alpha,\n        uint256 prime\n    )\n        public\n        returns (\n            bytes32 factHash,\n            uint256 memoryHash,\n            uint256 prod\n        )\n    {\n        require(values.length < 2**20, \"Too many memory values.\");\n        require(prime < 2**254, \"prime is too big for the optimizations in this function.\");\n        require(z < prime, \"Invalid value of z.\");\n        require(alpha < prime, \"Invalid value of alpha.\");\n        require(startAddr < 2**64 && startAddr < prime, \"Invalid value of startAddr.\");\n\n        uint256 nValues = values.length;\n\n        assembly {\n            // Initialize prod to 1.\n            prod := 1\n            // Initialize valuesPtr to point to the first value in the array.\n            let valuesPtr := add(values, 0x20)\n\n            let minus_z := mod(sub(prime, z), prime)\n\n            // Start by processing full batches of 8 cells, addr represents the last address in each\n            // batch.\n            let addr := add(startAddr, 7)\n            let lastAddr := add(startAddr, nValues)\n            for {\n\n            } lt(addr, lastAddr) {\n                addr := add(addr, 8)\n            } {\n                // Compute the product of (lin_comb - z) instead of (z - lin_comb), since we're\n                // doing an even number of iterations, the result is the same.\n                prod := mulmod(\n                    prod,\n                    mulmod(\n                        add(add(sub(addr, 7), mulmod(mload(valuesPtr), alpha, prime)), minus_z),\n                        add(\n                            add(sub(addr, 6), mulmod(mload(add(valuesPtr, 0x20)), alpha, prime)),\n                            minus_z\n                        ),\n                        prime\n                    ),\n                    prime\n                )\n\n                prod := mulmod(\n                    prod,\n                    mulmod(\n                        add(\n                            add(sub(addr, 5), mulmod(mload(add(valuesPtr, 0x40)), alpha, prime)),\n                            minus_z\n                        ),\n                        add(\n                            add(sub(addr, 4), mulmod(mload(add(valuesPtr, 0x60)), alpha, prime)),\n                            minus_z\n                        ),\n                        prime\n                    ),\n                    prime\n                )\n\n                prod := mulmod(\n                    prod,\n                    mulmod(\n                        add(\n                            add(sub(addr, 3), mulmod(mload(add(valuesPtr, 0x80)), alpha, prime)),\n                            minus_z\n                        ),\n                        add(\n                            add(sub(addr, 2), mulmod(mload(add(valuesPtr, 0xa0)), alpha, prime)),\n                            minus_z\n                        ),\n                        prime\n                    ),\n                    prime\n                )\n\n                prod := mulmod(\n                    prod,\n                    mulmod(\n                        add(\n                            add(sub(addr, 1), mulmod(mload(add(valuesPtr, 0xc0)), alpha, prime)),\n                            minus_z\n                        ),\n                        add(add(addr, mulmod(mload(add(valuesPtr, 0xe0)), alpha, prime)), minus_z),\n                        prime\n                    ),\n                    prime\n                )\n\n                valuesPtr := add(valuesPtr, 0x100)\n            }\n\n            // Handle leftover.\n            // Translate addr to the beginning of the last incomplete batch.\n            addr := sub(addr, 7)\n            for {\n\n            } lt(addr, lastAddr) {\n                addr := add(addr, 1)\n            } {\n                let address_value_lin_comb := addmod(\n                    addr,\n                    mulmod(mload(valuesPtr), alpha, prime),\n                    prime\n                )\n                prod := mulmod(prod, add(z, sub(prime, address_value_lin_comb)), prime)\n                valuesPtr := add(valuesPtr, 0x20)\n            }\n\n            memoryHash := keccak256(add(values, 0x20), mul(0x20, nValues))\n        }\n\n        factHash = keccak256(\n            abi.encodePacked(CONTINUOUS_PAGE, prime, nValues, z, alpha, prod, memoryHash, startAddr)\n        );\n\n        emit LogMemoryPageFactContinuous(factHash, memoryHash, prod);\n\n        registerFact(factHash);\n    }\n}\n"},"PageInfo.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ncontract PageInfo {\n    uint256 public constant PAGE_INFO_SIZE = 3;\n    // PAGE_INFO_SIZE_IN_BYTES cannot reference PAGE_INFO_SIZE as only direct constants are\n    // supported in assembly.\n    uint256 public constant PAGE_INFO_SIZE_IN_BYTES = 3 * 32;\n\n    uint256 public constant PAGE_INFO_ADDRESS_OFFSET = 0;\n    uint256 public constant PAGE_INFO_SIZE_OFFSET = 1;\n    uint256 public constant PAGE_INFO_HASH_OFFSET = 2;\n}\n"},"PrimeFieldElement0.sol":{"content":"/*\n  Copyright 2019-2021 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ncontract PrimeFieldElement0 {\n    uint256 internal constant K_MODULUS =\n        0x800000000000011000000000000000000000000000000000000000000000001;\n    uint256 internal constant K_MONTGOMERY_R =\n        0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;\n    uint256 internal constant K_MONTGOMERY_R_INV =\n        0x40000000000001100000000000012100000000000000000000000000000000;\n    uint256 internal constant GENERATOR_VAL = 3;\n    uint256 internal constant ONE_VAL = 1;\n    uint256 internal constant GEN1024_VAL =\n        0x659d83946a03edd72406af6711825f5653d9e35dc125289a206c054ec89c4f1;\n\n    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {\n        // uint256 res = fmul(val, kMontgomeryRInv);\n        assembly {\n            res := mulmod(\n                val,\n                0x40000000000001100000000000012100000000000000000000000000000000,\n                0x800000000000011000000000000000000000000000000000000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {\n        // Assuming bs is a 256bit bytes object, in Montgomery form, it is read into a field\n        // element.\n        uint256 res = uint256(bs);\n        return fromMontgomery(res);\n    }\n\n    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {\n        //uint256 res = fmul(val, kMontgomeryR);\n        assembly {\n            res := mulmod(\n                val,\n                0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1,\n                0x800000000000011000000000000000000000000000000000000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        //uint256 res = mulmod(a, b, kModulus);\n        assembly {\n            res := mulmod(a, b, 0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, b, kModulus);\n        assembly {\n            res := addmod(a, b, 0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, kModulus - b, kModulus);\n        assembly {\n            res := addmod(\n                a,\n                sub(0x800000000000011000000000000000000000000000000000000000000000001, b),\n                0x800000000000011000000000000000000000000000000000000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fpow(uint256 val, uint256 exp) internal view returns (uint256) {\n        return expmod(val, exp, K_MODULUS);\n    }\n\n    function expmod(\n        uint256 base,\n        uint256 exponent,\n        uint256 modulus\n    ) internal view returns (uint256 res) {\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20) // Length of Base.\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\n            mstore(add(p, 0x60), base) // Base.\n            mstore(add(p, 0x80), exponent) // Exponent.\n            mstore(add(p, 0xa0), modulus) // Modulus.\n            // Call modexp precompile.\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function inverse(uint256 val) internal view returns (uint256) {\n        return expmod(val, K_MODULUS - 2, K_MODULUS);\n    }\n}\n"}}}