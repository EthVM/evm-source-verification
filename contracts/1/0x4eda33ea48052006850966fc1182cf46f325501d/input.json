{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SquidFarmer.sol":{"content":"pragma solidity ^0.4.25;\r\n\r\n// In honor of the world's first AMM\r\n\r\ncontract SquidFarmer{\r\n    uint256 constant STARTING_SQUID = 1 hours * 1 hours;\r\n    uint256 constant STARTING_FEE = 100e18;\r\n    uint256 constant PSN = 8192;\r\n    uint256 constant PSNH = 4096;\r\n    ERC20 constant token = ERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\r\n    address constant bankAddress = address(0x83D0D842e6DB3B020f384a2af11bD14787BEC8E7);\r\n\r\n    uint256 public marketEggs;\r\n    bool public initialized;\r\n    mapping (address => uint256) public hatcherySquid;\r\n    mapping (address => uint256) public claimedEggs;\r\n    mapping (address => uint256) public lastHatch;\r\n    mapping (address => address) public referrals;\r\n\r\n    function hatchEggs(address ref) public {\r\n        require(initialized);\r\n        if (ref != address(0)) referrals[msg.sender] = ref;\r\n        uint256 eggsUsed = getMyEggs(msg.sender);\r\n        hatcherySquid[msg.sender] = SafeMath.add(hatcherySquid[msg.sender], eggsUsed);\r\n        claimedEggs[msg.sender] = 0;\r\n        lastHatch[msg.sender] = now;\r\n        \r\n        //send referral eggs\r\n        claimedEggs[referrals[msg.sender]] = SafeMath.add(claimedEggs[referrals[msg.sender]], SafeMath.div(eggsUsed, 15));\r\n        \r\n        //boost market to nerf squid hoarding\r\n        marketEggs = SafeMath.add(marketEggs,SafeMath.div(eggsUsed, 10));\r\n    }\r\n\r\n    function sellEggs() public {\r\n        require(initialized);\r\n        uint256 eggsSold = getMyEggs(msg.sender);\r\n        uint256 eggValue = calculateEggSell(eggsSold);\r\n        uint256 fee = devFee(eggValue);\r\n        claimedEggs[msg.sender] = 0;\r\n        lastHatch[msg.sender] = now;\r\n        marketEggs = SafeMath.add(marketEggs, eggsSold);\r\n        require(bankAddress.call.value(fee)());\r\n        require(msg.sender.call.value(SafeMath.sub(eggValue, fee))());\r\n    }\r\n\r\n    function buyEggs() public payable {\r\n        require(initialized);\r\n        require(hatcherySquid[msg.sender] > 0);\r\n        uint256 eggsBought = calculateEggBuy(msg.value, SafeMath.sub(getBalance(), msg.value));\r\n        eggsBought = SafeMath.sub(eggsBought,devFee(eggsBought));\r\n        require(bankAddress.call.value(devFee(msg.value))());\r\n        claimedEggs[msg.sender] = SafeMath.add(claimedEggs[msg.sender], eggsBought);\r\n    }\r\n\r\n    function () public payable {\r\n        buyEggs();\r\n    }\r\n\r\n    //magic trade balancing algorithm\r\n    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) public pure returns (uint256) {\r\n        //(PSN*bs)/(PSNH+((PSN*rs+PSNH*rt)/rt));\r\n        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));\r\n    }\r\n\r\n    function calculateEggSell(uint256 eggs) public view returns (uint256) {\r\n        return calculateTrade(eggs,marketEggs, getBalance());\r\n    }\r\n\r\n    function calculateEggBuy(uint256 eth, uint256 contractBalance) public view returns (uint256) {\r\n        return calculateTrade(eth,contractBalance, marketEggs);\r\n    }\r\n\r\n    function calculateEggBuySimple(uint256 eth) public view returns (uint256) {\r\n        return calculateEggBuy(eth, getBalance());\r\n    }\r\n\r\n    function devFee(uint256 amount) public pure returns (uint256) {\r\n        return SafeMath.div(amount, 20);\r\n    }\r\n\r\n    function seedMarket(uint256 eggs) public payable {\r\n        require(marketEggs == 0);\r\n        initialized = true;\r\n        marketEggs = eggs;\r\n    }\r\n\r\n    function getFirstSquid() public {\r\n        require(initialized);\r\n        require(hatcherySquid[msg.sender] == 0);\r\n        require(token.transferFrom(msg.sender, bankAddress, STARTING_FEE));\r\n        lastHatch[msg.sender] = now;\r\n        hatcherySquid[msg.sender] = STARTING_SQUID;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getMySquid(address adr) public view returns (uint256) {\r\n        return hatcherySquid[adr];\r\n    }\r\n\r\n    function getMyEggs(address adr) public view returns (uint256) {\r\n        return SafeMath.add(claimedEggs[adr], getEggsSinceLastHatch(adr));\r\n    }\r\n\r\n    function getEggsSinceLastHatch(address adr) public view returns (uint256) {\r\n        uint256 quadraticSquid = SafeMath.sqrt(hatcherySquid[adr]);\r\n        uint256 secondsPassed = min(quadraticSquid, SafeMath.sub(now, lastHatch[adr]));\r\n        return SafeMath.mul(secondsPassed, quadraticSquid);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        uint256 z = add(x >> 1, 1);\r\n        uint256 y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z), z)) / 2);\r\n        }\r\n        return y;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}"}}}