{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ConvexAllocator.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\nimport \"./libraries/Address.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\nimport \"./types/OlympusAccessControlled.sol\";\n\ninterface ICurve3Pool {\n    // add liquidity to Curve to receive back 3CRV tokens\n    function add_liquidity(\n        address _pool,\n        uint256[4] memory _deposit_amounts,\n        uint256 _min_mint_amount\n    ) external returns (uint256);\n\n    // remove liquidity Curve liquidity to recieve back base token\n    function remove_liquidity_one_coin(\n        address _pool,\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_amount\n    ) external returns (uint256);\n}\n\n//main Convex contract(booster.sol) basic interface\ninterface IConvex {\n    //deposit into convex, receive a tokenized deposit.  parameter to stake immediately\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n}\n\n//sample convex reward contracts interface\ninterface IConvexRewards {\n    //withdraw directly to curve LP token\n    function withdrawAndUnwrap(uint256 _amount, bool _claim) external returns (bool);\n\n    //claim rewards\n    function getReward() external returns (bool);\n\n    //get rewards for an address\n    function earned(address _account) external view returns (uint256);\n}\n\n/**\n *  Contract deploys reserves from treasury into the Convex lending pool,\n *  earning interest and $CVX.\n */\n\ncontract ConvexAllocator is OlympusAccessControlled {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /* ======== STRUCTS ======== */\n\n    struct TokenData {\n        address underlying;\n        address curveToken;\n        IConvexRewards rewardPool;\n        address[] rewardTokens;\n        int128 index;\n        uint256 deployed;\n        uint256 limit;\n        uint256 newLimit;\n        uint256 limitChangeTimelockEnd;\n    }\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Convex deposit contract\n    IConvex internal immutable booster = IConvex(0xF403C135812408BFbE8713b5A23a04b3D48AAE31); \n    // Curve 3Pool\n    ICurve3Pool internal immutable curve3Pool = ICurve3Pool(0xA79828DF1850E8a3A3064576f380D90aECDD3359); \n    // Olympus Treasury\n    ITreasury internal treasury = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef); \n\n    // info for deposited tokens\n    mapping(address => TokenData) public tokenInfo; \n    // convex pid for token\n    mapping(address => uint256) public pidForReserve; \n    // total RFV deployed into lending pool\n    uint256 public totalValueDeployed; \n    // timelock to raise deployment limit\n    uint256 public immutable timelockInBlocks = 6600; \n\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {}\n\n    /* ======== OPEN FUNCTIONS ======== */\n\n    /**\n     * @notice claims accrued CVX rewards for all tracked crvTokens\n     */\n    function harvest(address[] memory tokens) external {\n        for(uint256 i; i < tokens.length; i++) {\n            TokenData memory tokenData = tokenInfo[tokens[i]];\n            address[] memory rewardTokens = tokenData.rewardTokens;\n            \n            tokenData.rewardPool.getReward();\n\n            for (uint256 r = 0; r < rewardTokens.length; r++) {\n                uint256 balance = IERC20(rewardTokens[r]).balanceOf(address(this));\n\n                if (balance > 0) {\n                    IERC20(rewardTokens[r]).safeTransfer(address(treasury), balance);\n                }\n            }\n        }\n    }\n\n    /* ======== POLICY FUNCTIONS ======== */\n\n    function updateTreasury() external onlyGuardian {\n        require(authority.vault() != address(0), \"Zero address: Vault\");\n        require(address(authority.vault()) != address(treasury), \"No change\");\n        treasury = ITreasury(authority.vault());\n    }\n\n    /**\n     * @notice withdraws asset from treasury, deposits asset into lending pool, then deposits crvToken into convex\n     */\n    function deposit(\n        address token,\n        uint256 amount,\n        uint256[4] calldata amounts,\n        uint256 minAmount\n    ) public onlyGuardian {\n        require(!exceedsLimit(token, amount), \"Exceeds deployment limit\");\n        address curveToken = tokenInfo[token].curveToken;\n\n        // retrieve amount of asset from treasury\n        treasury.manage(token, amount); \n\n        // account for deposit\n        uint256 value = treasury.tokenValue(token, amount);\n        accountingFor(token, amount, value, true);\n\n        // approve and deposit into curve\n        IERC20(token).approve(address(curve3Pool), amount); \n        uint256 curveAmount = curve3Pool.add_liquidity(curveToken, amounts, minAmount); \n\n        // approve and deposit into convex\n        IERC20(curveToken).approve(address(booster), curveAmount); \n        booster.deposit(pidForReserve[token], curveAmount, true);\n    }\n\n    /**\n     * @notice withdraws crvToken from convex, withdraws from lending pool, then deposits asset into treasury\n     */\n    function withdraw(\n        address token,\n        uint256 amount,\n        uint256 minAmount,\n        bool reserve\n    ) public onlyGuardian {\n        address curveToken = tokenInfo[token].curveToken;\n\n        // withdraw from convex\n        tokenInfo[token].rewardPool.withdrawAndUnwrap(amount, false); \n\n        // approve and withdraw from curve\n        IERC20(curveToken).approve(address(curve3Pool), amount); \n        curve3Pool.remove_liquidity_one_coin(curveToken, amount, tokenInfo[token].index, minAmount);\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n\n        // account for withdrawal\n        uint256 value = treasury.tokenValue(token, balance);\n        accountingFor(token, balance, value, false);\n\n        if (reserve) {\n            // approve and deposit asset into treasury\n            IERC20(token).approve(address(treasury), balance); \n            treasury.deposit(balance, token, value);\n        } else IERC20(token).safeTransfer(address(treasury), balance);\n    }\n\n    /**\n     * @notice adds asset and corresponding crvToken to mapping\n     */\n    function addToken(\n        address token,\n        address curveToken,\n        address rewardPool,\n        address[] memory rewardTokens,\n        int128 index,\n        uint256 max,\n        uint256 pid\n    ) external onlyGuardian {\n        require(token != address(0), \"Zero address: Token\");\n        require(curveToken != address(0), \"Zero address: Curve Token\");\n        require(tokenInfo[token].deployed == 0, \"Token added\");\n\n        tokenInfo[token] = TokenData({\n            underlying: token,\n            curveToken: curveToken,\n            rewardPool: IConvexRewards(rewardPool),\n            rewardTokens: rewardTokens,\n            index: index,\n            deployed: 0,\n            limit: max,\n            newLimit: 0,\n            limitChangeTimelockEnd: 0\n        });\n\n        pidForReserve[token] = pid;\n    }\n\n    /**\n     * @notice add new reward token to be harvested\n     */\n    function addRewardTokens(address baseToken, address[] memory rewardTokens) external onlyGuardian {\n        tokenInfo[baseToken].rewardTokens = rewardTokens;\n    }\n\n    /**\n     * @notice lowers max can be deployed for asset (no timelock)\n     */\n    function lowerLimit(address token, uint256 newMax) external onlyGuardian {\n        require(newMax < tokenInfo[token].limit, \"Must be lower\");\n        require(newMax > tokenInfo[token].deployed, \"Greater than deployed\");\n        tokenInfo[token].limit = newMax;\n    }\n\n    /**\n     * @notice starts timelock to raise max allocation for asset\n     */\n    function queueRaiseLimit(address token, uint256 newMax) external onlyGuardian {\n        tokenInfo[token].limitChangeTimelockEnd = block.number.add(timelockInBlocks);\n        tokenInfo[token].newLimit = newMax;\n    }\n\n    /**\n     * @notice changes max allocation for asset when timelock elapsed\n     */\n    function raiseLimit(address token) external onlyGuardian {\n        require(block.number >= tokenInfo[token].limitChangeTimelockEnd, \"Timelock not expired\");\n        require(tokenInfo[token].limitChangeTimelockEnd != 0, \"Timelock not started\");\n\n        tokenInfo[token].limit = tokenInfo[token].newLimit;\n        tokenInfo[token].newLimit = 0;\n        tokenInfo[token].limitChangeTimelockEnd = 0;\n    }\n\n    /* ======== INTERNAL FUNCTIONS ======== */\n\n    /**\n     * @notice accounting of deposits/withdrawals of assets\n     */\n    function accountingFor(\n        address token,\n        uint256 amount,\n        uint256 value,\n        bool add\n    ) internal {\n        if (add) {\n            tokenInfo[token].deployed = tokenInfo[token].deployed.add(amount); // track amount allocated into pool\n            totalValueDeployed = totalValueDeployed.add(value); // track total value allocated into pools\n        } else {\n            // track amount allocated into pool\n            if (amount < tokenInfo[token].deployed) {\n                tokenInfo[token].deployed = tokenInfo[token].deployed.sub(amount);\n            } else tokenInfo[token].deployed = 0;\n\n            // track total value allocated into pools\n            if (value < totalValueDeployed) {\n                totalValueDeployed = totalValueDeployed.sub(value);\n            } else totalValueDeployed = 0;\n        }\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     * @notice query all pending rewards for a specific base token\n     */\n    function rewardsPending(address baseToken) external view returns (uint256) {\n        return tokenInfo[baseToken].rewardPool.earned(address(this));\n    }\n\n    /**\n     * @notice checks to ensure deposit does not exceed max allocation for asset\n     */\n    function exceedsLimit(address token, uint256 amount) public view returns (bool) {\n        uint256 willBeDeployed = tokenInfo[token].deployed.add(amount);\n        return (willBeDeployed > tokenInfo[token].limit);\n    }\n}"
    },
    "interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "interfaces/IOlympusAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity =0.7.5;\n\ninterface IOlympusAuthority {\n    /* ========== EVENTS ========== */\n    \n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n    \n    function governor() external view returns (address);\n    function guardian() external view returns (address);\n    function policy() external view returns (address);\n    function vault() external view returns (address);\n}"
    },
    "interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (uint256);\n}\n"
    },
    "libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\n\n// TODO(zx): replace with OZ implementation.\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    // function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n    //     require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    //     return _functionCallWithValue(target, data, value, errorMessage);\n    // }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n  /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address) internal pure returns(string memory) {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory HEX = \"0123456789abcdef\";\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = '0';\n        _addr[1] = 'x';\n\n        for(uint256 i = 0; i < 20; i++) {\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n        }\n\n        return string(_addr);\n\n    }\n}"
    },
    "libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}"
    },
    "libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.7.5;\n\n\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint c) {\n        if (a > 3) {\n            c = a;\n            uint b = add( div( a, 2), 1 );\n            while (b < c) {\n                c = b;\n                b = div( add( div( a, b ), b), 2 );\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n\n}"
    },
    "types/OlympusAccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../interfaces/IOlympusAuthority.sol\";\n\nabstract contract OlympusAccessControlled {\n\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IOlympusAuthority public authority;\n\n\n    /* ========== Constructor ========== */\n\n    constructor(IOlympusAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n    \n\n    /* ========== MODIFIERS ========== */\n    \n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n    \n    /* ========== GOV ONLY ========== */\n    \n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    }
  }
}