{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Saving.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.1;\n\nlibrary SafeMath {\n    \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint balance);\n    function transfer(address to, uint amount) external returns (bool);\n    \n    function allowance(address account, address from) external view returns (uint256);\n    function approve(address from, uint amount) external returns (bool);\n    function transferFrom(address from, address to, uint amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed account, address indexed from, uint amount);\n}\n\ncontract TokenWraper {\n    \n    using SafeMath for uint256;\n    \n    IERC20 public _token = IERC20(0x847287E3586dD4Fe7217a050580DdCDC83c73470);\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns(uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns(uint256) {\n        return _balances[account];\n    }\n\n    function _save(uint256 amount) internal {\n        _token.transferFrom(msg.sender, address(this), amount);\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n    }\n\n    function _withdraw(uint256 amount) internal {\n        _token.transfer(msg.sender, amount);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    }\n\n    function _removeReward(address founder, uint256 amount) internal {\n        _token.transfer(msg.sender, amount);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[founder] = _balances[founder].sub(amount);\n    }\n}\n\ncontract Saving is TokenWraper {\n    \n    using SafeMath for uint256;\n    \n    address public founder;\n    uint256 public timeLock = 3 days; // return unix epoch\n    uint256 public yearly = 365 days;\n    uint256 public percentRewardYearly; // % yearly\n    mapping(address => uint256) private savedAmount;\n    mapping(address => uint256) private savedTimestamp;\n    mapping(address => uint256) public claimRewardAmount;\n    mapping(address => uint256) public lockedUntil;\n    \n    IERC20 public token = IERC20(0x847287E3586dD4Fe7217a050580DdCDC83c73470);\n    \n    event Saved(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    \n    modifier isFounder() {\n        require(msg.sender == founder);\n        _;\n    }\n    \n    constructor(uint256 _percentRewardYearly) {\n        percentRewardYearly = _percentRewardYearly;\n        founder = msg.sender;\n    }\n    \n    function setNewFounder(address newAddress) public isFounder {\n        founder = newAddress;\n    }\n    \n    function setPercentRewardYearly(uint256 _percent) public isFounder {\n        percentRewardYearly = _percent;\n    }\n\n    function changeOwnership(address _account) public {\n        founder = _account;\n    }\n    \n    function rewardBalance() public view returns(uint256) {\n        return balanceOf(founder);\n    }\n    \n    function _rewardEarnedPerSecond(address account) public view returns(uint256) {\n        if(account == founder) {\n            return 0;\n        }\n        uint256 _savedAmount = savedAmount[account];\n        uint256 _expectedRewardYearly = _savedAmount.mul(percentRewardYearly);\n        _expectedRewardYearly = _expectedRewardYearly.div(100);\n        uint256 _reward = _expectedRewardYearly.div(yearly);\n        return _reward;\n    }\n    \n    function rewardEarned(address account) public view returns(uint256) {\n        uint256 _currentTime = block.timestamp;\n        uint256 _rangeTime = _currentTime.sub(savedTimestamp[account]);\n        uint256 _rewardEarned;\n        if(_rangeTime >= timeLock) {\n            _rewardEarned = _rewardEarnedPerSecond(account).mul(timeLock);\n        }else {\n            _rewardEarned = _rewardEarnedPerSecond(account).mul(_rangeTime);\n        }\n        if(claimRewardAmount[account] != 0) {\n            _rewardEarned = _rewardEarned.sub(claimRewardAmount[account]);\n        }\n        return _rewardEarned;\n    }\n    \n    function save(uint256 _amount) public {\n        require(_amount > 0, \"Cannot save 0\");\n        super._save(_amount);\n        uint256 _currentTime = block.timestamp;\n        savedAmount[msg.sender] = _amount;\n        claimRewardAmount[msg.sender] = 0;\n        savedTimestamp[msg.sender] = _currentTime;\n        lockedUntil[msg.sender] = _currentTime.add(timeLock);\n        emit Saved(msg.sender, _amount);\n    }\n    \n    function withdraw(uint256 _amount) public {\n        require(msg.sender != founder, \"Founder not allowed to withdraw\");\n        require(lockedUntil[msg.sender] > 0, \"No user found.\");\n        require(lockedUntil[msg.sender] < block.timestamp, \"Not unlocked yet.\");\n        require(_amount > 0, \"Cannot withdraw 0\");\n        super._withdraw(_amount);\n        emit Withdrawn(msg.sender, _amount);\n    }\n    \n    function getReward() public {\n        uint256 _rewardEarned = rewardEarned(msg.sender);\n        require(_rewardEarned > 0, \"Doesn't have a reward.\");\n        require(rewardBalance() > _rewardEarned, \"Reward balance not enough.\");\n        super._removeReward(founder, _rewardEarned);\n        claimRewardAmount[msg.sender] = claimRewardAmount[msg.sender].add(_rewardEarned);\n        if(lockedUntil[msg.sender] < block.timestamp) {\n            savedAmount[msg.sender] = 0;\n            claimRewardAmount[msg.sender] = 0;\n        }\n        emit RewardPaid(msg.sender, _rewardEarned);\n    }\n}"
    }
  }
}