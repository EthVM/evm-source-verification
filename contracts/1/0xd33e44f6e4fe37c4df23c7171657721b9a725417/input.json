{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/PolyNFTLockProxy.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./libs/ownership/Ownable.sol\";\nimport \"./libs/common/ZeroCopySink.sol\";\nimport \"./libs/common/ZeroCopySource.sol\";\nimport \"./libs/utils/Utils.sol\";\nimport \"./libs/utils/Address.sol\";\nimport \"./libs/token/ERC721/IERC721Metadata.sol\";\nimport \"./libs/token/ERC721/IERC721Receiver.sol\";\nimport \"./libs/math/SafeMath.sol\";\nimport \"./core/cross_chain_manager/interface/IEthCrossChainManager.sol\";\nimport \"./core/cross_chain_manager/interface/IEthCrossChainManagerProxy.sol\";\n\ncontract PolyNFTLockProxy is IERC721Receiver, Ownable {\n    using SafeMath for uint;\n    using Address for address;\n\n    struct TxArgs {\n        bytes toAssetHash;\n        bytes toAddress;\n        uint256 tokenId;\n        bytes tokenURI;\n    }\n\n    address public managerProxyContract;\n    mapping(uint64 => bytes) public proxyHashMap;\n    mapping(address => mapping(uint64 => bytes)) public assetHashMap;\n    mapping(address => bool) safeTransfer;\n\n    event SetManagerProxyEvent(address manager);\n    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);\n    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash);\n    event UnlockEvent(address toAssetHash, address toAddress, uint256 tokenId);\n    event LockEvent(address fromAssetHash, address fromAddress, bytes toAssetHash, bytes toAddress, uint64 toChainId, uint256 tokenId);\n    \n    modifier onlyManagerContract() {\n        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);\n        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n        _;\n    }\n    \n    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\n        managerProxyContract = ethCCMProxyAddr;\n        emit SetManagerProxyEvent(managerProxyContract);\n    }\n    \n    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {\n        proxyHashMap[toChainId] = targetProxyHash;\n        emit BindProxyEvent(toChainId, targetProxyHash);\n        return true;\n    }\n    \n    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {\n        assetHashMap[fromAssetHash][toChainId] = toAssetHash;\n        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash);\n        return true;\n    }\n    \n    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,\n    // *                           then mint a certin amount of tokens to the designated address since a certain amount \n    // *                           was burnt from the source chain invoker.\n    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.\n    // *                           based on the way of serialization in the source chain proxy contract.\n    // *  @param fromContractAddr  The source chain contract address\n    // *  @param fromChainId       The source chain id\n    // */\n    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) public onlyManagerContract returns (bool) {\n        TxArgs memory args = _deserializeTxArgs(argsBs);\n\n        require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\");\n        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\");\n        \n        require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n        require(args.toAddress.length != 0, \"toAddress cannot be empty\");\n        address toAddress = Utils.bytesToAddress(args.toAddress);\n        \n        bool success;\n        bytes memory res;\n        address owner;\n        bytes memory raw = abi.encodeWithSignature(\"ownerOf(uint256)\", args.tokenId);\n        (success, res) = toAssetHash.call(raw);\n        if (success) {\n            owner = abi.decode(res, (address));\n            require(owner == address(this) || owner == address(0), \"your token ID is not hold by lockproxy.\");\n            if (owner == address(this)) {\n                raw = abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256)\", address(this), toAddress, args.tokenId);\n                (success, ) = toAssetHash.call(raw);\n                require(success, \"failed to call safeTransferFrom\");\n            }\n        }\n        if (!success || owner == address(0)) {\n            raw = abi.encodeWithSignature(\"mintWithURI(address,uint256,string)\", toAddress, args.tokenId, string(args.tokenURI));\n            (success, ) = toAssetHash.call(raw);\n            require(success, \"failed to call mintWithURI to mint a new mapping NFT\");\n        }\n        \n        emit UnlockEvent(toAssetHash, toAddress, args.tokenId);\n        return true;\n    }\n\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public override returns (bytes4) {\n        address fromAssetHash = _msgSender();\n        require(data.length > 0, \"length of toAddress can't be zero. \");\n        require(fromAssetHash.isContract(), \"caller must be a contract. \");\n            \n        bytes memory toAddress;\n        uint64 toChainId;\n        bytes memory toAssetHash;\n        {\n            (toAddress, toChainId) = _deserializeCallData(data);\n            toAssetHash = assetHashMap[fromAssetHash][toChainId];\n            require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\n    \n            IERC721Metadata nft = IERC721Metadata(fromAssetHash);\n            require(nft.ownerOf(tokenId) == address(this), \"wrong owner for this token ID\");\n    \n            string memory uri = nft.tokenURI(tokenId);\n            TxArgs memory txArgs = TxArgs({\n                toAssetHash: toAssetHash,\n                toAddress: toAddress,\n                tokenId: tokenId,\n                tokenURI: bytes(uri)\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            IEthCrossChainManager eccm = IEthCrossChainManager(IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager());\n            \n            bytes memory toProxyHash = proxyHashMap[toChainId];\n            require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\n            require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n        {\n            emit LockEvent(fromAssetHash, from, toAssetHash, toAddress, toChainId, tokenId);\n        }\n\n        return this.onERC721Received.selector;\n    }\n    \n    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\n        bytes memory buff;\n        buff = abi.encodePacked(\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n            ZeroCopySink.WriteUint256(args.tokenId),\n            ZeroCopySink.WriteVarBytes(args.tokenURI)\n            );\n        return buff;\n    }\n\n    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\n        TxArgs memory args;\n        uint256 off = 0;\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n        (args.tokenId, off) = ZeroCopySource.NextUint256(valueBs, off);\n        (args.tokenURI, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n        return args;\n    }\n    \n    function _deserializeCallData(bytes memory valueBs) internal pure returns (bytes memory, uint64) {\n        bytes memory toAddress;\n        uint64 chainId;\n        uint256 off = 0;\n        (toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n        (chainId, off) = ZeroCopySource.NextUint64(valueBs, off);\n        return (toAddress, chainId);\n    }\n}"},"contracts/core/cross_chain_manager/interface/IEthCrossChainManager.sol":{"content":"pragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the EthCrossChainManager contract for business contract like LockProxy to request cross chain transaction\n */\ninterface IEthCrossChainManager {\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n}\n"},"contracts/core/cross_chain_manager/interface/IEthCrossChainManagerProxy.sol":{"content":"pragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.\n */\ninterface IEthCrossChainManagerProxy {\n    function getEthCrossChainManager() external view returns (address);\n}\n"},"contracts/libs/GSN/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"contracts/libs/common/ZeroCopySink.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\n *\n * Encode basic types in Solidity into bytes easily. It's designed to be used \n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain \n * and the decoding rules on other chains should be consistent. Here we  \n * follow the underlying serialization rule with implementation found here: \n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\n *\n * Using this library instead of the unchecked serialization method can help reduce\n * the risk of serious bugs and handfule, so it's recommended to use it.\n *\n * Please note that risk can be minimized, yet not eliminated.\n */\nlibrary ZeroCopySink {\n    /* @notice          Convert boolean value into bytes\n    *  @param b         The boolean value\n    *  @return          Converted bytes array\n    */\n    function WriteBool(bool b) internal pure returns (bytes memory) {\n        bytes memory buff;\n        assembly{\n            buff := mload(0x40)\n            mstore(buff, 1)\n            switch iszero(b)\n            case 1 {\n                mstore(add(buff, 0x20), shl(248, 0x00))\n                // mstore8(add(buff, 0x20), 0x00)\n            }\n            default {\n                mstore(add(buff, 0x20), shl(248, 0x01))\n                // mstore8(add(buff, 0x20), 0x01)\n            }\n            mstore(0x40, add(buff, 0x21))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert byte value into bytes\n    *  @param b         The byte value\n    *  @return          Converted bytes array\n    */\n    function WriteByte(byte b) internal pure returns (bytes memory) {\n        return WriteUint8(uint8(b));\n    }\n\n    /* @notice          Convert uint8 value into bytes\n    *  @param v         The uint8 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n        bytes memory buff;\n        assembly{\n            buff := mload(0x40)\n            mstore(buff, 1)\n            mstore(add(buff, 0x20), shl(248, v))\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n            mstore(0x40, add(buff, 0x21))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert uint16 value into bytes\n    *  @param v         The uint16 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x02\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x22))\n        }\n        return buff;\n    }\n    \n    /* @notice          Convert uint32 value into bytes\n    *  @param v         The uint32 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n        bytes memory buff;\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x04\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x24))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert uint64 value into bytes\n    *  @param v         The uint64 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x08\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x28))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert limited uint256 value into bytes\n    *  @param v         The uint256 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x20\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x40))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert limited uint256 value into bytes\n    *  @param v         The uint256 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint256(uint256 v) internal pure returns (bytes memory) {\n        require(v <= uint256(-1), \"Value exceeds uint256 range\");\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x20\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x40))\n        }\n        return buff;\n    }\n\n    /* @notice          Encode bytes format data into bytes\n    *  @param data      The bytes array data\n    *  @return          Encoded bytes array\n    */\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n        uint64 l = uint64(data.length);\n        return abi.encodePacked(WriteVarUint(l), data);\n    }\n\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n        if (v < 0xFD){\n    \t\treturn WriteUint8(uint8(v));\n    \t} else if (v <= 0xFFFF) {\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n    \t} else if (v <= 0xFFFFFFFF) {\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n    \t} else {\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n    \t}\n    }\n}"},"contracts/libs/common/ZeroCopySource.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\n *\n * Decode into basic types in Solidity from bytes easily. It's designed to be used \n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain \n * and the encoding rule on other chains should be consistent, and . Here we\n * follow the underlying deserialization rule with implementation found here: \n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\n *\n * Using this library instead of the unchecked serialization method can help reduce\n * the risk of serious bugs and handfule, so it's recommended to use it.\n *\n * Please note that risk can be minimized, yet not eliminated.\n */\nlibrary ZeroCopySource {\n    /* @notice              Read next byte as boolean type starting at offset from buff\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the boolean value\n    *  @return              The the read boolean value and new offset\n    */\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n        // byte === bytes1\n        byte v;\n        assembly{\n            v := mload(add(add(buff, 0x20), offset))\n        }\n        bool value;\n        if (v == 0x01) {\n\t\t    value = true;\n    \t} else if (v == 0x00) {\n            value = false;\n        } else {\n            revert(\"NextBool value error\");\n        }\n        return (value, offset + 1);\n    }\n\n    /* @notice              Read next byte starting at offset from buff\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the byte value\n    *  @return              The read byte value and new offset\n    */\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n        byte v;\n        assembly{\n            v := mload(add(add(buff, 0x20), offset))\n        }\n        return (v, offset + 1);\n    }\n\n    /* @notice              Read next byte as uint8 starting at offset from buff\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the byte value\n    *  @return              The read uint8 value and new offset\n    */\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n        uint8 v;\n        assembly{\n            let tmpbytes := mload(0x40)\n            let bvalue := mload(add(add(buff, 0x20), offset))\n            mstore8(tmpbytes, byte(0, bvalue))\n            mstore(0x40, add(tmpbytes, 0x01))\n            v := mload(sub(tmpbytes, 0x1f))\n        }\n        return (v, offset + 1);\n    }\n\n    /* @notice              Read next two bytes as uint16 type starting from offset\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint16 value\n    *  @return              The read uint16 value and updated offset\n    */\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n        \n        uint16 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let bvalue := mload(add(add(buff, 0x20), offset))\n            mstore8(tmpbytes, byte(0x01, bvalue))\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n            mstore(0x40, add(tmpbytes, 0x02))\n            v := mload(sub(tmpbytes, 0x1e))\n        }\n        return (v, offset + 2);\n    }\n\n\n    /* @notice              Read next four bytes as uint32 type starting from offset\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint32 value\n    *  @return              The read uint32 value and updated offset\n    */\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n        uint32 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x04\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n        }\n        return (v, offset + 4);\n    }\n\n    /* @notice              Read next eight bytes as uint64 type starting from offset\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint64 value\n    *  @return              The read uint64 value and updated offset\n    */\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n        uint64 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x08\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n        }\n        return (v, offset + 8);\n    }\n\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\n                            there are limits considering the numerical limits in multi-chain\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint256 value\n    *  @return              The read uint256 value and updated offset\n    */\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n        uint256 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x20\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(tmpbytes)\n        }\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n        return (v, offset + 32);\n    }\n\n    function NextUint256(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint256, offset exceeds maximum\");\n        uint256 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x20\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(tmpbytes)\n        }\n        require(v <= uint256(-1), \"Value exceeds the range\");\n        return (v, offset + 32);\n    }\n\n    /* @notice              Read next variable bytes starting from offset,\n                            the decoding rule coming from multi-chain\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the bytes value\n    *  @return              The read variable bytes array value and updated offset\n    */\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n        uint len;\n        (len, offset) = NextVarUint(buff, offset);\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n        bytes memory tempBytes;\n        assembly{\n            switch iszero(len)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(len, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, len)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, len)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return (tempBytes, offset + len);\n    }\n    /* @notice              Read next 32 bytes starting from offset,\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the bytes value\n    *  @return              The read bytes32 value and updated offset\n    */\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n        bytes32 v;\n        assembly {\n            v := mload(add(buff, add(offset, 0x20)))\n        }\n        return (v, offset + 32);\n    }\n\n    /* @notice              Read next 20 bytes starting from offset,\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the bytes value\n    *  @return              The read bytes20 value and updated offset\n    */\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n        bytes20 v;\n        assembly {\n            v := mload(add(buff, add(offset, 0x20)))\n        }\n        return (v, offset + 20);\n    }\n    \n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n        byte v;\n        (v, offset) = NextByte(buff, offset);\n\n        uint value;\n        if (v == 0xFD) {\n            // return NextUint16(buff, offset);\n            (value, offset) = NextUint16(buff, offset);\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n            return (value, offset);\n        } else if (v == 0xFE) {\n            // return NextUint32(buff, offset);\n            (value, offset) = NextUint32(buff, offset);\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n            return (value, offset);\n        } else if (v == 0xFF) {\n            // return NextUint64(buff, offset);\n            (value, offset) = NextUint64(buff, offset);\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n            return (value, offset);\n        } else{\n            // return (uint8(v), offset);\n            value = uint8(v);\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n            return (value, offset);\n        }\n    }\n}"},"contracts/libs/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"contracts/libs/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b != 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"contracts/libs/ownership/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public  onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"contracts/libs/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"},"contracts/libs/token/ERC721/IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"contracts/libs/token/ERC721/IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"},"contracts/libs/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"contracts/libs/utils/Utils.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\nlibrary Utils {\n\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\n    *  @param _bs   Source bytes array\n    *  @return      bytes32\n    */\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n        require(_bs.length == 32, \"bytes length is not 32.\");\n        assembly {\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n            value := mload(add(_bs, 0x20))\n        }\n    }\n\n    /* @notice      Convert bytes to uint256\n    *  @param _b    Source bytes should have length of 32\n    *  @return      uint256\n    */\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n        require(_bs.length == 32, \"bytes length is not 32.\");\n        assembly {\n            // load 32 bytes from memory starting from position _bs + 32\n            value := mload(add(_bs, 0x20))\n        }\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n    }\n\n    /* @notice      Convert uint256 to bytes\n    *  @param _b    uint256 that needs to be converted\n    *  @return      bytes\n    */\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n        assembly {\n            // Get a location of some free memory and store it in result as\n            // Solidity does for memory variables.\n            bs := mload(0x40)\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n            mstore(bs, 0x20)\n            //In the next word, put value in bytes format to the next 32 bytes\n            mstore(add(bs, 0x20), _value)\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n            mstore(0x40, add(bs, 0x40))\n        }\n    }\n\n    /* @notice      Convert bytes to address\n    *  @param _bs   Source bytes: bytes length must be 20\n    *  @return      Converted address from source bytes\n    */\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n    {\n        require(_bs.length == 20, \"bytes length does not match address\");\n        assembly {\n            // for _bs, first word store _bs.length, second word store _bs.value\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n            addr := mload(add(_bs, 0x14))\n        }\n\n    }\n    \n    /* @notice      Convert address to bytes\n    *  @param _addr Address need to be converted\n    *  @return      Converted bytes from address\n    */\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n        assembly {\n            // Get a location of some free memory and store it in result as\n            // Solidity does for memory variables.\n            bs := mload(0x40)\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n            mstore(bs, 0x14)\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n            mstore(add(bs, 0x20), shl(96, _addr))\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n            mstore(0x40, add(bs, 0x40))\n       }\n    }\n\n    /* @notice          Do hash leaf as the multi-chain does\n    *  @param _data     Data in bytes format\n    *  @return          Hashed value in bytes32 format\n    */\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n        result = sha256(abi.encodePacked(byte(0x0), _data));\n    }\n\n    /* @notice          Do hash children as the multi-chain does\n    *  @param _l        Left node\n    *  @param _r        Right node\n    *  @return          Hashed value in bytes32 format\n    */\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n    }\n\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\n    *  @param _preBytes     The bytes stored in storage\n    *  @param _postBytes    The bytes stored in memory\n    *  @return              Bool type indicating if they are equal\n    */\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // fslot can contain both the length and contents of the array\n                // if slength < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                // slength != 0\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\n    *  @param _bytes        The original bytes needs to be sliced\n    *  @param _start        The index of _bytes for the start of sliced bytes\n    *  @param _length       The index of _bytes for the end of sliced bytes\n    *  @return              The sliced bytes\n    */\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                // lengthmod <= _length % 32\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\n    *  @param _keepers      The array consists of serveral address\n    *  @param _signers      Some specific addresses to be looked into\n    *  @param _m            The number requirement paramter\n    *  @return              True means containment, false meansdo do not contain.\n    */\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n        uint m = 0;\n        for(uint i = 0; i < _signers.length; i++){\n            for (uint j = 0; j < _keepers.length; j++) {\n                if (_signers[i] == _keepers[j]) {\n                    m++;\n                    delete _keepers[j];\n                }\n            }\n        }\n        return m >= _m;\n    }\n\n    /* @notice              TODO\n    *  @param key\n    *  @return\n    */\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\n         require(key.length >= 67, \"key lenggh is too short\");\n         newkey = slice(key, 0, 35);\n         if (uint8(key[66]) % 2 == 0){\n             newkey[2] = byte(0x02);\n         } else {\n             newkey[2] = byte(0x03);\n         }\n         return newkey;\n    }\n    \n    /**\n     * @dev Returns true if `account` is a contract.\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}"}}}