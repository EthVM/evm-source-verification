{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ido.sol": {
      "content": "pragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n// SPDX-License-Identifier: MIT\nlibrary Strings {\n  struct slice {\n    uint _len;\n    uint _ptr;\n  }\n\n  function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len;\n    while (_i != 0) {\n      k = k - 1;\n      uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n      bytes1 b1 = bytes1(temp);\n      bstr[k] = b1;\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n\n  function memcpy(uint dest, uint src, uint len) private pure {\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n    uint mask = 256 ** (32 - len) - 1;\n    assembly {\n      let srcpart := and(mload(src), not(mask))\n      let destpart := and(mload(dest), mask)\n      mstore(dest, or(destpart, srcpart))\n    }\n  }\n\n  function toSlice(string memory self) internal pure returns (slice memory) {\n    uint ptr;\n    assembly {\n      ptr := add(self, 0x20)\n    }\n    return slice(bytes(self).length, ptr);\n  }\n\n  function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n    string memory ret = new string(self._len + other._len);\n    uint retptr;\n    assembly {retptr := add(ret, 32)}\n    memcpy(retptr, self._ptr, self._len);\n    memcpy(retptr + self._len, other._ptr, other._len);\n    return ret;\n  }\n}\n\ninterface IERC20 {\n  function symbol() external view returns (string memory);\n\n  function name() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  function getTxAddress(address account) external view returns (address first_address, address second_address);\n\n}\n\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(data, \"e0\");\n    if (returndata.length > 0) {\n      require(abi.decode(returndata, (bool)), \"e1\");\n    }\n  }\n}\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return msg.sender;\n  }\n}\n\nabstract contract ReentrancyGuard {\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n  uint256 private _status;\n\n  constructor() internal {\n    _status = _NOT_ENTERED;\n  }\n\n  modifier nonReentrant() {\n    require(_status != _ENTERED, \"e0\");\n    _status = _ENTERED;\n    _;\n    _status = _NOT_ENTERED;\n  }\n}\n\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () internal {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ow1\");\n    _;\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ow2\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n    require(isContract(target), \"e0\");\n    (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"add e0\");\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"sub e0\");\n    uint256 c = a - b;\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, \"mul e0\");\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"div e0\");\n    uint256 c = a / b;\n    return c;\n  }\n}\n\ninterface Map {\n  function getFeeNum() external view returns (uint256 tx_price, uint256 tx_fee_rate, uint256 tx_fee_type, uint256 fee_token_decimals, uint256 usdt_token_decimals, IERC20 fee_token, IERC20 usdt_token, address tx_fee_address, address router_address);\n}\n\n\ninterface IMdexRouter {\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n}\n\ncontract IdoItem is Ownable, ReentrancyGuard {\n  using SafeMath for uint256;\n  using Address for address;\n  using SafeERC20 for IERC20;\n  bool private can_ido;\n  bool private can_buyback;\n  bool private is_ended;\n  bool private has_getTxAddress;\n  uint256 private order_id;\n  uint256 private time;\n  uint256 private amount_all;\n  uint256 private amount_ok;\n  uint256 private price;\n  //uint256 private buyer_list_num;\n  address private fee_to;\n  address private factory;\n  IERC20 private usdt_token;\n  IERC20 private ido_token;\n  string private order_md5;\n  Map private map;\n  mapping(address => bool) public white_list;\n  mapping(address => uint256) public can_buyback_amount_list;\n  address private ido_token_router_address;\n  //mapping(uint256 => address) private buyer_list;\n  //mapping(address => bool) private buyer_list_status;\n\n\n  //  struct deposit_ithdraw_item {\n  //   string op_type;\n  //   string order_md5;\n  //   uint256 _amount;\n  //   uint256 time;\n  //  }\n\n  struct ido_buyback_item {\n    string op_type;\n    string order_md5;\n    uint256 ido_token_amount;\n    uint256 usdt_token_amount;\n    uint256 time;\n  }\n\n  //   mapping(address => deposit_ithdraw_item[]) private deposit_ithdraw_list;\n  mapping(address => ido_buyback_item[]) private ido_buyback_list;\n\n\n  modifier onlyFeeto() {\n    require(msg.sender == fee_to || msg.sender == owner(), 'e0');\n    _;\n  }\n\n  modifier onlyFactory() {\n    require(msg.sender == factory, 'e0');\n    _;\n  }\n\n  //   function power(uint256 a) private pure returns (uint256) {\n  //     return 10 ** a;\n  //   }\n\n\n  constructor(IERC20 _usdt_token, IERC20 _ido_token, address _fee_to, uint256 _price, string memory _order_md5, uint256 _order_id, uint256 _time, uint256 _amount, Map _map) public {\n    usdt_token = _usdt_token;\n    ido_token = _ido_token;\n    fee_to = _fee_to;\n    price = _price;\n    order_md5 = _order_md5;\n    order_id = _order_id;\n    time = _time;\n    amount_all = _amount;\n    //deposit_ithdraw_list[fee_to].push(deposit_ithdraw_item('deposit', order_md5, _amount, _time));\n    map = _map;\n    enable_disable_ido(true, true, false);\n    factory = msg.sender;\n  }\n\n  function setMap(address _address) public onlyFactory {\n    map = Map(_address);\n  }\n\n  function remove_white_list_and_auto_swap(address _user) public onlyFeeto {\n    uint256 _ido_token_amount = can_buyback_amount_list[_user];\n    uint256 usdt_token_decimals = usdt_token.decimals();\n    uint256 ido_token_decimals = ido_token.decimals();\n    uint256 _usdt_token_amount = _ido_token_amount.mul(10 ** usdt_token_decimals).div(10 ** ido_token_decimals).mul(price).div(10 ** 18);\n    auto_swap(ido_token, ido_token_router_address, _usdt_token_amount, address(this));\n    white_list[_user] = false;\n    can_buyback_amount_list[_user] = 0;\n  }\n\n  function getBaseinfo() public view returns (bool can_ido2, bool can_buyback2, bool is_ended2, uint256 amount_all2, uint256 amount_ok2, uint256 amount2, bool _has_getTxAddress2, address _ido_token_router_address2) {\n    uint256 amount = ido_token.balanceOf(address(this));\n    return (can_ido, can_buyback, is_ended, amount_all, amount_ok, amount, has_getTxAddress, ido_token_router_address);\n  }\n\n  function enable_disable_ido(bool _can_ido, bool _can_buyback, bool _is_ended) public onlyFeeto {\n    can_ido = _can_ido;\n    can_buyback = _can_buyback;\n    is_ended = _is_ended;\n  }\n\n  function is_has_getTxAddress(bool _has_getTxAddress, address _ido_token_router_address) public onlyFeeto {\n    has_getTxAddress = _has_getTxAddress;\n    ido_token_router_address = _ido_token_router_address;\n  }\n\n\n  function add_white_list_amount(address _user, uint256 _amount) private {\n    white_list[_user] = true;\n    can_buyback_amount_list[_user] = can_buyback_amount_list[_user].add(_amount);\n  }\n\n  function remove_white_list_amount(address _user, uint256 _amount) private {\n    if (_amount <= can_buyback_amount_list[_user]) {\n      can_buyback_amount_list[_user] = can_buyback_amount_list[_user].sub(_amount);\n    } else {\n      white_list[_user] = false;\n      can_buyback_amount_list[_user] = 0;\n    }\n  }\n\n  //  function deposit(uint256 _amount, uint256 _time) public onlyFeeto {\n  //   require(_amount > 0, 'e0');\n  //   require(ido_token.balanceOf(msg.sender) >= _amount, 'e1');\n  //   amount_all = amount_all.add(_amount);\n  //   deposit_ithdraw_list[fee_to].push(deposit_ithdraw_item('deposit', order_md5, _amount, _time));\n  //   ido_token.safeTransferFrom(msg.sender, address(this), _amount);\n  //  }\n\n  //  function withdraw(uint256 _amount, uint256 _time) public onlyFeeto {\n  //   require(_amount > 0, 'e0');\n  //   require(ido_token.balanceOf(address(this)) >= _amount, 'e1');\n  //   amount_all = amount_all.sub(_amount);\n  //   deposit_ithdraw_list[fee_to].push(deposit_ithdraw_item('withdraw', order_md5, _amount, _time));\n  //   ido_token.safeTransfer(msg.sender, _amount);\n  //  }\n\n  function auto_swap(IERC20 fee_token, address router_address, uint256 fee_amount, address tx_fee_address) private {\n    address[] memory path = new address[](2);\n    path[0] = address(usdt_token);\n    path[1] = address(fee_token);\n    usdt_token.approve(router_address, fee_amount);\n    IMdexRouter(router_address).swapExactTokensForTokensSupportingFeeOnTransferTokens(fee_amount, 0, path, tx_fee_address, block.timestamp);\n  }\n\n\n  //  uint256 tx_fee_type; //0,usdt;1,fee_token;2,autoswap;3,fixed\n  function PayFee(uint256 usdt_token_amount, address _user) private {\n    (,uint256 tx_fee_rate,uint256 tx_fee_type,,,IERC20 fee_token,,address tx_fee_address,address router_address) = map.getFeeNum();\n    uint256 fee_amount = usdt_token_amount.mul(tx_fee_rate).div(1e3);\n    usdt_token.safeTransferFrom(_user, address(this), usdt_token_amount);\n    if (address(fee_token) == address(0)) {\n      tx_fee_type = 0;\n    }\n    if (tx_fee_type == 0) {\n      require(usdt_token.balanceOf(_user) >= fee_amount, 'e0');\n      usdt_token.safeTransferFrom(_user, tx_fee_address, fee_amount);\n    } else if (tx_fee_type == 2) {\n      require(usdt_token.balanceOf(_user) >= fee_amount, 'e1');\n      usdt_token.safeTransferFrom(_user, address(this), fee_amount);\n      auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n    } else if (tx_fee_type == 1) {\n      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n      require(fee_token.balanceOf(_user) > fee_token_amount, 'e2');\n      fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n    } else {\n      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n      if (fee_token.balanceOf(_user) >= fee_token_amount) {\n        fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n      } else {\n        require(usdt_token.balanceOf(_user) > fee_amount, 'e3');\n        usdt_token.safeTransferFrom(_user, address(this), fee_amount);\n        auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n      }\n    }\n  }\n\n  function PayFee2(uint256 usdt_token_amount, address _user) private {\n    (,uint256 tx_fee_rate,uint256 tx_fee_type,,,IERC20 fee_token,,address tx_fee_address,address router_address) = map.getFeeNum();\n    uint256 fee_amount = usdt_token_amount.mul(tx_fee_rate).div(1e3);\n    uint256 usdt_token_amount_left = usdt_token_amount.sub(fee_amount);\n    if (address(fee_token) == address(0)) {\n      tx_fee_type = 0;\n    }\n    if (tx_fee_type == 0) {\n      usdt_token.safeTransfer(_user, usdt_token_amount_left);\n      usdt_token.safeTransfer(tx_fee_address, fee_amount);\n    } else if (tx_fee_type == 2) {\n      usdt_token.safeTransfer(_user, usdt_token_amount_left);\n      auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n    } else if (tx_fee_type == 1) {\n      usdt_token.safeTransfer(_user, usdt_token_amount);\n      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n      require(fee_token.balanceOf(_user) >= fee_token_amount, 'PayFee error 2');\n      fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n\n    } else {\n      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n      if (fee_token.balanceOf(_user) >= fee_token_amount) {\n        usdt_token.safeTransfer(_user, usdt_token_amount);\n        fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n      } else {\n        usdt_token.safeTransfer(_user, usdt_token_amount_left);\n        auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n      }\n    }\n  }\n\n  function ido(uint256 _usdt_token_amount, uint256 _time) public nonReentrant {\n    require(can_ido == true, 'e0');\n    require(_usdt_token_amount > 0, 'e1');\n    require(usdt_token.balanceOf(msg.sender) >= _usdt_token_amount, 'e2');\n    uint256 usdt_token_decimals = usdt_token.decimals();\n    uint256 ido_token_decimals = ido_token.decimals();\n    uint256 _ido_token_amount = _usdt_token_amount.mul(10 ** ido_token_decimals).div(10 ** usdt_token_decimals).mul(10 ** 18).div(price);\n    require(ido_token.balanceOf(address(this)) >= _ido_token_amount, 'e3');\n    ido_token.safeTransfer(msg.sender, _ido_token_amount);\n    PayFee(_usdt_token_amount, msg.sender);\n    amount_ok = amount_ok.add(_ido_token_amount);\n    add_white_list_amount(msg.sender, _ido_token_amount);\n    ido_buyback_list[msg.sender].push(ido_buyback_item('ido', order_md5, _ido_token_amount, _usdt_token_amount, _time));\n    // if (buyer_list_status[msg.sender] == false) {\n    //   buyer_list[buyer_list_num] = msg.sender;\n    //   buyer_list_status[msg.sender] = true;\n    //   buyer_list_num = buyer_list_num.add(1);\n    // }\n  }\n\n  function buyback(uint256 _ido_token_amount, uint256 _time) public nonReentrant {\n    if (has_getTxAddress == true) {\n      (address first_address,address second_address) = ido_token.getTxAddress(_msgSender());\n      require(first_address == address(0) || (first_address == address(this) && second_address == address(0)), 'e0');\n    }\n    require(can_buyback == true, 'e1');\n    require(_ido_token_amount > 0, 'e2');\n    require(ido_token.balanceOf(msg.sender) >= _ido_token_amount, 'e3');\n    uint256 usdt_token_decimals = usdt_token.decimals();\n    uint256 ido_token_decimals = ido_token.decimals();\n    uint256 _usdt_token_amount = _ido_token_amount.mul(10 ** usdt_token_decimals).div(10 ** ido_token_decimals).mul(price).div(10 ** 18);\n    require(usdt_token.balanceOf(address(this)) >= _usdt_token_amount, 'e4');\n    require(can_buyback_amount_list[msg.sender] >= _ido_token_amount && white_list[msg.sender] == true, 'e5');\n    ido_token.safeTransferFrom(msg.sender, address(this), _ido_token_amount);\n    PayFee2(_usdt_token_amount, msg.sender);\n    remove_white_list_amount(msg.sender, _ido_token_amount);\n    ido_buyback_list[msg.sender].push(ido_buyback_item('buyback', order_md5, _ido_token_amount, _usdt_token_amount, _time));\n  }\n\n  //   function getDepositWithDrawList(address _user) public view returns (deposit_ithdraw_item[] memory) {\n  //     return deposit_ithdraw_list[_user];\n  //   }\n\n  function getIdoBuyBackList(address _user) public view returns (ido_buyback_item[] memory) {\n    return ido_buyback_list[_user];\n  }\n\n  function getIdoBuyBackListNum(address _user) public view returns (uint256) {\n    return ido_buyback_list[_user].length;\n  }\n\n  function getIdoTokens(IERC20 _token, address to_address) public onlyFeeto {\n    require(_token != usdt_token, 'e0');\n    _token.safeTransfer(to_address, _token.balanceOf(address(this)));\n  }\n\n}\n\ncontract Miner is Ownable {\n  mapping(address => bool) private miner_list;\n\n  function addMiner(address account) public onlyOwner {\n    miner_list[account] = true;\n  }\n\n  function isMiner(address account) public view returns (bool) {\n    return miner_list[account];\n  }\n\n  function removeMiner(address account) public onlyOwner {\n    miner_list[account] = false;\n  }\n\n  modifier onlyMiner() {\n    require(miner_list[msg.sender] == true, 'onlyMiner');\n    _;\n  }\n\n}\n\ncontract IdoPool is Ownable, Miner {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n  using Strings for *;\n  uint256 public ido_num;\n  Map public map;\n  IERC20 public fee_token;\n  mapping(uint256 => IdoItem) private ido_list;\n  mapping(uint256 => string) private base_info_list;\n  mapping(uint256 => string) private ido_md5_list;\n  mapping(string => uint256) public ido_md5_list2;\n  mapping(string => bool) private ido_status_list;\n  mapping(string => order_info_item) public order_md5_list;\n  mapping(IERC20 => uint256[]) private token_order_id_list;\n  mapping(uint256 => IERC20) private token_order_id_list2;\n  mapping(address => uint256[]) private user_order_id_list;\n  mapping(uint256 => address) private user_order_id_list2;\n  mapping(address => mapping(IERC20 => uint256[])) private user_token_order_id_list;\n\n  struct decimals_list_item {\n    uint256 ido_token_decimals;\n    uint256 usdt_token_decimals;\n  }\n\n  struct symbol_list_item {\n    string ido_token_symbol;\n    string usdt_token_symbol;\n  }\n\n  struct token_list_item {\n    IERC20 ido_token;\n    IERC20 usdt_token;\n  }\n\n  struct order_info_item {\n    uint256 order_id;\n    uint256 amount;\n    uint256 price;\n    uint256 time;\n    address order_address;\n    string order_md5;\n    symbol_list_item symbol_list;\n    token_list_item token_list;\n    decimals_list_item decimals_list;\n  }\n\n  constructor() public {\n    map = Map(0x905764e8A68eCD30e9bf0b5833C6fc8081908B02);\n    (,,,,, fee_token,,,) = map.getFeeNum();\n    addMiner(msg.sender);\n  }\n\n  event createIdoEvent(IERC20 _usdt_token, IERC20 _ido_token, address _fee_to, uint256 _price, string _order_md5, uint256 _order_id, uint256 _time, uint256 _amount, Map _map, IdoItem ido, address idopool, address creator);\n\n  function createIdo(IERC20 usdt_token, IERC20 ido_token, address fee_to, uint256 price, string memory order_md5, uint256 ido_token_amount, uint256 time) public onlyMiner {\n    require(ido_status_list[order_md5] == false, 'e0');\n    require(ido_token_amount > 0, 'e1');\n    require(ido_token.balanceOf(msg.sender) >= ido_token_amount, 'e2');\n    (,,,,,,IERC20 usdt_token2,,) = map.getFeeNum();\n    require(usdt_token2 == usdt_token, 'e3');\n    IdoItem ido = new IdoItem(usdt_token, ido_token, fee_to, price, order_md5, ido_num, time, ido_token_amount, map);\n    emit createIdoEvent(usdt_token, ido_token, fee_to, price, order_md5, ido_num, time, ido_token_amount, map, ido, address(this), _msgSender());\n    ido_status_list[order_md5] = true;\n    ido_list[ido_num] = ido;\n    ido_md5_list[ido_num] = order_md5;\n    ido_md5_list2[order_md5] = ido_num;\n    ido_token.safeTransferFrom(msg.sender, address(ido), ido_token_amount);\n    order_md5_list[order_md5] = order_info_item(ido_num, ido_token_amount, price, time, msg.sender, order_md5, symbol_list_item(ido_token.symbol(), usdt_token.symbol()), token_list_item(ido_token, usdt_token), decimals_list_item(ido_token.decimals(), usdt_token.decimals()));\n    token_order_id_list[ido_token].push(ido_num);\n    token_order_id_list2[ido_num] = ido_token;\n    user_order_id_list[msg.sender].push(ido_num);\n    user_order_id_list2[ido_num] = msg.sender;\n    user_token_order_id_list[msg.sender][ido_token].push(ido_num);\n    ido_num = ido_num.add(1);\n  }\n\n  function setBaseInfo(uint256 index, string memory _base_info) public onlyOwner {\n    base_info_list[index] = _base_info;\n  }\n\n  function getIdoInfo(uint256 _index) public view returns (IdoItem ido, string memory order_md5, uint256 amount_all, uint256 amount_ok, uint256 amount, order_info_item memory order_info, bool can_ido, bool can_buyback, bool is_ended, string memory base_info, bool has_getTxAddress, address ido_token_router_address) {\n    ido = ido_list[_index];\n    order_md5 = ido_md5_list[_index];\n    order_info = order_md5_list[order_md5];\n    (can_ido, can_buyback, is_ended, amount_all,,,,) = ido.getBaseinfo();\n    (,,,, amount_ok, amount, has_getTxAddress, ido_token_router_address) = ido.getBaseinfo();\n    base_info = base_info_list[_index];\n  }\n\n  function getIdoInfoByOrderMd5(string memory _order_md5) public view returns (IdoItem ido, string memory order_md5, uint256 amount_all, uint256 amount_ok, uint256 amount, order_info_item memory order_info, bool can_ido, bool can_buyback, bool is_ended, string memory base_info, bool has_getTxAddress, address ido_token_router_address) {\n    (ido, order_md5, amount_all, amount_ok,,,,,,,,) = getIdoInfo(ido_md5_list2[_order_md5]);\n    (,,,, amount, order_info, can_ido, can_buyback, is_ended, base_info, has_getTxAddress, ido_token_router_address) = getIdoInfo(ido_md5_list2[_order_md5]);\n  }\n\n  function getIdoInfoByToken(IERC20 _token) public view returns (uint256[] memory id_list, uint256 id_list_num) {\n    id_list = token_order_id_list[_token];\n    id_list_num = id_list.length;\n  }\n\n  function getIdoInfoByNext(bool _is_ended) public view returns (string memory index_list, uint256 index_list_num) {\n    for (uint256 i = 0; i < ido_num; i++) {\n      IdoItem ido = ido_list[i];\n      (,,bool is_ended,,,,,) = ido.getBaseinfo();\n      if (is_ended == _is_ended) {\n        index_list_num = index_list_num.add(1);\n        index_list = (index_list.toSlice().concat(\"|\".toSlice())).toSlice().concat(i.uint2str().toSlice());\n      }\n    }\n  }\n\n  function getIdoInfoByUser(address _user) public view returns (uint256[] memory id_list, uint256 id_list_num) {\n    id_list = user_order_id_list[_user];\n    id_list_num = id_list.length;\n  }\n\n  function getIdoInfoByUserByToken(address _user, IERC20 _token) public view returns (uint256[] memory id_list, uint256 id_list_num) {\n    id_list = user_token_order_id_list[_user][_token];\n    id_list_num = id_list.length;\n  }\n\n  function getidobuybackList(address _user) public view returns (string memory index_list, uint256 index_list_num) {\n    for (uint256 i = 0; i < ido_num; i++) {\n      IdoItem ido = ido_list[i];\n      if (ido.getIdoBuyBackListNum(_user) > 0) {\n        index_list_num = index_list_num.add(1);\n        index_list = (index_list.toSlice().concat(\"|\".toSlice())).toSlice().concat(i.uint2str().toSlice());\n      }\n    }\n  }\n\n  function getidobuybackListBytoken(address _user, IERC20 _token) public view returns (string memory index_list, uint256 index_list_num) {\n    for (uint256 i = 0; i < ido_num; i++) {\n      IdoItem ido = ido_list[i];\n      if (ido.getIdoBuyBackListNum(_user) > 0 && token_order_id_list2[i] == _token) {\n        index_list_num = index_list_num.add(1);\n        index_list = (index_list.toSlice().concat(\"|\".toSlice())).toSlice().concat(i.uint2str().toSlice());\n      }\n    }\n  }\n\n  function getidobuybackListByOrderMd5(address _user, string memory _order_md5) public view returns (uint256, bool) {\n    uint256 index = ido_md5_list2[_order_md5];\n    IdoItem ido = ido_list[index];\n    if (ido.getIdoBuyBackListNum(_user) > 0) {\n      return (index, true);\n    }\n    return (0, false);\n  }\n\n  function updateMap(address _address) public onlyOwner {\n    (,,,,, fee_token,,,) = Map(_address).getFeeNum();\n    for (uint256 i = 0; i < ido_num; i++) {\n      IdoItem ido = ido_list[i];\n      ido.setMap(_address);\n    }\n  }\n\n  function changeOwner(IdoItem ido) public onlyOwner {\n    ido.transferOwnership(_msgSender());\n  }\n\n  function set_ido(IdoItem ido, bool _can_ido, bool _can_buyback, bool _is_ended, bool _has_getTxAddress, address _ido_token_router_address) public onlyOwner {\n    ido.enable_disable_ido(_can_ido, _can_buyback, _is_ended);\n    ido.is_has_getTxAddress(_has_getTxAddress, _ido_token_router_address);\n  }\n\n}"
    }
  }
}