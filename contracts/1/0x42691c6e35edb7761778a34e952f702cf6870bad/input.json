{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport {SimpleInvoice} from \"./Invoice.sol\";\n\ncontract Factory  {\n\n    bytes constant private invoiceCreationCode = type(SimpleInvoice).creationCode;\n\n    function withdraw(uint256 salt, address token, address receiver) external returns (address wallet) {\n        bytes memory bytecode = getByteCode(token, receiver);\n        assembly {\n            wallet := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(wallet != address(0), \"Create2: Failed on deploy\");\n    }\n\n    function computeAddress(uint256 salt, address token, address receiver) external view returns (address) {\n        bytes memory bytecode = getByteCode(token, receiver);\n        return computeAddress(bytes32(salt), bytecode, address(this));\n    }\n\n    function computeAddress(bytes32 salt, bytes memory bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 bytecodeHashHash = keccak256(bytecodeHash);\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHashHash)\n        );\n        return address(bytes20(_data << 96));\n    }\n    \n    \n    function getByteCode(address token, address receiver) private pure returns (bytes memory bytecode) {\n        bytecode = abi.encodePacked(invoiceCreationCode, abi.encode(token, receiver));\n    }\n}"
    },
    "contracts/Invoice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function transfer(address, uint256) external;\n    function balanceOf(address) external view returns(uint256);\n}\n\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\n/// @author davy42\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it's a contract without receive function\ncontract Invoice {\n\n    /// @notice Constructor\n    /// @dev The Invoice contract has only constructor.\n    /// @param token The address of the erc20 token contract\n    /// @param receiver The address to which tokens will be sent\n    /// @param amount amount of tokens\n    constructor(IERC20 token, address payable receiver, uint256 amount) {\n        token.transfer(receiver, amount);\n        selfdestruct(receiver);\n    }\n}\n\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\n/// @author davy42\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it's a contract without receive function\ncontract SimpleInvoice {\n\n    /// @notice Constructor\n    /// @dev The Invoice contract has only constructor.\n    /// @param token The address of the erc20 token contract\n    /// @param receiver The address to which tokens will be sent\n    constructor(IERC20 token, address payable receiver) {\n        token.transfer(receiver, token.balanceOf(address(this)));\n        selfdestruct(receiver);\n    }\n}"
    }
  }
}