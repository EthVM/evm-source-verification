{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ChangeNowMasterPayinV5.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\nimport './IERC20.sol';\nimport './PreparedPayinV5.sol';\n\ncontract ChangeNowMasterPayinV5 {\n    address public owner;\n    address public successor = address(0);\n    uint256 public payins = 0;\n\n    bytes constant payinBytecode = type(PreparedPayinV5).creationCode;\n    bytes32 constant payinBytecodeHash = keccak256(payinBytecode);\n\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n\n    /**\n     * @notice Checks that caller is owner.\n     */\n    modifier isOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n\n    /**\n     * @notice Checks that caller is successor.\n     */\n    modifier isSuccessor() {\n        require(msg.sender == successor, \"Caller is not successor\");\n        _;\n    }\n\n\n    /**\n     * @notice Sets new successor (only owner).\n     */\n    function setSuccessor(address newSuccessor) external isOwner {\n        successor = newSuccessor;\n    }\n\n\n    /**\n     * @notice Takes ownership (only successor).\n     */\n    function takeOwnership() external isSuccessor {\n        owner = successor;\n        successor = address(0);\n    }\n\n\n    /**\n     * @notice Converts payin index into subcontract address. Indexing starts from 0.\n     *\n     * @param {uint256} index - the payin index.\n     *\n     * @return {address} the corresponding payin subcontract address.\n     */\n    function payinAddress(uint256 index)\n        public\n        view\n        returns (address)\n    {\n        return address(uint256(keccak256(abi.encodePacked(\n            hex'ff',\n            address(this),\n            bytes32(index),\n            payinBytecodeHash\n        ))));\n    }\n\n    /**\n     * @notice Helper function to call payin contract in non-standard way\n     * (place selector and following args after token address)\n     *\n     */\n    function _payin_withdrawERC20(address token, address payin, address toAddress, uint256 amount)\n        internal\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x80))\n\n            mstore(ptr, shl(224, 0xa9059cbb)) // \"transfer(address,uint256)\" [ERC20 method]\n            mstore(add(ptr, 0x4), toAddress)  // 1st arg\n            mstore(add(ptr, 0x24), amount)    // 2nd arg\n            mstore(add(ptr, 0x44), token)     // (token address)\n\n            let result := call(gas(), payin, 0, ptr, 0x64, 0, 0)\n\n            if iszero(result) { revert(0, 0) }\n        }\n    }\n\n    /**\n     * @notice Generates next batch of payin subcontracts, up to maxCount\n     * (as much as enough gas left), but not less than minCount (be sure you\n     * have enough gas to covert the minimum).\n     *\n     * @param {uint256} minCount - the minimum payins count to generate.\n     * @param {uint256} maxCount - the maximum payins count to generate.\n     *\n     * @return {uint256,uint256} - the tuple (fromIndex, count) of:\n     * lowest payin index of generated batch and the batch size.\n     *\n     * NOTE: the function is not restricted by the isOwner modifier\n     *       since there is nothing to protect: the subcontracts are owned\n     *       by the factory (this contract) and this one is owned by the\n     *       owner, anyone can spend gas to help us to generate the pool.\n     */\n    function generateNextBatch(uint256 minCount, uint256 maxCount)\n        external\n        returns (uint256, uint256)\n    {\n        require(minCount > 0, 'assert: minCount > 0');\n        require(maxCount >= minCount, 'assert: maxCount > minCount');\n\n        uint256 fromIndex = payins;\n        uint256 calcSinceIndex = fromIndex + minCount;\n        uint256 toIndex = fromIndex + maxCount;\n        uint256 totalGasUsed = 0;\n\n        uint256 index = fromIndex;\n\n        bytes memory bytecode = payinBytecode;\n\n        while (index < toIndex) {\n            if (index >= calcSinceIndex) {\n                uint256 avgGas = (totalGasUsed / (index - fromIndex));\n\n                // is there enough gas left (with extra 5k) to generate next?\n                if (gasleft() < (avgGas + 5000)) {\n                    break;\n                }\n            }\n\n            uint256 gasBefore = gasleft();\n\n            // create payin subcontract\n            bytes32 salt = bytes32(index);\n            address payin;\n            assembly {\n                payin := create2(0, add(bytecode, 32), mload(bytecode), salt)\n            }\n\n            totalGasUsed += gasBefore - gasleft();\n            index++;\n        }\n\n        // save new generated payins count\n        payins = index;\n\n        // return (idx, count)\n        return (fromIndex, index - fromIndex);\n    }\n\n    /**\n     * @notice Harvests (withdraw whole balance) ERC20 tokens from batch of payins.\n     *\n     * @param {address} token - the ERC20 token address to harvest for.\n     * @param {uint256} fromIndex - the lowest index of payin of batch to harvest from.\n     * @param {uint256} count - the count of payins (batch size) to harvest from.\n     * @param {address} toAddress - the destination address to send harvested tokens to.\n     *\n     * @return {uint256} totalAmount - the total harvested amount.\n     */\n    function harvestERC20Batch(address token, uint256 fromIndex, uint256 count, address toAddress)\n        external\n        isOwner\n        returns (uint256)\n    {\n        require(toAddress != address(this), 'toAddress is this');\n        require(toAddress != address(0), 'toAddress is zero');\n\n        uint256 toIndex = fromIndex + count;\n        uint256 totalAmount = 0;\n\n        require(toIndex <= payins, 'not enough payins');\n\n        // send from payins (batch)\n        while (fromIndex < toIndex) {\n            address payin = payinAddress(fromIndex);\n            uint256 amount = IERC20(token).balanceOf(payin);\n\n            if (amount > 0) {\n                _payin_withdrawERC20(token, payin, toAddress, amount);\n                totalAmount += amount;\n            }\n\n            fromIndex++;\n        }\n\n        return totalAmount;\n    }\n\n\n    /**\n     * @notice Harvests (withdraw whole balance) ERC20 tokens from batch of payins.\n     *\n     * @param {address} token - the ERC20 token address to harvest for.\n     * @param {address[]} batch - the batch of addresses to harvest from.\n     * @param {address} toAddress - the destination address to send harvested tokens to.\n     *\n     * @return {uint256} totalAmount - the total harvested amount.\n     */\n    function harvestERC20BatchFor(address token, address[] calldata batch, address toAddress)\n    external isOwner returns (uint256)\n    {\n        require(toAddress != address(this), 'toAddress is this');\n        require(toAddress != address(0), 'toAddress is zero');\n\n        uint256 totalAmount = 0;\n\n        // send from given payins (batch)\n        for (uint256 i = 0; i < batch.length; i++) {\n            address payin = batch[i];\n            uint256 amount = IERC20(token).balanceOf(payin);\n\n            if (amount > 0) {\n                _payin_withdrawERC20(token, payin, toAddress, amount);\n                totalAmount += amount;\n            }\n        }\n\n        return totalAmount;\n    }\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n"},"PreparedPayinV5.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\ncontract PreparedPayinV5 {\n    address private factory;\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    fallback() external {\n        require(msg.sender == factory);\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, 0x64)\n\n            let result := call(\n                gas(),\n                mload(add(ptr, 0x44)),\n                0,\n                ptr,\n                0x44,\n                0,\n                0\n            )\n\n            if iszero(result) { revert(0, 0) }\n        }\n    }\n}\n"}}}