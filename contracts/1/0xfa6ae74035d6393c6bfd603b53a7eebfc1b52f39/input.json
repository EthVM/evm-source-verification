{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RaiLoanInfo.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2021-02-26\r\n*/\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n  contract DSMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x / y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint256 constant WAD = 10**18;\r\n    uint256 constant RAY = 10**27;\r\n\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}  abstract contract IGetSafes {\r\n    function getSafesAsc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\r\n    function getSafesDesc(address manager, address guy) external virtual view returns (uint[] memory ids, address[] memory safes, bytes32[] memory collateralTypes);\r\n\r\n}  abstract contract ISAFEEngine {\r\n\r\n    struct SAFE {\r\n        uint256 lockedCollateral;\r\n        uint256 generatedDebt;\r\n    }\r\n\r\n    struct CollateralType {\r\n        // Total debt issued for this specific collateral type\r\n        uint256 debtAmount;        // [wad]\r\n        // Accumulator for interest accrued on this collateral type\r\n        uint256 accumulatedRate;   // [ray]\r\n        // Floor price at which a SAFE is allowed to generate debt\r\n        uint256 safetyPrice;       // [ray]\r\n        // Maximum amount of debt that can be generated with this collateral type\r\n        uint256 debtCeiling;       // [rad]\r\n        // Minimum amount of debt that must be generated by a SAFE using this collateral\r\n        uint256 debtFloor;         // [rad]\r\n        // Price at which a SAFE gets liquidated\r\n        uint256 liquidationPrice;  // [ray]\r\n    }\r\n\r\n    mapping (bytes32 => mapping (address => SAFE )) public safes;\r\n    mapping (bytes32 => CollateralType) public collateralTypes;\r\n    mapping (bytes32 => mapping (address => uint)) public tokenCollateral;\r\n\r\n    function safeRights(address, address) virtual public view returns (uint);\r\n    function coinBalance(address) virtual public view returns (uint);\r\n    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\r\n    function approveSAFEModification(address) virtual public;\r\n    function transferInternalCoins(address, address, uint) virtual public;\r\n    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;\r\n}  abstract contract ISAFEManager {\r\n\r\n    function lastSAFEID(address) virtual public returns (uint);\r\n    function safeCan(address, uint, address) virtual public view returns (uint);\r\n    function collateralTypes(uint) virtual public view returns (bytes32);\r\n    function ownsSAFE(uint) virtual public view returns (address);\r\n    function safes(uint) virtual public view returns (address);\r\n    function safeEngine() virtual public view returns (address);\r\n    function openSAFE(bytes32, address) virtual public returns (uint);\r\n    function transferSAFEOwnership(uint, address) virtual public;\r\n    function allowSAFE(uint, address, uint) virtual public;\r\n    function handlerAllowed(address, uint) virtual public;\r\n    function modifySAFECollateralization(uint, int, int) virtual public;\r\n    function transferCollateral(uint, address, uint) virtual public;\r\n    function transferInternalCoins(uint, address, uint) virtual public;\r\n    function quitSystem(uint, address) virtual public;\r\n    function enterSystem(address, uint) virtual public;\r\n    function moveSAFE(uint, uint) virtual public;\r\n}  abstract contract IOracleRelayer {\r\n    struct CollateralType {\r\n        address orcl;\r\n        uint256 safetyCRatio;\r\n    }\r\n\r\n    mapping (bytes32 => CollateralType) public collateralTypes;\r\n\r\n    function redemptionPrice() public virtual returns (uint256);\r\n    uint256 public redemptionRate;\r\n}  abstract contract IMedianOracle {\r\n    function read() external virtual view returns (uint256);\r\n}  abstract contract ITaxCollector {\r\n    struct CollateralType {\r\n        // Per second borrow rate for this specific collateral type\r\n        uint256 stabilityFee;\r\n        // When SF was last collected for this collateral type\r\n        uint256 updateTime;\r\n    }\r\n    mapping (bytes32 => CollateralType) public collateralTypes;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RaiLoanInfo is DSMath {\r\n    // mainnet\r\n    address public constant GET_SAFES_ADDR = 0xdf4BC9aA98cC8eCd90Ba2BEe73aD4a1a9C8d202B;\r\n    address public constant MANAGER_ADDR = 0xEfe0B4cA532769a3AE758fD82E1426a03A94F185;\r\n    address public constant SAFE_ENGINE_ADDRESS = 0xCC88a9d330da1133Df3A7bD823B95e52511A6962;\r\n    address public constant ORACLE_RELAYER_ADDRESS = 0x4ed9C0dCa0479bC64d8f4EB3007126D5791f7851;\r\n    address public constant MEDIAN_ORACLE_ADDRESS = 0x12A5E1c81B10B264A575930aEae80681DDF595fe;\r\n    address public constant TAX_COLLECTOR_ADDRESS = 0xcDB05aEda142a1B0D6044C09C64e4226c1a281EB;\r\n    \r\n    // kovan\r\n    // address public constant GET_SAFES_ADDR = 0x702dcf4a8C3bBBd243477D5704fc45F2762D3826;\r\n    // address public constant MANAGER_ADDR = 0x807C8eCb73d9c8203d2b1369E678098B9370F2EA;\r\n    // address public constant SAFE_ENGINE_ADDRESS = 0x7f63fE955fFF8EA474d990f1Fc8979f2C650edbE;\r\n    // address public constant ORACLE_RELAYER_ADDRESS = 0xE5Ae4E49bEA485B5E5172EE6b1F99243cB15225c;\r\n    // address public constant MEDIAN_ORACLE_ADDRESS = 0x82bEAd00751EFA3286c9Dd17e4Ea2570916B3944;\r\n    // address public constant TAX_COLLECTOR_ADDRESS = 0xc1a94C5ad9FCD79b03F79B34d8C0B0C8192fdc16;\r\n\r\n    struct SafeInfo {\r\n        uint256 safeId;\r\n        uint256 coll;\r\n        uint256 debt;\r\n        address safeAddr;\r\n        bytes32 collType;\r\n    }\r\n\r\n    struct CollInfo {\r\n        uint256 debtCeiling;\r\n        uint256 currDebtAmount;\r\n        uint256 currRate;\r\n        uint256 dust;\r\n        uint256 safetyPrice;\r\n        uint256 liqPrice;\r\n        uint256 assetPrice;\r\n        uint256 liqRatio;\r\n        uint256 stabilityFee;\r\n    }\r\n\r\n    struct RaiInfo {\r\n        uint256 redemptionPrice;\r\n        uint256 currRaiPrice;\r\n        uint256 redemptionRate;\r\n    }\r\n\r\n    function getCollateralTypeInfo(bytes32 _collType)\r\n        public\r\n        returns (CollInfo memory collInfo)\r\n    {\r\n        (\r\n            uint256 debtAmount,\r\n            uint256 accumulatedRates,\r\n            uint256 safetyPrice,\r\n            uint256 debtCeiling,\r\n            uint256 debtFloor,\r\n            uint256 liquidationPrice\r\n        ) = ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\r\n\r\n        (, uint liqRatio) = IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\r\n\r\n        (uint stabilityFee,) = ITaxCollector(TAX_COLLECTOR_ADDRESS).collateralTypes(_collType);\r\n\r\n        collInfo = CollInfo({\r\n            debtCeiling: debtCeiling,\r\n            currDebtAmount: debtAmount,\r\n            currRate: accumulatedRates,\r\n            dust: debtFloor,\r\n            safetyPrice: safetyPrice,\r\n            liqPrice: liquidationPrice,\r\n            assetPrice: getPrice(_collType),\r\n            liqRatio: liqRatio,\r\n            stabilityFee: stabilityFee\r\n        });\r\n    }\r\n\r\n    function getCollAndRaiInfo(bytes32 _collType)\r\n        public\r\n        returns (CollInfo memory collInfo, RaiInfo memory raiInfo) {\r\n            collInfo = getCollateralTypeInfo(_collType);\r\n            raiInfo = getRaiInfo();\r\n        }\r\n\r\n    function getPrice(bytes32 _collType) public returns (uint256) {\r\n        (, uint256 safetyCRatio) =\r\n            IOracleRelayer(ORACLE_RELAYER_ADDRESS).collateralTypes(_collType);\r\n        (, , uint256 safetyPrice, , , ) =\r\n            ISAFEEngine(SAFE_ENGINE_ADDRESS).collateralTypes(_collType);\r\n\r\n        uint256 redemptionPrice = IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice();\r\n\r\n        return rmul(rmul(safetyPrice, redemptionPrice), safetyCRatio);\r\n    }\r\n\r\n    function getRaiInfo() public returns (RaiInfo memory raiInfo) {\r\n        raiInfo = RaiInfo({\r\n            redemptionPrice: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionPrice(),\r\n            currRaiPrice: IMedianOracle(MEDIAN_ORACLE_ADDRESS).read(),\r\n            redemptionRate: IOracleRelayer(ORACLE_RELAYER_ADDRESS).redemptionRate()\r\n        });\r\n    }\r\n\r\n    function getSafeInfo(uint256 _safeId) public view returns (SafeInfo memory safeInfo) {\r\n        address safeAddr = ISAFEManager(MANAGER_ADDR).safes(_safeId);\r\n        bytes32 collType = ISAFEManager(MANAGER_ADDR).collateralTypes(_safeId);\r\n\r\n        (uint256 coll, uint256 debt) = ISAFEEngine(SAFE_ENGINE_ADDRESS).safes(collType, safeAddr);\r\n\r\n        safeInfo = SafeInfo({\r\n            safeId: _safeId,\r\n            coll: coll,\r\n            debt: debt,\r\n            safeAddr: safeAddr,\r\n            collType: collType\r\n        });\r\n    }\r\n\r\n    function getUserSafes(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256[] memory ids,\r\n            address[] memory safes,\r\n            bytes32[] memory collateralTypes\r\n        )\r\n    {\r\n        return IGetSafes(GET_SAFES_ADDR).getSafesAsc(MANAGER_ADDR, _user);\r\n    }\r\n\r\n    function getUserSafesFullInfo(address _user) public view returns (SafeInfo[] memory safeInfos) {\r\n        (uint256[] memory ids, , ) = getUserSafes(_user);\r\n\r\n        safeInfos = new SafeInfo[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            safeInfos[i] = getSafeInfo(ids[i]);\r\n        }\r\n    }\r\n\r\n    function getFullInfo(address _user, bytes32 _collType)\r\n        public\r\n        returns (\r\n            CollInfo memory collInfo,\r\n            RaiInfo memory raiInfo,\r\n            SafeInfo[] memory safeInfos\r\n        )\r\n    {\r\n        collInfo = getCollateralTypeInfo(_collType);\r\n        raiInfo = getRaiInfo();\r\n        safeInfos = getUserSafesFullInfo(_user);\r\n    }\r\n}"}}}