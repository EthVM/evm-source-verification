{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":150},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/Controllable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Governable.sol\";\n\ncontract Controllable is Governable {\n\n  constructor(address _storage) Governable(_storage) public {\n  }\n\n  modifier onlyController() {\n    require(store.isController(msg.sender), \"Not a controller\");\n    _;\n  }\n\n  modifier onlyControllerOrGovernance(){\n    require((store.isController(msg.sender) || store.isGovernance(msg.sender)),\n      \"The caller must be controller or governance\");\n    _;\n  }\n\n  function controller() public view returns (address) {\n    return store.controller();\n  }\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/Governable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Storage.sol\";\n\ncontract Governable {\n\n  Storage public store;\n\n  constructor(address _store) public {\n    require(_store != address(0), \"new storage shouldn't be empty\");\n    store = Storage(_store);\n  }\n\n  modifier onlyGovernance() {\n    require(store.isGovernance(msg.sender), \"Not governance\");\n    _;\n  }\n\n  function setStorage(address _store) public onlyGovernance {\n    require(_store != address(0), \"new storage shouldn't be empty\");\n    store = Storage(_store);\n  }\n\n  function governance() public view returns (address) {\n    return store.governance();\n  }\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ncontract Storage {\n\n  address public governance;\n  address public controller;\n\n  constructor() public {\n    governance = msg.sender;\n  }\n\n  modifier onlyGovernance() {\n    require(isGovernance(msg.sender), \"Not governance\");\n    _;\n  }\n\n  function setGovernance(address _governance) public onlyGovernance {\n    require(_governance != address(0), \"new governance shouldn't be empty\");\n    governance = _governance;\n  }\n\n  function setController(address _controller) public onlyGovernance {\n    require(_controller != address(0), \"new controller shouldn't be empty\");\n    controller = _controller;\n  }\n\n  function isGovernance(address account) public view returns (bool) {\n    return account == governance;\n  }\n\n  function isController(address account) public view returns (bool) {\n    return account == controller;\n  }\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/interfaces/IBundle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ninterface IBundle {\n    \n    function underlyingBalanceInBundle() external view returns (uint256);\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n    \n    // function governance() external view returns (address);\n    // function controller() external view returns (address);\n    function getUnderlying() external view returns (address);\n    function getVault() external view returns (address);\n\n    function addStrategy(address _strategy, uint256 riskScore, uint256 weightage) external;\n    // function removeStrategy(address _strategy) external;\n    \n    function withdrawAll() external;\n    function withdraw(uint256 underlyingAmountToWithdraw, address holder) external returns (uint256);\n\n    function depositArbCheck() external view returns(bool);\n\n    function doHardWork() external;\n    function rebalance() external;\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/interfaces/IController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IController {\n    // [Grey list]\n    // An EOA can safely interact with the system no matter what.\n    // If you're using Metamask, you're using an EOA.\n    // Only smart contracts may be affected by this grey list.\n    //\n    // This contract will not be able to ban any EOA from the system\n    // even if an EOA is being added to the greyList, he/she will still be able\n    // to interact with the whole system as if nothing happened.\n    // Only smart contracts will be affected by being added to the greyList.\n    // This grey list is only used in Vault.sol, see the code there for reference\n    function greyList(address _target) external view returns(bool);\n\n    function addVaultAndStrategy(address _vault, address _strategy) external;\n    function doHardWork(address _vault) external;\n    function hasVault(address _vault) external returns(bool);\n\n    function salvage(address _token, uint256 amount) external;\n    function salvageStrategy(address _strategy, address _token, uint256 amount) external;\n\n    function notifyFee(address _underlying, uint256 fee) external;\n    function profitSharingNumerator() external view returns (uint256);\n    function profitSharingDenominator() external view returns (uint256);\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/interfaces/IStrategy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStrategy {\n    \n    // function unsalvagableTokens(address tokens) external view returns (bool);\n    \n    // function governance() external view returns (address);\n    // function controller() external view returns (address);\n    function getUnderlying() external view returns (address);\n    function getBundle() external view returns (address);\n\n    function withdrawAllToBundle() external;\n    function withdrawToBundle(uint256 amount) external;\n\n    function investedUnderlyingBalance() external view returns (uint256); // itsNotMuch()\n\n    // should only be called by controller\n    function salvage(address recipient, address token, uint256 amount) external;\n\n    function doHardWork() external;\n    function depositArbCheck() external view returns(bool);\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/CRVStrategyStable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./interfaces/Gauge.sol\";\nimport \"./interfaces/ICurveFi.sol\";\nimport \"./interfaces/yVault.sol\";\nimport \"./interfaces/IPriceConvertor.sol\";\nimport \"../../interfaces/IBundle.sol\";\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IStrategy.sol\";\nimport \"../../Controllable.sol\";\n\n/**\n* The goal of this strategy is to take a stable asset (DAI, USDC, USDT), turn it into ycrv using\n* the curve mechanisms, and supply ycrv into the ycrv vault. The ycrv vault will likely not have\n* a reward token distribution pool to avoid double dipping. All the calls to functions from this\n* strategy will be routed to the controller which should then call the respective methods on the\n* ycrv vault. This strategy will not be liquidating any yield crops (CRV), because the strategy\n* of the ycrv vault will do that for us.\n*/\ncontract CRVStrategyStable is IStrategy, Controllable {\n\n  enum TokenIndex {DAI, USDC, USDT, TUSD}\n\n  using SafeERC20 for IERC20;\n  using Address for address;\n  using SafeMath for uint256;\n\n  // underlying asset\n  address public underlying;\n\n  // the matching enum record used to determine the index\n  TokenIndex tokenIndex;\n\n  // our bundle holding the underlying asset\n  address public bundle;\n\n  // the y-vault (yield tokens from Curve) corresponding to our asset\n  address public yVault;\n\n  // yearn vault for depositing the yCRV tokens\n  address public ycrvVault;\n\n  // the address of yCRV token\n  address public ycrv;\n\n  // the address of the Curve protocol\n  address public curve;\n\n  // the address of the IPriceConvertor\n  address public convertor;\n\n  // these tokens cannot be claimed by the governance\n  mapping(address => bool) public unsalvagableTokens;\n\n  uint256 public curvePriceCheckpoint;\n  uint256 public ycrvUnit;\n  uint256 public arbTolerance = 3;\n\n  bool public investActivated;\n\n  modifier restricted() {\n    require(msg.sender == bundle || msg.sender == controller()\n      || msg.sender == governance(),\n      \"The sender has to be the controller, governance, or bundle\");\n    _;\n  }\n\n  constructor(\n    address _storage,\n    address _underlying,\n    address _bundle,\n    address _ycrvVault,\n    address _yVault,\n    uint256 _tokenIndex,\n    address _ycrv,\n    address _curveProtocol,\n    address _convertor\n  )\n  Controllable(_storage) public {\n    bundle = _bundle;\n    ycrvVault = _ycrvVault;\n    underlying = _underlying;\n    tokenIndex = TokenIndex(_tokenIndex);\n    yVault = _yVault;\n    ycrv = _ycrv;\n    curve = _curveProtocol;\n    convertor = _convertor;\n\n    // set these tokens to be not salvageable\n    unsalvagableTokens[underlying] = true;\n    unsalvagableTokens[yVault] = true;\n    unsalvagableTokens[ycrv] = true;\n    unsalvagableTokens[ycrvVault] = true;\n\n    investActivated = true;\n\n    ycrvUnit = 10 ** 18;\n    // starting with a stable price, the mainnet will override this value\n    curvePriceCheckpoint = ycrvUnit;\n  }\n\n  function getUnderlying() public override view returns (address) {\n    return underlying;\n  }\n\n  function getBundle() public override view returns (address) {\n    return bundle;\n  }\n\n  function depositArbCheck() public override view returns(bool) {\n    uint256 currentPrice = underlyingValueFromYCrv(ycrvUnit);\n    if (currentPrice < curvePriceCheckpoint) {\n      return currentPrice.mul(100).div(curvePriceCheckpoint) > 100 - arbTolerance;\n    } else {\n      return currentPrice.mul(100).div(curvePriceCheckpoint) < 100 + arbTolerance;\n    }\n  }\n\n  function setArbTolerance(uint256 tolerance) external onlyGovernance {\n    require(tolerance <= 100, \"at most 100\");\n    arbTolerance = tolerance;\n  }\n\n  /**\n  * Uses the Curve protocol to convert the underlying asset into yAsset and then to yCRV.\n  */\n  function yCurveFromUnderlying() internal {\n    // convert underlying asset to yAsset\n    uint256 underlyingBalance = IERC20(underlying).balanceOf(address(this));\n    if (underlyingBalance > 0) {\n      IERC20(underlying).safeApprove(yVault, 0);\n      IERC20(underlying).safeApprove(yVault, underlyingBalance);\n      yERC20(yVault).deposit(underlyingBalance);\n    }\n    // convert yAsset to yCRV\n    uint256 yBalance = IERC20(yVault).balanceOf(address(this));\n    if (yBalance > 0) {\n      IERC20(yVault).safeApprove(curve, 0);\n      IERC20(yVault).safeApprove(curve, yBalance);\n      // we can accept 0 as minimum because this is called only by a trusted role\n      uint256 minimum = 0;\n      uint256[4] memory coinAmounts = wrapCoinAmount(yBalance);\n      ICurveFi(curve).add_liquidity(\n        coinAmounts, minimum\n      );\n    }\n    // now we have yCRV\n  }\n\n  /**\n  * Uses the Curve protocol to convert the yCRV back into the underlying asset. If it cannot acquire\n  * the limit amount, it will acquire the maximum it can.\n  */\n  function yCurveToUnderlying(uint256 underlyingLimit) internal {\n    uint256 ycrvBalance = IERC20(ycrv).balanceOf(address(this));\n\n    // this is the maximum number of y-tokens we can get for our yCRV\n    uint256 yTokenMaximumAmount = yTokenValueFromYCrv(ycrvBalance);\n    if (yTokenMaximumAmount == 0) {\n      return;\n    }\n\n    // ensure that we will not overflow in the conversion\n    uint256 yTokenDesiredAmount = underlyingLimit == uint256(~0) ?\n      yTokenMaximumAmount : yTokenValueFromUnderlying(underlyingLimit);\n\n    uint256[4] memory yTokenAmounts = wrapCoinAmount(\n      Math.min(yTokenMaximumAmount, yTokenDesiredAmount));\n    uint256 yUnderlyingBalanceBefore = IERC20(yVault).balanceOf(address(this));\n    IERC20(ycrv).safeApprove(curve, 0);\n    IERC20(ycrv).safeApprove(curve, ycrvBalance);\n    ICurveFi(curve).remove_liquidity_imbalance(\n      yTokenAmounts, ycrvBalance\n    );\n    // now we have yUnderlying asset\n    uint256 yUnderlyingBalanceAfter = IERC20(yVault).balanceOf(address(this));\n    if (yUnderlyingBalanceAfter > yUnderlyingBalanceBefore) {\n      // we received new yUnderlying tokens for yCRV\n      yERC20(yVault).withdraw(yUnderlyingBalanceAfter.sub(yUnderlyingBalanceBefore));\n    }\n  }\n\n  /**\n  * Allows Governance to withdraw partial shares to reduce slippage incurred \n  *  and facilitate migration / withdrawal / strategy switch\n  */\n  function withdrawPartialYCRVShares(uint256 shares) external restricted {\n    yERC20(ycrvVault).withdraw(shares);\n    yCurveToUnderlying(uint256(~0));\n  }\n\n\n  function setInvestActivated(bool _investActivated) external restricted {\n    investActivated = _investActivated;\n  }\n\n  /**\n  * Withdraws an underlying asset from the strategy to the vault in the specified amount by asking\n  * the yCRV vault for yCRV (currently all of it), and then removing imbalanced liquidity from\n  * the Curve protocol. The rest is deposited back to the yCRV vault. If the amount requested cannot\n  * be obtained, the method will get as much as we have.\n  */\n  function withdrawToBundle(uint256 amountUnderlying) override external restricted {\n    // todo: If we want to be more accurate, we need to calculate how much yCRV we will need here\n    if(IERC20(underlying).balanceOf(address(this)) >= amountUnderlying){\n      IERC20(underlying).safeTransfer(bundle, amountUnderlying);\n      return;\n    }\n\n    uint256 shares = IERC20(ycrvVault).balanceOf(address(this));\n    yERC20(ycrvVault).withdraw(shares);\n    yCurveToUnderlying(amountUnderlying);\n    // we can transfer the asset to the vault\n    uint256 actualBalance = IERC20(underlying).balanceOf(address(this));\n    if (actualBalance > 0) {\n      IERC20(underlying).safeTransfer(bundle, Math.min(amountUnderlying, actualBalance));\n    }\n\n    // invest back the rest\n    investAllUnderlying();\n  }\n\n  /**\n  * Withdraws all assets from the vault. We ask the yCRV vault to give us our entire yCRV balance\n  * and then convert it to the underlying asset using the Curve protocol.\n  */\n  function withdrawAllToBundle() external override restricted {\n    uint256 shares = IERC20(ycrvVault).balanceOf(address(this));\n    yERC20(ycrvVault).withdraw(shares);\n    // withdraw everything until there is only dust left\n    yCurveToUnderlying(uint256(~0));\n    uint256 actualBalance = IERC20(underlying).balanceOf(address(this));\n    if (actualBalance > 0) {\n      IERC20(underlying).safeTransfer(bundle, actualBalance);\n    }\n  }\n\n  /**\n  * Invests all underlying assets into our yCRV vault.\n  */\n  function investAllUnderlying() internal {\n    if(!investActivated) {\n      return;\n    }\n\n    // convert the entire balance not yet invested into yCRV first\n    yCurveFromUnderlying();\n\n    // then deposit into the yCRV vault\n    uint256 ycrvBalance = IERC20(ycrv).balanceOf(address(this));\n    if (ycrvBalance > 0) {\n      IERC20(ycrv).safeApprove(ycrvVault, 0);\n      IERC20(ycrv).safeApprove(ycrvVault, ycrvBalance);\n      // deposits the entire balance and also asks the vault to invest it (public function)\n      yERC20(ycrvVault).deposit(ycrvBalance);\n    }\n  }\n\n  /**\n  * The hard work only invests all underlying assets, and then tells the controller to call hard\n  * work on the yCRV vault.\n  */\n  function doHardWork() public override restricted {\n    investAllUnderlying();\n    curvePriceCheckpoint = underlyingValueFromYCrv(ycrvUnit);\n  }\n\n  /**\n  * Salvages a token. We cannot salvage the shares in the yCRV pool, yCRV tokens, or underlying\n  * assets.\n  */\n  function salvage(address recipient, address token, uint256 amount) public override onlyGovernance {\n    // To make sure that governance cannot come in and take away the coins\n    require(!unsalvagableTokens[token], \"token is defined as not salvageable\");\n    IERC20(token).safeTransfer(recipient, amount);\n  }\n\n  /**\n  * Returns the underlying invested balance. This is the amount of yCRV that we are entitled to\n  * from the yCRV vault (based on the number of shares we currently have), converted to the\n  * underlying assets by the Curve protocol, plus the current balance of the underlying assets.\n  */\n  function investedUnderlyingBalance() public override view returns (uint256) {\n    uint256 shares = IERC20(ycrvVault).balanceOf(address(this));\n    uint256 price = yERC20(ycrvVault).getPricePerFullShare();\n    // the price is in yCRV units, because this is a yCRV vault\n    // the multiplication doubles the number of decimals for shares, so we need to divide\n    // the precision is always 10 ** 18 as the yCRV vault has 18 decimals\n    uint256 precision = 10 ** 18;\n    uint256 ycrvBalance = shares.mul(price).div(precision);\n    // now we can convert the balance to the token amount\n    uint256 ycrvValue = underlyingValueFromYCrv(ycrvBalance);\n    return ycrvValue.add(IERC20(underlying).balanceOf(address(this)));\n  }\n\n  /**\n  * Returns the value of yCRV in underlying token accounting for slippage and fees.\n  */\n  function yTokenValueFromYCrv(uint256 ycrvBalance) public view returns (uint256) {\n    return underlyingValueFromYCrv(ycrvBalance) // this is in DAI, we will convert to yDAI\n    .mul(10 ** 18)\n    .div(yERC20(yVault).getPricePerFullShare()); // function getPricePerFullShare() has 18 decimals for all tokens\n  }\n\n  /**\n  * Returns the value of yCRV in y-token (e.g., yCRV -> yDai) accounting for slippage and fees.\n  */\n  function underlyingValueFromYCrv(uint256 ycrvBalance) public view returns (uint256) {\n    return IPriceConvertor(convertor).yCrvToUnderlying(ycrvBalance, uint256(tokenIndex));\n  }\n\n  /**\n  * Returns the value of the underlying token in yToken\n  */\n  function yTokenValueFromUnderlying(uint256 amountUnderlying) public view returns (uint256) {\n    // 1 yToken = this much underlying, 10 ** 18 precision for all tokens\n    return amountUnderlying\n      .mul(10 ** 18)\n      .div(yERC20(yVault).getPricePerFullShare());\n  }\n\n  /**\n  * Wraps the coin amount in the array for interacting with the Curve protocol\n  */\n  function wrapCoinAmount(uint256 amount) internal view returns (uint256[4] memory) {\n    uint256[4] memory amounts = [uint256(0), uint256(0), uint256(0), uint256(0)];\n    amounts[uint56(tokenIndex)] = amount;\n    return amounts;\n  }\n\n  /**\n  * Replaces the price convertor\n  */\n  function setConvertor(address _convertor) public onlyGovernance {\n    // different price conversion from yCurve to yToken can help in emergency recovery situation\n    // or if there is a bug discovered in the price computation\n    convertor = _convertor;\n  }\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/CRVStrategyStableMainnet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./CRVStrategyStable.sol\";\nimport \"./PriceConvertor.sol\";\n\n/**\n* Adds the mainnet addresses to the CRVStrategyStable\n*/\ncontract CRVStrategyStableMainnet is CRVStrategyStable {\n\n  // token addresses\n  // y-addresses are taken from: https://docs.yearn.finance/yearn.finance/yearn-1\n  address constant public dai = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n  address constant public ydai = address(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n  address constant public usdc = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n  address constant public yusdc = address(0xd6aD7a6750A7593E092a9B218d66C0A814a3436e);\n  address constant public usdt = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  address constant public yusdt = address(0x83f798e925BcD4017Eb265844FDDAbb448f1707D);\n  address constant public tusd = address(0x0000000000085d4780B73119b644AE5ecd22b376);\n  address constant public ytusd = address(0x73a052500105205d34Daf004eAb301916DA8190f);\n\n  // pre-defined constant mapping: underlying -> y-token\n  mapping(address => address) public yVaults;\n\n  // yDAIyUSDCyUSDTyTUSD\n  address constant public __ycrv = address(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n\n  // ycrvVault\n  address constant public __ycrvVault = address(0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c);\n\n  // protocols\n  address constant public __curve = address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n\n  constructor(\n    address _storage,\n    address _underlying,\n    address _bundle\n  )\n  CRVStrategyStable(_storage, _underlying, _bundle, __ycrvVault, address(0), 0,\n    __ycrv,\n    __curve,\n    address(0)\n  )\n  public {\n    yVaults[dai] = ydai;\n    yVaults[usdc] = yusdc;\n    yVaults[usdt] = yusdt;\n    yVaults[tusd] = ytusd; \n    yVault = yVaults[underlying];\n    require(yVault != address(0), \"underlying not supported: yVault is not defined\");\n    if (_underlying == dai) {\n      tokenIndex = TokenIndex.DAI;\n    } else if (_underlying == usdc) {\n      tokenIndex = TokenIndex.USDC;\n    } else if (_underlying == usdt) {\n      tokenIndex = TokenIndex.USDT;\n    } else if (_underlying == tusd) {\n      tokenIndex = TokenIndex.TUSD;\n    } else {\n      revert(\"What is this asset?\");\n    }\n    convertor = address(new PriceConvertor());\n    curvePriceCheckpoint = underlyingValueFromYCrv(ycrvUnit);\n  }\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/PriceConvertor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./interfaces/IPriceConvertor.sol\";\n\ninterface IConvertor {\n  function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n}\n\ncontract PriceConvertor is IPriceConvertor {\n\n  IConvertor public zap = IConvertor(0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3);\n\n  function yCrvToUnderlying(uint256 _token_amount, uint256 i) public override view returns (uint256) {\n    // this returning the DAI amount, not yDAI\n    return zap.calc_withdraw_one_coin(_token_amount, int128(i));\n  }\n}\n\ncontract MockPriceConvertor is IPriceConvertor {\n  function yCrvToUnderlying(uint256 _token_amount, uint256 /* i */) public override view returns (uint256) {\n    // counting 1:1\n    return _token_amount;\n  }\n}"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/interfaces/Gauge.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface Gauge {\n    function deposit(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function withdraw(uint) external;\n    function user_checkpoint(address) external;\n}\n\ninterface VotingEscrow {\n    function create_lock(uint256 v, uint256 time) external;\n    function increase_amount(uint256 _value) external;\n    function increase_unlock_time(uint256 _unlock_time) external;\n    function withdraw() external;\n}\n\ninterface Mintr {\n    function mint(address) external;\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/interfaces/ICurveFi.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ICurveFi {\n  function get_virtual_price() external view returns (uint);\n  function add_liquidity(\n    uint256[4] calldata amounts,\n    uint256 min_mint_amount\n  ) external;\n  function remove_liquidity_imbalance(\n    uint256[4] calldata amounts,\n    uint256 max_burn_amount\n  ) external;\n  function remove_liquidity(\n    uint256 _amount,\n    uint256[4] calldata amounts\n  ) external;\n  function exchange(\n    int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount\n  ) external;\n  function calc_token_amount(\n    uint256[4] calldata amounts,\n    bool deposit\n  ) external view returns(uint);\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/interfaces/IPriceConvertor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IPriceConvertor {\n  function yCrvToUnderlying(uint256 _token_amount, uint256 i) external view returns (uint256);\n}\n"},"/Users/princearora/Documents/Mudrex/defi/mudrex_finance/contracts/strategies/CRVStrategies/interfaces/yVault.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface yERC20 {\n  function deposit(uint256 _amount) external;\n  function withdraw(uint256 _amount) external;\n  function getPricePerFullShare() external view returns (uint256);\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol":{"content":"pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"}}}