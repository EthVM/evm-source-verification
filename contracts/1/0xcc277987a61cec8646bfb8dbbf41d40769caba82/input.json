{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@cartesi/util/contracts/CartesiMath.sol":{"content":"// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title CartesiMath\n/// @author Felipe Argento\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nabstract contract CartesiMath {\n    using SafeMath for uint256;\n    mapping(uint256 => uint256) log2tableTimes1M;\n\n    constructor() {\n        log2tableTimes1M[1] = 0;\n        log2tableTimes1M[2] = 1000000;\n        log2tableTimes1M[3] = 1584962;\n        log2tableTimes1M[4] = 2000000;\n        log2tableTimes1M[5] = 2321928;\n        log2tableTimes1M[6] = 2584962;\n        log2tableTimes1M[7] = 2807354;\n        log2tableTimes1M[8] = 3000000;\n        log2tableTimes1M[9] = 3169925;\n        log2tableTimes1M[10] = 3321928;\n        log2tableTimes1M[11] = 3459431;\n        log2tableTimes1M[12] = 3584962;\n        log2tableTimes1M[13] = 3700439;\n        log2tableTimes1M[14] = 3807354;\n        log2tableTimes1M[15] = 3906890;\n        log2tableTimes1M[16] = 4000000;\n        log2tableTimes1M[17] = 4087462;\n        log2tableTimes1M[18] = 4169925;\n        log2tableTimes1M[19] = 4247927;\n        log2tableTimes1M[20] = 4321928;\n        log2tableTimes1M[21] = 4392317;\n        log2tableTimes1M[22] = 4459431;\n        log2tableTimes1M[23] = 4523561;\n        log2tableTimes1M[24] = 4584962;\n        log2tableTimes1M[25] = 4643856;\n        log2tableTimes1M[26] = 4700439;\n        log2tableTimes1M[27] = 4754887;\n        log2tableTimes1M[28] = 4807354;\n        log2tableTimes1M[29] = 4857980;\n        log2tableTimes1M[30] = 4906890;\n        log2tableTimes1M[31] = 4954196;\n        log2tableTimes1M[32] = 5000000;\n        log2tableTimes1M[33] = 5044394;\n        log2tableTimes1M[34] = 5087462;\n        log2tableTimes1M[35] = 5129283;\n        log2tableTimes1M[36] = 5169925;\n        log2tableTimes1M[37] = 5209453;\n        log2tableTimes1M[38] = 5247927;\n        log2tableTimes1M[39] = 5285402;\n        log2tableTimes1M[40] = 5321928;\n        log2tableTimes1M[41] = 5357552;\n        log2tableTimes1M[42] = 5392317;\n        log2tableTimes1M[43] = 5426264;\n        log2tableTimes1M[44] = 5459431;\n        log2tableTimes1M[45] = 5491853;\n        log2tableTimes1M[46] = 5523561;\n        log2tableTimes1M[47] = 5554588;\n        log2tableTimes1M[48] = 5584962;\n        log2tableTimes1M[49] = 5614709;\n        log2tableTimes1M[50] = 5643856;\n        log2tableTimes1M[51] = 5672425;\n        log2tableTimes1M[52] = 5700439;\n        log2tableTimes1M[53] = 5727920;\n        log2tableTimes1M[54] = 5754887;\n        log2tableTimes1M[55] = 5781359;\n        log2tableTimes1M[56] = 5807354;\n        log2tableTimes1M[57] = 5832890;\n        log2tableTimes1M[58] = 5857980;\n        log2tableTimes1M[59] = 5882643;\n        log2tableTimes1M[60] = 5906890;\n        log2tableTimes1M[61] = 5930737;\n        log2tableTimes1M[62] = 5954196;\n        log2tableTimes1M[63] = 5977279;\n        log2tableTimes1M[64] = 6000000;\n        log2tableTimes1M[65] = 6022367;\n        log2tableTimes1M[66] = 6044394;\n        log2tableTimes1M[67] = 6066089;\n        log2tableTimes1M[68] = 6087462;\n        log2tableTimes1M[69] = 6108524;\n        log2tableTimes1M[70] = 6129283;\n        log2tableTimes1M[71] = 6149747;\n        log2tableTimes1M[72] = 6169925;\n        log2tableTimes1M[73] = 6189824;\n        log2tableTimes1M[74] = 6209453;\n        log2tableTimes1M[75] = 6228818;\n        log2tableTimes1M[76] = 6247927;\n        log2tableTimes1M[77] = 6266786;\n        log2tableTimes1M[78] = 6285402;\n        log2tableTimes1M[79] = 6303780;\n        log2tableTimes1M[80] = 6321928;\n        log2tableTimes1M[81] = 6339850;\n        log2tableTimes1M[82] = 6357552;\n        log2tableTimes1M[83] = 6375039;\n        log2tableTimes1M[84] = 6392317;\n        log2tableTimes1M[85] = 6409390;\n        log2tableTimes1M[86] = 6426264;\n        log2tableTimes1M[87] = 6442943;\n        log2tableTimes1M[88] = 6459431;\n        log2tableTimes1M[89] = 6475733;\n        log2tableTimes1M[90] = 6491853;\n        log2tableTimes1M[91] = 6507794;\n        log2tableTimes1M[92] = 6523561;\n        log2tableTimes1M[93] = 6539158;\n        log2tableTimes1M[94] = 6554588;\n        log2tableTimes1M[95] = 6569855;\n        log2tableTimes1M[96] = 6584962;\n        log2tableTimes1M[97] = 6599912;\n        log2tableTimes1M[98] = 6614709;\n        log2tableTimes1M[99] = 6629356;\n        log2tableTimes1M[100] = 6643856;\n        log2tableTimes1M[101] = 6658211;\n        log2tableTimes1M[102] = 6672425;\n        log2tableTimes1M[103] = 6686500;\n        log2tableTimes1M[104] = 6700439;\n        log2tableTimes1M[105] = 6714245;\n        log2tableTimes1M[106] = 6727920;\n        log2tableTimes1M[107] = 6741466;\n        log2tableTimes1M[108] = 6754887;\n        log2tableTimes1M[109] = 6768184;\n        log2tableTimes1M[110] = 6781359;\n        log2tableTimes1M[111] = 6794415;\n        log2tableTimes1M[112] = 6807354;\n        log2tableTimes1M[113] = 6820178;\n        log2tableTimes1M[114] = 6832890;\n        log2tableTimes1M[115] = 6845490;\n        log2tableTimes1M[116] = 6857980;\n        log2tableTimes1M[117] = 6870364;\n        log2tableTimes1M[118] = 6882643;\n        log2tableTimes1M[119] = 6894817;\n        log2tableTimes1M[120] = 6906890;\n        log2tableTimes1M[121] = 6918863;\n        log2tableTimes1M[122] = 6930737;\n        log2tableTimes1M[123] = 6942514;\n        log2tableTimes1M[124] = 6954196;\n        log2tableTimes1M[125] = 6965784;\n        log2tableTimes1M[126] = 6977279;\n        log2tableTimes1M[127] = 6988684;\n        log2tableTimes1M[128] = 7000000;\n    }\n\n    /// @notice Approximates log2 * 1M\n    /// @param _num number to take log2 * 1M of\n    function log2ApproxTimes1M(uint256 _num) public view returns (uint256) {\n        require (_num > 0, \"Number cannot be zero\");\n        uint256 leading = 0;\n\n        if (_num == 1) return 0;\n\n        while (_num > 128) {\n           _num = _num >> 1;\n           leading += 1;\n       }\n       return (leading.mul(uint256(1000000))).add(log2tableTimes1M[_num]);\n    }\n}\n"},"@cartesi/util/contracts/Decorated.sol":{"content":"// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.7.0;\n\n\ncontract Decorated {\n    // This contract defines several modifiers but does not use\n    // them - they will be used in derived contracts.\n    modifier onlyBy(address user) {\n        require(msg.sender == user, \"Cannot be called by user\");\n        _;\n    }\n\n    modifier onlyAfter(uint256 time) {\n        require(block.timestamp > time, \"Cannot be called now\");\n        _;\n    }\n}\n"},"@cartesi/util/contracts/Instantiator.sol":{"content":"// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\npragma solidity ^0.7.0;\n\n\ninterface Instantiator {\n\n    modifier onlyInstantiated(uint256 _index) virtual;\n\n    modifier onlyActive(uint256 _index) virtual;\n\n    modifier increasesNonce(uint256 _index) virtual;\n\n    function isActive(uint256 _index) external view returns (bool);\n\n    function getNonce(uint256 _index) external view returns (uint256);\n\n    function isConcerned(uint256 _index, address _user) external view returns (bool);\n\n    function getSubInstances(uint256 _index, address) external view returns (address[] memory _addresses, uint256[] memory _indices);\n}\n"},"@cartesi/util/contracts/InstantiatorImpl.sol":{"content":"// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.7.0;\n\nimport \"./Instantiator.sol\";\n\nabstract contract InstantiatorImpl is Instantiator {\n    uint256 public currentIndex = 0;\n\n    mapping(uint256 => bool) internal active;\n    mapping(uint256 => uint256) internal nonce;\n\n    modifier onlyInstantiated(uint256 _index) override {\n        require(currentIndex > _index, \"Index not instantiated\");\n        _;\n    }\n\n    modifier onlyActive(uint256 _index) override {\n        require(currentIndex > _index, \"Index not instantiated\");\n        require(isActive(_index), \"Index inactive\");\n        _;\n    }\n\n    modifier increasesNonce(uint256 _index) override {\n        nonce[_index]++;\n        _;\n    }\n\n    function isActive(uint256 _index) public override view returns (bool) {\n        return (active[_index]);\n    }\n\n    function getNonce(uint256 _index)\n        public\n        override\n        view\n        onlyActive(_index)\n        returns (uint256 currentNonce)\n    {\n        return nonce[_index];\n    }\n\n    function deactivate(uint256 _index) internal {\n        active[_index] = false;\n        nonce[_index] = 0;\n    }\n}\n"},"@openzeppelin/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"contracts/BlockSelector.sol":{"content":"// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Block Selector\n\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"@cartesi/util/contracts/CartesiMath.sol\";\nimport \"@cartesi/util/contracts/InstantiatorImpl.sol\";\nimport \"@cartesi/util/contracts/Decorated.sol\";\n\ncontract BlockSelector is InstantiatorImpl, Decorated, CartesiMath {\n    using SafeMath for uint256;\n\n    struct BlockSelectorCtx {\n        mapping(uint256 => address) blockProducer; // block index to block producer\n        uint256 blockCount; // how many blocks have been created\n        uint256 lastBlockTimestamp; // timestamp of when current selection started\n        uint256 difficulty; // difficulty parameter defines how big the interval will be\n        uint256 minDifficulty; // lower bound for difficulty\n        uint256 difficultyAdjustmentParameter; // how fast the difficulty gets adjusted to reach the desired interval, number * 1000000\n        uint256 targetInterval; // desired block selection interval, used to tune difficulty\n        uint256 currentGoalBlockNumber; // main chain block number which will decide current random target\n\n        address posManagerAddress;\n\n    }\n\n    mapping(uint256 => BlockSelectorCtx) internal instance;\n\n    event BlockProduced(\n        uint256 indexed index,\n        address indexed producer,\n        uint256 blockNumber,\n        uint256 roundDuration,\n        uint256 difficulty,\n        uint256 targetInterval\n    );\n\n    /// @notice Instantiates a BlockSelector structure\n    /// @param _minDifficulty lower bound for difficulty parameter\n    /// @param _initialDifficulty starting difficulty\n    /// @param _difficultyAdjustmentParameter how quickly the difficulty gets updated\n    /// according to the difference between time passed and target interval.\n    /// @param _targetInterval how often we want produce blocks\n    /// @param _posManagerAddress address of ProofOfStake that will use this instance\n    function instantiate(\n        uint256 _minDifficulty,\n        uint256 _initialDifficulty,\n        uint256 _difficultyAdjustmentParameter,\n        uint256 _targetInterval,\n        address _posManagerAddress\n    ) public returns (uint256)\n    {\n        require(\n            _targetInterval > 30,\n            \"Target interval has to be bigger than 30 seconds\"\n        );\n\n        instance[currentIndex].minDifficulty = _minDifficulty;\n        instance[currentIndex].difficulty = _initialDifficulty;\n        instance[currentIndex].difficultyAdjustmentParameter = _difficultyAdjustmentParameter;\n        instance[currentIndex].targetInterval = _targetInterval;\n        instance[currentIndex].posManagerAddress = _posManagerAddress;\n\n        instance[currentIndex].currentGoalBlockNumber = block.number + 1; // goal has to be in the future, so miner cant manipulate (easily)\n        instance[currentIndex].lastBlockTimestamp = block.timestamp; // first selection starts when the instance is created\n\n        active[currentIndex] = true;\n        return currentIndex++;\n    }\n\n    /// @notice Calculates the log of the random number between the goal and callers address\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user address to calculate log of random\n    /// @return log of random number between goal and callers address * 1M\n    function getLogOfRandom(uint256 _index, address _user) internal view returns (uint256) {\n        bytes32 currentGoal = blockhash(instance[_index].currentGoalBlockNumber);\n        bytes32 hashedAddress = keccak256(abi.encodePacked(_user));\n        uint256 distance = uint256(keccak256(abi.encodePacked(hashedAddress, currentGoal)));\n\n        return CartesiMath.log2ApproxTimes1M(distance);\n    }\n\n    /// @notice Produces a block\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user address that has the right to produce block\n    /// @param _weight number that will weight the random number, will be the number of staked tokens\n    function produceBlock(uint256 _index, address _user, uint256 _weight) public returns (bool) {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        require(_weight > 0, \"Caller can't have zero staked tokens\");\n        require(msg.sender == bsc.posManagerAddress, \"Function can only be called by pos address\");\n\n        if (canProduceBlock(_index, _user, _weight)) {\n            emit BlockProduced(\n                _index,\n                _user,\n                bsc.blockCount,\n                getMicrosecondsSinceLastBlock(_index),\n                bsc.difficulty,\n                bsc.targetInterval\n            );\n\n            return _blockProduced(_index, _user);\n        }\n\n        return false;\n    }\n\n    /// @notice Check if address is allowed to produce block\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user the address that is gonna get checked\n    /// @param _weight number that will weight the random number, most likely will be the number of staked tokens\n    function canProduceBlock(uint256 _index, address _user, uint256 _weight) public view returns (bool) {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        // cannot produce if block selector goal hasnt been decided yet\n        if (block.number <= bsc.currentGoalBlockNumber) {\n            return false;\n        }\n\n        uint256 time = getMicrosecondsSinceLastBlock(_index);\n\n        // cannot get hash of block if its older than 256, we set 220 to avoid edge cases\n        // new goal cannot be in the past, otherwise user could \"choose it\"\n        return (\n            (block.number).sub(bsc.currentGoalBlockNumber) > 220 ||\n            (_weight.mul(time)) > bsc.difficulty.mul((256000000 - getLogOfRandom(_index, _user)))\n        );\n    }\n\n    /// @notice Block produced, declare producer and adjust difficulty\n    /// @param _index the index of the instance of block selector you want to interact with\n    /// @param _user address of user that won the round\n    function _blockProduced(uint256 _index, address _user) private returns (bool) {\n        BlockSelectorCtx storage bsc = instance[_index];\n        // declare producer\n        bsc.blockProducer[bsc.blockCount] = _user;\n\n        // adjust difficulty\n        bsc.difficulty = getNewDifficulty(\n            bsc.minDifficulty,\n            bsc.difficulty,\n            (block.timestamp).sub(bsc.lastBlockTimestamp),\n            bsc.targetInterval,\n            bsc.difficultyAdjustmentParameter\n        );\n\n        _reset(_index);\n        return true;\n    }\n\n    /// @notice Reset instance, advancing round and choosing new goal\n    /// @param _index the index of the instance of block selector you want to interact with\n    function _reset(uint256 _index) private {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        bsc.blockCount++;\n        bsc.currentGoalBlockNumber = block.number + 1;\n        bsc.lastBlockTimestamp = block.timestamp;\n    }\n\n    /// @notice Calculates new difficulty parameter\n    /// @param _minDiff minimum difficulty of instance\n    /// @param _oldDiff is the difficulty of previous round\n    /// @param _timePassed is how long the previous round took\n    /// @param _targetInterval is how long a round is supposed to take\n    /// @param _adjustmentParam is how fast the difficulty gets adjusted,\n    ///         should be number * 1000000\n    function getNewDifficulty(\n        uint256 _minDiff,\n        uint256 _oldDiff,\n        uint256 _timePassed,\n        uint256 _targetInterval,\n        uint256 _adjustmentParam\n    )\n    internal\n    pure\n    returns (uint256)\n    {\n        if (_timePassed < _targetInterval) {\n            return _oldDiff.add(_oldDiff.mul(_adjustmentParam).div(1000000) + 1);\n        } else if (_timePassed > _targetInterval) {\n            uint256 newDiff = _oldDiff.sub(_oldDiff.mul(_adjustmentParam).div(1000000) + 1);\n\n            return newDiff > _minDiff ? newDiff : _minDiff;\n        }\n\n        return _oldDiff;\n    }\n\n    /// @notice Returns the number of blocks\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return number of blocks\n    function getBlockCount(uint256 _index) public view returns (uint256) {\n        return instance[_index].blockCount;\n    }\n\n    /// @notice Returns last block timestamp\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return timestamp of when last block was created\n    function getLastBlockTimestamp(uint256 _index) public view returns (uint256) {\n        return instance[_index].lastBlockTimestamp;\n    }\n\n    /// @notice Returns current difficulty\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return difficulty of current selection\n    function getDifficulty(uint256 _index) public view returns (uint256) {\n        return instance[_index].difficulty;\n    }\n\n    /// @notice Returns min difficulty\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return min difficulty of instance\n    function getMinDifficulty(uint256 _index) public view returns (uint256) {\n        return instance[_index].minDifficulty;\n    }\n\n    /// @notice Returns difficulty adjustment parameter\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return difficulty adjustment parameter\n    function getDifficultyAdjustmentParameter(\n        uint256 _index\n    )\n    public\n    view\n    returns (uint256)\n    {\n        return instance[_index].difficultyAdjustmentParameter;\n    }\n\n    /// @notice Returns target interval\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return target interval\n    function getTargetInterval(uint256 _index) public view returns (uint256) {\n        return instance[_index].targetInterval;\n    }\n\n    /// @notice Returns time since last selection started, in microseconds\n    /// @param _index the index of the instance of block selector to be interact with\n    /// @return microseconds passed since last selection started\n    function getMicrosecondsSinceLastBlock(uint256 _index) public view returns (uint256) {\n        BlockSelectorCtx storage bsc = instance[_index];\n\n        // time since selection started times 1e6 (microseconds)\n        return ((block.timestamp).sub(bsc.lastBlockTimestamp)).mul(1000000);\n    }\n\n    function getState(uint256 _index, address _user)\n    public view returns (uint256[5] memory _uintValues) {\n        BlockSelectorCtx storage i = instance[_index];\n\n        uint256[5] memory uintValues = [\n            block.number,\n            i.currentGoalBlockNumber,\n            i.difficulty,\n            ((block.timestamp).sub(i.lastBlockTimestamp)).mul(1000000), // time passed\n            getLogOfRandom(_index, _user)\n        ];\n\n        return uintValues;\n    }\n\n    function isConcerned(uint256, address) public override pure returns (bool) {\n        return false; // isConcerned is only for the main concern (PoS)\n    }\n\n    function getSubInstances(uint256, address)\n        public override pure returns (address[] memory _addresses,\n            uint256[] memory _indices)\n    {\n        address[] memory a;\n        uint256[] memory i;\n\n        a = new address[](0);\n        i = new uint256[](0);\n\n        return (a, i);\n    }\n}\n"}}}