{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DSCCoin.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.7.0;\r\n\r\n// File: SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: FrozenChecker.sol\r\n\r\n/**\r\n * @title FrozenChecker\r\n * @dev Check account by frozen rules\r\n */\r\nlibrary FrozenChecker {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Rule for each address\r\n     */\r\n    struct Rule {\r\n        uint256 timeT;\r\n        uint8 initPercent;\r\n        uint256[] periods;\r\n        uint8[] percents;\r\n    }\r\n\r\n    function check(Rule storage self, uint256 totalFrozenValue) internal view returns (uint256) {\r\n        if (totalFrozenValue == uint256(0)) {\r\n            return 0;\r\n        }\r\n        //uint8 temp = self.initPercent;\r\n        if (self.timeT == uint256(0) || self.timeT > block.timestamp) {\r\n            return totalFrozenValue.sub(totalFrozenValue.mul(self.initPercent).div(100));\r\n        }\r\n        for (uint256 i = 0; i < self.periods.length.sub(1); i = i.add(1)) {\r\n            if (block.timestamp >= self.timeT.add(self.periods[i]) && block.timestamp < self.timeT.add(self.periods[i.add(1)])) {\r\n                return totalFrozenValue.sub(totalFrozenValue.mul(self.percents[i]).div(100));\r\n            }\r\n        }\r\n        if (block.timestamp >= self.timeT.add(self.periods[self.periods.length.sub(1)])) {\r\n            return totalFrozenValue.sub(totalFrozenValue.mul(self.percents[self.periods.length.sub(1)]).div(100));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n}\r\n\r\n// File: FrozenValidator.sol\r\n\r\nlibrary FrozenValidator {\r\n    \r\n    using SafeMath for uint256;\r\n    using FrozenChecker for FrozenChecker.Rule;\r\n\r\n    struct Validator {\r\n        mapping(address => IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint256 size;\r\n    }\r\n\r\n    struct IndexValue {\r\n        uint256 keyIndex; \r\n        FrozenChecker.Rule rule;\r\n        mapping (address => uint256) frozenBalances;\r\n    }\r\n\r\n    struct KeyFlag { \r\n        address key; \r\n        bool deleted; \r\n    }\r\n\r\n    function addRule(Validator storage self, address key, uint8 initPercent, uint256[] memory periods, uint8[] memory percents) internal returns (bool replaced) {\r\n        //require(self.size <= 10);\r\n        require(key != address(0));\r\n        require(periods.length == percents.length);\r\n        require(periods.length > 0);\r\n        require(periods[0] == uint256(0));\r\n        require(initPercent <= percents[0]);\r\n        for (uint256 i = 1; i < periods.length; i = i.add(1)) {\r\n            require(periods[i.sub(1)] < periods[i]);\r\n            require(percents[i.sub(1)] <= percents[i]);\r\n        }\r\n        require(percents[percents.length.sub(1)] == 100);\r\n        FrozenChecker.Rule memory rule = FrozenChecker.Rule(0, initPercent, periods, percents);\r\n        uint256 keyIndex = self.data[key].keyIndex;\r\n        self.data[key].rule = rule;\r\n        if (keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            //keyIndex = self.keys.length++;\r\n            keyIndex = self.keys.length;\r\n            self.keys.push();\r\n            self.data[key].keyIndex = keyIndex.add(1);\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function removeRule(Validator storage self, address key) internal returns (bool success) {\r\n        uint256 keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0) {\r\n            return false;\r\n        }\r\n        delete self.data[key];\r\n        self.keys[keyIndex.sub(1)].deleted = true;\r\n        self.size--;\r\n        return true;\r\n    }\r\n\r\n    function containRule(Validator storage self, address key) internal view returns (bool) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function addTimeT(Validator storage self, address addr, uint256 timeT) internal returns (bool) {\r\n        require(timeT > block.timestamp);\r\n        self.data[addr].rule.timeT = timeT;\r\n        return true;\r\n    }\r\n\r\n    function addFrozenBalance(Validator storage self, address from, address to, uint256 value) internal returns (uint256) {\r\n        self.data[from].frozenBalances[to] = self.data[from].frozenBalances[to].add(value);\r\n        return self.data[from].frozenBalances[to];\r\n    }\r\n\r\n    function validate(Validator storage self, address addr) internal view returns (uint256) {\r\n        uint256 frozenTotal = 0;\r\n        for (uint256 i = iterateStart(self); iterateValid(self, i); i = iterateNext(self, i)) {\r\n            address ruleaddr = iterateGet(self, i);\r\n            FrozenChecker.Rule storage rule = self.data[ruleaddr].rule;\r\n            frozenTotal = frozenTotal.add(rule.check(self.data[ruleaddr].frozenBalances[addr]));\r\n        }\r\n        return frozenTotal;\r\n    }\r\n\r\n\r\n    function iterateStart(Validator storage self) internal view returns (uint256 keyIndex) {\r\n        return iterateNext(self, uint256(-1));\r\n    }\r\n\r\n    function iterateValid(Validator storage self, uint256 keyIndex) internal view returns (bool) {\r\n        return keyIndex < self.keys.length;\r\n    }\r\n\r\n    function iterateNext(Validator storage self, uint256 keyIndex) internal view returns (uint256) {\r\n        keyIndex++;\r\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted) {\r\n            keyIndex++;\r\n        }\r\n        return keyIndex;\r\n    }\r\n\r\n    function iterateGet(Validator storage self, uint256 keyIndex) internal view returns (address) {\r\n        return self.keys[keyIndex].key;\r\n    }\r\n}\r\n\r\n// File: DSCCoin.sol\r\n\r\ncontract DSCCoin {\r\n\r\n    using SafeMath for uint256;\r\n    using FrozenValidator for FrozenValidator.Validator;\r\n\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    //--------------------------------  Basic Info  -------------------------------------//\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    //--------------------------------  Basic Info  -------------------------------------//\r\n\r\n\r\n    //--------------------------------  Admin Info  -------------------------------------//\r\n\r\n    address payable public admin;  //Admin address\r\n\r\n    /**\r\n     * @dev Change admin address\r\n     * @param newAdmin New admin address\r\n     */\r\n    function changeAdmin(address payable newAdmin) public returns (bool)  {\r\n        require(msg.sender == admin);\r\n        require(newAdmin != address(0));\r\n        uint256 balAdmin = balances[admin];\r\n        balances[newAdmin] = balances[newAdmin].add(balAdmin);\r\n        balances[admin] = 0;\r\n        admin = newAdmin;\r\n        emit Transfer(admin, newAdmin, balAdmin);\r\n        return true;\r\n    }\r\n\r\n    //--------------------------------  Admin Info  -------------------------------------//\r\n\r\n\r\n    //--------------------------  Events & Constructor  ------------------------------//\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Mint(address indexed target, uint256 value);\r\n    event Burn(address indexed target, uint256 value);\r\n    event ChainMapping(address indexed target, uint256 value);\r\n\r\n    // constructor\r\n    constructor(string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) {\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = tokenDecimals;\r\n        totalSupply = 0;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    //--------------------------  Events & Constructor  ------------------------------//\r\n    \r\n    \r\n    //-------------------------------  Mint & Burn  ----------------------------------//\r\n    \r\n    function mint(address target, uint256 value) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(!chainMapping);\r\n        require(!frozenAccount[target]);\r\n        require(block.timestamp > frozenTimestamp[target]);\r\n        balances[target] = balances[target].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n        emit Mint(target, value);\r\n        emit Transfer(address(0), target, value);\r\n        return true;\r\n    }\r\n    \r\n    function burn(address target, uint256 value) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(!chainMapping);\r\n        require(!frozenAccount[target]);\r\n        require(block.timestamp > frozenTimestamp[target]);\r\n        require(totalSupply>=value);\r\n        require(balances[target].sub(value)>=validator.validate(target));\r\n        balances[target] = balances[target].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(target, value);\r\n        emit Transfer(target, address(0), value);\r\n        return true;\r\n    }\r\n\r\n    //-------------------------------  Mint & Burn  ----------------------------------//\r\n    \r\n\r\n    //------------------------------ Account lock  -----------------------------------//\r\n\r\n    // 同一个账户满足任意冻结条件均被冻结\r\n    mapping (address => bool) frozenAccount; //无限期冻结的账户\r\n    mapping (address => uint256) frozenTimestamp; // 有限期冻结的账户\r\n\r\n    /**\r\n     * 查询账户是否存在锁定时间戳\r\n     */\r\n    function getFrozenTimestamp(address _target) public view returns (uint256) {\r\n        return frozenTimestamp[_target];\r\n    }\r\n\r\n    /**\r\n     * 查询账户是否被锁定\r\n     */\r\n    function getFrozenAccount(address _target) public view returns (bool) {\r\n        return frozenAccount[_target];\r\n    }\r\n\r\n    /**\r\n     * 锁定账户\r\n     */\r\n    function freeze(address _target, bool _freeze) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_target != admin);\r\n        frozenAccount[_target] = _freeze;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 通过时间戳锁定账户\r\n     */\r\n    function freezeWithTimestamp(address _target, uint256 _timestamp) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_target != admin);\r\n        frozenTimestamp[_target] = _timestamp;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 批量锁定账户\r\n     */\r\n    function multiFreeze(address[] memory _targets, bool[] memory _freezes) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_targets.length == _freezes.length);\r\n        uint256 len = _targets.length;\r\n        require(len > 0);\r\n        for (uint256 i = 0; i < len; i = i.add(1)) {\r\n            address _target = _targets[i];\r\n            require(_target != admin);\r\n            bool _freeze = _freezes[i];\r\n            frozenAccount[_target] = _freeze;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 批量通过时间戳锁定账户\r\n     */\r\n    function multiFreezeWithTimestamp(address[] memory _targets, uint256[] memory _timestamps) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_targets.length == _timestamps.length);\r\n        uint256 len = _targets.length;\r\n        require(len > 0);\r\n        for (uint256 i = 0; i < len; i = i.add(1)) {\r\n            address _target = _targets[i];\r\n            require(_target != admin);\r\n            uint256 _timestamp = _timestamps[i];\r\n            frozenTimestamp[_target] = _timestamp;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //------------------------------  Account lock  -----------------------------------//\r\n\r\n\r\n\r\n\r\n    //--------------------------      Frozen rules      ------------------------------//\r\n\r\n    FrozenValidator.Validator validator;\r\n\r\n    function addRule(address addr, uint8 initPercent, uint256[] memory periods, uint8[] memory percents) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        return validator.addRule(addr, initPercent, periods, percents);\r\n    }\r\n\r\n    function addTimeT(address addr, uint256 timeT) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        return validator.addTimeT(addr, timeT);\r\n    }\r\n\r\n    function removeRule(address addr) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        return validator.removeRule(addr);\r\n    }\r\n\r\n    //--------------------------      Frozen rules      ------------------------------//\r\n\r\n\r\n\r\n    //-----------------------------      Mapping      --------------------------------//\r\n\r\n    bool public chainMapping; //映射开关\r\n\r\n    function changeChainMapping(bool b) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        chainMapping = b;\r\n        return true;\r\n    }\r\n\r\n    function mappingToChain() public returns (bool) {\r\n        require(chainMapping);\r\n        emit ChainMapping(msg.sender, balances[msg.sender]);\r\n        return true;\r\n    }\r\n\r\n    //-----------------------------      Mapping      --------------------------------//\r\n\r\n\r\n\r\n    //-------------------------  Standard ERC20 Interfaces  --------------------------//\r\n\r\n    function multiTransfer(address[] memory _tos, uint256[] memory _values) public returns (bool) {\r\n        require(!chainMapping);\r\n        require(!frozenAccount[msg.sender]);\r\n        require(block.timestamp > frozenTimestamp[msg.sender]);\r\n        require(_tos.length == _values.length);\r\n        uint256 len = _tos.length;\r\n        require(len > 0);\r\n        uint256 amount = 0;\r\n        for (uint256 i = 0; i < len; i = i.add(1)) {\r\n            amount = amount.add(_values[i]);\r\n        }\r\n        require(amount <= balances[msg.sender].sub(validator.validate(msg.sender)));\r\n        for (uint256 j = 0; j < len; j = j.add(1)) {\r\n            address _to = _tos[j];\r\n            if (validator.containRule(msg.sender) && msg.sender != _to) {\r\n                validator.addFrozenBalance(msg.sender, _to, _values[j]);\r\n            }\r\n            balances[_to] = balances[_to].add(_values[j]);\r\n            balances[msg.sender] = balances[msg.sender].sub(_values[j]);\r\n            emit Transfer(msg.sender, _to, _values[j]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        transferfix(_to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferfix(address _to, uint256 _value) public {\r\n        require(!chainMapping);\r\n        require(!frozenAccount[msg.sender]);\r\n        require(block.timestamp > frozenTimestamp[msg.sender]);\r\n        require(balances[msg.sender].sub(_value) >= validator.validate(msg.sender));\r\n\r\n        if (validator.containRule(msg.sender) && msg.sender != _to) {\r\n            validator.addFrozenBalance(msg.sender, _to, _value);\r\n        }\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(!chainMapping);\r\n        require(!frozenAccount[_from]);\r\n        require(block.timestamp > frozenTimestamp[_from]);\r\n        require(_value <= balances[_from].sub(validator.validate(_from)));\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        if (validator.containRule(_from) && _from != _to) {\r\n            validator.addFrozenBalance(_from, _to, _value);\r\n        }\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    //-------------------------  Standard ERC20 Interfaces  --------------------------//\r\n    \r\n    function lockedBalanceOf(address _target) public view returns (uint256) {\r\n        return validator.validate(_target);\r\n    }\r\n\r\n    function withdraw(address _to, uint256 _value) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(!chainMapping);\r\n        require(balances[address(this)].sub(_value) >= 0);\r\n        balances[address(this)] = balances[address(this)].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(address(this), _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function kill() public {\r\n        require(msg.sender == admin);\r\n        selfdestruct(admin);\r\n    }\r\n\r\n}"}}}