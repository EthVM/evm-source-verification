{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Ether101V2.sol": {
      "content": "pragma solidity 0.5.14;\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract Ether101V2 {\r\n    using SafeMath for uint256;\r\n\r\n    struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint referrerID;\r\n        uint currentLevel;\r\n        uint totalEarningEth;\r\n        address[] referral;\r\n        mapping(uint => bool) levelActive;\r\n    }\r\n    \r\n    address public ownerAddress;\r\n    address public marketingAddress;\r\n    uint public marketingFee = 40 ether;\r\n    uint public currentId = 0;\r\n    bool public lockStatus;\r\n    \r\n    mapping (uint => uint) public LEVEL_PRICE;\r\n    mapping (uint => uint) public uplinePercentage;\r\n    mapping (address => UserStruct) public users;\r\n    mapping (uint => address) public userList;\r\n    mapping (address => mapping (uint => uint)) public EarnedEth;\r\n    mapping (address => uint) public loopCheck;\r\n    mapping (address => uint) public createdDate;\r\n    \r\n    event regLevelEvent(address indexed UserAddress, address indexed ReferrerAddress, uint Time);\r\n    event buyLevelEvent(address indexed UserAddress, uint Levelno, uint Time);\r\n    event getMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint LevelPrice, uint Time);\r\n    event lostMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint LevelPrice, uint Time);    \r\n    \r\n    constructor(address _marketing) public {\r\n        ownerAddress = msg.sender;\r\n        marketingAddress = _marketing;\r\n       \r\n        // Level_Price\r\n        LEVEL_PRICE[1] = 0.1 ether;\r\n        LEVEL_PRICE[2] = 0.3 ether;\r\n        LEVEL_PRICE[3] = 1 ether;\r\n        LEVEL_PRICE[4] = 3 ether;\r\n        LEVEL_PRICE[5] = 10 ether;\r\n        LEVEL_PRICE[6] = 30 ether;\r\n        LEVEL_PRICE[7] = 100 ether;\r\n        LEVEL_PRICE[8] = 300 ether;\r\n        LEVEL_PRICE[9] = 1000 ether;\r\n        LEVEL_PRICE[10] = 3000 ether;\r\n       \r\n        \r\n        uplinePercentage[1] = 50 ether;\r\n        uplinePercentage[2] = 10 ether;\r\n        \r\n        UserStruct memory userStruct;\r\n        currentId = currentId.add(1);\r\n    \r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currentId,\r\n            referrerID: 0,\r\n            currentLevel:1,\r\n            totalEarningEth:0,\r\n            referral: new address[](0)\r\n        });\r\n        users[ownerAddress] = userStruct;\r\n        userList[currentId] = ownerAddress;\r\n        users[ownerAddress].currentLevel = 10;\r\n    \r\n        for(uint i = 1; i <= 10; i++) {\r\n            users[ownerAddress].levelActive[i] = true;\r\n        }\r\n    } \r\n    \r\n    /**\r\n     * @dev User registration\r\n     */ \r\n    function regUser(uint _referrerID) external payable {\r\n        require(lockStatus == false, \"Contract Locked\");\r\n        require(users[msg.sender].isExist == false, \"User exist\");\r\n        require(_referrerID > 0 && _referrerID <= currentId, \"Incorrect referrer Id\");\r\n        require(msg.value == LEVEL_PRICE[1], \"Incorrect Value\");\r\n        \r\n        \r\n        // check \r\n        address UserAddress=msg.sender;\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(UserAddress)\r\n        }\r\n        require(size == 0, \"cannot be a contract\"); \r\n    \r\n        UserStruct memory userStruct;\r\n        currentId = currentId.add(1);\r\n        \r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currentId,\r\n            referrerID: _referrerID,\r\n            currentLevel: 1,\r\n            totalEarningEth:0,\r\n            referral: new address[](0)\r\n        });\r\n    \r\n        users[msg.sender] = userStruct;\r\n        userList[currentId] = msg.sender;\r\n        users[msg.sender].levelActive[1] = true;\r\n        users[userList[_referrerID]].referral.push(msg.sender);\r\n        \r\n        loopCheck[msg.sender] = 0;\r\n        createdDate[msg.sender] = now;\r\n        payForLevel(1, msg.sender, ((LEVEL_PRICE[1].mul(marketingFee)).div(10**20)));\r\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\r\n    }\r\n    \r\n    /**\r\n     * @dev To buy the next level by User\r\n     */ \r\n    function buyLevel(uint _level) external payable {\r\n        require(lockStatus == false, \"Contract Locked\");\r\n        require(users[msg.sender].isExist, \"User not exist\"); \r\n        require(_level > 0 && _level <= 10, \"Incorrect level\");\r\n        require(msg.value == LEVEL_PRICE[_level], \"Incorrect Value\");\r\n        require(users[msg.sender].levelActive[_level] == false,\"Already active\");\r\n    \r\n        if (_level != 1) {\r\n            for (uint i = _level - 1; i > 0; i--) \r\n                require(users[msg.sender].levelActive[i] == true, \"Buy the previous level\");\r\n        } \r\n           \r\n      \r\n        users[msg.sender].levelActive[_level] = true;\r\n        users[msg.sender].currentLevel = _level;\r\n    \r\n        loopCheck[msg.sender] = 0;\r\n        payForLevel(_level, msg.sender, ((LEVEL_PRICE[_level].mul(marketingFee)).div(10**20)));\r\n        emit buyLevelEvent(msg.sender, _level, now);\r\n    }\r\n    \r\n    /**\r\n     * @dev Internal function for payment\r\n     */ \r\n    function payForLevel(uint _level, address _userAddress, uint _marketingFee) internal {\r\n        address referer;\r\n        \r\n        referer = userList[users[_userAddress].referrerID];\r\n        \r\n        if (loopCheck[msg.sender] == 0) {\r\n            require((address(uint160(marketingAddress)).send(_marketingFee)), \"Transaction Failure 1\");\r\n            loopCheck[msg.sender] = loopCheck[msg.sender].add(1);\r\n            EarnedEth[marketingAddress][_level] =  EarnedEth[ownerAddress][_level].add(_marketingFee);\r\n            users[marketingAddress].totalEarningEth  = users[ownerAddress].totalEarningEth.add(_marketingFee);\r\n            emit getMoneyForLevelEvent(msg.sender, users[msg.sender].id, marketingAddress, users[marketingAddress].id, _level, _marketingFee, now);\r\n        }\r\n        \r\n        if (!users[referer].isExist) \r\n            referer = userList[1];\r\n        \r\n        if (loopCheck[msg.sender] > 2) \r\n            referer = userList[1];\r\n        \r\n        \r\n        if (users[referer].levelActive[_level] == true) {\r\n            \r\n            if (loopCheck[msg.sender] <= 2) {\r\n                uint uplinePrice;\r\n                \r\n                if(referer == ownerAddress) {\r\n                    \r\n                    for(uint i=loopCheck[msg.sender];i<=2;i++) {\r\n                        uint _uplineShare = (LEVEL_PRICE[_level].mul(uplinePercentage[i])).div(100 ether);\r\n                        uplinePrice = uplinePrice.add(_uplineShare);\r\n                    }\r\n                    \r\n                    require(address(uint160(referer)).send(uplinePrice), \"Transaction Failure\");\r\n                    users[referer].totalEarningEth = users[referer].totalEarningEth.add(uplinePrice);\r\n                    EarnedEth[referer][_level] = EarnedEth[referer][_level].add(uplinePrice);\r\n                    loopCheck[msg.sender] = 2;\r\n                    emit getMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, uplinePrice, now);\r\n                }\r\n                \r\n                else {\r\n                    uplinePrice = (LEVEL_PRICE[_level].mul(uplinePercentage[loopCheck[msg.sender]])).div(100 ether);\r\n                    require(address(uint160(referer)).send(uplinePrice), \"Transaction Failure\");\r\n                    users[referer].totalEarningEth = users[referer].totalEarningEth.add(uplinePrice);\r\n                    EarnedEth[referer][_level] = EarnedEth[referer][_level].add(uplinePrice);\r\n                    loopCheck[msg.sender] = loopCheck[msg.sender].add(1);\r\n                    emit getMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, uplinePrice, now);\r\n                    payForLevel(_level, referer, _marketingFee);\r\n                }\r\n            }\r\n        } else {\r\n            if (loopCheck[msg.sender] <= 2) {\r\n                uint uplinePrice = (LEVEL_PRICE[_level].mul(uplinePercentage[loopCheck[msg.sender]])).div(100 ether);\r\n                emit lostMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, uplinePrice,now);\r\n                payForLevel(_level, referer, _marketingFee);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Contract balance \r\n     */ \r\n    function failSafe(address payable _toUser, uint _amount) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only Owner Wallet\");\r\n        require(_toUser != address(0), \"Invalid Address\");\r\n        require(address(this).balance >= _amount, \"Insufficient balance\");\r\n    \r\n        (_toUser).transfer(_amount);\r\n        return true;\r\n    }\r\n            \r\n    /**\r\n     * @dev Update marketing fee percentage\r\n     */ \r\n    function updateFeePercentage(uint256 _marketingFee) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only OwnerWallet\");\r\n    \r\n        marketingFee = _marketingFee;\r\n        return true;  \r\n    }\r\n    \r\n    /**\r\n     * @dev Update marketing Address\r\n     */ \r\n    function updateMarketingAddress(address _marketing) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only OwnerWallet\");\r\n    \r\n        marketingAddress = _marketing;\r\n        return true;  \r\n    }\r\n    \r\n    /**\r\n     * @dev Update level price\r\n     */ \r\n    function updatePrice(uint _level, uint _price) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"only OwnerWallet\");\r\n    \r\n        LEVEL_PRICE[_level] = _price;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Update contract status\r\n     */ \r\n    function contractLock(bool _lockStatus) public returns (bool) {\r\n        require(msg.sender == ownerAddress, \"Invalid User\");\r\n    \r\n        lockStatus = _lockStatus;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Total earned ETH\r\n     */\r\n    function getTotalEarnedEther() public view returns (uint) {\r\n        uint totalEth;\r\n        for (uint i = 1; i <= currentId; i++) {\r\n            totalEth = totalEth.add(users[userList[i]].totalEarningEth);\r\n        }\r\n        return totalEth;\r\n    }\r\n        \r\n    /**\r\n     * @dev View referrals\r\n     */ \r\n    function viewUserReferral(address _userAddress) external view returns (address[] memory) {\r\n        return users[_userAddress].referral;\r\n    }\r\n    \r\n    /**\r\n     * @dev View level expired time\r\n     */ \r\n    function viewUserLevelExpired(address _userAddress,uint _level) external view returns (bool) {\r\n        return users[_userAddress].levelActive[_level];\r\n    }\r\n    \r\n    // fallback\r\n    function () external payable {\r\n        revert(\"Invalid Transaction\");\r\n    }\r\n}"
    }
  }
}