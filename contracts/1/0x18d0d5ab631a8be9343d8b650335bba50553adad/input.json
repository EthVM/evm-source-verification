{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AzizosV2.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\ncontract ABDKMathQuad {\r\n/*\r\n * ABDK Math Quad Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with IEEE 754\r\n * quadruple-precision binary floating-point numbers (quadruple precision\r\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\r\n * represented by bytes16 type.\r\n */\r\n  /**\r\n   * 0.\r\n   */\r\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\r\n\r\n  /**\r\n   * -0.\r\n   */\r\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * +Infinity.\r\n   */\r\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\r\n\r\n  /**\r\n   * -Infinity.\r\n   */\r\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\r\n\r\n  /**\r\n   * Canonical NaN value.\r\n   */\r\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into quadruple precision number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return quadruple precision number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\r\n    if (x == 0) return bytes16 (0);\r\n    else {\r\n      uint256 result = x;\r\n\r\n      uint256 msb = msb (result);\r\n      if (msb < 112) result <<= 112 - msb;\r\n      else if (msb > 112) result >>= msb - 112;\r\n\r\n      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\r\n\r\n      return bytes16 (uint128 (result));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert quadruple precision number into unsigned 256-bit integer number\r\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\r\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\r\n   * without error, because they are rounded to zero.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function toUInt (bytes16 x) internal pure returns (uint256) {\r\n    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\r\n\r\n    if (exponent < 16383) return 0; // Underflow\r\n\r\n    require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\r\n\r\n    require (exponent <= 16638); // Overflow\r\n    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\r\n      0x10000000000000000000000000000;\r\n\r\n    if (exponent < 16495) result >>= 16495 - exponent;\r\n    else if (exponent > 16495) result <<= exponent - 16495;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Special values behave in the following way:\r\n   *\r\n   * NaN + x = NaN for any x.\r\n   * Infinity + x = Infinity for any finite x.\r\n   * -Infinity + x = -Infinity for any finite x.\r\n   * Infinity + Infinity = Infinity.\r\n   * -Infinity + -Infinity = -Infinity.\r\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @param y quadruple precision number\r\n   * @return quadruple precision number\r\n   */\r\n  function addABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\r\n\r\n    if (xExponent == 0x7FFF) {\r\n      if (yExponent == 0x7FFF) { \r\n        if (x == y) return x;\r\n        else return NaN;\r\n      } else return x; \r\n    } else if (yExponent == 0x7FFF) return y;\r\n    else {\r\n      bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\r\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xExponent == 0) xExponent = 1;\r\n      else xSignifier |= 0x10000000000000000000000000000;\r\n\r\n      bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\r\n      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (yExponent == 0) yExponent = 1;\r\n      else ySignifier |= 0x10000000000000000000000000000;\r\n\r\n      if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\r\n      else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\r\n      else {\r\n        int256 delta = int256 (xExponent) - int256 (yExponent);\r\n  \r\n        if (xSign == ySign) {\r\n          if (delta > 112) return x;\r\n          else if (delta > 0) ySignifier >>= delta;\r\n          else if (delta < -112) return y;\r\n          else if (delta < 0) {\r\n            xSignifier >>= -delta;\r\n            xExponent = yExponent;\r\n          }\r\n  \r\n          xSignifier += ySignifier;\r\n  \r\n          if (xSignifier >= 0x20000000000000000000000000000) {\r\n            xSignifier >>= 1;\r\n            xExponent += 1;\r\n          }\r\n  \r\n          if (xExponent == 0x7FFF)\r\n            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\r\n          else {\r\n            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\r\n            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n  \r\n            return bytes16 (uint128 (\r\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\r\n                (xExponent << 112) |\r\n                xSignifier)); \r\n          }\r\n        } else {\r\n          if (delta > 0) {\r\n            xSignifier <<= 1;\r\n            xExponent -= 1;\r\n          } else if (delta < 0) {\r\n            ySignifier <<= 1;\r\n            xExponent = yExponent - 1;\r\n          }\r\n\r\n          if (delta > 112) ySignifier = 1;\r\n          else if (delta > 1) ySignifier = (ySignifier - 1 >> delta - 1) + 1;\r\n          else if (delta < -112) xSignifier = 1;\r\n          else if (delta < -1) xSignifier = (xSignifier - 1 >> -delta - 1) + 1;\r\n\r\n          if (xSignifier >= ySignifier) xSignifier -= ySignifier;\r\n          else {\r\n            xSignifier = ySignifier - xSignifier;\r\n            xSign = ySign;\r\n          }\r\n\r\n          if (xSignifier == 0)\r\n            return POSITIVE_ZERO;\r\n\r\n          uint256 msb = msb (xSignifier);\r\n\r\n          if (msb == 113) {\r\n            xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n            xExponent += 1;\r\n          } else if (msb < 112) {\r\n            uint256 shift = 112 - msb;\r\n            if (xExponent > shift) {\r\n              xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n              xExponent -= shift;\r\n            } else {\r\n              xSignifier <<= xExponent - 1;\r\n              xExponent = 0;\r\n            }\r\n          } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n          if (xExponent == 0x7FFF)\r\n            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\r\n          else return bytes16 (uint128 (\r\n              (xSign ? 0x80000000000000000000000000000000 : 0) |\r\n              (xExponent << 112) |\r\n              xSignifier));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Special values behave in the following way:\r\n   *\r\n   * NaN - x = NaN for any x.\r\n   * Infinity - x = Infinity for any finite x.\r\n   * -Infinity - x = -Infinity for any finite x.\r\n   * Infinity - -Infinity = Infinity.\r\n   * -Infinity - Infinity = -Infinity.\r\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @param y quadruple precision number\r\n   * @return quadruple precision number\r\n   */\r\n  function subABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    return addABDK(x, y ^ 0x80000000000000000000000000000000);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y.  Special values behave in the following way:\r\n   *\r\n   * NaN * x = NaN for any x.\r\n   * Infinity * x = Infinity for any finite positive x.\r\n   * Infinity * x = -Infinity for any finite negative x.\r\n   * -Infinity * x = -Infinity for any finite positive x.\r\n   * -Infinity * x = Infinity for any finite negative x.\r\n   * Infinity * 0 = NaN.\r\n   * -Infinity * 0 = NaN.\r\n   * Infinity * Infinity = Infinity.\r\n   * Infinity * -Infinity = -Infinity.\r\n   * -Infinity * Infinity = -Infinity.\r\n   * -Infinity * -Infinity = Infinity.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @param y quadruple precision number\r\n   * @return quadruple precision number\r\n   */\r\n  function mulABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\r\n\r\n    if (xExponent == 0x7FFF) {\r\n      if (yExponent == 0x7FFF) {\r\n        if (x == y) return x ^ y & 0x80000000000000000000000000000000;\r\n        else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\r\n        else return NaN;\r\n      } else {\r\n        if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\r\n        else return x ^ y & 0x80000000000000000000000000000000;\r\n      }\r\n    } else if (yExponent == 0x7FFF) {\r\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\r\n        else return y ^ x & 0x80000000000000000000000000000000;\r\n    } else {\r\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xExponent == 0) xExponent = 1;\r\n      else xSignifier |= 0x10000000000000000000000000000;\r\n\r\n      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (yExponent == 0) yExponent = 1;\r\n      else ySignifier |= 0x10000000000000000000000000000;\r\n\r\n      xSignifier *= ySignifier;\r\n      if (xSignifier == 0)\r\n        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\r\n            NEGATIVE_ZERO : POSITIVE_ZERO;\r\n\r\n      xExponent += yExponent;\r\n\r\n      uint256 msb =\r\n        xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\r\n        xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\r\n        msb (xSignifier);\r\n\r\n      if (xExponent + msb < 16496) { // Underflow\r\n        xExponent = 0;\r\n        xSignifier = 0;\r\n      } else if (xExponent + msb < 16608) { // Subnormal\r\n        if (xExponent < 16496)\r\n          xSignifier >>= 16496 - xExponent;\r\n        else if (xExponent > 16496)\r\n          xSignifier <<= xExponent - 16496;\r\n        xExponent = 0;\r\n      } else if (xExponent + msb > 49373) {\r\n        xExponent = 0x7FFF;\r\n        xSignifier = 0;\r\n      } else {\r\n        if (msb > 112)\r\n          xSignifier >>= msb - 112;\r\n        else if (msb < 112)\r\n          xSignifier <<= 112 - msb;\r\n\r\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        xExponent = xExponent + msb - 16607;\r\n      }\r\n\r\n      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\r\n          xExponent << 112 | xSignifier));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y.  Special values behave in the following way:\r\n   *\r\n   * NaN / x = NaN for any x.\r\n   * x / NaN = NaN for any x.\r\n   * Infinity / x = Infinity for any finite non-negative x.\r\n   * Infinity / x = -Infinity for any finite negative x including -0.\r\n   * -Infinity / x = -Infinity for any finite non-negative x.\r\n   * -Infinity / x = Infinity for any finite negative x including -0.\r\n   * x / Infinity = 0 for any finite non-negative x.\r\n   * x / -Infinity = -0 for any finite non-negative x.\r\n   * x / Infinity = -0 for any finite non-negative x including -0.\r\n   * x / -Infinity = 0 for any finite non-negative x including -0.\r\n   * \r\n   * Infinity / Infinity = NaN.\r\n   * Infinity / -Infinity = -NaN.\r\n   * -Infinity / Infinity = -NaN.\r\n   * -Infinity / -Infinity = NaN.\r\n   *\r\n   * Division by zero behaves in the following way:\r\n   *\r\n   * x / 0 = Infinity for any finite positive x.\r\n   * x / -0 = -Infinity for any finite positive x.\r\n   * x / 0 = -Infinity for any finite negative x.\r\n   * x / -0 = Infinity for any finite negative x.\r\n   * 0 / 0 = NaN.\r\n   * 0 / -0 = NaN.\r\n   * -0 / 0 = NaN.\r\n   * -0 / -0 = NaN.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @param y quadruple precision number\r\n   * @return quadruple precision number\r\n   */\r\n  function divABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\r\n\r\n    if (xExponent == 0x7FFF) {\r\n      if (yExponent == 0x7FFF) return NaN;\r\n      else return x ^ y & 0x80000000000000000000000000000000;\r\n    } else if (yExponent == 0x7FFF) {\r\n      if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\r\n      else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\r\n    } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\r\n      if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\r\n      else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\r\n    } else {\r\n      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (yExponent == 0) yExponent = 1;\r\n      else ySignifier |= 0x10000000000000000000000000000;\r\n\r\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xExponent == 0) {\r\n        if (xSignifier != 0) {\r\n          uint shift = 226 - msb (xSignifier);\r\n\r\n          xSignifier <<= shift;\r\n\r\n          xExponent = 1;\r\n          yExponent += shift - 114;\r\n        }\r\n      }\r\n      else {\r\n        xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\r\n      }\r\n\r\n      xSignifier = xSignifier / ySignifier;\r\n      if (xSignifier == 0)\r\n        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\r\n            NEGATIVE_ZERO : POSITIVE_ZERO;\r\n\r\n      assert (xSignifier >= 0x1000000000000000000000000000);\r\n\r\n      uint256 msb =\r\n        xSignifier >= 0x80000000000000000000000000000 ? msb (xSignifier) :\r\n        xSignifier >= 0x40000000000000000000000000000 ? 114 :\r\n        xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\r\n\r\n      if (xExponent + msb > yExponent + 16497) { // Overflow\r\n        xExponent = 0x7FFF;\r\n        xSignifier = 0;\r\n      } else if (xExponent + msb + 16380  < yExponent) { // Underflow\r\n        xExponent = 0;\r\n        xSignifier = 0;\r\n      } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\r\n        if (xExponent + 16380 > yExponent)\r\n          xSignifier <<= xExponent + 16380 - yExponent;\r\n        else if (xExponent + 16380 < yExponent)\r\n          xSignifier >>= yExponent - xExponent - 16380;\r\n\r\n        xExponent = 0;\r\n      } else { // Normal\r\n        if (msb > 112)\r\n          xSignifier >>= msb - 112;\r\n\r\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n        xExponent = xExponent + msb + 16269 - yExponent;\r\n      }\r\n\r\n      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\r\n          xExponent << 112 | xSignifier));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate 2^x.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @return quadruple precision number\r\n   */\r\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\r\n    bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\r\n    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\r\n    uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\r\n    else if (xExponent > 16397)\r\n      return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\r\n    else if (xExponent < 16255)\r\n      return 0x3FFF0000000000000000000000000000;\r\n    else {\r\n      if (xExponent == 0) xExponent = 1;\r\n      else xSignifier |= 0x10000000000000000000000000000;\r\n\r\n      if (xExponent > 16367)\r\n        xSignifier <<= xExponent - 16367;\r\n      else if (xExponent < 16367)\r\n        xSignifier >>= 16367 - xExponent;\r\n\r\n      if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\r\n        return POSITIVE_ZERO;\r\n\r\n      if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        return POSITIVE_INFINITY;\r\n\r\n      uint256 resultExponent = xSignifier >> 128;\r\n      xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n      if (xNegative && xSignifier != 0) {\r\n        xSignifier = ~xSignifier;\r\n        resultExponent += 1;\r\n      }\r\n\r\n      uint256 resultSignifier = 0x80000000000000000000000000000000;\r\n      if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n      if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n      if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n      if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n      if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n      if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n      if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n      if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n      if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n      if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n      if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n      if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n      if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n      if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n      if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\r\n      if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n      if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n      if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n      if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n      if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n      if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n      if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n      if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n      if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n      if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n      if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n      if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n      if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n      if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n      if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n      if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n      if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n      if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n      if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n      if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n      if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n      if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n      if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n      if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n      if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n      if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n      if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n      if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n      if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n      if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n      if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n      if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n      if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n      if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n      if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n      if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n      if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n      if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n      if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n      if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n      if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n      if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n      if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n      if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n      if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n      if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n      if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n      if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n      if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n      if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\r\n      if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\r\n      if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\r\n      if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\r\n      if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\r\n      if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\r\n      if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\r\n      if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\r\n      if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\r\n      if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\r\n      if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\r\n      if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\r\n      if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\r\n      if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\r\n      if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\r\n      if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\r\n      if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\r\n      if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\r\n      if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\r\n      if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\r\n      if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\r\n      if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\r\n      if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\r\n      if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\r\n      if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\r\n      if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\r\n      if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\r\n      if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\r\n      if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\r\n      if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\r\n      if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\r\n      if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\r\n      if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\r\n      if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\r\n      if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\r\n      if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\r\n      if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\r\n      if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\r\n      if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\r\n      if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\r\n      if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\r\n      if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\r\n      if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\r\n      if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\r\n      if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\r\n      if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\r\n      if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\r\n      if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\r\n      if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\r\n      if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\r\n      if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\r\n      if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\r\n      if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\r\n      if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\r\n      if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\r\n      if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\r\n      if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\r\n      if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\r\n      if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\r\n      if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\r\n      if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\r\n      if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\r\n\r\n      if (!xNegative) {\r\n        resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        resultExponent += 0x3FFF;\r\n      } else if (resultExponent <= 0x3FFE) {\r\n        resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        resultExponent = 0x3FFF - resultExponent;\r\n      } else {\r\n        resultSignifier = resultSignifier >> resultExponent - 16367;\r\n        resultExponent = 0;\r\n      }\r\n\r\n      return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate e^x.\r\n   *\r\n   * @param x quadruple precision number\r\n   * @return quadruple precision number\r\n   */\r\n  function exp (bytes16 x) internal pure returns (bytes16) {\r\n    return pow_2 (mulABDK (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\r\n  }\r\n  \r\n  function msb (uint256 x) private pure returns (uint256) {\r\n    require (x > 0);\r\n\r\n    uint256 result = 0;\r\n\r\n    if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\r\n    if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\r\n    if (x >= 0x100000000) { x >>= 32; result += 32; }\r\n    if (x >= 0x10000) { x >>= 16; result += 16; }\r\n    if (x >= 0x100) { x >>= 8; result += 8; }\r\n    if (x >= 0x10) { x >>= 4; result += 4; }\r\n    if (x >= 0x4) { x >>= 2; result += 2; }\r\n    if (x >= 0x2) result += 1; // No need to shift x anymore\r\n\r\n    return result;\r\n  }\r\n  \r\n  function totalSupplyAtTime (uint t) internal pure returns (bytes16 fin) {\r\n      bytes16 xQuad = fromUInt(t);\r\n      bytes16 xQuadSub = subABDK(xQuad, 0x4016e133800000000000000000000000);\r\n      bytes16 exponent = mulABDK(xQuadSub, 0xbfea0c6f7a0b5ed8d36b4c7f34938583);\r\n      bytes16 expExp = exp(exponent);\r\n      bytes16 bottom = addABDK(0x3fff0000000000000000000000000000, expExp);\r\n      bytes16 whole = divABDK(0x402a22db571485000000000000000000, bottom);\r\n      fin = addABDK(whole, 0x401f73b9fbd700000000000000000000);\r\n  }\r\n  \r\n}\r\n\r\ncontract SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    \r\n}\r\n\r\ncontract ERC20wRebase is SafeMath, ABDKMathQuad {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  address public _owner;\r\n  uint private supplyTotal;\r\n  uint private constant _decimals = 9;\r\n  uint private constant uintMax = ~uint256(0);\r\n  uint private constant tokensMax = 10**4 * 10**_decimals;\r\n  uint private tokensInitial = 10**1 * 10**_decimals;\r\n  uint internal unitsPerToken;\r\n  uint private unitsTotal = uintMax - (uintMax % tokensMax);\r\n  uint public tokensCurrent;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping(address => mapping(address => uint)) allowed;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    name = \"AzizosV2\";\r\n    symbol = \"AZIZv2\";\r\n    decimals = 9;\r\n    supplyTotal = tokensMax;\r\n    unitsPerToken = div(unitsTotal, supplyTotal);\r\n    uint unitsInitial =  mul(unitsPerToken, tokensInitial);\r\n    tokensCurrent = tokensInitial;\r\n    balances[msg.sender] = unitsInitial;\r\n    _owner = msg.sender;\r\n    emit Transfer(address(0), msg.sender, tokensInitial);\r\n  }\r\n\r\n  function rebase(int supplyDelta) external onlyOwner returns (uint) {\r\n    if (supplyDelta == 0) {\r\n        emit RebaseEvent(supplyDelta);\r\n        return supplyTotal;\r\n    }\r\n    \r\n    if (supplyDelta < 0) {\r\n        tokensCurrent = sub(tokensCurrent, div(mul(uint(-supplyDelta), tokensCurrent), supplyTotal));\r\n        supplyTotal = sub(supplyTotal, uint(-supplyDelta));\r\n    }\r\n    \r\n    if (supplyDelta > 0) {\r\n        tokensCurrent = add(tokensCurrent, div(mul(uint(supplyDelta), tokensCurrent), supplyTotal));\r\n        supplyTotal = add(supplyTotal, uint(supplyDelta));\r\n    }\r\n\r\n    unitsPerToken = div(unitsTotal, supplyTotal);\r\n\r\n    emit RebaseEvent(supplyDelta);\r\n    return supplyTotal;\r\n  }\r\n\r\n  function totalSupply() public view returns (uint) {\r\n    return tokensCurrent;\r\n  }\r\n  \r\n  function balanceOf(address who) public view returns (uint) {\r\n    return div(balances[who], unitsPerToken);\r\n  }\r\n\r\n  function transfer(address to, uint value) public returns (bool) {\r\n    uint unitValue = mul(value, unitsPerToken);\r\n    balances[msg.sender] = sub(balances[msg.sender], unitValue);\r\n    balances[to] = add(balances[to], unitValue);\r\n    emit Transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner_, address spender) public view returns (uint) {\r\n    return allowed[owner_][spender];\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n    allowed[from][msg.sender] = sub(allowed[from][msg.sender], value);\r\n\r\n    uint unitValue = mul(value, unitsPerToken);\r\n    balances[from] = sub(balances[from], unitValue);\r\n    balances[to] = add(balances[to], unitValue);\r\n    emit Transfer(from, to, value);\r\n\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint value) public returns (bool) {\r\n    allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint addedValue) public returns (bool) {\r\n    allowed[msg.sender][spender] = add(allowed[msg.sender][spender], addedValue);\r\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\r\n    uint256 oldValue = allowed[msg.sender][spender];\r\n    if (subtractedValue >= oldValue) {\r\n      allowed[msg.sender][spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][spender] = sub(oldValue, subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  event RebaseEvent(int supplyDelta);\r\n\r\n}\r\n\r\nabstract contract TwinContract {\r\n    \r\n    function totalBalanceOf(address _of) virtual public view returns (uint256 amount);\r\n    function mint(address unlocker, uint unlockAmount) virtual external returns (bool);\r\n    function getRewardsGiven() virtual public view returns(uint);\r\n    function rebase(int supplyDelta) virtual external returns (uint);\r\n    function getTokensCurrent() virtual public view returns(uint);\r\n    function getSupplyTotal() virtual public view returns (uint);\r\n    function setTokensCurrent(uint newTokens) virtual external returns(uint);\r\n    function getUnitsPerToken() virtual public view returns (uint);\r\n    \r\n}\r\n\r\nabstract contract ThirdPartyContract {\r\n    \r\n    function transferFrom(address from, address to, uint256 value) virtual public returns (bool);\r\n    function transfer(address to, uint value) virtual public returns (bool);\r\n    \r\n}\r\n\r\ncontract AzizosV2 is ERC20wRebase {\r\n  \r\n  uint public totalValueTPT;\r\n  uint public totalRewardsGivenTPT;\r\n  \r\n  address public twinAddress;\r\n  TwinContract private twinContract;\r\n  address public thirdPartyTokenAddress;\r\n  ThirdPartyContract private thirdPartyContract;\r\n  uint public lockingEnabledTime;\r\n  bool public lockEnabled = false;\r\n\r\n  event Mint(address mintee, uint amount);\r\n  event Lock(address locker, uint lockAmount, uint duration);\r\n  event Unlock(address unlocker);\r\n  event UpdatePosition(address updater, int amountDelta, int timeDelta);\r\n  event LockTPT(address locker, uint lockAmount, uint duration);\r\n  event UnlockTPT(address unlocker);\r\n  event UpdatePositionTPT(address updater, int amountDelta, int timeDelta);\r\n  event EnableLock();\r\n  event SetTwin(address twinAddress);\r\n  event SetTPT(address tptAddress);\r\n  event ChangeOwner(address newOwner);\r\n  \r\n  modifier onlyTwin() {\r\n    require(msg.sender == twinAddress, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n  \r\n  function setTwin(address addr) external onlyOwner returns (bool) {\r\n    require(twinAddress == address(0), \"TWIN_ALREADY_SET\");\r\n    twinAddress = addr;\r\n    twinContract = TwinContract(addr);\r\n    emit SetTwin(addr);\r\n    return true;\r\n  }\r\n  \r\n  function setTPT(address addr) external onlyOwner returns (bool) {\r\n      thirdPartyTokenAddress = addr;\r\n      thirdPartyContract = ThirdPartyContract(addr);\r\n      emit SetTPT(addr);\r\n      return true;\r\n  }\r\n  \r\n  function changeOwner(address addr) external onlyOwner returns (bool) {\r\n    _owner = addr;\r\n    return true;\r\n  }\r\n\r\n  mapping(address => lockStruct) public locked;\r\n  mapping(address => lockTPTStruct) public lockedTPT;\r\n  \r\n  struct lockStruct {\r\n    uint amount;\r\n    bytes16 percentSupplyLocked;\r\n    uint unlockTime;\r\n    bool punishmentFlag;\r\n    uint confirmedReward;\r\n    bytes16 supplyWhenLastModified;\r\n  }\r\n  \r\n  struct lockTPTStruct {\r\n    uint amount;\r\n    uint value;\r\n    uint unlockTime;\r\n    bool punishmentFlag;\r\n    uint confirmedReward;\r\n    bytes16 supplyWhenLastModified;\r\n  }\r\n  \r\n  function mint(address unlocker, uint unlockAmount) external onlyTwin returns (bool) {\r\n    uint addedTokens = unlockAmount;\r\n    uint addedUnits = mul(unitsPerToken, addedTokens);\r\n    tokensCurrent = add(tokensCurrent, addedTokens);\r\n    balances[unlocker] = add(balances[unlocker], addedUnits);\r\n    emit Mint(unlocker, unlockAmount);\r\n    return true;\r\n  }\r\n  \r\n  function enableLocking() external onlyOwner returns (bool) {\r\n    require(!lockEnabled, \"LOCKING_ALREADY_ENABLED\");\r\n    lockEnabled = true;\r\n    lockingEnabledTime = now;\r\n    emit EnableLock();\r\n    return lockEnabled;\r\n  }\r\n  \r\n  function lock(uint amount, uint duration) public returns (bool) {\r\n    require(locked[msg.sender].amount == 0, \"POSITION_ALREADY_EXISTS\");\r\n    require(amount > 0, \"INVALID_AMOUNT\");\r\n    require(duration > 0, \"INVALID_DURATION\");\r\n    require(lockEnabled, \"LOCKING_NOT_ENABLED_YET\");\r\n    uint unitAmount = mul(amount, unitsPerToken);\r\n    uint unitsCurrent = mul(tokensCurrent, unitsPerToken);\r\n    bytes16 percentSupplyLocked = divABDK(fromUInt(unitAmount), fromUInt(unitsCurrent));\r\n    uint unlockTime = add(now, duration);\r\n    locked[msg.sender] = lockStruct(unitAmount, percentSupplyLocked, unlockTime, false, 0, mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60));\r\n    transfer(address(this), amount);\r\n    emit Lock(msg.sender, amount, duration);\r\n    return true;\r\n  }\r\n  \r\n  function lockTPT(uint amount, uint duration) public returns (bool) {\r\n    require(lockedTPT[msg.sender].amount == 0, \"POSITION_ALREADY_EXISTS\");\r\n    require(amount > 0, \"INVALID_AMOUNT\");\r\n    require(duration > 0, \"INVALID_DURATION\");\r\n    require(lockEnabled, \"LOCKING_NOT_ENABLED_YET\");\r\n    uint value = amount;\r\n    totalValueTPT = add(totalValueTPT, value);\r\n    lockedTPT[msg.sender] = lockTPTStruct(amount, value, add(now, duration), false, 0, mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60));\r\n    thirdPartyContract.transferFrom(msg.sender, address(this), amount);\r\n    emit LockTPT(msg.sender, amount, duration);\r\n    return true;\r\n  }\r\n\r\n  function calculateUnlockReward(address unlocker, uint unlockTime, bool includeConfirmed) private view returns (uint reward) {\r\n    bool pseudoFlag = false;\r\n    if (locked[unlocker].punishmentFlag || locked[unlocker].unlockTime > unlockTime) {\r\n      pseudoFlag = true;\r\n    }\r\n    int timeUnlockTimeDiff = int(unlockTime) - int(locked[unlocker].unlockTime);\r\n    if (timeUnlockTimeDiff < 0) {\r\n      timeUnlockTimeDiff = -timeUnlockTimeDiff;\r\n    }\r\n    uint minNowUnlockTime = (unlockTime + locked[unlocker].unlockTime) / 2 - uint(timeUnlockTimeDiff) / 2;\r\n    require(minNowUnlockTime == unlockTime || minNowUnlockTime == locked[unlocker].unlockTime, \"MIN_ERROR\");\r\n    reward = toUInt(mulABDK(subABDK(mulABDK(totalSupplyAtTime(sub(minNowUnlockTime, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60), locked[unlocker].supplyWhenLastModified), locked[unlocker].percentSupplyLocked));\r\n    if (includeConfirmed) {\r\n        reward = add(reward, locked[unlocker].confirmedReward);\r\n    }\r\n    reward = div(reward, 3);\r\n    if (pseudoFlag) {\r\n      reward = div(reward, 2);\r\n    }\r\n  }\r\n  \r\n  function calculateUnlockRewardTPT(address unlocker, uint unlockTime, bool includeConfirmed) private view returns (uint reward) {\r\n    bool pseudoFlag = false;\r\n    if(lockedTPT[unlocker].punishmentFlag || lockedTPT[unlocker].unlockTime > unlockTime) {\r\n      pseudoFlag = true;\r\n    }\r\n    int timeUnlockTimeDiff = int(unlockTime) - int(lockedTPT[unlocker].unlockTime);\r\n    if (timeUnlockTimeDiff < 0) {\r\n      timeUnlockTimeDiff = -timeUnlockTimeDiff;\r\n    }\r\n    uint minNowUnlockTime = (unlockTime + lockedTPT[unlocker].unlockTime) / 2 - uint(timeUnlockTimeDiff) / 2;\r\n    require(minNowUnlockTime == unlockTime || minNowUnlockTime == lockedTPT[unlocker].unlockTime, \"MIN_ERROR\");\r\n    reward = toUInt(mulABDK(subABDK(mulABDK(totalSupplyAtTime(sub(minNowUnlockTime, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60), lockedTPT[unlocker].supplyWhenLastModified), divABDK(fromUInt(lockedTPT[unlocker].value), fromUInt(totalValueTPT))));\r\n    if (includeConfirmed) {\r\n        reward = add(reward, lockedTPT[unlocker].confirmedReward);\r\n    }\r\n    reward = toUInt(mulABDK(fromUInt(reward), subABDK(0x3fff0000000000000000000000000000, divABDK(fromUInt(totalRewardsGivenTPT), mulABDK(subABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40202a05f20000000000000000000000), 0x40d3c25c268497681c2650cb4be40d60)))));\r\n    reward = toUInt(mulABDK(fromUInt(reward), 0x3ffe5555555555555555555555555555));\r\n    if (pseudoFlag) {\r\n      reward = div(reward, 2);\r\n    }      \r\n  }\r\n  \r\n  function updatePosition(int amountDelta, int durationDelta) public returns (bool) {\r\n    require(locked[msg.sender].amount > 0, \"NO_POSITION\");\r\n\r\n    uint unitsCurrent = mul(tokensCurrent, unitsPerToken);\r\n\r\n    if (locked[msg.sender].unlockTime < now) {\r\n        uint confirmedReward = calculateUnlockReward(msg.sender, now, false);\r\n        require (durationDelta > 0, \"DURATION_DELTA_OF_EXPIRED_POSITION_MUST_BE_POSITIVE\");\r\n        require (amountDelta >= 0, \"AMOUNT_DELTA_OF_EXPIRE_POSITION_MUST_BE_AT_LEAST_ZERO\");\r\n        bytes16 percentSupplyLocked = divABDK(fromUInt(locked[msg.sender].amount), fromUInt(unitsCurrent));\r\n        locked[msg.sender].percentSupplyLocked = percentSupplyLocked;\r\n        locked[msg.sender].unlockTime = now;\r\n        locked[msg.sender].confirmedReward = add(locked[msg.sender].confirmedReward, confirmedReward);\r\n    } else {\r\n        uint confirmedReward = calculateUnlockReward(msg.sender, now, false) * 2;\r\n        locked[msg.sender].confirmedReward = add(locked[msg.sender].confirmedReward, confirmedReward);\r\n    }\r\n    \r\n    if (amountDelta > 0) {\r\n      uint unitDelta = mul(uint(amountDelta), unitsPerToken);\r\n      locked[msg.sender].amount = add(locked[msg.sender].amount, unitDelta);\r\n      bytes16 percentSupplyLocked = divABDK(fromUInt(unitDelta), fromUInt(unitsCurrent));\r\n      locked[msg.sender].percentSupplyLocked = addABDK(locked[msg.sender].percentSupplyLocked, percentSupplyLocked);\r\n      transfer(address(this), uint(amountDelta));\r\n    }\r\n    \r\n    if (amountDelta < 0) {\r\n      uint unitDelta = mul(uint(-amountDelta), unitsPerToken);\r\n      locked[msg.sender].amount = sub(locked[msg.sender].amount, unitDelta);\r\n      bytes16 percentSupplyLocked = divABDK(fromUInt(unitDelta), fromUInt(unitsCurrent));\r\n      locked[msg.sender].percentSupplyLocked = subABDK(locked[msg.sender].percentSupplyLocked, percentSupplyLocked);\r\n      locked[msg.sender].punishmentFlag = true;\r\n      this.transfer(msg.sender, uint(-amountDelta));\r\n    }\r\n\r\n    if (durationDelta < 0) {\r\n      locked[msg.sender].unlockTime = sub(locked[msg.sender].unlockTime, uint(-durationDelta));\r\n      locked[msg.sender].punishmentFlag = true;\r\n    }\r\n\r\n    if (durationDelta > 0) {\r\n      locked[msg.sender].unlockTime = add(locked[msg.sender].unlockTime, uint(durationDelta));\r\n    }\r\n    \r\n    locked[msg.sender].supplyWhenLastModified = mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60);\r\n\r\n    require(locked[msg.sender].amount > 0, \"POSITION_AMOUNT_CANNOT_BE_NEGATIVE\");\r\n    require(locked[msg.sender].unlockTime > now, \"UNLOCKTIME_MUST_BE_IN_FUTURE\");\r\n    \r\n    emit UpdatePosition(msg.sender, amountDelta, durationDelta);\r\n    return true;\r\n  }\r\n  \r\n  function updatePositionTPT(int amountDelta, int durationDelta) public returns (bool) {\r\n    require(lockedTPT[msg.sender].amount > 0, \"NO_POSITION\");\r\n    \r\n    uint confirmedReward = calculateUnlockRewardTPT(msg.sender, now, false) * 2;\r\n    lockedTPT[msg.sender].confirmedReward = add(lockedTPT[msg.sender].confirmedReward, confirmedReward);\r\n\r\n    if (lockedTPT[msg.sender].unlockTime < now) {\r\n        require (durationDelta > 0, \"DURATION_DELTA_OF_EXPIRED_POSITION_MUST_BE_POSITIVE\");\r\n        require (amountDelta >= 0, \"AMOUNT_DELTA_OF_EXPIRE_POSITION_MUST_BE_AT_LEAST_ZERO\");\r\n        lockedTPT[msg.sender].unlockTime = now;\r\n    }\r\n\r\n    if (amountDelta > 0) {\r\n      lockedTPT[msg.sender].amount = add(lockedTPT[msg.sender].amount, uint(amountDelta));\r\n      uint value = uint(amountDelta);\r\n      totalValueTPT = add(totalValueTPT, value);\r\n      lockedTPT[msg.sender].value = add(lockedTPT[msg.sender].value, value);\r\n      thirdPartyContract.transferFrom(msg.sender, address(this), uint(amountDelta));\r\n    }\r\n    \r\n    if (amountDelta < 0) {\r\n      lockedTPT[msg.sender].amount = sub(lockedTPT[msg.sender].amount, uint(-amountDelta));\r\n      uint value = uint(-amountDelta);\r\n      totalValueTPT = sub(totalValueTPT, value);\r\n      lockedTPT[msg.sender].value = sub(lockedTPT[msg.sender].value, value);\r\n      lockedTPT[msg.sender].punishmentFlag = true;\r\n      thirdPartyContract.transfer(msg.sender, uint(-amountDelta));\r\n    }\r\n\r\n    if (durationDelta < 0) {\r\n      lockedTPT[msg.sender].unlockTime = sub(lockedTPT[msg.sender].unlockTime, uint(-durationDelta));\r\n      uint value = lockedTPT[msg.sender].amount;\r\n      totalValueTPT = sub(totalValueTPT, value);\r\n      lockedTPT[msg.sender].value = sub(lockedTPT[msg.sender].value, value);\r\n      lockedTPT[msg.sender].punishmentFlag = true;\r\n    }\r\n\r\n    if (durationDelta > 0) {\r\n      lockedTPT[msg.sender].unlockTime = add(lockedTPT[msg.sender].unlockTime, uint(durationDelta));\r\n      uint value = lockedTPT[msg.sender].amount;\r\n      totalValueTPT = add(totalValueTPT, value);\r\n      lockedTPT[msg.sender].value = add(lockedTPT[msg.sender].value, value);\r\n    }\r\n    \r\n    lockedTPT[msg.sender].supplyWhenLastModified = mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60);\r\n    \r\n    require(lockedTPT[msg.sender].amount > 0, \"POSITION_AMOUNT_CANNOT_BE_NEGATIVE\");\r\n    require(lockedTPT[msg.sender].unlockTime > now, \"UNLOCKTIME_MUST_BE_IN_FUTURE\");\r\n    \r\n    emit UpdatePositionTPT(msg.sender, amountDelta, durationDelta);\r\n    return true;\r\n  }\r\n  \r\n  function unlock() public returns (bool success) {\r\n    require(locked[msg.sender].amount > 0, \"NO_POSITION\");\r\n    uint tokenAmount = div(locked[msg.sender].amount, unitsPerToken);\r\n    this.transfer(msg.sender, tokenAmount);\r\n    uint reward = calculateUnlockReward(msg.sender, now, true);\r\n    uint rewardTokens = div(reward, twinContract.getUnitsPerToken());\r\n    success = twinContract.mint(msg.sender, rewardTokens);\r\n    locked[msg.sender] = lockStruct(0, bytes16(0), 0, false, 0, bytes16(0));\r\n    require(success, \"MINT_FAILED\");\r\n    emit Unlock(msg.sender);\r\n  }\r\n  \r\n  function unlockTPT() public returns (bool success) {\r\n    require(lockedTPT[msg.sender].amount > 0, \"NO_POSITION\");\r\n    thirdPartyContract.transfer(msg.sender, lockedTPT[msg.sender].amount);\r\n    uint reward = calculateUnlockRewardTPT(msg.sender, now, true);\r\n    totalRewardsGivenTPT = add(reward, totalRewardsGivenTPT);\r\n    uint rewardTokens = div(reward, twinContract.getUnitsPerToken());\r\n    success = twinContract.mint(msg.sender, rewardTokens);\r\n    totalValueTPT = sub(totalValueTPT, lockedTPT[msg.sender].value);\r\n    lockedTPT[msg.sender] = lockTPTStruct(0, 0, 0, false, 0, bytes16(0));\r\n    require(success, \"MINT_FAILED\");\r\n    emit UnlockTPT(msg.sender);\r\n  }\r\n  \r\n  function getRewardTokens(address addr, uint time) public view returns (uint) {\r\n    require(locked[addr].amount > 0, \"NO_POSITION\");\r\n    return div(calculateUnlockReward(addr, time, true), twinContract.getUnitsPerToken());\r\n  }\r\n  \r\n  function getLockedTokens(address addr) public view returns (uint) {\r\n    require(locked[addr].amount > 0, \"NO_POSITION\");\r\n    return div(locked[addr].amount, unitsPerToken);   \r\n  }\r\n  \r\n  function getRewardTokensTPT(address addr, uint time) public view returns (uint) {\r\n    require(lockedTPT[addr].amount > 0, \"NO_POSITION\");\r\n    return div(calculateUnlockRewardTPT(addr, time, true), twinContract.getUnitsPerToken());\r\n  }\r\n  \r\n  function getUnitsPerToken() public view returns (uint) {\r\n      return unitsPerToken;\r\n  }\r\n\r\n}"
    }
  }
}