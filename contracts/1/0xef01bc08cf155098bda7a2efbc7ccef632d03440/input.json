{
  "language": "Solidity",
  "settings": {
    "libraries": {
      "Strings.sol": {
        "Strings": "0xdbedc4ee481be454dc3ecd2f9b00e9315467a483"
      },
      "AbiDecoder.sol": {
        "AbiDecoder": "0x62627154d5ef4c3a2aa7fd1cadbd4425596ac74d"
      },
      "EnsHelper.sol": {
        "EnsHelper": "0x7d33110619e8f95f12a750f21a08b8c7cfb864e1"
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AbiDecoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\nimport \"./Strings.sol\";\n\nlibrary AbiDecoder {\n  /**\n   * @notice Extract all params from calldata given a list of param types and raw calldata bytes\n   */\n  function getParamsFromCalldata(\n    string[] memory paramTypes,\n    bytes calldata data\n  ) public pure returns (bytes[] memory) {\n    uint256 numberOfParams = paramTypes.length;\n    bytes[] memory results = new bytes[](numberOfParams);\n    for (uint256 paramIdx = 0; paramIdx < numberOfParams; paramIdx++) {\n      string memory paramType = paramTypes[paramIdx];\n      bytes memory param = getParamFromCalldata(data, paramType, paramIdx);\n      results[paramIdx] = param;\n    }\n    return results;\n  }\n\n  /**\n   * @notice Extract param bytes given calldata, param type and param index\n   */\n  function getParamFromCalldata(\n    bytes calldata data,\n    string memory paramType,\n    uint256 paramIdx\n  ) public pure returns (bytes memory) {\n    uint256 paramsStartIdx = 0x04; // Start after method selector\n    uint256 paramOffset = 0x20 * paramIdx;\n    bytes memory paramDescriptorValue = bytes(\n      data[paramsStartIdx + paramOffset:paramsStartIdx + paramOffset + 0x20]\n    );\n\n    bool paramTypeIsStringOrBytes = Strings.stringsEqual(paramType, \"bytes\") ||\n      Strings.stringsEqual(paramType, \"string\");\n    bool paramTypeIsStringArrayOrBytesArray = Strings.stringsEqual(\n      paramType,\n      \"bytes[]\"\n    ) || Strings.stringsEqual(paramType, \"string[]\");\n    bool _paramTypeIsArray = paramTypeIsArray(paramType);\n\n    uint256 paramStartIdx = uint256(bytes32(paramDescriptorValue)) + 0x04;\n    if (paramTypeIsStringOrBytes) {\n      return extractParamForBytesType(data, paramStartIdx);\n    } else if (paramTypeIsStringArrayOrBytesArray) {\n      return extractParamForBytesArrayType(data, paramStartIdx);\n    } else if (_paramTypeIsArray) {\n      return extractParamForSimpleArray(data, paramStartIdx);\n    } else {\n      return paramDescriptorValue;\n    }\n  }\n\n  /**\n   * @notice Extract param for \"bytes\" and \"string\" types given calldata and a param start index\n   */\n  function extractParamForBytesType(bytes calldata data, uint256 paramStartIdx)\n    public\n    pure\n    returns (bytes memory)\n  {\n    uint256 paramEndIdx = paramStartIdx + 0x20;\n    bytes32 bytesLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\n    uint256 bytesLength = uint256(bytesLengthBytes);\n    bytes memory dataToAdd = abi.encodePacked(\n      uint256(0x20),\n      bytes32(bytesLengthBytes)\n    );\n    uint256 numberOfRowsOfBytes = (bytesLength / 32) + 1;\n    for (uint256 rowIdx; rowIdx < numberOfRowsOfBytes; rowIdx++) {\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\n      dataToAdd = abi.encodePacked(\n        dataToAdd,\n        data[rowStartIdx:rowStartIdx + 0x20]\n      );\n    }\n    return dataToAdd;\n  }\n\n  /**\n   * @notice Extract param for \"bytes[]\" and \"string[]\" types given calldata and a param start index\n   */\n  function extractParamForBytesArrayType(\n    bytes calldata data,\n    uint256 paramStartIdx\n  ) public pure returns (bytes memory) {\n    uint256 paramEndIdx = paramStartIdx + 0x20;\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\n    uint256 arrayLength = uint256(arrayLengthBytes);\n    bytes memory dataToAdd = abi.encodePacked(\n      uint256(0x20),\n      bytes32(arrayLengthBytes)\n    );\n    uint256 lastOffsetStartIdx = paramEndIdx + (0x20 * arrayLength) - 0x20;\n    uint256 lastOffset = uint256(\n      bytes32(data[lastOffsetStartIdx:lastOffsetStartIdx + 0x20])\n    );\n    bytes32 lastElementBytesLengthBytes = bytes32(\n      data[paramEndIdx + lastOffset:paramEndIdx + lastOffset + 0x20]\n    );\n    uint256 lastElementBytesLength = uint256(lastElementBytesLengthBytes);\n    uint256 numberOfRowsOfBytesForLastElement = (lastElementBytesLength / 32) +\n      1;\n    uint256 dataEndIdx = paramEndIdx +\n      lastOffset +\n      0x20 +\n      (0x20 * numberOfRowsOfBytesForLastElement);\n    dataToAdd = abi.encodePacked(dataToAdd, data[paramEndIdx:dataEndIdx]);\n    return dataToAdd;\n  }\n\n  /**\n   * @notice Extract param for \"*[]\" types given calldata and a param start index, assuming each element is 32 bytes\n   */\n  function extractParamForSimpleArray(\n    bytes calldata data,\n    uint256 paramStartIdx\n  ) public pure returns (bytes memory) {\n    uint256 paramEndIdx = paramStartIdx + 0x20;\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\n    uint256 arrayLength = uint256(arrayLengthBytes);\n    bytes memory dataToAdd = abi.encodePacked(\n      uint256(0x20),\n      bytes32(arrayLengthBytes)\n    );\n    for (uint256 rowIdx; rowIdx < arrayLength; rowIdx++) {\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\n      dataToAdd = abi.encodePacked(\n        dataToAdd,\n        data[rowStartIdx:rowStartIdx + 0x20]\n      );\n    }\n    return dataToAdd;\n  }\n\n  /**\n   * @notice Check to see if the last two characters of a string are \"[]\"\n   */\n  function paramTypeIsArray(string memory paramType)\n    internal\n    pure\n    returns (bool)\n  {\n    bytes32 lastTwoCharacters;\n    assembly {\n      let len := mload(paramType)\n      lastTwoCharacters := mload(add(add(paramType, 0x20), sub(len, 2)))\n    }\n    return lastTwoCharacters == bytes32(bytes(\"[]\"));\n  }\n}\n"
    },
    "Allowlist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\nimport \"./Strings.sol\";\nimport \"./Introspection.sol\";\n\n/*******************************************************\n *                      Interfaces\n *******************************************************/\ninterface IAllowlistFactory {\n  function protocolOwnerAddressByOriginName(string memory originName)\n    external\n    view\n    returns (address ownerAddress);\n}\n\n/*******************************************************\n *                      Core Logic\n *******************************************************/\ncontract Allowlist {\n  /**\n   * methodName: Name of the method to validate (ie. \"approve\")\n   * paramTypes: Param types of the method to validate (ie. [\"address\", \"uint256\"])\n   * requirements: Array of requirements, where a requirement is as follows:\n   *    Element 0: Requirement type (ie. \"target\" or \"param\")\n   *    Element 1: Method name of validation method (ie. \"isVaultToken\")\n   *    Element 2: Index of param to test as a string. Only applicable where requirement type is \"param\" (ie. \"0\")\n   */\n  struct Condition {\n    string methodName;\n    string[] paramTypes;\n    string[][] requirements;\n    address implementationAddress;\n  }\n\n  Condition[] public conditions; // Array of conditions per protocol (managed by protocol owner)\n  string public protocolOriginName; // Domain name of protocol (ie. \"yearn.finance\")\n  address public rootAllowlistAddress; // Address of root allowlist (parent/factory)\n\n  /**\n   * Initialize the contract (this will only be called by proxy)\n   */\n  function initialize(string memory _protocolOriginName) public {\n    require(\n      rootAllowlistAddress == address(0),\n      \"Contract is already initialized\"\n    );\n    rootAllowlistAddress = msg.sender;\n    protocolOriginName = _protocolOriginName;\n  }\n\n  /*******************************************************\n   *                     Owner logic\n   *******************************************************/\n  modifier onlyOwner() {\n    require(\n      msg.sender == ownerAddress() || msg.sender == address(0),\n      \"Caller is not the protocol owner\"\n    );\n    _;\n  }\n\n  function ownerAddress() public view returns (address protcolOwnerAddress) {\n    protcolOwnerAddress = IAllowlistFactory(rootAllowlistAddress)\n      .protocolOwnerAddressByOriginName(protocolOriginName);\n  }\n\n  /*******************************************************\n   *                   Condition CRUD Logic\n   *******************************************************/\n  function addCondition(Condition memory condition) public onlyOwner {\n    validateCondition(condition);\n    conditions.push(condition);\n  }\n\n  function addConditions(Condition[] memory _conditions) public onlyOwner {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < _conditions.length;\n      conditionIdx++\n    ) {\n      Condition memory condition = _conditions[conditionIdx];\n      addCondition(condition);\n    }\n  }\n\n  function addConditionWithoutValidation(Condition memory condition)\n    public\n    onlyOwner\n  {\n    conditions.push(condition);\n  }\n\n  function addConditionsWithoutValidation(Condition[] memory _conditions)\n    public\n    onlyOwner\n  {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < _conditions.length;\n      conditionIdx++\n    ) {\n      Condition memory condition = _conditions[conditionIdx];\n      addCondition(condition);\n    }\n  }\n\n  function deleteCondition(uint256 conditionIdx) public onlyOwner {\n    Condition memory lastCondition = conditions[conditions.length - 1];\n    conditions[conditionIdx] = lastCondition;\n    conditions.pop();\n  }\n\n  function deleteAllConditions() public onlyOwner {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < conditions.length;\n      conditionIdx++\n    ) {\n      conditions.pop();\n    }\n  }\n\n  function updateCondition(uint256 conditionIdx, Condition memory condition)\n    public\n    onlyOwner\n  {\n    deleteCondition(conditionIdx);\n    addCondition(condition);\n  }\n\n  function conditionsList() public view returns (Condition[] memory test) {\n    Condition[] memory _conditions = new Condition[](conditions.length);\n    for (\n      uint256 conditionIdx;\n      conditionIdx < conditions.length;\n      conditionIdx++\n    ) {\n      _conditions[conditionIdx] = conditions[conditionIdx];\n    }\n    return _conditions;\n  }\n\n  function conditionsLength() public view returns (uint256) {\n    return conditions.length;\n  }\n\n  /*******************************************************\n   *                Condition Validation Logic\n   *******************************************************/\n  function validateCondition(Condition memory condition) public view {\n    string[][] memory requirements = condition.requirements;\n\n    for (\n      uint256 requirementIdx;\n      requirementIdx < requirements.length;\n      requirementIdx++\n    ) {\n      string[] memory requirement = requirements[requirementIdx];\n      string memory requirementType = requirement[0];\n      string memory requirementValidationMethod = requirement[1];\n      string memory methodSignature;\n      string memory paramType;\n      bool requirementTypeIsTarget = Strings.stringsEqual(\n        requirementType,\n        \"target\"\n      );\n      bool requirementTypeIsParam = Strings.stringsEqual(\n        requirementType,\n        \"param\"\n      );\n      if (requirementTypeIsTarget) {\n        require(\n          requirement.length == 2,\n          \"Requirement length must be equal to 2\"\n        );\n        methodSignature = string(\n          abi.encodePacked(requirementValidationMethod, \"(address)\")\n        );\n      } else if (requirementTypeIsParam) {\n        require(\n          requirement.length == 3,\n          \"Requirement length must be equal to 3\"\n        );\n        uint256 paramIdx = Strings.atoi(requirement[2], 10);\n        require(\n          paramIdx <= condition.paramTypes.length - 1,\n          \"Requirement parameter index is out of range\"\n        );\n        paramType = condition.paramTypes[paramIdx];\n        methodSignature = string(\n          abi.encodePacked(requirementValidationMethod, \"(\", paramType, \")\")\n        );\n      } else {\n        revert(\"Unsupported requirement type\");\n      }\n\n      address implementationAddress = condition.implementationAddress;\n      require(\n        implementationAddress != address(0),\n        \"Implementation address is not set\"\n      );\n\n      bool implementsInterface = Introspection.implementsMethodSignature(\n        implementationAddress,\n        methodSignature\n      );\n      require(\n        implementsInterface == true,\n        \"Implementation does not implement method selector\"\n      );\n    }\n  }\n\n  function validateConditions() public view {\n    for (\n      uint256 conditionIdx;\n      conditionIdx < conditions.length;\n      conditionIdx++\n    ) {\n      Condition memory condition = conditions[conditionIdx];\n      validateCondition(condition);\n    }\n  }\n\n  function implementationValid() public view returns (bool) {\n    (bool success, ) = address(this).staticcall(\n      abi.encodeWithSignature(\"validateConditions()\")\n    );\n    return success;\n  }\n}\n"
    },
    "AllowlistFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\nimport \"./Strings.sol\";\nimport \"./AbiDecoder.sol\";\nimport \"./EnsHelper.sol\";\nimport \"./Allowlist.sol\";\n\n/*******************************************************\n *                      Interfaces\n *******************************************************/\ninterface Registry {\n  function isRegistered(address) external view returns (bool);\n}\n\ninterface IAllowlist {\n  function implementationAddress() external view returns (address);\n\n  function conditionsLength() external view returns (uint256);\n\n  function initialize(string memory) external;\n\n  function conditionsList()\n    external\n    view\n    returns (Allowlist.Condition[] memory);\n\n  function implementationValid() external view returns (bool);\n}\n\n/*******************************************************\n *                     Main Contract Logic\n *******************************************************/\ncontract AllowlistFactory {\n  /**\n   * @notice Protocol registration\n   */\n  address private allowlistTemplateAddress;\n  string[] public registeredProtocols; // Array of all protocols which have successfully completed registration\n  mapping(string => bool) public registeredProtocol; // Determine whether or not a specific protocol is registered\n  mapping(string => address) public allowlistAddressByOriginName; // Address of protocol specific allowlist\n\n  constructor(address _allowlistTemplateAddress) {\n    allowlistTemplateAddress = _allowlistTemplateAddress;\n  }\n\n  /**\n   * @notice Determine protocol onwer address given an origin name\n   * @param originName is the domain name for a protocol (ie. \"yearn.finance\")\n   * @return ownerAddress Returns the address of the domain controller if the domain is registered on ENS\n   */\n  function protocolOwnerAddressByOriginName(string memory originName)\n    public\n    view\n    returns (address ownerAddress)\n  {\n    ownerAddress = EnsHelper.ownerAddressByName(originName);\n  }\n\n  /**\n   * @notice Begin protocol registration\n   * @param originName is the domain name for a protocol (ie. \"yearn.finance\")\n   * @dev Only valid protocol owners can begin registration\n   * @dev Beginning registration generates a smart contract each protocol can use\n   *      to manage their conditions and validation implementation logic\n   * @dev Only fully registered protocols appear on the registration list\n   */\n  function startProtocolRegistration(string memory originName) public {\n    address protocolOwnerAddress = protocolOwnerAddressByOriginName(originName);\n    if (protocolOwnerAddress != msg.sender) {\n      revert(\"Only protocol owners can register protocols\");\n    }\n\n    address allowlistAddress = cloneAllowlist();\n    IAllowlist(allowlistAddress).initialize(originName);\n    allowlistAddressByOriginName[originName] = allowlistAddress;\n  }\n\n  /**\n   * @notice Clones the allowlist using EIP-1167 template during new protocol registration\n   */\n  function cloneAllowlist() internal returns (address allowlistAddress) {\n    bytes20 templateAddress = bytes20(allowlistTemplateAddress);\n    assembly {\n      let clone := mload(0x40)\n      mstore(\n        clone,\n        0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n      )\n      mstore(add(clone, 0x14), templateAddress)\n      mstore(\n        add(clone, 0x28),\n        0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n      )\n      allowlistAddress := create(0, clone, 0x37)\n    }\n  }\n\n  /**\n   * @notice Finish protocol registration\n   * @param originName is the domain name for a protocol (ie. \"yearn.finance\")\n   * @dev In order to fully register a protocol the protocol must have a\n   *      valid implementation contract and at least one condition\n   * @dev Fully registered protocols are added to the registration list\n   */\n  function finishProtocolRegistration(string memory originName) public {\n    address allowListAddress = allowlistAddressByOriginName[originName];\n    IAllowlist allowList = IAllowlist(allowListAddress);\n\n    uint256 conditionsLength = allowList.conditionsLength();\n    if (conditionsLength == 0) {\n      revert(\"Must have at least one condition to complete registration\");\n    }\n\n    bool implementationValid = allowList.implementationValid();\n    if (!implementationValid) {\n      revert(\"Protocol implementation does not satisfy all conditions\");\n    }\n\n    registeredProtocols.push(originName);\n    registeredProtocol[originName] = true;\n  }\n\n  /**\n   * @notice Return a list of fully registered protocols\n   */\n  function registeredProtocolsList() public view returns (string[] memory) {\n    return registeredProtocols;\n  }\n\n  /**\n   * @notice Calculate a method signature given a condition\n   * @param condition The condition from which to generate the signature\n   * @return signature The method signature in string format (ie. \"approve(address,uint256)\")\n   */\n  function methodSignatureByCondition(Allowlist.Condition memory condition)\n    public\n    pure\n    returns (string memory signature)\n  {\n    bytes memory signatureBytes = abi.encodePacked(condition.methodName, \"(\");\n    for (uint256 paramIdx; paramIdx < condition.paramTypes.length; paramIdx++) {\n      signatureBytes = abi.encodePacked(\n        signatureBytes,\n        condition.paramTypes[paramIdx]\n      );\n      if (paramIdx + 1 < condition.paramTypes.length) {\n        signatureBytes = abi.encodePacked(signatureBytes, \",\");\n      }\n    }\n    signatureBytes = abi.encodePacked(signatureBytes, \")\");\n    signature = string(signatureBytes);\n  }\n\n  /**\n   * @notice Check target validity\n   * @param implementationAddress The address the validation method will be executed against\n   * @param targetAddress The target address to validate\n   * @param requirementValidationMethod The method to execute\n   * @return targetValid Returns true if the target is valid and false otherwise\n   * @dev If \"requirementValidationMethod\" is \"isValidVaultToken\" and target address is usdc\n   *      the validation check will look like this: usdc.isValidVaultToken(targetAddress),\n   *      where the result of the validation method is expected to return a bool\n   */\n  function checkTarget(\n    address implementationAddress,\n    address targetAddress,\n    string memory requirementValidationMethod\n  ) public view returns (bool targetValid) {\n    string memory methodSignature = string(\n      abi.encodePacked(requirementValidationMethod, \"(address)\")\n    );\n    (, bytes memory data) = address(implementationAddress).staticcall(\n      abi.encodeWithSignature(methodSignature, targetAddress)\n    );\n    targetValid = abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Check method selector validity\n   * @param data Raw input calldata (we will extract the 4-byte selector\n   *             from the beginning of the calldata)\n   * @param condition The condition struct to check (we generate the complete\n   *        method selector using condition.methodName and condition.paramTypes)\n   * @return methodSelectorValid Returns true if the method selector is valid and false otherwise\n   */\n  function checkMethodSelector(\n    bytes calldata data,\n    Allowlist.Condition memory condition\n  ) public pure returns (bool methodSelectorValid) {\n    string memory methodSignature = methodSignatureByCondition(condition);\n    bytes4 methodSelectorBySignature = bytes4(\n      keccak256(bytes(methodSignature))\n    );\n    bytes4 methodSelectorByCalldata = bytes4(data[0:4]);\n    methodSelectorValid = methodSelectorBySignature == methodSelectorByCalldata;\n  }\n\n  /**\n   * @notice Check an individual method param's validity\n   * @param implementationAddress The address the validation method will be executed against\n   * @param requirement The specific requirement (of type \"param\") to check (ie. [\"param\", \"isVault\", \"0\"])\n   * @dev A condition may have multiple requirements, all of which must be true\n   * @dev The middle element of a requirement is the requirement validation method\n   * @dev The last element of a requirement is the parameter index to validate against\n   * @param condition The entire condition struct to check the param against\n   * @param data Raw input calldata for the original method call\n   * @return Returns true if the param is valid, false if not\n   */\n  function checkParam(\n    address implementationAddress,\n    string[] memory requirement,\n    Allowlist.Condition memory condition,\n    bytes calldata data\n  ) public view returns (bool) {\n    uint256 paramIdx = Strings.atoi(requirement[2], 10);\n    string memory paramType = condition.paramTypes[paramIdx];\n    bytes memory paramCalldata = AbiDecoder.getParamFromCalldata(\n      data,\n      paramType,\n      paramIdx\n    );\n    string memory methodSignature = string(\n      abi.encodePacked(requirement[1], \"(\", paramType, \")\")\n    );\n    bytes memory encodedCalldata = abi.encodePacked(\n      bytes4(keccak256(bytes(methodSignature))),\n      paramCalldata\n    );\n    bool success;\n    bytes memory resultData;\n    (success, resultData) = address(implementationAddress).staticcall(\n      encodedCalldata\n    );\n    if (success) {\n      return abi.decode(resultData, (bool));\n    }\n    return false;\n  }\n\n  /**\n   * @notice Test a target address and calldata against a specific condition and implementation\n   * @param condition The condition to test\n   * @param targetAddress Target address of the original method call\n   * @param data Calldata of the original methodcall\n   * @return Returns true if the condition passes and false if not\n   * @dev The condition check is comprised of 3 parts:\n          - Method selector check (to make sure the calldata method selector matches the condition method selector)\n          - Target check (to make sure the target is valid)\n          - Param check (to make sure the specified param is valid)\n   */\n  function testCondition(\n    Allowlist.Condition memory condition,\n    address targetAddress,\n    bytes calldata data\n  ) public view returns (bool) {\n    string[][] memory requirements = condition.requirements;\n    address implementationAddress = condition.implementationAddress;\n    for (\n      uint256 requirementIdx;\n      requirementIdx < requirements.length;\n      requirementIdx++\n    ) {\n      string[] memory requirement = requirements[requirementIdx];\n      string memory requirementType = requirement[0];\n      string memory requirementValidationMethod = requirement[1];\n      if (!checkMethodSelector(data, condition)) {\n        return false;\n      }\n      if (Strings.stringsEqual(requirementType, \"target\")) {\n        bool targetValid = checkTarget(\n          implementationAddress,\n          targetAddress,\n          requirementValidationMethod\n        );\n        if (!targetValid) {\n          return false;\n        }\n      } else if (Strings.stringsEqual(requirementType, \"param\")) {\n        bool paramValid = checkParam(\n          implementationAddress,\n          requirement,\n          condition,\n          data\n        );\n        if (!paramValid) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @notice Test target address and calldata against all stored protocol conditions\n   * @dev This is done to determine whether or not the target address and calldata are valid and whitelisted\n   * @dev This is the primary method that should be called by integrators\n   * @return Returns true if the check is successful and false if not\n   */\n  function validateCalldata(\n    string memory originName,\n    address targetAddress,\n    bytes calldata data\n  ) public view returns (bool) {\n    Allowlist.Condition[] memory _conditions = conditionsByOriginName(\n      originName\n    );\n    for (\n      uint256 conditionIdx;\n      conditionIdx < _conditions.length;\n      conditionIdx++\n    ) {\n      Allowlist.Condition memory condition = _conditions[conditionIdx];\n      bool conditionPassed = testCondition(condition, targetAddress, data);\n      if (conditionPassed) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @notice Fetch a list of conditions given a protocol origin name\n   * @param originName is the domain name for a protocol (ie. \"yearn.finance\")\n   * @return Returns an array of conditions\n   */\n  function conditionsByOriginName(string memory originName)\n    public\n    view\n    returns (Allowlist.Condition[] memory)\n  {\n    address allowlistAddress = allowlistAddressByOriginName[originName];\n    Allowlist.Condition[] memory _conditions = IAllowlist(allowlistAddress)\n      .conditionsList();\n    return _conditions;\n  }\n}\n"
    },
    "EnsHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface IEnsRegistry {\n  function resolver(bytes32 node) external view returns (address);\n\n  function owner(bytes32 node) external view returns (address);\n}\n\ninterface IEnsResolver {\n  function addr(bytes32 node) external view returns (address);\n}\n\ninterface IStringSplit {\n  function splitStringByDeliminator(\n    string memory input,\n    string memory deliminator\n  ) external view returns (string[] memory);\n}\n\nlibrary EnsHelper {\n  address public constant registryAddress =\n    0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;\n  address private constant splitStringAddress =\n    0x1C0EeEF670d82498F7547062Aac7eE2143eC52ff;\n\n  function resolvedAddressByNamehash(bytes32 namehash)\n    public\n    view\n    returns (address resolvedAddress)\n  {\n    address resolverAddress = resolverAddressByNamehash(namehash);\n    resolvedAddress = IEnsResolver(resolverAddress).addr(namehash);\n  }\n\n  function resolvedAddressByName(string memory name)\n    public\n    view\n    returns (address resolvedAddress)\n  {\n    bytes32 namehash = namehashByName(name);\n    resolvedAddress = resolvedAddressByNamehash(namehash);\n  }\n\n  function resolverAddressByNamehash(bytes32 namehash)\n    public\n    view\n    returns (address resolverAddress)\n  {\n    resolverAddress = IEnsRegistry(registryAddress).resolver(namehash);\n  }\n\n  function resolverAddressByName(string memory name)\n    public\n    view\n    returns (address resolverAddress)\n  {\n    bytes32 namehash = namehashByName(name);\n    resolverAddress = resolverAddressByNamehash(namehash);\n  }\n\n  function namehashByName(string memory name)\n    public\n    view\n    returns (bytes32 namehash)\n  {\n    string[] memory parts = IStringSplit(splitStringAddress)\n      .splitStringByDeliminator(name, \".\");\n    for (uint256 partIdx = parts.length - 1; partIdx >= 0; partIdx--) {\n      string memory part = parts[partIdx];\n      namehash = keccak256(\n        abi.encodePacked(namehash, keccak256(abi.encodePacked(bytes(part))))\n      );\n      if (partIdx == 0) {\n        break;\n      }\n    }\n  }\n\n  function ownerAddressByNamehash(bytes32 namehash)\n    public\n    view\n    returns (address ownerAddress)\n  {\n    ownerAddress = IEnsRegistry(registryAddress).owner(namehash);\n  }\n\n  function ownerAddressByName(string memory name)\n    public\n    view\n    returns (address ownerAddress)\n  {\n    bytes32 namehash = namehashByName(name);\n    ownerAddress = IEnsRegistry(registryAddress).owner(namehash);\n  }\n}\n"
    },
    "Introspection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary Introspection {\n  // function implementsMethodNameAndParamTypes(string memory methodName, string[])\n  function implementsMethodSignature(address _address, string memory _signature)\n    public\n    view\n    returns (bool)\n  {\n    bytes4 _selector = bytes4(keccak256(bytes(_signature)));\n    uint256 contractSize;\n    assembly {\n      contractSize := extcodesize(_address)\n    }\n    bytes memory code = new bytes(contractSize);\n    assembly {\n      extcodecopy(_address, add(code, 0x20), 0, contractSize)\n    }\n    uint256 ptr = 0;\n    while (ptr < contractSize) {\n      // PUSH4 0x000000 (selector)\n      if (code[ptr] == 0x63) {\n        bytes memory selectorBytes = new bytes(64);\n        selectorBytes[0] = code[ptr + 1];\n        selectorBytes[1] = code[ptr + 2];\n        selectorBytes[2] = code[ptr + 3];\n        selectorBytes[3] = code[ptr + 4];\n        bytes4 selector = abi.decode(selectorBytes, (bytes4));\n        if (selector == _selector) {\n          return true;\n        }\n      }\n      ptr++;\n    }\n    return false;\n  }\n\n  function implementsInterface(address _address, string[] memory _interface)\n    public\n    view\n    returns (bool)\n  {\n    for (uint256 methodIdx = 0; methodIdx < _interface.length; methodIdx++) {\n      string memory method = _interface[methodIdx];\n      bool methodIsImplemented = implementsMethodSignature(_address, method);\n      if (!methodIsImplemented) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"
    },
    "Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary Strings {\n  /**\n   * @notice Search for a needle in a haystack\n   * @param haystack The string to search\n   * @param needle The string to search for\n   */\n  function stringStartsWith(string memory haystack, string memory needle)\n    public\n    pure\n    returns (bool)\n  {\n    return indexOfStringInString(needle, haystack) == 0;\n  }\n\n  /**\n   * @notice Case insensitive string search\n   * @param needle The string to search for\n   * @param haystack The string to search\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\n   */\n  function indexOfStringInString(string memory needle, string memory haystack)\n    public\n    pure\n    returns (int256)\n  {\n    bytes memory _needle = bytes(needle);\n    bytes memory _haystack = bytes(haystack);\n    if (_haystack.length < _needle.length) {\n      return -1;\n    }\n    bool _match;\n    for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\n      for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\n        uint8 needleChar = uint8(_needle[needleIdx]);\n        if (haystackIdx + needleIdx >= _haystack.length) {\n          return -1;\n        }\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\n        if (needleChar == haystackChar) {\n          _match = true;\n          if (needleIdx == _needle.length - 1) {\n            return int256(haystackIdx);\n          }\n        } else {\n          _match = false;\n          break;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * @notice Check to see if two strings are exactly equal\n   */\n  function stringsEqual(string memory input1, string memory input2)\n    public\n    pure\n    returns (bool)\n  {\n    uint256 input1Length = bytes(input1).length;\n    uint256 input2Length = bytes(input2).length;\n    uint256 maxLength;\n    if (input1Length > input2Length) {\n      maxLength = input1Length;\n    } else {\n      maxLength = input2Length;\n    }\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\n    bytes32 input1Bytes32;\n    bytes32 input2Bytes32;\n    for (uint256 rowIdx; rowIdx < numberOfRowsToCompare; rowIdx++) {\n      uint256 offset = 0x20 * (rowIdx + 1);\n      assembly {\n        input1Bytes32 := mload(add(input1, offset))\n        input2Bytes32 := mload(add(input2, offset))\n      }\n      if (input1Bytes32 != input2Bytes32) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function atoi(string memory a, uint8 base) public pure returns (uint256 i) {\n    require(base == 2 || base == 8 || base == 10 || base == 16);\n    bytes memory buf = bytes(a);\n    for (uint256 p = 0; p < buf.length; p++) {\n      uint8 digit = uint8(buf[p]) - 0x30;\n      if (digit > 10) {\n        digit -= 7;\n      }\n      require(digit < base);\n      i *= base;\n      i += digit;\n    }\n    return i;\n  }\n\n  function itoa(uint256 i, uint8 base) public pure returns (string memory a) {\n    require(base == 2 || base == 8 || base == 10 || base == 16);\n    if (i == 0) {\n      return \"0\";\n    }\n    bytes memory buf = new bytes(256);\n    uint256 p = 0;\n    while (i > 0) {\n      uint8 digit = uint8(i % base);\n      uint8 ascii = digit + 0x30;\n      if (digit > 9) {\n        ascii += 7;\n      }\n      buf[p++] = bytes1(ascii);\n      i /= base;\n    }\n    uint256 length = p;\n    for (p = 0; p < length / 2; p++) {\n      buf[p] ^= buf[length - 1 - p];\n      buf[length - 1 - p] ^= buf[p];\n      buf[p] ^= buf[length - 1 - p];\n    }\n    return string(buf);\n  }\n}\n"
    }
  }
}