{
  "language": "Solidity",
  "sources": {
    "DebtLocker.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity =0.8.7;\n\ninterface IAuctioneerLike {\n\n    function getExpectedAmount(uint256 swapAmount_) external view returns (uint256 expectedAmount_);\n\n}\n\ninterface IERC20Like {\n\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\n\n    function balanceOf(address account_) external view returns (uint256 balanceOf_);\n\n    function decimals() external view returns (uint8 decimals_);\n\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\n\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_);\n\n}\n\ninterface IMapleGlobalsLike {\n\n   function getLatestPrice(address asset_) external view returns (uint256 price_);\n\n   function protocolPaused() external view returns (bool protocolPaused_);\n\n}\n\ninterface IMapleLoanLike {\n\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;\n\n    function claimableFunds() external view returns (uint256 claimableFunds_);\n\n    function collateralAsset() external view returns (address collateralAsset_);\n\n    function fundsAsset() external view returns (address fundsAsset_);\n\n    function principal() external view returns (uint256 principal_);\n\n    function claimFunds(uint256 amount_, address destination_) external;\n\n    function repossess(address destination_) external returns (uint256 collateralAssetAmount_, uint256 fundsAssetAmount_);\n\n}\n\ninterface IMapleProxyFactoryLike {\n\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) external;\n\n}\n\ninterface IPoolFactoryLike {\n\n    function globals() external pure returns (address globals_);\n\n}\n\ninterface IPoolLike {\n\n    function poolDelegate() external view returns (address poolDelegate_);\n\n    function superFactory() external view returns (address superFactory_);\n\n}\n\n/// @title Small Library to standardize erc20 token interactions.\nlibrary ERC20Helper {\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function transfer(address token_, address to_, uint256 amount_) internal returns (bool success_) {\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\n    }\n\n    function transferFrom(address token_, address from_, address to_, uint256 amount_) internal returns (bool success_) {\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\n    }\n\n    function approve(address token_, address spender_, uint256 amount_) internal returns (bool success_) {\n        // If setting approval to zero fails, return false.\n        if (!_call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, uint256(0)))) return false;\n\n        // If `amount_` is zero, return true as the previous step already did this.\n        if (amount_ == uint256(0)) return true;\n\n        // Return the result of setting the approval to `amount_`.\n        return _call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, amount_));\n    }\n\n    function _call(address token_, bytes memory data_) private returns (bool success_) {\n        if (token_.code.length == uint256(0)) return false;\n\n        bytes memory returnData;\n        ( success_, returnData ) = token_.call(data_);\n\n        return success_ && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n}\n\ninterface ILiquidator {\n\n    /**\n     * @dev   Auctioneer was set.\n     * @param auctioneer_ Address of the auctioneer.\n     */\n    event AuctioneerSet(address auctioneer_);\n\n    /**\n     * @dev   Funds were withdrawn from the liquidator.\n     * @param token_       Address of the token that was withdrawn.\n     * @param destination_ Address of where tokens were sent.\n     * @param amount_      Amount of tokens that were sent.\n     */\n    event FundsPulled(address token_, address destination_, uint256 amount_);\n\n    /**\n     * @dev   Portion of collateral was liquidated.\n     * @param swapAmount_     Amount of collateralAsset that was liquidated.\n     * @param returnedAmount_ Amount of fundsAsset that was returned.\n     */\n    event PortionLiquidated(uint256 swapAmount_, uint256 returnedAmount_);\n\n    /**\n     * @dev Getter function that returns `collateralAsset`.\n     */\n    function collateralAsset() external view returns (address collateralAsset_);\n\n    /**\n     * @dev Getter function that returns `destination` - address that liquidated funds are sent to.\n     */\n    function destination() external view returns (address destination_);\n\n    /**\n     * @dev Getter function that returns `auctioneer`.\n     */\n    function auctioneer() external view returns (address auctioneer_);\n\n    /**\n     * @dev Getter function that returns `fundsAsset`.\n     */\n    function fundsAsset() external view returns (address fundsAsset_);\n\n    /**\n     * @dev Getter function that returns `globals`.\n     */\n    function globals() external view returns (address);\n\n    /**\n     * @dev Getter function that returns `owner`.\n     */\n    function owner() external view returns (address owner_);\n\n    /**\n     * @dev   Set the auctioneer contract address, which is used to pull the `getExpectedAmount`.\n     *        Can only be set by `owner`.\n     * @param auctioneer_ The auctioneer contract address.\n     */\n    function setAuctioneer(address auctioneer_) external;\n\n    /**\n     * @dev   Pulls a specified amount of ERC-20 tokens from the contract.\n     *        Can only be called by `owner`.\n     * @param token_       The ERC-20 token contract address.\n     * @param destination_ The destination of the transfer.\n     * @param amount_      The amount to transfer.\n     */\n    function pullFunds(address token_, address destination_, uint256 amount_) external;\n\n    /**\n     * @dev    Returns the expected amount to be returned from a flash loan given a certain amount of `collateralAsset`.\n     * @param  swapAmount_     Amount of `collateralAsset` to be flash-borrowed.\n     * @return expectedAmount_ Amount of `fundsAsset` that must be returned in the same transaction.\n     */\n    function getExpectedAmount(uint256 swapAmount_) external returns (uint256 expectedAmount_);\n\n    /**\n     * @dev   Flash loan function that:\n     *        1. Transfers a specified amount of `collateralAsset` to `msg.sender`.\n     *        2. Performs an arbitrary call to `msg.sender`, to trigger logic necessary to get `fundsAsset` (e.g., AMM swap).\n     *        3. Performs a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user.\n     *        If the required amount of `fundsAsset` is not returned in step 3, the entire transaction reverts.\n     * @param swapAmount_      Amount of `collateralAsset` that is to be borrowed in the flash loan.\n     * @param maxReturnAmount_ Max amount of `fundsAsset` that can be returned to the liquidator contract.\n     * @param data_            ABI-encoded arguments to be used in the low-level call to perform step 2.\n     */\n    function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external;\n\n}\n\ncontract Liquidator is ILiquidator {\n\n    uint256 private constant NOT_LOCKED = uint256(0);\n    uint256 private constant LOCKED     = uint256(1);\n\n    uint256 internal _locked;\n\n    address public override immutable collateralAsset;\n    address public override immutable destination;\n    address public override immutable fundsAsset;\n    address public override immutable globals;\n    address public override immutable owner;\n\n    address public override auctioneer;\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    modifier whenProtocolNotPaused() {\n        require(!IMapleGlobalsLike(globals).protocolPaused(), \"LIQ:PROTOCOL_PAUSED\");\n        _;\n    }\n\n    modifier lock() {\n        require(_locked == NOT_LOCKED, \"LIQ:LOCKED\");\n        _locked = LOCKED;\n        _;\n        _locked = NOT_LOCKED;\n    }\n\n    /**\n     * @param owner_           The address of an account that will have administrative privileges on this contract.\n     * @param collateralAsset_ The address of the collateral asset being liquidated.\n     * @param fundsAsset_      The address of the funds asset.\n     * @param auctioneer_      The address of an Auctioneer.\n     * @param destination_     The address to send funds asset after liquidation.\n     * @param globals_         The address of a Maple Globals contract.\n     */\n    constructor(address owner_, address collateralAsset_, address fundsAsset_, address auctioneer_, address destination_, address globals_) {\n        require((owner           = owner_)           != address(0), \"LIQ:C:INVALID_OWNER\");\n        require((collateralAsset = collateralAsset_) != address(0), \"LIQ:C:INVALID_COL_ASSET\");\n        require((fundsAsset      = fundsAsset_)      != address(0), \"LIQ:C:INVALID_FUNDS_ASSET\");\n        require((destination     = destination_)     != address(0), \"LIQ:C:INVALID_DEST\");\n\n        require(!IMapleGlobalsLike(globals = globals_).protocolPaused(), \"LIQ:C:INVALID_GLOBALS\");\n\n        // NOTE: Auctioneer of zero is valid, since it is starting the contract off in a paused state.\n        auctioneer = auctioneer_;\n    }\n\n    function setAuctioneer(address auctioneer_) external override {\n        require(msg.sender == owner, \"LIQ:SA:NOT_OWNER\");\n\n        emit AuctioneerSet(auctioneer = auctioneer_);\n    }\n\n    function pullFunds(address token_, address destination_, uint256 amount_) external override {\n        require(msg.sender == owner, \"LIQ:PF:NOT_OWNER\");\n\n        emit FundsPulled(token_, destination_, amount_);\n\n        require(ERC20Helper.transfer(token_, destination_, amount_), \"LIQ:PF:TRANSFER\");\n    }\n\n    function getExpectedAmount(uint256 swapAmount_) public view override returns (uint256 expectedAmount_) {\n        return IAuctioneerLike(auctioneer).getExpectedAmount(swapAmount_);\n    }\n\n    function liquidatePortion(uint256 collateralAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override whenProtocolNotPaused lock {\n        // Transfer a requested amount of collateralAsset to the borrwer.\n        require(ERC20Helper.transfer(collateralAsset, msg.sender, collateralAmount_), \"LIQ:LP:TRANSFER\");\n\n        // Perform a low-level call to msg.sender, allowing a swap strategy to be executed with the transferred collateral.\n        msg.sender.call(data_);\n\n        // Calculate the amount of fundsAsset required based on the amount of collateralAsset borrowed.\n        uint256 returnAmount = getExpectedAmount(collateralAmount_);\n        require(returnAmount <= maxReturnAmount_, \"LIQ:LP:MAX_RETURN_EXCEEDED\");\n\n        emit PortionLiquidated(collateralAmount_, returnAmount);\n\n        // Pull required amount of fundsAsset from the borrower, if this amount of funds cannot be recovered atomically, revert.\n        require(ERC20Helper.transferFrom(fundsAsset, msg.sender, destination, returnAmount), \"LIQ:LP:TRANSFER_FROM\");\n    }\n\n}\n\n/// @title An implementation that is to be proxied, must implement IProxied.\ninterface IProxied {\n\n    /**\n     *  @dev The address of the proxy factory.\n     */\n    function factory() external view returns (address factory_);\n\n    /**\n     *  @dev The address of the implementation contract being proxied.\n     */\n    function implementation() external view returns (address implementation_);\n\n    /**\n     *  @dev   Modifies the proxy's implementation address.\n     *  @param newImplementation_ The address of an implementation contract.\n     */\n    function setImplementation(address newImplementation_) external;\n\n    /**\n     *  @dev   Modifies the proxy's storage by delegate-calling a migrator contract with some arguments.\n     *         Access control logic critical since caller can force a selfdestruct via a malicious `migrator_` which is delegatecalled.\n     *  @param migrator_  The address of a migrator contract.\n     *  @param arguments_ Some encoded arguments to use for the migration.\n     */\n    function migrate(address migrator_, bytes calldata arguments_) external;\n\n}\n\n/// @title A Maple implementation that is to be proxied, must implement IMapleProxied.\ninterface IMapleProxied is IProxied {\n\n    /**\n     *  @dev   The instance was upgraded.\n     *  @param toVersion_ The new version of the loan.\n     *  @param arguments_ The upgrade arguments, if any.\n     */\n    event Upgraded(uint256 toVersion_, bytes arguments_);\n\n    /**\n     *  @dev   Upgrades a contract implementation to a specific version.\n     *         Access control logic critical since caller can force a selfdestruct via a malicious `migrator_` which is delegatecalled.\n     *  @param toVersion_ The version to upgrade to.\n     *  @param arguments_ Some encoded arguments to use for the upgrade.\n     */\n    function upgrade(uint256 toVersion_, bytes calldata arguments_) external;\n\n}\n\n/// @title DebtLocker interacts with Loans on behalf of PoolV1.\ninterface IDebtLocker is IMapleProxied {\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    /**\n     * @dev   Emitted when `setAllowedSlippage` is called.\n     * @param newSlippage_ New value for `allowedSlippage`.\n     */\n    event AllowedSlippageSet(uint256 newSlippage_);\n\n    /**\n     * @dev   Emitted when `setAuctioneer` is called.\n     * @param newAuctioneer_ New value for `auctioneer` in Liquidator.\n     */\n    event AuctioneerSet(address newAuctioneer_);\n\n    /**\n     * @dev   Emitted when `fundsToCapture` is set.\n     * @param amount_ The amount of funds that will be captured next claim.\n     */\n    event FundsToCaptureSet(uint256 amount_);\n\n    /**\n     * @dev Emitted when `stopLiquidation` is called.\n     */\n    event LiquidationStopped();\n\n    /**\n     * @dev   Emitted when `setMinRatio` is called.\n     * @param newMinRatio_ New value for `minRatio`.\n     */\n    event MinRatioSet(uint256 newMinRatio_);\n\n    /*****************/\n    /*** Functions ***/\n    /*****************/\n\n    /**\n     * @dev   Accept the new loan terms and trigger a refinance.\n     * @param refinancer_ The address of the refinancer contract.\n     * @param calls_      The array of encoded data that are to be executed as delegatecalls by the refinancer.\n     * @param amount_     The amount of `fundsAsset` that is to be sent to the Loan as part of the transaction.\n     */\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;\n\n    /**\n     *  @dev    Claims funds to send to Pool. Handles funds from payments and liquidations.\n     *          Only the Pool can call this function.\n     *  @return details_\n     *              [0] => Total Claimed.\n     *              [1] => Interest Claimed.\n     *              [2] => Principal Claimed.\n     *              [3] => Pool Delegate Fees Claimed.\n     *              [4] => Excess Returned Claimed.\n     *              [5] => Amount Recovered (from Liquidation).\n     *              [6] => Default Suffered.\n     */\n    function claim() external returns (uint256[7] memory details_);\n\n    /**\n     * @dev   Allows the poolDelegate to pull some funds from liquidator contract.\n     * @param liquidator_  The liquidator to which pull funds from.\n     * @param token_       The token address of the funds.\n     * @param destination_ The destination address of captured funds.\n     * @param amount_      The amount to pull.\n     */\n    function pullFundsFromLiquidator(address liquidator_, address token_, address destination_, uint256 amount_) external;\n\n    /**\n     * @dev Returns the address of the Pool Delegate that has control of the DebtLocker.\n     */\n    function poolDelegate() external view returns (address poolDelegate_);\n\n    /**\n     * @dev Repossesses funds and collateral from a loan and transfers them to the Liquidator.\n     */\n    function triggerDefault() external;\n\n    /**\n     * @dev   Sets the allowed slippage for auctioneer (used to determine expected amount to be returned in flash loan).\n     * @param allowedSlippage_ Basis points representation of allowed percent slippage from market price.\n     */\n    function setAllowedSlippage(uint256 allowedSlippage_) external;\n\n    /**\n     * @dev   Sets the auctioneer contract for the liquidator.\n     * @param auctioneer_ Address of auctioneer contract.\n     */\n    function setAuctioneer(address auctioneer_) external;\n\n    /**\n     * @dev   Sets the minimum \"price\" for auctioneer (used to determine expected amount to be returned in flash loan).\n     * @param minRatio_ Price in fundsAsset precision (e.g., 10 * 10 ** 6 for $10 price for USDC).\n     */\n    function setMinRatio(uint256 minRatio_) external;\n\n    /**\n     * @dev    Returns the expected amount to be returned to the liquidator during a flash borrower liquidation.\n     * @param  swapAmount_   Amount of collateralAsset being swapped.\n     * @return returnAmount_ Amount of fundsAsset that must be returned in the same transaction.\n     */\n    function getExpectedAmount(uint256 swapAmount_) external view returns (uint256 returnAmount_);\n\n    /**\n     * @dev   Returns the expected amount to be returned to the liquidator during a flash borrower liquidation.\n     * @param amount_ The amount of funds that should be captured next claim.\n     */\n    function setFundsToCapture(uint256 amount_) external;\n\n    /**\n     * @dev Called by the PoolDelegate in case of a DoS, where a user transfers small amounts of collateralAsset into the Liquidator\n     *      to make `_isLiquidationActive` remain true.\n     *      CALLING THIS MAY RESULT IN RECOGNIZED LOSSES IN POOL ACCOUNTING. CONSULT MAPLE TEAM FOR GUIDANCE.\n     */\n    function stopLiquidation() external;\n\n    /*************/\n    /*** State ***/\n    /*************/\n\n    /**\n     * @dev The Loan contract this locker is holding tokens for.\n     */\n    function loan() external view returns (address loan_);\n\n    /**\n     * @dev The address of the liquidator.\n     */\n    function liquidator() external view returns (address liquidator_);\n\n    /**\n     * @dev The owner of this Locker (the Pool).\n     */\n    function pool() external view returns (address pool_);\n\n    /**\n     * @dev The maximum slippage allowed during liquidations.\n     */\n    function allowedSlippage() external view returns (uint256 allowedSlippage_);\n\n    /**\n     * @dev The amount in funds asset recovered during liquidations.\n     */\n    function amountRecovered() external view returns (uint256 amountRecovered_);\n\n    /**\n     * @dev The minimum exchange ration between funds asset and collateral asset.\n     */\n    function minRatio() external view returns (uint256 minRatio_);\n\n    /**\n     * @dev Returns the principal that was present at the time of last claim.\n     */\n    function principalRemainingAtLastClaim() external view returns (uint256 principalRemainingAtLastClaim_);\n\n    /**\n     * @dev Returns if the funds have been repossessed.\n     */\n    function repossessed() external view returns (bool repossessed_);\n\n    /**\n     * @dev Returns the amount of funds that will be captured next claim.\n     */\n    function fundsToCapture() external view returns (uint256 fundsToCapture_);\n\n}\n\n/// @title DebtLockerStorage maps the storage layout of a DebtLocker.\ncontract DebtLockerStorage {\n\n    address internal _liquidator;\n    address internal _loan;\n    address internal _pool;\n\n    bool internal _repossessed;\n\n    uint256 internal _allowedSlippage;\n    uint256 internal _amountRecovered;\n    uint256 internal _fundsToCapture;\n    uint256 internal _minRatio;\n    uint256 internal _principalRemainingAtLastClaim;\n\n}\n\nabstract contract SlotManipulatable {\n\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\n        return keccak256(abi.encodePacked(key_, slot_));\n    }\n\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\n        assembly {\n            value_ := sload(slot_)\n        }\n    }\n\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\n        assembly {\n            sstore(slot_, value_)\n        }\n    }\n\n}\n\n/// @title An implementation that is to be proxied, will need ProxiedInternals.\nabstract contract ProxiedInternals is SlotManipulatable {\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    /// @dev Delegatecalls to a migrator contract to manipulate storage during an initialization or migration.\n    function _migrate(address migrator_, bytes calldata arguments_) internal virtual returns (bool success_) {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(migrator_)\n        }\n\n        if (size == uint256(0)) return false;\n\n        ( success_, ) = migrator_.delegatecall(arguments_);\n    }\n\n    /// @dev Sets the factory address in storage.\n    function _setFactory(address factory_) internal virtual returns (bool success_) {\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\n        return true;\n    }\n\n    /// @dev Sets the implementation address in storage.\n    function _setImplementation(address implementation_) internal virtual returns (bool success_) {\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation_))));\n        return true;\n    }\n\n    /// @dev Returns the factory address.\n    function _factory() internal view virtual returns (address factory_) {\n        return address(uint160(uint256(_getSlotValue(FACTORY_SLOT))));\n    }\n\n    /// @dev Returns the implementation address.\n    function _implementation() internal view virtual returns (address implementation_) {\n        return address(uint160(uint256(_getSlotValue(IMPLEMENTATION_SLOT))));\n    }\n\n}\n\n/// @title A Maple implementation that is to be proxied, will need MapleProxiedInternals.\nabstract contract MapleProxiedInternals is ProxiedInternals {}\n\n/// @title DebtLocker interacts with Loans on behalf of PoolV1.\ncontract DebtLocker is IDebtLocker, DebtLockerStorage, MapleProxiedInternals {\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    modifier whenProtocolNotPaused() {\n        require(!IMapleGlobalsLike(_getGlobals()).protocolPaused(), \"DL:PROTOCOL_PAUSED\");\n        _;\n    }\n\n    /********************************/\n    /*** Administrative Functions ***/\n    /********************************/\n\n    function migrate(address migrator_, bytes calldata arguments_) external override {\n        require(msg.sender == _factory(),        \"DL:M:NOT_FACTORY\");\n        require(_migrate(migrator_, arguments_), \"DL:M:FAILED\");\n    }\n\n    function setImplementation(address newImplementation_) external override {\n        require(msg.sender == _factory(),               \"DL:SI:NOT_FACTORY\");\n        require(_setImplementation(newImplementation_), \"DL:SI:FAILED\");\n    }\n\n    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {\n        require(msg.sender == _getPoolDelegate(), \"DL:U:NOT_POOL_DELEGATE\");\n\n        emit Upgraded(toVersion_, arguments_);\n\n        IMapleProxyFactoryLike(_factory()).upgradeInstance(toVersion_, arguments_);\n    }\n\n    /*******************************/\n    /*** Pool Delegate Functions ***/\n    /*******************************/\n\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {\n        require(msg.sender == _getPoolDelegate(), \"DL:ANT:NOT_PD\");\n\n        address loanAddress = _loan;\n\n        require(\n            (IMapleLoanLike(loanAddress).claimableFunds() + _fundsToCapture == uint256(0)) &&\n            (IMapleLoanLike(loanAddress).principal() == _principalRemainingAtLastClaim),\n            \"DL:ANT:NEED_TO_CLAIM\"\n        );\n\n        require(\n            amount_ == uint256(0) || ERC20Helper.transfer(IMapleLoanLike(loanAddress).fundsAsset(), loanAddress, amount_),\n            \"DL:ANT:TRANSFER_FAILED\"\n        );\n\n        IMapleLoanLike(loanAddress).acceptNewTerms(refinancer_, calls_, uint256(0));\n\n        // NOTE: This must be set after accepting the new terms, which affects the loan principal.\n        _principalRemainingAtLastClaim = IMapleLoanLike(loanAddress).principal();\n    }\n\n    function claim() external override whenProtocolNotPaused returns (uint256[7] memory details_) {\n        require(msg.sender == _pool, \"DL:C:NOT_POOL\");\n\n        return _repossessed ? _handleClaimOfRepossessed(msg.sender, _loan) : _handleClaim(msg.sender, _loan);\n    }\n\n    function pullFundsFromLiquidator(address liquidator_, address token_, address destination_, uint256 amount_) external override {\n        require(msg.sender == _getPoolDelegate(), \"DL:SA:NOT_PD\");\n\n        Liquidator(liquidator_).pullFunds(token_, destination_, amount_);\n    }\n\n    function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {\n        require(msg.sender == _getPoolDelegate(),    \"DL:SAS:NOT_PD\");\n        require(allowedSlippage_ <= uint256(10_000), \"DL:SAS:INVALID_SLIPPAGE\");\n\n        emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);\n    }\n\n    function setAuctioneer(address auctioneer_) external override whenProtocolNotPaused {\n        require(msg.sender == _getPoolDelegate(), \"DL:SA:NOT_PD\");\n\n        emit AuctioneerSet(auctioneer_);\n\n        Liquidator(_liquidator).setAuctioneer(auctioneer_);\n    }\n\n    function setFundsToCapture(uint256 amount_) override external whenProtocolNotPaused {\n        require(msg.sender == _getPoolDelegate(), \"DL:SFTC:NOT_PD\");\n\n        emit FundsToCaptureSet(_fundsToCapture = amount_);\n    }\n\n    function setMinRatio(uint256 minRatio_) external override whenProtocolNotPaused {\n        require(msg.sender == _getPoolDelegate(), \"DL:SMR:NOT_PD\");\n\n        emit MinRatioSet(_minRatio = minRatio_);\n    }\n\n    // Pool delegate can prematurely stop liquidation when there's still significant amount to be liquidated.\n    function stopLiquidation() external override {\n        require(msg.sender == _getPoolDelegate(), \"DL:SL:NOT_PD\");\n\n        _liquidator = address(0);\n\n        emit LiquidationStopped();\n    }\n\n    function triggerDefault() external override whenProtocolNotPaused {\n        require(msg.sender == _pool, \"DL:TD:NOT_POOL\");\n\n        address loanAddress = _loan;\n\n        require(\n            (IMapleLoanLike(loanAddress).claimableFunds() == uint256(0)) &&\n            (IMapleLoanLike(loanAddress).principal() == _principalRemainingAtLastClaim),\n            \"DL:TD:NEED_TO_CLAIM\"\n        );\n\n        _repossessed = true;\n\n        // Ensure that principal is always up to date, claim function will clear out all payments, but on refinance we need to ensure that\n        // accounting is updated properly when principal is updated and there are no claimable funds.\n\n        // Repossess collateral and funds from Loan.\n        ( uint256 collateralAssetAmount, ) = IMapleLoanLike(loanAddress).repossess(address(this));\n\n        address collateralAsset = IMapleLoanLike(loanAddress).collateralAsset();\n        address fundsAsset      = IMapleLoanLike(loanAddress).fundsAsset();\n\n        if (collateralAsset == fundsAsset || collateralAssetAmount == uint256(0)) return;\n\n        // Deploy Liquidator contract and transfer collateral.\n        require(\n            ERC20Helper.transfer(\n                collateralAsset,\n                _liquidator = address(new Liquidator(address(this), collateralAsset, fundsAsset, address(this), address(this), _getGlobals())),\n                collateralAssetAmount\n            ),\n            \"DL:TD:TRANSFER\"\n       );\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _handleClaim(address pool_, address loan_) internal returns (uint256[7] memory details_) {\n        // Get loan state variables needed\n        uint256 claimableFunds = IMapleLoanLike(loan_).claimableFunds();\n\n        require(claimableFunds > uint256(0), \"DL:HC:NOTHING_TO_CLAIM\");\n\n        // Send funds to pool\n        IMapleLoanLike(loan_).claimFunds(claimableFunds, pool_);\n\n        uint256 currentPrincipalRemaining = IMapleLoanLike(loan_).principal();\n\n        // Determine how much of `claimableFunds` is principal\n        uint256 principalPortion = _principalRemainingAtLastClaim - currentPrincipalRemaining;\n\n        // Update state variables\n        _principalRemainingAtLastClaim = currentPrincipalRemaining;\n\n        // Set return values\n        // Note: All fees get deducted and transferred during `loan.fundLoan()` that omits the need to\n        // return the fees distribution to the pool.\n        details_[0] = claimableFunds;\n        details_[1] = claimableFunds - principalPortion;\n        details_[2] = principalPortion;\n\n        uint256 amountOfFundsToCapture = _fundsToCapture;\n\n        if (amountOfFundsToCapture > uint256(0)) {\n            details_[0] += amountOfFundsToCapture;\n            details_[2] += amountOfFundsToCapture;\n\n            _fundsToCapture = uint256(0);\n\n            require(ERC20Helper.transfer(IMapleLoanLike(loan_).fundsAsset(), pool_, amountOfFundsToCapture), \"DL:HC:CAPTURE_FAILED\");\n        }\n    }\n\n    function _handleClaimOfRepossessed(address pool_, address loan_) internal returns (uint256[7] memory details_) {\n        require(!_isLiquidationActive(), \"DL:HCOR:LIQ_NOT_FINISHED\");\n\n        address fundsAsset       = IMapleLoanLike(loan_).fundsAsset();\n        uint256 principalToCover = _principalRemainingAtLastClaim;      // Principal remaining at time of liquidation\n        uint256 fundsCaptured    = _fundsToCapture;\n\n        // Funds recovered from liquidation and any unclaimed previous payment amounts\n        uint256 recoveredFunds = IERC20Like(fundsAsset).balanceOf(address(this)) - fundsCaptured;\n\n        uint256 totalClaimed = recoveredFunds + fundsCaptured;\n\n        // If `recoveredFunds` is greater than `principalToCover`, the remaining amount is treated as interest in the context of the pool.\n        // If `recoveredFunds` is less than `principalToCover`, the difference is registered as a shortfall.\n        details_[0] = totalClaimed;\n        details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : uint256(0);\n        details_[2] = fundsCaptured;\n        details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;\n        details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : uint256(0);\n\n        _fundsToCapture = uint256(0);\n        _repossessed    = false;\n\n        require(ERC20Helper.transfer(fundsAsset, pool_, totalClaimed), \"DL:HCOR:TRANSFER\");\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function allowedSlippage() external view override returns (uint256 allowedSlippage_) {\n        return _allowedSlippage;\n    }\n\n    function amountRecovered() external view override returns (uint256 amountRecovered_) {\n        return _amountRecovered;\n    }\n\n    function factory() external view override returns (address factory_) {\n        return _factory();\n    }\n\n    function fundsToCapture() external view override returns (uint256 fundsToCapture_) {\n        return _fundsToCapture;\n    }\n\n    function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {\n        address loanAddress     = _loan;\n        address collateralAsset = IMapleLoanLike(loanAddress).collateralAsset();\n        address fundsAsset      = IMapleLoanLike(loanAddress).fundsAsset();\n        address globals         = _getGlobals();\n\n        uint8 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();\n\n        uint256 oracleAmount =\n            swapAmount_\n                * IMapleGlobalsLike(globals).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.\n                * uint256(10) ** uint256(IERC20Like(fundsAsset).decimals())   // Convert to `toAsset` decimal precision.\n                * (uint256(10_000) - _allowedSlippage)                        // Multiply by allowed slippage basis points\n                / IMapleGlobalsLike(globals).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.\n                / uint256(10) ** uint256(collateralAssetDecimals)             // Convert from `fromAsset` decimal precision.\n                / uint256(10_000);                                            // Divide basis points for slippage.\n\n        uint256 minRatioAmount = (swapAmount_ * _minRatio) / (uint256(10) ** collateralAssetDecimals);\n\n        return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount;\n    }\n\n    function implementation() external view override returns (address implementation_) {\n        return _implementation();\n    }\n\n    function liquidator() external view override returns (address liquidator_) {\n        return _liquidator;\n    }\n\n    function loan() external view override returns (address loan_) {\n        return _loan;\n    }\n\n    function minRatio() external view override returns (uint256 minRatio_) {\n        return _minRatio;\n    }\n\n    function pool() external view override returns (address pool_) {\n        return _pool;\n    }\n\n    function poolDelegate() external override view returns (address poolDelegate_) {\n        return _getPoolDelegate();\n    }\n\n    function principalRemainingAtLastClaim() external view override returns (uint256 principalRemainingAtLastClaim_) {\n        return _principalRemainingAtLastClaim;\n    }\n\n    function repossessed() external view override returns (bool repossessed_) {\n        return _repossessed;\n    }\n\n    /*******************************/\n    /*** Internal View Functions ***/\n    /*******************************/\n\n    function _getGlobals() internal view returns (address globals_) {\n        return IPoolFactoryLike(IPoolLike(_pool).superFactory()).globals();\n    }\n\n    function _getPoolDelegate() internal view returns(address poolDelegate_) {\n        return IPoolLike(_pool).poolDelegate();\n    }\n\n    function _isLiquidationActive() internal view returns (bool isActive_) {\n        address liquidatorAddress = _liquidator;\n\n        return (liquidatorAddress != address(0)) && (IERC20Like(IMapleLoanLike(_loan).collateralAsset()).balanceOf(liquidatorAddress) != uint256(0));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "metadata": {
      "bytecodeHash": "none"
    }
  }
}