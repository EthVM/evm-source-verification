{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Lun.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\n// The following code is based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.1/contracts/token/ERC20\r\n// With custom modifications\r\npragma solidity ^0.8.0;\r\n\r\ncontract Lun {\r\n    /// @notice EIP-20 token symbol\r\n    string private _symbol = \"LUN\";\r\n    /// @notice EIP-20 token name\r\n    string private _name = \"LunDAO\";\r\n    /// @notice Total number of tokens\r\n    uint256 private _totalSupply;\r\n\r\n    /// @notice Token balances for each account\r\n    mapping(address => uint256) private _balances;\r\n    /// @notice Allowance amounts on behalf of others\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /// @notice EIP-20 transfer event\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /// @notice EIP-20 approval event\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice Construct a new Lun token\r\n    constructor() {\r\n        _mint(msg.sender, 1_000_000e18);\r\n    }\r\n\r\n    /// @notice Returns the name of EIP-20 token\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /// @notice Returns the symbol of EIP-20 token\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /// @notice Returns the decimals of EIP-20 token\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /// @notice Returns the totalsupply of EIP-20 token\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens owned by the `account`\r\n     * @param account The address of the account to get the balance of\r\n     * @return The number of tokens owned\r\n     */\r\n    function balanceOf(address account) public view virtual returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param recipient The address of the receiver account, cannot be the address(0).\r\n     * @param amount The number of tokens to transfer, the caller must have a balance of at least `amount`.\r\n     * @return Whether or not the transfer succeeded\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\r\n     * @param owner The address of the account holding the tokens\r\n     * @param spender The address of the account spending the tokens\r\n     * @return The number of tokens approved\r\n     */\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `msg.sender`\r\n     * @param spender The address of the account which may transfer tokens, cannot be the address(0).\r\n     * @param amount The number of tokens that are approved\r\n     * @return Whether or not the approval succeeded\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `sender` to `recipient`\r\n     * @param sender The address of the sender account, cannot be the address(0), must have a balance of at least `amount`.\r\n     * @param recipient The address of the receiver account, cannot be the address(0)\r\n     * @param amount The number of tokens to transfer\r\n     * @return Whether or not the transfer succeeded\r\n     * Requirements:\r\n     * - msg.sender must have allowance for ``sender``'s tokens of at least `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, msg.sender, currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\r\n     * @param sender The address of sender account, cannot be the address(0).\r\n     * @param recipient The address of the receiver account, cannot be the address(0).\r\n     * @param amount The number of tokens to transfer, the `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Create `amount` tokens and transfer them to `account`, and increasing the total supply.\r\n     * @param account The address of the receiver account, cannot be the address(0).\r\n     * Requirements:\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Destroy `amount` tokens from `account`, and decreasing the total supply.\r\n     * @param account The address of the tokens to burn. \r\n     * @param amount The number of tokens to burn.\r\n     * \r\n     * Requirements:\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Approve `spender` to transfer up to `amount` from `owner`\r\n     * @param owner The address of the account who own the tokens, cannot be the address(0).\r\n     * @param spender The address of the account which may transfer tokens, cannot be the address(0).\r\n     * @param amount The number of tokens that are approved\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Destroy `amount` tokens from `msg.sender`, and decreasing the total supply.\r\n     * @param amount The number of tokens to burn.\r\n     * \r\n     * Requirements:\r\n     * - `msg.sender` must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Destroy `amount` tokens from `account`, and decreasing the total supply.\r\n     * @param account The address of the tokens to burn. \r\n     * @param amount The number of tokens to burn.\r\n     * \r\n     * Requirements:\r\n     * - msg.sender must have allowance for `account`'s tokens of at least `amount` tokens.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 currentAllowance = allowance(account, msg.sender);\r\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(account, msg.sender, currentAllowance - amount);\r\n        }\r\n        _burn(account, amount);\r\n    }\r\n}"}}}