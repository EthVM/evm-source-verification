{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "GUniLPOracle.sol": {
      "content": "/**\r\n *Submitted for verification at Etherscan.io on 2021-09-17\r\n*/\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// GUniLPOracle.sol\r\n\r\n// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n///////////////////////////////////////////////////////\r\n//                                                   //\r\n//    Methodology for Calculating LP Token Price     //\r\n//                                                   //\r\n///////////////////////////////////////////////////////\r\n\r\n// We derive the sqrtPriceX96 via Maker's own oracles to prevent price manipulation in the pool:\r\n// \r\n// p0 = price of token0 in USD\r\n// p1 = price of token1 in USD\r\n// UNITS_0 = decimals of token0\r\n// UNITS_1 = decimals of token1\r\n// \r\n// token1/token0 = (p0 / 10^UNITS_0) / (p1 / 10^UNITS_1)               [Conversion from Maker's price ratio into Uniswap's format]\r\n//               = (p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)\r\n// \r\n// sqrtPriceX96 = sqrt(token1/token0) * 2^96                           [From Uniswap's definition]\r\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^96\r\n//              = sqrt((p0 * 10^UNITS_1) / (p1 * 10^UNITS_0)) * 2^48 * 2^48\r\n//              = sqrt((p0 * 10^UNITS_1 * 2^96) / (p1 * 10^UNITS_0)) * 2^48\r\n// \r\n// Once we have the sqrtPriceX96 we can use that to compute the fair reserves for each token. This part may be slightly subjective\r\n// depending on the implementation, but we expect most tokens to provide something like getUnderlyingBalancesAtPrice(uint160 sqrtPriceX96)\r\n// which will forward our oracle-calculated `sqrtPriceX96` to the Uniswap-provided LiquidityAmounts.getAmountsForLiquidity(...)\r\n// This function will return the fair reserves for each token. Vendor-specific logic is then used to tack any uninvested fees on top of those amounts.\r\n// \r\n// Once we have the fair reserves and the prices we can compute the token price by:\r\n// \r\n// Token Price = TVL / Token Supply\r\n//             = (r0 * p0 + r1 * p1) / totalSupply\r\n\r\npragma solidity =0.6.12;\r\n\r\ninterface ERC20Like {\r\n    function decimals()                 external view returns (uint8);\r\n    function totalSupply()              external view returns (uint256);\r\n}\r\n\r\ninterface GUNILike {\r\n    function token0()                               external view returns (address);\r\n    function token1()                               external view returns (address);\r\n    function getUnderlyingBalancesAtPrice(uint160)  external view returns (uint256,uint256);\r\n}\r\n\r\ninterface OracleLike {\r\n    function read() external view returns (uint256);\r\n}\r\n\r\ncontract GUniLPOracle {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;                                       // Addresses with admin authority\r\n    function rely(address _usr) external auth { wards[_usr] = 1; emit Rely(_usr); }  // Add admin\r\n    function deny(address _usr) external auth { wards[_usr] = 0; emit Deny(_usr); }  // Remove admin\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"GUniLPOracle/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    address public immutable src;   // Price source\r\n\r\n    // hop and zph are packed into single slot to reduce SLOADs;\r\n    // this outweighs the cost from added bitmasking operations.\r\n    uint8   public stopped;         // Stop/start ability to update\r\n    uint16  public hop = 1 hours;   // Minimum time in between price updates\r\n    uint232 public zph;             // Time of last price update plus hop\r\n\r\n    bytes32 public immutable wat;   // Label of token whose price is being tracked\r\n\r\n    // --- Whitelisting ---\r\n    mapping (address => uint256) public bud;\r\n    modifier toll { require(bud[msg.sender] == 1, \"GUniLPOracle/contract-not-whitelisted\"); _; }\r\n\r\n    struct Feed {\r\n        uint128 val;  // Price\r\n        uint128 has;  // Is price valid\r\n    }\r\n\r\n    Feed    internal cur;  // Current price  (mem slot 0x3)\r\n    Feed    internal nxt;  // Queued price   (mem slot 0x4)\r\n\r\n    // --- Data ---\r\n    uint256 private immutable UNIT_0;  // Numerical representation of one token of token0 (10^decimals) \r\n    uint256 private immutable UNIT_1;  // Numerical representation of one token of token1 (10^decimals) \r\n    uint256 private immutable TO_18_DEC_0;  // Conversion factor to 18 decimals\r\n    uint256 private immutable TO_18_DEC_1;  // Conversion factor to 18 decimals\r\n\r\n    address public            orb0;  // Oracle for token0, ideally a Medianizer\r\n    address public            orb1;  // Oracle for token1, ideally a Medianizer\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    function _add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require((z = _x + _y) >= _x, \"GUniLPOracle/add-overflow\");\r\n    }\r\n    function _sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require((z = _x - _y) <= _x, \"GUniLPOracle/sub-underflow\");\r\n    }\r\n    function _mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\r\n        require(_y == 0 || (z = _x * _y) / _y == _x, \"GUniLPOracle/mul-overflow\");\r\n    }\r\n    function toUint160(uint256 x) internal pure returns (uint160 z) {\r\n        require((z = uint160(x)) == x, \"GUniLPOracle/uint160-overflow\");\r\n    }\r\n\r\n    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\r\n    function sqrt(uint256 _x) private pure returns (uint128) {\r\n        if (_x == 0) return 0;\r\n        else {\r\n            uint256 xx = _x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n            if (xx >= 0x8) { r <<= 1; }\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1;\r\n            r = (r + _x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = _x / r;\r\n            return uint128 (r < r1 ? r : r1);\r\n        }\r\n    }\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event Step(uint256 hop);\r\n    event Stop();\r\n    event Start();\r\n    event Value(uint128 curVal, uint128 nxtVal);\r\n    event Link(uint256 id, address orb);\r\n    event Kiss(address a);\r\n    event Diss(address a);\r\n\r\n    // --- Init ---\r\n    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\r\n        require(_src  != address(0),                        \"GUniLPOracle/invalid-src-address\");\r\n        require(_orb0 != address(0) && _orb1 != address(0), \"GUniLPOracle/invalid-oracle-address\");\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n        src  = _src;\r\n        wat  = _wat;\r\n        uint256 dec0 = uint256(ERC20Like(GUNILike(_src).token0()).decimals());\r\n        require(dec0 <= 18, \"GUniLPOracle/token0-dec-gt-18\");\r\n        UNIT_0 = 10 ** dec0;\r\n        TO_18_DEC_0 = 10 ** (18 - dec0);\r\n        uint256 dec1 = uint256(ERC20Like(GUNILike(_src).token1()).decimals());\r\n        require(dec1 <= 18, \"GUniLPOracle/token1-dec-gt-18\");\r\n        UNIT_1 = 10 ** dec1;\r\n        TO_18_DEC_1 = 10 ** (18 - dec1);\r\n        orb0 = _orb0;\r\n        orb1 = _orb1;\r\n    }\r\n\r\n    function stop() external auth {\r\n        stopped = 1;\r\n        delete cur;\r\n        delete nxt;\r\n        zph = 0;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() external auth {\r\n        stopped = 0;\r\n        emit Start();\r\n    }\r\n\r\n    function step(uint256 _hop) external auth {\r\n        require(_hop <= uint16(-1), \"GUniLPOracle/invalid-hop\");\r\n        hop = uint16(_hop);\r\n        emit Step(_hop);\r\n    }\r\n\r\n    function link(uint256 _id, address _orb) external auth {\r\n        require(_orb != address(0), \"GUniLPOracle/no-contract-0\");\r\n        if(_id == 0) {\r\n            orb0 = _orb;\r\n        } else if (_id == 1) {\r\n            orb1 = _orb;\r\n        } else {\r\n            revert(\"GUniLPOracle/invalid-id\");\r\n        }\r\n        emit Link(_id, _orb);\r\n    }\r\n\r\n    // For consistency with other oracles.\r\n    function zzz() external view returns (uint256) {\r\n        if (zph == 0) return 0;  // backwards compatibility\r\n        return _sub(zph, hop);\r\n    }\r\n\r\n    function pass() external view returns (bool) {\r\n        return block.timestamp >= zph;\r\n    }\r\n\r\n    function seek() internal returns (uint128 quote) {\r\n        // All Oracle prices are priced with 18 decimals against USD\r\n        uint256 p0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\r\n        require(p0 != 0, \"GUniLPOracle/invalid-oracle-0-price\");\r\n        uint256 p1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\r\n        require(p1 != 0, \"GUniLPOracle/invalid-oracle-1-price\");\r\n        uint160 sqrtPriceX96 = toUint160(sqrt(_mul(_mul(p0, UNIT_1), (1 << 96)) / (_mul(p1, UNIT_0))) << 48);\r\n\r\n        // Get balances of the tokens in the pool\r\n        (uint256 r0, uint256 r1) = GUNILike(src).getUnderlyingBalancesAtPrice(sqrtPriceX96);\r\n        require(r0 > 0 || r1 > 0, \"GUniLPOracle/invalid-balances\");\r\n        uint256 totalSupply = ERC20Like(src).totalSupply();\r\n        require(totalSupply >= 1e9, \"GUniLPOracle/total-supply-too-small\"); // Protect against precision errors with dust-levels of collateral\r\n\r\n        // Add the total value of each token together and divide by the totalSupply to get the unit price\r\n        uint256 preq = _add(\r\n            _mul(p0, _mul(r0, TO_18_DEC_0)),\r\n            _mul(p1, _mul(r1, TO_18_DEC_1))\r\n        ) / totalSupply;\r\n        require(preq < 2 ** 128, \"GUniLPOracle/quote-overflow\");\r\n        quote = uint128(preq);  // WAD\r\n    }\r\n\r\n    function poke() external {\r\n\r\n        // Ensure a single SLOAD while avoiding solc's excessive bitmasking bureaucracy.\r\n        uint256 hop_;\r\n        {\r\n\r\n            // Block-scoping these variables saves some gas.\r\n            uint256 stopped_;\r\n            uint256 zph_;\r\n            assembly {\r\n                let slot1 := sload(1)\r\n                stopped_  := and(slot1,         0xff  )\r\n                hop_      := and(shr(8, slot1), 0xffff)\r\n                zph_      := shr(24, slot1)\r\n            }\r\n\r\n            // When stopped, values are set to zero and should remain such; thus, disallow updating in that case.\r\n            require(stopped_ == 0, \"GUniLPOracle/is-stopped\");\r\n\r\n            // Equivalent to requiring that pass() returns true.\r\n            // The logic is repeated instead of calling pass() to save gas\r\n            // (both by eliminating an internal call here, and allowing pass to be external).\r\n            require(block.timestamp >= zph_, \"GUniLPOracle/not-passed\");\r\n        }\r\n\r\n        uint128 val = seek();\r\n        require(val != 0, \"GUniLPOracle/invalid-price\");\r\n        Feed memory cur_ = nxt;  // This memory value is used to save an SLOAD later.\r\n        cur = cur_;\r\n        nxt = Feed(val, 1);\r\n\r\n        // The below is equivalent to:\r\n        //\r\n        //    zph = block.timestamp + hop\r\n        //\r\n        // but ensures no extra SLOADs are performed.\r\n        //\r\n        // Even if _hop = (2^16 - 1), the maximum possible value, add(timestamp(), _hop)\r\n        // will not overflow (even a 232 bit value) for a very long time.\r\n        //\r\n        // Also, we know stopped was zero, so there is no need to account for it explicitly here.\r\n        assembly {\r\n            sstore(\r\n                1,\r\n                add(\r\n                    // zph value starts 24 bits in\r\n                    shl(24, add(timestamp(), hop_)),\r\n\r\n                    // hop value starts 8 bits in\r\n                    shl(8, hop_)\r\n                )\r\n            )\r\n        }\r\n\r\n        // Equivalent to emitting Value(cur.val, nxt.val), but averts extra SLOADs.\r\n        emit Value(cur_.val, val);\r\n\r\n        // Safe to terminate immediately since no postfix modifiers are applied.\r\n        assembly {\r\n            stop()\r\n        }\r\n    }\r\n\r\n    function peek() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint256(cur.val)), cur.has == 1);\r\n    }\r\n\r\n    function peep() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint256(nxt.val)), nxt.has == 1);\r\n    }\r\n\r\n    function read() external view toll returns (bytes32) {\r\n        require(cur.has == 1, \"GUniLPOracle/no-current-value\");\r\n        return (bytes32(uint256(cur.val)));\r\n    }\r\n\r\n    function kiss(address _a) external auth {\r\n        require(_a != address(0), \"GUniLPOracle/no-contract-0\");\r\n        bud[_a] = 1;\r\n        emit Kiss(_a);\r\n    }\r\n\r\n    function kiss(address[] calldata _a) external auth {\r\n        for(uint256 i = 0; i < _a.length; i++) {\r\n            require(_a[i] != address(0), \"GUniLPOracle/no-contract-0\");\r\n            bud[_a[i]] = 1;\r\n            emit Kiss(_a[i]);\r\n        }\r\n    }\r\n\r\n    function diss(address _a) external auth {\r\n        bud[_a] = 0;\r\n        emit Diss(_a);\r\n    }\r\n\r\n    function diss(address[] calldata _a) external auth {\r\n        for(uint256 i = 0; i < _a.length; i++) {\r\n            bud[_a[i]] = 0;\r\n            emit Diss(_a[i]);\r\n        }\r\n    }\r\n}"
    }
  }
}