{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "mytest/FoundingEvent.sol": {
      "content": "pragma solidity >=0.7.0 <0.8.0;\n\ninterface I{\n\tfunction getPair(address t, address t1) external view returns(address pair);\n\tfunction createPair(address t, address t1) external returns(address pair);\n\tfunction init(uint Eth,address pair) external;\n\tfunction deposit() external payable;\n\tfunction transfer(address to, uint value) external returns(bool);\n\tfunction mint(address to) external returns(uint liquidity);\n}\n\npragma solidity >=0.7.0 <0.8.0;\n\n// Author: Sam Porter\n// With LGE it's now possible to create fairer distribution and fund promising projects without VC vultures at all.\n// Non-upgradeable, not owned, liquidity is being created automatically on first transaction after last block of LGE.\n// Founders' liquidity is not locked, instead an incentive to keep it is introduced.\n// The Event lasts for ~2 months to ensure fair distribution.\n// 0,5% of contributed Eth goes to developer for earliest development expenses including audits and bug bounties.\n// Blockchain needs no VCs, no authorities.12631000 81000\n\n//import \"./I.sol\";\n\ncontract FoundingEvent {\n\tmapping(address => uint) public contributions;\n\taddress payable private _deployer;\n\tuint88 private _phase;\n\tbool private _lgeOngoing;\n\tuint private _ETHDeposited;\n\n\tconstructor() {_deployer = msg.sender;_lgeOngoing = true;}\n\n\tfunction depositEth() external payable {\n\t\trequire(_lgeOngoing == true);\n\t\tuint amount = msg.value;\n\t\tif (block.number >= 12550000) {uint phase = _phase; if(block.number >= phase+12550000){_phase = uint88(phase + 9000);_createLiquidity(phase);}}\n\t\tuint deployerShare = amount/100; amount -= deployerShare; _deployer.transfer(deployerShare);\n\t\tcontributions[msg.sender] += amount;\n\t}\n\n\tfunction _createLiquidity(uint phase) internal {\n\t\taddress WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\t\taddress token = 0xc8f1999009f6Cb7d712a25cA219E0ff2a9Ea0290;\n\t\taddress staking = 0xB0b3E52e432b80D3A37e15AB6BBF4673225e160f;\n\t\taddress factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n\t\taddress tknETHLP = I(factory).getPair(token,WETH);\n\t\tif (tknETHLP == address(0)) {tknETHLP=I(factory).createPair(token, WETH);}\n\t\t_ETHDeposited += address(this).balance;\n\t\tuint ethToDeposit = address(this).balance;\n\t\tuint tokenToDeposit = 1e23;\n\t\tif (phase == 81000) {I(staking).init(_ETHDeposited, tknETHLP);delete _lgeOngoing; delete _ETHDeposited; delete _phase; delete _deployer;}\n\t\tI(WETH).deposit{value: ethToDeposit}();\n\t\tI(token).transfer(tknETHLP, tokenToDeposit);\n\t\tI(WETH).transfer(tknETHLP, ethToDeposit);\n\t\tI(tknETHLP).mint(staking);\n\t}\n}"
    }
  }
}