{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"VoteBribe.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\ninterface vote {\r\n    struct VoteData {\r\n        bool is_open;\r\n        bool is_executed;\r\n        uint start_date;\r\n        uint snapshot_block;\r\n        uint support_required;\r\n        uint min_accept_quorum;\r\n        uint yea;\r\n        uint nay;\r\n        uint voting_power;\r\n    }\r\n    \r\n    function getVote(uint vote_id) external view returns (VoteData memory);\r\n    function getVoterState(uint vote_id, address voter) external view returns (uint);\r\n}\r\n\r\ninterface ve {\r\n    function balanceOfAt(address owner, uint block_number) external view returns (uint);\r\n}\r\n\r\ninterface erc20 {\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n\r\ncontract BribeV2Vote {\r\n    vote constant VOTE = vote(0xE478de485ad2fe566d49342Cbd03E49ed7DB3356);\r\n    ve constant veCRV = ve(0x5f3b5DfEb7B28CDbD7FAba78963EE202a494e2A2);\r\n    uint constant desired_vote = 1;\r\n    \r\n    // vote_id => reward_token => reward_amount\r\n    mapping(uint => mapping(address => uint)) public reward_amount;\r\n    mapping(uint => uint) public snapshot_block;\r\n    mapping(uint => uint) public yeas;\r\n    mapping(uint => mapping(address => mapping(address => uint))) given_rewards;\r\n    mapping(uint => mapping(address => uint)) public vote_states;\r\n    mapping(uint => mapping(address => mapping(address => bool))) public has_claimed;\r\n    \r\n    mapping(uint => address[]) _rewards_per_vote;\r\n    mapping(uint => mapping(address => bool)) _rewards_for_vote_exists;\r\n    \r\n    event Bribe(address indexed briber, uint vote_id, address reward_token, uint amount);\r\n    event Claim(address indexed claimant, uint vote_id, address reward_token, uint amount);\r\n    \r\n    function rewards_per_vote(uint vote_id) external view returns (address[] memory) {\r\n        return _rewards_per_vote[vote_id];\r\n    }\r\n    \r\n    function add_reward_amount(uint vote_id, address reward_token, uint amount) external returns (bool) {\r\n        vote.VoteData memory _vote = VOTE.getVote(vote_id);\r\n        uint _vote_state = vote_states[vote_id][reward_token];\r\n        require(_vote_state == 0);\r\n        _safeTransferFrom(reward_token, msg.sender, address(this), amount);\r\n        reward_amount[vote_id][reward_token] += amount;\r\n        given_rewards[vote_id][reward_token][msg.sender] += amount;\r\n        snapshot_block[vote_id] = _vote.snapshot_block;\r\n        if (!_rewards_for_vote_exists[vote_id][reward_token]) {\r\n            _rewards_for_vote_exists[vote_id][reward_token] = true;\r\n            _rewards_per_vote[vote_id].push(reward_token);\r\n        }\r\n        emit Bribe(msg.sender, vote_id, reward_token, amount);\r\n        return true;\r\n    }\r\n    \r\n    function estimate_bribe(uint vote_id, address reward_token, address claimant) external view returns (uint) {\r\n        vote.VoteData memory _vote = VOTE.getVote(vote_id);\r\n        uint _vecrv = veCRV.balanceOfAt(claimant, _vote.snapshot_block);\r\n        if (VOTE.getVoterState(vote_id, claimant) == desired_vote) {\r\n            return reward_amount[vote_id][reward_token] * _vecrv / _vote.yea;\r\n        } else {\r\n            return reward_amount[vote_id][reward_token] * _vecrv / (_vote.yea + _vecrv);\r\n        }\r\n    }\r\n    \r\n    function _update_vote_state(uint vote_id, address reward_token) internal returns (uint) {\r\n        vote.VoteData memory _vote = VOTE.getVote(vote_id);\r\n        require(!_vote.is_open);\r\n        uint total_vecrv = _vote.yea + _vote.nay;\r\n        bool has_quorum = total_vecrv * 10**18 / _vote.voting_power > _vote.min_accept_quorum;\r\n        bool has_support = _vote.yea * 10**18 / total_vecrv > _vote.support_required;\r\n        \r\n        if (has_quorum && has_support) {\r\n            vote_states[vote_id][reward_token] = 1;\r\n            yeas[vote_id] = _vote.yea;\r\n            return 1;\r\n        } else {\r\n            vote_states[vote_id][reward_token] = 2;\r\n            return 2;\r\n        }\r\n    }\r\n    \r\n    function withdraw_reward(uint vote_id, address reward_token, address claimant) external returns (bool) {\r\n        uint _vote_state = vote_states[vote_id][reward_token];\r\n        if (_vote_state == 0) {\r\n            _vote_state = _update_vote_state(vote_id, reward_token);\r\n        }\r\n        require(_vote_state == 2);\r\n        uint _amount = given_rewards[vote_id][reward_token][msg.sender];\r\n        given_rewards[vote_id][reward_token][msg.sender] = 0;\r\n        reward_amount[vote_id][reward_token] -= _amount;\r\n        _safeTransfer(reward_token, claimant, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function claim_reward(uint vote_id, address reward_token, address claiment) external returns (bool) {\r\n        return _claim_reward(vote_id, reward_token, claiment);\r\n    }\r\n    \r\n    function claim_reward(uint vote_id, address reward_token) external returns (bool) {\r\n        return _claim_reward(vote_id, reward_token, msg.sender);\r\n    }\r\n    \r\n    function _claim_reward(uint vote_id, address reward_token, address claimant) internal returns (bool) {\r\n        uint _vote_state = vote_states[vote_id][reward_token];\r\n        if (_vote_state == 0) {\r\n            _vote_state = _update_vote_state(vote_id, reward_token);\r\n        }\r\n        require(_vote_state == 1);\r\n        require(!has_claimed[vote_id][reward_token][msg.sender]);\r\n        require(VOTE.getVoterState(vote_id, claimant) == desired_vote);\r\n        has_claimed[vote_id][reward_token][msg.sender] = true;\r\n        \r\n        uint _vecrv = veCRV.balanceOfAt(claimant, snapshot_block[vote_id]);\r\n        uint _amount = reward_amount[vote_id][reward_token] * _vecrv / yeas[vote_id];\r\n        _safeTransfer(reward_token, claimant, _amount);\r\n        emit Bribe(claimant, vote_id, reward_token, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function _safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n    \r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}"}}}