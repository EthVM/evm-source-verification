{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/lpLock.sol":{"content":"\npragma solidity 0.8.0;\n//SPDX-License-Identifier: BSD-3-Clause\n/**\n * Vaults Reward Fund Locked till 20th Oct 2020 \n * Farming vault token will transfer on Vaults smart contrcat after unlock which will be without withdrawal permission\n *\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n    address public pendingOwner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor ()  {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyCaller() {\n        require(isOwner());\n        _;\n    }\n    /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyPendingOwner() {\n    assert(msg.sender != address(0));\n    require(msg.sender == pendingOwner);\n    _;\n  }\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n    /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyCaller {\n    require(_newOwner != address(0));\n    pendingOwner = _newOwner;\n  }\n  /**\n   * @dev Allows the pendingOwner address to finalize the transfer.\n   */\n  function claimOwnership() onlyPendingOwner public {\n    _transferOwnership(pendingOwner);\n    pendingOwner = address(0);\n  }\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\ninterface token {\n    function transfer(address, uint) external returns (bool);\n}\ncontract DAO1_LP_Locker is Ownable {\n    address public constant beneficiary = 0x920ae8A9c224d554d9642292670a684a1466ED16; // DAO1 Token Owner address\n    // unlocks on Dec 07 2022\n    uint public constant unlockTime = 1670351400;\n    function isUnlocked() public view returns (bool) {\n        return block.timestamp > unlockTime;\n    }\n    function claim(address _tokenAddr, uint _amount) public onlyCaller {\n        require(isUnlocked(), \"Cannot transfer tokens while locked.\");\n        token(_tokenAddr).transfer(beneficiary, _amount);\n    }\n}"}}}