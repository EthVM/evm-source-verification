{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ERC721TokenProxy.sol":{"content":"// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Proxy.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Tells the address of the implementation where every call will be delegated.\r\n     * @return address of the implementation to which it will be delegated\r\n     */\r\n    function implementation() public view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    fallback() external payable {\r\n        // solhint-disable-previous-line no-complex-fallback\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n        assembly {\r\n            /*\r\n                0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\r\n                loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\r\n                memory. It's needed because we're going to write the return data of delegatecall to the\r\n                free memory slot.\r\n            */\r\n            let ptr := mload(0x40)\r\n            /*\r\n                `calldatacopy` is copy calldatasize bytes from calldata\r\n                First argument is the destination to which data is copied(ptr)\r\n                Second argument specifies the start position of the copied data.\r\n                    Since calldata is sort of its own unique location in memory,\r\n                    0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\r\n                    That's always going to be the zeroth byte of the function selector.\r\n                Third argument, calldatasize, specifies how much data will be copied.\r\n                    calldata is naturally calldatasize bytes long (same thing as msg.data.length)\r\n            */\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            /*\r\n                delegatecall params explained:\r\n                gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\r\n                    us the amount of gas still available to execution\r\n\r\n                _impl: address of the contract to delegate to\r\n\r\n                ptr: to pass copied data\r\n\r\n                calldatasize: loads the size of `bytes memory data`, same as msg.data.length\r\n\r\n                0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\r\n                        these are set to 0, 0 so the output data will not be written to memory. The output\r\n                        data will be read using `returndatasize` and `returdatacopy` instead.\r\n\r\n                result: This will be 0 if the call fails and 1 if it succeeds\r\n            */\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            /*\r\n\r\n            */\r\n            /*\r\n                ptr current points to the value stored at 0x40,\r\n                because we assigned it like ptr := mload(0x40).\r\n                Because we use 0x40 as a free memory pointer,\r\n                we want to make sure that the next time we want to allocate memory,\r\n                we aren't overwriting anything important.\r\n                So, by adding ptr and returndatasize,\r\n                we get a memory location beyond the end of the data we will be copying to ptr.\r\n                We place this in at 0x40, and any reads from 0x40 will now read from free memory\r\n            */\r\n            mstore(0x40, add(ptr, returndatasize()))\r\n            /*\r\n                `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\r\n                    slot it will copy to, 0 means copy from the beginning of the return data, and size is\r\n                    the amount of data to copy.\r\n                `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\r\n            */\r\n            returndatacopy(ptr, 0, returndatasize())\r\n\r\n            /*\r\n                if `result` is 0, revert.\r\n                if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\r\n                copied to `ptr` from the delegatecall return data\r\n            */\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, returndatasize())\r\n                }\r\n                default {\r\n                    return(ptr, returndatasize())\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IOwnable.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n}\r\n\r\n// File: contracts/upgradeable_contracts/omnibridge_nft/components/bridged/ERC721TokenProxy.sol\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721TokenProxy\r\n * @dev Helps to reduces the size of the deployed bytecode for automatically created tokens, by using a proxy contract.\r\n */\r\ncontract ERC721TokenProxy is Proxy {\r\n    // storage layout is copied from ERC721BridgeToken.sol\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n    mapping(address => uint256) private _holderTokens;\r\n\r\n    //EnumerableMap.UintToAddressMap private _tokenOwners;\r\n    uint256[] private _tokenOwnersEntries;\r\n    mapping(bytes32 => uint256) private _tokenOwnersIndexes;\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    string private name;\r\n    string private symbol;\r\n    mapping(uint256 => string) private _tokenURIs;\r\n    string private _baseURI;\r\n    address private bridgeContract;\r\n\r\n    /**\r\n     * @dev Creates an upgradeable token proxy for ERC721BridgeToken.sol, initializes its eternalStorage.\r\n     * @param _tokenImage address of the token image used for mirroring all functions.\r\n     * @param _name token name.\r\n     * @param _symbol token symbol.\r\n     * @param _owner address of the owner for this contract.\r\n     */\r\n    constructor(\r\n        address _tokenImage,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _owner\r\n    ) {\r\n        assembly {\r\n            // EIP 1967\r\n            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\r\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _tokenImage)\r\n        }\r\n        name = _name;\r\n        symbol = _symbol;\r\n        bridgeContract = _owner; // _owner == HomeOmnibridgeNFT/ForeignOmnibridgeNFT mediator\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the implementation contract address, mirrored token image.\r\n     * @return impl token image address.\r\n     */\r\n    function implementation() public view override returns (address impl) {\r\n        assembly {\r\n            impl := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the implementation contract address.\r\n     * Only the bridge and bridge owner can call this method.\r\n     * @param _implementation address of the new implementation.\r\n     */\r\n    function setImplementation(address _implementation) external {\r\n        require(msg.sender == bridgeContract || msg.sender == IOwnable(bridgeContract).owner());\r\n        require(_implementation != address(0));\r\n        require(Address.isContract(_implementation));\r\n        assembly {\r\n            // EIP 1967\r\n            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\r\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _implementation)\r\n        }\r\n    }\r\n}"}}}