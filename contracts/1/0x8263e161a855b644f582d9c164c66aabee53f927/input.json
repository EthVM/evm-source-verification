{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CalculationsSushiswap.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ninterface PriceRouter {\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function WETH() external view returns (address);\n}\n\ninterface Pair {\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112,\n            uint112,\n            uint32\n        );\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract CalculationsSushiswap {\n    address public primaryRouterAddress;\n    address public primaryFactoryAddress;\n    address public secondaryRouterAddress;\n    address public secondaryFactoryAddress;\n    address public wethAddress;\n    address public usdcAddress;\n    PriceRouter primaryRouter;\n    PriceRouter secondaryRouter;\n\n    address ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address zeroAddress = 0x0000000000000000000000000000000000000000;\n\n    constructor(\n        address _primaryRouterAddress,\n        address _primaryFactoryAddress,\n        address _secondaryRouterAddress,\n        address _secondaryFactoryAddress,\n        address _usdcAddress\n    ) {\n        primaryRouterAddress = _primaryRouterAddress;\n        primaryFactoryAddress = _primaryFactoryAddress;\n        secondaryRouterAddress = _secondaryRouterAddress;\n        secondaryFactoryAddress = _secondaryFactoryAddress;\n        usdcAddress = _usdcAddress;\n        primaryRouter = PriceRouter(primaryRouterAddress);\n        secondaryRouter = PriceRouter(secondaryRouterAddress);\n        wethAddress = primaryRouter.WETH();\n    }\n\n    // Uniswap/Sushiswap\n    function getPriceUsdc(address tokenAddress) public view returns (uint256) {\n        if (isLpToken(tokenAddress)) {\n            return getLpTokenPriceUsdc(tokenAddress);\n        }\n        return getPriceFromRouterUsdc(tokenAddress);\n    }\n\n    function getPriceFromRouter(address token0Address, address token1Address)\n        public\n        view\n        returns (uint256)\n    {\n        // Convert ETH address (0xEeee...) to WETH\n        if (token0Address == ethAddress) {\n            token0Address = wethAddress;\n        }\n        if (token1Address == ethAddress) {\n            token1Address = wethAddress;\n        }\n\n        address[] memory path;\n        uint8 numberOfJumps;\n        bool inputTokenIsWeth =\n            token0Address == wethAddress || token1Address == wethAddress;\n        if (inputTokenIsWeth) {\n            // path = [token0, weth] or [weth, token1]\n            numberOfJumps = 1;\n            path = new address[](numberOfJumps + 1);\n            path[0] = token0Address;\n            path[1] = token1Address;\n        } else {\n            // path = [token0, weth, token1]\n            numberOfJumps = 2;\n            path = new address[](numberOfJumps + 1);\n            path[0] = token0Address;\n            path[1] = wethAddress;\n            path[2] = token1Address;\n        }\n\n        IERC20 token0 = IERC20(token0Address);\n        uint256 amountIn = 10**uint256(token0.decimals());\n        uint256[] memory amountsOut;\n\n        bool fallbackRouterExists = secondaryRouterAddress != zeroAddress;\n        if (fallbackRouterExists) {\n            try primaryRouter.getAmountsOut(amountIn, path) returns (\n                uint256[] memory _amountsOut\n            ) {\n                amountsOut = _amountsOut;\n            } catch {\n                amountsOut = secondaryRouter.getAmountsOut(amountIn, path);\n            }\n        } else {\n            amountsOut = primaryRouter.getAmountsOut(amountIn, path);\n        }\n\n        // Return raw price (without fees)\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        uint256 feeBips = 30; // .3% per swap\n        amountOut = (amountOut * 10000) / (10000 - (feeBips * numberOfJumps));\n        return amountOut;\n    }\n\n    function getPriceFromRouterUsdc(address tokenAddress)\n        public\n        view\n        returns (uint256)\n    {\n        return getPriceFromRouter(tokenAddress, usdcAddress);\n    }\n\n    function isLpToken(address tokenAddress) public view returns (bool) {\n        if (tokenAddress == ethAddress) {\n            return false;\n        }\n        Pair lpToken = Pair(tokenAddress);\n        try lpToken.factory() {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    function getRouterForLpToken(address tokenAddress)\n        public\n        view\n        returns (PriceRouter)\n    {\n        Pair lpToken = Pair(tokenAddress);\n        address factoryAddress = lpToken.factory();\n        if (factoryAddress == primaryFactoryAddress) {\n            return primaryRouter;\n        } else if (factoryAddress == secondaryFactoryAddress) {\n            return secondaryRouter;\n        }\n        revert();\n    }\n\n    function getLpTokenTotalLiquidityUsdc(address tokenAddress)\n        public\n        view\n        returns (uint256)\n    {\n        Pair pair = Pair(tokenAddress);\n        address token0Address = pair.token0();\n        address token1Address = pair.token1();\n        IERC20 token0 = IERC20(token0Address);\n        IERC20 token1 = IERC20(token1Address);\n        uint8 token0Decimals = token0.decimals();\n        uint8 token1Decimals = token1.decimals();\n        uint256 token0Price = getPriceUsdc(token0Address);\n        uint256 token1Price = getPriceUsdc(token1Address);\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n        uint256 totalLiquidity =\n            ((reserve0 / 10**token0Decimals) * token0Price) +\n                ((reserve1 / 10**token1Decimals) * token1Price);\n        return totalLiquidity;\n    }\n\n    function getLpTokenPriceUsdc(address tokenAddress)\n        public\n        view\n        returns (uint256)\n    {\n        Pair pair = Pair(tokenAddress);\n        uint256 totalLiquidity = getLpTokenTotalLiquidityUsdc(tokenAddress);\n        uint256 totalSupply = pair.totalSupply();\n        uint8 pairDecimals = pair.decimals();\n        uint256 pricePerLpTokenUsdc =\n            (totalLiquidity * 10**pairDecimals) / totalSupply;\n        return pricePerLpTokenUsdc;\n    }\n}\n"}}}