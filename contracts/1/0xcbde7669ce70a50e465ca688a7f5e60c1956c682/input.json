{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"SUKUPriceOracle.sol":{"content":"// File: contracts/interfaces/AggregatorV3Interface.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >0.5.16;\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    // getRoundData and latestRoundData should both raise \"No data present\"\r\n    // if they do not have data to report, instead of returning unset values\r\n    // which could be misinterpreted as actual reported values.\r\n    function getRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}\r\n\r\n// File: contracts/interfaces/UniswapPriceOracleInterface.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >0.5.16;\r\n\r\ninterface UniswapPriceOracleInterface {\r\n    function update() external;\r\n\r\n    function consult(address token) external view returns (uint256 amountOut);\r\n}\r\n\r\n// File: contracts/interfaces/CTokenInterfaces.sol\r\n\r\npragma solidity >0.5.16;\r\n\r\ninterface CTokenInterface {\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\ninterface CErc20Interface {\r\n    function underlying() external view returns (address);\r\n}\r\n\r\ninterface Erc20Interface {\r\n    function decimals() external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/SUKUPriceOracle.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity >0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract SUKUPriceOracle {\r\n    using SafeMath for uint256;\r\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\r\n    bool public constant isPriceOracle = true;\r\n    uint256 constant MANTISSA_DECIMALS = 18;\r\n\r\n    AggregatorV3Interface internal priceFeedETHUSD;\r\n    AggregatorV3Interface internal priceFeedUSDCETH;\r\n    UniswapPriceOracleInterface internal uniswapPriceOracle;\r\n\r\n    constructor(\r\n        address priceFeedETHUSD_,\r\n        address priceFeedUSDCETH_,\r\n        address uniswapPriceOracle_\r\n    ) public {\r\n        priceFeedETHUSD = AggregatorV3Interface(priceFeedETHUSD_);\r\n        priceFeedUSDCETH = AggregatorV3Interface(priceFeedUSDCETH_);\r\n        uniswapPriceOracle = UniswapPriceOracleInterface(uniswapPriceOracle_);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current price of a supported cToken underlying\r\n     * @param cToken The address of the market (token)\r\n     * @return USD price mantissa or failure for unsupported markets\r\n     */\r\n    function getUnderlyingPrice(address cToken) public view returns (uint256) {\r\n        string memory cTokenSymbol = CTokenInterface(cToken).symbol();\r\n        // sETH doesn't not have an underlying field\r\n        if (compareStrings(cTokenSymbol, \"sETH\")) {\r\n            return getETHUSDCPrice();\r\n        }\r\n        address underlyingAddress = CErc20Interface(cToken).underlying();\r\n        uint underlyingDecimals = Erc20Interface(underlyingAddress).decimals();\r\n        // Becuase decimals places differ among contracts it's necessary to\r\n        //  scale the price so that the values between tokens stays as expected\r\n        uint256 priceFactor = MANTISSA_DECIMALS.sub(underlyingDecimals);\r\n        if (compareStrings(cTokenSymbol, \"sUSDC\")) {\r\n            return\r\n                getETHUSDCPrice()\r\n                    .mul(getUSDCETHPrice())\r\n                    .div(10**MANTISSA_DECIMALS)\r\n                    .mul(10**priceFactor);\r\n        } else if (compareStrings(cTokenSymbol, \"sSUKU\")) {\r\n            uint256 SUKUETHpriceMantissa =\r\n                uniswapPriceOracle.consult(\r\n                    address(CErc20Interface(address(cToken)).underlying())\r\n                );\r\n            return\r\n                getETHUSDCPrice()\r\n                    .mul(SUKUETHpriceMantissa)\r\n                    .div(10**MANTISSA_DECIMALS)\r\n                    .mul(10**priceFactor);\r\n        } else {\r\n            revert(\"This is not a supported market address.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the ETHUSD price from ChainLink and convert to a mantissa value\r\n     * @return USD price mantissa\r\n     */\r\n    function getETHUSDCPrice() public view returns (uint256) {\r\n        (\r\n            uint80 roundID,\r\n            int256 price,\r\n            uint256 startedAt,\r\n            uint256 timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceFeedETHUSD.latestRoundData();\r\n        // Get decimals of price feed\r\n        uint256 decimals = priceFeedETHUSD.decimals();\r\n        // Add decimal places to format an 18 decimal mantissa\r\n        uint256 priceMantissa =\r\n            uint256(price).mul(10**(MANTISSA_DECIMALS.sub(decimals)));\r\n\r\n        return priceMantissa;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the USDCETH price from ChainLink and convert to a mantissa value\r\n     * @return USD price mantissa\r\n     */\r\n    function getUSDCETHPrice() public view returns (uint256) {\r\n        (\r\n            uint80 roundID,\r\n            int256 price,\r\n            uint256 startedAt,\r\n            uint256 timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceFeedUSDCETH.latestRoundData();\r\n        // Get decimals of price feed\r\n        uint256 decimals = priceFeedUSDCETH.decimals();\r\n        // Add decimal places to format an 18 decimal mantissa\r\n        uint256 priceMantissa =\r\n            uint256(price).mul(10**(MANTISSA_DECIMALS.sub(decimals)));\r\n\r\n        return priceMantissa;\r\n    }\r\n\r\n    function compareStrings(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return (keccak256(abi.encodePacked((a))) ==\r\n            keccak256(abi.encodePacked((b))));\r\n    }\r\n}"}}}