{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/3_Ballot.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2020-03-27\r\n*/\r\n\r\npragma solidity 0.5.16; /*\r\n\r\n\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n\r\n ██████╗ ██╗██╗     ██╗     ██╗ ██████╗ ███╗   ██╗    ███╗   ███╗ ██████╗ ███╗   ██╗███████╗██╗   ██╗\r\n ██╔══██╗██║██║     ██║     ██║██╔═══██╗████╗  ██║    ████╗ ████║██╔═══██╗████╗  ██║██╔════╝╚██╗ ██╔╝\r\n ██████╔╝██║██║     ██║     ██║██║   ██║██╔██╗ ██║    ██╔████╔██║██║   ██║██╔██╗ ██║█████╗   ╚████╔╝ \r\n ██╔══██╗██║██║     ██║     ██║██║   ██║██║╚██╗██║    ██║╚██╔╝██║██║   ██║██║╚██╗██║██╔══╝    ╚██╔╝  \r\n ██████╔╝██║███████╗███████╗██║╚██████╔╝██║ ╚████║    ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║███████╗   ██║   \r\n ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   \r\n                                                                                            \r\n\r\n\r\n-------------------------------------------------------------------\r\n Copyright (c) 2020 onwards Billion Money Inc. ( https://billionmoney.live )\r\n-------------------------------------------------------------------\r\n */\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address  public owner;\r\n    address  internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address  _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ninterface interfaceOldBMContract\r\n{\r\n    function lastIDCount() external view returns(uint);\r\n    function userInfos(address user) external view returns(bool, uint, uint);\r\n    function viewUserLevelExpired(address _user, uint _level) external view returns(uint);\r\n    function totalDivCollection() external view returns(uint);\r\n    function thisMonthEnd() external view returns(uint);\r\n    function nextMemberFillIndex(uint) external view returns(uint);\r\n    function nextMemberFillBox(uint) external view returns(uint); \r\n    function autoPoolLevel(uint _lvl, uint _index) external view returns (uint, uint); \r\n    function userAddressByID(uint) external view returns(address);\r\n}\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         PAX interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface paxInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n }\r\n\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n// This is billionMoney Version 2 , which works after the last id of old contract\r\ncontract billionMoney is owned {\r\n\r\n    // Replace below address with main PAX token\r\n    // All address here below taken from old contract\r\n    address public paxTokenAddress;\r\n    address public oldBMContractAddress;\r\n    address public specialAddress1;\r\n    address public specialAddress2;\r\n    uint public maxDownLimit = 2;\r\n    uint public levelLifeTime = 15552000;  // =180 days;\r\n    uint public lastIDCount;\r\n    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID \r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parentID;\r\n        uint referrerID;\r\n        address[] dReferred;\r\n        mapping(uint => uint) levelExpired;\r\n    }\r\n    mapping(uint => uint) public priceOfLevel; // Main network level price chart \r\n    mapping(uint => uint) public distForLevel; // distribution price chart for main network\r\n    mapping(uint => uint) public autoPoolDist; // price chart for auto pool level\r\n    mapping(uint => uint) public uniLevelDistPart; // price chart for uniLevel distribution\r\n    uint256 public totalDivCollection;\r\n    uint public globalDivDistPart = 0.6 ether;\r\n    uint public systemDistPart = 1 ether;   \r\n    uint public oneMonthDuration = 2592000; // = 30 days\r\n    uint public thisMonthEnd;\r\n    struct divPoolRecord\r\n    {\r\n        uint totalDividendCollection;\r\n        uint totalEligibleCount;\r\n    }\r\n    divPoolRecord[] public divPoolRecords;\r\n    mapping ( address => uint) public eligibleUser; // if val > 0 then user is eligible from this divPoolRecords;\r\n    mapping(uint => mapping ( address => bool)) public dividendReceived; // dividend index => user => true/false\r\n\r\n    struct autoPool\r\n    {\r\n        uint userID;\r\n        uint autoPoolParent;\r\n    }\r\n    mapping(uint => autoPool[]) public autoPoolLevel;  // users lavel records under auto pool scheme\r\n    uint lastlDCount; // To track total id/synced from last contract, so that in this contract id will start form next\r\n    mapping(address => mapping(uint => uint)) public autoPoolIndex; //to find index of user inside auto pool\r\n    uint[10] public nextMemberFillIndex;  // which auto pool index is in top of queue to fill in \r\n    uint[10] public nextMemberFillBox;   // 3 downline to each, so which downline need to fill in\r\n    uint[10][10] public autoPoolSubDist;\r\n    bool stopSwap;\r\n    mapping (address => userInfo)  userInfos;  // to see value two seperate 'view' functions created where userInfo can be checked by Id and by address both\r\n    mapping (uint => address )  userAddressByID; // this keeps user address with respect to id , will return id of given address\r\n    mapping(address => uint256) public totalGainInMainNetwork; //This is the withdrawable amount of user which he gains through main network, after each withdraw it becomes 0\r\n    mapping(address => uint256) public totalGainInUniLevel; // This is the withdrawable amount of user which he gains from unilevel network, after each withdraw it becomes 0\r\n    mapping(address => uint256) public totalGainInAutoPool; // This is the withdrawable amount of user from auto pool level after each withdraw it becomes 0 \r\n    mapping(address => uint256) public netTotalUserWithdrawable;  //Dividend is not included in it dividend is seperate pool which eligible user can withdraw after each next month\r\n    event regLevelEv(address indexed _userWallet, uint indexed _userID, uint indexed _referrerID, uint _time, address _refererWallet, uint _originalReferrer);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _user, address indexed _referredID, uint _level, uint _amount, uint _time);\r\n    event lostForLevelEv(address indexed _user, address indexed _referredID, uint _level, uint _amount, uint _time);\r\n    event payDividendEv(uint timeNow,uint payAmount,address paitTo);\r\n    event updateAutoPoolEv(uint timeNow,uint autoPoolLevelIndex,uint userIndexInAutoPool, address user);\r\n    event autoPoolPayEv(uint timeNow,address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst);\r\n    event paidForUniLevelEv(uint timeNow,address PaitTo,uint Amount);\r\n    uint[10] autoPoolCount;  // This variable is only useful for fetching auto pool records from old contract, once all records fetched it has no use\r\n    \r\n    constructor(address  ownerAddress) public {\r\n        owner = ownerAddress;\r\n\r\n        emit OwnershipTransferred(address(0), owner);\r\n\r\n        priceOfLevel[1] = 20 ether;\r\n        priceOfLevel[2] = 20 ether;\r\n        priceOfLevel[3] = 40 ether;\r\n        priceOfLevel[4] = 140 ether;\r\n        priceOfLevel[5] = 600 ether;\r\n        priceOfLevel[6] = 5000 ether;\r\n        priceOfLevel[7] = 5500 ether;\r\n        priceOfLevel[8] = 10000 ether;\r\n        priceOfLevel[9] = 20000 ether;\r\n        priceOfLevel[10] = 40000 ether;\r\n\r\n        distForLevel[1] = 10 ether;\r\n        distForLevel[2] = 15 ether;\r\n        distForLevel[3] = 30 ether;\r\n        distForLevel[4] = 120 ether;\r\n        distForLevel[5] = 500 ether;\r\n        distForLevel[6] = 4700 ether;\r\n        distForLevel[7] = 5000 ether;\r\n        distForLevel[8] = 9000 ether;\r\n        distForLevel[9] = 18000 ether;\r\n        distForLevel[10] = 35000 ether;\r\n\r\n        autoPoolDist[1] = 4 ether;\r\n        autoPoolDist[2] = 5 ether;\r\n        autoPoolDist[3] = 10 ether;\r\n        autoPoolDist[4] = 20 ether;\r\n        autoPoolDist[5] = 100 ether;\r\n        autoPoolDist[6] = 300 ether;\r\n        autoPoolDist[7] = 500 ether;\r\n        autoPoolDist[8] = 1000 ether;\r\n        autoPoolDist[9] = 2000 ether;\r\n        autoPoolDist[10] = 5000 ether;        \r\n\r\n        uniLevelDistPart[1] = 1 ether;\r\n        uniLevelDistPart[2] = 0.6 ether;\r\n        uniLevelDistPart[3] = 0.4 ether;\r\n\r\n        for (uint i = 4 ; i < 11; i++)\r\n        {\r\n           uniLevelDistPart[i] =  0.2 ether;\r\n        } \r\n\r\n        autoPool memory temp;\r\n        for (uint i = 11 ; i < 21; i++)\r\n        {\r\n           uniLevelDistPart[i] =  0.1 ether;\r\n           uint a = i-11;\r\n           autoPoolLevel[a].push(temp);\r\n           uint distPart = autoPoolDist[a+1];\r\n           autoPoolSubDist[a][0] = distPart * 1250 / 10000;\r\n           autoPoolSubDist[a][1] = distPart * 1250 / 10000;\r\n           autoPoolSubDist[a][2] = distPart * 1000 / 10000;\r\n           autoPoolSubDist[a][3] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][4] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][5] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][6] = distPart * 750 / 10000;\r\n           autoPoolSubDist[a][7] = distPart * 1000 / 10000;\r\n           autoPoolSubDist[a][8] = distPart * 1250 / 10000;                                                                             \r\n           autoPoolSubDist[a][9] = distPart * 1250 / 10000;\r\n        } \r\n\r\n    }\r\n\r\n    function ()  external {\r\n        revert();\r\n    }\r\n\r\n    // use findFreeReferrer function to get _parentID \r\n    function regUser(uint _referrerID, uint _parentID) public returns(bool) \r\n    {\r\n        //this saves gas while using this multiple times\r\n        address  msgSender = msg.sender; \r\n        if(!stopSwap) stopSwap = true;\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n        \r\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\r\n        uint fct = 1;\r\n        require(userInfos[userAddressByID[_parentID]].joined, 'freeReferrer not exist');\r\n\r\n        //transferring PAX tokens from smart user to smart contract for level 1\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[1]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            referrerID: _referrerID,\r\n            parentID: _parentID,\r\n            dReferred: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[lastIDCount] = msgSender;\r\n\r\n        userInfos[msgSender].levelExpired[1] = now + levelLifeTime;\r\n\r\n        userInfos[userAddressByID[_referrerID]].dReferred.push(msgSender);\r\n\r\n        totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n        netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n\r\n        if(thisMonthEnd < now) startNextMonth();\r\n\r\n        uint lastDivPoolIndex = divPoolRecords.length -1 ;\r\n        divPoolRecords[lastDivPoolIndex].totalDividendCollection += globalDivDistPart * fct;\r\n        totalDivCollection += globalDivDistPart * fct;\r\n\r\n        address usr = userAddressByID[_referrerID];\r\n        if(eligibleUser[usr] == 0)\r\n        {\r\n            if(userInfos[usr].dReferred.length == 10 )\r\n            {\r\n                eligibleUser[usr] = lastDivPoolIndex + 1;\r\n                divPoolRecords[lastDivPoolIndex].totalEligibleCount++;\r\n            }\r\n        }\r\n\r\n        require(payForLevel(1, msgSender,fct),\"pay for level fail\");\r\n        emit regLevelEv(msgSender, lastIDCount, _parentID, now,userAddressByID[_referrerID], _referrerID );\r\n        emit levelBuyEv(msgSender, 1, priceOfLevel[1] * fct, now);\r\n        require(updateNPayAutoPool(1,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n\r\n    function viewCurrentMonthDividend() public view returns(uint256 amount, uint256 indexCount)\r\n    {\r\n        uint256 length = divPoolRecords.length;\r\n        return (divPoolRecords[length-1].totalDividendCollection,length);\r\n    }\r\n\r\n    function buyLevel(uint _level) public returns(bool){\r\n        \r\n        //this saves gas while using this multiple times\r\n        address msgSender = msg.sender;   \r\n        \r\n        \r\n        //checking conditions\r\n        require(userInfos[msgSender].joined, 'User not exist'); \r\n        uint fct=1;\r\n        require(_level >= 1 && _level <= 10, 'Incorrect level');\r\n        \r\n        //transfer tokens\r\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\r\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[_level]),\"token transfer failed\");\r\n        }\r\n        else\r\n        {\r\n            fct = 0;\r\n        }\r\n        \r\n        \r\n        //updating variables\r\n        if(_level == 1) {\r\n            userInfos[msgSender].levelExpired[1] += levelLifeTime;\r\n        }\r\n        else {\r\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[msgSender].levelExpired[l] >= now, 'Buy the previous level');\r\n\r\n            if(userInfos[msgSender].levelExpired[_level] == 0) userInfos[msgSender].levelExpired[_level] = now + levelLifeTime;\r\n            else userInfos[msgSender].levelExpired[_level] += levelLifeTime;\r\n        }\r\n\r\n        require(payForLevel(_level, msgSender,fct),\"pay for level fail\");\r\n        emit levelBuyEv(msgSender, _level, priceOfLevel[_level] * fct, now);\r\n        require(updateNPayAutoPool(_level,msgSender,fct),\"auto pool update fail\");\r\n        return true;\r\n    }\r\n    \r\n\r\n    function payForLevel(uint _level, address _user,uint fct) internal returns (bool){\r\n        address referer;\r\n        address referer1;\r\n        address referer2;\r\n        address referer3;\r\n        address referer4;\r\n\r\n        if(_level == 1 || _level == 6) {\r\n            referer = userAddressByID[userInfos[_user].referrerID];\r\n            payForUniLevel(userInfos[_user].referrerID,fct);\r\n            totalGainInMainNetwork[owner] += systemDistPart * fct;\r\n            netTotalUserWithdrawable[owner] += systemDistPart * fct;\r\n        }\r\n        else if(_level == 2 || _level == 7) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer = userAddressByID[userInfos[referer1].referrerID];\r\n        }\r\n        else if(_level == 3 || _level == 8) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer = userAddressByID[userInfos[referer2].referrerID];\r\n        }\r\n        else if(_level == 4 || _level == 9) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer = userAddressByID[userInfos[referer3].referrerID];\r\n        }\r\n        else if(_level == 5 || _level == 10) {\r\n            referer1 = userAddressByID[userInfos[_user].referrerID];\r\n            referer2 = userAddressByID[userInfos[referer1].referrerID];\r\n            referer3 = userAddressByID[userInfos[referer2].referrerID];\r\n            referer4 = userAddressByID[userInfos[referer3].referrerID];\r\n            referer = userAddressByID[userInfos[referer4].referrerID];\r\n        }\r\n\r\n\r\n        if(!userInfos[referer].joined) referer = userAddressByID[defaultRefID];\r\n\r\n       \r\n        if(userInfos[referer].levelExpired[_level] >= now) {\r\n            totalGainInMainNetwork[referer] += distForLevel[_level] * fct;\r\n            netTotalUserWithdrawable[referer] += distForLevel[_level] * fct;\r\n            emit paidForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\r\n\r\n        }\r\n        else{\r\n\r\n            emit lostForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\r\n            payForLevel(_level, referer,fct);\r\n\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n    function findFreeReferrerByAddress(address _user) public view returns(uint) {\r\n        if(userInfos[_user].dReferred.length < maxDownLimit) return userInfos[_user].id;\r\n\r\n        address[] memory downLine = new address[](126);\r\n        downLine[0] = userInfos[_user].dReferred[0];\r\n        downLine[1] = userInfos[_user].dReferred[1];\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n            if(userInfos[downLine[i]].dReferred.length == maxDownLimit) {\r\n                if(i < 62) {\r\n                    downLine[(i+1)*2] = userInfos[downLine[i]].dReferred[0];\r\n                    downLine[(i+1)*2+1] = userInfos[downLine[i]].dReferred[1];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = downLine[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return userInfos[freeReferrer].id;\r\n    }\r\n\r\n    function findFreeReferrerByID(uint _userID) public view returns(uint) {\r\n        return findFreeReferrerByAddress(userAddressByID[_userID]);\r\n    }\r\n\r\n\r\n\r\n\r\n    function payForUniLevel(uint _referrerID, uint fct) internal returns(bool)\r\n    {\r\n        uint256 endID = 21;\r\n        for (uint i = 0 ; i < endID; i++)\r\n        {\r\n            address usr = userAddressByID[_referrerID];\r\n            _referrerID = userInfos[usr].referrerID;\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n            uint Amount = uniLevelDistPart[i + 1 ]  * fct;\r\n            totalGainInUniLevel[usr] += Amount;\r\n            netTotalUserWithdrawable[usr] += Amount;\r\n            emit paidForUniLevelEv(now,usr, Amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    event withdrawMyGainEv(uint timeNow,address caller,uint totalAmount);\r\n    function withdrawMyDividendNAll() public returns(uint)\r\n    {\r\n        address  caller = msg.sender;\r\n        require(userInfos[caller].joined, 'User not exist');\r\n        uint from = eligibleUser[caller];\r\n        uint totalAmount;\r\n        if(from > 0)\r\n        {\r\n            from --;\r\n            uint lastDivPoolIndex = divPoolRecords.length;\r\n            if( lastDivPoolIndex > 1 )\r\n            {\r\n                lastDivPoolIndex = lastDivPoolIndex -2;\r\n\r\n                for(uint i=0;i<150;i++)\r\n                {\r\n                    if(lastDivPoolIndex < i) break;\r\n                    uint curIndex = lastDivPoolIndex - i;\r\n                    if( curIndex >= from && !dividendReceived[curIndex][caller] )\r\n                    {\r\n                        totalAmount +=  ( divPoolRecords[curIndex].totalDividendCollection * 10000000000 /  divPoolRecords[curIndex].totalEligibleCount ) / 10000000000;\r\n                        dividendReceived[curIndex][caller] = true;\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        if(totalAmount > 0)\r\n        {\r\n            totalDivCollection -= totalAmount;\r\n            emit payDividendEv(now, totalAmount, caller);\r\n        }\r\n        totalAmount = totalAmount + netTotalUserWithdrawable[caller];\r\n        netTotalUserWithdrawable[caller] = 0;\r\n        totalGainInAutoPool[caller] = 0;\r\n        totalGainInMainNetwork[caller] = 0;\r\n        totalGainInUniLevel[caller] = 0;\r\n        require(paxInterface(paxTokenAddress).transfer(msg.sender, totalAmount),\"token transfer failed\");\r\n        emit withdrawMyGainEv(now, caller, totalAmount);\r\n        \r\n    }\r\n\r\n    function viewMyDividendPotential(address user) public view returns(uint256 totalDivPotential, uint256 lastUnPaidIndex)\r\n    {\r\n        if (eligibleUser[user] > 0 )\r\n        {\r\n            uint256 i;\r\n            uint256 lastIndex = divPoolRecords.length -1;\r\n            for(i=1;i<50;i++)\r\n            {\r\n                lastUnPaidIndex = lastIndex - i;\r\n                if(dividendReceived[lastUnPaidIndex][user] == true) break;\r\n                totalDivPotential = totalDivPotential + ( divPoolRecords[lastUnPaidIndex].totalDividendCollection * 10000000000 /  divPoolRecords[lastUnPaidIndex].totalEligibleCount);               \r\n            }\r\n            return (totalDivPotential, lastUnPaidIndex + 1);\r\n        }\r\n        return (0,0);\r\n    }\r\n\r\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[10] memory timeSinceJoined )\r\n    {\r\n        if(userInfos[usr].joined)\r\n        {\r\n            for(uint256 i=0;i<10;i++)\r\n            {\r\n                uint256 t = userInfos[usr].levelExpired[i+1];\r\n                if(t>now)\r\n                {\r\n                    timeSinceJoined[i] = (t-now);\r\n                }\r\n            }\r\n        }\r\n        return timeSinceJoined;\r\n    }\r\n\r\n    \r\n    \r\n    function divPoolAllLevel() public view returns (uint256[10] memory divPoolArray)\r\n    {\r\n        for(uint256 i=0;i<10;i++)\r\n        {\r\n            divPoolArray[i] = divPoolRecords[i].totalDividendCollection;\r\n        }\r\n        return divPoolArray;\r\n    }\r\n    \r\n\r\n    function startNextMonth() public returns(bool)\r\n    {\r\n        require(thisMonthEnd < now,\"month end not reached\");\r\n        thisMonthEnd = now + oneMonthDuration;\r\n        divPoolRecord memory temp;\r\n        temp.totalEligibleCount = 1;\r\n        divPoolRecords.push(temp);\r\n        uint lastDivPoolIndex = divPoolRecords.length -1;\r\n        if (lastDivPoolIndex > 0)\r\n        {\r\n            divPoolRecords[lastDivPoolIndex].totalEligibleCount = divPoolRecords[lastDivPoolIndex -1].totalEligibleCount;\r\n            lastlDCount++;\r\n        }\r\n        return (true);\r\n    }\r\n\r\n    function updateNPayAutoPool(uint _level,address _user, uint fct) internal returns (bool)\r\n    {\r\n        uint a = _level -1;\r\n        uint len = autoPoolLevel[a].length;\r\n        autoPool memory temp;\r\n        temp.userID = userInfos[_user].id;\r\n        temp.autoPoolParent = nextMemberFillIndex[a];       \r\n        autoPoolLevel[a].push(temp);        \r\n        uint idx = nextMemberFillIndex[a];\r\n\r\n        address  usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n        if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        for(uint i=0;i<10;i++)\r\n        {\r\n            uint amount = autoPoolSubDist[a][i]  * fct;\r\n            totalGainInAutoPool[usr] += amount;\r\n            netTotalUserWithdrawable[usr] += amount;\r\n            emit autoPoolPayEv(now, usr,a+1, amount, _user);\r\n            idx = autoPoolLevel[a][idx].autoPoolParent; \r\n            usr = userAddressByID[autoPoolLevel[a][idx].userID];\r\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\r\n        }\r\n\r\n        if(nextMemberFillBox[a] == 0)\r\n        {\r\n            nextMemberFillBox[a] = 1;\r\n        }   \r\n        else if (nextMemberFillBox[a] == 1)\r\n        {\r\n            nextMemberFillBox[a] = 2;\r\n        }\r\n        else\r\n        {\r\n            nextMemberFillIndex[a]++;\r\n            nextMemberFillBox[a] = 0;\r\n        }\r\n        autoPoolIndex[_user][_level - 1] = len;\r\n        emit updateAutoPoolEv(now, _level, len, _user);\r\n        return true;\r\n    }\r\n\r\n\r\n    function viewUserdReferred(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].dReferred;\r\n    }\r\n\r\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\r\n        return userInfos[_user].levelExpired[_level];\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    \r\n    /*======================================\r\n    =            ADMIN FUNCTIONS           =\r\n    ======================================*/\r\n    \r\n    function changePAXaddress(address newPAXaddress) onlyOwner public returns(string memory){\r\n        //if owner makes this 0x0 address, then it will halt all the operation of the contract. This also serves as security feature.\r\n        //so owner can halt it in any problematic situation. Owner can then input correct address to make it all come back to normal.\r\n        paxTokenAddress = newPAXaddress;\r\n        return(\"PAX address updated successfully\");\r\n    }\r\n\r\n\r\n\r\n    \r\n    function changeDefaultRefID(uint newDefaultRefID) onlyOwner public returns(string memory){\r\n        //this ref ID will be assigned to user who joins without any referredIDs ID.\r\n        defaultRefID = newDefaultRefID;\r\n        return(\"Default Ref ID updated successfully\");\r\n    }\r\n\r\n    function userInfoS(address usr) public view returns(bool joined, uint id, uint parent, uint referrer, address[10] memory direct,uint[10] memory levelExpired)\r\n    {\r\n        joined = userInfos[usr].joined;\r\n        id = userInfos[usr].id;\r\n        parent = userInfos[usr].parentID;\r\n        referrer = userInfos[usr].referrerID;\r\n        uint len = userInfos[usr].dReferred.length;\r\n        for (uint i=0;i<len;i++)\r\n        {\r\n            direct[i] = userInfos[usr].dReferred[i];\r\n        }\r\n        for (uint i=1;i<=10;i++)\r\n        {\r\n            levelExpired[i-1] = userInfos[usr].levelExpired[i];\r\n        }  \r\n        return (joined, id, parent, referrer, direct, levelExpired) ;     \r\n    }\r\n\r\n    function getUserAddressById(uint id) public view returns(address)\r\n    {\r\n        if(id>0 && id <= lastIDCount)\r\n        {\r\n            return userAddressByID[id];\r\n        }\r\n        return address(0);\r\n    }\r\n\r\n\r\n\r\n    //*********************************************************************************************/\r\n    //*********************All below functions are only for swaping purpose ********************** /\r\n    //******** these functions will not work twice updating for any record even by admin **********/\r\n    //******** this is a trust of public and responsibility of admin to make sure all *************/\r\n    //******** updated records are perfectly matching with old contract which *********************/\r\n    //****************** any user can verify by comparing it with old records**********************/\r\n\r\n    //***** All these functions written in a way that once sysncing complete can not be caalled again *********/\r\n\r\n\r\n    // this is only to set first id will work only once\r\n    function setFirstID() public returns (string memory)\r\n    {\r\n        address msgSender = msg.sender;\r\n        require(!userInfos[msgSender].joined, \"can't create first id twice\");\r\n        require(lastlDCount == 0 , \"can't create first id twice\"); \r\n        ( uint _id,uint _parentID ) = viewUserInfos(msg.sender);\r\n        userInfo memory UserInfo;\r\n        UserInfo.joined = true;\r\n        UserInfo.id = _id;\r\n        UserInfo.parentID = _parentID;\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[_id] = msgSender;\r\n        for(uint i = 1; i <= 10; i++) {\r\n            userInfos[msgSender].levelExpired[i] = 99999999999;\r\n        }\r\n        autoPool memory temp;\r\n        for (uint i = 0 ; i < 10; i++)\r\n        {\r\n           temp.userID = _id;  \r\n           autoPoolLevel[i].push(temp);\r\n           autoPoolIndex[msgSender][i] = _id;\r\n        } \r\n        eligibleUser[msgSender] = 1;\r\n        lastIDCount ++;\r\n    }\r\n\r\n    function viewUserInfos(address userAddress) public view returns(uint _id, uint _parentID)\r\n    {\r\n        ( ,_id,_parentID) = interfaceOldBMContract(oldBMContractAddress).userInfos(userAddress);\r\n        return (_id,_parentID);\r\n    }\r\n\r\n    function setGlobalVariables() public onlyOwner returns(bool)\r\n    {\r\n        require(thisMonthEnd==0, \"can't be called twice\");\r\n        totalDivCollection = interfaceOldBMContract(oldBMContractAddress).totalDivCollection();\r\n        thisMonthEnd = interfaceOldBMContract(oldBMContractAddress).thisMonthEnd();\r\n        for(uint i =0; i < 10; i++)\r\n        {\r\n            nextMemberFillIndex[i] = interfaceOldBMContract(oldBMContractAddress).nextMemberFillIndex(i);\r\n            nextMemberFillBox[i] = interfaceOldBMContract(oldBMContractAddress).nextMemberFillBox(i);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setEligibleUsers(address[] memory _users,uint divIndex) public onlyOwner returns(bool)\r\n    {\r\n        require(divPoolRecords[divIndex].totalEligibleCount == 0 , \"can't run twice\" );\r\n        require(!stopSwap , \"can't run now was for swaping only\");\r\n        uint len = _users.length;\r\n        for (uint i=0;i<len;i++)\r\n        {\r\n            eligibleUser[_users[i]] = divIndex + 1;\r\n        }\r\n        if(divIndex == 0 ) divPoolRecords[divIndex].totalEligibleCount++;  // this is for id 1 \r\n        divPoolRecords[divIndex].totalEligibleCount += ( divIndex * divPoolRecords[divIndex-1].totalEligibleCount ) + len;\r\n        return true;\r\n    }\r\n\r\n    function setDividendPoolData(uint _totalDividendCollection, uint _totalDividendCollection2 ) public onlyOwner returns(bool)\r\n    {\r\n        require(totalDivCollection == 0, \"can't run twice\");\r\n        divPoolRecord memory temp;\r\n        temp.totalDividendCollection = _totalDividendCollection;\r\n        divPoolRecords.push(temp);\r\n        divPoolRecord memory temp2;\r\n        temp2.totalDividendCollection = _totalDividendCollection2;\r\n        divPoolRecords.push(temp);        \r\n        return (true);\r\n    }\r\n\r\n    function setLastIDCount(uint _lastIDCountOfOldContract) public onlyOwner returns(bool)\r\n    {\r\n        require(lastIDCount == 1, \"can't run twice\");\r\n        lastIDCount = _lastIDCountOfOldContract;\r\n        return true;\r\n    }\r\n\r\n    function setUserInfos( uint _id,uint _parentID ) public onlyOwner returns(bool)\r\n    {\r\n            require(_id >= 1 && _id <= lastIDCount, \"can't run twice for same id or non-existing in old\");\r\n            address _user = interfaceOldBMContract(oldBMContractAddress).userAddressByID(_id);\r\n            require(!stopSwap , \"can't run now was for swaping only\");\r\n            userInfo memory UserInfo;\r\n            UserInfo.joined = true;\r\n            UserInfo.id = _id;\r\n            UserInfo.parentID = _parentID;\r\n            userInfos[_user] =UserInfo;\r\n            userAddressByID[_id] = _user;\r\n            uint _levelExpired;\r\n            for(uint i = 1; i <= 10; i++) {\r\n                _levelExpired = interfaceOldBMContract(oldBMContractAddress).viewUserLevelExpired(_user, i);\r\n                userInfos[_user].levelExpired[i] = _levelExpired;\r\n            }\r\n        return true;\r\n    }\r\n\r\n    function setAutoPool(uint level, uint recordCount) public onlyOwner returns(bool)\r\n    {\r\n        require(level <= 10 && level > 0, \"invalid level\");\r\n        require(!stopSwap , \"can't run now was for swaping only\");\r\n        uint a = level -1;\r\n        uint tmp = autoPoolCount[a];\r\n        autoPool memory temp;\r\n        for (uint i = autoPoolCount[a]; i<tmp + recordCount; i++)\r\n        {\r\n            (uint _id,uint _parentID) = interfaceOldBMContract(oldBMContractAddress).autoPoolLevel(tmp,i);\r\n            if(_id > 1 )\r\n            {\r\n                temp.userID = _id;\r\n                temp.autoPoolParent = _parentID;\r\n                autoPoolLevel[a].push(temp);\r\n                autoPoolIndex[userAddressByID[_id]][a] = autoPoolLevel[a].length -1;\r\n            }\r\n        }\r\n        autoPoolCount[a] = tmp + recordCount; \r\n        return true;\r\n    }\r\n\r\n    function setReferrerNDirect(uint _id, uint _referrer, address[] memory direct) public onlyOwner returns(bool)\r\n    {\r\n        address usr = userAddressByID[_id];\r\n        require(!stopSwap , \"can't run now was for swaping only\");\r\n        userInfos[usr].referrerID = _referrer;\r\n        uint len = direct.length;\r\n        for (uint i=0;i<len;i++)\r\n        {\r\n            userInfos[usr].dReferred.push(direct[i]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function updateAddresses(address _paxTokenAddress,address _oldBMContractAddress,address _specialAddress1,address _specialAddress2 ) public onlyOwner returns (bool)\r\n    {\r\n        require(!stopSwap , \"can't run now was for swaping only\");\r\n        paxTokenAddress = _paxTokenAddress;\r\n        oldBMContractAddress = _oldBMContractAddress;\r\n        specialAddress1 = _specialAddress1;\r\n        specialAddress2 = _specialAddress2;\r\n        return true;\r\n    }\r\n\r\n}"}}}