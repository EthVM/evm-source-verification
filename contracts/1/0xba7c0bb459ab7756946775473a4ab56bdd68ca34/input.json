{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/AbqErc20.sol":{"content":"// SPDX-License-Identifier:MIT\r\npragma solidity >=0.7.0;\r\nimport \"./SafeMathTyped.sol\";\r\n\r\n// The MIT License\r\n//\r\n// Copyright (c) 2017-2018 0xcert, d.o.o. https://0xcert.org\r\n// \r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// \r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n/**\r\n * @title ERC20 standard token implementation.\r\n * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\r\n */\r\ncontract Token\r\n{\r\n  string internal tokenName;\r\n\r\n  string internal tokenSymbol;\r\n\r\n  uint8 internal tokenDecimals;\r\n\r\n  uint256 internal tokenTotalSupply;\r\n\r\n  mapping (address => uint256) internal balances;\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n   * @dev Trigger when tokens are transferred, including zero value transfers.\r\n   */\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  /**\r\n   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\r\n   */\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = tokenName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = tokenSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals the token uses.\r\n   */\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (uint8 _decimals)\r\n  {\r\n    _decimals = tokenDecimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the total token supply.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256 _totalSupply)\r\n  {\r\n    _totalSupply = tokenTotalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the account balance of another account with address _owner.\r\n   * @param _owner The address from which the balance will be retrieved.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _balance)\r\n  {\r\n    _balance = balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\r\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\r\n   * @param _to The address of the recipient.\r\n   * @param _value The amount of token to be transferred.\r\n   */\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = SafeMathTyped.sub256(balances[msg.sender], _value);\r\n    balances[_to] = SafeMathTyped.add256(balances[_to], _value);\r\n\r\n    emit Transfer(msg.sender, _to, _value);\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\r\n   * this function is called again it overwrites the current allowance with _value.\r\n   * @param _spender The address of the account able to transfer the tokens.\r\n   * @param _value The amount of tokens to be approved for transfer.\r\n   */\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n\r\n    emit Approval(msg.sender, _spender, _value);\r\n    _success = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\r\n   * @param _owner The address of the account owning tokens.\r\n   * @param _spender The address of the account able to transfer the tokens.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    external\r\n    view\r\n    returns (uint256 _remaining)\r\n  {\r\n    _remaining = allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\r\n   * Transfer event.\r\n   * @param _from The address of the sender.\r\n   * @param _to The address of the recipient.\r\n   * @param _value The amount of token to be transferred.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool _success)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = SafeMathTyped.sub256(balances[_from], _value);\r\n    balances[_to] = SafeMathTyped.add256(balances[_to], _value);\r\n    allowed[_from][msg.sender] = SafeMathTyped.sub256(allowed[_from][msg.sender], _value);\r\n\r\n    emit Transfer(_from, _to, _value);\r\n    _success = true;\r\n  }\r\n\r\n}\r\n\r\n/// @notice This is the ABQ token. It allows the owner (the Aardbanq DAO) to mint new tokens. It also allow the \r\n/// owner to change owners. The ABQ token has 18 decimals.\r\ncontract AbqErc20 is Token\r\n{\r\n    /// @notice The owner of the ABQ Token. This is the Aardbanq DAO.\r\n    address public owner;\r\n    /// @notice The address for the founders' contract.\r\n    address public founderContract;\r\n\r\n    constructor(address _owner, address _founderContract)\r\n    {\r\n        tokenName = \"Aardbanq DAO\";\r\n        tokenSymbol = \"ABQ\";\r\n        tokenDecimals = 18;\r\n        tokenTotalSupply = 0;\r\n        owner = _owner;\r\n        founderContract = _founderContract;\r\n    }\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"ABQ/only-owner\");\r\n        _;\r\n    }\r\n\r\n    event OwnerChange(address indexed newOwner);\r\n    /// @notice Allows the owner to change the ownership to another address.\r\n    /// @param _newOwner The address that should be the new owner.\r\n    function changeOwner(address _newOwner)\r\n        external\r\n        onlyOwner()\r\n    {\r\n        owner = _newOwner;\r\n        emit OwnerChange(_newOwner);\r\n    }\r\n\r\n    /// @notice Allows the owner to mint tokens.\r\n    /// @param _target The address to mint the tokens to.\r\n    /// @param _abqAmount The amount of ABQ to mint.\r\n    function mint(address _target, uint256 _abqAmount)\r\n        external\r\n        onlyOwner()\r\n    {\r\n        balances[_target] = SafeMathTyped.add256(balances[_target], _abqAmount);\r\n        emit Transfer(address(0), _target, _abqAmount);\r\n\r\n        // CG: Founder's part 15% of total that will be issued\r\n        // MATH:\r\n        // totalIncrease = mintAmount + founderPart {A}\r\n        // also:\r\n        // founderPart = 0.15 * totalIncrease\r\n        // ... founderPart / 0.15 = totalIncrease   {B}\r\n        // substituting {A} in {B}\r\n        // ... founderPart / 0.15 = mintAmount + founderPart\r\n        // ... (founderPart / 0.15) - founderPart = mintAmount\r\n        // ... (founderPart - (0.15 * founderPart)) / 0.15 = mintAmount\r\n        // ... (0.85 * founderPart) / 0.15 = mintAmount\r\n        // ... 0.85 * founderPart = 0.15 * mintAmount\r\n        // ... founderPart = (0.15 / 0.85) * mintAmount\r\n        // ... founderPart ~= (mintAmount * 17647) / 100000\r\n        uint256 founderShare = SafeMathTyped.mul256(_abqAmount, 17647) / 100000;\r\n        balances[founderContract] = SafeMathTyped.add256(balances[founderContract], founderShare);\r\n        tokenTotalSupply = SafeMathTyped.add256(SafeMathTyped.add256(tokenTotalSupply, _abqAmount), founderShare);\r\n        emit Transfer(address(0), founderContract, founderShare);\r\n    }\r\n\r\n    /// @notice Allow the sender to burn tokens in their account.\r\n    /// @param _abqAmount The amount of tokens to burn from the msg.sender account.\r\n    function burn(uint256 _abqAmount)\r\n      external\r\n    {\r\n      tokenTotalSupply = SafeMathTyped.sub256(tokenTotalSupply, _abqAmount);\r\n      balances[msg.sender] = SafeMathTyped.sub256(balances[msg.sender], _abqAmount);\r\n      emit Transfer(msg.sender, address(0), _abqAmount);\r\n    }\r\n\r\n    event NameChange(string newName);\r\n    /// @notice Allow the owner to change the name of the token. \r\n    /// @param _newName The new name for the token\r\n    function changeName(string calldata _newName)\r\n      external\r\n      onlyOwner()\r\n    {\r\n      tokenName = _newName;\r\n      emit NameChange(_newName);\r\n    }\r\n\r\n    event SymbolChange(string newSymbol);\r\n    /// @notice Allow the owner to change the symbol of the token.\r\n    /// @param _newSymbol The new symbol for the token.\r\n    function changeSymbol(string calldata _newSymbol)\r\n      external\r\n      onlyOwner()\r\n    {\r\n      tokenSymbol = _newSymbol;\r\n      emit SymbolChange(_newSymbol);\r\n    }\r\n}"},"contracts/DelegateOwnershipManager.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\nimport \"./Minter.sol\";\r\nimport \"./AbqErc20.sol\";\r\n\r\n/// @notice A delegate ownership manager to allow minting permissions to be set independent of ownership on the ABQ token.\r\ncontract DelegateOwnershipManager is Minter\r\n{\r\n    /// @notice The ABQ token.\r\n    AbqErc20 public abqToken;\r\n    /// @notice The owner of the DelegateOwnershipManager. This should be the Aardbanq DAO.\r\n    address public owner;\r\n    /// @notice The addresses that have mint permissions.\r\n    mapping(address => bool) public mintPermission;\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(msg.sender == owner, \"ABQ/only-owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrMintPermission()\r\n    {\r\n        require(msg.sender == owner || mintPermission[msg.sender], \"ABQ/only-owner-or-mint-permission\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Construct a DelegateOwnershipManager.\r\n    /// @param _abqToken The ABQ token.\r\n    /// @param _owner The owner for this contract. This should be the Aardbanq DAO.\r\n    constructor (AbqErc20 _abqToken, address _owner)\r\n    {\r\n        abqToken = _abqToken;\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @notice Event emitted when minting permission is set.\r\n    /// @param target The address to set permission for.\r\n    /// @param mayMint The permission state.\r\n    event MintPermission(address indexed target, bool mayMint);\r\n    /// @notice Set minting permission for a given address.\r\n    /// @param _target The address to set minting permission for.\r\n    /// @param _mayMint If set to true the _target address will be allowed to mint.\r\n    function setMintPermission(address _target, bool _mayMint)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        mintPermission[_target] = _mayMint;\r\n        emit MintPermission(_target, _mayMint);\r\n    }\r\n\r\n    /// @notice The event emitted if the owner is changed.\r\n    /// @param newOwner The new owner for this contract.\r\n    event OwnerChange(address indexed newOwner);\r\n    /// @notice Allows the owner to change the ownership to another address.\r\n    /// @param _newOwner The address that should be the new owner.\r\n    function changeThisOwner(address _newOwner)\r\n        external\r\n        onlyOwner()\r\n    {\r\n        owner = _newOwner;\r\n        emit OwnerChange(_newOwner);\r\n    }\r\n\r\n    /// @notice Mint tokens should the msg.sender has permission to mint.\r\n    /// @param _target The address to mint tokens to.\r\n    /// @param _amount The amount of tokens to mint.\r\n    function mint(address _target, uint256 _amount)\r\n        onlyOwnerOrMintPermission()\r\n        override\r\n        external\r\n    {\r\n        abqToken.mint(_target, _amount);\r\n    }\r\n\r\n    /// @notice Change the owner of the token. Only the owner may call this.\r\n    /// @param _newOwner The new owner of the token.\r\n    function changeTokenOwner(address _newOwner)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        abqToken.changeOwner(_newOwner);\r\n    }\r\n\r\n    /// @notice Change the name of the token. Only the owner may call this.\r\n    function changeName(string calldata _newName)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        abqToken.changeName(_newName);\r\n    }\r\n\r\n    /// @notice Change the symbol of the token. Only the owner may call this.\r\n    function changeSymbol(string calldata _newSymbol)\r\n        onlyOwner()\r\n        external\r\n    {\r\n        abqToken.changeSymbol(_newSymbol);\r\n    }\r\n}"},"contracts/Minter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n// This code is the property of the Aardbanq DAO.\r\n// The Aardbanq DAO is located at 0x829c094f5034099E91AB1d553828F8A765a3DaA1 on the Ethereum Main Net.\r\n// It is the author's wish that this code should be open sourced under the MIT license, but the final \r\n// decision on this would be taken by the Aardbanq DAO with a vote once sufficient ABQ tokens have been \r\n// distributed.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\npragma solidity >=0.7.0;\r\n\r\ninterface Minter\r\n{\r\n    function mint(address _target, uint256 _amount) external;\r\n}"},"contracts/SafeMathTyped.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMathTyped {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"uint256 overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"Can't divide by 0\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"uint256 underflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"uint256 overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"Can't mod by 0\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the greater of two numbers\r\n    */\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the lesser of two numbers\r\n    */\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}"}}}