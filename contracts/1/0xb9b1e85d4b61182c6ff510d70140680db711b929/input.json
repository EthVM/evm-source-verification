{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"HoldefiV1.1/HoldefiOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\n/// @title HoldefiOwnable\n/// @author Holdefi Team\n/// @notice Taking ideas from Open Zeppelin's Ownable contract\n/// @dev Contract module which provides a basic access control mechanism, where\n/// there is an account (an owner) that can be granted exclusive access to\n/// specific functions.\n///\n/// By default, the owner account will be the one that deploys the contract. This\n/// can later be changed with {transferOwnership}.\n///\n/// This module is used through inheritance. It will make available the modifier\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\n/// the owner.\n/// @dev Error codes description: \n///     OE01: Sender should be the owner\n///     OE02: New owner can not be zero address\n///     OE03: Pending owner is empty\n///     OE04: Pending owner is not same as the `msg.sender`\ncontract HoldefiOwnable {\n    address public owner;\n    address public pendingOwner;\n\n    /// @notice Event emitted when an ownership transfer request is recieved\n    event OwnershipTransferRequested(address newPendingOwner);\n\n    /// @notice Event emitted when an ownership transfer request is accepted by the pending owner\n    event OwnershipTransferred(address newOwner, address oldOwner);\n\n    /// @notice Initializes the contract owner\n    constructor () public {\n        owner = msg.sender;\n        emit OwnershipTransferred(owner, address(0));\n    }\n\n    /// @notice Throws if called by any account other than the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OE01\");\n        _;\n    }\n\n    /// @notice Transfers ownership of the contract to a new owner\n    /// @dev Can only be called by the current owner\n    /// @param newOwner Address of new owner\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"OE02\");\n        pendingOwner = newOwner;\n\n        emit OwnershipTransferRequested(newOwner);\n    }\n\n    /// @notice Pending owner accepts ownership of the contract\n    /// @dev Only Pending owner can call this function\n    function acceptTransferOwnership () external {\n        require (pendingOwner != address(0), \"OE03\");\n        require (pendingOwner == msg.sender, \"OE04\");\n        \n        emit OwnershipTransferred(pendingOwner, owner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}"},"HoldefiV1.1/HoldefiSettings.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./HoldefiOwnable.sol\";\r\n\r\n/// @notice File: contracts/Holdefi.sol\r\ninterface HoldefiInterface {\r\n\tstruct Market {\r\n\t\tuint256 totalSupply;\r\n\t\tuint256 supplyIndex;\r\n\t\tuint256 supplyIndexUpdateTime;\r\n\r\n\t\tuint256 totalBorrow;\r\n\t\tuint256 borrowIndex;\r\n\t\tuint256 borrowIndexUpdateTime;\r\n\r\n\t\tuint256 promotionReserveScaled;\r\n\t\tuint256 promotionReserveLastUpdateTime;\r\n\t\tuint256 promotionDebtScaled;\r\n\t\tuint256 promotionDebtLastUpdateTime;\r\n\t}\r\n\r\n\tfunction marketAssets(address market) external view returns (Market memory);\r\n\tfunction holdefiSettings() external view returns (address contractAddress);\r\n\tfunction beforeChangeSupplyRate (address market) external;\r\n\tfunction beforeChangeBorrowRate (address market) external;\r\n\tfunction reserveSettlement (address market) external;\r\n}\r\n\r\n/// @title HoldefiSettings contract\r\n/// @author Holdefi Team\r\n/// @notice This contract is for Holdefi settings implementation\r\n/// @dev Error codes description: \r\n/// \tSE01: Market is not exist\r\n/// \tSE02: Collateral is not exist\r\n/// \tSE03: Conflict with Holdefi contract\r\n/// \tSE04: The contract should be set once\r\n/// \tSE05: Rate should be in the allowed range\r\n/// \tSE06: Sender should be Holdefi contract\r\n/// \tSE07: Collateral is exist\r\n/// \tSE08: Market is exist\r\n/// \tSE09: Market list is full\r\n/// \tSE10: Total borrow is not zero\r\n/// \tSE11: Changing rate is not allowed at this time\r\n/// \tSE12: Changing rate should be less than Max allowed\r\ncontract HoldefiSettings is HoldefiOwnable {\r\n\r\n\tusing SafeMath for uint256;\r\n\r\n\t/// @notice Markets Features\r\n\tstruct MarketSettings {\r\n\t\tbool isExist;\t\t// Market is exist or not\r\n\t\tbool isActive;\t\t// Market is open for deposit or not\r\n\r\n\t\tuint256 borrowRate;\r\n\t\tuint256 borrowRateUpdateTime;\r\n\r\n\t\tuint256 suppliersShareRate;\r\n\t\tuint256 suppliersShareRateUpdateTime;\r\n\r\n\t\tuint256 promotionRate;\r\n\t}\r\n\r\n\t/// @notice Collateral Features\r\n\tstruct CollateralSettings {\r\n\t\tbool isExist;\t\t// Collateral is exist or not\r\n\t\tbool isActive;\t\t// Collateral is open for deposit or not\r\n\r\n\t\tuint256 valueToLoanRate;\r\n\t\tuint256 VTLUpdateTime;\r\n\r\n\t\tuint256 penaltyRate;\r\n\t\tuint256 penaltyUpdateTime;\r\n\r\n\t\tuint256 bonusRate;\r\n\t}\r\n\r\n\tuint256 constant private rateDecimals = 10 ** 4;\r\n\r\n\taddress constant private ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n\tuint256 constant private periodBetweenUpdates = 604800;      \t// seconds per week\r\n\r\n\tuint256 constant private maxBorrowRate = 4000;      \t\t\t// 40%\r\n\r\n\tuint256 constant private borrowRateMaxIncrease = 500;      \t\t// 5%\r\n\r\n\tuint256 constant private minSuppliersShareRate = 5000;      \t// 50%\r\n\r\n\tuint256 constant private suppliersShareRateMaxDecrease = 500;\t// 5%\r\n\r\n\tuint256 constant private maxValueToLoanRate = 20000;      \t\t// 200%\r\n\r\n\tuint256 constant private valueToLoanRateMaxIncrease = 500;      // 5%\r\n\r\n\tuint256 constant private maxPenaltyRate = 13000;      \t\t\t// 130%\r\n\r\n\tuint256 constant private penaltyRateMaxIncrease = 500;      \t// 5%\r\n\r\n\tuint256 constant private maxPromotionRate = 10000;\t\t\t\t// 100%\r\n\r\n\tuint256 constant private maxListsLength = 50;\r\n\r\n\t/// @dev Used for calculating liquidation threshold \r\n\t/// There is 5% gap between value to loan rate and liquidation rate\r\n\tuint256 constant private fivePercentLiquidationGap = 500;\r\n\r\n\tmapping (address => MarketSettings) public marketAssets;\r\n\taddress[] public marketsList;\r\n\r\n\tmapping (address => CollateralSettings) public collateralAssets;\r\n\r\n\tHoldefiInterface public holdefiContract;\r\n\r\n\t/// @notice Event emitted when market activation status is changed\r\n\tevent MarketActivationChanged(address indexed market, bool status);\r\n\r\n\t/// @notice Event emitted when collateral activation status is changed\r\n\tevent CollateralActivationChanged(address indexed collateral, bool status);\r\n\r\n\t/// @notice Event emitted when market existence status is changed\r\n\tevent MarketExistenceChanged(address indexed market, bool status);\r\n\r\n\t/// @notice Event emitted when collateral existence status is changed\r\n\tevent CollateralExistenceChanged(address indexed collateral, bool status);\r\n\r\n\t/// @notice Event emitted when market borrow rate is changed\r\n\tevent BorrowRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when market suppliers share rate is changed\r\n\tevent SuppliersShareRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when market promotion rate is changed\r\n\tevent PromotionRateChanged(address indexed market, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when collateral value to loan rate is changed\r\n\tevent ValueToLoanRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when collateral penalty rate is changed\r\n\tevent PenaltyRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\r\n\r\n\t/// @notice Event emitted when collateral bonus rate is changed\r\n\tevent BonusRateChanged(address indexed collateral, uint256 newRate, uint256 oldRate);\r\n\r\n\r\n\t/// @dev Modifier to make a function callable only when the market is exist\r\n\t/// @param market Address of the given market\r\n    modifier marketIsExist(address market) {\r\n        require (marketAssets[market].isExist, \"SE01\");\r\n        _;\r\n    }\r\n\r\n\t/// @dev Modifier to make a function callable only when the collateral is exist\r\n\t/// @param collateral Address of the given collateral\r\n    modifier collateralIsExist(address collateral) {\r\n        require (collateralAssets[collateral].isExist, \"SE02\");\r\n        _;\r\n    }\r\n\r\n\r\n\t/// @notice you cannot send ETH to this contract\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n \t/// @notice Activate a market asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\tfunction activateMarket (address market) external onlyOwner marketIsExist(market) {\r\n\t\tactivateMarketInternal(market);\r\n\t}\r\n\r\n\t/// @notice Deactivate a market asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\tfunction deactivateMarket (address market) external onlyOwner marketIsExist(market) {\r\n\t\tmarketAssets[market].isActive = false;\r\n\t\temit MarketActivationChanged(market, false);\r\n\t}\r\n\r\n\t/// @notice Activate a collateral asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address the given collateral\r\n\tfunction activateCollateral (address collateral) external onlyOwner collateralIsExist(collateral) {\r\n\t\tactivateCollateralInternal(collateral);\r\n\t}\r\n\r\n\t/// @notice Deactivate a collateral asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\tfunction deactivateCollateral (address collateral) external onlyOwner collateralIsExist(collateral) {\r\n\t\tcollateralAssets[collateral].isActive = false;\r\n\t\temit CollateralActivationChanged(collateral, false);\r\n\t}\r\n\r\n\t/// @notice Returns the list of markets\r\n\t/// @return res List of markets\r\n\tfunction getMarketsList() external view returns (address[] memory res) {\r\n\t\tres = marketsList;\r\n\t}\r\n\r\n\t/// @notice Disposable function to interact with Holdefi contract\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param holdefiContractAddress Address of the Holdefi contract\r\n\tfunction setHoldefiContract(HoldefiInterface holdefiContractAddress) external onlyOwner {\r\n\t\trequire (holdefiContractAddress.holdefiSettings() == address(this), \"SE03\");\r\n\t\trequire (address(holdefiContract) == address(0), \"SE04\");\r\n\t\tholdefiContract = holdefiContractAddress;\r\n\t}\r\n\r\n\t/// @notice Returns supply, borrow and promotion rate of the given market\r\n\t/// @dev supplyRate = (totalBorrow * borrowRate) * suppliersShareRate / totalSupply\r\n\t/// @param market Address of the given market\r\n\t/// @return borrowRate Borrow rate of the given market\r\n\t/// @return supplyRateBase Supply rate base of the given market\r\n\t/// @return promotionRate Promotion rate of the given market\r\n\tfunction getInterests (address market)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (uint256 borrowRate, uint256 supplyRateBase, uint256 promotionRate)\r\n\t{\r\n\t\tuint256 totalBorrow = holdefiContract.marketAssets(market).totalBorrow;\r\n\t\tuint256 totalSupply = holdefiContract.marketAssets(market).totalSupply;\r\n\t\tborrowRate = marketAssets[market].borrowRate;\r\n\r\n\t\tif (totalSupply == 0) {\r\n\t\t\tsupplyRateBase = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuint256 totalInterestFromBorrow = totalBorrow.mul(borrowRate);\r\n\t\t\tuint256 suppliersShare = totalInterestFromBorrow.mul(marketAssets[market].suppliersShareRate).div(rateDecimals);\r\n\t\t\tsupplyRateBase = suppliersShare.div(totalSupply);\r\n\t\t}\r\n\t\tpromotionRate = marketAssets[market].promotionRate;\r\n\t}\r\n\r\n\r\n\t/// @notice Set promotion rate for a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param newPromotionRate New promotion rate\r\n\tfunction setPromotionRate (address market, uint256 newPromotionRate) external onlyOwner {\r\n\t\trequire (newPromotionRate <= maxPromotionRate, \"SE05\");\r\n\r\n\t\tholdefiContract.reserveSettlement(market);\r\n\r\n\t\temit PromotionRateChanged(market, newPromotionRate, marketAssets[market].promotionRate);\r\n\t\tmarketAssets[market].promotionRate = newPromotionRate;\r\n\t}\r\n\r\n\t/// @notice Reset promotion rate of the market to zero\r\n\t/// @dev Can only be called by holdefi contract\r\n\t/// @param market Address of the given market\r\n\tfunction resetPromotionRate (address market) external {\r\n\t\trequire (msg.sender == address(holdefiContract), \"SE06\");\r\n\r\n\t\temit PromotionRateChanged(market, 0, marketAssets[market].promotionRate);\r\n\t\tmarketAssets[market].promotionRate = 0;\r\n\t}\r\n\r\n\t/// @notice Set borrow rate for a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param newBorrowRate New borrow rate\r\n\tfunction setBorrowRate (address market, uint256 newBorrowRate)\r\n\t\texternal \r\n\t\tonlyOwner\r\n\t\tmarketIsExist(market)\r\n\t{\r\n\t\tsetBorrowRateInternal(market, newBorrowRate);\r\n\t}\r\n\r\n\t/// @notice Set suppliers share rate for a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\t/// @param newSuppliersShareRate New suppliers share rate\r\n\tfunction setSuppliersShareRate (address market, uint256 newSuppliersShareRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tmarketIsExist(market)\r\n\t{\r\n\t\tsetSuppliersShareRateInternal(market, newSuppliersShareRate);\r\n\t}\r\n\r\n\t/// @notice Set value to loan rate for a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param newValueToLoanRate New value to loan rate\r\n\tfunction setValueToLoanRate (address collateral, uint256 newValueToLoanRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tcollateralIsExist(collateral)\r\n\t{\r\n\t\tsetValueToLoanRateInternal(collateral, newValueToLoanRate);\r\n\t}\r\n\r\n\t/// @notice Set penalty rate for a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param newPenaltyRate New penalty rate\r\n\tfunction setPenaltyRate (address collateral, uint256 newPenaltyRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tcollateralIsExist(collateral)\r\n\t{\r\n\t\tsetPenaltyRateInternal(collateral, newPenaltyRate);\r\n\t}\r\n\r\n\t/// @notice Set bonus rate for a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the given collateral\r\n\t/// @param newBonusRate New bonus rate\r\n\tfunction setBonusRate (address collateral, uint256 newBonusRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t\tcollateralIsExist(collateral)\r\n\t{\r\n\t\tsetBonusRateInternal(collateral, newBonusRate); \r\n\t}\r\n\r\n\t/// @notice Add a new asset as a market\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the new market\r\n\t/// @param borrowRate BorrowRate of the new market\r\n\t/// @param suppliersShareRate SuppliersShareRate of the new market\r\n\tfunction addMarket (address market, uint256 borrowRate, uint256 suppliersShareRate)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\trequire (!marketAssets[market].isExist, \"SE08\");\r\n\t\trequire (marketsList.length < maxListsLength, \"SE09\");\r\n\r\n\t\tmarketsList.push(market);\r\n\t\tmarketAssets[market].isExist = true;\r\n\t\temit MarketExistenceChanged(market, true);\r\n\r\n\t\tsetBorrowRateInternal(market, borrowRate);\r\n\t\tsetSuppliersShareRateInternal(market, suppliersShareRate);\r\n\t\t\r\n\t\tactivateMarketInternal(market);\t\t\r\n\t}\r\n\r\n\t/// @notice Remove a market asset\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param market Address of the given market\r\n\tfunction removeMarket (address market) external onlyOwner marketIsExist(market) {\r\n\t\trequire (holdefiContract.marketAssets(market).totalBorrow == 0, \"SE10\");\r\n\t\t\r\n\t\tholdefiContract.beforeChangeBorrowRate(market);\r\n\r\n\t\tuint256 index;\r\n\t\tuint256 marketListLength = marketsList.length;\r\n\t\tfor (uint256 i = 0 ; i < marketListLength ; i++) {\r\n\t\t\tif (marketsList[i] == market) {\r\n\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmarketsList[index] = marketsList[marketListLength-1];\r\n\t\tmarketsList.pop();\r\n\t\tdelete marketAssets[market];\r\n\t\temit MarketExistenceChanged(market, false);\r\n\t}\r\n\r\n\t/// @notice Add a new asset as a collateral\r\n\t/// @dev Can only be called by the owner\r\n\t/// @param collateral Address of the new collateral\r\n\t/// @param valueToLoanRate ValueToLoanRate of the new collateral\r\n\t/// @param penaltyRate PenaltyRate of the new collateral\r\n\t/// @param bonusRate BonusRate of the new collateral\r\n\tfunction addCollateral (\r\n\t\taddress collateral,\r\n\t\tuint256 valueToLoanRate,\r\n\t\tuint256 penaltyRate,\r\n\t\tuint256 bonusRate\r\n\t)\r\n\t\texternal\r\n\t\tonlyOwner\r\n\t{\r\n\t\trequire (!collateralAssets[collateral].isExist, \"SE07\");\r\n\r\n\t\tcollateralAssets[collateral].isExist = true;\r\n\t\temit CollateralExistenceChanged(collateral, true);\r\n\r\n\t\tsetValueToLoanRateInternal(collateral, valueToLoanRate);\r\n\t\tsetPenaltyRateInternal(collateral, penaltyRate);\r\n\t\tsetBonusRateInternal(collateral, bonusRate);\r\n\r\n\t\tactivateCollateralInternal(collateral);\r\n\t}\r\n\r\n\t/// @notice Activate the market\r\n\tfunction activateMarketInternal (address market) internal {\r\n\t\tmarketAssets[market].isActive = true;\r\n\t\temit MarketActivationChanged(market, true);\r\n\t}\r\n\r\n\t/// @notice Activate the collateral\r\n\tfunction activateCollateralInternal (address collateral) internal {\r\n\t\tcollateralAssets[collateral].isActive = true;\r\n\t\temit CollateralActivationChanged(collateral, true);\r\n\t}\r\n\r\n\t/// @notice Set borrow rate operation\r\n\tfunction setBorrowRateInternal (address market, uint256 newBorrowRate) internal {\r\n\t\trequire (newBorrowRate <= maxBorrowRate, \"SE05\");\r\n\t\tuint256 currentTime = block.timestamp;\r\n\r\n\t\tif (marketAssets[market].borrowRateUpdateTime != 0) {\r\n\t\t\tif (newBorrowRate > marketAssets[market].borrowRate) {\r\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].borrowRateUpdateTime);\r\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"SE11\");\r\n\r\n\t\t\t\tuint256 maxIncrease = marketAssets[market].borrowRate.add(borrowRateMaxIncrease);\r\n\t\t\t\trequire (newBorrowRate <= maxIncrease, \"SE12\");\r\n\t\t\t}\r\n\r\n\t\t\tholdefiContract.beforeChangeBorrowRate(market);\r\n\t\t}\r\n\r\n\t\temit BorrowRateChanged(market, newBorrowRate, marketAssets[market].borrowRate);\r\n\r\n\t\tmarketAssets[market].borrowRate = newBorrowRate;\r\n\t\tmarketAssets[market].borrowRateUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set suppliers share rate operation\r\n\tfunction setSuppliersShareRateInternal (address market, uint256 newSuppliersShareRate) internal {\r\n\t\trequire (\r\n\t\t\tnewSuppliersShareRate >= minSuppliersShareRate && newSuppliersShareRate <= rateDecimals,\r\n\t\t\t\"SE05\"\r\n\t\t);\r\n\t\tuint256 currentTime = block.timestamp;\r\n\r\n\t\tif (marketAssets[market].suppliersShareRateUpdateTime != 0) {\r\n\t\t\tif (newSuppliersShareRate < marketAssets[market].suppliersShareRate) {\r\n\t\t\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].suppliersShareRateUpdateTime);\r\n\t\t\t\trequire (deltaTime >= periodBetweenUpdates, \"SE11\");\r\n\r\n\t\t\t\tuint256 decreasedAllowed = newSuppliersShareRate.add(suppliersShareRateMaxDecrease);\r\n\t\t\t\trequire (\r\n\t\t\t\t\tmarketAssets[market].suppliersShareRate <= decreasedAllowed,\r\n\t\t\t\t\t\"SE12\"\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tholdefiContract.beforeChangeSupplyRate(market);\r\n\t\t}\r\n\r\n\t\temit SuppliersShareRateChanged(\r\n\t\t\tmarket,\r\n\t\t\tnewSuppliersShareRate,\r\n\t\t\tmarketAssets[market].suppliersShareRate\r\n\t\t);\r\n\r\n\t\tmarketAssets[market].suppliersShareRate = newSuppliersShareRate;\r\n\t\tmarketAssets[market].suppliersShareRateUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set value to loan rate operation\r\n\tfunction setValueToLoanRateInternal (address collateral, uint256 newValueToLoanRate) internal {\r\n\t\trequire (\r\n\t\t\tnewValueToLoanRate <= maxValueToLoanRate &&\r\n\t\t\tcollateralAssets[collateral].penaltyRate.add(fivePercentLiquidationGap) <= newValueToLoanRate,\r\n\t\t\t\"SE05\"\r\n\t\t);\r\n\t\t\r\n\t\tuint256 currentTime = block.timestamp;\r\n\t\tif (\r\n\t\t\tcollateralAssets[collateral].VTLUpdateTime != 0 &&\r\n\t\t\tnewValueToLoanRate > collateralAssets[collateral].valueToLoanRate\r\n\t\t) {\r\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].VTLUpdateTime);\r\n\t\t\trequire (deltaTime >= periodBetweenUpdates,\"SE11\");\r\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].valueToLoanRate.add(\r\n\t\t\t\tvalueToLoanRateMaxIncrease\r\n\t\t\t);\r\n\t\t\trequire (newValueToLoanRate <= maxIncrease,\"SE12\");\r\n\t\t}\r\n\t\temit ValueToLoanRateChanged(\r\n\t\t\tcollateral,\r\n\t\t\tnewValueToLoanRate,\r\n\t\t\tcollateralAssets[collateral].valueToLoanRate\r\n\t\t);\r\n\r\n\t    collateralAssets[collateral].valueToLoanRate = newValueToLoanRate;\r\n\t    collateralAssets[collateral].VTLUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set penalty rate operation\r\n\tfunction setPenaltyRateInternal (address collateral, uint256 newPenaltyRate) internal {\r\n\t\trequire (\r\n\t\t\tnewPenaltyRate <= maxPenaltyRate &&\r\n\t\t\tnewPenaltyRate <= collateralAssets[collateral].valueToLoanRate.sub(fivePercentLiquidationGap) &&\r\n\t\t\tcollateralAssets[collateral].bonusRate <= newPenaltyRate,\r\n\t\t\t\"SE05\"\r\n\t\t);\r\n\r\n\t\tuint256 currentTime = block.timestamp;\r\n\t\tif (\r\n\t\t\tcollateralAssets[collateral].penaltyUpdateTime != 0 &&\r\n\t\t\tnewPenaltyRate > collateralAssets[collateral].penaltyRate\r\n\t\t) {\r\n\t\t\tuint256 deltaTime = currentTime.sub(collateralAssets[collateral].penaltyUpdateTime);\r\n\t\t\trequire (deltaTime >= periodBetweenUpdates, \"SE11\");\r\n\t\t\tuint256 maxIncrease = collateralAssets[collateral].penaltyRate.add(penaltyRateMaxIncrease);\r\n\t\t\trequire (newPenaltyRate <= maxIncrease, \"SE12\");\r\n\t\t}\r\n\r\n\t\temit PenaltyRateChanged(collateral, newPenaltyRate, collateralAssets[collateral].penaltyRate);\r\n\r\n\t    collateralAssets[collateral].penaltyRate  = newPenaltyRate;\r\n\t    collateralAssets[collateral].penaltyUpdateTime = currentTime;\r\n\t}\r\n\r\n\t/// @notice Set Bonus rate operation\r\n\tfunction setBonusRateInternal (address collateral, uint256 newBonusRate) internal {\r\n\t\trequire (\r\n\t\t\tnewBonusRate <= collateralAssets[collateral].penaltyRate && newBonusRate >= rateDecimals,\r\n\t\t\t\"SE05\"\r\n\t\t);\r\n\t\t\r\n\t\temit BonusRateChanged(collateral, newBonusRate, collateralAssets[collateral].bonusRate);\r\n\t    collateralAssets[collateral].bonusRate = newBonusRate;    \r\n\t}\r\n}\r\n"},"HoldefiV1.1/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"}}}